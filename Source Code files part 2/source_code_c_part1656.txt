 CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxmapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    This file contains the prototypes, etc for the
    FAX mapi API.

Author:

    Wesley Witt (wesw) 7-Mar-1997

Environment:

    User Mode

--*/

#ifndef _FAXMAPI_
#define _FAXMAPI_

#ifdef __cplusplus
extern "C" {
#endif


typedef BOOL
(WINAPI *PFAXLOG)(
    IN DWORD Category,
    IN DWORD Level,
    IN DWORD StringCount,
    IN DWORD FormatId,
    IN ...
    );

typedef BOOL
(WINAPI *PSERVICEMESSAGEBOX)(
    IN LPCWSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    );



BOOL WINAPI
FaxMapiInitialize(
    IN HANDLE HeapHandle,
    IN PSERVICEMESSAGEBOX pServiceMessageBox,
    IN BOOL DebugService
    );

LPCWSTR WINAPI
GetProfileName(
    IN LPVOID ProfileInfo
    );

LPVOID WINAPI
AddNewMapiProfile(
    LPCWSTR ProfileName,
    BOOL UseMail,
    BOOL ShowPopUp
    );

BOOL WINAPI
StoreMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         MsgSenderNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    );

BOOL WINAPI
MailMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         RecipientNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    );

LONG WINAPI
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    );



typedef BOOL (WINAPI *PFAXMAPIINITIALIZE)         (VOID);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxisapi.h ===
#include "winfax.h"

//
// command codes
//

#define ICMD_CONNECT                0x80000001
#define ICMD_DISCONNECT             0x80000002
#define ICMD_ENUM_PORTS             0x80000003
#define ICMD_OPEN_PORT              0x80000004
#define ICMD_GET_PORT               0x80000006
#define ICMD_SET_PORT               0x80000007
#define ICMD_CLOSE                  0x80000008
#define ICMD_GET_ROUTINGINFO        0x80000009
#define ICMD_GET_DEVICE_STATUS      0x8000000a
#define ICMD_ENUM_ROUTING_METHODS   0x8000000b
#define ICMD_ENABLE_ROUTING_METHOD  0x8000000c
#define ICMD_GET_VERSION            0x8000000d

//
// packets
//

typedef struct _IFAX_CONNECT {
    DWORD   Command;
    WCHAR   ServerName[64];
} IFAX_CONNECT, *PIFAX_CONNECT;

typedef struct _IFAX_GENERAL {
    DWORD   Command;
    HANDLE  FaxHandle;
} IFAX_GENERAL, *PIFAX_GENERAL;

typedef struct _IFAX_OPEN_PORT {
    DWORD   Command;
    HANDLE  FaxHandle;
    DWORD   DeviceId;
    DWORD   Flags;
} IFAX_OPEN_PORT, *PIFAX_OPEN_PORT;

typedef struct _IFAX_SET_PORT {
    DWORD           Command;
    HANDLE          FaxPortHandle;
    FAX_PORT_INFOW  PortInfo;
} IFAX_SET_PORT, *PIFAX_SET_PORT;

typedef struct _IFAX_GET_ROUTINGINFO {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
} IFAX_GET_ROUTINGINFO, *PIFAX_GET_ROUTINGINFO;

typedef struct _IFAX_ENABLE_ROUTING_METHOD {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
    BOOL    Enabled;
} IFAX_ENABLE_ROUTING_METHOD, *PIFAX_ENABLE_ROUTING_METHOD;

typedef struct _IFAX_RESPONSE_HEADER {
    DWORD   Size;
    DWORD   ErrorCode;
} IFAX_RESPONSE_HEADER, *PIFAX_RESPONSE_HEADER;





typedef BOOL (WINAPI *PUNLOADINIT)(VOID);
typedef BOOL (WINAPI *PUNLOADER)(HMODULE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxcfg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcfg.h

Abstract:

    Public interface to the fax configuration DLL

Environment:

        Windows NT fax configuration applet

Revision History:

        05/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

Note:

    The fax configuration DLL is not thread-safe. Make sure you're not
    using it simultaneously from multiples of a single process.

--*/


#ifndef _FAXCFG_H_
#define _FAXCFG_H_


//
// Fax configuration types
//

#define FAXCONFIG_CLIENT        0
#define FAXCONFIG_SERVER        1
#define FAXCONFIG_WORKSTATION   2

//
// Initialize the fax configuration DLL
//
// Parameters:
//
//  pServerName - Specifies the name of the fax server machine.
//      Pass NULL for local machine.
//
// Return value:
//
//  -1 - An error has occurred
//  FAXCONFIG_CLIENT -
//  FAXCONFIG_SERVER -
//  FAXCONFIG_WORKSTATION - Indicates the type of configuration the user can run
//

INT
FaxConfigInit(
    LPTSTR  pServerName,
    BOOL    CplInit
    );

//
// De-initialize the fax configuration DLL
//
//  You should call this function after you're done using the
//  fax configuration DLL.
//

VOID
FaxConfigCleanup(
    VOID
    );

//
// Get an array of handles to client/server/workstation configuration pages
//
// Parameters:
//
//  phPropSheetPages - Specifies a buffer for storing property page handles
//  count - Specifies the maximum number of handles the input buffer can hold
//
// Return value:
//
//  -1 - An error has occurred
//  >0 - Total number of configuration pages available
//
// Note:
//
//  To figure out how large the input buffer should be, the caller can
//  first call these functions with phPropSheetPages set to NULL and
//  count set to 0.
//

INT
FaxConfigGetClientPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetServerPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetWorkstationPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

#endif  // !_FAXCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\jobtag.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jobtag.h

Abstract:

    Tags used in JOB_INFO_2.pParameters field for passing information
    about fax jobs through the print system to the fax service.

Environment:

        Windows NT fax driver

Revision History:

        06/03/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _JOBTAG_H_
#define _JOBTAG_H_

//
// Tags used to pass in fax job parameters - JOB_INFO_2.pParameters
//
//  JOB_INFO_2.pParameters field contains a tagged string of the form
//      <tag>value<tag>value
//
//  The format of tags is defined as:
//      <$FAXTAG$ tag-name>
//
//  There is exactly one space between the tag keyword and the tag name.
//  Characters in a tag are case-sensitive.
//
//  Currently only two tag names are defined:
//      REC#    recipient's phone number
//      RECNAME recipient's name
//      TSID    sending station identifier
//      SDRNAME sender's name
//      SDRCO   sender's company
//      SDRDEPT sender's department
//      BILL    billing code
//
//  If no recipient number tag is present, the entire string is used
//  as the recipient's fax number.
//

#define FAXTAG_PREFIX           TEXT("<$FAXTAG$ ")
#define FAXTAG_TSID             TEXT("<$FAXTAG$ TSID>")
#define FAXTAG_RECIPIENT_NUMBER TEXT("<$FAXTAG$ REC#>")
#define FAXTAG_RECIPIENT_NAME   TEXT("<$FAXTAG$ RECNAME>")
#define FAXTAG_SENDER_NAME      TEXT("<$FAXTAG$ SDRNAME>")
#define FAXTAG_SENDER_COMPANY   TEXT("<$FAXTAG$ SDRCO>")
#define FAXTAG_SENDER_DEPT      TEXT("<$FAXTAG$ SDRDEPT>")
#define FAXTAG_BILLING_CODE     TEXT("<$FAXTAG$ BILL>")
#define FAXTAG_SEND_RETRY       TEXT("<$FAXTAG$ SENDRETRY>")
#define FAXTAG_ROUTE_FILE       TEXT("<$FAXTAG$ ROUTEFILE>")
#define FAXTAG_PROFILE_NAME     TEXT("<$FAXTAG$ PROFILENAME>")
#define FAXTAG_EMAIL_NAME       TEXT("<$FAXTAG$ EMAILNAME>")
#define FAXTAG_DOWNLEVEL_CLIENT TEXT("<$FAXTAG$ DOWNLEVEL>")
#define FAXTAG_WHEN_TO_SEND     TEXT("<$FAXTAG$ WHENTOSEND>")  // string == "cheap" | "at"
#define FAXTAG_SEND_AT_TIME     TEXT("<$FAXTAG$ SENDATTIME>")  // string == "hh:mm"

#endif  // !_JOBTAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxwiz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxwiz.h

Abstract:

    This file defines the fax setup wizard api.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;

//
// install modes
//

#define INSTALL_NEW                 0x00000001
#define INSTALL_UPGRADE             0x00000002
#define INSTALL_DRIVERS             0x00000004
#define INSTALL_REMOVE              0x00000008
#define INSTALL_UNATTENDED          0x00000010


BOOL WINAPI
FaxWizInit(
    VOID
    );

DWORD
WINAPI
FaxWizGetError(
    VOID
    );

VOID
WINAPI
FaxWizSetInstallMode(
    DWORD RequestedInstallMode,
    DWORD RequestedInstallType,
    LPWSTR AnswerFile
    );

BOOL WINAPI
FaxWizPointPrint(
    LPTSTR DirectoryName,
    LPTSTR PrinterName
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetServerPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetWorkstationPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetClientPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetPointPrintPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizRemoteAdminPages(
    LPDWORD PageCount
    );

PFNPROPSHEETCALLBACK WINAPI
FaxWizGetPropertySheetCallback(
    VOID
    );

//
// Function pointer types used when the client doesn't
// statically link to faxwiz.dll.
//

typedef BOOL (WINAPI *LPFAXWIZINIT)(VOID);
typedef DWORD (WINAPI *LPFAXWIZGETERROR)(VOID);
typedef BOOL (WINAPI*LPFAXWIZPOINTPRINT)(LPTSTR, LPTSTR);
typedef LPHPROPSHEETPAGE (WINAPI *LPFAXWIZGETPOINTPRINTPAGES)(LPDWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file defines the debugging interfaces
    available to the FAX compoments.

Author:

    Wesley Witt (wesw) 22-Dec-1995

Environment:

    User Mode

--*/


#ifndef _FAXUTIL_
#define _FAXUTIL_

#ifdef __cplusplus
extern "C" {
#endif

#define OffsetToString( Offset, Buffer ) ((Offset) ? (LPTSTR) ((Buffer) + ((ULONG_PTR) Offset)) : NULL)
#define StringSize(_s)              (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)
#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null

#define FAXBITS     1728
#define FAXBYTES    (FAXBITS/BYTEBITS)

#define MAXHORZBITS FAXBITS
#define MAXVERTBITS 3000        // 14inches plus

#define MINUTES_PER_HOUR    60
#define MINUTES_PER_DAY     (24 * 60)

#define SECONDS_PER_MINUTE  60
#define SECONDS_PER_HOUR    (SECONDS_PER_MINUTE * MINUTES_PER_HOUR)
#define SECONDS_PER_DAY     (MINUTES_PER_DAY * SECONDS_PER_MINUTE)

#define FILETIMETICKS_PER_SECOND    10000000    // 100 nanoseconds / second
#define FILETIMETICKS_PER_DAY       ((LONGLONG) FILETIMETICKS_PER_SECOND * (LONGLONG) SECONDS_PER_DAY)
#define MILLISECONDS_PER_SECOND     1000

#ifndef MAKELONGLONG
#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))
#endif

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

#define DWord2FaxTime(pFaxTime, dwValue) (pFaxTime)->hour = LOWORD(dwValue), (pFaxTime)->minute = HIWORD(dwValue)
#define FaxTime2DWord(pFaxTime) MAKELONG((pFaxTime)->hour, (pFaxTime)->minute)

#define EMPTY_STRING    L""

#define IsSmallBiz()        (ValidateProductSuite( VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED))
#define IsCommServer()      (ValidateProductSuite( VER_SUITE_COMMUNICATIONS ))
#define IsProductSuite()    (ValidateProductSuite( VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED | VER_SUITE_COMMUNICATIONS ))

typedef GUID *PGUID;

//
// debugging information
//

#ifndef FAXUTIL_DEBUG

#if DBG

#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     dprintf _x_

#define DebugStop(_x_)      {\
                                dprintf _x_;\
                                dprintf(TEXT("Stopping at %s @ %d"),TEXT(__FILE__),__LINE__);\
                                __try {\
                                    DebugBreak();\
                                } __except (UnhandledExceptionFilter(GetExceptionInformation())) {\
                                }\
                            }

#else

#define Assert(exp)
#define DebugPrint(_x_)
#define DebugStop(_x_)

#endif

extern BOOL ConsoleDebugOutput;

void
dprintf(
    LPCTSTR Format,
    ...
    );

VOID
AssertError(
    LPCTSTR Expression,
    LPCTSTR File,
    ULONG  LineNumber
    );

#endif

//
// list management
//

#ifndef NO_FAX_LIST

#define InitializeListHead(ListHead) {\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead);\
    Assert((ListHead)->Flink && (ListHead)->Blink);\
    }

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    Assert((Entry)->Blink  && (Entry)->Flink);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define RemoveHeadList(ListHead) \
    Assert((ListHead)->Flink);\
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#endif

//
// memory allocation
//

#ifndef FAXUTIL_MEM

#define HEAP_SIZE   (1024*1024)

#ifdef FAX_HEAP_DEBUG
#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    ULONG       Size;
    ULONG       Line;
#ifdef UNICODE
    WCHAR       File[22];
#else
    CHAR        File[20];
#endif
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)          pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(d,s)      pMemReAlloc(d,s,__LINE__,__FILE__)
#define MemFree(p)           pMemFree(p,__LINE__,__FILE__)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p,__LINE__,__FILE__)
#define CheckHeap(p)         pCheckHeap(p,__LINE__,__FILE__)
#else
#define MemAlloc(s)          pMemAlloc(s)
#define MemReAlloc(d,s)      pMemReAlloc(d,s)
#define MemFree(p)           pMemFree(p)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p)
#define CheckHeap(p)
#endif

typedef LPVOID (WINAPI *PMEMALLOC)   (DWORD);
typedef LPVOID (WINAPI *PMEMREALLOC) (LPVOID,DWORD);
typedef VOID   (WINAPI *PMEMFREE)  (LPVOID);

#define HEAPINIT_NO_VALIDATION      0x00000001
#define HEAPINIT_NO_STRINGS         0x00000002


HANDLE
HeapInitialize(
    HANDLE hHeap,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    DWORD Flags
    );

BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    );

BOOL
HeapCleanup(
    VOID
    );

#ifdef FAX_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );

VOID
PrintAllocations(
    VOID
    );

#else

#define PrintAllocations()

#endif

PVOID
pMemAlloc(
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID dest,
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

#endif

//
// file functions
//

#ifndef FAXUTIL_FILE

typedef struct _FILE_MAPPING {
    HANDLE  hFile;
    HANDLE  hMap;
    LPBYTE  fPtr;
    DWORD   fSize;
} FILE_MAPPING, *PFILE_MAPPING;

BOOL
MapFileOpen(
    LPTSTR FileName,
    BOOL ReadOnly,
    DWORD ExtendBytes,
    PFILE_MAPPING FileMapping
    );

VOID
MapFileClose(
    PFILE_MAPPING FileMapping,
    DWORD TrimOffset
    );

#endif

//
// printer functions
//

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    );

//
// string functions
//

#ifndef FAXUTIL_STRING

LPTSTR
StringDup(
    LPCTSTR String
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

VOID
FreeString(
    LPVOID String
    );

VOID
MakeDirectory(
    LPCTSTR Dir
    );

VOID
DeleteDirectory(
    LPTSTR Dir
    );

VOID
HideDirectory(
    LPTSTR Dir
    );

LPTSTR
ConcatenatePaths(
    LPTSTR Path,
    LPCTSTR Append
    );


int 
MyLoadString(
    HINSTANCE  hInstance,
    UINT       uID,
    LPTSTR     lpBuffer,
    int        nBufferMax,
    LANGID     LangID
    );

VOID
ConsoleDebugPrint(
    LPCTSTR buf
    );

int
FormatElapsedTimeStr(
    FILETIME *ElapsedTime,
    LPTSTR TimeStr,
    DWORD StringSize
    );

LPTSTR
ExpandEnvironmentString(
    LPCTSTR EnvString
    );

LPTSTR
GetEnvVariable(
    LPCTSTR EnvString
    );

#endif

//
// product suite functions
//

#ifndef FAXUTIL_SUITE

BOOL
ValidateProductSuite(
    WORD Mask
    );

DWORD
GetProductType(
    VOID
    );

#endif

//
// registry functions
//

#ifndef FAXUTIL_REG

typedef BOOL (WINAPI *PREGENUMCALLBACK) (HKEY,LPTSTR,DWORD,LPVOID);

HKEY
OpenRegistryKey(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    );

//
// caution!!! this is a recursive delete function !!!
//
BOOL
DeleteRegistryKey(
    HKEY hKey,
    LPCTSTR SubKey
    );

DWORD
EnumerateRegistryKeys(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL ChangeValues,
    PREGENUMCALLBACK EnumCallback,
    LPVOID ContextData
    );

LPTSTR
GetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    );

DWORD
GetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName
    );

LPBYTE
GetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD DataSize
    );

DWORD
GetSubKeyCount(
    HKEY hKey
    );

DWORD
GetMaxSubKeyLen(
    HKEY hKey
    );

BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName,
    DWORD Value
    );

BOOL
SetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    const LPBYTE Value,
    LONG Length
    );

BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value,
    DWORD Length
    );

#endif

//
// shortcut routines
//

#ifndef FAXUTIL_SHORTCUT

BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

BOOL
CreateShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

BOOL
IsCoverPageShortcut(
    LPCTSTR  pLinkName
    );

BOOL
GetServerCpDir(
    LPCTSTR ServerName OPTIONAL,
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
GetClientCpDir(
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
GetSpecialPath(
    int Id,
    LPTSTR DirBuffer
    );

#endif

//
// fax adaptive answer modem routines
//

#ifndef FAXUTIL_ADAPTIVE

#include <setupapi.h>

LPVOID
InitializeAdaptiveAnswerList(
    HINF hInf
    );

BOOL
IsModemAdaptiveAnswer(
    LPVOID ModemList,
    LPCTSTR ModemId
    );

#endif


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//
//  This was borrowed from fatprocs.h

#ifdef DBG
#define try_fail(S) { DebugPrint(( TEXT("Failure in FILE %s LINE %d"), TEXT(__FILE__), __LINE__ )); S; goto try_exit; }
#else
#define try_fail(S) { S; goto try_exit; }
#endif

#define try_return(S) { S; goto try_exit; }
#define NOTHING

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\winres.h ===
//
// this header file is necessay because
// of vc.  it insists on including
// a file named winres.h in it's generated
// rc file.  the problem is that winres.h
// is a non-standard header file that
// exists only in a vc install.
//

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\warning.h ===
#pragma warning(3:4101)         // Unreferenced local variable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxitg.rc
//
#define IDS_PROJNAME                    100
#define IDR_FAXQUEUE                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\faxitg.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the dll exports from this
    control(s).

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "faxitg.h"

#include "faxitg_i.c"
#include "FaxQueue.h"


CComModule _Module;
WCHAR g_ClientDir[MAX_PATH*2];
WSADATA g_WsaData;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FaxQueue, CFaxQueue)
END_OBJECT_MAP()


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        if (WSAStartup( 0x0101, &g_WsaData ) != 0) {
            return FALSE;
        }
        ExpandEnvironmentStrings( L"%windir%\\itg\\", g_ClientDir, sizeof(g_ClientDir)/sizeof(WCHAR) );
        CreateDirectory( g_ClientDir, NULL );
    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }

    return TRUE;
}


STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\faxqueue.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxqueue.h

Abstract:

    This file contains the class definition for the
    faxqueue object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXQUEUE_H_
#define __FAXQUEUE_H_

#include <winsock2.h>
#include "resource.h"       // main symbols

class ATL_NO_VTABLE CFaxQueue :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxQueue, &CLSID_FaxQueue>,
    public IDispatchImpl<IFaxQueue, &IID_IFaxQueue, &LIBID_FAXITGLib>
{
public:
        CFaxQueue();
        ~CFaxQueue();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXQUEUE)

BEGIN_COM_MAP(CFaxQueue)
        COM_INTERFACE_ENTRY(IFaxQueue)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(put_Connect)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_GetNextFax)(/*[out, retval]*/ BSTR *pVal);

private:
    IN_ADDR m_RemoteIpAddress;
    SOCKET  m_Socket;
    WCHAR   m_ServerDir[MAX_COMPUTERNAME_LENGTH+16];

};

#endif //__FAXQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\faxqueue.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the FaxQueue object.
    The purpose of this object is to gain access
    to the fax service's fax queue and retrieve
    a received fax from the queue.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxitg.h"
#include "faxqueue.h"
#include "faxsvr.h"

extern WCHAR g_ClientDir[MAX_PATH*2];


CFaxQueue::CFaxQueue()
{
}


CFaxQueue::~CFaxQueue()
{
}


STDMETHODIMP CFaxQueue::get_GetNextFax(BSTR * pVal)
{
    INT Bytes;
    FAX_QUEUE_MESSAGE Msg;
    LPWSTR FileName;
    WCHAR SrcName[MAX_PATH];
    WCHAR DstName[MAX_PATH];


    //
    // request the next avail fax
    //

    Msg.Request = REQ_NEXT_FAX;

    Bytes = send( m_Socket, (char*)&Msg, sizeof(Msg), 0 );
    if (Bytes == SOCKET_ERROR) {
        return E_FAIL;
    }

    //
    // receive the file name
    //

    Bytes = recv( m_Socket, (char*)&Msg, sizeof(Msg), 0 );
    if (Bytes == SOCKET_ERROR) {
        return E_FAIL;
    }

    FileName = (LPWSTR) Msg.Buffer;

    if (FileName[0] == 0 || Msg.Response != RSP_GOOD) {
        return E_FAIL;
    }

    //
    // copy the file from the server
    //

    wcscpy( SrcName, m_ServerDir );
    wcscat( SrcName, FileName );

    wcscpy( DstName, g_ClientDir );
    wcscat( DstName, FileName );

    if (CopyFile( SrcName, DstName, FALSE )) {
        Msg.Response = 1;
    } else {
        Msg.Response = 0;
    }

    Msg.Request = REQ_ACK;

    //
    // send our response
    //

    Bytes = send( m_Socket, (char*)&Msg, sizeof(Msg), 0 );
    if (Bytes == SOCKET_ERROR) {
        return E_FAIL;
    }

    *pVal = SysAllocString( FileName );
    if (*pVal == NULL) {
        return E_FAIL;
    }

    return S_OK;
}


STDMETHODIMP CFaxQueue::put_Connect(BSTR ServerName)
{
    PHOSTENT Host;
    SOCKADDR_IN cli_addr;
    CHAR ServerNameA[MAX_COMPUTERNAME_LENGTH];
    DWORD Size;



    Size = WideCharToMultiByte(
        CP_ACP,
        0,
        ServerName,
        -1,
        ServerNameA,
        sizeof(ServerNameA),
        NULL,
        NULL
        );
    if (Size == 0) {
        return E_FAIL;
    }

    Host = gethostbyname( ServerNameA );
    if (Host == NULL || *Host->h_addr_list == NULL) {
        return E_FAIL;
    }

    CopyMemory ((char *) &m_RemoteIpAddress, Host->h_addr, Host->h_length);

    //
    // set up client socket
    //

    m_Socket = socket( PF_INET, SOCK_STREAM, 0 );
    if (m_Socket == INVALID_SOCKET){
        return E_FAIL;
    }

    //
    // connect to the server
    //

    ZeroMemory( &cli_addr, sizeof(cli_addr) );

    cli_addr.sin_family       = AF_INET;
    cli_addr.sin_port         = htons( SERVICE_PORT );
    cli_addr.sin_addr         = m_RemoteIpAddress;

    if (connect( m_Socket, (LPSOCKADDR)&cli_addr, sizeof(cli_addr) ) == SOCKET_ERROR){
        return E_FAIL;
    }

    //
    // create the server dir name
    //

    wcscpy( m_ServerDir, L"\\\\" );
    wcscat( m_ServerDir, ServerName );
    wcscat( m_ServerDir, L"\\itg\\" );

    //
    // return success
    //

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\stdafx.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file contains the static support code for the
    atl controls in this project.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\tiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff.h

Abstract:

    This file the data structures and constant
    definitions for the TIFF file format.
    See the TIFF specification Revision 6.0,
    dated 6-3-92, from Adobe for specific details.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFF_
#define _TIFF_

#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

#pragma pack(1)

typedef struct _TIFF_HEADER {
    WORD        Identifier;
    WORD        Version;
    DWORD       IFDOffset;
} TIFF_HEADER, *PTIFF_HEADER;

//
// TIFF Image File Directories are comprised of
// a table of field descriptors of the form shown
// below.  The table is sorted in ascending order
// by tag.  The values associated with each entry
// are disjoint and may appear anywhere in the file
// (so long as they are placed on a word boundary).
//
// If the value is 4 bytes or less, then it is placed
// in the offset field to save space.  If the value
// is less than 4 bytes, it is left-justified in the
// offset field.
//
typedef struct _TIFF_TAG {
    WORD        TagId;
    WORD        DataType;
    DWORD       DataCount;
    DWORD       DataOffset;
} TIFF_TAG;

typedef TIFF_TAG UNALIGNED *PTIFF_TAG;

typedef struct TIFF_IFD {
    WORD        wEntries;
    TIFF_TAG    ifdEntries[1];
} TIFF_IFD;

typedef TIFF_IFD UNALIGNED *PTIFF_IFD;


#pragma pack()


//
// NB: In the comments below,
//  - items marked with a + are obsoleted by revision 5.0,
//  - items marked with a ! are introduced in revision 6.0.
//  - items marked with a % are introduced post revision 6.0.
//  - items marked with a $ are obsoleted by revision 6.0.
//

//
// Tag data type information.
//
#define TIFF_NOTYPE                     0       // placeholder
#define TIFF_BYTE                       1       // 8-bit unsigned integer
#define TIFF_ASCII                      2       // 8-bit bytes w/ last byte null
#define TIFF_SHORT                      3       // 16-bit unsigned integer
#define TIFF_LONG                       4       // 32-bit unsigned integer
#define TIFF_RATIONAL                   5       // 64-bit unsigned fraction
#define TIFF_SBYTE                      6       // !8-bit signed integer
#define TIFF_UNDEFINED                  7       // !8-bit untyped data
#define TIFF_SSHORT                     8       // !16-bit signed integer
#define TIFF_SLONG                      9       // !32-bit signed integer
#define TIFF_SRATIONAL                  10      // !64-bit signed fraction
#define TIFF_FLOAT                      11      // !32-bit IEEE floating point
#define TIFF_DOUBLE                     12      // !64-bit IEEE floating point

//
// TIFF Tag Definitions.
//
#define TIFFTAG_SUBFILETYPE             254     // subfile data descriptor
#define     FILETYPE_REDUCEDIMAGE       0x1     // reduced resolution version
#define     FILETYPE_PAGE               0x2     // one page of many
#define     FILETYPE_MASK               0x4     // transparency mask
#define TIFFTAG_OSUBFILETYPE            255     // +kind of data in subfile
#define     OFILETYPE_IMAGE             1       // full resolution image data
#define     OFILETYPE_REDUCEDIMAGE      2       // reduced size image data
#define     OFILETYPE_PAGE              3       // one page of many
#define TIFFTAG_IMAGEWIDTH              256     // image width in pixels
#define TIFFTAG_IMAGELENGTH             257     // image height in pixels
#define TIFFTAG_BITSPERSAMPLE           258     // bits per channel (sample)
#define TIFFTAG_COMPRESSION             259     // data compression technique
#define     COMPRESSION_NONE            1       // dump mode
#define     COMPRESSION_CCITTRLE        2       // CCITT modified Huffman RLE
#define     COMPRESSION_CCITTFAX3       3       // CCITT Group 3 fax encoding
#define     COMPRESSION_CCITTFAX4       4       // CCITT Group 4 fax encoding
#define     COMPRESSION_LZW             5       // Lempel-Ziv  & Welch
#define     COMPRESSION_OJPEG           6       // !6.0 JPEG
#define     COMPRESSION_JPEG            7       // %JPEG DCT compression
#define     COMPRESSION_NEXT            32766   // NeXT 2-bit RLE
#define     COMPRESSION_CCITTRLEW       32771   // #1 w/ word alignment
#define     COMPRESSION_PACKBITS        32773   // Macintosh RLE
#define     COMPRESSION_THUNDERSCAN     32809   // ThunderScan RLE
//
// compression codes 32908-32911 are reserved for Pixar
//
#define     COMPRESSION_PIXARFILM       32908   // Pixar companded 10bit LZW
#define     COMPRESSION_DEFLATE         32946   // Deflate compression
#define     COMPRESSION_JBIG            34661   // ISO JBIG
#define TIFFTAG_PHOTOMETRIC             262     // photometric interpretation
#define     PHOTOMETRIC_MINISWHITE      0       // min value is white
#define     PHOTOMETRIC_MINISBLACK      1       // min value is black
#define     PHOTOMETRIC_RGB             2       // RGB color model
#define     PHOTOMETRIC_PALETTE         3       // color map indexed
#define     PHOTOMETRIC_MASK            4       // $holdout mask
#define     PHOTOMETRIC_SEPARATED       5       // !color separations
#define     PHOTOMETRIC_YCBCR           6       // !CCIR 601
#define     PHOTOMETRIC_CIELAB          8       // !1976 CIE L*a*b*
#define TIFFTAG_THRESHHOLDING           263     // +thresholding used on data
#define     THRESHHOLD_BILEVEL          1       // b&w art scan
#define     THRESHHOLD_HALFTONE         2       // or dithered scan
#define     THRESHHOLD_ERRORDIFFUSE     3       // usually floyd-steinberg
#define TIFFTAG_CELLWIDTH               264     // +dithering matrix width
#define TIFFTAG_CELLLENGTH              265     // +dithering matrix height
#define TIFFTAG_FILLORDER               266     // data order within a byte
#define     FILLORDER_MSB2LSB           1       // most significant -> least
#define     FILLORDER_LSB2MSB           2       // least significant -> most
#define TIFFTAG_DOCUMENTNAME            269     // name of doc. image is from
#define TIFFTAG_IMAGEDESCRIPTION        270     // info about image
#define TIFFTAG_MAKE                    271     // scanner manufacturer name
#define TIFFTAG_MODEL                   272     // scanner model name/number
#define TIFFTAG_STRIPOFFSETS            273     // offsets to data strips
#define TIFFTAG_ORIENTATION             274     // +image orientation
#define     ORIENTATION_TOPLEFT         1       // row 0 top, col 0 lhs
#define     ORIENTATION_TOPRIGHT        2       // row 0 top, col 0 rhs
#define     ORIENTATION_BOTRIGHT        3       // row 0 bottom, col 0 rhs
#define     ORIENTATION_BOTLEFT         4       // row 0 bottom, col 0 lhs
#define     ORIENTATION_LEFTTOP         5       // row 0 lhs, col 0 top
#define     ORIENTATION_RIGHTTOP        6       // row 0 rhs, col 0 top
#define     ORIENTATION_RIGHTBOT        7       // row 0 rhs, col 0 bottom
#define     ORIENTATION_LEFTBOT         8       // row 0 lhs, col 0 bottom
#define TIFFTAG_SAMPLESPERPIXEL         277     // samples per pixel
#define TIFFTAG_ROWSPERSTRIP            278     // rows per strip of data
#define TIFFTAG_STRIPBYTECOUNTS         279     // bytes counts for strips
#define TIFFTAG_MINSAMPLEVALUE          280     // +minimum sample value
#define TIFFTAG_MAXSAMPLEVALUE          281     // +maximum sample value
#define TIFFTAG_XRESOLUTION             282     // pixels/resolution in x
#define TIFFTAG_YRESOLUTION             283     // pixels/resolution in y
#define TIFFTAG_PLANARCONFIG            284     // storage organization
#define     PLANARCONFIG_CONTIG         1       // single image plane
#define     PLANARCONFIG_SEPARATE       2       // separate planes of data
#define TIFFTAG_PAGENAME                285     // page name image is from
#define TIFFTAG_XPOSITION               286     // x page offset of image lhs
#define TIFFTAG_YPOSITION               287     // y page offset of image lhs
#define TIFFTAG_FREEOFFSETS             288     // +byte offset to free block
#define TIFFTAG_FREEBYTECOUNTS          289     // +sizes of free blocks
#define TIFFTAG_GRAYRESPONSEUNIT        290     // $gray scale curve accuracy
#define     GRAYRESPONSEUNIT_10S        1       // tenths of a unit
#define     GRAYRESPONSEUNIT_100S       2       // hundredths of a unit
#define     GRAYRESPONSEUNIT_1000S      3       // thousandths of a unit
#define     GRAYRESPONSEUNIT_10000S     4       // ten-thousandths of a unit
#define     GRAYRESPONSEUNIT_100000S    5       // hundred-thousandths
#define TIFFTAG_GRAYRESPONSECURVE       291     // $gray scale response curve
#define TIFFTAG_GROUP3OPTIONS           292     // 32 flag bits
#define     GROUP3OPT_2DENCODING        0x1     // 2-dimensional coding
#define     GROUP3OPT_UNCOMPRESSED      0x2     // data not compressed
#define     GROUP3OPT_FILLBITS          0x4     // fill to byte boundary
#define TIFFTAG_GROUP4OPTIONS           293     // 32 flag bits
#define     GROUP4OPT_UNCOMPRESSED      0x2     // data not compressed
#define TIFFTAG_RESOLUTIONUNIT          296     // units of resolutions
#define     RESUNIT_NONE                1       // no meaningful units
#define     RESUNIT_INCH                2       // english
#define     RESUNIT_CENTIMETER          3       // metric
#define TIFFTAG_PAGENUMBER              297     // page numbers of multi-page
#define TIFFTAG_COLORRESPONSEUNIT       300     // $color curve accuracy
#define     COLORRESPONSEUNIT_10S       1       // tenths of a unit
#define     COLORRESPONSEUNIT_100S      2       // hundredths of a unit
#define     COLORRESPONSEUNIT_1000S     3       // thousandths of a unit
#define     COLORRESPONSEUNIT_10000S    4       // ten-thousandths of a unit
#define     COLORRESPONSEUNIT_100000S   5       // hundred-thousandths
#define TIFFTAG_TRANSFERFUNCTION        301     // !colorimetry info
#define TIFFTAG_SOFTWARE                305     // name & release
#define TIFFTAG_DATETIME                306     // creation date and time
#define TIFFTAG_ARTIST                  315     // creator of image
#define TIFFTAG_HOSTCOMPUTER            316     // machine where created
#define TIFFTAG_PREDICTOR               317     // prediction scheme w/ LZW
#define TIFFTAG_WHITEPOINT              318     // image white point
#define TIFFTAG_PRIMARYCHROMATICITIES   319     // !primary chromaticities
#define TIFFTAG_COLORMAP                320     // RGB map for pallette image
#define TIFFTAG_HALFTONEHINTS           321     // !highlight+shadow info
#define TIFFTAG_TILEWIDTH               322     // !rows/data tile
#define TIFFTAG_TILELENGTH              323     // !cols/data tile
#define TIFFTAG_TILEOFFSETS             324     // !offsets to data tiles
#define TIFFTAG_TILEBYTECOUNTS          325     // !byte counts for tiles
#define TIFFTAG_BADFAXLINES             326     // lines w/ wrong pixel count
#define TIFFTAG_CLEANFAXDATA            327     // regenerated line info
#define     CLEANFAXDATA_CLEAN          0       // no errors detected
#define     CLEANFAXDATA_REGENERATED    1       // receiver regenerated lines
#define     CLEANFAXDATA_UNCLEAN        2       // uncorrected errors exist
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     // max consecutive bad lines
#define TIFFTAG_SUBIFD                  330     // subimage descriptors
#define TIFFTAG_INKSET                  332     // !inks in separated image
#define     INKSET_CMYK                 1       // !cyan-magenta-yellow-black
#define TIFFTAG_INKNAMES                333     // !ascii names of inks
#define TIFFTAG_DOTRANGE                336     // !0% and 100% dot codes
#define TIFFTAG_TARGETPRINTER           337     // !separation target
#define TIFFTAG_EXTRASAMPLES            338     // !info about extra samples
#define     EXTRASAMPLE_UNSPECIFIED     0       // !unspecified data
#define     EXTRASAMPLE_ASSOCALPHA      1       // !associated alpha data
#define     EXTRASAMPLE_UNASSALPHA      2       // !unassociated alpha data
#define TIFFTAG_SAMPLEFORMAT            339     // !data sample format
#define     SAMPLEFORMAT_UINT           1       // !unsigned integer data
#define     SAMPLEFORMAT_INT            2       // !signed integer data
#define     SAMPLEFORMAT_IEEEFP         3       // !IEEE floating point data
#define     SAMPLEFORMAT_VOID           4       // !untyped data
#define TIFFTAG_SMINSAMPLEVALUE         340     // !variable MinSampleValue
#define TIFFTAG_SMAXSAMPLEVALUE         341     // !variable MaxSampleValue
#define TIFFTAG_JPEGTABLES              347     // %JPEG table stream
//
// Tags 512-521 are obsoleted by Technical Note #2
// which specifies a revised JPEG-in-TIFF scheme.
//
#define TIFFTAG_JPEGPROC                512     // !JPEG processing algorithm
#define     JPEGPROC_BASELINE           1       // !baseline sequential
#define     JPEGPROC_LOSSLESS           14      // !Huffman coded lossless
#define TIFFTAG_JPEGIFOFFSET            513     // !pointer to SOI marker
#define TIFFTAG_JPEGIFBYTECOUNT         514     // !JFIF stream length
#define TIFFTAG_JPEGRESTARTINTERVAL     515     // !restart interval length
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     // !lossless proc predictor
#define TIFFTAG_JPEGPOINTTRANSFORM      518     // !lossless point transform
#define TIFFTAG_JPEGQTABLES             519     // !Q matrice offsets
#define TIFFTAG_JPEGDCTABLES            520     // !DCT table offsets
#define TIFFTAG_JPEGACTABLES            521     // !AC coefficient offsets
#define TIFFTAG_YCBCRCOEFFICIENTS       529     // !RGB -> YCbCr transform
#define TIFFTAG_YCBCRSUBSAMPLING        530     // !YCbCr subsampling factors
#define TIFFTAG_YCBCRPOSITIONING        531     // !subsample positioning
#define     YCBCRPOSITION_CENTERED      1       // !as in PostScript Level 2
#define     YCBCRPOSITION_COSITED       2       // !as in CCIR 601-1
#define TIFFTAG_REFERENCEBLACKWHITE     532     // !colorimetry info
//
// tags 32952-32956 are private tags registered to Island Graphics
//
#define TIFFTAG_REFPTS                  32953   // image reference points
#define TIFFTAG_REGIONTACKPOINT         32954   // region-xform tack point
#define TIFFTAG_REGIONWARPCORNERS       32955   // warp quadrilateral
#define TIFFTAG_REGIONAFFINE            32956   // affine transformation mat
//
// tags 32995-32999 are private tags registered to SGI
//
#define TIFFTAG_MATTEING                32995   // $use ExtraSamples
#define TIFFTAG_DATATYPE                32996   // $use SampleFormat
#define TIFFTAG_IMAGEDEPTH              32997   // z depth of image
#define TIFFTAG_TILEDEPTH               32998   // z depth/data tile
//
// tags 33300-33309 are private tags registered to Pixar
//
// TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
// are set when an image has been cropped out of a larger image.
// They reflect the size of the original uncropped image.
// The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
// to determine the position of the smaller image in the larger one.
//
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   // full image size in x
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   // full image size in y
//
// tag 33432 is listed in the 6.0 spec w/ unknown ownership
//
#define TIFFTAG_COPYRIGHT               33432   // copyright string
//
// tags 34232-34236 are private tags registered to Texas Instruments
//
#define TIFFTAG_FRAMECOUNT              34232   // Sequence Frame Count
//
// tag 34750 is a private tag registered to Pixel Magic
//
#define TIFFTAG_JBIGOPTIONS             34750   // JBIG options
//
// tags 34908-34914 are private tags registered to SGI
//
#define TIFFTAG_FAXRECVPARAMS           34908   // encoded Class 2 ses. parms
#define TIFFTAG_FAXSUBADDRESS           34909   // received SubAddr string
#define TIFFTAG_FAXRECVTIME             34910   // receive time (secs)
//
// tags 40001-40100 are private tags registered to ms
//
#define TIFFTAG_RECIP_NAME              40001
#define TIFFTAG_RECIP_NUMBER            40002
#define TIFFTAG_SENDER_NAME             40003
#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005
#define TIFFTAG_TSID                    40006
#define TIFFTAG_CSID                    40007
#define TIFFTAG_FAX_TIME                40008
//
// The following are ``pseudo tags'' that can be
// used to control codec-specific functionality.
// These tags are not written to file.  Note that
// these values start at 0xffff+1 so that they'll
// never collide with Aldus-assigned tags.
//
// If you want your private pseudo tags ``registered''
// (i.e. added to this file), send mail to sam@sgi.com
// with the appropriate C definitions to add.
//
#define TIFFTAG_FAXMODE                 65536   // Group 3/4 format control
#define     FAXMODE_CLASSIC     0x0000          // default, include RTC
#define     FAXMODE_NORTC       0x0001          // no RTC at end of data
#define     FAXMODE_NOEOL       0x0002          // no EOL code at end of row
#define     FAXMODE_BYTEALIGN   0x0004          // byte align row
#define     FAXMODE_WORDALIGN   0x0008          // word align row
#define     FAXMODE_CLASSF      FAXMODE_NORTC   // TIFF Class F
#define TIFFTAG_JPEGQUALITY             65537   // Compression quality level
//
// Note: quality level is on the IJG 0-100 scale.  Default value is 75
//
#define TIFFTAG_JPEGCOLORMODE           65538   // Auto RGB<=>YCbCr convert?
#define     JPEGCOLORMODE_RAW   0x0000          // no conversion (default)
#define     JPEGCOLORMODE_RGB   0x0001          // do auto conversion
#define TIFFTAG_JPEGTABLESMODE          65539   // What to put in JPEGTables
#define     JPEGTABLESMODE_QUANT 0x0001         // include quantization tbls
#define     JPEGTABLESMODE_HUFF 0x0002          // include Huffman tbls
//
// Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF
//
#define TIFFTAG_FAXFILLFUNC             65540   // G3/G4 fill function
#define TIFFTAG_PIXARLOGDATAFMT         65549   // PixarLogCodec I/O data sz
#define     PIXARLOGDATAFMT_8BIT        0       // regular u_char samples
#define     PIXARLOGDATAFMT_8BITABGR    1       // ABGR-order u_chars
#define     PIXARLOGDATAFMT_10BITLOG    2       // 10-bit log-encoded (raw)
#define     PIXARLOGDATAFMT_12BITPICIO  3       // as per PICIO (1.0==2048)
#define     PIXARLOGDATAFMT_16BIT       4       // signed short samples
#define     PIXARLOGDATAFMT_FLOAT       5       // IEEE float samples

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\client\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7061590F_C8B2_11D0_B225_00C04FB6C2F5__INCLUDED_)
#define AFX_STDAFX_H__7061590F_C8B2_11D0_B225_00C04FB6C2F5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7061590F_C8B2_11D0_B225_00C04FB6C2F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\include\faxsvr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsvr.h

Abstract:

    This file contains common data structures and defines
    for the itg routing extension and the client com
    comtrol.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/


#define SERVICE_PORT    5001
#define MAX_CLIENTS     32

#define BUFFER_SIZE     512
#define REQ_NEXT_FAX    1
#define REQ_ACK         2
#define RSP_GOOD        1
#define RSP_BAD         0

typedef struct _FAX_QUEUE_MESSAGE {
    DWORD   Request;
    DWORD   Response;
    CHAR    Buffer[BUFFER_SIZE];
} FAX_QUEUE_MESSAGE, *PFAX_QUEUE_MESSAGE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\perfmon\faxcount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxmon\faxmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.c

Abstract:

    Implementation of the following print monitor entry points:
        InitializePrintMonitor
        OpenPort
        ClosePort
        StartDocPort
        EndDocPort
        WritePort
        ReadPort

Environment:

    Windows NT fax print monitor

Revision History:

    05/09/96 -davidx-
        Remove caching of ports from the monitor.

    02/22/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxmon.h"
#include "tiff.h"
#include "faxreg.h"
#include <splapip.h>

//
// Determine whether we're at the beginning of a TIFF file
//

#define ValidTiffFileHeader(p) \
        (((LPSTR) (p))[0] == 'I' && ((LPSTR) (p))[1] == 'I' && \
         ((PBYTE) (p))[2] == 42  && ((PBYTE) (p))[3] == 0)

//
// Read a DWORD value from an unaligned address
//

#define ReadUnalignedDWord(p) *((DWORD UNALIGNED *) (p))

//
// Write a DWORD value to an unaligned address
//

#define WriteUnalignedDWord(p, value) (*((DWORD UNALIGNED *) (p)) = (value))

//
// Fax monitor name string
//

TCHAR   faxMonitorName[CCHDEVICENAME] = TEXT("Windows NT Fax Monitor");

//
// DLL instance handle
//

HANDLE  ghInstance = NULL;

//
// Retry parameters when failing to connect to the fax service
//  default = infinite retry with 5 seconds interval
//

DWORD   connectRetryCount = 0;
DWORD   connectRetryInterval = 5;



BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {

    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        LoadString(ghInstance, IDS_FAX_MONITOR_NAME, faxMonitorName, CCHDEVICENAME);
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}



LPMONITOREX
InitializePrintMonitor(
    LPTSTR  pRegistryRoot
    )

/*++

Routine Description:

    Initialize the print monitor

Arguments:

    pRegistryRoot = Points to a string that specifies the registry root for the monitor

Return Value:

    Pointer to a MONITOREX structure which contains function pointers
    to other print monitor entry points. NULL if there is an error.

--*/

{
    static MONITOREX faxmonFuncs = {

        sizeof(MONITOR),
        {
            FaxMonEnumPorts,
            FaxMonOpenPort,
            NULL,                   // OpenPortEx
            FaxMonStartDocPort,
            FaxMonWritePort,
            FaxMonReadPort,
            FaxMonEndDocPort,
            FaxMonClosePort,
            FaxMonAddPort,
            FaxMonAddPortEx,
            FaxMonConfigurePort,
            FaxMonDeletePort,
            NULL,                   // GetPrinterDataFromPort
            NULL,                   // SetPortTimeOuts
        }
    };


    Trace("InitializePrintMonitor");

    //
    // Get fax service connection retry parameters from the registry
    //

    if (pRegistryRoot) {

        HKEY    hRegKey;
        LONG    status;

        status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                pRegistryRoot,
                                0,
                                NULL,
                                0,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &hRegKey,
                                NULL);

        if (status == ERROR_SUCCESS) {

            connectRetryCount =
                GetRegistryDWord(hRegKey, REGVAL_CONNECT_RETRY_COUNT, connectRetryCount);

            connectRetryInterval =
                GetRegistryDWord(hRegKey, REGVAL_CONNECT_RETRY_INTERVAL, connectRetryInterval);

            RegCloseKey(hRegKey);
        }
    }

    return &faxmonFuncs;
}



BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    )

/*++

Routine Description:

    Provides a port for a newly connected printer

Arguments:

    pName - Points to a string that specifies the port name
    pHandle - Returns a handle to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT         pFaxPort = NULL;


    Trace("OpenPort");
    Assert(pHandle != NULL && pPortName != NULL);

    //
    // Get information about the specified port
    //

    if ((pFaxPort = MemAllocZ(sizeof(FAXPORT))) &&
        (pPortName = DuplicateString(FAX_PORT_NAME)))
    {
        pFaxPort->startSig = pFaxPort->endSig = pFaxPort;
        pFaxPort->pName = pPortName;
        pFaxPort->hFile = INVALID_HANDLE_VALUE;

    } else {

        MemFree(pFaxPort);
        pFaxPort = NULL;
    }

    *pHandle = (HANDLE) pFaxPort;
    return (*pHandle != NULL);
}



VOID
FreeFaxJobInfo(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Free up memory used for maintaining information about the current job

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    NONE

--*/

{
    //
    // Close and delete the temporary file if necessary
    //

    if (pFaxPort->hFile != INVALID_HANDLE_VALUE) {

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->pFilename) {

        DeleteFile(pFaxPort->pFilename);
        MemFree(pFaxPort->pFilename);
        pFaxPort->pFilename = NULL;
    }

    if (pFaxPort->hPrinter) {

        ClosePrinter(pFaxPort->hPrinter);
        pFaxPort->hPrinter = NULL;
    }

    MemFree(pFaxPort->pPrinterName);
    pFaxPort->pPrinterName = NULL;

    MemFree(pFaxPort->pParameters);
    pFaxPort->pParameters = NULL;
    ZeroMemory(&pFaxPort->jobParam, sizeof(pFaxPort->jobParam));

    //
    // Disconnect from the fax service if necessary
    //

    if (pFaxPort->hFaxSvc) {

        if (! pFaxPort->pFaxClose(pFaxPort->hFaxSvc)) {
            Error(("FaxClose failed: %d\n", GetLastError()));
        }

        FreeLibrary( pFaxPort->hWinFax );

        pFaxPort->hFaxSvc = NULL;
        pFaxPort->pFaxConnectFaxServerW = NULL;
        pFaxPort->pFaxClose = NULL;
        pFaxPort->pFaxSendDocumentW = NULL;
        pFaxPort->pFaxAccessCheck = NULL;

    }
}



BOOL
FaxMonClosePort(
    HANDLE  hPort
    )

/*++

Routine Description:

    Closes the port specified by hPort when there are no printers connected to it

Arguments:

    hPort - Specifies the handle of the port to be close

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;

    Trace("ClosePort");

    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort)) {

        Error(("Trying to close an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Free up memory used for maintaining information about the current job
    //

    FreeFaxJobInfo(pFaxPort);

    MemFree(pFaxPort->pName);
    MemFree(pFaxPort);
    return TRUE;
}



LPTSTR
CreateTempFaxFile(
    VOID
    )

/*++

Routine Description:

    Create a temporary file in the system spool directory for storing fax data

Arguments:

    NONE

Return Value:

    Pointer to the name of the newly created temporary file
    NULL if there is an error

--*/

{
    //TCHAR   spoolDir[MAX_PATH];
    //HANDLE  hServer;
    LPTSTR  pFilename;

    TCHAR   TempDir[MAX_PATH];
    TCHAR   FileName[MAX_PATH];

    //
    // Allocate a memory buffer for holding the temporary filename
    //

    if (pFilename = MemAlloc(sizeof(TCHAR) * MAX_PATH)) {
    
        if (!GetTempPath(sizeof(TempDir)/sizeof(TCHAR),TempDir)||
            !GetTempFileName(TempDir, TEXT("fax"), 0, FileName))
        {
            MemFree(pFilename);
            pFilename = NULL;
        }  else {
            lstrcpy(pFilename,FileName);
        }

    }

    if (! pFilename)
        Error(("Failed to create temporary file in the spool directory\n"));

    return pFilename;
}



BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    )

/*++

Routine Description:

    Open a handle to the current fax job file associated with a port

Arguments:

    pFaxPort - Points to a fax port structure
    doAppend - Specifies whether to discard existing data in the file or
        append new data to it

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   creationFlags;

    Assert(pFaxPort->pFilename && pFaxPort->hFile == INVALID_HANDLE_VALUE);
    Verbose(("Temporary fax job file: %ws\n", pFaxPort->pFilename));

    //
    // Open the file for reading and writing
    //

    creationFlags = doAppend ? OPEN_ALWAYS : (OPEN_ALWAYS | TRUNCATE_EXISTING);

    pFaxPort->hFile = CreateFile(pFaxPort->pFilename,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 NULL,
                                 creationFlags,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    //
    // If we're appending, then move the file pointer to end of file
    //

    if (doAppend && pFaxPort->hFile != INVALID_HANDLE_VALUE &&
        SetFilePointer(pFaxPort->hFile, 0, NULL, FILE_END) == 0xffffffff)
    {
        Error(("SetFilePointer failed: %d\n", GetLastError()));

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    return (pFaxPort->hFile != INVALID_HANDLE_VALUE);
}



LPCTSTR
ExtractFaxTag(
    LPCTSTR      pTagKeyword,
    LPCTSTR      pTaggedStr,
    INT        *pcch
    )

/*++

Routine Description:

    Find the value of for the specified tag in a tagged string.

Arguments:

    pTagKeyword - specifies the interested tag keyword
    pTaggedStr - points to the tagged string to be searched
    pcch - returns the length of the specified tag value (if found)

Return Value:

    Points to the value for the specified tag.
    NULL if the specified tag is not found

NOTE:

    Tagged strings have the following form:
        <tag>value<tag>value

    The format of tags is defined as:
        <$FAXTAG$ tag-name>

    There is exactly one space between the tag keyword and the tag name.
    Characters in a tag are case-sensitive.

--*/

{
    LPCTSTR  pValue;

    if (pValue = _tcsstr(pTaggedStr, pTagKeyword)) {

        pValue += _tcslen(pTagKeyword);

        if (pTaggedStr = _tcsstr(pValue, FAXTAG_PREFIX))
            *pcch = (INT)(pTaggedStr - pValue);
        else
            *pcch = _tcslen(pValue);
    }

    return pValue;
}



BOOL
GetJobInfo(
    PFAXPORT    pFaxPort,
    DWORD       jobId
    )

/*++

Routine Description:

    Retrieve recipient information from the devmode associated with the job

Arguments:

    pFaxPort - Points to a fax port structure
    jobId - Specifies the current job ID

Return Value:

    TRUE if the job parameters are successfully retrieved or
    the fax job is from a downlevel fax client.

    FALSE if there is an error.

--*/

{
    JOB_INFO_2 *pJobInfo2;
    LPCTSTR      pParameters = NULL;

    //
    // Retrieve the parameter string associated with the specified job.
    // If there is no job parameter or the parameter contains the tag
    // <$FAXTAG$ DOWNLEVEL>, then we assume the job comes from downlevel client.
    //

    ZeroMemory(&pFaxPort->jobParam, sizeof(pFaxPort->jobParam));
    pFaxPort->jobParam.SizeOfStruct = sizeof( FAX_JOB_PARAM );

    if ((pJobInfo2 = MyGetJob(pFaxPort->hPrinter, 2, jobId)) == NULL ||
        (pParameters = pJobInfo2->pParameters) == NULL ||
        _tcsstr(pParameters, FAXTAG_DOWNLEVEL_CLIENT) != NULL)
    {
        MemFree(pJobInfo2);
        return TRUE;
    }

    if ((pFaxPort->pParameters = DuplicateString(pParameters)) != NULL) {

        //
        // Tags used to pass information about fax jobs
        //

        static LPCTSTR faxtagNames[NUM_JOBPARAM_TAGS] = {

            FAXTAG_RECIPIENT_NUMBER,
            FAXTAG_RECIPIENT_NAME,
            FAXTAG_TSID,
            FAXTAG_SENDER_NAME,
            FAXTAG_SENDER_COMPANY,
            FAXTAG_SENDER_DEPT,
            FAXTAG_BILLING_CODE,
            FAXTAG_WHEN_TO_SEND,
            FAXTAG_SEND_AT_TIME,
            FAXTAG_PROFILE_NAME,
            FAXTAG_EMAIL_NAME
        };

        LPTSTR WhenToSend = NULL;
        LPTSTR SendAtTime = NULL;
        LPTSTR DeliveryReportType = NULL;

        LPTSTR *fieldStr[NUM_JOBPARAM_TAGS] = {

            (LPTSTR *)&pFaxPort->jobParam.RecipientNumber,
            (LPTSTR *)&pFaxPort->jobParam.RecipientName,
            (LPTSTR *)&pFaxPort->jobParam.Tsid,
            (LPTSTR *)&pFaxPort->jobParam.SenderName,
            (LPTSTR *)&pFaxPort->jobParam.SenderCompany,
            (LPTSTR *)&pFaxPort->jobParam.SenderDept,
            (LPTSTR *)&pFaxPort->jobParam.BillingCode,
            &WhenToSend,
            &SendAtTime,
            (LPTSTR *)&pFaxPort->jobParam.DeliveryReportAddress,
            &DeliveryReportType
        };

        INT     fieldLen[NUM_JOBPARAM_TAGS];
        INT     count;

        pParameters = pFaxPort->pParameters;
        Verbose(("JOB_INFO_2.pParameter = %ws\n", pParameters));

        //
        // Extract individual fields out of the tagged string
        //

        for (count=0; count < NUM_JOBPARAM_TAGS; count++) {

            *fieldStr[count] = (LPTSTR)ExtractFaxTag(faxtagNames[count],
                                             pParameters,
                                             &fieldLen[count]);
        }

        //
        // Null-terminate each field
        //

        for (count=0; count < NUM_JOBPARAM_TAGS; count++) {
            if (*fieldStr[count]) {
                (*fieldStr[count])[fieldLen[count]] = NUL;
            }
        }

        if (WhenToSend) {
            if (_tcsicmp( WhenToSend, TEXT("cheap") ) == 0) {
                pFaxPort->jobParam.ScheduleAction = JSA_DISCOUNT_PERIOD;
            } else if (_tcsicmp( WhenToSend, TEXT("at") ) == 0) {
                pFaxPort->jobParam.ScheduleAction = JSA_SPECIFIC_TIME;
            }
        }

        if (SendAtTime) {
            if (_tcslen(SendAtTime) == 5 && SendAtTime[2] == L':' &&
                _istdigit(SendAtTime[0]) && _istdigit(SendAtTime[1]) &&
                _istdigit(SendAtTime[3]) && _istdigit(SendAtTime[4]))
            {
                DWORDLONG FileTime;
                SYSTEMTIME LocalTime;
                INT Minutes;
                INT SendMinutes;

                SendAtTime[2] = 0;
                
                //
                // Calculate the number of minutes from now to send and add that to the current time.
                //
                
                GetLocalTime( &LocalTime );
                SystemTimeToFileTime( &LocalTime, (LPFILETIME) &FileTime );

                SendMinutes = min(23,_ttoi( &SendAtTime[0] )) * 60 + min(59,_ttoi( &SendAtTime[3] ));

                Minutes = LocalTime.wHour * 60 + LocalTime.wMinute;

                Minutes = SendMinutes - Minutes;


                // Account for passing midnight
                //
                if (Minutes < 0) {
                    Minutes += 24 * 60;
                }
                
                FileTime += (DWORDLONG)(Minutes * 60I64 * 1000I64 * 1000I64 * 10I64);

                FileTimeToSystemTime((LPFILETIME) &FileTime, &pFaxPort->jobParam.ScheduleTime );
    
                SendAtTime[2] = L':';
                
            }
        }

        if (DeliveryReportType) {
            if (_tcsicmp( DeliveryReportType, TEXT("email") ) == 0) {
                pFaxPort->jobParam.DeliveryReportType = DRT_EMAIL;
            } else if (_tcsicmp( DeliveryReportType, TEXT("inbox") ) == 0) {
                pFaxPort->jobParam.DeliveryReportType = DRT_INBOX;
            }
        }

        if (pFaxPort->jobParam.RecipientNumber == NULL) {

            Error(("Missing recipient phone number.\n"));
            SetJob(pFaxPort->hPrinter, jobId, 0, NULL, JOB_CONTROL_PAUSE);
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    MemFree(pJobInfo2);

    return (pFaxPort->jobParam.RecipientNumber != NULL);
}



BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    )

/*++

Routine Description:

    Spooler calls this function to start a new print job on the port

Arguments:

    hPort - Identifies the port
    pPrinterName - Specifies the name of the printer to which the job is being sent
    JobId - Identifies the job being sent by the spooler
    Level - Specifies the DOC_INFO_x level
    pDocInfo - Points to the document information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT                pFaxPort = (PFAXPORT) hPort;


    Verbose(("Entering StartDocPort: %d ...\n", JobId));

    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort)) {

        Error(("StartDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Check if we're at the beginning of a series of chained jobs
    //

    if (! pFaxPort->hFaxSvc) {

        PJOB_INFO_1 pJobInfo1;
        PORT_INFO_3 portInfo3;
        HANDLE      hPrinter = NULL;
        BOOL        offline = FALSE;
        DWORD       count = connectRetryCount;
        DWORD       jobStatus = 0;

        Assert(pFaxPort->pPrinterName == NULL &&
               pFaxPort->hPrinter == NULL &&
               pFaxPort->pParameters == NULL &&
               pFaxPort->pFilename == NULL &&
               pFaxPort->hFile == INVALID_HANDLE_VALUE);

        //
        // load the winfax dll
        //

        pFaxPort->hWinFax = LoadLibrary( L"winfax.dll" );
        if (pFaxPort->hWinFax == NULL) {
            Error(("LoadLibrary failed loading winfax.dll\n"));
            return FALSE;
        }

        //
        // get the function addresses
        //

        pFaxPort->pFaxConnectFaxServerW = (PFAXCONNECTFAXSERVERW) GetProcAddress( pFaxPort->hWinFax, "FaxConnectFaxServerW" );
        pFaxPort->pFaxClose = (PFAXCLOSE) GetProcAddress( pFaxPort->hWinFax, "FaxClose" );
        pFaxPort->pFaxSendDocumentW = (PFAXSENDDOCUMENTW) GetProcAddress( pFaxPort->hWinFax, "FaxSendDocumentW" );
        pFaxPort->pFaxAccessCheck = (PFAXACCESSCHECK) GetProcAddress( pFaxPort->hWinFax, "FaxAccessCheck" );

        if (pFaxPort->pFaxConnectFaxServerW == NULL || 
            pFaxPort->pFaxClose == NULL || 
            pFaxPort->pFaxSendDocumentW == NULL ||
            pFaxPort->pFaxAccessCheck == NULL) {
            Error(("GetProcAddress failed loading winfax.dll\n"));
            return FALSE;
        }

        //
        // Connect to the fax service and obtain a session handle
        //

        while (! pFaxPort->pFaxConnectFaxServerW(NULL, &pFaxPort->hFaxSvc)) {

            Error(("FaxConnectFaxServer failed: %d\n", GetLastError()));
            pFaxPort->hFaxSvc = NULL;

            if (! offline) {

                portInfo3.dwStatus = PORT_STATUS_OFFLINE;
                portInfo3.pszStatus = NULL;
                portInfo3.dwSeverity = PORT_STATUS_TYPE_WARNING;

                if (! SetPort(NULL, pFaxPort->pName, 3, (LPBYTE) &portInfo3))
                    Error(("SetPort failed: %d\n", GetLastError()));
            }

            offline = TRUE;
            Sleep(connectRetryInterval * 1000);

            //
            // Check if the job has been deleted or restarted
            //

            if (!hPrinter && !OpenPrinter(pPrinterName, &hPrinter, NULL)) {

                Error(("OpenPrinter failed: %d\n", GetLastError()));
                hPrinter = NULL;

            } else if (pJobInfo1 = MyGetJob(hPrinter, 1, JobId)) {

                jobStatus = pJobInfo1->Status;

            }

            MemFree(pJobInfo1);

            if (--count == 0 || (jobStatus & (JOB_STATUS_DELETING|
                                              JOB_STATUS_DELETED|
                                              JOB_STATUS_RESTART)))
            {
                break;
            }
        }

        //
        // Remove the offline status on the port
        //

        if (offline) {

            portInfo3.dwStatus = 0;
            portInfo3.pszStatus = NULL;
            portInfo3.dwSeverity = PORT_STATUS_TYPE_INFO;

            if (! SetPort(NULL, pFaxPort->pName, 3, (LPBYTE) &portInfo3)) {
                Error(("SetPort failed: %d\n", GetLastError()));
            }
        }

        if (hPrinter) {
            ClosePrinter(hPrinter);
        }

        if (pFaxPort->hFaxSvc) {
            if (!pFaxPort->pFaxAccessCheck(pFaxPort->hFaxSvc, FAX_JOB_SUBMIT) ) {
                FreeFaxJobInfo(pFaxPort);
                Error(("FaxAccessCheck failed : %d\n", GetLastError() ));
                SetLastError(ERROR_ACCESS_DENIED);
                return FALSE;
            }
      //      HANDLE      hToken;

            //
            // The monitor runs in the context of the current job's owner.
            // In order to create temporary files in the spool directory,
            // we need to revert to the spooler context first.
            //

/*            if (! (hToken = RevertToPrinterSelf()))
                Error(("RevertToPrinterSelf failed: %d\n", GetLastError()));
*/
            //
            // Remember the printer name because we'll need it at EndDocPort time.
            // Get a temporary filename and open it for reading and writing.
            // Remember other job related information
            //

            if (! (pFaxPort->pPrinterName = DuplicateString(pPrinterName)) ||
                ! OpenPrinter(pPrinterName, &pFaxPort->hPrinter, NULL) ||
                ! GetJobInfo(pFaxPort, JobId) ||
                ! (pFaxPort->pFilename = CreateTempFaxFile()) ||
                ! OpenTempFaxFile(pFaxPort, FALSE))
            {
                FreeFaxJobInfo(pFaxPort);
            } else
                pFaxPort->jobId = pFaxPort->nextJobId = JobId;

            //
            // Switch back to the original context if necessary
            //

/*            if (hToken && !ImpersonatePrinterClient(hToken))
                Error(("ImpersonatePrinterClient failed: %d\n", GetLastError())); */
        }

    } else {

        Assert(pFaxPort->jobId == JobId);
    }

    return (pFaxPort->hFaxSvc != NULL);
}



INT
FixUpFaxFile(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Fixed up the saved print job data into a well-formed TIFF file

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    error code FAXERR_*

--*/

{
    DWORD   fileSize;
    PBYTE   pFileEnd, pFileHdr;
    PBYTE   pFileView = NULL;
    HANDLE  hFileMap = NULL;
    INT     result = FAXERR_BAD_TIFF;

    //
    // Get the size of print job file
    //

    FlushFileBuffers(pFaxPort->hFile);

    if ((fileSize = GetFileSize(pFaxPort->hFile, NULL)) == 0)
        return FAXERR_IGNORE;

    if (fileSize == 0xffffffff)
        return FAXERR_FATAL;

    __try {

        //
        // Map the fax job file into memory
        //

        if ((hFileMap = CreateFileMapping(pFaxPort->hFile, NULL, PAGE_READWRITE, 0, 0, NULL)) &&
            (pFileHdr = pFileView = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, fileSize)) &&
            ValidTiffFileHeader(pFileHdr))
        {
            DWORD   ifdOffset, maxOffset, fileOffset;
            PBYTE   pIfdOffset;

            //
            // A fax print job may contain multiple TIFF files. Each each iteration
            // of the outer loop below deals with a single embedded TIFF file.
            //

            pFileEnd = pFileHdr + fileSize;
            ifdOffset = ReadUnalignedDWord(pFileHdr + sizeof(DWORD));

            do {

                Verbose(("Reading embedded TIFF file ...\n"));
                maxOffset = 0;
                fileOffset = (DWORD)(pFileHdr - pFileView);

                //
                // Each iteration of the following loops processes one IFD
                // from an embedded TIFF file.
                //

                do {

                    PTIFF_IFD           pIfd;
                    PTIFF_TAG           pIfdEntry;
                    INT                 ifdCount;
                    DWORD               size, index, stripCount = 0;
                    PDWORD              pStripOffsets = NULL;

                    pIfd = (PTIFF_IFD) (pFileHdr + ifdOffset);
                    Assert( (PBYTE) pIfd < pFileEnd);
                    if ((PBYTE) pIfd >= pFileEnd) {
                        result = FAXERR_FATAL;
                        __leave;
                    }
                    ifdOffset += sizeof(WORD) + pIfd->wEntries * sizeof(TIFF_TAG);
                    pIfdOffset = pFileHdr + ifdOffset;

                    Assert(pIfdOffset < pFileEnd);
                    if (pIfdOffset >= pFileEnd) {
                        result = FAXERR_FATAL;
                        __leave;
                    }

                    if ((ifdOffset + sizeof(DWORD)) > maxOffset)
                        maxOffset = ifdOffset + sizeof(DWORD);

                    //
                    // We should add the file offset to any non-zero IFD offset
                    //

                    if ((ifdOffset = ReadUnalignedDWord(pIfdOffset)) != 0)
                        WriteUnalignedDWord(pIfdOffset, ifdOffset + fileOffset);

                    //
                    // Now go through each IFD entry and calculate the largest offset
                    //

                    pIfdEntry = (PTIFF_TAG) ((PBYTE) pIfd + sizeof(WORD));
                    ifdCount = pIfd->wEntries;

                    Verbose(("  Reading IFD: %d entries ...\n", ifdCount));

                    while (ifdCount-- > 0) {

                        //
                        // Figure the size of various TIFF data types
                        //

                        switch (pIfdEntry->DataType) {

                        case TIFF_ASCII:
                        case TIFF_BYTE:
                        case TIFF_SBYTE:
                        case TIFF_UNDEFINED:

                            size = 1;
                            break;

                        case TIFF_SHORT:
                        case TIFF_SSHORT:

                            size = 2;
                            break;

                        case TIFF_LONG:
                        case TIFF_SLONG:
                        case TIFF_FLOAT:

                            size = 4;
                            break;

                        case TIFF_RATIONAL:
                        case TIFF_SRATIONAL:
                        case TIFF_DOUBLE:

                            size = 8;
                            break;

                        default:

                            Warning(("Unknown TIFF data type: %d\n", pIfdEntry->DataType));
                            size = 1;
                            break;
                        }

                        //
                        // Look for StripOffsets and StripByteCounts tags
                        //

                        if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS ||
                            pIfdEntry->TagId == TIFFTAG_STRIPBYTECOUNTS)
                        {
                            DWORD   n = pIfdEntry->DataCount;

                            if ((pIfdEntry->DataType == TIFF_LONG) &&
                                (stripCount == 0 || stripCount == n) &&
                                (pStripOffsets || (pStripOffsets = MemAllocZ(sizeof(DWORD)*n))))
                            {
                                if ((stripCount = n) == 1) {

                                    pStripOffsets[0] += pIfdEntry->DataOffset;

                                    if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS)
                                        pIfdEntry->DataOffset += fileOffset;

                                } else {

                                    DWORD UNALIGNED *p;

                                    Verbose(("Multiple strips per page: %d\n", n));

                                    p = (DWORD UNALIGNED *) (pFileHdr + pIfdEntry->DataOffset);

                                    for (index=0; index < stripCount; index++) {

                                        n = *p;
                                        pStripOffsets[index] += n;

                                        if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS)
                                            *p = n + fileOffset;

                                        p = (DWORD UNALIGNED *) ((LPBYTE) p + sizeof(DWORD));
                                    }
                                }

                            } else
                                Error(("Bad StripOffsets/StripByteCounts tag\n"));
                        }

                        //
                        // For a composite value, IFDENTRY.value is an offset
                        //

                        if (size * pIfdEntry->DataCount > sizeof(DWORD)) {

                            if (pIfdEntry->DataOffset > maxOffset)
                                maxOffset = pIfdEntry->DataOffset;

                            pIfdEntry->DataOffset += fileOffset;
                        }

                        pIfdEntry++;
                    }

                    //
                    // Make sure to skip the image data when search for the next file
                    //

                    if (pStripOffsets) {

                        for (index=0; index < stripCount; index++) {

                            if (pStripOffsets[index] > maxOffset)
                                maxOffset = pStripOffsets[index];
                        }

                        MemFree(pStripOffsets);
                    }

                } while (ifdOffset);

                //
                // Search for the beginning of next TIFF file
                //

                pFileHdr += maxOffset;

                while (pFileHdr < pFileEnd) {

                    if (ValidTiffFileHeader(pFileHdr)) {

                        //
                        // Modify the offset in the last IFD
                        //

                        ifdOffset = ReadUnalignedDWord(pFileHdr + sizeof(DWORD));
                        WriteUnalignedDWord(pIfdOffset, ifdOffset + (DWORD)(pFileHdr - pFileView));
                        break;
                    }

                    pFileHdr++;
                }

            } while (pFileHdr < pFileEnd);

            result = FAXERR_NONE;
        }

    } __finally {

        //
        // Perform necessary cleanup before returning to caller
        //

        if (pFileView)
            UnmapViewOfFile(pFileView);

        if (hFileMap)
            CloseHandle(hFileMap);

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    return result;
}



INT
CheckJobRestart(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Check if the job has been restarted.
    If not, get the ID of the next job in the chain.

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    FAXERR_RESTART or FAXERR_NONE

--*/

{
    JOB_INFO_3 *pJobInfo3;
    JOB_INFO_2 *pJobInfo2;
    INT         status = FAXERR_NONE;

    //
    // If not, get the ID of the next job in the chain.
    //

    Verbose(("Job chain: id = %d\n", pFaxPort->nextJobId));

    if (pJobInfo3 = MyGetJob(pFaxPort->hPrinter, 3, pFaxPort->jobId)) {

        pFaxPort->nextJobId = pJobInfo3->NextJobId;
        MemFree(pJobInfo3);

    } else
        pFaxPort->nextJobId = 0;

    //
    // Determine whether the job has been restarted or deleted
    //

    if (pJobInfo2 = MyGetJob(pFaxPort->hPrinter, 2, pFaxPort->jobId)) {

        if (pJobInfo2->Status & (JOB_STATUS_RESTART | JOB_STATUS_DELETING))
            status = FAXERR_RESTART;

        MemFree(pJobInfo2);
    }

    return status;
}


BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    )

/*++

Routine Description:

    Spooler calls this function at the end of a print job

Arguments:

    hPort - Identifies the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;
    INT         status;
    LPTSTR      pAtSign, pNewRecipName = NULL;
    //HANDLE      hToken;
    DWORD       FaxJobId;
    BOOL        Rslt;
    JOB_INFO_2  *pJobInfo2;


    Trace("EndDocPort");

    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) {

        Error(("EndDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Check if the job has been restarted. If not, get the ID of
    // the next job in the chain.
    //

    if ((status = CheckJobRestart(pFaxPort)) != FAXERR_NONE)
        goto ExitEndDocPort;

    //
    // Check if we're at the end of a job chain
    //

    if (pFaxPort->nextJobId != 0 && pFaxPort->pParameters != NULL) {

        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        return TRUE;
    }

    //
    // The monitor runs in the context of the current job's owner.
    // In order to create temporary files in the spool directory,
    // we need to revert to the spooler context first.
    //

/*    if (! (hToken = RevertToPrinterSelf()))
        Error(("RevertToPrinterSelf failed: %d\n", GetLastError()));
*/
    //
    // Check if we're dealing with fax jobs from win31 or win95 clients
    //

    if ((pFaxPort->pParameters == NULL) &&
        (status = ProcessDownlevelFaxJob(pFaxPort)) != FAXERR_NONE)
    {
        goto ExitEndDocPort;
    }

    //
    // Fix up the temporary fax data into a properly formatted TIFF file.
    //

    if ((status = FixUpFaxFile(pFaxPort)) != FAXERR_NONE) {
        goto ExitEndDocPort;
    }

    //
    // Call the fax service to send the TIFF file
    //

    #if DBG

    if (_debugLevel > 0) {

        DbgPrint("Send document to fax service:\n");
        DbgPrint("  Printer Name: %ws\n", pFaxPort->pPrinterName);
        DbgPrint("  Job ID: %d\n", pFaxPort->jobId);
        DbgPrint("  File Name: %ws\n", pFaxPort->pFilename);
        DbgPrint("  Recipient Number: %ws\n", pFaxPort->jobParam.RecipientNumber);
        DbgPrint("  Recipient Name: %ws\n", pFaxPort->jobParam.RecipientName);
        DbgPrint("  TSID: %ws\n", pFaxPort->jobParam.Tsid);
        DbgPrint("  Sender Name: %ws\n", pFaxPort->jobParam.SenderName);
        DbgPrint("  Sender Company: %ws\n", pFaxPort->jobParam.SenderCompany);
        DbgPrint("  Sender Dept: %ws\n", pFaxPort->jobParam.SenderDept);
        DbgPrint("  Billing Code: %ws\n", pFaxPort->jobParam.BillingCode);
    }

    #endif

    //
    // fixup the fax address
    //

    if (pAtSign = _tcschr(pFaxPort->jobParam.RecipientNumber, TEXT('@'))) {

        *pAtSign++ = NUL;

        if (pFaxPort->jobParam.RecipientName == NULL)
            pNewRecipName = (LPTSTR) pFaxPort->jobParam.RecipientName = (LPTSTR)DuplicateString(pFaxPort->jobParam.RecipientNumber);

        _tcscpy((LPTSTR)pFaxPort->jobParam.RecipientNumber, pAtSign);
    }

    //
    // send the fax
    //

    pJobInfo2 = MyGetJob( pFaxPort->hPrinter, 2, pFaxPort->jobId );
    if (pJobInfo2) {
        pFaxPort->jobParam.DocumentName = pJobInfo2->pDocument;
    } else {
        pFaxPort->jobParam.DocumentName = NULL;
    }

/*    if (hToken && !ImpersonatePrinterClient(hToken)) {
        Error(("ImpersonatePrinterClient failed: %d\n", GetLastError()));
    } */

    pFaxPort->jobParam.Reserved[0] = 0xffffffff;
    pFaxPort->jobParam.Reserved[1] = pFaxPort->jobId;

    Rslt = pFaxPort->pFaxSendDocumentW( pFaxPort->hFaxSvc, pFaxPort->pFilename, &pFaxPort->jobParam, NULL, &FaxJobId );

/*    if (! (hToken = RevertToPrinterSelf())) {
        Error(("RevertToPrinterSelf failed: %d\n", GetLastError()));
    } */

    if (pJobInfo2) {
        MemFree( pJobInfo2 );
        pFaxPort->jobParam.DocumentName = NULL;
    }

    if (Rslt) {
        status = FAXERR_NONE;
        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        DeleteFile( pFaxPort->pFilename );
    } else {
        status = GetLastError();
        Error(("FaxSendDocumentForSpooler failed: %d\n", GetLastError()));
    }

ExitEndDocPort:

    if (status == FAXERR_NONE) {

        //
        // If the job was successfully sent to the fax service, then
        // the service will delete the temporary file when it's done
        // with it. So we don't need to delete it here.
        //

        MemFree(pFaxPort->pFilename);
        pFaxPort->pFilename = NULL;

    } else {

        //
        // If the job wasn't successfully sent to the fax service,
        // inform the spooler that there is an error on the job.
        //
        // Or if the print job has no data, simply ignore it.
        //

        switch (status) {

        case FAXERR_RESTART:

            Warning(("Job restarted or deleted: id = %d\n", pFaxPort->jobId));

        case FAXERR_IGNORE:

            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
            break;

        default:

            Error(("Error sending fax job: id = %d\n", pFaxPort->jobId));

            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_PAUSE);
            SetJobStatus(pFaxPort->hPrinter, pFaxPort->jobId, status);
            break;
        }
    }

    if (pNewRecipName) {

        MemFree(pNewRecipName);
        pFaxPort->jobParam.RecipientName = NULL;
    }

    FreeFaxJobInfo(pFaxPort);

    //
    // Switch back to the original context if necessary
    //

/*    if (hToken && !ImpersonatePrinterClient(hToken))
        Error(("ImpersonatePrinterClient failed: %d\n", GetLastError()));*/

    return (status < FAXERR_SPECIAL);
}



BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    )

/*++

Routine Description:

    Writes data to a port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer that contains data to be written to the port
    cbBuf - Specifies the size in bytes of the buffer
    pcbWritten - Returns the count of bytes successfully written to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;

    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) {

        Error(("WritePort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Assert(pFaxPort->hFile != INVALID_HANDLE_VALUE);
    return WriteFile(pFaxPort->hFile, pBuffer, cbBuf, pcbWritten, NULL);
}



BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    )

/*++

Routine Description:

    Reads data from the port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer where data read from the printer can be written
    cbBuf - Specifies the size in bytes of the buffer pointed to by pBuffer
    pcbRead - Returns the number of bytes successfully read from the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Trace("ReadPort");
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    )

/*++

Routine Description:

    Enumerates the ports available on the specified server

Arguments:

    pServerName - Specifies the name of the server whose ports are to be enumerated
    dwLevel - Specifies the version of the structure to which pPorts points
    pPorts - Points to an array of PORT_INFO_1 structures where data describing
        the available ports will be writteno
    cbBuf - Specifies the size in bytes of the buffer to which pPorts points
    pcbNeeded - Returns the required buffer size identified by pPorts
    pReturned -  Returns the number of PORT_INFO_1 structures returned

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAX_DESC_LEN    64

{
    TCHAR            portDescStr[MAX_DESC_LEN];
    INT              descStrSize, faxmonNameSize;
    DWORD            cbNeeded;
    BOOL             status = TRUE;
    PORT_INFO_1      *pPortInfo1 = (PORT_INFO_1 *) pPorts;
    PORT_INFO_2      *pPortInfo2 = (PORT_INFO_2 *) pPorts;
    INT              strSize;


    Trace("EnumPorts");

    if (pcbNeeded == NULL || pReturned == NULL || (pPorts == NULL && cbBuf != 0)) {

        Error(("Invalid input parameters\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Load the fax port description string
    //

    if (! LoadString(ghInstance, IDS_FAX_PORT_DESC, portDescStr, MAX_DESC_LEN))
        portDescStr[0] = NUL;

    descStrSize = SizeOfString(portDescStr);
    faxmonNameSize = SizeOfString(faxMonitorName);

    switch (Level) {

    case 1:

        cbNeeded = sizeof(PORT_INFO_1) + SizeOfString(FAX_PORT_NAME);
        break;

    case 2:

        cbNeeded = sizeof(PORT_INFO_2) + descStrSize + faxmonNameSize + SizeOfString(FAX_PORT_NAME);
        break;
    }

    *pReturned = 1;
    *pcbNeeded = cbNeeded;

    if (cbNeeded > cbBuf) {

        //
        // Caller didn't provide a big enough buffer
        //

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        status = FALSE;

    } else {

        //
        // Strings must be packed at the end of the caller provided buffer.
        // Otherwise, spooler will mess up.
        //

        pPorts += cbBuf;

        //
        // Copy the requested port information to the caller provided buffer
        //

        strSize = SizeOfString(FAX_PORT_NAME);
        pPorts -= strSize;
        CopyMemory(pPorts, FAX_PORT_NAME, strSize);

        switch (Level) {

        case 1:

            pPortInfo1->pName = (LPTSTR) pPorts;
            Verbose(("Port info 1: %ws\n", pPortInfo1->pName));

            pPortInfo1++;
            break;

        case 2:

            pPortInfo2->pPortName = (LPTSTR) pPorts;

            //
            // Copy the fax monitor name string
            //

            pPorts -= faxmonNameSize;
            pPortInfo2->pMonitorName = (LPTSTR) pPorts;
            CopyMemory(pPorts, faxMonitorName, faxmonNameSize);

            //
            // Copy the fax port description string
            //

            pPorts -= descStrSize;
            pPortInfo2->pDescription = (LPTSTR) pPorts;
            CopyMemory(pPorts, portDescStr, descStrSize);

            pPortInfo2->fPortType = PORT_TYPE_WRITE;
            pPortInfo2->Reserved = 0;

            Verbose(("Port info 2: %ws, %ws, %ws\n",
                     pPortInfo2->pPortName,
                     pPortInfo2->pMonitorName,
                     pPortInfo2->pDescription));

            pPortInfo2++;
            break;
        }
    }

    return status;
}



BOOL
DisplayErrorNotImplemented(
    HWND    hwnd,
    INT     titleId
    )

/*++

Routine Description:

    Display an error dialog to tell the user that he cannot manage
    fax devices in the Printers folder.

Arguments:

    hwnd - Specifies the parent window for the message box
    titleId - Message box title string resource ID

Return Value:

    FALSE

--*/

{
    TCHAR   title[128];
    TCHAR   message[256];

    LoadString(ghInstance, titleId, title, 128);
    LoadString(ghInstance, IDS_CONFIG_ERROR, message, 256);
    MessageBox(hwnd, message, title, MB_OK|MB_ICONERROR);

    SetLastError(ERROR_SUCCESS);
    return FALSE;
}



BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    )

/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Trace("AddPort");

    return DisplayErrorNotImplemented(hwnd, IDS_ADD_PORT);
}



BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    )

/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Trace("AddPortEx");
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    )

/*++

Routine Description:

    Delete the specified port from the list of supported ports

Arguments:

    pServerName - Specifies the name of the server from which the port is to be removed
    hwnd - Identifies the parent window of the port-deletion dialog box
    pPortName - Specifies the name of the port to be deleted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Trace("DeletePort");
    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}



BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    )

/*++

Routine Description:

    Display a dialog box to allow user to configure the specified port

Arguments:

    pServerName - Specifies the name of the server on which the given port exists
    hwnd - Identifies the parent window of the port-configuration dialog
    pPortName - Specifies the name of the port to be configured

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Trace("ConfigurePort");

    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     strSize;

    if (pSrcStr != NULL) {

        strSize = SizeOfString(pSrcStr);

        if (pDestStr = MemAlloc(strSize))
            CopyMemory(pDestStr, pSrcStr, strSize);
        else
            Error(("Memory allocation failed\n"));

    } else
        pDestStr = NULL;

    return pDestStr;
}



PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    Error(("GetJob failed: %d\n", GetLastError()));
    MemFree(pJobInfo);
    return NULL;
}



BOOL
SetJobStatus(
    HANDLE  hPrinter,
    DWORD   jobId,
    INT     statusStrId
    )

/*++

Routine Description:

    Update the status information of a print job

Arguments:

    hPrinter - Specifies the printer on which the job is printed
    jobId - Specifies the job identifier
    statusStrID - Specifies the status string resource ID

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAX_MESSAGE_LEN 256

{
    JOB_INFO_1 *pJobInfo1;
    BOOL        result = FALSE;
    TCHAR       message[MAX_MESSAGE_LEN];

    //
    // Get the current job information
    //

    if (pJobInfo1 = MyGetJob(hPrinter, 1, jobId)) {

        //
        // Update the status field
        //

        if (LoadString(ghInstance, statusStrId, message, MAX_MESSAGE_LEN))
            pJobInfo1->pStatus = message;
        else {

            pJobInfo1->pStatus = NULL;
            pJobInfo1->Status = JOB_STATUS_ERROR;
        }

        pJobInfo1->Position = JOB_POSITION_UNSPECIFIED;

        if (! (result = SetJob(hPrinter, jobId, 1, (PBYTE) pJobInfo1, 0)))
            Error(("SetJob failed: %d\n", GetLastError()));

        MemFree(pJobInfo1);
    }

    return result;
}



DWORD
GetRegistryDWord(
    HKEY    hRegKey,
    LPTSTR  pValueName,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value from the registry

Arguments:

    hRegKey - Handle to the user info registry key
    pValueName - Specifies the name of the string value in registry
    defaultValue - Specifies the default value to be used in case of an error

Return Value:

    Requested DWORD value from the user info registry key

--*/

{
    DWORD   size, type, value;

    //
    // Retrieve the country code value from the registry.
    // Use the default value if none exists.
    //

    size = sizeof(value);

    if (RegQueryValueEx(hRegKey, pValueName, NULL, &type, (PBYTE) &value, &size) != ERROR_SUCCESS ||
        type != REG_DWORD)
    {
        value = defaultValue;
    }

    return value;
}



#if DBG

//
// Variable for controlling the amount of debug messages generated
//

INT _debugLevel = 1;


LPCSTR
StripDirPrefixA(
    LPCSTR  pFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename

Arguments:

    pFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    LPCSTR  pstr;

    if (pstr = strrchr(pFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pFilename;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\itg\server\faxitg.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the itg routing extension.
    The purpose of this routing extension is to create
    a queue of faxes that are processed by network
    client applications.  The clients are manual routers
    that simply display the fax and allow the operator
    to send the fax via email.

    This code has 2 main parts, routing extension that
    is called by the fax service and the client service
    threads.

    The routing extension part simply copies the fax file
    into a disk directory that becomes the queue.

    The client service threads service requests from the
    clients for retrieving queued faxes.  The clients
    communicate through the use of sockets.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include <windows.h>
#include <winsock2.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <lm.h>

#include "faxutil.h"
#include "faxroute.h"
#include "faxsvr.h"

#define MAX_THREADS                 1

#define FAX_RECEIVE_DIR             TEXT("%systemroot%\\faxreceive")
#define FILE_QUEUE_DIR              TEXT("%systemroot%\\faxreceive\\itg")

#define ITG_SHARE_NAME              TEXT("Itg")
#define ITG_SHARE_COMMENT           TEXT("ITG Fax Queue")

typedef struct _CLIENT_DATA {
    SOCKET              Socket;
    OVERLAPPED          Overlapped;
    FAX_QUEUE_MESSAGE   Message;
} CLIENT_DATA, *PCLIENT_DATA;


PFAXROUTEGETFILE    FaxRouteGetFile;
HINSTANCE           MyhInstance;
BOOL                ServiceDebug;
LPWSTR              FaxReceiveDir;
LPWSTR              FileQueueDir;
PSID                ServiceSid;
WSADATA             WsaData;
CLIENT_DATA         ClientData[MAX_CLIENTS];
DWORD               ClientCount;



DWORD
ServerWorkerThread(
    HANDLE ServerCompletionPort
    )

/*++

Routine Description:

    This is the worker thread for servicing client
    requests for retrieving faxes.

Arguments:

    ServerCompletionPort    - Completion port handle

Return Value:

    Thread return value.

--*/

{
    BOOL Rval;
    DWORD Bytes;
    WCHAR FileName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    DWORD ClientIndex;
    LPOVERLAPPED Overlapped;
    PCLIENT_DATA ThisClient;


    while( TRUE ) {

        //
        // get the next packet
        //

        Rval = GetQueuedCompletionStatus(
            ServerCompletionPort,
            &Bytes,
            &ClientIndex,
            &Overlapped,
            INFINITE
            );
        if (!Rval) {
            Rval = GetLastError();
            continue;
        }

        ThisClient = &ClientData[ClientIndex];

        if (ThisClient->Message.Request == REQ_NEXT_FAX) {

            //
            // get the next tif file in the queue
            //

            wcscpy( FileName, FileQueueDir );
            wcscat( FileName, L"\\*.tif" );

            hFind = FindFirstFile( FileName, &FindData );
            if (hFind == INVALID_HANDLE_VALUE) {

                FindClose( hFind );
                ThisClient->Message.Response = RSP_BAD;

            } else {

                FindClose( hFind );
                ThisClient->Message.Response = RSP_GOOD;
                wcscpy( (LPWSTR) ThisClient->Message.Buffer, FindData.cFileName );

            }

            //
            // send the file name to the client
            //

            Bytes = send( ThisClient->Socket, (char*)&ThisClient->Message, sizeof(FAX_QUEUE_MESSAGE), 0 );
            if (Bytes == (DWORD)SOCKET_ERROR) {
                DebugPrint(( L"Windows Sockets error %d: Couldn't send data to client\n", WSAGetLastError() ));
            }

            goto next_packet;

        }

        if (ThisClient->Message.Request == REQ_ACK) {
            if (ThisClient->Message.Response == RSP_GOOD) {

                //
                // if the client successfully copied the file
                // then delete it from the queue
                //

                wcscpy( FileName, FileQueueDir );
                wcscat( FileName, L"\\" );
                wcscat( FileName, (LPWSTR) ThisClient->Message.Buffer );

                DeleteFile( FileName );
            }
            goto next_packet;
        }

next_packet:

        //
        // re-prime the pump for this client by queuing another read
        //

        ReadFile(
            (HANDLE) ThisClient->Socket,
            (LPVOID) &ThisClient->Message,
            sizeof(FAX_QUEUE_MESSAGE),
            &Bytes,
            &ThisClient->Overlapped
            );
    }

    return 0;
}


DWORD
ServerNetworkThread(
    LPVOID lpv
    )

/*++

Routine Description:

    This is the worker thread for servicing initial
    client connections.

Arguments:

    Not used.

Return Value:

    Thread return value.

--*/

{
    SOCKET srv_sock, cli_sock;
    SOCKADDR_IN srv_addr;
    HANDLE ServerCompletionPort;
    HANDLE hThread;
    DWORD ThreadId;
    HANDLE CompletionPort;
    DWORD Bytes;


    //
    // create the single completion port that
    // is used to service client requests
    //

    ServerCompletionPort = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1
        );
    if (!ServerCompletionPort) {
        return FALSE;
    }

    //
    // create the thread to service client requests
    //

    hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) ServerWorkerThread,
        (LPVOID) ServerCompletionPort,
        0,
        &ThreadId
        );
    if (!hThread) {
        return FALSE;
    }

    CloseHandle( hThread );

    //
    // Create the server-side socket
    //

    srv_sock = socket( AF_INET, SOCK_STREAM, 0 );
    if (srv_sock == INVALID_SOCKET){
        DebugPrint(( L"Windows Sockets error %d: Couldn't create socket.", WSAGetLastError() ));
        return FALSE;
    }

    //
    // create the server address
    //

    ZeroMemory( &srv_addr, sizeof(srv_addr) );

    srv_addr.sin_family = AF_INET;
    srv_addr.sin_port   = htons( SERVICE_PORT );

    //
    // Bind socket to the appropriate port and interface
    //

    if (bind(srv_sock, (LPSOCKADDR)&srv_addr, sizeof(srv_addr) ) == SOCKET_ERROR){
        DebugPrint(( L"Windows Sockets error %d: Couldn't bind socket.", WSAGetLastError() ));
        return FALSE;
    }

    //
    // Listen for incoming connections
    //

    if (listen( srv_sock, MAX_CLIENTS ) == SOCKET_ERROR){
        DebugPrint(( L"Windows Sockets error %d: Couldn't set up listen on socket.", WSAGetLastError() ));
        return FALSE;
    }

    //
    // Accept and service incoming connection requests indefinitely
    //

    while (TRUE) {

        //
        // get a new client connection
        //

        cli_sock = accept( srv_sock, NULL, NULL );
        if (cli_sock==INVALID_SOCKET){
            DebugPrint(( L"Windows Sockets error %d: Couldn't accept incoming connection on socket.",WSAGetLastError() ));
            return FALSE;
        }

        //
        // setup the client data struct
        //

        ClientData[ClientCount].Socket = cli_sock;

        //
        // add the client to the completion port for reads
        //

        CompletionPort = CreateIoCompletionPort(
            (HANDLE) ClientData[ClientCount].Socket,
            ServerCompletionPort,
            ClientCount,
            MAX_THREADS
            );
        if (CompletionPort == NULL) {
            DebugPrint(( L"Failed to add a socket to the completion port, ec=%d", GetLastError() ));
            closesocket( cli_sock );
            continue;
        }

        //
        // prime the pump by queueing up a read
        //

        ReadFile(
            (HANDLE) ClientData[ClientCount].Socket,
            (LPVOID) &ClientData[ClientCount].Message,
            sizeof(FAX_QUEUE_MESSAGE),
            &Bytes,
            &ClientData[ClientCount].Overlapped
            );

        //
        // next client
        //

        ClientCount += 1;
    }

    return TRUE;
}


extern "C"
DWORD
FaxRouteDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    This is the dll entrypoint for this routing extension.

Arguments:

    hInstance   - Module handle
    Reason      - Reason for being called
    Context     - Register context

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
    }

    return TRUE;
}


BOOL
CreateNetworkShare(
    LPTSTR Path,
    LPTSTR ShareName,
    LPTSTR Comment
    )

/*++

Routine Description:

    This functions creates a network share,
    shares out a local disk directory.

Arguments:

    Path        - Local disk directory to share
    ShareName   - Name of the share
    Comment     - Comments

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    SHARE_INFO_2 ShareInfo;
    NET_API_STATUS rVal;
    TCHAR ExpandedPath[MAX_PATH*2];


    ExpandEnvironmentStrings( Path, ExpandedPath, sizeof(ExpandedPath) );

    ShareInfo.shi2_netname        = ShareName;
    ShareInfo.shi2_type           = STYPE_DISKTREE;
    ShareInfo.shi2_remark         = Comment;
    ShareInfo.shi2_permissions    = ACCESS_ALL;
    ShareInfo.shi2_max_uses       = (DWORD) -1,
    ShareInfo.shi2_current_uses   = (DWORD) -1;
    ShareInfo.shi2_path           = ExpandedPath;
    ShareInfo.shi2_passwd         = NULL;

    rVal = NetShareAdd(
        NULL,
        2,
        (LPBYTE) &ShareInfo,
        NULL
        );

    return rVal == 0;
}


BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAXROUTEADDFILE pFaxRouteAddFile,
    IN PFAXROUTEDELETEFILE pFaxRouteDeleteFile,
    IN PFAXROUTEGETFILE pFaxRouteGetFile,
    IN PFAXROUTEENUMFILES pFaxRouteEnumFiles
    )

/*++

Routine Description:

    This functions is called by the fax service to
    initialize the routing extension.

Arguments:

    HeapHandle              - Heap handle for memory all allocations
    pFaxRouteAddFile        - Support function for adding files to routing file list
    pFaxRouteDeleteFile     - Support function for deleting files from the routing file list
    pFaxRouteGetFile        - Support function for geting files from the routing file list
    pFaxRouteEnumFiles      - Support function for enumerating files in the routing file list

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    HANDLE hThread;
    DWORD ThreadId;
    DWORD Size;


    FaxRouteGetFile = pFaxRouteGetFile;

    HeapInitialize(HeapHandle,NULL,NULL,0);

    Size = ExpandEnvironmentStrings( FAX_RECEIVE_DIR, FaxReceiveDir, 0 );
    if (Size) {
        FaxReceiveDir = (LPWSTR) MemAlloc( Size * sizeof(WCHAR) );
        if (FaxReceiveDir) {
            ExpandEnvironmentStrings( FAX_RECEIVE_DIR, FaxReceiveDir, Size );
        }
    }

    Size = ExpandEnvironmentStrings( FILE_QUEUE_DIR, FileQueueDir, 0 );
    if (Size) {
        FileQueueDir = (LPWSTR) MemAlloc( Size * sizeof(WCHAR) );
        if (FileQueueDir) {
            ExpandEnvironmentStrings( FILE_QUEUE_DIR, FileQueueDir, Size );
        }
    }

    if (FaxReceiveDir == NULL || FileQueueDir == NULL) {
        return FALSE;
    }

    CreateNetworkShare( FileQueueDir, ITG_SHARE_NAME, ITG_SHARE_COMMENT );

    //
    // initialize winsock
    //

    if (WSAStartup( 0x0101, &WsaData )) {
        return FALSE;
    }

    hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) ServerNetworkThread,
        NULL,
        0,
        &ThreadId
        );
    if (!hThread) {
        return FALSE;
    }

    return TRUE;
}


BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    )

/*++

Routine Description:

    This functions is called by the fax service to
    get routing configuration data.

Arguments:

    RoutingGuid         - Unique identifier for the requested routing method
    DeviceId            - Device that is being configured
    RoutingInfo         - Routing info buffer
    RoutingInfoSize     - Size of the buffer

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    RoutingInfo = NULL;
    RoutingInfoSize = 0;
    return TRUE;
}


BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    IN  DWORD RoutingInfoSize
    )

/*++

Routine Description:

    This functions is called by the fax service to
    set routing configuration data.

Arguments:

    RoutingGuid         - Unique identifier for the requested routing method
    DeviceId            - Device that is being configured
    RoutingInfo         - Routing info buffer
    RoutingInfoSize     - Size of the buffer

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    return TRUE;
}


BOOL WINAPI
FaxRouteConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    )

/*++

Routine Description:

    This functions is called by the fax service to
    get a property sheet for user configuration of
    the routing extension.

Arguments:

    PropSheetPage       - Handle to a property sheet

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    return TRUE;
}


BOOL WINAPI
FaxRouteItg(
    PFAX_ROUTE FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )

/*++

Routine Description:

    This functions is called by the fax service to
    route a received fax.

Arguments:

    FaxRoute            - Routing information
    FailureData         - Failure data buffer
    FailureDataSize     - Size of failure data buffer

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    DWORD Size;
    WCHAR TiffFileName[MAX_PATH];
    LPWSTR SrcFName = NULL;
    WCHAR DstFName[MAX_PATH];
    LPTSTR FBaseName;
    WCHAR FName[_MAX_FNAME];
    WCHAR Ext[_MAX_EXT];


    Size = sizeof(TiffFileName) / sizeof(WCHAR);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        0,
        TiffFileName,
        &Size))
    {
        return FALSE;
    }

    Size = GetFullPathName(
        TiffFileName,
        0,
        SrcFName,
        &FBaseName
        );

    SrcFName = (LPWSTR) MemAlloc( (Size + 1) * sizeof(WCHAR) );
    if (!SrcFName) {
        return FALSE;
    }

    GetFullPathName(
        TiffFileName,
        Size,
        SrcFName,
        &FBaseName
        );

    _wsplitpath( SrcFName, NULL, NULL, FName, Ext );

    wcscpy( DstFName, FileQueueDir );
    wcscat( DstFName, L"\\" );
    wcscat( DstFName, FName );
    wcscat( DstFName, Ext );

    if (!CopyFile( SrcFName, DstFName, TRUE )) {
        MemFree( SrcFName );
        return FALSE;
    }

    MemFree( SrcFName );

    return TRUE;
}


BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\perfmon\faxperf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxperf.cpp

Abstract:

    This module contains the fax perfom dll code.

Author:

    Wesley Witt (wesw) 22-Aug-1996

--*/

#include <windows.h>
#include <winperf.h>

#include "faxcount.h"
#include "faxperf.h"
#include "faxreg.h"



#define FAX_NUM_PERF_OBJECT_TYPES           1
#define COUNTER_SIZE                        sizeof(DWORD)


#define INBOUND_BYTES_OFFSET                (COUNTER_SIZE                                     )  //   1
#define INBOUND_FAXES_OFFSET                (INBOUND_BYTES_OFFSET               + COUNTER_SIZE)  //   2
#define INBOUND_PAGES_OFFSET                (INBOUND_FAXES_OFFSET               + COUNTER_SIZE)  //   3
#define INBOUND_MINUTES_OFFSET              (INBOUND_PAGES_OFFSET               + COUNTER_SIZE)  //   4
#define INBOUND_FAILED_RECEIVE_OFFSET       (INBOUND_MINUTES_OFFSET             + COUNTER_SIZE)  //   5
#define OUTBOUND_BYTES_OFFSET               (INBOUND_FAILED_RECEIVE_OFFSET      + COUNTER_SIZE)  //   6
#define OUTBOUND_FAXES_OFFSET               (OUTBOUND_BYTES_OFFSET              + COUNTER_SIZE)  //   7
#define OUTBOUND_PAGES_OFFSET               (OUTBOUND_FAXES_OFFSET              + COUNTER_SIZE)  //   8
#define OUTBOUND_MINUTES_OFFSET             (OUTBOUND_PAGES_OFFSET              + COUNTER_SIZE)  //   9
#define OUTBOUND_FAILED_CONNECTIONS_OFFSET  (OUTBOUND_MINUTES_OFFSET            + COUNTER_SIZE)  //  10
#define OUTBOUND_FAILED_XMIT_OFFSET         (OUTBOUND_FAILED_CONNECTIONS_OFFSET + COUNTER_SIZE)  //  11
#define TOTAL_BYTES_OFFSET                  (OUTBOUND_FAILED_XMIT_OFFSET        + COUNTER_SIZE)  //  12
#define TOTAL_FAXES_OFFSET                  (TOTAL_BYTES_OFFSET                 + COUNTER_SIZE)  //  13
#define TOTAL_PAGES_OFFSET                  (TOTAL_FAXES_OFFSET                 + COUNTER_SIZE)  //  14
#define TOTAL_MINUTES_OFFSET                (TOTAL_PAGES_OFFSET                 + COUNTER_SIZE)  //  15
#define LAST_COUNTER_OFFSET                 (TOTAL_MINUTES_OFFSET               + COUNTER_SIZE)  //

#define SIZE_OF_FAX_PERFORMANCE_DATA        LAST_COUNTER_OFFSET

#define PERF_COUNTER_DEFINITION(nm,ty)   \
    {                                    \
        sizeof(PERF_COUNTER_DEFINITION), \
        nm,                              \
        0,                               \
        nm,                              \
        0,                               \
        0,                               \
        PERF_DETAIL_NOVICE,              \
        ty,                              \
        COUNTER_SIZE,                    \
        nm##_OFFSET                      \
    }

#define PERF_COUNTER_INC(nm) \
    FaxDataDefinition.nm##.CounterNameTitleIndex += dwFirstCounter; \
    FaxDataDefinition.nm##.CounterHelpTitleIndex += dwFirstHelp


#pragma pack (4)

typedef struct _FAX_DATA_DEFINITION {
    PERF_OBJECT_TYPE            FaxObjectType;
    PERF_COUNTER_DEFINITION     InboundBytes;
    PERF_COUNTER_DEFINITION     InboundFaxes;
    PERF_COUNTER_DEFINITION     InboundPages;
    PERF_COUNTER_DEFINITION     InboundMinutes;
    PERF_COUNTER_DEFINITION     InboundFailedReceive;
    PERF_COUNTER_DEFINITION     OutboundBytes;
    PERF_COUNTER_DEFINITION     OutboundFaxes;
    PERF_COUNTER_DEFINITION     OutboundPages;
    PERF_COUNTER_DEFINITION     OutboundMinutes;
    PERF_COUNTER_DEFINITION     OutboundFailedConnections;
    PERF_COUNTER_DEFINITION     OutboundFailedXmit;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     TotalFaxes;
    PERF_COUNTER_DEFINITION     TotalPages;
    PERF_COUNTER_DEFINITION     TotalMinutes;
} FAX_DATA_DEFINITION, *PFAX_DATA_DEFINITION;

#pragma pack ()


FAX_DATA_DEFINITION FaxDataDefinition = {
    {
        sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA,
        sizeof(FAX_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        FAXOBJ,
        0,
        FAXOBJ,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(FAX_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/sizeof(PERF_COUNTER_DEFINITION),
        0,
        PERF_NO_INSTANCES,
        0,
    },

    PERF_COUNTER_DEFINITION( INBOUND_BYTES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAXES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_PAGES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_MINUTES,                    PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAILED_RECEIVE,             PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_BYTES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAXES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_PAGES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_MINUTES,                   PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_CONNECTIONS,        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_XMIT,               PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_BYTES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_FAXES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_PAGES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_MINUTES,                      PERF_COUNTER_RAWCOUNT  )

};

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

WCHAR GLOBAL_STRING[]  = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[]  = L"Costly";
WCHAR NULL_STRING[]    = L"\0";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)




DWORD dwOpenCount = 0;
BOOL bInitOK = FALSE;
HANDLE hMap;
PFAX_PERF_COUNTERS PerfCounters;


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

DWORD APIENTRY
OpenFaxPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the Fax Service to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened


Return Value:

    None.

--*/

{
    LONG            status;
    HKEY            hKeyDriverPerf = NULL;
    DWORD           size;
    DWORD           type;
    DWORD           dwFirstCounter;
    DWORD           dwFirstHelp;


    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount) {

        hMap = OpenFileMapping(
            FILE_MAP_READ,
            FALSE,
            FAXPERF_SHARED_MEMORY
            );
        if (!hMap) {
            goto OpenExitPoint;            
        }

        PerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
        if (!PerfCounters) {
            goto OpenExitPoint;            
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REGKEY_FAXPERF,
            0L,
            KEY_READ,
            &hKeyDriverPerf
            );

        if (status != ERROR_SUCCESS) {
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Counter",
            0L,
            &type,
            (LPBYTE)&dwFirstCounter,
            &size
            );

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Help",
            0L,
            &type,
            (LPBYTE)&dwFirstHelp,
            &size
            );

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex += dwFirstCounter;
        FaxDataDefinition.FaxObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        PERF_COUNTER_INC( InboundBytes              );
        PERF_COUNTER_INC( InboundFaxes              );
        PERF_COUNTER_INC( InboundPages              );
        PERF_COUNTER_INC( InboundMinutes            );
        PERF_COUNTER_INC( InboundFailedReceive      );
        PERF_COUNTER_INC( OutboundBytes             );
        PERF_COUNTER_INC( OutboundFaxes             );
        PERF_COUNTER_INC( OutboundPages             );
        PERF_COUNTER_INC( OutboundMinutes           );
        PERF_COUNTER_INC( OutboundFailedConnections );
        PERF_COUNTER_INC( OutboundFailedXmit        );
        PERF_COUNTER_INC( TotalBytes                );
        PERF_COUNTER_INC( TotalFaxes                );
        PERF_COUNTER_INC( TotalPages                );
        PERF_COUNTER_INC( TotalMinutes              );

        RegCloseKey (hKeyDriverPerf); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }

    InterlockedIncrement( (PLONG)&dwOpenCount); // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    if (!bInitOK) {
        if (hKeyDriverPerf) {
            RegCloseKey (hKeyDriverPerf);
        }

        if (PerfCounters) {
            UnmapViewOfFile(PerfCounters);            
        }
        
        if (hMap) {
            CloseHandle( hMap );
        }        
        
    }

    // 
    // the performance APIs log an error in eventvwr if you fail this call
    // so we always return ERROR_SUCCESS so we don't clutter the logs
    //
    //return status;
    return ERROR_SUCCESS;
}


DWORD APIENTRY
CollectFaxPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Fax counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    LPDWORD             pData;
    ULONG               SpaceNeeded;
    DWORD               dwQueryType;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if (!(IsNumberInUnicodeList (FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex, lpValueName))) {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS;
        }
    }

    SpaceNeeded = sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    pData = (LPDWORD) *lppData;

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    CopyMemory(
        pData,
        &FaxDataDefinition,
        sizeof(FAX_DATA_DEFINITION)
        );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_DATA_DEFINITION));

    //
    //  Format and collect Fax data from the service
    //

    *pData = SIZE_OF_FAX_PERFORMANCE_DATA;
    pData += 1;

    CopyMemory( pData, PerfCounters, sizeof(FAX_PERF_COUNTERS) );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_PERF_COUNTERS));

    *lpNumObjectTypes = FAX_NUM_PERF_OBJECT_TYPES;
    *lpcbTotalBytes = (DWORD)((LPBYTE)pData - (LPBYTE)*lppData);
    *lppData = (PVOID) pData;

    return ERROR_SUCCESS;
}


DWORD APIENTRY
CloseFaxPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Fax performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    InterlockedDecrement( (PLONG)&dwOpenCount );
    
    if ((dwOpenCount == 0) && bInitOK) {
        if (PerfCounters) {
            UnmapViewOfFile(PerfCounters);            
            PerfCounters = NULL;
        }
        
        if (hMap) {
            CloseHandle( hMap );
            hMap = NULL;
        }

        bInitOK = FALSE;
    }
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxmon\client16.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    client16.c

Abstract:

    Support for 16-bit (win31 and win95) fax clients

Environment:

        Windows NT fax monitor

Revision History:

        06/02/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxmon.h"
#include "tiffstub.h"
#include "prtcovpg.h"
#include "jobtag.h"


//
// File header for the fax data from downlevel client
//

#define FAX16_SIGNATURE         'NF16'

typedef struct {

    WORD    Magic;              // 'II'
    WORD    Magic2;             // 0x0042
    DWORD   FirstIFDOffset;     // offset to the first IFD
    DWORD   Fax16Signature;     // 'NF16'
    DWORD   CodePage;           // code page use for converting multibyte strings to Unicode

    DWORD   SenderName;         // sender's name string
    DWORD   SenderFaxNumber;    // sender's fax number string
    DWORD   SenderCompany;      // sender's company string
    DWORD   SenderAddress;      // sender's address string
    DWORD   SenderTitle;        // sender's title string
    DWORD   SenderDepartment;   // sender's department string
    DWORD   SenderOffice;       // sender's office location string
    DWORD   SenderHomePhone;    // sender's home phone number string
    DWORD   SenderOfficePhone;  // sender's office phone number string

    DWORD   RecName;            // recipient's name string
    DWORD   RecFaxNumber;       // recipient's fax number string
    DWORD   RecCompany;         // recipient's company string
    DWORD   RecAddress;         // recipient's address string
    DWORD   RecCity;            // recipient's city string
    DWORD   RecState;           // recipient's state string
    DWORD   RecZip;             // recipient's zip code string
    DWORD   RecCountry;         // recipient's country string
    DWORD   RecTitle;           // recipient's title string
    DWORD   RecDepartment;      // recipient's department string
    DWORD   RecOffice;          // recipient's office string
    DWORD   RecHomePhone;       // recipient's home phone number string
    DWORD   RecOfficePhone;     // recipient's office phone number string

    DWORD   SubjectLine;        // subject string
    DWORD   NoteMessage;        // note string
    DWORD   TimeSent;           // time-sent string
    DWORD   BillingCode;        // billing code string

    DWORD   CoverPageFilename;  // cover page filename string
    DWORD   CoverPageDataSize;  // size of embedded cover page file in bytes
    DWORD   CoverPageData;      // offset to beginning of embedded cover page file
    DWORD   NumberOfPages;      // number of pages (not including the cover page)
    DWORD   EmailNotify;        // offset to Email notification address
    DWORD   Reserved[7];        // reserved - must be 0 for now

    //
    // String data and embedded cover page file if any
    //

} FAX16_TIFF_HEADER, *PFAX16_TIFF_HEADER;



LPWSTR
CopyClientStringToUnicode(
    PFAX16_TIFF_HEADER  pFax16Hdr,
    ULONG_PTR               offset
    )

/*++

Routine Description:

    Copy ANSI string from 16-bit clients to Unicode string

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client
    offset - Specifies the starting offset for the ANSI string

Return Value:

    Pointer to the duplicated Unicode string
    NULL if there is an error

--*/

{
    LPSTR   pAnsiStr;
    INT     cch;
    LPWSTR  pUnicodeStr = NULL;

    if (offset != 0) {

        pAnsiStr = (LPSTR) ((LPBYTE) pFax16Hdr + offset);
        cch = strlen(pAnsiStr);

        if (pUnicodeStr = MemAllocZ((cch + 1) * sizeof(WCHAR)))
            MultiByteToWideChar(pFax16Hdr->CodePage, 0, pAnsiStr, cch, pUnicodeStr, cch);
    }

    return pUnicodeStr;
}



VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Dispose of cover page field information

Arguments:

    pCPFields - Points to cover page field information

Return Value:

    NONE

--*/

{



    if (pCPFields != NULL) {

        LPTSTR *ppStr;
        LONG_PTR     count;

        //
        // Free individual cover page field strings.
        // HACK: We assume all fields between RecName and ToList are LPTSTRs.
        //

        ppStr = &pCPFields->RecName;
        count = (offsetof(COVERPAGEFIELDS, ToList) -
                 offsetof(COVERPAGEFIELDS, RecName)) / sizeof(LPTSTR);

        while (count-- > 0) {

            MemFree(*ppStr);
            ppStr++;
        }

        MemFree(pCPFields);
    }
}



PCOVERPAGEFIELDS
CollectFax16CoverPageFields(
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Collect cover page field information  from 16bit client fax job

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client

Return Value:

    Pointer to cover page field information
    NULL if there is an error

--*/

{
    //
    // Map fields in FAX16_TIFF_HEADER to fields in COVERPAGEFIELDS.
    // HACK: We assume all fields between RecName and NumberOfPages are LPTSTRs.
    //

    #define NUM_CPFIELDS ((offsetof(COVERPAGEFIELDS, NumberOfPages) - \
                           offsetof(COVERPAGEFIELDS, RecName)) / sizeof(LPTSTR))

    ULONG_PTR strOffsets[NUM_CPFIELDS] = {

        pFax16Hdr->RecName,
        pFax16Hdr->RecFaxNumber,
        pFax16Hdr->RecCompany,
        pFax16Hdr->RecAddress,
        pFax16Hdr->RecCity,
        pFax16Hdr->RecState,
        pFax16Hdr->RecZip,
        pFax16Hdr->RecCountry,
        pFax16Hdr->RecTitle,
        pFax16Hdr->RecDepartment,
        pFax16Hdr->RecOffice,
        pFax16Hdr->RecHomePhone,
        pFax16Hdr->RecOfficePhone,

        pFax16Hdr->SenderName,
        pFax16Hdr->SenderFaxNumber,
        pFax16Hdr->SenderCompany,
        pFax16Hdr->SenderAddress,
        pFax16Hdr->SenderTitle,
        pFax16Hdr->SenderDepartment,
        pFax16Hdr->SenderOffice,
        pFax16Hdr->SenderHomePhone,
        pFax16Hdr->SenderOfficePhone,

        pFax16Hdr->NoteMessage,
        pFax16Hdr->SubjectLine,
        pFax16Hdr->TimeSent,
    };

    PCOVERPAGEFIELDS pCPFields;
    LPTSTR          *ppStr;
    LONG_PTR         index;

    if ((pCPFields = MemAllocZ(sizeof(COVERPAGEFIELDS))) == NULL)
        return NULL;

    //
    // Convert individual cover page field from ANSI to Unicode string
    //

    for (index=0, ppStr = &pCPFields->RecName; index < NUM_CPFIELDS; index++, ppStr++) {

        if ((strOffsets[index] != 0) &&
            (*ppStr = CopyClientStringToUnicode(pFax16Hdr, strOffsets[index])) == NULL)
        {
            FreeCoverPageFields(pCPFields);
            return NULL;
        }
    }

    //
    // Number of pages printed
    //

    if ((pCPFields->NumberOfPages = MemAllocZ(sizeof(TCHAR) * 16)) == NULL) {

        FreeCoverPageFields(pCPFields);
        return NULL;
    }

    return pCPFields;
}



BOOL
CollectFax16JobParam(
    PFAXPORT            pFaxPort,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR              pBillingCode
    )

/*++

Routine Description:

    Collect 16-bit client fax job parameters

Arguments:

    pFaxPort - Points to a fax port structure
    pCPFields - Points to cover page field information
    pBillingCode - Points to billing code string from 16-bit client

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    //
    // Cover page fields which are passed fax service as parameters
    //

    LPTSTR  pSrcStr[NUM_JOBPARAM_TAGS] = {

        pCPFields->RecFaxNumber,
        pCPFields->RecName,
        pCPFields->SdrFaxNumber,
        pCPFields->SdrName,
        pCPFields->SdrCompany,
        pCPFields->SdrDepartment,
        pBillingCode
    };

    LPTSTR *ppDestStr[NUM_JOBPARAM_TAGS] = {

        (LPTSTR *)&pFaxPort->jobParam.RecipientNumber,
        (LPTSTR *)&pFaxPort->jobParam.RecipientName,
        (LPTSTR *)&pFaxPort->jobParam.Tsid,
        (LPTSTR *)&pFaxPort->jobParam.SenderName,
        (LPTSTR *)&pFaxPort->jobParam.SenderCompany,
        (LPTSTR *)&pFaxPort->jobParam.SenderDept,
        (LPTSTR *)&pFaxPort->jobParam.BillingCode
    };

    INT     size, index;
    LPTSTR  p;

    //
    // Calculate the total length for all parameters
    //

    for (index=size=0; index < NUM_JOBPARAM_TAGS; index++) {

        if (pSrcStr[index])
            size += SizeOfString(pSrcStr[index]);
    }

    //
    // Concatenate all parameters into a single string
    //

    if (size > 0 && (p = pFaxPort->pParameters = MemAllocZ(size))) {

        for (index=0; index < NUM_JOBPARAM_TAGS; index++) {

            if (pSrcStr[index]) {

                *ppDestStr[index] = p;
                _tcscpy(p, pSrcStr[index]);
                p += _tcslen(p) + 1;
            }
        }
    }

    return (pFaxPort->pParameters != NULL);
}



LPTSTR
GetClientCoverPageFile(
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Return the cover page file associated with a 16-bit client fax job

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client

Return Value:

    Points to the name of the cover page file
    NULL if there is an error

--*/

#define SERVER_CP_DIRECTORY TEXT("\\coverpg\\")

{
    LPTSTR  pFilename;

    if (pFax16Hdr->CoverPageFilename) {

        //
        // Use server-based cover page file
        //

        if (pFilename = CopyClientStringToUnicode(pFax16Hdr, pFax16Hdr->CoverPageFilename)) {

            LPTSTR  pServerDir = NULL, p;
            DWORD   cb, len;

            len = (_tcslen(SERVER_CP_DIRECTORY) + _tcslen(pFilename) + 1) * sizeof(TCHAR);

            if (!GetPrinterDriverDirectory(NULL, NULL, 1, NULL, 0, &cb) &&
                GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                (pServerDir = MemAllocZ(cb + len)) &&
                GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE) pServerDir, cb, &cb))
            {
                //
                // Strip off the last component of the driver directory
                // which should be w32<arch>.
                //

                if (p = _tcsrchr(pServerDir, TEXT('\\')))
                    *p = NUL;

                _tcscat(pServerDir, SERVER_CP_DIRECTORY);
                _tcscat(pServerDir, pFilename);

                MemFree(pFilename);
                pFilename = pServerDir;

            } else {

                MemFree(pServerDir);
                MemFree(pFilename);
                pFilename = NULL;
            }
        }

    } else if (pFilename = CreateTempFaxFile()) {

        //
        // Cover page data is embedded in the cover page job
        //  Create a temporary file and copy cover page data into it
        //

        HANDLE  hFile;
        DWORD   cbWritten;
        BOOL    copied = FALSE;

        Assert(pFax16Hdr->CoverPageData != 0 && pFax16Hdr->CoverPageDataSize != 0);

        hFile = CreateFile(pFilename,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS | TRUNCATE_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile != INVALID_HANDLE_VALUE) {

            copied = WriteFile(hFile,
                               (LPBYTE) pFax16Hdr + pFax16Hdr->CoverPageData,
                               pFax16Hdr->CoverPageDataSize,
                               &cbWritten,
                               NULL);

            CloseHandle(hFile);
        }

        if (! copied) {

            Error(("Failed to copy cover page data to a temporary file\n"));
            DeleteFile(pFilename);
            MemFree(pFilename);
            pFilename = NULL;
        }
    }

    return pFilename;
}



LPTSTR
GetBaseNoteFilename(
    VOID
    )

/*++

Routine Description:

    Get the name of base cover page file in system32 directory

Arguments:

    NONE

Return Value:

    Pointer to name of base cover page file
    NULL if there is an error

--*/

#define BASENOTE_FILENAME   TEXT("\\basenote.cov")

{
    TCHAR       systemDir[MAX_PATH];
    LPTSTR      pBaseNoteName = NULL;
    COVDOCINFO  covDocInfo;

    if (GetSystemDirectory(systemDir, MAX_PATH) &&
        (pBaseNoteName = MemAlloc(SizeOfString(systemDir) + SizeOfString(BASENOTE_FILENAME))))
    {
        _tcscpy(pBaseNoteName, systemDir);
        _tcscat(pBaseNoteName, BASENOTE_FILENAME);
        Verbose(("Base cover page filename: %ws\n", pBaseNoteName));

        if (PrintCoverPage(NULL, NULL, pBaseNoteName, &covDocInfo) ||
            ! (covDocInfo.Flags & COVFP_NOTE) ||
            ! (covDocInfo.Flags & COVFP_SUBJECT))
        {
            Error(("Invalid base cover page file: %ws\n", pBaseNoteName));
            MemFree(pBaseNoteName);
            pBaseNoteName = NULL;
        }
    }

    return pBaseNoteName;
}



BOOL
ProcessFax16CoverPage(
    PFAXPORT            pFaxPort,
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Render the cover page for downlevel client into a temporary file

Arguments:

    pFaxPort - Points to a fax port structure
    pFax16Hdr - Pointer to the fax data from downlevel client

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOVERPAGEFIELDS    pCPFields;
    LPTSTR              pBillingCode;
    INT                 result = FALSE;

    //
    // Make sure the recipient's fax number is specified
    //

    if (pFax16Hdr->RecFaxNumber == 0) {

        Error(("No recipient number is specified\n"));
        return FALSE;
    }

    //
    // Collect cover page field information and
    // assemble fax job parameters and
    // create a new temporary file for storing cover page job
    //

    pBillingCode = CopyClientStringToUnicode(pFax16Hdr, pFax16Hdr->BillingCode);

    if ((pCPFields = CollectFax16CoverPageFields(pFax16Hdr)) &&
        CollectFax16JobParam(pFaxPort, pCPFields, pBillingCode) &&
        (pFaxPort->pFilename = CreateTempFaxFile()))
    {
        LPTSTR      pCPFilename = NULL;
        LPTSTR      pBaseNoteName = NULL;
        DWORD       pageCount = pFax16Hdr->NumberOfPages;
        BOOL        renderCP;
        COVDOCINFO  covDocInfo;

        //
        // Check if cover page is requested - either a server cover page filename
        // is specified or the cover page data is embedded in the file.
        //

        renderCP = (pFax16Hdr->CoverPageFilename ||
                    (pFax16Hdr->CoverPageDataSize && pFax16Hdr->CoverPageData));

        ZeroMemory(&covDocInfo, sizeof(covDocInfo));

        if (renderCP) {

            if (pCPFilename = GetClientCoverPageFile(pFax16Hdr)) {

                //
                // Find out if the specified cover page contains note/subject fields
                //

                DWORD ec = PrintCoverPage( NULL, NULL, pCPFilename, &covDocInfo );
                if (ec) {
                    Error(( "Cannot examine cover page: %d\n", ec ));
                }

                result = TRUE;
                pageCount++;
            }

        } else
            result = TRUE;

        //
        // Calculate the total number of pages including cover page(s)
        //

        if (((pCPFields->Note &&
              !IsEmptyString(pCPFields->Note) &&
              !(covDocInfo.Flags & COVFP_NOTE)) ||

             (pCPFields->Subject &&
              !IsEmptyString(pCPFields->Subject) &&
              !(covDocInfo.Flags & COVFP_SUBJECT))) &&

            (pBaseNoteName = GetBaseNoteFilename()))
        {
            renderCP = TRUE;
            pageCount++;
        }

        wsprintf(pCPFields->NumberOfPages, TEXT("%d"), pageCount);

        //
        // Render the fax cover page(s)
        //

        if (result && renderCP) {

            DOCINFO docinfo;
            HDC     hdc = NULL;
            DEVMODE devmode, *pDevmode;

            ZeroMemory(&docinfo, sizeof(docinfo));
            docinfo.cbSize = sizeof(docinfo);
            docinfo.lpszDocName = TEXT("faxmon");
            docinfo.lpszOutput = pFaxPort->pFilename;
            renderCP = FALSE;

            if (covDocInfo.PaperSize > 0) {

                ZeroMemory(&devmode, sizeof(devmode));
                _tcsncpy(devmode.dmDeviceName, pFaxPort->pPrinterName, CCHDEVICENAME);

                devmode.dmSpecVersion = DM_SPECVERSION;
                devmode.dmSize = sizeof(devmode);

                devmode.dmFields = DM_PAPERSIZE|DM_ORIENTATION;
                devmode.dmPaperSize = covDocInfo.PaperSize;
                devmode.dmOrientation = covDocInfo.Orientation;

                pDevmode = &devmode;

            } else
                pDevmode = NULL;

            if ((hdc = CreateDC(NULL, pFaxPort->pPrinterName, NULL, pDevmode)) &&
                (StartDoc(hdc, &docinfo) > 0))
            {
                //
                // Render the user specified cover page
                //

                if (pCPFilename) {

                    if (StartPage(hdc) > 0) {

                        renderCP = PrintCoverPage(hdc, pCPFields, pCPFilename, &covDocInfo) == 0 ? TRUE : FALSE;
                        EndPage(hdc);
                    }

                } else
                    renderCP = TRUE;

                //
                // Render the extra cover page for note and subject
                //

                if (pBaseNoteName && renderCP) {

                    if (StartPage(hdc) > 0) {

                        renderCP = PrintCoverPage(hdc, pCPFields, pBaseNoteName, &covDocInfo) == 0 ? TRUE : FALSE;
                        EndPage(hdc);

                    } else
                        renderCP = FALSE;
                }

                if (renderCP)
                    EndDoc(hdc);
                else
                    AbortDoc(hdc);
            }

            result = renderCP;

            if (hdc)
                DeleteDC(hdc);
        }

        //
        // In the embedded cover page data case, we created a temporary
        // cover page file earlier. So delete it here.
        //

        if (pCPFilename && !pFax16Hdr->CoverPageFilename)
            DeleteFile(pCPFilename);

        MemFree(pCPFilename);
        MemFree(pBaseNoteName);
    }

    FreeCoverPageFields(pCPFields);
    MemFree(pBillingCode);

    //
    // Open the cover page TIFF file if there was no error
    //

    return result && OpenTempFaxFile(pFaxPort, TRUE);
}



BOOL
ConcatFax16Data(
    PFAXPORT            pFaxPort,
    PFAX16_TIFF_HEADER  pFax16Hdr,
    DWORD               size
    )

/*++

Routine Description:

    Concatenate the fax data from downlevel client to the end of cover page TIFF file

Arguments:

    pFaxPort - Points to a fax port structure
    pFax16Hdr - Pointer to the fax data from downlevel client
    size - Size of the fax data from downlevel client

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   bytesWritten;

    return (pFax16Hdr->NumberOfPages == 0) ||
           (WriteFile(pFaxPort->hFile, pFax16Hdr, size, &bytesWritten, NULL) &&
            bytesWritten == size);
}



INT
ProcessDownlevelFaxJob(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Process fax jobs sent from win31 and win95 clients

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    error code FAXERR_*

--*/

{
    DWORD   fileSize;
    LPVOID  pFileView = NULL;
    HANDLE  hFileMap = NULL;
    INT     result = FAXERR_BAD_DATA16;
    LPTSTR  pOrigFilename;

    //
    // Get the size of fax job file
    //

    FlushFileBuffers(pFaxPort->hFile);

    if ((fileSize = GetFileSize(pFaxPort->hFile, NULL)) == 0xffffffff ||
        (fileSize < sizeof(DWORD) * 2))
    {
        return FAXERR_FATAL;
    }

    //
    // Map the fax job data into memory
    //

    if (hFileMap = CreateFileMapping(pFaxPort->hFile, NULL, PAGE_READONLY, 0, 0, NULL))
        pFileView = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, fileSize);

    CloseHandle(pFaxPort->hFile);
    pFaxPort->hFile = INVALID_HANDLE_VALUE;

    pOrigFilename = pFaxPort->pFilename;
    pFaxPort->pFilename = NULL;

    __try {

        PFAX16_TIFF_HEADER  pFax16Hdr = pFileView;

        //
        // Validate the fax data from the downlevel client
        //

        if (hFileMap != NULL &&
            pFileView != NULL &&
            ValidTiffFileHeader(pFileView) &&
            pFax16Hdr->Fax16Signature == FAX16_SIGNATURE)
        {
            //
            // Render the cover page into a temporary TIFF file
            // and concatenate the original TIFF data at the end
            //

            if (ProcessFax16CoverPage(pFaxPort, pFax16Hdr) &&
                ConcatFax16Data(pFaxPort, pFax16Hdr, fileSize))
            {
                result = FAXERR_NONE;

            } else {

                Error(("Error processing downlevel fax job\n"));
                result = FAXERR_FATAL;
            }

        } else {

            Error(("Bad TIFF file from downlevel fax client\n"));
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        Error(("Access violation while reading downlevel fax job\n"));
    }

    //
    // Perform necessary cleanup before returning to caller
    //

    if (pFileView)
        UnmapViewOfFile(pFileView);

    if (hFileMap)
        CloseHandle(hFileMap);

    DeleteFile(pOrigFilename);
    MemFree(pOrigFilename);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\faxtable.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtable.h

Abstract:

    Tables used for Group3 fax compression

Environment:

	Windows NT Fax driver, kernel mode

Revision History:

	01/23/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FAXTABLE_H_
#define _FAXTABLE_H_

//
// Data structure for representing code table entries
//

typedef struct {

    WORD    length;     // code length
    WORD    code;       // code word itself

} CODETABLE;

typedef const CODETABLE *PCODETABLE;

//
// Code word for end-of-line (EOL)
//  000000000001
//

#define EOL_CODE        1
#define EOL_LENGTH      12

//
// Code word for 2D encoding - pass mode
//  0001
//

#define PASSCODE        1
#define PASSCODE_LENGTH 4

//
// Code word for 2D encoding - horizontal mode prefix
//  001
//

#define HORZCODE        1
#define HORZCODE_LENGTH 3

//
// Code word for 2D encoding - vertical mode
//

static const CODETABLE VertCodes[] = {

    {  7, 0x02 },       // 0000010         VL3
    {  6, 0x02 },       // 000010          VL2
    {  3, 0x02 },       // 010             VL1
    {  1, 0x01 },       // 1                V0
    {  3, 0x03 },       // 011             VR1
    {  6, 0x03 },       // 000011          VR2
    {  7, 0x03 },       // 0000011         VR3
};

//
// Code table for white runs
//

static const CODETABLE WhiteRunCodes[] = {
    
    {  8, 0x35 },       // 00110101          0
    {  6, 0x07 },       // 000111            1
    {  4, 0x07 },       // 0111              2
    {  4, 0x08 },       // 1000              3
    {  4, 0x0b },       // 1011              4
    {  4, 0x0c },       // 1100              5
    {  4, 0x0e },       // 1110              6
    {  4, 0x0f },       // 1111              7
    {  5, 0x13 },       // 10011             8
    {  5, 0x14 },       // 10100             9
    {  5, 0x07 },       // 00111            10
    {  5, 0x08 },       // 01000            11
    {  6, 0x08 },       // 001000           12
    {  6, 0x03 },       // 000011           13
    {  6, 0x34 },       // 110100           14
    {  6, 0x35 },       // 110101           15
    {  6, 0x2a },       // 101010           16
    {  6, 0x2b },       // 101011           17
    {  7, 0x27 },       // 0100111          18
    {  7, 0x0c },       // 0001100          19
    {  7, 0x08 },       // 0001000          20
    {  7, 0x17 },       // 0010111          21
    {  7, 0x03 },       // 0000011          22
    {  7, 0x04 },       // 0000100          23
    {  7, 0x28 },       // 0101000          24
    {  7, 0x2b },       // 0101011          25
    {  7, 0x13 },       // 0010011          26
    {  7, 0x24 },       // 0100100          27
    {  7, 0x18 },       // 0011000          28
    {  8, 0x02 },       // 00000010         29
    {  8, 0x03 },       // 00000011         30
    {  8, 0x1a },       // 00011010         31
    {  8, 0x1b },       // 00011011         32
    {  8, 0x12 },       // 00010010         33
    {  8, 0x13 },       // 00010011         34
    {  8, 0x14 },       // 00010100         35
    {  8, 0x15 },       // 00010101         36
    {  8, 0x16 },       // 00010110         37
    {  8, 0x17 },       // 00010111         38
    {  8, 0x28 },       // 00101000         39
    {  8, 0x29 },       // 00101001         40
    {  8, 0x2a },       // 00101010         41
    {  8, 0x2b },       // 00101011         42
    {  8, 0x2c },       // 00101100         43
    {  8, 0x2d },       // 00101101         44
    {  8, 0x04 },       // 00000100         45
    {  8, 0x05 },       // 00000101         46
    {  8, 0x0a },       // 00001010         47
    {  8, 0x0b },       // 00001011         48
    {  8, 0x52 },       // 01010010         49
    {  8, 0x53 },       // 01010011         50
    {  8, 0x54 },       // 01010100         51
    {  8, 0x55 },       // 01010101         52
    {  8, 0x24 },       // 00100100         53
    {  8, 0x25 },       // 00100101         54
    {  8, 0x58 },       // 01011000         55
    {  8, 0x59 },       // 01011001         56
    {  8, 0x5a },       // 01011010         57
    {  8, 0x5b },       // 01011011         58
    {  8, 0x4a },       // 01001010         59
    {  8, 0x4b },       // 01001011         60
    {  8, 0x32 },       // 00110010         61
    {  8, 0x33 },       // 00110011         62
    {  8, 0x34 },       // 00110100         63
    {  5, 0x1b },       // 11011            64
    {  5, 0x12 },       // 10010           128
    {  6, 0x17 },       // 010111          192
    {  7, 0x37 },       // 0110111         256
    {  8, 0x36 },       // 00110110        320
    {  8, 0x37 },       // 00110111        384
    {  8, 0x64 },       // 01100100        448
    {  8, 0x65 },       // 01100101        512
    {  8, 0x68 },       // 01101000        576
    {  8, 0x67 },       // 01100111        640
    {  9, 0xcc },       // 011001100       704
    {  9, 0xcd },       // 011001101       768
    {  9, 0xd2 },       // 011010010       832
    {  9, 0xd3 },       // 011010011       896
    {  9, 0xd4 },       // 011010100       960
    {  9, 0xd5 },       // 011010101      1024
    {  9, 0xd6 },       // 011010110      1088
    {  9, 0xd7 },       // 011010111      1152
    {  9, 0xd8 },       // 011011000      1216
    {  9, 0xd9 },       // 011011001      1280
    {  9, 0xda },       // 011011010      1344
    {  9, 0xdb },       // 011011011      1408
    {  9, 0x98 },       // 010011000      1472
    {  9, 0x99 },       // 010011001      1536
    {  9, 0x9a },       // 010011010      1600
    {  6, 0x18 },       // 011000         1664
    {  9, 0x9b },       // 010011011      1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

//
// Code table for black runs
//

static const CODETABLE BlackRunCodes[] = {
    
    { 10, 0x37 },       // 0000110111        0
    {  3, 0x02 },       // 010               1
    {  2, 0x03 },       // 11                2
    {  2, 0x02 },       // 10                3
    {  3, 0x03 },       // 011               4
    {  4, 0x03 },       // 0011              5
    {  4, 0x02 },       // 0010              6
    {  5, 0x03 },       // 00011             7
    {  6, 0x05 },       // 000101            8
    {  6, 0x04 },       // 000100            9
    {  7, 0x04 },       // 0000100          10
    {  7, 0x05 },       // 0000101          11
    {  7, 0x07 },       // 0000111          12
    {  8, 0x04 },       // 00000100         13
    {  8, 0x07 },       // 00000111         14
    {  9, 0x18 },       // 000011000        15
    { 10, 0x17 },       // 0000010111       16
    { 10, 0x18 },       // 0000011000       17
    { 10, 0x08 },       // 0000001000       18
    { 11, 0x67 },       // 00001100111      19
    { 11, 0x68 },       // 00001101000      20
    { 11, 0x6c },       // 00001101100      21
    { 11, 0x37 },       // 00000110111      22
    { 11, 0x28 },       // 00000101000      23
    { 11, 0x17 },       // 00000010111      24
    { 11, 0x18 },       // 00000011000      25
    { 12, 0xca },       // 000011001010     26
    { 12, 0xcb },       // 000011001011     27
    { 12, 0xcc },       // 000011001100     28
    { 12, 0xcd },       // 000011001101     29
    { 12, 0x68 },       // 000001101000     30
    { 12, 0x69 },       // 000001101001     31
    { 12, 0x6a },       // 000001101010     32
    { 12, 0x6b },       // 000001101011     33
    { 12, 0xd2 },       // 000011010010     34
    { 12, 0xd3 },       // 000011010011     35
    { 12, 0xd4 },       // 000011010100     36
    { 12, 0xd5 },       // 000011010101     37
    { 12, 0xd6 },       // 000011010110     38
    { 12, 0xd7 },       // 000011010111     39
    { 12, 0x6c },       // 000001101100     40
    { 12, 0x6d },       // 000001101101     41
    { 12, 0xda },       // 000011011010     42
    { 12, 0xdb },       // 000011011011     43
    { 12, 0x54 },       // 000001010100     44
    { 12, 0x55 },       // 000001010101     45
    { 12, 0x56 },       // 000001010110     46
    { 12, 0x57 },       // 000001010111     47
    { 12, 0x64 },       // 000001100100     48
    { 12, 0x65 },       // 000001100101     49
    { 12, 0x52 },       // 000001010010     50
    { 12, 0x53 },       // 000001010011     51
    { 12, 0x24 },       // 000000100100     52
    { 12, 0x37 },       // 000000110111     53
    { 12, 0x38 },       // 000000111000     54
    { 12, 0x27 },       // 000000100111     55
    { 12, 0x28 },       // 000000101000     56
    { 12, 0x58 },       // 000001011000     57
    { 12, 0x59 },       // 000001011001     58
    { 12, 0x2b },       // 000000101011     59
    { 12, 0x2c },       // 000000101100     60
    { 12, 0x5a },       // 000001011010     61
    { 12, 0x66 },       // 000001100110     62
    { 12, 0x67 },       // 000001100111     63
    { 10, 0x0f },       // 0000001111       64
    { 12, 0xc8 },       // 000011001000    128
    { 12, 0xc9 },       // 000011001001    192
    { 12, 0x5b },       // 000001011011    256
    { 12, 0x33 },       // 000000110011    320
    { 12, 0x34 },       // 000000110100    384
    { 12, 0x35 },       // 000000110101    448
    { 13, 0x6c },       // 0000001101100   512
    { 13, 0x6d },       // 0000001101101   576
    { 13, 0x4a },       // 0000001001010   640
    { 13, 0x4b },       // 0000001001011   704
    { 13, 0x4c },       // 0000001001100   768
    { 13, 0x4d },       // 0000001001101   832
    { 13, 0x72 },       // 0000001110010   896
    { 13, 0x73 },       // 0000001110011   960
    { 13, 0x74 },       // 0000001110100  1024
    { 13, 0x75 },       // 0000001110101  1088
    { 13, 0x76 },       // 0000001110110  1152
    { 13, 0x77 },       // 0000001110111  1216
    { 13, 0x52 },       // 0000001010010  1280
    { 13, 0x53 },       // 0000001010011  1344
    { 13, 0x54 },       // 0000001010100  1408
    { 13, 0x55 },       // 0000001010101  1472
    { 13, 0x5a },       // 0000001011010  1536
    { 13, 0x5b },       // 0000001011011  1600
    { 13, 0x64 },       // 0000001100100  1664
    { 13, 0x65 },       // 0000001100101  1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

#ifdef USELSB

//
// Table used to reverse fill order from MSB to LSB
//

static const BYTE BitReverseTable[256] = {

    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

#endif

#endif	// !_FAXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\enable.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of device and surface related DDI entry points:

        DrvEnableDriver
        DrvDisableDriver
        DrvEnablePDEV
        DrvResetPDEV
        DrvCompletePDEV
        DrvDisablePDEV
        DrvEnableSurface
        DrvDisableSurface
        DrvBitBlt
        DrvStretchBlt
        DrvDitherColor
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"
#include "forms.h"

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

static DRVFN FaxDriverFuncs[] =
{
    { INDEX_DrvEnablePDEV,          (PFN) DrvEnablePDEV         },
    { INDEX_DrvResetPDEV,           (PFN) DrvResetPDEV          },
    { INDEX_DrvCompletePDEV,        (PFN) DrvCompletePDEV       },
    { INDEX_DrvDisablePDEV,         (PFN) DrvDisablePDEV        },
    { INDEX_DrvEnableSurface,       (PFN) DrvEnableSurface      },
    { INDEX_DrvDisableSurface,      (PFN) DrvDisableSurface     },

    { INDEX_DrvStartDoc,            (PFN) DrvStartDoc           },
    { INDEX_DrvEndDoc,              (PFN) DrvEndDoc             },
    { INDEX_DrvStartPage,           (PFN) DrvStartPage          },
    { INDEX_DrvSendPage,            (PFN) DrvSendPage           },

    { INDEX_DrvBitBlt,              (PFN) DrvBitBlt             },
    { INDEX_DrvStretchBlt,          (PFN) DrvStretchBlt         },
    { INDEX_DrvCopyBits,            (PFN) DrvCopyBits           },
    { INDEX_DrvDitherColor,         (PFN) DrvDitherColor        },
    { INDEX_DrvEscape,              (PFN) DrvEscape             },
};

//
// Forward declaration of local functions
//

VOID SelectPrinterForm(PDEVDATA);
BOOL FillDevInfo(PDEVDATA, ULONG, PVOID);
BOOL FillGdiInfo(PDEVDATA, ULONG, PVOID);
VOID FreeDevData(PDEVDATA);



HINSTANCE   ghInstance;


BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
    case DRVQUERY_USERMODE:

        Assert(pcbNeeded != NULL);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;

    default:

        Error(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}



BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pDrvEnableData
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    iEngineVersion - Specifies the DDI version number that GDI is written for
    cb - Size of the buffer pointed to by pDrvEnableData
    pDrvEnableData - Points to an DRVENABLEDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvEnableDriver...\n"));

    //
    // Make sure we have a valid engine version and
    // we're given enough room for the DRVENABLEDATA.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION || cb < sizeof(DRVENABLEDATA)) {

        Error(("DrvEnableDriver failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }

    //
    // Fill in the DRVENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = DDI_DRIVER_VERSION;
    pDrvEnableData->c = sizeof(FaxDriverFuncs) / sizeof(DRVFN);
    pDrvEnableData->pdrvfn = FaxDriverFuncs;

    return TRUE;
}



DHPDEV
DrvEnablePDEV(
    PDEVMODE  pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pGdiInfo,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    pdm - Points to a DEVMODE structure that contains driver data
    pLogAddress - Points to the logical address string
    cPatterns - Specifies the number of standard patterns
    phsurfPatterns - Buffer to hold surface handles to standard patterns
    cjGdiInfo - Size of GDIINFO buffer
    pGdiInfo - Points to a GDIINFO structure
    cjDevInfo - Size of DEVINFO buffer
    pDevInfo - Points to a DEVINFO structure
    hdev - GDI device handle
    pDeviceName - Points to device name string
    hPrinter - Spooler printer handle

Return Value:

    Driver device handle, NULL if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvEnablePDEV...\n"));

    //
    // Allocate memory for our DEVDATA structure and initialize it
    //

    if (! (pdev = MemAllocZ(sizeof(DEVDATA)))) {

        Error(("Memory allocation failed\n"));
        return NULL;
    }

    pdev->hPrinter = hPrinter;
    pdev->startDevData = pdev;
    pdev->endDevData = pdev;

    //
    // Save and validate DEVMODE information
    //  start with the driver default
    //  then merge with the system default
    //  finally merge with the input devmode
    //

    if (CurrentVersionDevmode(pdm)) {

        memcpy(&pdev->dm, pdm, sizeof(DRVDEVMODE));

        //
        // NOTE: We now use dmPrintQuality and dmYResolution fields
        // to store the resolution measured in dots-per-inch. Add
        // the following check as a safety precaution in case older
        // DEVMODE is passed to us.
        //

        if (pdev->dm.dmPublic.dmPrintQuality <= 0 ||
            pdev->dm.dmPublic.dmYResolution <= 0)
        {
            pdev->dm.dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
            pdev->dm.dmPublic.dmYResolution = FAXRES_VERTICAL;
        }

    } else {

        Error(("Bad DEVMODE passed to DrvEnablePDEV\n"));
        DriverDefaultDevmode(&pdev->dm, NULL, hPrinter);
    }

    //
    // Calculate the paper size information
    //

    SelectPrinterForm(pdev);

    //
    // Fill out GDIINFO and DEVINFO structure
    //

    if (! FillGdiInfo(pdev, cjGdiInfo, pGdiInfo) ||
        ! FillDevInfo(pdev, cjDevInfo, pDevInfo))
    {
        FreeDevData(pdev);
        return NULL;
    }

    //
    // Zero out the array of HSURF's so that the engine will
    // automatically simulate the standard patterns for us
    //

    memset(phsurfPatterns, 0, sizeof(HSURF) * cPatterns);

    //
    // Return a pointer to our DEVDATA structure
    //

    return (DHPDEV) pdev;
}



BOOL
DrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvResetPDEV.
    Please refer to DDK documentation for more details.

Arguments:

    phpdevOld - Driver handle to the old device
    phpdevNew - Driver handle to the new device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdevOld, pdevNew;

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Validate both old and new device
    //

    pdevOld = (PDEVDATA) dhpdevOld;
    pdevNew = (PDEVDATA) dhpdevNew;

    if (! ValidDevData(pdevOld) || ! ValidDevData(pdevNew)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Transfer information from old device to new device
    //

    if (pdevOld->pageCount != 0) {

        pdevNew->pageCount = pdevOld->pageCount;
        pdevNew->flags |= PDEV_RESETPDEV;
        pdevNew->fileOffset = pdevOld->fileOffset;

        if (pdevOld->pFaxIFD) {

            pdevNew->pFaxIFD = pdevOld->pFaxIFD;
            pdevOld->pFaxIFD = NULL;
        }
    }

    //
    // Carry over relevant flag bits
    //

    pdevNew->flags |= pdevOld->flags & PDEV_CANCELLED;

    return TRUE;
}



VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCompletePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    hdev - GDI device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvCompletePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Remember the engine's handle to the physical device
    //

    pdev->hdev = hdev;
}



HSURF
DrvEnableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    Handle to newly created surface, NULL if there is an error

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;
    FLONG       flHooks;

    Verbose(("Entering DrvEnableSurface...\n"));

    //
    // Validate the pointer to our DEVDATA structure
    //

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Adjust the bitmap size so that we always end up with 1728 pixels per scanline
    //

    Assert(MAX_WIDTH_PIXELS % DWORDBITS == 0);

    if (IsLandscapeMode(pdev)) {

        Assert(pdev->imageSize.cy <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cy = MAX_WIDTH_PIXELS;
        pdev->imageSize.cx = ((pdev->imageSize.cx + (BYTEBITS - 1)) / BYTEBITS) * BYTEBITS;

    } else {

        Assert(pdev->imageSize.cx <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cx = MAX_WIDTH_PIXELS;
    }

    pdev->lineOffset = PadBitsToBytes(pdev->imageSize.cx, sizeof(DWORD));

    //
    // Call the engine to create a standard bitmap surface for us
    //

    pdev->hbitmap = (HSURF) EngCreateBitmap(pdev->imageSize,
                                            pdev->lineOffset,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT | BMF_USERMEM,
                                            NULL);

    if (pdev->hbitmap == NULL) {

        Error(("EngCreateBitmap failed\n"));
        return NULL;
    }

    //
    // Associate the surface with the device and inform the
    // engine which functions we have hooked out
    //

    if (pdev->dm.dmPrivate.flags & FAXDM_NO_HALFTONE)
        flHooks = 0;
    else
        flHooks = (HOOK_STRETCHBLT | HOOK_BITBLT | HOOK_COPYBITS);

    EngAssociateSurface(pdev->hbitmap, pdev->hdev, flHooks);

    //
    // Return the surface handle to the engine
    //

    return pdev->hbitmap;
}



VOID
DrvDisableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisableSurface...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Call the engine to delete the surface handle
    //

    if (pdev->hbitmap != NULL) {

        EngDeleteSurface(pdev->hbitmap);
        pdev->hbitmap = NULL;
    }
}



VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisablePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Free up memory allocated for the current PDEV
    //

    FreeDevData(pdev);
}



VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    Verbose(("Entering DrvDisableDriver...\n"));
}



BOOL
IsCompatibleSurface(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    XLATEOBJ   *pxlo
    )

/*++

Routine Description:

    Check if the source surface is compatible with the destination surface
    i.e. we can bitblt without halftonig

Arguments:

    psoDst - Specifies the destination surface
    psoSrc - Specifies the source surface
    pxlo - How to transform colors between the source surface and the destination surface

Return Value:

    TRUE if the source surface is compatible with the destination surface
    FALSE otherwise

--*/

{
    BOOL result;

    //
    // We know our destination surface is always 1bpp
    //

    Assert(psoDst->iBitmapFormat == BMF_1BPP);

    //
    // Check whether the transformation is trivial
    //

    if (!pxlo || (pxlo->flXlate & XO_TRIVIAL)) {

        result = (psoSrc->iBitmapFormat == psoDst->iBitmapFormat);

    } else if ((pxlo->flXlate & XO_TABLE) && pxlo->cEntries <= 2) {
        
        ULONG srcPalette[2];

        srcPalette[0] = srcPalette[1] = RGB_BLACK;
        XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, pxlo->cEntries, srcPalette);

        result = (srcPalette[0] == RGB_BLACK || srcPalette[0] == RGB_WHITE) &&
                 (srcPalette[1] == RGB_BLACK || srcPalette[1] == RGB_WHITE);

    } else
        result = FALSE;

    return result;
}



BOOL
DrvCopyBits(
    SURFOBJ    *psoTrg,   
    SURFOBJ    *psoSrc,    
    CLIPOBJ    *pco,   
    XLATEOBJ   *pxlo, 
    RECTL      *prclDst, 
    POINTL     *pptlSrc 
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    Verbose(("Entering DrvCopyBits ...\n"));
    
    //
    // Check if halftoning is necessary
    // If not, let the engine handle it
    //

    if ((psoSrc->iType != STYPE_BITMAP) ||
        (psoTrg->iType != STYPE_BITMAP) ||
        IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        return EngCopyBits(psoTrg, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {
        POINTL  ptlBrushOrg;
        RECTL   rclDst, rclSrc;

        ptlBrushOrg.x = ptlBrushOrg.y = 0;

        rclDst        = *prclDst;
        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy))
        {
            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;
            rclDst.right  = rclDst.left + (rclSrc.right - rclSrc.left);
            rclDst.bottom = rclDst.top  + (rclSrc.bottom - rclSrc.top);
        }

        return EngStretchBlt(psoTrg,
                             psoSrc,
                             NULL,
                             pco,
                             pxlo,
                             &DefHTClrAdj,
                             &ptlBrushOrg,
                             &rclDst,
                             &rclSrc,
                             NULL,
                             HALFTONE);
    }
}



BOOL
DrvBitBlt(
    SURFOBJ    *psoTrg,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclTrg,
    POINTL     *pptlSrc,
    POINTL     *pptlMask,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrush,
    ROP4        rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    COLORADJUSTMENT *pca;
    PDEVDATA        pdev;
    DWORD           rop3Foreground, rop3Background;
    SURFOBJ         *psoNewSrc;
    HBITMAP         hbmpNewSrc;
    POINTL          brushOrg;
    BOOL            result;

    Verbose(("Entering DrvBitBlt...\n"));
    
    //
    // Validate input parameters
    //

    Assert(psoTrg != NULL);
    pdev = (PDEVDATA) psoTrg->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Use the system default color adjustment information
    //

    pca = &DefHTClrAdj;

    //
    // Figure out the foreground and background ROP3
    //

    psoNewSrc = NULL;
    hbmpNewSrc = NULL;
    rop3Foreground = GetForegroundRop3(rop4);
    rop3Background = GetBackgroundRop3(rop4);

    if ((Rop3NeedPattern(rop3Foreground) || Rop3NeedPattern(rop3Background)) && pptlBrush) {

        brushOrg = *pptlBrush;

    } else {

        brushOrg.x = brushOrg.y = 0;
    }

    //
    // If a source bitmap is involved in the raster operation and
    // the source is not compatible with the destination surface,
    // then we'll halftone the source bitmap into a new bitmap and
    // bitblt the new bitmap onto the destination surface.
    //

    if ((Rop3NeedSource(rop3Foreground) || Rop3NeedSource(rop3Background)) &&
        !IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        RECTL   rclNewSrc, rclOldSrc;
        SIZEL   bmpSize;
        LONG    lDelta;

        rclNewSrc.left = rclNewSrc.top = 0;
        rclNewSrc.right = prclTrg->right - prclTrg->left;
        rclNewSrc.bottom = prclTrg->bottom - prclTrg->top;

        rclOldSrc.left = pptlSrc->x;
        rclOldSrc.top = pptlSrc->y;
        rclOldSrc.right = rclOldSrc.left + rclNewSrc.right;
        rclOldSrc.bottom = rclOldSrc.top + rclNewSrc.bottom;

        //
        // Express path for the most common case: SRCCOPY
        //

        if (rop4 == 0xcccc) {

            return EngStretchBlt(psoTrg,
                                 psoSrc,
                                 psoMask,
                                 pco,
                                 pxlo,
                                 pca,
                                 &brushOrg,
                                 prclTrg,
                                 &rclOldSrc,
                                 pptlMask,
                                 HALFTONE);
        }

        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's (0, 0) minus the original location
        //

        brushOrg.x -= prclTrg->left;
        brushOrg.y -= prclTrg->top;

        //
        // Create a temporary bitmap surface
        // Halftone the source bitmap into the temporary bitmap
        //

        Assert(psoTrg->iBitmapFormat == BMF_1BPP);

        bmpSize.cx = rclNewSrc.right;
        bmpSize.cy = rclNewSrc.bottom;
        lDelta = PadBitsToBytes(bmpSize.cx, sizeof(DWORD));

        if (! (hbmpNewSrc = EngCreateBitmap(bmpSize,
                                            lDelta,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT,
                                            NULL)) ||
            ! EngAssociateSurface((HSURF) hbmpNewSrc, pdev->hdev, 0) ||
            ! (psoNewSrc = EngLockSurface((HSURF) hbmpNewSrc)) ||
            ! EngStretchBlt(psoNewSrc,
                            psoSrc,
                            NULL,
                            NULL,
                            pxlo,
                            pca,
                            &brushOrg,
                            &rclNewSrc,
                            &rclOldSrc,
                            NULL,
                            HALFTONE))
        {
            if (psoNewSrc)
                EngUnlockSurface(psoNewSrc);
        
            if (hbmpNewSrc)
                EngDeleteSurface((HSURF) hbmpNewSrc);

            return FALSE;
        }

        //
        // Proceed to bitblt from the temporary bitmap to the destination
        //

        psoSrc = psoNewSrc;
        pptlSrc = (PPOINTL) &rclNewSrc.left;
        pxlo = NULL;
        brushOrg.x = brushOrg.y = 0;
    }

    //
    // Let engine do the work
    //

    result = EngBitBlt(psoTrg,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclTrg,
                       pptlSrc,
                       pptlMask,
                       pbo,
                       &brushOrg,
                       rop4);

    //
    // Clean up properly before returning
    //

    if (psoNewSrc)
        EngUnlockSurface(psoNewSrc);

    if (hbmpNewSrc)
        EngDeleteSurface((HSURF) hbmpNewSrc);

    return result;
}



BOOL
DrvStretchBlt(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    COLORADJUSTMENT  *pca,
    POINTL     *pptlBrushOrg,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    POINTL     *pptlMask,
    ULONG       iMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvStretchBlt...\n"));

    //
    // If no color adjustment information is provided, use the system default 
    //

    if (pca == NULL)
        pca = &DefHTClrAdj;

    //
    // Let engine do the work; make sure halftone is enabled
    //

    return EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         HALFTONE);
}



ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgb,
    ULONG  *pul
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iMode - Determines the palette to dither against
    rgb - Specifies the RGB color that is to be dithered
    pul - Points to a memory location in which the dithering information is to be recorded

Return Value:

    DCR_HALFTONE to indicate that the engine should create a halftone
    approximation for the driver.

--*/

{
    return DCR_HALFTONE;
}



BOOL
FillDevInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pdevinfo
    )

/*++

Routine Description:

    Fill in the DEVINFO structure pointed to by pdevinfo.

Arguments:

    pdev - Pointer to our DEVDATA structure
    cb - Size of structure pointed to by pdevinfo
    pdevinfo - Pointer to DEVINFO structure

[Notes:]

    Since we have to worry about not writing out more than cb bytes to
    pdevinfo, we will first fill in a local buffer, then copy cb bytes
    to pdevinfo.

Return Value:

    TRUE if successful. FALSE otherwise.

--*/

{
    static ULONG paletteColors[2] = {

        RGB_BLACK,
        RGB_WHITE,
    };

    DEVINFO devinfo;

    memset(&devinfo, 0, sizeof(devinfo));

    //
    // Fill in the graphics capabilities flags: we let the engine
    // do almost everything. Also, we have to tell the engine not
    // to do metafile spooling because we hook out DrvDocumentEvent.
    //

    devinfo.flGraphicsCaps = GCAPS_HALFTONE |
                             GCAPS_MONO_DITHER |
                             GCAPS_COLOR_DITHER |
                             GCAPS_DONTJOURNAL;

    //
    // No device fonts
    //

    devinfo.cFonts = 0;

    //
    // Black and white palette: entry 0 is black and entry 1 is white
    //

    if (! (pdev->hpal = EngCreatePalette(PAL_INDEXED, 2, paletteColors, 0, 0, 0))) {

        Error(("EngCreatePalette failed\n"));
        return FALSE;
    }

    devinfo.hpalDefault = pdev->hpal;
    devinfo.iDitherFormat = BMF_1BPP;
    devinfo.cxDither = devinfo.cyDither = 4;

    //
    // Copy cb bytes from devinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(devinfo))
    {
        memset(pdevinfo, 0, cb);
        memcpy(pdevinfo, &devinfo, sizeof(devinfo));
    }
    else
        memcpy(pdevinfo, &devinfo, cb);

    return TRUE;
}



BOOL
FillGdiInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pgdiinfo
    )

/*++

Routine Description:

    Fill in the device capabilities information for the engine.

Arguments:

    pdev - Pointer to DEVDATA structure
    cb - Size of buffer pointed to by pgdiinfo
    pgdiinfo - Pointer to a GDIINFO buffer

Return Value:

    NONE

--*/

{
    GDIINFO gdiinfo;
    LONG    maxRes;

    memset(&gdiinfo, 0, sizeof(gdiinfo));

    //
    // This field doesn't seem to have any effect for printer drivers.
    // Put our driver version number in there anyway.
    //

    gdiinfo.ulVersion = DRIVER_VERSION;

    //
    // We're raster printers
    //

    gdiinfo.ulTechnology = DT_RASPRINTER;

    //
    // Width and height of the imageable area measured in microns.
    // Remember to turn on the sign bit.
    //

    gdiinfo.ulHorzSize = - (pdev->imageArea.right - pdev->imageArea.left);
    gdiinfo.ulVertSize = - (pdev->imageArea.bottom - pdev->imageArea.top);

    //
    // Convert paper size and imageable area from microns to pixels
    //

    pdev->paperSize.cx = MicronToPixel(pdev->paperSize.cx, pdev->xres);
    pdev->paperSize.cy = MicronToPixel(pdev->paperSize.cy, pdev->yres);

    pdev->imageArea.left = MicronToPixel(pdev->imageArea.left, pdev->xres);
    pdev->imageArea.right = MicronToPixel(pdev->imageArea.right, pdev->xres);
    pdev->imageArea.top = MicronToPixel(pdev->imageArea.top, pdev->yres);
    pdev->imageArea.bottom = MicronToPixel(pdev->imageArea.bottom, pdev->yres);

    pdev->imageSize.cx = pdev->imageArea.right - pdev->imageArea.left;
    pdev->imageSize.cy = pdev->imageArea.bottom - pdev->imageArea.top;

    //
    // Width and height of the imageable area measured in device pixels
    //

    gdiinfo.ulHorzRes = pdev->imageSize.cx;
    gdiinfo.ulVertRes = pdev->imageSize.cy;

    //
    // Color depth information
    //

    gdiinfo.cBitsPixel = 1;
    gdiinfo.cPlanes = 1;
    gdiinfo.ulNumColors = 2;

    //
    // Resolution information
    //

    gdiinfo.ulLogPixelsX = pdev->xres;
    gdiinfo.ulLogPixelsY = pdev->yres;

    //
    // Win31 compatible text capability flags. Are they still used by anyone?
    //

    gdiinfo.flTextCaps = 0;

    //
    // Device pixel aspect ratio
    //

    gdiinfo.ulAspectX = pdev->yres;
    gdiinfo.ulAspectY = pdev->xres;
    gdiinfo.ulAspectXY = CalcHypot(pdev->xres, pdev->yres);

    //
    // Dotted line appears to be approximately 25dpi
    // We assume either xres is a multiple of yres or yres is a multiple of xres
    //

    maxRes = max(pdev->xres, pdev->yres);
    Assert((maxRes % pdev->xres) == 0 && (maxRes % pdev->yres == 0));

    gdiinfo.xStyleStep = maxRes / pdev->xres;
    gdiinfo.yStyleStep = maxRes / pdev->yres;
    gdiinfo.denStyleStep = maxRes / 25;

    //
    // Size and margins of physical surface measured in device pixels
    //

    gdiinfo.szlPhysSize.cx = pdev->paperSize.cx;
    gdiinfo.szlPhysSize.cy = pdev->paperSize.cy;

    gdiinfo.ptlPhysOffset.x = pdev->imageArea.left;
    gdiinfo.ptlPhysOffset.y = pdev->imageArea.top;

    //
    // Use default halftone information
    //

    gdiinfo.ciDevice = DefDevHTInfo.ColorInfo;
    gdiinfo.ulDevicePelsDPI = max(pdev->xres, pdev->yres);
    gdiinfo.ulPrimaryOrder = PRIMARY_ORDER_CBA;
    gdiinfo.ulHTOutputFormat = HT_FORMAT_1BPP;
    gdiinfo.flHTFlags = HT_FLAG_HAS_BLACK_DYE;
    gdiinfo.ulHTPatternSize = HT_PATSIZE_4x4_M;

    //
    // Copy cb byte from gdiinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(gdiinfo))
    {
        memset(pgdiinfo, 0, cb);
        memcpy(pgdiinfo, &gdiinfo, sizeof(gdiinfo));
    }
    else
        memcpy(pgdiinfo, &gdiinfo, cb);

    return TRUE;
}



VOID
FreeDevData(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free up all memory associated with the specified PDEV

Arguments:

    pdev    Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->hpal)
        EngDeletePalette(pdev->hpal);

    MemFree(pdev->pFaxIFD);
    MemFree(pdev);
}



VOID
SelectPrinterForm(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Store printer paper size information in our DEVDATA structure

Arguments:

    pdev - Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    FORM_INFO_1 formInfo;

    //
    // Validate devmode form specification; use default form if it's invalid.
    //

    if (! ValidDevmodeForm(pdev->hPrinter, &pdev->dm.dmPublic, &formInfo)) {

        memset(&formInfo, 0, sizeof(formInfo));

        //
        // Default to A4 paper
        //

        formInfo.Size.cx = formInfo.ImageableArea.right = A4_WIDTH;
        formInfo.Size.cy = formInfo.ImageableArea.bottom = A4_HEIGHT;
    }

    Assert(formInfo.Size.cx > 0 && formInfo.Size.cy > 0);
    Assert(formInfo.ImageableArea.left >= 0 &&
           formInfo.ImageableArea.top >= 0 &&
           formInfo.ImageableArea.left < formInfo.ImageableArea.right &&
           formInfo.ImageableArea.top < formInfo.ImageableArea.bottom &&
           formInfo.ImageableArea.right <= formInfo.Size.cx &&
           formInfo.ImageableArea.bottom <= formInfo.Size.cy);

    //
    // Take landscape into consideration
    //

    if (IsLandscapeMode(pdev)) {

        LONG    width, height;

        //
        // Swap the width and height
        //

        pdev->paperSize.cy = width = formInfo.Size.cx;
        pdev->paperSize.cx = height = formInfo.Size.cy;

        //
        // Rotate the coordinate system 90 degrees counterclockwise
        //

        pdev->imageArea.left = height - formInfo.ImageableArea.bottom;
        pdev->imageArea.top = formInfo.ImageableArea.left;
        pdev->imageArea.right = height - formInfo.ImageableArea.top;
        pdev->imageArea.bottom = formInfo.ImageableArea.right;

        //
        // Swap x and y resolution
        //
    
        pdev->xres = pdev->dm.dmPublic.dmYResolution;
        pdev->yres = pdev->dm.dmPublic.dmPrintQuality;

    } else {

        pdev->paperSize = formInfo.Size;
        pdev->imageArea = formInfo.ImageableArea;

        pdev->xres = pdev->dm.dmPublic.dmPrintQuality;
        pdev->yres = pdev->dm.dmPublic.dmYResolution;
    }
}



LONG
CalcHypot(
    LONG    x,
    LONG    y
    )

/*++

Routine Description:

    Returns the length of the hypotenouse of a right triangle

Arguments:

    x, y - Edges of the right triangle

Return Value:

    Hypotenouse of the right triangle

--*/

{
    LONG    hypo, delta, target;

    //
    // Take care of negative inputs
    //
    
    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    //
    // use sq(x) + sq(y) = sq(hypo);
    // start with MAX(x, y),
    // use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the target hypotenouse.
    //

    hypo = max(x, y);
    target = min(x, y);
    target *= target;

    for(delta = 0; delta < target; hypo++)
        delta += (hypo << 1) + 1;

    return hypo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxmon\tiffstub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiffstub.h

Abstract:

    Miminal set of declarations for dealing with TIFF files. We need this in the
    monitor because a fax print job may consist of several TIFF files concatenated
    together. We must patch it up into a single valid TIFF before passing it to
    the fax service.

Environment:

	Windows NT fax print monitor

Revision History:

	02/25/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _TIFFSTUB_H_
#define _TIFFSTUB_H_

//
// Constants for various TIFF data types
//

#define TIFFTYPE_BYTE       1
#define TIFFTYPE_ASCII      2
#define TIFFTYPE_SHORT      3
#define TIFFTYPE_LONG       4
#define TIFFTYPE_RATIONAL   5
#define TIFFTYPE_SBYTE      6
#define TIFFTYPE_UNDEFINED  7
#define TIFFTYPE_SSHORT     8
#define TIFFTYPE_SLONG      9
#define TIFFTYPE_SRATIONAL  10
#define TIFFTYPE_FLOAT      11
#define TIFFTYPE_DOUBLE     12

//
// Constants for TIFF tags which we're interested in
//

#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_STRIPBYTECOUNTS     279

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY;

typedef IFDENTRY UNALIGNED *PIFDENTRY_UNALIGNED;

//
// Data structure for representing an IFD
//

typedef struct {

    WORD        wEntries;
    IFDENTRY    ifdEntries[1];

} IFD;

typedef IFD UNALIGNED *PIFD_UNALIGNED;

//
// Determine whether we're at the beginning of a TIFF file
//

#define ValidTiffFileHeader(p) \
        (((LPSTR) (p))[0] == 'I' && ((LPSTR) (p))[1] == 'I' && \
         ((PBYTE) (p))[2] == 42  && ((PBYTE) (p))[3] == 0)

//
// Read a DWORD value from an unaligned address
//

#define ReadUnalignedDWord(p) *((DWORD UNALIGNED *) (p))

//
// Write a DWORD value to an unaligned address
//

#define WriteUnalignedDWord(p, value) (*((DWORD UNALIGNED *) (p)) = (value))

#endif	// !_TIFFSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\escape.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    escape.c

Abstract:

    Implementation of escape related DDI entry points:
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



ULONG
DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEscape.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface the call is directed to
    iEsc - Specifies a query
    cjIn - Specifies the size in bytes of the buffer pointed to by pvIn
    pvIn - Points to input data buffer
    cjOut - Specifies the size in bytes of the buffer pointed to by pvOut
    pvOut -  Points to the output buffer

Return Value:

    Depends on the query specified by iEsc parameter

--*/

{
    Verbose(("Entering DrvEscape...\n"));

    switch (iEsc) {

    case QUERYESCSUPPORT:

        //
        // Query which escapes are supported: The only escape we support
        // is QUERYESCSUPPORT itself.
        //

        if (cjIn != sizeof(ULONG) || !pvIn) {

            Error(("Invalid input paramaters\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return DDI_ERROR;
        }

        if (*((PULONG) pvIn) == QUERYESCSUPPORT)
            return TRUE;

        break;

    default:

        Verbose(("Unsupported iEsc: %d\n", iEsc));
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\faxtiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.c

Abstract:

    Functions to compress the bitmap bits using CCITT Group3 2-dimensional coding
    and output the resulting data as TIFF-F file.

Environment:

        Windows NT fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

#include "faxdrv.h"
#include "faxtiff.h"
#include "faxtable.h"



BOOL
WriteData(
    PDEVDATA    pdev,
    PVOID       pbuf,
    DWORD       cbbuf
    )

/*++

Routine Description:

    Output a buffer of data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pbuf - Points to data buffer
    cbbuf - Number of bytes in the buffer

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    DWORD   cbwritten;

    //
    // Stop if the document has been cancelled.
    //

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Send output to spooler directly
    //

    if (! WritePrinter(pdev->hPrinter, pbuf, cbbuf, &cbwritten) || cbbuf != cbwritten) {

        Error(("WritePrinter failed\n"));
        pdev->flags |= PDEV_CANCELLED;
        return FALSE;
    }

    pdev->fileOffset += cbbuf;
    return TRUE;
}



PDWORD
CalcXposeMatrix(
    VOID
    )

/*++

Routine Description:

    Generate the transpose matrix for rotating landscape bitmaps

Arguments:

    NONE

Return Value:

    Pointer to the generated transpose matrix
    NULL if there is an error

--*/

{
    static DWORD templateData[16] = {

        /* 0000 */  0x00000000,
        /* 0001 */  0x00000001,
        /* 0010 */  0x00000100,
        /* 0011 */  0x00000101,
        /* 0100 */  0x00010000,
        /* 0101 */  0x00010001,
        /* 0110 */  0x00010100,
        /* 0111 */  0x00010101,
        /* 1000 */  0x01000000,
        /* 1001 */  0x01000001,
        /* 1010 */  0x01000100,
        /* 1011 */  0x01000101,
        /* 1100 */  0x01010000,
        /* 1101 */  0x01010001,
        /* 1110 */  0x01010100,
        /* 1111 */  0x01010101
    };

    PDWORD  pdwXpose, pTemp;
    INT     index;

    //
    // First check if the transpose matrix has been generated already
    //

    if (pdwXpose = MemAlloc(sizeof(DWORD) * 2 * (1 << BYTEBITS))) {

        for (index=0, pTemp=pdwXpose; index < (1 << BYTEBITS); index++, pTemp++) {

            pTemp[0] = templateData[index >> 4];
            pTemp[1 << BYTEBITS] = templateData[index & 0xf];
        }
    }

    return pdwXpose;
}



BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    )

/*++

Routine Description:

    Output a completed page bitmap to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pBitmapData - Points to bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LONG    bmpWidth, bmpHeight;
    BOOL    result;
    DWORD   compressedBytes;

    Verbose(("Sending page %d...\n", pdev->pageCount));
    Assert(pdev->pCompBits == NULL);

    //
    // For portrait output, encode the entire bitmap in one shot
    // For landscape output, we need to rotate the bitmap here:
    //  Generate the transpose matrix and allocate a
    //  temporary buffer large enough to hold 8 scanlines
    //

    if (IsLandscapeMode(pdev)) {

        bmpWidth = pdev->imageSize.cy;
        bmpHeight = pdev->imageSize.cx;

    } else {

        bmpWidth = pdev->imageSize.cx;
        bmpHeight = pdev->imageSize.cy;
    }

    //
    // Initialize fax encodier
    //

    if (! InitFaxEncoder(pdev, bmpWidth, bmpHeight))
        return FALSE;

    if (! IsLandscapeMode(pdev)) {

        LONG    dwordCount;
        PDWORD  pBits;

        //
        // Invert the entire page bitmap in memory
        //

        Assert(bmpWidth % DWORDBITS == 0);
        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        //
        // Compress the page bitmap
        //

        result = EncodeFaxData(pdev, pBitmapData, bmpWidth, bmpHeight);

        //
        // Restore the original page bitmap
        //

        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        if (! result) {

            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

    } else {

        register PDWORD pdwXposeHigh, pdwXposeLow;
        register DWORD  dwHigh, dwLow;
        PBYTE           pBuffer, pbCol;
        LONG            deltaNew;

        //
        // Calculate the transpose matrix for fast bitmap rotation
        //

        if (!(pdwXposeHigh = CalcXposeMatrix()) || !(pBuffer = MemAllocZ(bmpWidth))) {

            MemFree(pdwXposeHigh);
            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

        pdwXposeLow = pdwXposeHigh + (1 << BYTEBITS);

        //
        // During each iteration thru the following loop, we will process
        // one byte column and generate 8 rotated scanlines.
        //

        Assert(bmpHeight % BYTEBITS == 0);
        Assert(bmpWidth  % DWORDBITS == 0);

        deltaNew = bmpWidth / BYTEBITS;
        pbCol = pBitmapData + (bmpHeight / BYTEBITS - 1);

        do {

            PBYTE   pbWrite = pBuffer;
            PBYTE   pbTemp = pbCol;
            LONG    loopCount = deltaNew;

            while (loopCount--) {

                //
                // Rotate the next 8 bytes in the current column
                // Unroll the loop here in hopes of faster execution
                //

                dwHigh = pdwXposeHigh[*pbTemp];
                dwLow  = pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                //
                // Invert black and white pixel polarity
                //

                dwHigh ^= 0xffffffff;
                dwLow  ^= 0xffffffff;

                //
                // Distribute the resulting byte to 8 separate scanlines
                //

                *pbWrite = (BYTE) dwLow;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*3);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) dwHigh;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*3);
                pbWrite -= (deltaNew * BYTEBITS - deltaNew - 1);
            }

            //
            // Encode the next band of scanlines
            //

            if (! EncodeFaxData(pdev, pBuffer, bmpWidth, BYTEBITS)) {

                MemFree(pdwXposeHigh);
                MemFree(pBuffer);
                FreeCompBitsBuffer(pdev);
                return FALSE;
            }

        } while (pbCol-- != pBitmapData);

        MemFree(pdwXposeHigh);
        MemFree(pBuffer);
    }

    //
    // Output EOB (two EOLs) after the last scanline
    // and make sure the compressed data is WORD aligned
    //

    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    FlushBits(pdev);

    if ((compressedBytes = (DWORD)(pdev->pCompBufPtr - pdev->pCompBits)) & 1) {

        *pdev->pCompBufPtr++ = 0;
        compressedBytes++;
    }

    //
    // Output the IFD for the previous page and generate the IFD for the current page
    // Output the compressed bitmap data
    //

    result = WriteTiffIFD(pdev, bmpWidth, bmpHeight, compressedBytes) &&
             WriteTiffBits(pdev, pdev->pCompBits, compressedBytes);

    FreeCompBitsBuffer(pdev);

    return result;
}



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}



INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}



VOID
OutputRun(
    PDEVDATA    pdev,
    INT         run,
    PCODETABLE  pCodeTable
    )

/*++

Routine Description:

    Output a single run (black or white) using the specified code table

Arguments:

    pdev - Points to our DEVDATA structure
    run - Specifies the length of the run
    pCodeTable - Specifies the code table to use

Return Value:

    NONE

--*/

{
    PCODETABLE  pTableEntry;

    //
    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.
    //

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run -= 2560;
    }

    //
    // Use appropriate make-up code word if the run is longer than 63 pixels
    //

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run &= 0x3f;
    }

    //
    // Output terminating code word
    //

    OutputBits(pdev, pCodeTable[run].length, pCodeTable[run].code);
}



#ifdef USE1D

VOID
OutputEOL(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output EOL code at the beginning of each scanline

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    DWORD   length, code;

    //
    // EOL code word always ends on a byte boundary
    //

    code = EOL_CODE;
    length = EOL_LENGTH + ((pdev->bitcnt - EOL_LENGTH) & 7);
    OutputBits(pdev, length, code);
}


BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     bitIndex, run;

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Output byte-aligned EOL code
        //

        OutputEOL(pdev);

        //
        // Use 1-dimensional encoding scheme
        //

        bitIndex = 0;

        while (TRUE) {

            //
            // Code white run
            //

            run = FindWhiteRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, WhiteRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;

            //
            // Code black run
            //

            run = FindBlackRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, BlackRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;
        }

        //
        // Move on to the next scanline
        //

        plinebuf += delta;
    }

    return TRUE;
}



#else //!USE1D

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     a0, a1, a2, b1, b2, distance;
    PBYTE   prefline = pdev->prefline;

    Assert(lineWidth % BYTEBITS == 0);

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Use 2-dimensional encoding scheme
        //

        a0 = 0;
        a1 = GetBit(plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0);
        b1 = GetBit(prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0);

        while (TRUE) {

            b2 = (b1 >= lineWidth) ? lineWidth :
                    NextChangingElement(prefline, b1, lineWidth, GetBit(prefline, b1));

            if (b2 < a1) {

                //
                // Pass mode
                //

                OutputBits(pdev, PASSCODE_LENGTH, PASSCODE);
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                OutputBits(pdev, VertCodes[distance+3].length, VertCodes[distance+3].code);
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= lineWidth) ? lineWidth :
                        NextChangingElement(plinebuf, a1, lineWidth, GetBit(plinebuf, a1));

                OutputBits(pdev, HORZCODE_LENGTH, HORZCODE);

                if (a1 != 0 && GetBit(plinebuf, a0)) {

                    OutputRun(pdev, a1-a0, BlackRunCodes);
                    OutputRun(pdev, a2-a1, WhiteRunCodes);

                } else {

                    OutputRun(pdev, a1-a0, WhiteRunCodes);
                    OutputRun(pdev, a2-a1, BlackRunCodes);
                }

                a0 = a2;
            }

            if (a0 >= lineWidth)
                break;

            a1 = NextChangingElement(plinebuf, a0, lineWidth, GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, a0, lineWidth, !GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, b1, lineWidth, GetBit(plinebuf, a0));
        }

        //
        // Move on to the next scanline
        //

        prefline = plinebuf;
        plinebuf += delta;
    }

    //
    // Remember the last line as a reference
    //

    CopyMemory(pdev->prefline, prefline, delta);

    return TRUE;
}

#endif //!USE1D



//
// IFD entries we generate for each page
//

WORD FaxIFDTags[NUM_IFD_ENTRIES] = {

    TIFFTAG_NEWSUBFILETYPE,
    TIFFTAG_IMAGEWIDTH,
    TIFFTAG_IMAGEHEIGHT,
    TIFFTAG_BITSPERSAMPLE,
    TIFFTAG_COMPRESSION,
    TIFFTAG_PHOTOMETRIC,
    TIFFTAG_FILLORDER,
    TIFFTAG_STRIPOFFSETS,
    TIFFTAG_SAMPLESPERPIXEL,
    TIFFTAG_ROWSPERSTRIP,
    TIFFTAG_STRIPBYTECOUNTS,
    TIFFTAG_XRESOLUTION,
    TIFFTAG_YRESOLUTION,
#ifdef USE1D
    TIFFTAG_G3OPTIONS,
#else
    TIFFTAG_G4OPTIONS,
#endif
    TIFFTAG_RESUNIT,
    TIFFTAG_PAGENUMBER,
    TIFFTAG_SOFTWARE,
    TIFFTAG_CLEANFAXDATA,
};

#define SoftwareStr "Windows NT Fax Driver"

static FAXIFD FaxIFDTemplate = {

    0,
    NUM_IFD_ENTRIES,

    {
        { TIFFTAG_NEWSUBFILETYPE, TIFFTYPE_LONG, 1, SUBFILETYPE_PAGE },
        { TIFFTAG_IMAGEWIDTH, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_IMAGEHEIGHT, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_BITSPERSAMPLE, TIFFTYPE_SHORT, 1, 1 },
#ifdef USE1D
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G3FAX },
#else
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G4FAX },
#endif
        { TIFFTAG_PHOTOMETRIC, TIFFTYPE_SHORT, 1, PHOTOMETRIC_WHITEIS0 },
#ifdef USELSB
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_LSB },
#else
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_MSB },
#endif
        { TIFFTAG_STRIPOFFSETS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_SAMPLESPERPIXEL, TIFFTYPE_SHORT, 1, 1 },
        { TIFFTAG_ROWSPERSTRIP, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_STRIPBYTECOUNTS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_XRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
        { TIFFTAG_YRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
#ifdef USE1D
        { TIFFTAG_G3OPTIONS, TIFFTYPE_LONG, 1, G3_ALIGNEOL },
#else
        { TIFFTAG_G4OPTIONS, TIFFTYPE_LONG, 1, 0 },
#endif
        { TIFFTAG_RESUNIT, TIFFTYPE_SHORT, 1, RESUNIT_INCH },
        { TIFFTAG_PAGENUMBER, TIFFTYPE_SHORT, 2, 0 },
        { TIFFTAG_SOFTWARE, TIFFTYPE_ASCII, sizeof(SoftwareStr)+1, 0 },
        { TIFFTAG_CLEANFAXDATA, TIFFTYPE_SHORT, 1, 0 },
    },

    0,
    DRIVER_SIGNATURE,
    TIFFF_RES_X,
    1,
    TIFFF_RES_Y,
    1,
    SoftwareStr
};



BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output document trailer information to the spooler

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;

    if (pFaxIFD == NULL || pdev->pageCount == 0)
        return TRUE;

    //
    // Output the IFD for the last page of the document
    //

    pFaxIFD->nextIFDOffset = pFaxIFD->filler = 0;

    return WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
}



BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the IFD for the previous page and generate the IFD for the current page

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap image
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;
    ULONG_PTR   offset;
    BOOL    result = TRUE;

    //
    // Create the IFD data structure if necessary
    //

    if (pFaxIFD == NULL) {

        if (! (pFaxIFD = MemAlloc(sizeof(FAXIFD))))
            return FALSE;

        pdev->pFaxIFD = pFaxIFD;
        memcpy(pFaxIFD, &FaxIFDTemplate, sizeof(FAXIFD));

        #if DBG

        for (offset=0; offset < NUM_IFD_ENTRIES; offset++) {

            Assert(pFaxIFD->ifd[offset].tag == FaxIFDTags[offset]);
        }

        #endif
    }

    if (pdev->pageCount <= 1) {

        //
        // If this is the very first page, there is no previous IFD.
        // Output the TIFF file header instead.
        //

        TIFFFILEHEADER *pTiffFileHeader;

        pdev->fileOffset = 0;

        if (pTiffFileHeader = MemAlloc(sizeof(TIFFFILEHEADER))) {

            pTiffFileHeader->magic1 = TIFF_MAGIC1;
            pTiffFileHeader->magic2 = TIFF_MAGIC2;
            pTiffFileHeader->signature = DRIVER_SIGNATURE;
            pTiffFileHeader->firstIFD = sizeof(TIFFFILEHEADER) +
                                        compressedBytes +
                                        offsetof(FAXIFD, wIFDEntries);

            result = WriteData(pdev, pTiffFileHeader, sizeof(TIFFFILEHEADER));
            MemFree(pTiffFileHeader);

        } else {

            Error(("Memory allocation failed\n"));
            result = FALSE;
        }

    } else {

        //
        // Not the first page of the document
        // Output the IFD for the previous page
        //

        pFaxIFD->nextIFDOffset = pdev->fileOffset + compressedBytes + sizeof(FAXIFD) +
                                 offsetof(FAXIFD, wIFDEntries);

        result = WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
    }

    //
    // Generate the IFD for the current page
    //

    offset = pdev->fileOffset;

    pFaxIFD->ifd[IFD_PAGENUMBER].value = MAKELONG(pdev->pageCount-1, 0);
    pFaxIFD->ifd[IFD_IMAGEWIDTH].value = bmpWidth;
    pFaxIFD->ifd[IFD_IMAGEHEIGHT].value = bmpHeight;
    pFaxIFD->ifd[IFD_ROWSPERSTRIP].value = bmpHeight;
    pFaxIFD->ifd[IFD_STRIPBYTECOUNTS].value = compressedBytes;
    pFaxIFD->ifd[IFD_STRIPOFFSETS].value = (ULONG)offset;
    offset += compressedBytes;

    pFaxIFD->ifd[IFD_XRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, xresNum);
    pFaxIFD->ifd[IFD_YRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, yresNum);
    pFaxIFD->ifd[IFD_SOFTWARE].value = (ULONG)offset + offsetof(FAXIFD, software);

    pFaxIFD->yresNum = (pdev->dm.dmPublic.dmYResolution == FAXRES_VERTDRAFT) ?
                            TIFFF_RES_Y_DRAFT :
                            TIFFF_RES_Y;

    return result;
}



BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the compressed bitmap data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pCompBits - Points to a buffer containing compressed bitmap data
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define OUTPUT_BUFFER_SIZE  4096

{
    PBYTE   pBuffer;
    DWORD   bytesToWrite;

#ifndef USERMODE_DRIVER
    //
    // Since we allocated the compressed bitmap data buffer from
    // the user mode memory space, we couldn't passed it directly
    // to EngWritePrinter.
    //
    // Here we allocate a temporary buffer from kernel mode memory
    // space and output the compressed data one buffer at a time.
    //

    if (! (pBuffer = MemAlloc(OUTPUT_BUFFER_SIZE))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    while (compressedBytes > 0) {

        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);
        CopyMemory(pBuffer, pCompBits, bytesToWrite);

        if (! WriteData(pdev, pBuffer, bytesToWrite)) {

            MemFree(pBuffer);
            return FALSE;
        }

        pCompBits += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    MemFree(pBuffer);
    return TRUE;
#else
    //
    // just dump the data in OUTPUT_BUFFER_SIZE increments
    //
    pBuffer = pCompBits;
    while (compressedBytes > 0) {
        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);

        if (! WriteData(pdev, pBuffer, bytesToWrite) ) {
            return FALSE;
        }

        pBuffer += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    return TRUE;    
#endif

}



BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    )

/*++

Routine Description:

    Enlarge the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure
    scanlineSize - Number of uncompressed bytes per scanline

Return Value:

    TRUE if successful, FALSE if memory allocation fails

--*/

{
    DWORD   oldBufferSize;
    PBYTE   pNewBuffer;

    //
    // Allocate a new buffer which is one increment larger than existing one
    //

    oldBufferSize = pdev->pCompBits ? pdev->compBufSize : 0;
    pdev->compBufSize = oldBufferSize + pdev->compBufInc;

    if (! (pNewBuffer = MemAlloc(pdev->compBufSize))) {

        Error(("MemAlloc failed\n"));
        FreeCompBitsBuffer(pdev);
        return FALSE;
    }

    if (pdev->pCompBits) {

        //
        // Growing an existing buffer
        //

        Warning(("Growing compressed bitmap buffer: %d -> %d\n", oldBufferSize, pdev->compBufSize));

        memcpy(pNewBuffer, pdev->pCompBits, oldBufferSize);
        pdev->pCompBufPtr = pNewBuffer + (pdev->pCompBufPtr - pdev->pCompBits);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pNewBuffer;

    } else {

        //
        // First time allocation
        //

        pdev->pCompBufPtr = pdev->pCompBits = pNewBuffer;
    }

    //
    // Set a high-water mark to about 4 scanlines before the end of the buffer
    //

    pdev->pCompBufMark = pdev->pCompBits + (pdev->compBufSize - 4*scanlineSize);

    return TRUE;
}



VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->pCompBits) {

        MemFree(pdev->prefline);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pdev->pCompBufPtr = NULL;
        pdev->compBufSize = 0;
    }
}



BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    )

/*++

Routine Description:

    Initialize the fax encoder

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Calculate the increment in which to enlarge the compressed bits buffer:
    //  about 1/4 of the uncompressed bitmap buffer
    //

    bmpWidth /= BYTEBITS;
    pdev->compBufInc = bmpWidth * bmpHeight / 4;

    //
    // Allocate the initial buffer
    //

    if (! (pdev->prefline = MemAllocZ(bmpWidth)) ||
        ! GrowCompBitsBuffer(pdev, bmpWidth))
    {
        MemFree(pdev->prefline);
        return FALSE;
    }

    //
    // Perform other initialization of fax encoder
    //

    pdev->bitdata = 0;
    pdev->bitcnt = DWORDBITS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxmon\faxmon.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.h

Abstract:

    Header file for fax print monitor

Environment:

        Windows NT fax print monitor

Revision History:

        02/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXMON_H_
#define _FAXMON_H_

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <tchar.h>

#include "winfax.h"
#include "winfaxp.h"
#include "jobtag.h"

//
// String resource IDs
//

#define IDS_FAX_MONITOR_NAME    256
#define IDS_FAX_PORT_DESC       257
#define IDS_PORT_ALREADY_EXISTS 258
#define IDS_FAXERR_RECOVERABLE  259
#define IDS_FAXERR_FATAL        260
#define IDS_FAXERR_BAD_TIFF     261
#define IDS_FAXERR_BAD_DATA16   262
#define IDS_ADD_PORT            263
#define IDS_DELETE_PORT         264
#define IDS_CONFIGURE_PORT      265
#define IDS_CONFIG_ERROR        266
#define IDS_ADD_ERROR           267
#define IDS_DELETE_ERROR        268

//
// Data structure for representing a fax monitor port
//

typedef struct _FAXPORT {

    PVOID                   startSig;               // signature
    LPTSTR                  pName;                  // port name
    HANDLE                  hFaxSvc;                // fax service handle
    DWORD                   jobId;                  // main job ID
    DWORD                   nextJobId;              // next job ID in the chain
    HANDLE                  hFile;                  // handle to currently open file
    LPTSTR                  pFilename;              // pointer to currently open file name
    LPTSTR                  pPrinterName;           // currently connected printer name
    HANDLE                  hPrinter;               // open handle to currently connected printer
    LPTSTR                  pParameters;            // pointer to job parameter string
    FAX_JOB_PARAM           jobParam;               // pointer to individual job parameters
    HMODULE                 hWinFax;                // handle for loaded winfax dll
    PFAXCONNECTFAXSERVERW   pFaxConnectFaxServerW;  // function pointer
    PFAXCLOSE               pFaxClose;              // function pointer
    PFAXSENDDOCUMENTW       pFaxSendDocumentW;      // function pointer
    PFAXACCESSCHECK         pFaxAccessCheck;        // function pointer
    PVOID                   endSig;                 // signature

} FAXPORT, *PFAXPORT;

#define ValidFaxPort(pFaxPort) \
        ((pFaxPort) && (pFaxPort) == (pFaxPort)->startSig && (pFaxPort) == (pFaxPort)->endSig)

//
// Different error code when sending fax document
//

#define FAXERR_NONE         0
#define FAXERR_IGNORE       1
#define FAXERR_RESTART      2
#define FAXERR_SPECIAL      3

#define FAXERR_FATAL        IDS_FAXERR_FATAL
#define FAXERR_RECOVERABLE  IDS_FAXERR_RECOVERABLE
#define FAXERR_BAD_TIFF     IDS_FAXERR_BAD_TIFF
#define FAXERR_BAD_DATA16   IDS_FAXERR_BAD_DATA16

//
// Memory allocation and deallocation macros
//

#define MemAlloc(size)  ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size) ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(ptr)    { if (ptr) LocalFree((HLOCAL) (ptr)); }

//
// Number of tags used for passing fax job parameters
//

#define NUM_JOBPARAM_TAGS 11

//
// Nul terminator for a character string
//

#define NUL             0

//
// Result of string comparison
//

#define EQUAL_STRING    0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define IsNulChar(c)        ((c) == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif

//
// Path separator character
//

#define PATH_SEPARATOR  '\\'

//
// Declaration of print monitor entry points
//

BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    );

BOOL
FaxMonClosePort(
    HANDLE  hPort
    );

BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    );

BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    );

BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    );

BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    );

BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    );

//
// Get the list of fax devices from the service
//

PFAX_PORT_INFO
MyFaxEnumPorts(
    LPDWORD pcPorts,
    BOOL    useCache
    );

//
// Wrapper function for fax service's FaxGetPort API
//

PFAX_PORT_INFO
MyFaxGetPort(
    LPTSTR  pPortName,
    BOOL    useCache
    );

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Update the status information of a print job
//

BOOL
SetJobStatus(
    HANDLE  hPrinter,
    DWORD   jobId,
    INT     statusStrId
    );

//
// Wrapper function for spooler API GetJob
//

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    );

//
// Create a temporary file in the system spool directory for storing fax data
//

LPTSTR
CreateTempFaxFile(
    VOID
    );

//
// Open a handle to the current fax job file associated with a port
//

BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    );

//
// Process fax jobs sent from win31 and win95 clients
//

INT
ProcessDownlevelFaxJob(
    PFAXPORT    pFaxPort
    );


//
// Retrieve a DWORD value from the registry
//

DWORD
GetRegistryDWord(
    HKEY    hRegKey,
    LPTSTR  pValueName,
    DWORD   defaultValue
    );

#define REGVAL_CONNECT_RETRY_COUNT      TEXT("ConnectRetryCount")
#define REGVAL_CONNECT_RETRY_INTERVAL   TEXT("ConnectRetryInterval")


#if DBG

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  A variable which controls the amount of debug messages. To generate
//  lots of debug messages, enter the following line in the debugger:
//
//      ed _debugLevel 1
//
// Verbose
//  Display a debug message if _debugLevel is set to non-zero.
//
//      Verbose(("Entering XYZ: param = %d\n", param));
//
// Error
//  Display an error message along with the filename and the line number
//  to indicate where the error occurred.
//
//      Error(("XYZ failed"));
//
// Assert
//  Verify a condition is true. If not, force a breakpoint.
//
//      Assert(p != NULL && (p->flags & VALID));

extern INT  _debugLevel;
extern VOID DbgPrint(LPCSTR, ...);
extern LPCSTR StripDirPrefixA(LPCSTR);

#define Warning(arg) {\
            DbgPrint("WRN %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Error(arg) {\
            DbgPrint("ERR %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Verbose(arg) { if (_debugLevel > 0) DbgPrint arg; }
#define Assert(cond) {\
            if (! (cond)) {\
                DbgPrint("ASSERT: %s (%d)\n", StripDirPrefixA(__FILE__), __LINE__);\
                __try { \
                    DebugBreak(); \
                } __except (UnhandledExceptionFilter(GetExceptionInformation())) { \
                } \
            }\
        }

#define Trace(funcName) { if (_debugLevel > 0) DbgPrint("Entering %s ...\n", funcName); }

#else   // !DBG

#define Verbose(arg)
#define Assert(cond)
#define Warning(arg)
#define Error(arg)
#define Trace(funcName)

#endif // DBG

#endif // !_FAXMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\faxtiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    Declarations for Group3 2D compression and generating TIFF files

Environment:

        Windows NT Fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

NOTE:

    Structure of the TIFF output file from the driver:

    4949        II
    002a        42
    00000008    Offset to the first IFD

    IFD for the first page

    Number of directory entries
    NEWSUBFILETYPE  LONG     1  2 - Page in a multi-page document
    PAGENUMBER      SHORT    2  PageNumber 0000
    IMAGEWIDTH      LONG     1  ImageWidth
    IMAGEHEIGHT     LONG     1  ImageHeight
    BITSPERSAMPLE   SHORT    1  1
    SAMPLESPERPIXEL SHORT    1  1
    COMPRESSION     SHORT    1  4 - G4Fax
    GROUP4OPTIONS   SHORT    1  0
    CLEANFAXDATA    SHORT    1  0
    FILLORDER       SHORT    1  2
    PHOTOMETRIC     SHORT    1  0 - WhiteIsZero
    RESOLUTIONUNIT  SHORT    1  2 - Inch
    XRESOLUTION     RATIONAL 1  Xdpi
    YRESOLUTION     RATIONAL 1  Ydpi
    ROWSPERSTRIP    LONG     1  ImageHeight
    STRIPBYTECOUNTS LONG     1  Compressed data byte count
    STRIPOFFSETS    LONG     1  Offset to compressed data
    Next IFD offset
    Compressed data for the first page

    IFD for the second page
    Compressed data for the second page
    ...

    Last IFD

    0001
    SOFTWARE        ASCII    n  "Windows NT Fax Driver"
    00000000
    00000000

--*/

#ifndef _FAXTIFF_H_
#define _FAXTIFF_H_

//
// TIFF field tag and type constants
//

#define TIFFTYPE_ASCII              2
#define TIFFTYPE_SHORT              3
#define TIFFTYPE_LONG               4
#define TIFFTYPE_RATIONAL           5

#define TIFFTAG_NEWSUBFILETYPE      254
#define     SUBFILETYPE_PAGE        2
#define TIFFTAG_IMAGEWIDTH          256
#define TIFFTAG_IMAGEHEIGHT         257
#define TIFFTAG_BITSPERSAMPLE       258
#define TIFFTAG_COMPRESSION         259
#define     COMPRESSION_G3FAX       3
#define     COMPRESSION_G4FAX       4
#define TIFFTAG_PHOTOMETRIC         262
#define     PHOTOMETRIC_WHITEIS0    0
#define     PHOTOMETRIC_BLACKIS0    1
#define TIFFTAG_FILLORDER           266
#define     FILLORDER_MSB           1
#define     FILLORDER_LSB           2
#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_SAMPLESPERPIXEL     277
#define TIFFTAG_ROWSPERSTRIP        278
#define TIFFTAG_STRIPBYTECOUNTS     279
#define TIFFTAG_XRESOLUTION         282
#define     TIFFF_RES_X             204
#define TIFFTAG_YRESOLUTION         283
#define     TIFFF_RES_Y             196
#define     TIFFF_RES_Y_DRAFT       98
#define TIFFTAG_G3OPTIONS           292
#define     G3_2D                   1
#define     G3_ALIGNEOL             4
#define TIFFTAG_G4OPTIONS           293
#define TIFFTAG_RESUNIT             296
#define     RESUNIT_INCH            2
#define TIFFTAG_PAGENUMBER          297
#define TIFFTAG_SOFTWARE            305
#define TIFFTAG_CLEANFAXDATA        327

//
// Data structure for representing our TIFF output file header information
//

typedef struct {

    WORD    magic1;     // II
    WORD    magic2;     // 42
    LONG    firstIFD;   // offset to first IFD
    DWORD   signature;  // driver private signature

} TIFFFILEHEADER;

#define TIFF_MAGIC1     'II'
#define TIFF_MAGIC2     42

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY, *PIFDENTRY;

//
// IFD entries we generate for each page
//

enum {

    IFD_NEWSUBFILETYPE,
    IFD_IMAGEWIDTH,
    IFD_IMAGEHEIGHT,
    IFD_BITSPERSAMPLE,
    IFD_COMPRESSION,
    IFD_PHOTOMETRIC,
    IFD_FILLORDER,
    IFD_STRIPOFFSETS,
    IFD_SAMPLESPERPIXEL,
    IFD_ROWSPERSTRIP,
    IFD_STRIPBYTECOUNTS,
    IFD_XRESOLUTION,
    IFD_YRESOLUTION,
    IFD_G3G4OPTIONS,
    IFD_RESUNIT,
    IFD_PAGENUMBER,
    IFD_SOFTWARE,
    IFD_CLEANFAXDATA,

    NUM_IFD_ENTRIES
};

typedef struct {

    WORD        reserved;
    WORD        wIFDEntries;
    IFDENTRY    ifd[NUM_IFD_ENTRIES];
    DWORD       nextIFDOffset;
    DWORD       filler;
    DWORD       xresNum;
    DWORD       xresDenom;
    DWORD       yresNum;
    DWORD       yresDenom;
    CHAR        software[32];

} FAXIFD, *PFAXIFD;

//
// Output compressed data bytes in correct fill order
//

#ifdef USELSB

#define OutputByte(n)   BitReverseTable[(BYTE) (n)]

#else

#define OutputByte(n)   ((BYTE) (n))

#endif

//
// Output a sequence of compressed bits
//

#define OutputBits(pdev, length, code) { \
            (pdev)->bitdata |= (code) << ((pdev)->bitcnt - (length)); \
            if (((pdev)->bitcnt -= (length)) <= 2*BYTEBITS) { \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 2*BYTEBITS)); \
                (pdev)->bitdata <<= 2*BYTEBITS; \
                (pdev)->bitcnt += 2*BYTEBITS; \
            } \
        }

//
// Flush any leftover bits into the compressed bitmap buffer
//

#define FlushBits(pdev) { \
            while ((pdev)->bitcnt < DWORDBITS) { \
                (pdev)->bitcnt += BYTEBITS; \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                (pdev)->bitdata <<= BYTEBITS; \
            } \
            (pdev)->bitdata = 0; \
            (pdev)->bitcnt = DWORDBITS; \
        }

//
// Find the next pixel on the scanline whose color is opposite of
// the specified color, starting from the specified starting point
//

#define NextChangingElement(pbuf, startBit, stopBit, isBlack) \
        ((startBit) + ((isBlack) ? FindBlackRun((pbuf), (startBit), (stopBit)) : \
                                   FindWhiteRun((pbuf), (startBit), (stopBit))))

//
// Check if the specified pixel on the scanline is black or white
//  1 - the specified pixel is black
//  0 - the specified pixel is white
//

#define GetBit(pbuf, bit)   (((pbuf)[(bit) >> 3] >> (((bit) ^ 7) & 7)) & 1)

//
// Compress the specified number of scanlines
//

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    );

//
// Output TIFF IFD for the current page
//

BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBits
    );

//
// Output the compressed bitmap data for the current page
//

BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBits
    );

//
// Enlarge the buffer for holding the compressed bitmap data
//

BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    );

//
// Free the buffer for holding the compressed bitmap data
//

VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    );

//
// Initialize the fax encoder
//

BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    );

#endif  // !_FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\faxdrv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    faxdrv.h

Abstract:

    Fax driver graphics DLL header file

[Environment:]

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXDRV_H_
#define _FAXDRV_H_

#include "faxlib.h"

//
// Data structure maintained by the fax driver graphics DLL
//

typedef struct {

    PVOID       startDevData;   // data structure signature

    HANDLE      hPrinter;       // handle to printer
    HDEV        hdev;           // handle to GDI device
    HANDLE      hpal;           // handle to default palette
    DWORD       flags;          // flag bits
    DRVDEVMODE  dm;             // devmode information
    INT         pageCount;      // number of pages printed
    SIZEL       paperSize;      // paper size measured in pixels
    SIZEL       imageSize;      // image size measured in pixels
    RECTL       imageArea;      // imageable area measured in pixels
    LONG        xres, yres;     // x- and y-resolution
    HSURF       hbitmap;        // handle to bitmap surface
    LONG        lineOffset;     // bitmap scanline byte offset
    DWORD       jobId;          // job ID

    DWORD       fileOffset;     // output byte count for current document
    PBYTE       pCompBits;      // buffer to hold G4 compressed bitmap data
    PBYTE       pCompBufPtr;    // pointer to next free byte in the buffer
    PBYTE       pCompBufMark;   // high-water mark
    DWORD       compBufSize;    // size of compressed bitmap data buffer
    DWORD       compBufInc;     // increment to enlarge the buffer when necessary
    PBYTE       prefline;       // raster data for the reference line
    INT         bitcnt;         // these two fields are used for assembling variable-length
    DWORD       bitdata;        // compressed bits into byte stream
    PVOID       pFaxIFD;        // IFD entries for each page

    PVOID       endDevData;     // data structure signature

} DEVDATA, *PDEVDATA;

//
// Constants for DEVDATA.flags field
//

#define PDEV_CANCELLED  0x0001  // current job has been cancelled
#define PDEV_RESETPDEV  0x0002  // DrvResetPDEV has been called
#define PDEV_WITHINPAGE 0x0004  // drawing on a page

//
// Check if a DEVDATA structure is valid
//

#define ValidDevData(pdev)  \
        ((pdev) && (pdev)->startDevData == (pdev) && (pdev)->endDevData == (pdev))

//
// Color values and indices
//

#define RGB_BLACK   RGB(0, 0, 0)
#define RGB_WHITE   RGB(255, 255, 255)

#define BLACK_INDEX 0
#define WHITE_INDEX 1

//
// Number of bits consisting a BYTE and a DWORD
//

#define BYTEBITS    8
#define DWORDBITS   (sizeof(DWORD) * BYTEBITS)

//
// Pad bit scanline data to N-byte boundary
//

#define PadBitsToBytes(bits, N) \
        ((((bits) + ((N) * BYTEBITS - 1)) / ((N) * BYTEBITS)) * (N))

//
// Macros for manipulating ROP4s and ROP3s
//

#define GetForegroundRop3(rop4) ((rop4) & 0xFF)
#define GetBackgroundRop3(rop4) (((rop4) >> 8) & 0xFF)
#define Rop3NeedPattern(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define Rop3NeedSource(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define Rop3NeedDest(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))

//
// Determine whether the page is in landscape mode
//

#define IsLandscapeMode(pdev)   ((pdev)->dm.dmPublic.dmOrientation == DMORIENT_LANDSCAPE)

//
// Returns the length of the hypotenouse of a right triangle
//

LONG
CalcHypot(
    LONG    x,
    LONG    y
    );

//
// Output a completed page bitmap to the spooler
//

BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    );

//
// Output document trailer information to the spooler
//

BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    );

#endif // !_FAXDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\cwabutil.h ===
#ifndef _CWABUTIL_H_
#define _CWABUTIL_H_

LPVOID 
InitializeWAB(
    HINSTANCE hInstance
    );

VOID 
UnInitializeWAB( 
    LPVOID 
    );

BOOL
CallWabAddress(
    HWND            hDlg,
    PUSERMEM        pUserMem,
    PRECIPIENT *    ppNewRecipient
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\async.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    async.c

Abstract:

    Functions for asynch send wizard actions

Environment:

        Windows NT fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxui.h"
#include "tapiutil.h"



DWORD
AsyncWizardThread(
    PBYTE param
    )
/*++

Routine Description:

    Do some agonizingly slow tasks asynchronously so the wizard seems faster to the user.

Arguments:

    none.

Return Value:

    not used.

--*/
{
    PUSERMEM pUserMem = (PUSERMEM) param;
#ifdef FAX_SCAN_ENABLED
    WCHAR TempPath[MAX_PATH];
#endif
    
    //
    // initialize tapi so that we can get tapi country codes, etc.
    //    

    InitTapiService();
    SetEvent(pUserMem->hTapiEvent);

    //
    // use server coverpages (may startup fax service, which is slow)
    //
    pUserMem->ServerCPOnly = UseServerCp(pUserMem->hPrinter);
    SetEvent(pUserMem->hFaxSvcEvent);
       
#ifdef FAX_SCAN_ENABLED
    //
    // look for twain stuff
    //
    if (GetEnvironmentVariable( L"NTFaxSendNote",
                                TempPath,
                                sizeof(TempPath)) == 0 || TempPath[0] != L'1') {
        pUserMem->TwainAvail = FALSE;
    } else {
        pUserMem->TwainAvail = InitializeTwain(pUserMem);
    }
    SetEvent(pUserMem->hTwainEvent);       
#endif

    return 0;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\cwabobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.cpp

Abstract:

    Interface to the windows address book.

Environment:

        Fax send wizard

Revision History:

        10/23/97 -GeorgeJe-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>

#include <wab.h>

#include "faxui.h"
#include "cwabobj.h"

static
LPWSTR
DupUnicodeString(
    LPWSTR  pStr
    );

static
LPWSTR
DupStringAnsiToUnicode(
    LPSTR  pAnsiStr
    );

static
LPSPropValue
FindProp(
    LPSPropValue rgprop,
    ULONG cprop,
    ULONG ulPropTag
    );

static
AddRecipient(
    PRECIPIENT *ppNewRecip,
    LPWSTR DisplayName,
    LPWSTR FaxNumber
    );

static SizedSPropTagArray(5, sPropTags) =
{
    5,
    {
        PR_DISPLAY_NAME_A,
        PR_PRIMARY_FAX_NUMBER_A,
        PR_HOME_FAX_NUMBER_A,
        PR_BUSINESS_FAX_NUMBER_A,
        PR_OBJECT_TYPE
    }
};

CWabObj::CWabObj(
    HINSTANCE hInstance
    )
/*++

Routine Description:

    Constructor for CWabObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    m_Initialized = FALSE;
    
    m_lpAdrList = NULL;

    m_hInstance = hInstance;
}

BOOL
CWabObj::Initialize(
    VOID
    )
/*++

Routine Description:

    intialization function for CWabObj class

Arguments:

    NONE

Return Value:

    TRUE if the object is initialized successfully, else FALSE

--*/

{
    TCHAR szDllPath[MAX_PATH];
    HKEY hKey = NULL;
    LONG rVal;
    DWORD dwType;
    DWORD cbData = MAX_PATH * sizeof(TCHAR);
    HRESULT hr;

    PCTSTR szDefaultPath = TEXT("%CommonProgramFiles%\\System\\wab32.dll");

    m_Initialized = TRUE;

    //
    // get the path to wab32.dll
    //
    rVal = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGVAL_WABPATH,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if (rVal == ERROR_SUCCESS) {

        rVal = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    &dwType,
                    (LPBYTE) szDllPath,
                    &cbData
                    );

        RegCloseKey( hKey );

    }

    if (rVal != ERROR_SUCCESS) {
        ExpandEnvironmentStrings(szDefaultPath,szDllPath,sizeof(szDllPath)/sizeof(TCHAR));
    }    

    m_hWab = LoadLibrary( szDllPath );

    if (m_hWab != NULL) {

        m_lpWabOpen = (LPWABOPEN) GetProcAddress( m_hWab , "WABOpen" );

    } else {

        m_lpWabOpen = (LPWABOPEN) NULL;

    }

    if (m_lpWabOpen == NULL) {
        hr = E_FAIL;
        goto exit;
    }

    //
    // open the wab
    //
    hr = m_lpWabOpen( &m_lpAdrBook, &m_lpWABObject, 0, 0 );

exit:
    if (HR_FAILED(hr)) {

        m_lpAdrBook = NULL;
        m_lpWABObject = NULL;
        m_Initialized = FALSE;
        if (m_hWab != NULL) {
            FreeLibrary( m_hWab );
        }
        m_hWab = NULL;        
    }

    return(m_Initialized);

}




CWabObj::~CWabObj()
/*++

Routine Description:

    Destructor for CWabObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    if (m_lpAdrBook) {
        m_lpAdrBook->Release();
    }

    if (m_lpWABObject) {
        m_lpWABObject->Release();
    }

    if ( m_hWab ) {
        FreeLibrary( m_hWab );
    }
}

BOOL
CWabObj::Address(
    HWND hWnd,
    PRECIPIENT pRecipients,
    PRECIPIENT * ppNewRecip
    )
/*++

Routine Description:

    Bring up the address book UI.  Prepopulate the to box with the entries in
    pRecipient.  Return the modified entries in ppNewRecip.

Arguments:

    hWnd - window handle to parent window
    pRecipients - list of recipients to look up
    ppNewRecipients - list of new/modified recipients

Return Value:

    TRUE if all recipients had a fax number.
    FALSE if one or more of them didn't.

--*/
{
    ADRPARM AdrParms = { 0 };
    LPADRLIST tmp;
    HRESULT hr;
    DWORD i;
    DWORD nRecips;
    PRECIPIENT tmpRecipient;
    ULONG DestComps[3] = { MAPI_TO, MAPI_CC, MAPI_BCC };
    DWORD cDropped;

    nRecips = 0;
    tmpRecipient = pRecipients;

    m_hWnd = hWnd;

    m_PickNumber = 0;

    //
    // count recipients and set up initial address list
    //
    while (tmpRecipient) {

        nRecips++;
        tmpRecipient = (PRECIPIENT) tmpRecipient->pNext;
    }

    if (nRecips > 0) {

        hr = m_lpWABObject->AllocateBuffer( CbNewADRLIST( nRecips ), (LPVOID *) &m_lpAdrList );
        m_lpAdrList->cEntries = nRecips;

    } else {

        m_lpAdrList = NULL;

    }

    for (i = 0, tmpRecipient = pRecipients; i < nRecips; i++, tmpRecipient = (PRECIPIENT) tmpRecipient->pNext) {

        LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[i];

        lpAdrEntry->cValues = 3;

        hr = m_lpWABObject->AllocateBuffer( sizeof( SPropValue ) * 3, (LPVOID *) &lpAdrEntry->rgPropVals );

        ZeroMemory( lpAdrEntry->rgPropVals, sizeof( SPropValue ) * 3 );

        lpAdrEntry->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
        lpAdrEntry->rgPropVals[0].Value.lpszA = DupStringUnicodeToAnsi( lpAdrEntry->rgPropVals, tmpRecipient->pName );
        lpAdrEntry->rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
        lpAdrEntry->rgPropVals[1].Value.l = MAPI_TO;
        lpAdrEntry->rgPropVals[2].ulPropTag = PR_PRIMARY_FAX_NUMBER_A;
        lpAdrEntry->rgPropVals[2].Value.lpszA = DupStringUnicodeToAnsi( lpAdrEntry->rgPropVals, tmpRecipient->pAddress );

    }

    tmp = m_lpAdrList;

    AdrParms.cDestFields = 1;
    AdrParms.ulFlags = DIALOG_MODAL;
    AdrParms.nDestFieldFocus = 0;
    AdrParms.lpulDestComps = DestComps;
    AdrParms.lpszCaption = TEXT( "" );

    //
    // Bring up the address book UI
    //
    hr = m_lpAdrBook->Address(
                (ULONG *) &hWnd,
                &AdrParms,
                &m_lpAdrList
                );

    if (FAILED (hr) || !m_lpAdrList || m_lpAdrList->cEntries == 0) {
        //
        // in this case the user pressed cancel, so we skip resolving any of our addresses that aren't listed in the
        // WAB
        //
        cDropped = 0;        
        goto skipresolve;
    }

    //
    // Resolve names
    //
    hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hWnd, 0, NULL, m_lpAdrList);

skipresolve:
    tmp = m_lpAdrList;

    if (m_lpAdrList) {

        for (i = cDropped = 0; i < m_lpAdrList->cEntries; i++) {
            LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[i];

            if (!InterpretAddress( lpAdrEntry->rgPropVals, lpAdrEntry->cValues, ppNewRecip )){
                cDropped++;
            }

        }

        //
        // Clean up
        //
        for (ULONG iEntry = 0; iEntry < m_lpAdrList->cEntries; ++iEntry)
        {
            if(m_lpAdrList->aEntries[iEntry].rgPropVals)
                m_lpWABObject->FreeBuffer(m_lpAdrList->aEntries[iEntry].rgPropVals);
        }
        m_lpWABObject->FreeBuffer(m_lpAdrList);
        m_lpAdrList = NULL;
    }

    m_hWnd = NULL;

    return cDropped == 0;
}

BOOL
CWabObj::InterpretAddress(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT *ppNewRecip
    )
/*++

Routine Description:

    Interpret the address book entry represented by SPropVal.

Arguments:

    SPropVal - Property values for address book entry.
    cValues - number of property values
    ppNewRecip - new recipient list

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/
{
    LPSPropValue lpSPropVal;
    LPWSTR FaxNumber, DisplayName;
    BOOL rVal = FALSE;

    //
    // get the object type
    //
    lpSPropVal = FindProp( SPropVal, cValues, PR_OBJECT_TYPE );

    if (lpSPropVal) {

        //
        // If the object is a mail user, get the fax numbers and add the recipient
        // to the list.  If the object is a distribtion list, process it.
        //

        switch (lpSPropVal->Value.l) {

            case MAPI_MAILUSER:

                if(GetRecipientInfo( SPropVal, cValues, &FaxNumber, &DisplayName )) {

                    AddRecipient( ppNewRecip, DisplayName, FaxNumber );

                    rVal = TRUE;
                }

                break;

            case MAPI_DISTLIST:

                rVal = InterpretDistList( SPropVal, cValues, ppNewRecip );
        }

        return rVal;

    } else {

        //
        // If there is no object type then this is valid entry that we queried on that went unresolved.
        // We know that there is a fax number so add it.
        //
        if(GetRecipientInfo( SPropVal, cValues, &FaxNumber, &DisplayName )) {
            AddRecipient( ppNewRecip, DisplayName, FaxNumber );
            rVal = TRUE;
        }

    }

    return rVal;
}

BOOL
CWabObj::InterpretDistList(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT * ppNewRecip
    )
/*++

Routine Description:

    Process a distribution list.

Arguments:

    SPropVal - Property values for distribution list.
    cValues - Number of properties.
    ppNewRecip - New recipient list.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

#define EXIT_IF_FAILED(hr) { if (FAILED(hr)) goto ExitDistList; }

{
    LPSPropValue    lpPropVals;
    LPSRowSet       pRows = NULL;
    LPDISTLIST      lpMailDistList = NULL;
    LPMAPITABLE     pMapiTable = NULL;
    ULONG           ulObjType, cRows;
    HRESULT         hr;
    BOOL            rVal = FALSE;

    lpPropVals = FindProp( SPropVal, cValues, PR_ENTRYID );

    if (lpPropVals) {
        LPENTRYID lpEntryId = (LPENTRYID) lpPropVals->Value.bin.lpb;
        DWORD cbEntryId = lpPropVals->Value.bin.cb;

        //
        // Open the recipient entry
        //

        hr = m_lpAdrBook->OpenEntry(
                    cbEntryId,
                    lpEntryId,
                    (LPCIID) NULL,
                    0,
                    &ulObjType,
                    (LPUNKNOWN *) &lpMailDistList
                    );

        EXIT_IF_FAILED( hr );

        //
        // Get the contents table of the address entry
        //

        hr = lpMailDistList->GetContentsTable(
                    MAPI_DEFERRED_ERRORS,
                    &pMapiTable
                    );

        EXIT_IF_FAILED(hr);

        //
        // Limit the query to only the properties we're interested in
        //

        hr = pMapiTable->SetColumns((LPSPropTagArray) &sPropTags, 0);

        EXIT_IF_FAILED(hr);

        //
        // Get the total number of rows
        //

        hr = pMapiTable->GetRowCount(0, &cRows);

        EXIT_IF_FAILED(hr);

        //
        // Get the individual entries of the distribution list
        //

        hr = pMapiTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);

        EXIT_IF_FAILED(hr);

        hr = pMapiTable->QueryRows(cRows, 0, &pRows);

        EXIT_IF_FAILED(hr);

        hr = S_OK;


        if (pRows && pRows->cRows) {

            //
            // Handle each entry of the distribution list in turn:
            //  for simple entries, call InterpretAddress
            //  for embedded distribution list, call this function recursively
            //

            for (cRows = 0; cRows < pRows->cRows; cRows++) {

                LPSPropValue lpProps = pRows->aRow[cRows].lpProps;
                ULONG cRowValues = pRows->aRow[cRows].cValues;

                lpPropVals = FindProp( lpProps, cRowValues, PR_OBJECT_TYPE );

                if (lpPropVals) {

                    switch (lpPropVals->Value.l) {

                        case MAPI_MAILUSER:

                            rVal = InterpretAddress( lpProps, cRowValues, ppNewRecip );

                            break;

                        case MAPI_DISTLIST:

                            rVal = InterpretDistList( lpProps, cRowValues, ppNewRecip );
                    }
                }
            }

        }
    }
ExitDistList:
    //
    // Perform necessary clean up before returning to caller
    //

    if (pRows) {

        for (cRows = 0; cRows < pRows->cRows; cRows++) {

            m_lpWABObject->FreeBuffer(pRows->aRow[cRows].lpProps);

        }

        m_lpWABObject->FreeBuffer(pRows);
    }

    if (pMapiTable)
        pMapiTable->Release();

    if (lpMailDistList)
        lpMailDistList->Release();

    return rVal;
}

INT_PTR
CALLBACK
ChooseFaxNumberDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Dialog proc for choose fax number dialog.

Arguments:

    lParam - pointer to PickFax structure.

Return Value:

    Control id of selection.

--*/

{
    PPICKFAX pPickFax = (PPICKFAX) lParam;
    TCHAR buffer[MAX_TITLE_LEN];

    switch (uMsg) {
        case WM_INITDIALOG:

            SetDlgItemText(hDlg, IDC_DISPLAY_NAME, pPickFax->DisplayName);

            buffer[0] = 0;
            GetDlgItemText(hDlg, IDC_BUSINESS_FAX, buffer, MAX_TITLE_LEN);
            _tcscat(buffer, pPickFax->BusinessFax);
            SetDlgItemText(hDlg, IDC_BUSINESS_FAX, buffer);

            buffer[0] = 0;
            GetDlgItemText(hDlg, IDC_HOME_FAX, buffer, MAX_TITLE_LEN);
            _tcscat(buffer, pPickFax->HomeFax);
            SetDlgItemText(hDlg, IDC_HOME_FAX, buffer);

            CheckDlgButton(hDlg, IDC_BUSINESS_FAX, BST_CHECKED);
            return TRUE;

        case WM_COMMAND:

            switch(LOWORD( wParam )){
                case IDOK:
                    if (IsDlgButtonChecked(hDlg, IDC_BUSINESS_FAX) == BST_CHECKED) {
                        if (IsDlgButtonChecked(hDlg, IDC_ALWAYS_OPTION) == BST_CHECKED) {
                            EndDialog(hDlg, IDC_ALLBUS);
                        }
                        else {
                            EndDialog(hDlg, IDC_BUSINESS_FAX);
                        }
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_HOME_FAX) == BST_CHECKED) {
                        if (IsDlgButtonChecked(hDlg, IDC_ALWAYS_OPTION) == BST_CHECKED) {
                            EndDialog(hDlg, IDC_ALLHOME);
                        }
                        else {
                            EndDialog(hDlg, IDC_HOME_FAX);
                        }
                    }

                    break;;
            }

            break;

        default:
            return FALSE;

    }

    return FALSE;
}

#define StrPropOk( strprop )    ((strprop) && (strprop)->Value.lpszA && *(strprop)->Value.lpszA)

BOOL
CWabObj::GetRecipientInfo(
    LPSPropValue SPropVals,
    ULONG cValues,
    LPWSTR * FaxNumber,
    LPWSTR * DisplayName
    )
/*++

Routine Description:

    Get the fax number and display name properties.

Arguments:

    SPropVal - Property values for distribution list.
    cValues - Number of properties.
    FaxNumber - pointer to pointer to string to hold the fax number.
    DisplayName - pointer to pointer to string to hold the display name.

Return Value:

    TRUE if there is a fax number and display name.
    FALSE otherwise.

--*/

{
    LPSPropValue lpPropVals;
    LPSPropValue lpPropArray;
    BOOL Result = FALSE;
    PICKFAX PickFax = { 0 };

    *FaxNumber = *DisplayName = NULL;


    //
    // Get the entryid and open the entry.
    //

    lpPropVals = FindProp( SPropVals, cValues, PR_ENTRYID );

    if (lpPropVals) {
        ULONG lpulObjType;
        LPMAILUSER lpMailUser = NULL;
        LPENTRYID lpEntryId = (LPENTRYID) lpPropVals->Value.bin.lpb;
        DWORD cbEntryId = lpPropVals->Value.bin.cb;
        HRESULT hr;
        ULONG countValues;

        hr = m_lpAdrBook->OpenEntry(
                    cbEntryId,
                    lpEntryId,
                    (LPCIID) NULL,
                    0,
                    &lpulObjType,
                    (LPUNKNOWN *) &lpMailUser
                    );

        if (HR_SUCCEEDED(hr)) {

            //
            // Get the properties.
            //
            hr = ((IMailUser *) lpMailUser)->GetProps( (LPSPropTagArray) &sPropTags, 0, &countValues, &lpPropArray );

            if (HR_SUCCEEDED(hr)) {

                lpPropVals = FindProp( lpPropArray, countValues, PR_BUSINESS_FAX_NUMBER_A );

                if (StrPropOk( lpPropVals )) {
                    PickFax.BusinessFax = DupStringAnsiToUnicode( lpPropVals->Value.lpszA );
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_HOME_FAX_NUMBER_A );

                if (StrPropOk( lpPropVals )) {
                    PickFax.HomeFax = DupStringAnsiToUnicode( lpPropVals->Value.lpszA );
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_DISPLAY_NAME_A );

                if (StrPropOk( lpPropVals )) {

                    *DisplayName = PickFax.DisplayName = DupStringAnsiToUnicode( lpPropVals->Value.lpszA );

                }

                //
                // If there are two fax numbers, ask the user to pick one.
                //
                if (PickFax.BusinessFax && PickFax.HomeFax) {
                    int dlgResult;

                    if (m_PickNumber != 0) {

                        dlgResult = m_PickNumber;

                    } else {
                        dlgResult = (int)DialogBoxParam(
                                         (HINSTANCE) m_hInstance,
                                         MAKEINTRESOURCE( IDD_CHOOSE_FAXNUMBER ),
                                         m_hWnd,
                                         ChooseFaxNumberDlgProc,
                                         (LPARAM) &PickFax
                                         );

                    }

                    switch( dlgResult ) {
                        case IDC_ALLBUS:
                            m_PickNumber = IDC_BUSINESS_FAX;
                            // fall through

                        case IDC_BUSINESS_FAX:

                            MemFree( PickFax.HomeFax );
                            *FaxNumber = PickFax.BusinessFax;
                            break;

                        case IDC_ALLHOME:
                            m_PickNumber = IDC_HOME_FAX;
                            // fall through

                        case IDC_HOME_FAX:

                            MemFree( PickFax.BusinessFax );
                            *FaxNumber = PickFax.HomeFax;
                            break;
                    }

                } else if (PickFax.BusinessFax) {

                    *FaxNumber = PickFax.BusinessFax;

                } else if (PickFax.HomeFax) {

                    *FaxNumber = PickFax.HomeFax;

                }


            }

            m_lpWABObject->FreeBuffer( lpPropArray );
        }

        if (lpMailUser) {
            lpMailUser->Release();
        }

    } else {
        // If there is no entryid, then this is a valid entry that we queried on that went unresolved
        // add if anyway.  In this case we know that PR_PRIMARY_FAX_NUMBER_A and PR_DISPLAY_NAME_A will be
        // present.

        lpPropVals = FindProp( SPropVals, cValues, PR_PRIMARY_FAX_NUMBER_A );

        if (lpPropVals) {

            *FaxNumber = DupStringAnsiToUnicode( lpPropVals->Value.lpszA );
        }

        lpPropVals = FindProp( SPropVals, cValues, PR_DISPLAY_NAME_A );

        if (lpPropVals) {

            *DisplayName = DupStringAnsiToUnicode( lpPropVals->Value.lpszA );
        }


    }

    if (FaxNumber && DisplayName) {
        return (*FaxNumber != 0 && *DisplayName != 0);
    } else {
        return FALSE;
    }
}

LPSPropValue
FindProp(
    LPSPropValue rgprop,
    ULONG cprop,
    ULONG ulPropTag
    )
/*++

Routine Description:

    Searches for a given property tag in a propset. If the given
    property tag has type PT_UNSPECIFIED, matches only on the
    property ID; otherwise, matches on the entire tag.

Arguments:

    rgprop - Property values.
    cprop - Number of properties.
    ulPropTag - Property to search for.

Return Value:

    Pointer to property desired property value or NULL.
--*/

{
    BOOL f = PROP_TYPE(ulPropTag) == PT_UNSPECIFIED;
    LPSPropValue pprop = rgprop;

    if (!cprop || !rgprop)
        return NULL;

    while (cprop--)
    {
        if (pprop->ulPropTag == ulPropTag ||
                         (f && PROP_ID(pprop->ulPropTag) == PROP_ID(ulPropTag)))
                return pprop;
        ++pprop;
    }

    return NULL;
}

LPSTR
CWabObj::DupStringUnicodeToAnsi(
    LPVOID  lpObject,
    LPWSTR  pUnicodeStr
    )

/*++

Routine Description:

    Convert a Unicode string to a multi-byte string

Arguments:

    pUnicodeStr - Pointer to the Unicode string to be duplicated

Return Value:

    Pointer to the duplicated multi-byte string

NOTE:

    This is only need because the WAB is not Unicode enabled on NT.

    This uses the WAB memory allocator so it must be freed with FreeBuffer.
--*/

{
    INT     nChar;
    LPSTR   pAnsiStr;

    //
    // Figure out how much memory to allocate for the multi-byte string
    //

    if (! (nChar = WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, NULL, 0, NULL, NULL)) ||
        ! HR_SUCCEEDED( m_lpWABObject->AllocateMore( nChar, lpObject, (LPVOID *) &pAnsiStr )))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, pAnsiStr, nChar, NULL, NULL);
    return pAnsiStr;
}

LPWSTR
DupStringAnsiToUnicode(
    LPSTR  pAnsiStr
    )

/*++

Routine Description:

    Convert a multi-byte string to a Unicode string

Arguments:

    pAnsiStr - Pointer to the Ansi string to be duplicated

Return Value:

    Pointer to the duplicated Unicode string

NOTE:

    This is only need because MAPI is not Unicode enabled on NT.

    This routine uses MemAlloc to allocate memory so the caller needs
    to use MemFree.
--*/

{
    INT     nChar;
    LPWSTR   pUnicodeStr;

    //
    // Figure out how much memory to allocate for the Unicode string
    //

    if (! (nChar = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAnsiStr, -1, NULL, 0)) ||
        ! ( pUnicodeStr = (LPWSTR) MemAlloc( nChar * sizeof(WCHAR) ) ))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAnsiStr, -1, pUnicodeStr, nChar);

    return pUnicodeStr;
}

LPWSTR
DupUnicodeString(
    LPWSTR  pStr
    )
/*++

Routine Description:

    Duplicate a Unicode string.

Arguments:

    pStr - pointer to string to duplicate.

Return Value:

    pointer to duplicated string.
--*/

{
    LPWSTR NewStr;

    NewStr = (LPWSTR) MemAlloc( (wcslen( pStr ) + 1) * sizeof (WCHAR));
    wcscpy( NewStr, pStr );
    return NewStr;
}


AddRecipient(
    PRECIPIENT *ppNewRecip,
    LPWSTR DisplayName,
    LPWSTR FaxNumber
    )
/*++

Routine Description:

    Add a recipient to the recipient list.

Arguments:

    ppNewRecip - pointer to pointer to list to add item to.
    DisplayName - recipient name.
    FaxNumber - recipient fax number.

Return Value:

    NA
--*/
{
    PRECIPIENT NewRecip;

    NewRecip = (PRECIPIENT) MemAllocZ( sizeof( RECIPIENT ) );

    if (NewRecip) {

        NewRecip->pName = DisplayName;
        NewRecip->pAddress = FaxNumber;
        NewRecip->pNext = (LPVOID) *ppNewRecip;
        *ppNewRecip = NewRecip;
    }

    return 0;
}


extern "C"
BOOL
CallWabAddress(
    HWND hDlg,
    PUSERMEM pUserMem,
    PRECIPIENT * ppNewRecipient
    )
/*++

Routine Description:

    C wrapper for CWabObj->Address

Arguments:

    hDlg - parent window handle.
    pUserMem - pointer to USERMEM structure
    ppNewRecipient - list to add new recipients to.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

{
    LPWABOBJ lpCWabObj = (LPWABOBJ) pUserMem->lpWabInit;

    return lpCWabObj->Address(
                hDlg,
                pUserMem->pRecipients,
                ppNewRecipient
                );

}

extern "C"
LPVOID
InitializeWAB(
    HINSTANCE hInstance
    )
/*++

Routine Description:

    Initialize the WAB.

Arguments:

    hInstance - instance handle.

Return Value:

    NONE
--*/

{
    LPWABOBJ lpWabObj = new CWabObj( hInstance );

    if (lpWabObj) {
        if (!lpWabObj->Initialize()) {
            delete (lpWabObj);
            lpWabObj = NULL;
        }
    }

    return (LPVOID) lpWabObj;
}

extern "C"
VOID
UnInitializeWAB(
    LPVOID lpVoid
    )
/*++

Routine Description:

    UnInitialize the WAB.

Arguments:

    NONE

Return Value:

    NONE
--*/

{
    LPWABOBJ lpWabObj = (LPWABOBJ) lpVoid;

    delete lpWabObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\coverpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.h

Abstract:

    Functions for working with cover pages

Environment:

        Windows NT fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _COVERPAGE_H_
#define _COVERPAGE_H_

//
// Directory on the server for storing cover pages.
// This is concatenated with \\servername\print$.
//

#define SERVER_CP_DIRECTORY TEXT("\\CoverPg\\")

//
// Cover page filename extension and link filename extension
//

#define CP_FILENAME_EXT     TEXT(".cov")
#define LNK_FILENAME_EXT    TEXT(".lnk")
#define MAX_FILENAME_EXT    4

//
// Data structure for representing a list of cover pages:
//  the first nServerDirs paths refer to the server cover page directory
//  remaining paths contain user cover page directories
//

#define MAX_COVERPAGE_DIRS  8

typedef struct {

    INT     nDirs;
    INT     nServerDirs;
    LPTSTR  pDirPath[MAX_COVERPAGE_DIRS];

} CPDATA, *PCPDATA;

//
// Flag bits attached to each cover page in a listbox
//

#define CPFLAG_DIRINDEX 0x00FF
#define CPFLAG_SERVERCP 0x0100
#define CPFLAG_LINK     0x0200
#define CPFLAG_SELECTED 0x0400
#define CPFLAG_SUFFIX   0x0800

//
// Generate a list of available cover pages (both server and user)
//

VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    );

//
// Retrieve the currently selected cover page name
//

INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pBuffer
    );

//
// Allocate memory to hold cover page information
//

PCPDATA
AllocCoverPageInfo(
    HANDLE  hPrinter,
    BOOL ServerCpOnly
    );

//
// must clients use server coverpages?
//

BOOL
UseServerCp(
    HANDLE  hPrinter
    );

//
// Free up memory used for cover page information
//

VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    );

//
// Resolve a shortcut to find the destination file
//

BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

//
// Function to determine whether CoInitialize was called
//

BOOL
IsOleInitialized(
    VOID
    );

//
// Perform OLE initialization if necessary
//

VOID
DoOleInitialization(
    VOID
    );

#endif  // !_COVERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\page.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    page.c

Abstract:

    Implementation of document and page related DDI entry points:
        DrvStartDoc
        DrvEndDoc
        DrvStartPage
        DrvSendPage

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    pDocName - Specifies a Unicode document name
    jobId - Identifies the print job

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvStartDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Initialize page count and other information
    //

    if (! (pdev->flags & PDEV_RESETPDEV)) {

        pdev->pageCount = 0;
        pdev->jobId = jobId;
    }

    return TRUE;
}



BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;
    RECTL       pageRect;

    Verbose(("Entering DrvStartPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Ignore nested calls to DrvStartPage
    //

    if (pdev->flags & PDEV_WITHINPAGE) {

        Error(("Nested call to DrvStartPage\n"));
        return TRUE;
    }

    pdev->flags |= PDEV_WITHINPAGE;

    //
    // Erase the page to all white
    //

    pageRect.left = pageRect.top = 0;
    pageRect.right = pdev->imageSize.cx;
    pageRect.bottom = pdev->imageSize.cy;

    EngEraseSurface(pso, &pageRect, WHITE_INDEX);

    pdev->pageCount++;
    return TRUE;
}



BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvSendPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvSendPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Assert(pdev->flags & PDEV_WITHINPAGE);
    pdev->flags &= ~PDEV_WITHINPAGE;

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Output code to end a page
    //

    Assert(pso->lDelta == pdev->lineOffset);
    Assert(pso->fjBitmap & BMF_TOPDOWN);

    return OutputPageBitmap(pdev, pso->pvBits);
}



BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEndDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    flags - A set of flag bits

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvEndDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((pdev->flags & PDEV_CANCELLED) || (flags & ED_ABORTDOC)) {

        Error(("Print job was cancelled\n"));

    } else if (pdev->pageCount) {

        //
        // Perform any necessary work at the end of a document
        //

        Verbose(("Number of pages printed: %d\n", pdev->pageCount));
        OutputDocTrailer(pdev);
    }

    //
    // Clean up
    //

    pdev->pageCount = 0;
    pdev->flags = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\cwabobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.h

Abstract:

    Class definition for CWabObj

Environment:

        Fax send wizard

Revision History:

        10/23/97 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#define REGVAL_WABPATH  TEXT("Software\\Microsoft\\WAB\\DLLPath")

typedef class CWabObj {
    
    HINSTANCE   m_hWab;
    LPWABOPEN   m_lpWabOpen;

    LPADRBOOK   m_lpAdrBook;
    LPWABOBJECT m_lpWABObject;

    LPADRLIST   m_lpAdrList; 

    BOOL        m_Initialized;
    
    HWND        m_hWnd;

    HINSTANCE   m_hInstance;

    DWORD       m_PickNumber;

    LPSTR       DupStringUnicodeToAnsi(
                        LPVOID  lpObject,
                        LPWSTR  pUnicodeStr
                        );
                
    BOOL        GetRecipientInfo(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    LPWSTR * FaxNumber,
                    LPWSTR * DisplayName
                    );

    BOOL        InterpretAddress(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT *ppNewRecip
                    );
                
    BOOL        InterpretDistList(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT *ppNewRecip
                    );

                    
public:

    CWabObj(HINSTANCE hInstance);
    ~CWabObj();

    BOOL
    Initialize();
    
    BOOL
    Address( 
        HWND hWnd,
        PRECIPIENT pRecip,
        PRECIPIENT * ppNewRecip
        );

} WABOBJ, * LPWABOBJ;


typedef struct {
    LPWSTR DisplayName;
    LPWSTR BusinessFax;
    LPWSTR HomeFax;
} PICKFAX, * PPICKFAX;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\coverpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for working with cover pages

Environment:

        Windows NT fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxui.h"

#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>

//
// Suffix string appended to all user cover page filenames
//

static TCHAR PersonalSuffixStr[64];



VOID
InsertOneCoverPageFilenameToList(
    HWND    hwndList,
    LPTSTR  pFilename,
    INT     flags
    )

/*++

Routine Description:

    Insert one cover page filename into the list of cover pages

Arguments:

    hwndList - Handle to list window
    pFilename - Name of the cover page file
    flags - Flags to be associated with the list item

Return Value:

    NONE

--*/

{
    INT     listIndex;
    LPTSTR  pBuffer = NULL;

    //
    // Add " (Personal)" suffix to all user cover pages
    //

    if ((flags & CPFLAG_SERVERCP) == 0) {

        if (IsEmptyString(PersonalSuffixStr))
            LoadString(ghInstance, IDS_USERCP_SUFFIX, PersonalSuffixStr, 64);

        if (pBuffer = MemAlloc(SizeOfString(pFilename) + SizeOfString(PersonalSuffixStr))) {

            _tcscpy(pBuffer, pFilename);
            _tcscat(pBuffer, PersonalSuffixStr);

            flags |= CPFLAG_SUFFIX;
            pFilename = pBuffer;
        }
    }

    //
    // Insert the cover page filename into the list
    //

    listIndex = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFilename);

    if (listIndex != CB_ERR)
        SendMessage(hwndList, CB_SETITEMDATA, listIndex, flags);

    MemFree(pBuffer);
}



VOID
AddCoverPagesToList(
    PCPDATA     pCPInfo,
    HWND        hwndList,
    LPTSTR      pSelected,
    INT         nDirs
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a list

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to a list window
    pSelected - Currently selected cover page
    nDirs - Cover page directory index

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           filename[MAX_PATH];
    HANDLE          hFindFile;
    LPTSTR          pDirPath, pFilename, pExtension;
    INT             dirLen, fileLen, flags;

    //
    // Are we working on server or user cover pages?
    //

    flags = nDirs | ((nDirs < pCPInfo->nServerDirs) ? CPFLAG_SERVERCP : 0);
    pDirPath = pCPInfo->pDirPath[nDirs];

    if (IsEmptyString(pDirPath))
        return;

    //
    // Look at the directory prefix of the currently selected cover page file
    //

    if ((dirLen = _tcslen(pDirPath)) >= MAX_PATH - MAX_FILENAME_EXT - 1) {

        Error(("Directory name too long: %ws\n", pDirPath));
        return;
    }

    _tcscpy(filename, pDirPath);

    if (_tcsnicmp(pDirPath, pSelected, dirLen) != EQUAL_STRING)
        pSelected = NULL;
    else
        pSelected += dirLen;

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    do {

        //
        // Generate a specification for the files we're interested in
        //

        pFilename = &filename[dirLen];
        *pFilename = TEXT('*');
        _tcscpy(pFilename+1, (flags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile(filename, &findData);

        if (hFindFile != INVALID_HANDLE_VALUE) {

            do {

                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY))
                    continue;

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = _tcslen(findData.cFileName)) <= MAX_FILENAME_EXT)
                    continue;

                if (fileLen + dirLen >= MAX_PATH) {

                    Error(("Filename too long: %ws%ws\n", pDirPath, findData.cFileName));
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (flags & CPFLAG_LINK) {

                    _tcscpy(pFilename, findData.cFileName);

                    if (! IsCoverPageShortcut(filename))
                        continue;
                }

                //
                // Compare with the currently selected cover page filename
                //

                if (pSelected && _tcsicmp(pSelected, findData.cFileName) == EQUAL_STRING) {

                    pSelected = NULL;
                    flags |= CPFLAG_SELECTED;

                } else
                    flags &= ~CPFLAG_SELECTED;

                //
                // Don't display the filename extension
                //

                if (pExtension = _tcsrchr(findData.cFileName, TEXT(FILENAME_EXT))) {
                    *pExtension = NUL;
                }

                //
                // Add the cover page name to the list window
                //

                InsertOneCoverPageFilenameToList(hwndList, findData.cFileName, flags);

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;

    } while ((flags & CPFLAG_LINK) && ! (flags & CPFLAG_SERVERCP));
}



VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    )

/*++

Routine Description:

    Generate a list of available cover pages (both server and user)

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pSelectedCoverPage - Name of currently selected cover page file

Return Value:

    NONE

--*/

{
    INT itemFlags, index;

    //
    // Validate input parameters
    //

    if (pCPInfo == NULL || hwndList == NULL)
        return;

    //
    // Disable redraw on the list and reset its content
    //

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Add server and user cover pages to the list
    //

    for (index=0; index < pCPInfo->nDirs; index++)
        AddCoverPagesToList(pCPInfo, hwndList, pSelectedCoverPage, index);

    //
    // Highlight the currently selected cover page
    //

    index = (INT)SendMessage(hwndList, CB_GETCOUNT, 0, 0);

    if (index > 0) {

        //
        // Go through each list item and check if it should be selected
        //

        while (--index >= 0) {

            itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, index, 0);

            if (itemFlags != CB_ERR && (itemFlags & CPFLAG_SELECTED)) {

                SendMessage(hwndList, CB_SETCURSEL, index, 0);
                break;
            }
        }

        //
        // If nothing is selected, select the first item by default
        //

        if (index < 0)
            SendMessage(hwndList, CB_SETCURSEL, 0, 0);
    }

    //
    // Enable redraw on the list window
    //

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
}



INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pBuffer
    )

/*++

Routine Description:

    Retrieve the currently selected cover page name

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pBuffer - Points to a buffer for storing the selected cover page filename
        The size of the buffer is assumed to be MAX_PATH characters.
        if pBuffer is NULL, we assume the called is interested in the item flags

Return Value:

    Flags associated with the currently selected item
    Negative if there is an error

--*/

{
    LPTSTR      pDirPath, pFilename;
    INT         selIndex, itemFlags, nameLen;

    //
    // Default to empty string in case of an error
    //

    if (pBuffer)
        pBuffer[0] = NUL;

    if (pCPInfo == NULL || hwndList == NULL)
        return CB_ERR;

    //
    // Get currently selected item index
    //

    if ((selIndex = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR)
        return selIndex;

    //
    // Get the flags associated with the currently selected item
    //

    itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0);

    if (itemFlags != CB_ERR && pBuffer != NULL) {

        Assert((itemFlags & CPFLAG_DIRINDEX) < pCPInfo->nDirs);
        pDirPath = pCPInfo->pDirPath[itemFlags & CPFLAG_DIRINDEX];

        //
        // Assemble the full pathname for the cover page file
        //  directory prefix
        //  display name
        //  filename extension
        //

        while (*pBuffer++ = *pDirPath++)
            NULL;

        pBuffer--;
        pFilename = NULL;

        if ((nameLen = (INT)SendMessage(hwndList, CB_GETLBTEXTLEN, selIndex, 0)) != CB_ERR &&
            (pFilename = MemAlloc(sizeof(TCHAR) * (nameLen + 1))) &&
            SendMessage(hwndList, CB_GETLBTEXT, selIndex, (LPARAM) pFilename) != CB_ERR)
        {
            //
            // If the cover page filename has a suffix, we need to remove it first
            //

            if (itemFlags & CPFLAG_SUFFIX) {

                INT suffixLen = _tcslen(PersonalSuffixStr);

                if (nameLen >= suffixLen &&
                    _tcscmp(pFilename + (nameLen - suffixLen), PersonalSuffixStr) == EQUAL_STRING)
                {
                    *(pFilename + (nameLen - suffixLen)) = NUL;

                } else
                    Error(("Corrupted cover page filename: %ws\n", pFilename));

            }

            _tcscpy(pBuffer, pFilename);
            _tcscat(pBuffer, (itemFlags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

        } else
            itemFlags = CB_ERR;

        MemFree(pFilename);
    }

    return itemFlags;
}



BOOL
GetServerCoverPageDirs(
    HANDLE  hPrinter,
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Find the directories in which the server cover pages are stored

Arguments:

    hPrinter - Handle to a printer object
    pCPInfo - Points to cover page information

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PPRINTER_INFO_2 pPrinterInfo2;
    BOOL            status = FALSE;    
    LPTSTR          pServerDir = NULL;
    LPTSTR          pServerSubDir, p;

    //
    // Find the name of the print server - We really would like to use
    // level 4 instead of level 2 here. But GetPrinter returns error for
    // remote printers.
    //

    if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)))
        return FALSE;

    if ( !(pServerDir = MemAlloc(sizeof(TCHAR) * MAX_PATH)) ||
         !GetServerCpDir(pPrinterInfo2->pServerName,pServerDir,MAX_PATH*sizeof(TCHAR)) )   {
        goto exit;
    }
    
    pCPInfo->pDirPath[pCPInfo->nDirs] = pServerDir;
    pCPInfo->nDirs += 1;
    pCPInfo->nServerDirs += 1;
    status = TRUE;

    //
    // Find a subdirectory for the specified printer
    //

    if (p = _tcsrchr(pPrinterInfo2->pPrinterName, TEXT(PATH_SEPARATOR)))
        p++;
    else
        p = pPrinterInfo2->pPrinterName;

    if ((_tcslen(pServerDir) + _tcslen(p) < MAX_PATH) &&
        (pServerSubDir = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
    {
        _tcscpy(pServerSubDir, pServerDir);
        ConcatenatePaths(pServerSubDir, p);        

        pCPInfo->pDirPath[pCPInfo->nDirs] = pServerSubDir;
        pCPInfo->nDirs += 1;
        pCPInfo->nServerDirs += 1;
    }
    

    //
    // Clean up before returning to caller
    //

exit:
    if (!status) {
        MemFree(pServerDir);
    }

    MemFree( pPrinterInfo2 );

    return status;
}



VOID
AppendPathSeparator(
    LPTSTR  pDirPath
    )

/*++

Routine Description:

    Append a path separator (if necessary) at the end of a directory name

Arguments:

    pDirPath - Points to a directory name

Return Value:

    NONE

--*/

{
    INT length;


    //
    // Calculate the length of directory string
    //

    length = _tcslen(pDirPath);

    if (length >= MAX_PATH-1 || length < 1)
        return;

    //
    // If the last character is not a path separator,
    // append a path separator at the end
    //

    if (pDirPath[length-1] != TEXT(PATH_SEPARATOR)) {

        pDirPath[length] = TEXT(PATH_SEPARATOR);
        pDirPath[length+1] = NUL;
    }
}



BOOL
UseServerCp(
    HANDLE  hPrinter
    )
{
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    HANDLE FaxHandle = NULL;
    PFAX_CONFIGURATION FaxConfig = NULL;
    BOOL Rval = FALSE;
    HMODULE hMod = NULL;
    PFAXCONNECTFAXSERVERW pFaxConnectFaxServer;
    PFAXCLOSE pFaxClose;
    PFAXFREEBUFFER pFaxFreeBuffer;
    PFAXGETCONFIGURATIONW pFaxGetConfiguration;


    hMod = LoadLibrary( L"winfax.dll" );
    if (hMod == NULL) {
        return FALSE;
    }

    pFaxConnectFaxServer = (PFAXCONNECTFAXSERVER) GetProcAddress( hMod, "FaxConnectFaxServerW" );
    pFaxClose = (PFAXCLOSE) GetProcAddress( hMod, "FaxClose" );
    pFaxFreeBuffer = (PFAXFREEBUFFER) GetProcAddress( hMod, "FaxFreeBuffer" );
    pFaxGetConfiguration = (PFAXGETCONFIGURATIONW) GetProcAddress( hMod, "FaxGetConfigurationW" );

    if (pFaxConnectFaxServer == NULL || pFaxClose == NULL || pFaxFreeBuffer == NULL || pFaxGetConfiguration == NULL) {
        FreeLibrary( hMod );
        return FALSE;
    }

    if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2))) {
        goto exit;
    }

    if (!pFaxConnectFaxServer( pPrinterInfo2->pServerName, &FaxHandle )) {
        goto exit;
    }

    if (!pFaxGetConfiguration( FaxHandle, &FaxConfig )) {
        goto exit;
    }

    Rval = FaxConfig->ServerCp;

exit:
    if (pPrinterInfo2) {
        MemFree( pPrinterInfo2 );
    }
    if (FaxConfig) {
        pFaxFreeBuffer( FaxConfig );
    }
    if (FaxHandle) {
        pFaxClose( FaxHandle );
    }

    return Rval;
}



PCPDATA
AllocCoverPageInfo(
    HANDLE  hPrinter,
    BOOL    ServerCpOnly
    )

/*++

Routine Description:

    Allocate memory to hold cover page information

Arguments:

    hPrinter - Handle to a printer object

Return Value:

    Pointer to a CPDATA structure, NULL if there is an error

--*/

{
    PCPDATA pCPInfo;
    INT     nDirs;
    LPTSTR  pDirPath, pUserCPDir, pSavedPtr;


    if (pCPInfo = MemAllocZ(sizeof(CPDATA))) {

        //
        // Find the directory in which the server cover pages are stored
        //

        if (! GetServerCoverPageDirs(hPrinter, pCPInfo))
            Error(("Couldn't get server cover page directories\n"));

        //
        // Find the directory in which the user cover pages are stored
        //

        if (ServerCpOnly == FALSE &&
            (pUserCPDir = pSavedPtr = GetUserCoverPageDir()))
        {
            while (*pUserCPDir && pCPInfo->nDirs < MAX_COVERPAGE_DIRS) {

                LPTSTR  pNextDir = pUserCPDir;

                //
                // Find the next semicolon character
                //

                while (*pNextDir && *pNextDir != TEXT(';'))
                    pNextDir++;

                if (*pNextDir != NUL)
                    *pNextDir++ = NUL;

                //
                // Make sure the directory name is not too long
                //

                if (_tcslen(pUserCPDir) < MAX_PATH) {

                    if (! (pDirPath = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
                        break;

                    pCPInfo->pDirPath[pCPInfo->nDirs++] = pDirPath;
                    _tcscpy(pDirPath, pUserCPDir);
                }

                pUserCPDir = pNextDir;
            }

            MemFree(pSavedPtr);
        }

        //
        // Append path separators at the end if necessary
        //

        for (nDirs=0; nDirs < pCPInfo->nDirs; nDirs++) {

            AppendPathSeparator(pCPInfo->pDirPath[nDirs]);
            Verbose(("Cover page directory: %ws\n", pCPInfo->pDirPath[nDirs]));
        }
    }

    return pCPInfo;
}



VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Free up memory used for cover page information

Arguments:

    pCPInfo - Points to cover page information to be freed

Return Value:

    NONE

--*/

{
    if (pCPInfo) {

        INT index;

        for (index=0; index < pCPInfo->nDirs; index++)
            MemFree(pCPInfo->pDirPath[index]);

        MemFree(pCPInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\devcaps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devcaps.c

Abstract:

    Implementation of DrvDeviceCapabilities

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"

//
// Forward declaration for local functions
//

DWORD
CalcMinMaxExtent(
    PPOINT      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

DWORD
EnumResolutions(
    PLONG       pResolutions
    );



DWORD
DrvDeviceCapabilities(
    HANDLE      hPrinter,
    LPTSTR      pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Provides information about the specified device and its capabilities

Arguments:

    hPrinter - Identifies a printer object
    pDeviceName - Points to a null-terminated device name string
    wCapability - Specifies the interested device capability
    pOutput - Points to the output buffer
    pdm - Points to the source devmode structure

Return Value:

    The return value depends on wCapability.

Note:

    Please refer for DDK documentation for more details.

--*/

{
    FORM_INFO_1 *pFormsDB;
    DWORD       cForms;
    PVOID       pdmAlloced;
    DWORD       result = 0;

    Verbose(("Entering DrvDeviceCapabilities: %d %x...\n", wCapability, pOutput));

    //
    // Validate input devmode and combine it with driver default
    //

    if (! (pdmAlloced = MemAlloc(sizeof(DRVDEVMODE)))) {

        Error(("Memory allocation failed\n"));
        return GDI_ERROR;
    }

    DriverDefaultDevmode(pdmAlloced, pDeviceName, hPrinter);
    pdm = pdmAlloced;
    result = 0;

    //
    // Return appropriate information depending upon wCapability
    //

    switch (wCapability) {

    case DC_VERSION:

        result = pdm->dmSpecVersion;
        break;

    case DC_DRIVER:

        result = pdm->dmDriverVersion;
        break;

    case DC_SIZE:

        result = pdm->dmSize;
        break;

    case DC_EXTRA:

        result = pdm->dmDriverExtra;
        break;

    case DC_FIELDS:

        result = pdm->dmFields;
        break;

    case DC_COPIES:

        //
        // Pretend that we can handle huge number of copies so that
        // the apps won't try to do multi-copies themselves.
        //

        result = 1000;
        break;

    case DC_ORIENTATION:

        //
        // Landscape rotates counterclockwise
        //

        result = 90;
        break;

    case DC_PAPERNAMES:
    case DC_PAPERS:
    case DC_PAPERSIZE:
    case DC_MINEXTENT:
    case DC_MAXEXTENT:

        //
        // Get a list of forms in the forms database
        //

        pFormsDB = GetFormsDatabase(hPrinter, &cForms);

        if (pFormsDB == NULL || cForms == 0) {

            Error(("Cannot get system forms\n"));
            return GDI_ERROR;
        }

        result = (wCapability == DC_MINEXTENT || wCapability == DC_MAXEXTENT) ?
                    CalcMinMaxExtent(pOutput, pFormsDB, cForms, wCapability) :
                    EnumPaperSizes(pOutput, pFormsDB, cForms, wCapability);

        MemFree(pFormsDB);
        break;

    case DC_BINNAMES:

        //
        // Simulate a single input slot
        //

        if (pOutput)
            LoadString(ghInstance, IDS_SLOT_ONLYONE, pOutput, CCHBINNAME);
        result = 1;
        break;

    case DC_BINS:

        if (pOutput)
            *((PWORD) pOutput) = DMBIN_ONLYONE;
        result = 1;
        break;

    case DC_ENUMRESOLUTIONS:

        result = EnumResolutions(pOutput);
        break;

    default:

        Error(("Unknown device capability: %d\n", wCapability));
        result = GDI_ERROR;
        break;
    }

    MemFree(pdmAlloced);
    return result;
}



DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves a list of supported paper sizes

Arguments:

    pOutput - Specifies a buffer for storing requested information
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - Specifies what the caller is interested in

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LPTSTR  pPaperNames = NULL;
    PWORD   pPapers = NULL;
    PPOINT  pPaperSizes = NULL;

    //
    // Figure out what the caller is interested in
    //

    switch (wCapability) {

    case DC_PAPERNAMES:
        pPaperNames = pOutput;
        break;

    case DC_PAPERSIZE:
        pPaperSizes = pOutput;
        break;

    case DC_PAPERS:
        pPapers = pOutput;
        break;

    default:
        Assert(FALSE);
    }

    //
    // Go through each form in the forms database
    //

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect requested information
        //

        if (! IsSupportedForm(pFormsDB))
            continue;

        count++;

        //
        // Return the size of the form in 0.1mm units.
        // The unit used in FORM_INFO_1 is 0.001mm.
        //

        if (pPaperSizes) {

            pPaperSizes->x = pFormsDB->Size.cx / 100;
            pPaperSizes->y = pFormsDB->Size.cy / 100;
            pPaperSizes++;
        }

        //
        // Return the formname.
        //

        if (pPaperNames) {

            CopyString(pPaperNames, pFormsDB->pName, CCHPAPERNAME);
            pPaperNames += CCHPAPERNAME;
        }

        //
        // Return one-based index of the form.
        //

        if (pPapers)
            *pPapers++ = (WORD) index + DMPAPER_FIRST;
    }

    return count;
}



DWORD
CalcMinMaxExtent(
    PPOINT      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves the minimum or maximum paper size extent

Arguments:

    pOutput - Specifies a buffer for storing requested information
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - What the caller is interested in: DC_MAXEXTENT or DC_MINEXTENT

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LONG    minX, minY, maxX, maxY;

    //
    // Go through each form in the forms database
    //

    minX = minY = MAX_LONG;
    maxX = maxY = 0;

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect the requested information
        //

        if (! IsSupportedForm(pFormsDB))
            continue;

        count++;

        if (pOutput == NULL)
            continue;

        if (minX > pFormsDB->Size.cx)
            minX = pFormsDB->Size.cx;

        if (minY > pFormsDB->Size.cy)
            minY = pFormsDB->Size.cy;

        if (maxX < pFormsDB->Size.cx)
            maxX = pFormsDB->Size.cx;

        if (maxY < pFormsDB->Size.cy)
            maxY = pFormsDB->Size.cy;
    }

    //
    // If an output buffer is provided, store the calculated
    // minimum and maximum extent information.
    //

    if (pOutput != NULL) {

        //
        // NOTE: What unit does the caller expect?! The documentation
        // doesn't mention anything about this. I assume this should
        // be in the same unit as DEVMODE.dmPaperLength, which is 0.1mm.
        //

        if (wCapability == DC_MINEXTENT) {

            pOutput->x = minX / 100;
            pOutput->y = minY / 100;

        } else {

            pOutput->x = maxX / 100;
            pOutput->y = maxY / 100;
        }
    }

    return count;
}



DWORD
EnumResolutions(
    PLONG       pResolutions
    )

/*++

Routine Description:

    Retrieves a list of supported resolutions

Arguments:

    pResolutions - Specifies a buffer for storing resolution information

Return Value:

    Number of resolutions supported

Note:

    Each resolution is represented by two LONGs representing
    horizontal and vertical resolutions (in dpi) respectively.

--*/

{
    if (pResolutions != NULL) {

        //
        // We support the following resolution settings:
        //  Normal = 200x200 dpi
        //  Draft = 200x100 dpi
        //

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTICAL;

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTDRAFT;
    }

    return 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\docevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docevent.c

Abstract:

    Implementation of DrvDocumentEvent

Environment:

    Fax driver user interface

Revision History:

    01/13/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "tapiutil.h"
#include <gdispool.h>
#include "prtcovpg.h"
#include "jobtag.h"
#include "faxreg.h"


//
// Data structure passed in during CREATEDCPRE document event
//

typedef struct {

    LPTSTR      pDriverName;    // driver name
    LPTSTR      pPrinterName;   // printer name
    PDEVMODE    pdmInput;       // input devmode
    ULONG       fromCreateIC;   // whether called from CreateIC

} CREATEDCDATA, *PCREATEDCDATA;

//
// Data structure passed in during ESCAPE document event
//

typedef struct {

    ULONG       iEscape;        // nEscape parameter passed to ExtEscape
    ULONG       cbInput;        // cbInput parameter passed to ExtEscape
    LPCSTR      pInput;         // pszInData parameter passed to ExtEscape

} ESCAPEDATA, *PESCAPEDATA;

//
// Check if a document event requires a device context
//

#define DocEventRequiresDC(iEsc) \
        ((iEsc) >= DOCUMENTEVENT_RESETDCPRE && (iEsc) <= DOCUMENTEVENT_LAST)

//
// Present the Send Fax Wizard to the user
//

BOOL
SendFaxWizard(
    PUSERMEM    pUserMem
    );

BOOL
DoFirstTimeInitStuff(
    HWND hwnd,
    BOOL WarnOnPrint
    );


PUSERMEM
GetPDEVUserMem(
    HDC     hdc
    )

/*++

Routine Description:

    Retrieve a pointer to the user mode memory structure associated with a PDEV

Arguments:

    hdc - Specifies the printer device context

Return Value:

    Pointer to user mode memory structure, NULL if there is an error

--*/

{
    PUSERMEM pUserMem;

    //
    // Get a pointer to the user mode memory structure associated
    // with the specified device context
    //

    EnterDrvSem();

    pUserMem = gUserMemList;

    while (pUserMem && hdc != pUserMem->hdc)
        pUserMem = pUserMem->pNext;

    LeaveDrvSem();

    //
    // Make sure the user memory structure is valid
    //

    if (pUserMem) {

        if (! ValidPDEVUserMem(pUserMem)) {

            Error(("Corrupted user mode memory structure\n"));
            pUserMem = NULL;
        }

    } else
        Error(("DC has no associated user mode memory structure\n"));

    return pUserMem;
}



VOID
FreeRecipientList(
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Free up the list of recipients associated with each fax job

Arguments:

    pUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    PRECIPIENT  pNextRecipient, pFreeRecipient;

    //
    // Free the list of recipients
    //

    pNextRecipient = pUserMem->pRecipients;

    while (pNextRecipient) {

        pFreeRecipient = pNextRecipient;
        pNextRecipient = pNextRecipient->pNext;
        FreeRecipient(pFreeRecipient);
    }

    pUserMem->pRecipients = NULL;
}



VOID
FreePDEVUserMem(
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Free up the user mode memory associated with each PDEV

Arguments:

    pUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    if (pUserMem) {

        FreeRecipientList(pUserMem);

        MemFree(pUserMem->pPrinterName);
        MemFree(pUserMem->pSubject);
        MemFree(pUserMem->pNoteMessage);
        MemFree(pUserMem->pEnvVar);
        MemFree(pUserMem->pPrintFile);
        MemFree(pUserMem);
    }
}



INT
DocEventCreateDCPre(
    HANDLE        hPrinter,
    HDC           hdc,
    PCREATEDCDATA pCreateDCData,
    PDEVMODE     *ppdmOutput
    )

/*++

Routine Description:

    Handle CREATEDCPRE document event

Arguments:

    hPrinter - Handle to the printer object
    hdc - Specifies the printer device context
    pCreateDCData - Pointer to CREATEDCDATA structure passed in from GDI
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    PUSERMEM        pUserMem;   
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    
    Verbose(("Document event: CREATEDCPRE%s\n", pCreateDCData->fromCreateIC ? "*" : ""));
    *ppdmOutput = NULL;

    //
    // Allocate space for user mode memory data structure
    //

    if ((pUserMem = MemAllocZ(sizeof(USERMEM))) == NULL ||
        (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) == NULL ||
        (pUserMem->pPrinterName = DuplicateString(pPrinterInfo2->pPrinterName)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        MemFree(pUserMem);
        MemFree(pPrinterInfo2);
        return DOCUMENTEVENT_FAILURE;
    }

    //
    // Merge the input devmode with the driver and system defaults
    //

    pUserMem->hPrinter = hPrinter;
    pUserMem->isLocalPrinter = (pPrinterInfo2->pServerName == NULL);
    GetCombinedDevmode(&pUserMem->devmode, pCreateDCData->pdmInput, hPrinter, pPrinterInfo2, FALSE);
    MemFree(pPrinterInfo2);

    //
    // Special code path for EFC server printing - if FAXDM_EFC_SERVER bit is
    // set in DMPRIVATE.flags, then we'll bypass the fax wizard and let the
    // job through without any intervention.
    //

    if (pUserMem->devmode.dmPrivate.flags & FAXDM_NO_WIZARD) {
        pUserMem->directPrinting = TRUE;
    }

    //
    // Mark the private fields of our devmode
    //

    MarkPDEVUserMem(pUserMem);

    *ppdmOutput = (PDEVMODE) &pUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;
}



INT
DocEventResetDCPre(
    HDC         hdc,
    PUSERMEM    pUserMem,
    PDEVMODE    pdmInput,
    PDEVMODE   *ppdmOutput
    )

/*++

Routine Description:

    Handle RESETDCPRE document event

Arguments:

    hdc - Specifies the printer device context
    pUserMem - Points to the user mode memory structure
    pdmInput - Points to the input devmode passed to ResetDC
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    if (pdmInput == (PDEVMODE) &pUserMem->devmode) {

        //
        // ResetDC was called by ourselves - assume the devmode is already valid
        //

    } else {

        //
        // Merge the input devmode with driver and system default
        //

        GetCombinedDevmode(&pUserMem->devmode, pdmInput, pUserMem->hPrinter, NULL, TRUE);

        //
        // Mark the private fields of our devmode
        //

        MarkPDEVUserMem(pUserMem);
    }

    *ppdmOutput = (PDEVMODE) &pUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;
}



BOOL
IsPrintingToFile(
    LPCTSTR     pDestStr
    )

/*++

Routine Description:

    Check if the destination of a print job is a file.

Arguments:

    pDestStr - Job destination specified in DOCINFO.lpszOutput

Return Value:

    TRUE if the destination is a disk file, FALSE otherwse

--*/

{
    DWORD   fileAttrs, fileType;
    HANDLE  hFile;

    //
    // If the destination is NULL, then we're not printing to file
    //
    // Otherwise, attempt to use the destination string as the name of a file.
    // If we failed to get file attributes or the name refers to a directory,
    // then we're not printing to file.
    //

    if (pDestStr == NULL) {
        return FALSE;
    }

    //
    //  make sure it's not a directory
    //
    fileAttrs = GetFileAttributes(pDestStr);
    if (fileAttrs != 0xffffffff) {
        if (fileAttrs & FILE_ATTRIBUTE_DIRECTORY) {
            return FALSE;
        }
    }

    //
    // check if file exists...if it doesn't try to create it.
    //
    hFile = CreateFile(pDestStr, 0, 0, NULL, OPEN_EXISTING, 0, NULL); 
    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = CreateFile(pDestStr, 0, 0, NULL, CREATE_NEW, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
    }

    //
    // verify that this file is really a disk file, not a link to LPT1 or something evil like that
    //
    fileType = GetFileType(hFile);
    CloseHandle(hFile);
    if ((fileType & FILE_TYPE_DISK)==0) {
        return FALSE;            
    }
    

    //
    // it must be a file
    //

    return TRUE;
}



INT
DocEventStartDocPre(
    HDC         hdc,
    PUSERMEM    pUserMem,
    LPDOCINFO   pDocInfo
    )

/*++

Routine Description:

    Handle STARTDOCPRE document event

Arguments:

    hdc - Specifies the printer device context
    pUserMem - Points to the user mode memory structure
    pDocInfo - Points to DOCINFO structure that was passed in from GDI

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    //
    // Initialize user mode memory structure
    //

    pUserMem->pageCount = 0;
    FreeRecipientList(pUserMem);

    //
    // Present the fax wizard here if necessary
    //

    if (pDocInfo && IsPrintingToFile(pDocInfo->lpszOutput)) {

        //
        // Printing to file case: don't get involved
        //

        Warning(("Printing direct: %ws\n", pDocInfo->lpszOutput));
        pUserMem->jobType = JOBTYPE_DIRECT;

    } else {

        //
        // check to see if we should print to file
        //

        LPTSTR pEnvVar;
        DWORD EnvSize;

        EnvSize = GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, NULL, 0 );
        if (EnvSize) {
            pEnvVar = (LPTSTR) MemAllocZ( EnvSize * sizeof(TCHAR) );
            if (pEnvVar) {
                if (GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, pEnvVar, EnvSize )) {
                    pUserMem->directPrinting = TRUE;
                    pUserMem->pPrintFile = pEnvVar;
                    pUserMem->jobType = JOBTYPE_DIRECT;
                    pDocInfo->lpszOutput = pEnvVar;
                    return DOCUMENTEVENT_SUCCESS;
                }
            }
        }

        //
        // Normal fax print job. Present the send fax wizard.
        // If the user selected cancel, then return -2 to GDI.
        //
        if (!DoFirstTimeInitStuff(NULL, TRUE) ||
            ! SendFaxWizard(pUserMem)) {

            SetLastError(ERROR_CANCELLED);
            return -2;
        }

        Assert(pUserMem->pRecipients);
        pUserMem->jobType = JOBTYPE_NORMAL;
    }

    return DOCUMENTEVENT_SUCCESS;
}



VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Free up memory used to hold the cover page information

Arguments:

    pCPFields - Points to a COVERPAGEFIELDS structure

Return Value:

    NONE

--*/

{
    if (pCPFields == NULL)
        return;

    //
    // NOTE: We don't need to free the following fields here because they're
    // allocated and freed elsewhere and we're only using a copy of the pointer:
    //  RecName
    //  RecFaxNumber
    //  Note
    //  Subject
    //

    MemFree(pCPFields->SdrName);
    MemFree(pCPFields->SdrFaxNumber);
    MemFree(pCPFields->SdrCompany);
    MemFree(pCPFields->SdrAddress);
    MemFree(pCPFields->SdrTitle);
    MemFree(pCPFields->SdrDepartment);
    MemFree(pCPFields->SdrOfficeLocation);
    MemFree(pCPFields->SdrHomePhone);
    MemFree(pCPFields->SdrOfficePhone);

    MemFree(pCPFields->NumberOfPages);
    MemFree(pCPFields->TimeSent);

    MemFree(pCPFields);
}



PCOVERPAGEFIELDS
CollectCoverPageFields(
    PUSERMEM    pUserMem,
    DWORD       pageCount
    )

/*++

Routine Description:

    Collect cover page information into a COVERPAGEFIELDS structure

Arguments:

    pUserMem - Pointer to user mode data structure
    pageCount - Total number of pages (including cover pages)

Return Value:

    Pointer to a COVERPAGEFIELDS structure, NULL if there is an error

--*/

#define FillCoverPageField(field, pValueName) { \
            buffer = GetRegistryString(hRegKey, pValueName, TEXT("")); \
            if (! IsEmptyString(buffer)) { \
                pCPFields->field = DuplicateString(buffer); \
                MemFree(buffer); \
            } \
        }

{
    PCOVERPAGEFIELDS    pCPFields;
    LPTSTR              buffer;
    HKEY                hRegKey;
    INT                 dateTimeLen;

    //
    // Allocate memory to hold the top level structure
    // and open the user info registry key for reading
    //

    if (! (pCPFields = MemAllocZ(sizeof(COVERPAGEFIELDS))) ||
        ! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
    {
        FreeCoverPageFields(pCPFields);
        return NULL;
    }

    //
    // Read sender information from the registry
    //

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    FillCoverPageField(SdrName, REGVAL_FULLNAME);
    FillCoverPageField(SdrCompany, REGVAL_COMPANY);
    FillCoverPageField(SdrAddress, REGVAL_ADDRESS);
    FillCoverPageField(SdrTitle, REGVAL_TITLE);
    FillCoverPageField(SdrDepartment, REGVAL_DEPT);
    FillCoverPageField(SdrOfficeLocation, REGVAL_OFFICE);
    FillCoverPageField(SdrHomePhone, REGVAL_HOME_PHONE);
    FillCoverPageField(SdrOfficePhone, REGVAL_OFFICE_PHONE);
    FillCoverPageField(SdrFaxNumber, REGVAL_FAX_NUMBER);

    RegCloseKey(hRegKey);

    //
    // Number of pages and current local system time
    //

    if (pCPFields->NumberOfPages = MemAllocZ(sizeof(TCHAR) * 16))
        wsprintf(pCPFields->NumberOfPages, TEXT("%d"), pageCount);

    //
    // When the fax was sent
    //

    dateTimeLen = 128;

    if (pCPFields->TimeSent = MemAllocZ(sizeof(TCHAR) * dateTimeLen)) {

        LPTSTR  p = pCPFields->TimeSent;
        INT     cch;

        GetDateFormat(LOCALE_USER_DEFAULT, 0, NULL, NULL, p, dateTimeLen);

        cch = _tcslen(p);
        p += cch;

        if (++cch < dateTimeLen) {

            *p++ = ' ';
            dateTimeLen -= cch;

            GetTimeFormat(LOCALE_USER_DEFAULT, 0, NULL, NULL, p, dateTimeLen);
        }
    }

    return pCPFields;
}



DWORD
FaxTimeToJobTime(
    DWORD   faxTime
    )

/*++

Routine Description:

    Convert fax time to spooler job time:
        Fax time is a DWORD whose low-order WORD represents hour value and
        high-order WORD represents minute value. Spooler job time is a DWORD
        value expressing minutes ellapsed since 12:00 AM GMT.

Arguments:

    faxTime - Specifies the fax time to be converted

Return Value:

    Spooler job time corresponding to the input fax time

--*/

{
    TIME_ZONE_INFORMATION   timeZoneInfo;
    LONG                    jobTime;

    //
    // Convert fax time to minutes pass midnight
    //

    jobTime = LOWORD(faxTime) * 60 + HIWORD(faxTime);

    //
    // Take time zone information in account - Add one full
    // day to take care of the case where the bias is negative.
    //

    switch (GetTimeZoneInformation(&timeZoneInfo)) {

    case TIME_ZONE_ID_DAYLIGHT:

        jobTime += timeZoneInfo.DaylightBias;

    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_UNKNOWN:

        jobTime += timeZoneInfo.Bias + MINUTES_PER_DAY;
        break;

    default:

        Error(("GetTimeZoneInformation failed: %d\n", GetLastError()));
        break;
    }

    //
    // Make sure the time value is less than one day
    //

    return jobTime % MINUTES_PER_DAY;
}



PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    Error(("GetJob failed: %d\n", GetLastError()));
    MemFree(pJobInfo);
    return NULL;
}



BOOL
SetJobInfoAndTime(
    HANDLE      hPrinter,
    DWORD       jobId,
    LPTSTR      pJobParam,
    PDMPRIVATE  pdmPrivate
    )

/*++

Routine Description:

    Change the devmode and start/stop times associated with a cover page job

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the job ID
    pJobParam - Specifies the fax job parameters
    pdmPrivate - Specifies private devmode information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_2 *pJobInfo2;
    BOOL        result = FALSE;

    //
    // Get the current job information
    //

    if (pJobInfo2 = MyGetJob(hPrinter, 2, jobId)) {

        //
        // set the time to send to be now, always
        //

        Warning(("Fax job parameters: %ws\n", pJobParam));
        pJobInfo2->pParameters = pJobParam;
        pJobInfo2->Position = JOB_POSITION_UNSPECIFIED;
        pJobInfo2->pDevMode = NULL;
        pJobInfo2->UntilTime = pJobInfo2->StartTime;

        if (! (result = SetJob(hPrinter, jobId, 2, (PBYTE) pJobInfo2, 0))) {
            Error(("SetJob failed: %d\n", GetLastError()));
        }

        MemFree(pJobInfo2);
    }

    return result;
}



BOOL
ChainFaxJobs(
    HANDLE  hPrinter,
    DWORD   parentJobId,
    DWORD   childJobId
    )

/*++

Routine Description:

    Tell the spooler to chain up two print jobs

Arguments:

    hPrinter - Specifies the printer object
    parentJobId - Specifies the job to chain from
    childJobId - Specifies the job to chain to

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_3 jobInfo3 = { parentJobId, childJobId };

    Warning(("Chaining cover page job to body job: %d => %d\n", parentJobId, childJobId));

    return SetJob(hPrinter, parentJobId, 3, (PBYTE) &jobInfo3, 0);
}



LPTSTR
GetJobName(
    HANDLE  hPrinter,
    DWORD   jobId
    )

/*++

Routine Description:

    Return the name of the specified print job

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the fax body job

Return Value:

    Pointer to the job name string, NULL if there is an error

--*/

{
    JOB_INFO_1 *pJobInfo1;
    LPTSTR      pJobName;

    //
    // Get the information about the specified job and
    // return a copy of the job name string
    //

    if (pJobInfo1 = MyGetJob(hPrinter, 1, jobId)) {

        pJobName = DuplicateString(pJobInfo1->pDocument);
        MemFree(pJobInfo1);

    } else
        pJobName = NULL;

    return pJobName;
}



LPTSTR
ComposeFaxJobName(
    LPTSTR  pBodyDocName,
    LPTSTR  pRecipientName
    )

/*++

Routine Description:

    Compose the document name string for a cover page job

Arguments:

    pBodyDocName - Specifies the name of the body job
    pRecipient - Specifies the recipient's name

Return Value:

    Pointer to cover page job name string, NULL if there is an error

--*/

#define DOCNAME_FORMAT_STRING   TEXT("%s - %s")

{
    LPTSTR  pCoverJobName;

    if (pBodyDocName == NULL) {

        //
        // If the body job name is NULL somehow, then simply
        // use the recipient's name as the cover page job name.
        //

        pCoverJobName = DuplicateString(pRecipientName);

    } else if (pCoverJobName = MemAlloc(SizeOfString(DOCNAME_FORMAT_STRING) +
                                        SizeOfString(pBodyDocName) +
                                        SizeOfString(pRecipientName)))
    {
        //
        // Otherwise, the cover page job name is generated by
        // concatenating the recipient's name with the body job name.
        //

        wsprintf(pCoverJobName, DOCNAME_FORMAT_STRING, pRecipientName, pBodyDocName);
    }

    return pCoverJobName;
}



LPTSTR
GetBaseNoteFilename(
    VOID
    )

/*++

Routine Description:

    Get the name of base cover page file in system32 directory

Arguments:

    argument-name - description of argument

Return Value:

    Pointer to name of base cover page file
    NULL if there is an error

--*/

#define BASENOTE_FILENAME   TEXT("\\basenote.cov")

{
    TCHAR       systemDir[MAX_PATH];
    LPTSTR      pBaseNoteName = NULL;
    COVDOCINFO  covDocInfo;

    if (GetSystemDirectory(systemDir, MAX_PATH) &&
        (pBaseNoteName = MemAlloc(SizeOfString(systemDir) + SizeOfString(BASENOTE_FILENAME))))
    {
        _tcscpy(pBaseNoteName, systemDir);
        _tcscat(pBaseNoteName, BASENOTE_FILENAME);
        Verbose(("Base cover page filename: %ws\n", pBaseNoteName));

        if (PrintCoverPage(NULL, NULL, pBaseNoteName, &covDocInfo) ||
            ! (covDocInfo.Flags & COVFP_NOTE) ||
            ! (covDocInfo.Flags & COVFP_SUBJECT))
        {
            Error(("Invalid base cover page file: %ws\n", pBaseNoteName));
            MemFree(pBaseNoteName);
            pBaseNoteName = NULL;
        }
    }

    return pBaseNoteName;
}



LPTSTR
ComposeFaxJobParameter(
    PUSERMEM            pUserMem,
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Assemble fax job parameters into a single tagged string

Arguments:

    pUserMem - Points to user mode memory structure
    pCPFields - Points to cover page field information

Return Value:

    Pointer to fax job parameter string, NULL if there is an error

--*/

#define NUM_JOBPARAM_TAGS 10

{
    //
    // Tags used to pass information about fax jobs
    //

    static LPTSTR faxtagNames[NUM_JOBPARAM_TAGS] = {

        FAXTAG_RECIPIENT_NUMBER,
        FAXTAG_RECIPIENT_NAME,
        FAXTAG_TSID,
        FAXTAG_SENDER_NAME,
        FAXTAG_SENDER_COMPANY,
        FAXTAG_SENDER_DEPT,
        FAXTAG_BILLING_CODE,
        FAXTAG_EMAIL_NAME,
        FAXTAG_WHEN_TO_SEND,
        FAXTAG_SEND_AT_TIME
    };

    LPTSTR faxtagValues[NUM_JOBPARAM_TAGS] = {

        pCPFields->RecFaxNumber,
        pCPFields->RecName,
        pCPFields->SdrFaxNumber,
        pCPFields->SdrName,
        pCPFields->SdrCompany,
        pCPFields->SdrDepartment,
        pUserMem->devmode.dmPrivate.billingCode,
        pUserMem->devmode.dmPrivate.emailAddress,
        NULL,
        NULL
    };

    LPTSTR  pJobParam, p;
    INT     index, size;
    TCHAR   SendAtTime[16];


    //
    // create the sendattime string
    //

    if (pUserMem->devmode.dmPrivate.whenToSend == SENDFAX_AT_CHEAP) {
        faxtagValues[8] = TEXT("cheap");
    }

    if (pUserMem->devmode.dmPrivate.whenToSend == SENDFAX_AT_TIME) {

        wsprintf( SendAtTime, TEXT("%02d:%02d"),
            pUserMem->devmode.dmPrivate.sendAtTime.Hour,
            pUserMem->devmode.dmPrivate.sendAtTime.Minute
            );

        faxtagValues[8] = TEXT("at");
        faxtagValues[9] = SendAtTime;
    }

    //
    // Figure out the total length of the tagged string
    //

    for (index=size=0; index < NUM_JOBPARAM_TAGS; index++) {

        if (faxtagValues[index] && !IsEmptyString(faxtagValues[index]))
            size += SizeOfString(faxtagNames[index]) + SizeOfString(faxtagValues[index]);
    }

    if (size == 0 || (pJobParam = p = MemAlloc(size)) == NULL)
        return NULL;

    //
    // Assemble fax job parameters into a single tagged string
    //

    for (index=0; index < NUM_JOBPARAM_TAGS; index++) {

        if (faxtagValues[index] && !IsEmptyString(faxtagValues[index])) {

            _tcscpy(p, faxtagNames[index]);
            p += _tcslen(p);

            _tcscpy(p, faxtagValues[index]);
            p += _tcslen(p);
        }
    }

    return pJobParam;
}



BOOL
DoCoverPageRendering(
    HDC         hdc,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Render a cover page for each recipient

Arguments:

    hdc - Handle to the current printer device context
    pUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PCOVERPAGEFIELDS    pCPFields;
    PRECIPIENT          pRecipient;
    DOCINFO             docinfo;
    INT                 newJobId, lastJobId, cCoverPagesSent;
    LPTSTR              pBaseNoteName = NULL;
    PDMPRIVATE          pdmPrivate = &pUserMem->devmode.dmPrivate;
    HANDLE              hPrinter = pUserMem->hPrinter;
    DWORD               bodyJobId = pUserMem->jobId;
    LPTSTR              pBodyDocName, pJobParam;
    BOOL                sendCoverPage;
    DWORD               pageCount;

    //
    // Determine if we need a cover page or not
    //

    if ((sendCoverPage = pdmPrivate->sendCoverPage) && IsEmptyString(pUserMem->coverPage)) {

        Warning(("Missing cover page file\n"));
        sendCoverPage = FALSE;
    }

    //
    // Check if we need an extra cover page for rendering note/subject fields
    //

    pageCount = pUserMem->pageCount;

    if (sendCoverPage)
        pageCount++;

    if (((pUserMem->pSubject && !(pUserMem->noteSubjectFlag & COVFP_SUBJECT)) ||
         (pUserMem->pNoteMessage && !(pUserMem->noteSubjectFlag & COVFP_NOTE))) &&
        (pBaseNoteName = GetBaseNoteFilename()))
    {
        pageCount++;
    }

    //
    // Collect cover page information
    //

    if ((pCPFields = CollectCoverPageFields(pUserMem, pageCount)) == NULL) {

        Error(("Couldn't collect cover page information\n"));
        return FALSE;
    }

    //
    // Fill out a DOCINFO structure which is passed to StartDoc
    //

    memset(&docinfo, 0, sizeof(docinfo));
    docinfo.cbSize = sizeof(docinfo);

    pBodyDocName = GetJobName(hPrinter, bodyJobId);

    //
    // We assume the fax body job has already been paused
    // Use a separate cover page for each recipient
    //

    lastJobId = cCoverPagesSent = 0;

    for (pRecipient=pUserMem->pRecipients; pRecipient; pRecipient=pRecipient->pNext) {

        //
        // Fill out other fields of cover page information
        //

        pCPFields->Subject = pUserMem->pSubject;
        pCPFields->Note = pUserMem->pNoteMessage;

        //
        // Get recipient's name and fax number
        //

        pCPFields->RecName = pRecipient->pName;
        pCPFields->RecFaxNumber = pRecipient->pAddress;

        //
        // Start a cover page job
        //

        docinfo.lpszDocName = ComposeFaxJobName(pBodyDocName, pRecipient->pName);
        pJobParam = ComposeFaxJobParameter(pUserMem, pCPFields);

        if ((newJobId = StartDoc(hdc, &docinfo)) > 0) {

            BOOL        rendered = FALSE;
            COVDOCINFO  covDocInfo;

            //
            // Pass fax job parameters using JOB_INFO_2.pParameters field.
            //

            if (! SetJob(hPrinter, newJobId, 0, NULL, JOB_CONTROL_PAUSE) ||
                ! SetJobInfoAndTime(hPrinter,
                                    newJobId,
                                    pJobParam ? pJobParam : pCPFields->RecFaxNumber,
                                    pdmPrivate))
            {
                Error(("Couldn't modify the fax job\n"));

            } else if (! sendCoverPage) {

                //
                // If the user chose not to include cover page,
                // the cover page job will be empty
                //

                rendered = TRUE;

            } else if (StartPage(hdc) > 0) {

                //
                // Call the library function to render the cover page.
                //

                rendered = PrintCoverPage( hdc, pCPFields, pUserMem->coverPage, &covDocInfo );
                if (rendered) {
                    Error(("PrintCoverPage failed: %d\n", rendered ));
                    rendered = FALSE;
                } else {
                    rendered = TRUE;
                }

                EndPage(hdc);
            }

            //
            // Chain the cover page job to the fax body job if no error occured
            //

            if (rendered && ChainFaxJobs(hPrinter, newJobId, bodyJobId)) {

                //
                // Check if we need an extra page for note/subject fields
                //

                if (pBaseNoteName) {

                    if (StartPage(hdc) > 0) {

                        DWORD ec;

                        if (pUserMem->noteSubjectFlag & COVFP_SUBJECT)
                            pCPFields->Subject = NULL;

                        if (pUserMem->noteSubjectFlag & COVFP_NOTE)
                            pCPFields->Note = NULL;

                        ec = PrintCoverPage(hdc, pCPFields, pBaseNoteName, &covDocInfo);
                        if (ec) {
                            Error(("PrintCoverPage failed: %d\n", ec));
                        }

                        EndPage(hdc);

                    } else
                        Error(("StartPage failed: %d\n", GetLastError()));
                }

                if (lastJobId != 0)
                    SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME);

                lastJobId = newJobId;
                EndDoc(hdc);
                cCoverPagesSent++;

            } else {

                AbortDoc(hdc);
                newJobId = 0;
            }
        }

        MemFree((PVOID)docinfo.lpszDocName);
        MemFree((PVOID)pJobParam);

        //
        // Indicate to the user about the fact that we failed to render the
        // for the current recipient
        //

        if (newJobId <= 0)
            DisplayMessageDialog(NULL, 0, 0, IDS_CPRENDER_FAILED, pRecipient->pName);
    }

    MemFree(pBaseNoteName);
    MemFree(pBodyDocName);
    FreeCoverPageFields(pCPFields);

    //
    // Resume the last cover page job if it's paused and
    // delete the fax body job if no cover page jobs were sent
    //

    if (lastJobId != 0)
        SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME);

    if (cCoverPagesSent > 0)
        SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_RESUME);
    else {

        Error(("Fax job deleted due to an error\n"));
        SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_DELETE);
    }

    return cCoverPagesSent > 0;
}



INT
DocEventEndDocPost(
    HDC         hdc,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Handle ENDDOCPOST document event

Arguments:

    hdc - Specifies the printer device context
    pUserMem - Points to the user mode memory structure

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    INT result = DOCUMENTEVENT_SUCCESS;

    switch (pUserMem->jobType) {

    case JOBTYPE_NORMAL:

        Warning(("Number of pages printed: %d\n", pUserMem->pageCount));

        if (! pUserMem->directPrinting) {

            HDC             hdcCP = NULL;
            DWORD           dmFlags, dmFields;
            SHORT           dmPaperSize, dmOrientation;
            PDEVMODE        pdmPublic;
            PDMPRIVATE      pdmPrivate;

            //
            // Generate a cover page for each recipient and associate
            // the cover page job with the main body. Create a new DC
            // to rendering the cover page instead of using the existing DC.
            //

            pdmPublic = &pUserMem->devmode.dmPublic;
            pdmPrivate = &pUserMem->devmode.dmPrivate;

            dmFlags = pdmPrivate->flags;
            pdmPrivate->flags |= FAXDM_NO_WIZARD;

            if (pUserMem->cpPaperSize) {

                dmFields = pdmPublic->dmFields;
                pdmPublic->dmFields &= ~(DM_PAPERWIDTH|DM_PAPERLENGTH|DM_FORMNAME);
                pdmPublic->dmFields |= DM_PAPERSIZE;

                dmPaperSize = pdmPublic->dmPaperSize;
                pdmPublic->dmPaperSize = pUserMem->cpPaperSize;

                dmOrientation = pdmPublic->dmOrientation;
                pdmPublic->dmOrientation = pUserMem->cpOrientation;
            }

            if (! (hdcCP = CreateDC(NULL,
                                    pUserMem->pPrinterName,
                                    NULL,
                                    (PDEVMODE) &pUserMem->devmode)) ||
                ! DoCoverPageRendering(hdcCP, pUserMem))
            {
                result = DOCUMENTEVENT_FAILURE;
            }

            if (hdcCP != NULL)
                DeleteDC(hdcCP);

            if (pUserMem->cpPaperSize) {

                pdmPublic->dmFields = dmFields;
                pdmPublic->dmPaperSize = dmPaperSize;
                pdmPublic->dmOrientation = dmOrientation;
            }

            pdmPrivate->flags = dmFlags;

            //
            // Free up the list of recipients
            //

            FreeRecipientList(pUserMem);
        }
        break;

    }

    return result;
}



INT
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    INT     iEsc,
    ULONG   cbIn,
    PULONG  pjIn,
    ULONG   cbOut,
    PULONG  pjOut
    )

/*++

Routine Description:

    Hook into GDI at various points during the output process

Arguments:

    hPrinter - Specifies the printer object
    hdc - Handle to the printer DC
    iEsc - Why this function is called (see notes below)
    cbIn - Size of the input buffer
    pjIn - Pointer to the input buffer
    cbOut - Size of the output buffer
    pjOut - Pointer to the output buffer

Return Value:

    DOCUMENTEVENT_SUCCESS - success
    DOCUMENTEVENT_UNSUPPORTED - iEsc is not supported
    DOCUMENTEVENT_FAILURE - an error occured

NOTE:

    DOCUMENTEVENT_CREATEDCPRE
        input - pointer to a CREATEDCDATA structure
        output - pointer to a devmode that's passed to DrvEnablePDEV
        return value -
            DOCUMENTEVENT_FAILURE causes CreateDC to fail and nothing else is called

    DOCUMENTEVENT_CREATEDCPOST
        hdc - NULL if if something failed since CREATEDCPRE
        input - pointer to the devmode pointer returned by CREATEDCPRE
        return value - ignored

    DOCUMENTEVENT_RESETDCPRE
        input - pointer to the input devmode passed to ResetDC
        output - pointer to a devmode that's passed to the kernel driver
        return value -
            DOCUMENTEVENT_FAILURE causes ResetDC to fail
            and CREATEDCPOST will not be called in that case

    DOCUMENTEVENT_RESETDCPOST
        return value - ignored

    DOCUMENTEVENT_STARTDOCPRE
        input - pointer to a DOCINFOW structure
        return value -
            DOCUMENTEVENT_FAILURE causes StartDoc to fail
            and DrvStartDoc will not be called in this case

    DOCUMENTEVENT_STARTDOCPOST
        return value - ignored

    DOCUMENTEVENT_STARTPAGE
        return value -
            DOCUMENTEVENT_FAILURE causes StartPage to fail
            and DrvStartPage will not be called in this case

    DOCUMENTEVENT_ENDPAGE
        return value - ignored and DrvEndPage always called

    DOCUMENTEVENT_ENDDOCPRE
        return value - ignored and DrvEndDoc always called

    DOCUMENTEVENT_ENDDOCPOST
        return value - ignored

    DOCUMENTEVENT_ABORTDOC
        return value - ignored

    DOCUMENTEVENT_DELETEDC
        return value - ignored

    DOCUMENTEVENT_ESCAPE
        input - pointer to a ESCAPEDATA structure
        cbOut, pjOut - cbOutput and lpszOutData parameters passed to ExtEscape
        return value - ignored

    DOCUMENTEVENT_SPOOLED
        This flag bit is ORed with other iEsc values if the document is
        spooled as metafile rather than printed directly to port.

--*/

{
    PUSERMEM    pUserMem = NULL;
    PDEVMODE    pDevmode;
    INT         result = DOCUMENTEVENT_SUCCESS;

    Verbose(("Entering DrvDocumentEvent: %d...\n", iEsc));

    //
    // Metafile spooling on fax jobs is not currently supported
    //

    Assert((iEsc & DOCUMENTEVENT_SPOOLED) == 0);

    //
    // Check if the document event requires a device context
    //

    if (DocEventRequiresDC(iEsc)) {

        if (!hdc || !(pUserMem = GetPDEVUserMem(hdc))) {

            Error(("Invalid device context: hdc = %x, iEsc = %d\n", hdc, iEsc));
            return DOCUMENTEVENT_FAILURE;
        }
    }

    switch (iEsc) {

    case DOCUMENTEVENT_CREATEDCPRE:

        Assert(cbIn >= sizeof(CREATEDCDATA) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
        result = DocEventCreateDCPre(hPrinter, hdc, (PCREATEDCDATA) pjIn, (PDEVMODE *) pjOut);
        break;

    case DOCUMENTEVENT_CREATEDCPOST:

        //
        // Handle CREATEDCPOST document event:
        //  If CreateDC succeeded, then associate the user mode memory structure
        //  with the device context. Otherwise, free the user mode memory structure.
        //

        Assert(cbIn >= sizeof(PVOID) && pjIn);
        pDevmode = *((PDEVMODE *) pjIn);
        Assert(CurrentVersionDevmode(pDevmode));

        pUserMem = ((PDRVDEVMODE) pDevmode)->dmPrivate.pUserMem;
        Assert(ValidPDEVUserMem(pUserMem));

        if (hdc) {

            pUserMem->hdc = hdc;

            EnterDrvSem();
            pUserMem->pNext = gUserMemList;
            gUserMemList = pUserMem;
            LeaveDrvSem();

        } else
            FreePDEVUserMem(pUserMem);

        break;

    case DOCUMENTEVENT_RESETDCPRE:

        Verbose(("Document event: RESETDCPRE\n"));
        Assert(cbIn >= sizeof(PVOID) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
        result = DocEventResetDCPre(hdc, pUserMem, *((PDEVMODE *) pjIn), (PDEVMODE *) pjOut);
        break;

    case DOCUMENTEVENT_STARTDOCPRE:
        //
        // if printing a fax attachment then enable direct printing
        //

        if (pUserMem->hMutex == NULL) {
            pUserMem->hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE,FAXXP_MUTEX_NAME);
            if (pUserMem->hMutex) {
                if (WaitForSingleObject( pUserMem->hMutex, 0) == WAIT_OBJECT_0) {
                    pUserMem->directPrinting = TRUE;
                }
                else {
                    CloseHandle( pUserMem->hMutex ) ;
                    pUserMem->hMutex = NULL;
                }
            }
        }

        //
        // normal case if we're bringing up the send wizard
        //

        if (! pUserMem->directPrinting) {

            Assert(cbIn >= sizeof(PVOID) && pjIn);
            result = DocEventStartDocPre(hdc, pUserMem, *((LPDOCINFO *) pjIn));
        } 
        
        //
        // we're doing direct printing -- check if this is invoked via mapi-spooler
        //
        else if (pUserMem->hMutex) {
            //
            // we own the mutex...make sure we can open the shared memory region.
            //
            pUserMem->pEnvVar = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,FAXXP_MEM_NAME);
            if (!pUserMem->pEnvVar) {
                ReleaseMutex( pUserMem->hMutex );
                CloseHandle( pUserMem->hMutex );
                pUserMem->hMutex = NULL;
            } else {
                //
                // we own the mutex and we have the shared memory region open.
                //

                // check if we are printing to a file or are doing direct printing for
                // the mapi spooler.
                //
                LPTSTR filename;

                filename = (LPTSTR)MapViewOfFile(
                                         pUserMem->pEnvVar,
                                         FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0
                                         );

                if (!filename) {
                    Error(("Failed to map a view of the file: %d\n", pUserMem->pEnvVar));
                    return DOCUMENTEVENT_FAILURE;
                }

                if (filename && *filename) {
                    //
                    // this is really the filename we want to print to.
                    //
                    pUserMem->directPrinting = TRUE;
                    pUserMem->pPrintFile = DuplicateString(filename);
                    pUserMem->jobType = JOBTYPE_DIRECT;
                    (*((LPDOCINFO *) pjIn))->lpszOutput = pUserMem->pPrintFile;
                }
                    
                UnmapViewOfFile( filename );

            }
    
        }
        break;

    case DOCUMENTEVENT_STARTDOCPOST:

        if (!pUserMem->directPrinting && pUserMem->jobType == JOBTYPE_NORMAL) {

            //
            // Job ID is passed in from GDI
            //

            Assert(cbIn >= sizeof(DWORD) && pjIn);
            pUserMem->jobId = *((LPDWORD) pjIn);

            //
            // Tell spooler to pause the fax body job so that
            // we can associate cover pages with it later
            //

            if (! SetJob(pUserMem->hPrinter, pUserMem->jobId, 0, NULL, JOB_CONTROL_PAUSE)) {

                Error(("Couldn't pause fax body job: %d\n", pUserMem->jobId));
                return DOCUMENTEVENT_FAILURE;
            }

        } else if (pUserMem->pEnvVar) {

            LPDWORD pJobId;
            
            //
            // Job ID is passed in from GDI
            //

            Assert(cbIn >= sizeof(DWORD) && pjIn);
            pUserMem->jobId = *((LPDWORD) pjIn);

            if (!pUserMem->pPrintFile) {
            
                
    
                //
                // Tell spooler to pause the fax job
                // so that the mapi fax transport provider
                // can chain this job
                //
    
                if (! SetJob(pUserMem->hPrinter, pUserMem->jobId, 0, NULL, JOB_CONTROL_PAUSE)) {
    
                    Error(("Couldn't pause fax body job: %d\n", pUserMem->jobId));
                    return DOCUMENTEVENT_FAILURE;
                }

            }

            pJobId = (LPDWORD)MapViewOfFile(
                pUserMem->pEnvVar,
                FILE_MAP_WRITE,
                0,
                0,
                0
                );
            if (!pJobId) {
                Error(("Failed to map a view of the file: %d\n", pUserMem->jobId));
                return DOCUMENTEVENT_FAILURE;
            }

            *pJobId = (DWORD) pUserMem->jobId;

            UnmapViewOfFile( pJobId );
            CloseHandle( pUserMem->pEnvVar );
            pUserMem->pEnvVar = NULL;            
        }
        break;

    case DOCUMENTEVENT_ENDPAGE:

        if (! pUserMem->directPrinting)
            pUserMem->pageCount++;
        break;

    case DOCUMENTEVENT_ENDDOCPOST:

        if (! pUserMem->directPrinting)
            result = DocEventEndDocPost(hdc, pUserMem);
        else if (pUserMem->hMutex) {
            HANDLE  hEvent = NULL;

            hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, FAXXP_EVENT_NAME);
            if (hEvent) {
                SetEvent(hEvent);
                CloseHandle(hEvent) ;
            }

            ReleaseMutex(pUserMem->hMutex);
            CloseHandle(pUserMem->hMutex);
            pUserMem->hMutex = NULL;
        }

        break;

    case DOCUMENTEVENT_DELETEDC:

        EnterDrvSem();

        if (pUserMem == gUserMemList)
            gUserMemList = gUserMemList->pNext;
        else {

            PUSERMEM p;

            if (p = gUserMemList) {

                while (p->pNext && p->pNext != pUserMem)
                    p = p->pNext;

                if (p->pNext != NULL)
                    p->pNext = pUserMem->pNext;
                else
                    Error(("Orphaned user mode memory structure!!!\n"));

            } else
                Error(("gUserMemList shouldn't be NULL!!!\n"));
        }

        LeaveDrvSem();
        FreePDEVUserMem(pUserMem);
        break;

    case DOCUMENTEVENT_ABORTDOC:
    case DOCUMENTEVENT_RESETDCPOST:
    case DOCUMENTEVENT_STARTPAGE:
    case DOCUMENTEVENT_ENDDOCPRE:

        break;

    case DOCUMENTEVENT_ESCAPE:
    default:

        Verbose(("Unsupported DrvDocumentEvent escape: %d\n", iEsc));
        result = DOCUMENTEVENT_UNSUPPORTED;
        break;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\docprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docprop.c

Abstract:

    Implemetation of DDI entry points:
        DrvDocumentPropertySheets
        DrvDocumentProperties
        DrvAdvancedDocumentProperties
        DrvConvertDevMode

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include "libproto.h"
#include "faxhelp.h"


INT_PTR FaxOptionsProc(HWND, UINT, WPARAM, LPARAM);
LONG SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER);
BOOL GenerateFormsList(PUIDATA);
BOOL AddDocPropPages(PUIDATA, LPTSTR);
LPTSTR GetHelpFilename(PUIDATA);



LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Document Properties" property sheets

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PUIDATA                 pUiData;

    //
    // Validate input parameters
    // pPSUIInfo = NULL is a special case: don't need to display the dialog
    //

    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ? pPSUIInfo->lParamInit : lParam))) {

        Assert(FALSE);
        return -1;
    }

    if (pPSUIInfo == NULL)
        return SimpleDocumentProperties(pDPHdr);

    Verbose(("DrvDocumentPropertySheets: %d\n", pPSUIInfo->Reason));

    //
    // Create a UIDATA structure if necessary
    //

    pUiData = (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) ?
                    FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn) :
                    (PUIDATA) pPSUIInfo->UserData;

    if (! ValidUiData(pUiData))
        return -1;

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:

        pUiData->hasPermission = ((pDPHdr->fMode & DM_NOPERMISSION) == 0);
        pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
        pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

        if (pDPHdr->fMode & DM_USER_DEFAULT)
            pUiData->configDefault = TRUE;

        //
        // Find online help filename
        //

        GetHelpFilename(pUiData);

        //
        // Add our pages to the property sheet
        //

        if (GenerateFormsList(pUiData) && AddDocPropPages(pUiData, pDPHdr->pszPrinterName)) {

            pPSUIInfo->UserData = (DWORD_PTR) pUiData;
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }

        //
        // Clean up properly in case of an error
        //

        HeapDestroy(pUiData->hheap);
        break;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInstance;
            pPSUIHdr->IconID = IDI_CPSUI_PRINTER2;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:

        //
        // Copy the new devmode back into the output buffer provided by the caller
        // Always return the smaller of current and input devmode
        //

        {   PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;

            Verbose(("Set result: %d\n", pSRInfo->Result));

            if (pSRInfo->Result == CPSUI_OK && (pDPHdr->fMode & (DM_COPY|DM_UPDATE))) {

                ConvertDevmodeOut((PDEVMODE) &pUiData->devmode,
                                  pDPHdr->pdmIn,
                                  pDPHdr->pdmOut);
            }

            pPSUIInfo->Result = pSRInfo->Result;
        }
        return 1;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Cleanup properly before exiting
        //

        HeapDestroy(pUiData->hheap);
        return 1;
    }

    return -1;
}



LONG
DoDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Arguments:

    hwnd - Handle to the parent window of the document properties dialog box.

    hPrinter - Handle to a printer object.

    pPrinterName - Points to a null-terminated string that specifies
        the name of the device for which the document properties dialog
        box should be displayed.

    pdmOutput - Points to a DEVMODE structure that receives the document
        properties data specified by the user.

    pdmInput - Points to a DEVMODE structure that initializes the dialog
        box controls. This parameter can be NULL.

    fmode - Specifies a mask of flags that determine which operations
        the function performs.

Return Value:

    > 0 if successful
    = 0 if canceled
    < 0 if error

--*/

{
    DOCUMENTPROPERTYHEADER  docPropHdr;
    DWORD                   result;

    //
    // Initialize a DOCUMENTPROPERTYHEADER structure
    //

    memset(&docPropHdr, 0, sizeof(docPropHdr));
    docPropHdr.cbSize = sizeof(docPropHdr);
    docPropHdr.hPrinter = hPrinter;
    docPropHdr.pszPrinterName = pPrinterName;
    docPropHdr.pdmIn = pdmInput;
    docPropHdr.pdmOut = pdmOutput;
    docPropHdr.fMode = fMode;

    //
    // Don't need to get compstui involved when the dialog is not displayed
    //

    if ((fMode & DM_PROMPT) == 0)
        return SimpleDocumentProperties(&docPropHdr);

    CallCompstui(hwnd, DrvDocumentPropertySheets, (LPARAM) &docPropHdr, &result);
    return result;
}



LONG
DrvDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Routine Description:

    Set the public members of a DEVMODE structure for a print document

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    LONG result;

    Verbose(("Entering DrvDocumentProperties: fMode = %x...\n", fMode));

    //
    // Check if caller is asking querying for size
    //

    if (fMode == 0 || pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Call the common routine shared with DrvAdvancedDocumentProperties
    //

    result = DoDocumentProperties(hwnd, hPrinter, pPrinterName, pdmOutput, pdmInput, fMode);

    return (result > 0) ? IDOK : (result == 0) ? IDCANCEL : result;
}



LONG
DrvAdvancedDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Set the private members of a DEVMODE structure.
    In this release, this function is almost identical to
    DrvDocumentProperties above with a few minor exceptions

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    Verbose(("Entering DrvAdvancedDocumentProperties...\n"));

    //
    // Return the number of bytes required if pdmOutput is NULL
    //

    if (pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Otherwise, call the common routine shared with DrvDocumentProperties
    //

    return DoDocumentProperties(hwnd,
                                hPrinter,
                                pPrinterName,
                                pdmOutput,
                                pdmInput,
                                DM_COPY|DM_PROMPT|DM_ADVANCED) > 0;
}



BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pdmIn,
    PDEVMODE    pdmOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    Use by SetPrinter and GetPrinter to convert devmodes

Arguments:

    pPrinterName - Points to printer name string
    pdmIn - Points to the input devmode
    pdmOut - Points to the output devmode buffer
    pcbNeeded - Specifies the size of output buffer on input
        On output, this is the size of output devmode
    fMode - Specifies what function to perform

Return Value:

    TRUE if successful
    FALSE otherwise and an error code is logged

--*/

{
    static DRIVER_VERSION_INFO versionInfo = {

        // Current driver version number and private devmode size

        DRIVER_VERSION, sizeof(DMPRIVATE),

        // 3.51 driver version number and private devmode size
        // NOTE: We don't have a 3.51 driver - use current version number and devmode size.

        DRIVER_VERSION, sizeof(DMPRIVATE)
    };

    INT     result;
    HANDLE  hPrinter;

    Verbose(("Entering DrvConvertDevMode: %x...\n", fMode));

    //
    // Call a library routine to handle the common cases
    //

    result = CommonDrvConvertDevmode(pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode, &versionInfo);

    //
    // If not handled by the library routine, we only need to worry
    // about the case when fMode is CDM_DRIVER_DEFAULT
    //

    if (result == CDM_RESULT_NOT_HANDLED && fMode == CDM_DRIVER_DEFAULT) {

        //
        // Return driver default devmode
        //

        if (OpenPrinter(pPrinterName, &hPrinter, NULL)) {

            PDRVDEVMODE pdmDefault = (PDRVDEVMODE) pdmOut;

            DriverDefaultDevmode(pdmDefault, pPrinterName, hPrinter);
            pdmDefault->dmPrivate.flags |= FAXDM_DRIVER_DEFAULT;

            result = CDM_RESULT_TRUE;
            ClosePrinter(hPrinter);

        } else
            Error(("OpenPrinter failed: %d\n", GetLastError()));
    }

    return (result == CDM_RESULT_TRUE);
}



LONG
SimpleDocumentProperties(
    PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    PUIDATA pUiData;

    //
    // Check if the caller is interested in the size only
    //

    pDPHdr->cbOut = sizeof(DRVDEVMODE);

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL)
        return pDPHdr->cbOut;

    //
    // Create a UIDATA structure
    //

    if (! (pUiData = FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn)))
        return -1;

    //
    // Copy the devmode back into the output buffer provided by the caller
    // Always return the smaller of current and input devmode
    //

    if (pDPHdr->fMode & (DM_COPY | DM_UPDATE))
        ConvertDevmodeOut((PDEVMODE) &pUiData->devmode, pDPHdr->pdmIn, pDPHdr->pdmOut);

    HeapDestroy(pUiData->hheap);
    return 1;
}



BOOL
AddDocPropPages(
    PUIDATA pUiData,
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Add our "Document Properties" pages to the property sheet

Arguments:

    pUiData - Points to our UIDATA structure
    pPrinterName - Specifies the printer name

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PROPSHEETPAGE   psp;

    //
    // "Document Properties" dialog only has one tab - "Fax Options"
    //

    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = ghInstance;

    if (pUiData->configDefault) {

        psp.lParam = 0;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USER_INFO);
        psp.pfnDlgProc = UserInfoDlgProc;

    } else {

        psp.lParam = (LPARAM) pUiData;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_DOCPROP);
        psp.pfnDlgProc = FaxOptionsProc;
    }

    pUiData->hFaxOptsPage = (HANDLE)
        pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                 CPSFUNC_ADD_PROPSHEETPAGE,
                                 (LPARAM) &psp,
                                 0);

    return (pUiData->hFaxOptsPage != NULL);
}



BOOL
GenerateFormsList(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Generate the list of forms supported by the fax driver

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFORM_INFO_1    pFormsDB;
    DWORD           cForms, count;

    //
    // Get a list of forms in the forms database
    //

    pFormsDB = GetFormsDatabase(pUiData->hPrinter, &cForms);

    if (pFormsDB == NULL || cForms == 0) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    //
    // Enumerate the list of supported forms
    //

    pUiData->cForms = count = EnumPaperSizes(NULL, pFormsDB, cForms, DC_PAPERS);
    Assert(count != GDI_ERROR);

    pUiData->pFormNames = HeapAlloc(pUiData->hheap, 0, sizeof(TCHAR) * count * CCHPAPERNAME);
    pUiData->pPapers = HeapAlloc(pUiData->hheap, 0, sizeof(WORD) * count);

    if (!pUiData->pFormNames || !pUiData->pPapers) {

        MemFree(pFormsDB);
        return FALSE;
    }

    EnumPaperSizes(pUiData->pFormNames, pFormsDB, cForms, DC_PAPERNAMES);
    EnumPaperSizes(pUiData->pPapers, pFormsDB, cForms, DC_PAPERS);

    MemFree(pFormsDB);
    return TRUE;
}



LPTSTR
GetHelpFilename(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Return the driver's help filename string

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    Pointer to the driver help filename, NULL if error

--*/

{
    PDRIVER_INFO_3  pDriverInfo3 = NULL;
    PVOID           pHelpFile = NULL;

    //
    // Attempt to get help file name using the new DRIVER_INFO_3
    //

    if (pDriverInfo3 = MyGetPrinterDriver(pUiData->hPrinter, 3)) {

        if ((pDriverInfo3->pHelpFile != NULL) &&
            (pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(pDriverInfo3->pHelpFile))))
        {
            _tcscpy(pHelpFile, pDriverInfo3->pHelpFile);
        }

        MemFree(pDriverInfo3);
    }

    //
    // If DRIVER_INFO_3 isn't supported, get help file name the old fashion way
    //

    if (pHelpFile == NULL) {
        if (!(pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(FAXCFG_HELP_FILENAME))) )
        {
            pHelpFile = NULL;

        } else {

            _tcscpy(pHelpFile, FAXCFG_HELP_FILENAME);
        }
    }

    Verbose(("Driver help filename: %ws\n", pHelpFile));
    return (pUiData->pHelpFile = pHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\help.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Help related declarations

Environment:

    Windows NT fax driver

Revision History:

    07/30/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _HELP_H_
#define _HELP_H_

//
// Name of the help file for the fax driver
//

#define HELP_FILENAME               TEXT("fax.hlp")

//
// Help indices
//

#define IDH_BILLING_CODE                  2002
#define IDH_IMAGE_QUALITY                 2025
#define IDH_LANDSCAPE                     2026
#define IDH_PAPER_SIZE                    2037
#define IDH_PORTRAIT                      2038
#define IDH_SEND_ASAP                     2046
#define IDH_SEND_AT_CHEAP                 2047
#define IDH_SEND_AT_TIME                  2048
#define IDH_EMAIL                         2049
#define IDH_FAX_SEND_GRP                  2075
#define IDH_DEFAULT_PRINT_SETUP_GRP       2070
#define IDH_ORIENTATION                   2062
#define IDH_SEND_AT_TIME                  2048

#endif  // !_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\faxopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxopts.c

Abstract:

    Functions for handling the Fax Options property sheet page

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "faxhelp.h"

//
// Table for mapping control IDs to help indices
//

static ULONG_PTR faxOptionsHelpIDs[] = {

    IDC_SEND_ASAP,                  IDH_FAXDEFAULT_SEND_ASAP,
    IDC_SEND_AT_CHEAP,              IDH_FAXDEFAULT_SEND_AT_CHEAP,
    IDC_SEND_AT_TIME,               IDH_FAXDEFAULT_SEND_AT_TIME,
    IDC_PAPER_SIZE,                 IDH_FAXDEFAULT_PAPER_SIZE,
    IDC_IMAGE_QUALITY,              IDH_FAXDEFAULT_IMAGE_QUALITY,
    IDC_PORTRAIT,                   IDH_FAXDEFAULT_PORTRAIT,
    IDC_LANDSCAPE,                  IDH_FAXDEFAULT_LANDSCAPE,
    IDC_BILLING_CODE,               IDH_FAXDEFAULT_BILLING_CODE,
    IDC_EMAIL,                      IDH_FAXDEFAULT_GENERAL_EMAIL_ADDRESS,
    IDI_FAX_OPTIONS,                (DWORD) -1,
    IDC_TITLE,                      (DWORD) -1,
    IDC_FAX_SEND_GRP,               IDH_FAXDEFAULT_FAX_SEND_TIME_GRP,
    IDC_DEFAULT_PRINT_SETUP_GRP,    IDH_FAXDEFAULT_DEFAULT_PRINT_SETUP_GRP,
    IDC_ORIENTATION,                IDH_FAXDEFAULT_ORIENTATION,
    IDC_SENDTIME,                   IDH_FAXDEFAULT_FAX_SEND_AT_TIME,
    0,                              0
};



VOID
DoInitializeFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Initializes the Fax Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE        pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE      pdmPrivate = &pUiData->devmode.dmPrivate;
    TCHAR           buffer[MAX_STRING_LEN];
    //TCHAR           TimeFormat[32];
    SYSTEMTIME      st;
    HWND            hwndList,hTimeControl;
    INT             itemId;
    TCHAR           Is24H[2], IsRTL[2], *pszTimeFormat = TEXT("h : mm tt");
    
    if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIME, Is24H,sizeof(Is24H) ) && Is24H[0] == TEXT('1')) {
        pszTimeFormat = TEXT("H : mm");
    }
    else if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIMEMARKPOSN, IsRTL,sizeof(IsRTL) ) && IsRTL[0] == TEXT('1')) {
        pszTimeFormat = TEXT("tt h : mm");
    }

    //
    // Time to send
    //

    itemId = (pdmPrivate->whenToSend == SENDFAX_AT_CHEAP) ? IDC_SEND_AT_CHEAP :
             (pdmPrivate->whenToSend == SENDFAX_AT_TIME) ? IDC_SEND_AT_TIME : IDC_SEND_ASAP;

    CheckRadioButton(hDlg, IDC_SEND_ASAP, IDC_SEND_AT_TIME, itemId);

    //
    // Initialize the send-at time control
    //

    //LoadString(ghInstance,IDS_WIZ_TIME_FORMAT,TimeFormat,sizeof(TimeFormat));
    hTimeControl = GetDlgItem(hDlg, IDC_SENDTIME);
        
    //DateTime_SetFormat( hTimeControl,TimeFormat );    
    DateTime_SetFormat( hTimeControl,pszTimeFormat );    

    GetLocalTime(&st);
    st.wHour = pdmPrivate->sendAtTime.Hour;
    st.wMinute = pdmPrivate->sendAtTime.Minute;
    DateTime_SetSystemtime( hTimeControl, GDT_VALID, &st );
    
    EnableWindow(hTimeControl, pdmPrivate->whenToSend == SENDFAX_AT_TIME);    

    //
    // Initialize the print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if (hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) {

        LPTSTR  pFormName = pUiData->pFormNames;
        INT     listIdx;

        for (itemId=0; itemId < pUiData->cForms; itemId++, pFormName += CCHPAPERNAME) {

            if ((listIdx = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFormName)) != CB_ERR) {

                SendMessage(hwndList, CB_SETITEMDATA, listIdx, itemId);

                if (_tcscmp(pFormName, pdmPublic->dmFormName) == EQUAL_STRING)
                    SendMessage(hwndList, CB_SETCURSEL, listIdx, 0);
            }
        }
    }

    if (hwndList = GetDlgItem(hDlg, IDC_IMAGE_QUALITY)) {

        LoadString(ghInstance, IDS_QUALITY_NORMAL, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        LoadString(ghInstance, IDS_QUALITY_DRAFT, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        itemId = (pdmPublic->dmYResolution == FAXRES_VERTDRAFT) ? 1 : 0;
        SendMessage(hwndList, CB_SETCURSEL, itemId, 0);
    }

    itemId = (pdmPublic->dmOrientation == DMORIENT_LANDSCAPE) ?
                IDC_LANDSCAPE : IDC_PORTRAIT;

    CheckDlgButton(hDlg, itemId, TRUE);

    SendDlgItemMessage(hDlg, IDC_BILLING_CODE, EM_SETLIMITTEXT, MAX_BILLING_CODE-1, 0);
    SetDlgItemText(hDlg, IDC_BILLING_CODE, pdmPrivate->billingCode);

    SendDlgItemMessage(hDlg, IDC_EMAIL, EM_SETLIMITTEXT, MAX_EMAIL_ADDRESS-1, 0);
    SetDlgItemText(hDlg, IDC_EMAIL, pdmPrivate->emailAddress);

    //
    // Disable all controls if the user has no permission
    //

    if (! pUiData->hasPermission) {

        EnableWindow(GetDlgItem(hDlg, IDC_SEND_ASAP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SEND_AT_CHEAP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SEND_AT_TIME), FALSE);

        EnableWindow(GetDlgItem(hDlg, IDC_PAPER_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_IMAGE_QUALITY), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PORTRAIT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LANDSCAPE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BILLING_CODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EMAIL), FALSE);
    }
}



VOID
DoSaveFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Save the information on the Fax Options property sheet page to registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE    pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE  pdmPrivate = &pUiData->devmode.dmPrivate;
    HWND        hwndList;
    INT         listIdx;    
    DWORD rVal;
    SYSTEMTIME SendTime;                        

    //
    // Time to send
    //

    pdmPrivate->whenToSend =
        IsDlgButtonChecked(hDlg, IDC_SEND_AT_CHEAP) ? SENDFAX_AT_CHEAP :
        IsDlgButtonChecked(hDlg, IDC_SEND_AT_TIME) ? SENDFAX_AT_TIME : SENDFAX_ASAP;

    //
    // Retrieve the current settings of send-at time control
    //

    rVal = DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_SENDTIME), &SendTime);
    pdmPrivate->sendAtTime.Hour = SendTime.wHour;
    pdmPrivate->sendAtTime.Minute = SendTime.wMinute;

    //
    // Retrieve the current settings of print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) &&
        (listIdx = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR)
    {
        listIdx = (INT)SendMessage(hwndList, CB_GETITEMDATA, listIdx, 0);

        if (listIdx >= 0 && listIdx < pUiData->cForms) {

            pdmPublic->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
            pdmPublic->dmFields |= DM_FORMNAME;
            pdmPublic->dmPaperSize = pUiData->pPapers[listIdx];

            CopyStringW(pdmPublic->dmFormName,
                        pUiData->pFormNames + listIdx * CCHPAPERNAME,
                        CCHFORMNAME);
        }
    }

    pdmPublic->dmPrintQuality = FAXRES_HORIZONTAL;

    pdmPublic->dmYResolution =
        (SendDlgItemMessage(hDlg, IDC_IMAGE_QUALITY, CB_GETCURSEL, 0, 0) == 1) ?
            FAXRES_VERTDRAFT :
            FAXRES_VERTICAL;

    pdmPublic->dmOrientation =
        IsDlgButtonChecked(hDlg, IDC_LANDSCAPE) ? DMORIENT_LANDSCAPE : DMORIENT_PORTRAIT;

    GetDlgItemText(hDlg, IDC_BILLING_CODE, pdmPrivate->billingCode, MAX_BILLING_CODE);
    GetDlgItemText(hDlg, IDC_EMAIL, pdmPrivate->emailAddress, MAX_EMAIL_ADDRESS);
    
}



INT_PTR
FaxOptionsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling Fax Options property sheet page

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    WORD    cmdId;
    static BOOL bPortrait;
    LPHELPINFO  lpHelpInfo;
    
    switch (message) {

    case WM_INITDIALOG:

        //
        // Remember the pointer to our UIDATA structure
        //

        lParam = ((PROPSHEETPAGE *) lParam)->lParam;
        pUiData = (PUIDATA) lParam;
        Assert(ValidUiData(pUiData));
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        //
        // Intitialize the controls with information from the registry
        //

        DoInitializeFaxOptions(hDlg, pUiData);
        bPortrait = IsDlgButtonChecked(hDlg,IDC_PORTRAIT);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

            case IDC_SEND_ASAP:
            case IDC_SEND_AT_CHEAP:
            case IDC_SEND_AT_TIME:
    
                //
                // Enable/disable time control depending on whether user
                // has chosen to send fax at specific time.
                //
    
                EnableWindow(GetDlgItem(hDlg, IDC_SENDTIME), cmdId == IDC_SEND_AT_TIME);
                PropSheet_Changed(GetParent(hDlg),hDlg);
                return TRUE;
    
            case IDC_SENDTIME:
                PropSheet_Changed(GetParent(hDlg),hDlg);
                break;
    
            case IDC_BILLING_CODE:
            case IDC_EMAIL:
                PropSheet_Changed(GetParent(hDlg),hDlg);
                break;
            
            };        

        if (HIWORD(wParam) == CBN_SELCHANGE) {
            if (GetDlgCtrlID((HWND)lParam) == IDC_IMAGE_QUALITY ||
                GetDlgCtrlID((HWND)lParam) == IDC_PAPER_SIZE ) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        if (HIWORD(wParam) == BN_CLICKED) {
            if ((LOWORD(wParam) == IDC_PORTRAIT && !bPortrait) ||
                (LOWORD(wParam) == IDC_LANDSCAPE && bPortrait)) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        break;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_APPLY) {            
            pUiData = (PUIDATA) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidUiData(pUiData));

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveFaxOptions(hDlg, pUiData);


            //
            // HACK: Inform common UI library that user has pressed OK
            //

            pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                     CPSFUNC_SET_RESULT,
                                     (LPARAM) pUiData->hFaxOptsPage,
                                     CPSUI_OK);
            
            return TRUE;
        } else if (((NMHDR *) lParam)->code == DTN_DATETIMECHANGE) {
           PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

    case WM_HELP:
        lpHelpInfo = (LPHELPINFO) lParam;

        if (IsChild(hDlg, lpHelpInfo->hItemHandle)) {
            while (GetParent(lpHelpInfo->hItemHandle) != hDlg) {
                lpHelpInfo->hItemHandle = GetParent(lpHelpInfo->hItemHandle);
            }
        }

    case WM_CONTEXTMENU:
        FAXWINHELP(message, wParam, lParam, faxOptionsHelpIDs);

/*++
        pUiData = (PUIDATA) GetWindowLongPtr(hDlg, DWLP_USER);

        if (ValidUiData(pUiData) && pUiData->pHelpFile) {

            HWND    hwndHelp;
            INT     helpCommand;

            if (message == WM_HELP) {

                hwndHelp = ((LPHELPINFO) lParam)->hItemHandle;
                helpCommand = HELP_WM_HELP;

            } else {

                hwndHelp = (HWND) wParam;
                helpCommand = HELP_CONTEXTMENU;
            }

            WinHelp(hwndHelp, pUiData->pHelpFile, helpCommand, (ULONG_PTR) faxOptionsHelpIDs);

        } else
            Assert(FALSE);

--*/
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\faxui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.c

Abstract:

    Common routines for fax driver user interface

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include <shlobj.h>


CRITICAL_SECTION    faxuiSemaphore;     // Semaphore for protecting critical sections
HANDLE              ghInstance;         // DLL instance handle
PUSERMEM            gUserMemList;       // Global list of user mode memory structures
INT                 _debugLevel = 1;    // for debuggping purposes

PVOID
PrMemAlloc(
    DWORD size
    )
{
    return (PVOID)LocalAlloc(LPTR, size);
}

VOID
PrMemFree(
    PVOID ptr
    )
{
    if (ptr) {
        LocalFree((HLOCAL) ptr);
    }
}



BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    WCHAR       DllName[MAX_PATH];
    INITCOMMONCONTROLSEX CommonControlsEx = {sizeof(INITCOMMONCONTROLSEX),
                                             ICC_WIN95_CLASSES|ICC_DATE_CLASSES };

    switch (ulReason) {

    case DLL_PROCESS_ATTACH:

        //
        // Keep our driver UI dll always loaded in memory
        //

        if (! GetModuleFileName(hModule, DllName, MAX_PATH) ||
            ! LoadLibrary(DllName))
        {
            return FALSE;
        }

        ghInstance = hModule;
        gUserMemList = NULL;

        HeapInitialize( NULL, PrMemAlloc, PrMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );

        InitializeCriticalSection(&faxuiSemaphore);
        InitCommonControlsEx(&CommonControlsEx);
        break;

    case DLL_PROCESS_DETACH:

        while (gUserMemList != NULL) {

            PUSERMEM    pUserMem;

            pUserMem = gUserMemList;
            gUserMemList = gUserMemList->pNext;
            FreePDEVUserMem(pUserMem);
        }

        DeleteCriticalSection(&faxuiSemaphore);
        break;
    }

    return TRUE;
}



LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    )

/*++

Routine Description:

    Calling common UI DLL entry point dynamically

Arguments:

    hwndOwner, pfnPropSheetUI, lParam, pResult - Parameters passed to common UI DLL

Return Value:

    Return value from common UI library

--*/

{
    HINSTANCE   hInstCompstui;
    FARPROC     pProc;
    LONG        Result = ERR_CPSUI_GETLASTERROR;

    //
    // Only need to call the ANSI version of LoadLibrary
    //

    static const CHAR szCompstui[] = "compstui.dll";
    static const CHAR szCommonPropSheetUI[] = "CommonPropertySheetUIW";

    if ((hInstCompstui = LoadLibraryA(szCompstui)) &&
        (pProc = GetProcAddress(hInstCompstui, szCommonPropSheetUI)))
    {
        Result = (LONG)(*pProc)(hwndOwner, pfnPropSheetUI, lParam, pResult);
    }

    if (hInstCompstui)
        FreeLibrary(hInstCompstui);

    return Result;
}



VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    )

/*++

Routine Description:

    Combine DEVMODE information:
     start with the driver default
     then merge with the system default
     then merge with the user default
     finally merge with the input devmode

Arguments:

    pdmOut - Pointer to the output devmode buffer
    pdmIn - Pointer to an input devmode
    hPrinter - Handle to a printer object
    pPrinterInfo2 - Point to a PRINTER_INFO_2 structure or NULL
    publicOnly - Only merge the public portion of the devmode

Return Value:

    TRUE

--*/

{
    PPRINTER_INFO_2 pAlloced = NULL;
    PDEVMODE        pdmUser;

    //
    // Get a PRINTER_INFO_2 structure if one is not provided
    //

    if (! pPrinterInfo2)
        pPrinterInfo2 = pAlloced = MyGetPrinter(hPrinter, 2);

    //
    // Start with driver default devmode
    //

    if (! publicOnly) {

        DriverDefaultDevmode(pdmOut,
                             pPrinterInfo2 ? pPrinterInfo2->pPrinterName : NULL,
                             hPrinter);
    }

    //
    // Merge with the system default devmode and user default devmode
    //

    if (pPrinterInfo2) {

        #if 0

        //
        // Since we have per-user devmode and there is no way to
        // change the printer's default devmode, there is no need
        // to merge it here.
        //

        if (! MergeDevmode(pdmOut, pPrinterInfo2->pDevMode, publicOnly))
            Error(("Invalid system default devmode\n"));

        #endif

        if (pdmUser = GetPerUserDevmode(pPrinterInfo2->pPrinterName)) {

            if (! MergeDevmode(pdmOut, pdmUser, publicOnly))
                Error(("Invalid user devmode\n"));

            MemFree(pdmUser);
        }
    }

    MemFree(pAlloced);

    //
    // Merge with the input devmode
    //

    if (! MergeDevmode(pdmOut, pdmIn, publicOnly))
        Error(("Invalid input devmode\n"));
}



PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Fill in the data structure used by the fax driver user interface

Arguments:

    hPrinter - Handle to the printer
    pdmInput - Pointer to input devmode, NULL if there is none

Return Value:

    Pointer to UIDATA structure, NULL if error.

--*/

{
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    PUIDATA         pUiData = NULL;
    HANDLE          hheap = NULL;

    //
    // Create a heap to manage memory
    // Allocate memory to hold UIDATA structure
    // Get printer info from the spooler
    // Copy the driver name
    //

    if (! (hheap = HeapCreate(0, 4096, 0)) ||
        ! (pUiData = HeapAlloc(hheap, HEAP_ZERO_MEMORY, sizeof(UIDATA))) ||
        ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)))
    {
        if (hheap)
            HeapDestroy(hheap);

        MemFree(pPrinterInfo2);
        return NULL;
    }

    pUiData->startSign = pUiData->endSign = pUiData;
    pUiData->hPrinter = hPrinter;
    pUiData->hheap = hheap;

    //
    // Combine various devmode information
    //

    GetCombinedDevmode(&pUiData->devmode, pdmInput, hPrinter, pPrinterInfo2, FALSE);

    //
    // Validate the form requested by the input devmode
    //

    if (! ValidDevmodeForm(hPrinter, &pUiData->devmode.dmPublic, NULL))
        Error(("Invalid form specification\n"));

    MemFree(pPrinterInfo2);
    return pUiData;
}



INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    NONE

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_DLGTITLE;

        LoadString(ghInstance, titleStrId, pTitle, MAX_TITLE_LEN);

        //
        // Load message format string resource
        //

        LoadString(ghInstance, formatStrId, pFormat, MAX_STRING_LEN);

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = MessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}



BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

    Implementation of DDI entry point DevQueryPrintEx. Even though we don't
    really need this entry point, we must export it so that the spooler
    will load our driver UI.

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure

Return Value:

    TRUE if there is no conflicts, FALSE otherwise

--*/

{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\mapiutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapiutil.c

Abstract:

    Utility functions for working with MAPI

Environment:

    Windows NT fax driver user interface

Revision History:

    09/18/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"

#define  INITGUID
#define  USES_IID_IMAPISession
#define  USES_IID_IDistList

#include "mapiwrap.h"

//
// Global variables used for accessing MAPI services
//

static HINSTANCE        hInstMapi = NULL;
static INT              mapiRefCount = 0;

ULONG                   lhMapiSession = 0;
LPMAPISESSION           lpMapiSession = NULL;
LPMAPILOGON             lpfnMAPILogon = NULL;
LPMAPILOGOFF            lpfnMAPILogoff = NULL;
LPMAPIADDRESS           lpfnMAPIAddress = NULL;
LPMAPIFREEBUFFER        lpfnMAPIFreeBuffer = NULL;
LPSCMAPIXFROMSMAPI      lpfnScMAPIXFromSMAPI = NULL;

//
// Function to insert a recipient into the recipient list view
//

BOOL
InsertRecipientListItem(
    HWND        hwndLV,
    PRECIPIENT  pRecipient
    );



BOOL
IsMapiAvailable(
    VOID
    )

/*++

Routine Description:

    Determine whether MAPI is available

Arguments:

    NONE

Return Value:

    TRUE if MAPI is installed on the system, FALSE otherwise

--*/

{
    return GetProfileInt(TEXT("MAIL"), TEXT("MAPI"), 0);
}



BOOL
DoMapiLogon(
    HWND        hDlg
    )

/*++

Routine Description:

    Logon MAPI to in order to access address book

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE if there is an error

!!!BUGBUG:

    MAPI is not Unicoded enabled on NT.
    Must revisit this code once that's fixed.

--*/

#define MAX_PROFILE_NAME 256

{
    LPTSTR  profileName;
    CHAR    ansiProfileName[MAX_PROFILE_NAME];
    HKEY    hRegKey;
    ULONG   status;

    //
    // Retrieve the fax profile name stored in registry
    //

    profileName[0] = NUL;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_SETUP, REG_READONLY)) {

        profileName = GetRegistryString(hRegKey, REGVAL_FAX_PROFILE, TEXT(""));
        
        RegCloseKey(hRegKey);

        if (!profileName || !*profileName) {
            return FALSE;
        }
    } else {
        return FALSE;
    }

    Verbose(("Fax profile name: %ws\n", profileName));

    //
    // Attempt to logon to MAPI - We need to convert MAPI profile name to ANSI
    // here because MAPI is not Unicode enabled.
    //

    if (! WideCharToMultiByte(CP_ACP,
                              0,
                              profileName,
                              -1,
                              ansiProfileName,
                              MAX_PROFILE_NAME,
                              NULL,
                              NULL))
    {
        Error(("WideCharToMultiByte failed: %d\n", GetLastError()));
        MemFree(profileName);
        return FALSE;
    }

    MemFree(profileName);

    status = lpfnMAPILogon((ULONG) hDlg,
                           ansiProfileName,
                           NULL,
                           MAPI_LOGON_UI,
                           0,
                           &lhMapiSession);

    //
    // If a profile name is specified and logon failed,
    // then try again without a profile.
    //

    if (status != SUCCESS_SUCCESS && !IsEmptyString(ansiProfileName)) {

        ansiProfileName[0] = NUL;

        status = lpfnMAPILogon((ULONG) hDlg,
                               ansiProfileName,
                               NULL,
                               MAPI_LOGON_UI,
                               0,
                               &lhMapiSession);
    }

    if (status != SUCCESS_SUCCESS) {

        Error(("MAPILogon failed: %d\n", status));
        return FALSE;
    }

    //
    // Convert simple MAPI session handle to extended MAPI session pointer
    //

    if (FAILED(lpfnScMAPIXFromSMAPI(lhMapiSession, 0, &IID_IMAPISession, &lpMapiSession))) {

        Error(("ScMAPIXFromSMAPI failed: %d\n", GetLastError()));
        lpfnMAPILogoff(lhMapiSession, 0, 0, 0);
        return FALSE;
    }

    return TRUE;
}



BOOL
InitMapiService(
    HWND    hDlg
    )

/*++

Routine Description:

    Initialize Simple MAPI services if necessary

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Every successful call to this function must be balanced
    by a call to DeinitMapiService.

--*/

{
    BOOL result;

    EnterDrvSem();

    //
    // Load MAPI32.DLL into memory if necessary
    //

    if ((hInstMapi == NULL) &&
        (hInstMapi = LoadLibrary(TEXT("MAPI32.DLL"))))
    {
        //
        // Get pointers to various Simple MAPI functions
        //

        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress(hInstMapi, "MAPILogon");
        lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(hInstMapi, "MAPILogoff");
        lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress(hInstMapi, "MAPIAddress");
        lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(hInstMapi, "MAPIFreeBuffer");
        lpfnScMAPIXFromSMAPI = (LPSCMAPIXFROMSMAPI) GetProcAddress(hInstMapi, "ScMAPIXFromSMAPI");

        //
        // Begins a simple MAPI session and obtain session handle and pointer
        //

        if (lpfnMAPILogon == NULL ||
            lpfnMAPILogoff == NULL ||
            lpfnMAPIAddress == NULL ||
            lpfnMAPIFreeBuffer == NULL ||
            lpfnScMAPIXFromSMAPI == NULL ||
            !DoMapiLogon(hDlg))
        {
            //
            // Clean up properly in case of error
            //

            lhMapiSession = 0;
            lpMapiSession = NULL;
            FreeLibrary(hInstMapi);
            hInstMapi = NULL;
        }
    }

    if (result = (hInstMapi != NULL))
        mapiRefCount++;
    else
        Error(("InitMapiService failed: %d", GetLastError()));

    LeaveDrvSem();

    return result;
}



VOID
DeinitMapiService(
    VOID
    )

/*++

Routine Description:

    Deinitialize Simple MAPI services if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    EnterDrvSem();

    Assert(hInstMapi != NULL);

    if (mapiRefCount > 0 && --mapiRefCount == 0 && hInstMapi != NULL) {
        
        if (lpMapiSession)
            MAPICALL(lpMapiSession)->Release(lpMapiSession);

        if (lhMapiSession)
            lpfnMAPILogoff(lhMapiSession, 0, 0, 0);

        lhMapiSession = 0;
        lpMapiSession = NULL;
        FreeLibrary(hInstMapi);
        hInstMapi = NULL;
    }

    LeaveDrvSem();
}



LPSTR
DupStringUnicodeToAnsi(
    LPWSTR  pUnicodeStr
    )

/*++

Routine Description:

    Convert a Unicode string to a multi-byte string

Arguments:

    pUnicodeStr - Pointer to the Unicode string to be duplicated

Return Value:

    Pointer to the duplicated multi-byte string

NOTE:

    This is only need because MAPI is not Unicode enabled on NT.

--*/

{
    INT     nChar;
    LPSTR   pAnsiStr;

    //
    // Figure out how much memory to allocate for the multi-byte string
    //

    if (! (nChar = WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, NULL, 0, NULL, NULL)) ||
        ! (pAnsiStr = MemAlloc(nChar)))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, pAnsiStr, nChar, NULL, NULL);
    return pAnsiStr;
}



BOOL
CallMapiAddress(
    HWND            hDlg,
    PUSERMEM        pUserMem,
    PULONG          pnRecips,
    lpMapiRecipDesc *ppRecips
    )

/*++

Routine Description:

    Call MAPIAddress to display the address dialog

Arguments:

    hDlg - Handle to the send fax wizard window
    pUserMem - Points to user mode memory structure
    pnRecips - Returns number of selected recipients
    ppRecips - Returns information about selected recipients

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    lpMapiRecipDesc pRecips;
    PRECIPIENT      pRecipient;
    ULONG           nRecips, index;
    LONG            status;

    //
    // Convert the recipient list to an array of MapiRecipDesc
    //

    nRecips = 0;
    pRecipient = pUserMem->pRecipients;

    while (pRecipient) {

        nRecips++;
        pRecipient = pRecipient->pNext;
    }

    if (nRecips == 0)
        pRecips = NULL;
    else if (! (pRecips = MemAllocZ(nRecips * sizeof(MapiRecipDesc))))
        return FALSE;

    status = SUCCESS_SUCCESS;
    index = nRecips;
    pRecipient = pUserMem->pRecipients;

    Verbose(("Recipients passed to MAPIAddress:\n"));

    while (index-- > 0) {

        Assert(pRecipient != NULL);

        pRecips[index].ulRecipClass = MAPI_TO;
        pRecips[index].lpszName = DupStringUnicodeToAnsi(pRecipient->pName);
        pRecips[index].lpszAddress = DupStringUnicodeToAnsi(pRecipient->pAddress);

        if (!pRecips[index].lpszName || !pRecips[index].lpszAddress) {

            status = MAPI_E_INSUFFICIENT_MEMORY;
            break;
        }

        Verbose(("    %s, %s\n", pRecips[index].lpszName, pRecips[index].lpszAddress));

        pRecipient = pRecipient->pNext;
    }

    //
    // Call MAPI to display the address book dialog
    //

    if (status == SUCCESS_SUCCESS) {

        status = lpfnMAPIAddress(lhMapiSession,
                                 (ULONG) hDlg,
                                 NULL,
                                 1,
                                 NULL,
                                 nRecips,
                                 pRecips,
                                 MAPI_LOGON_UI,
                                 0,
                                 pnRecips,
                                 ppRecips);
    }

    //
    // Free the input recipient list after coming back from MAPI
    //

    for (index=0; index < nRecips; index++) {

        MemFree(pRecips[index].lpszName);
        MemFree(pRecips[index].lpszAddress);
    }

    MemFree(pRecips);

    if (status != SUCCESS_SUCCESS) {

        Error(("MAPIAddress failed: %d\n", status));
        return FALSE;
    }

    return TRUE;
}



INT
InterpretSimpleAddress(
    PUSERMEM        pUserMem,
    HWND            hwndLV,
    LPSTR           pRecipName,
    LPSTR           pRecipAddress
    )

/*++

Routine Description:

    Process a simple address entry and insert it into the recipient list view

Arguments:

    pUserMem - Points to user mode memory structure
    hwndLV - Handle to the recipient list view window
    pRecipName - Specifies the name of the recipient
    pRecipName - Specifies the recipient's address

Return Value:

    -1 : if there is an error
     0 : if the address entry is ignored
     1 : if successful

--*/

{
    LPTSTR      pName, pAddress;
    INT         nameLen, addrLen;
    PRECIPIENT  pRecipient;

    //
    // Allocate memory to hold recipient information
    //

    if (pRecipName == NULL) {

        Error(("Recipient name is NULL!\n"));
        return -1;
    }

    nameLen = strlen(pRecipName) + 1;
    addrLen = strlen(pRecipAddress) + 1;

    pRecipient = MemAllocZ(sizeof(RECIPIENT));
    pName = MemAllocZ(nameLen * sizeof(TCHAR));
    pAddress = MemAllocZ(addrLen * sizeof(TCHAR));

    if (!pRecipient || !pName || !pAddress) {

        Error(("Memory allocation failed\n"));
        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return -1;
    }

    pRecipient->pName = pName;
    pRecipient->pAddress = pAddress;

    //
    // Convert name and address from Ansi string to Unicode string
    //

    MultiByteToWideChar(CP_ACP, 0, pRecipName, -1, pName, nameLen);
    MultiByteToWideChar(CP_ACP, 0, pRecipAddress, -1, pAddress, addrLen);

    //
    // Add this recipient to the recipient list
    //

    if (InsertRecipientListItem(hwndLV, pRecipient)) {

        pRecipient->pNext = pUserMem->pRecipients;
        pUserMem->pRecipients = pRecipient;
        return 1;

    } else {

        FreeRecipient(pRecipient);
        return -1;
    }
}



INT
DetermineAddressType(
    LPSTR   pAddress
    )

/*++

Routine Description:

    Determine the type of an address

Arguments:

    pAddress - Points to an address or address type string

Return Value:

    One of the ADDRTYPE_* constants below

--*/

#define ADDRTYPE_NULL       0
#define ADDRTYPE_FAX        1
#define ADDRTYPE_MAPIPDL    2
#define ADDRTYPE_UNKNOWN    3

#define ADDRTYPESTR_FAX     "FAX"
#define ADDRTYPESTR_MAPIPDL "MAPIPDL"

{
    INT     n;
    LPSTR   p;

    //
    // Check if the input string is NULL
    //

    if (pAddress == NULL)
        return ADDRTYPE_NULL;

    //
    // Check if the address type is FAX
    //

    p = ADDRTYPESTR_FAX;
    n = strlen(p);

    if ((_strnicmp(pAddress, p, n) == EQUAL_STRING) &&
        (pAddress[n] == NUL || pAddress[n] == ':'))
    {
        return ADDRTYPE_FAX;
    }

    //
    // Check if the address type is MAPIPDL
    //

    p = ADDRTYPESTR_MAPIPDL;
    n = strlen(p);

    if ((_strnicmp(pAddress, p, n) == EQUAL_STRING) &&
        (pAddress[n] == NUL || pAddress[n] == ':'))
    {
        return ADDRTYPE_MAPIPDL;
    }

    //
    // Address type is something that we don't understand
    //

    return ADDRTYPE_UNKNOWN;
}



LPSTR
ConcatTypeWithAddress(
    LPSTR   pType,
    LPSTR   pAddress
    )

/*++

Routine Description:

    Helper function to concatenate address type in front of the address

Arguments:

    pType - Points to address type string
    pAddress - Points to address string

Return Value:

    Pointer to concatenated address, NULL if there is an error

--*/

{
    INT     length;
    LPSTR   p;

    //
    // Sanity check
    //

    if (pType == NULL || pAddress == NULL)
        return NULL;

    //
    // Calculate the length of the concatenated string
    //

    length = strlen(pType) + 1 + strlen(pAddress) + 1;

    //
    // Concatenate type with address, separated by a colon
    //

    if (p = MemAllocZ(length))
        sprintf(p, "%s:%s", pType, pAddress);

    return p;
}



INT
InterpretDistList(
    PUSERMEM        pUserMem,
    HWND            hwndLV,
    ULONG           ulEIDSize,
    PVOID           pEntryID
    )

/*++

Routine Description:

    Expand a distribution list entry and insert the individual
    addresses into the recipient list view.

Arguments:

    pUserMem - Points to user mode memory structure
    hwndLV - Handle to the recipient list view window
    ulEIDSize - Specifies the size of entry ID
    pEntryID - Points to entry ID data

Return Value:

    > 0 : total number of useful address entries
    = 0 : no useful address entry found
    < 0 : if there is an error

--*/

#define EXIT_IF_FAILED(hr) { if (FAILED(hr)) goto ExitDistList; }

{
    LPDISTLIST      pDistList = NULL;
    LPMAPITABLE     pMapiTable = NULL;
    LPSRowSet       pRows = NULL;
    ULONG           ulObjType, cRows;
    HRESULT         hr;
    INT             entriesUsed = 0;

    static SizedSPropTagArray(4, sPropTags) =
    {
        4,
        {
            PR_ENTRYID,
            PR_ADDRTYPE_A,
            PR_DISPLAY_NAME_A,
            PR_EMAIL_ADDRESS_A
        }
    };

    //
    // Deal with distribution lists
    //

    if (ulEIDSize == 0 || pEntryID == NULL) {

        Error(("Unusable address entry\n"));
        return FALSE;
    }

    //
    // Open the recipient entry
    //

    hr = MAPICALL(lpMapiSession)->OpenEntry(lpMapiSession,
                                            ulEIDSize,
                                            pEntryID,
                                            &IID_IDistList,
                                            MAPI_DEFERRED_ERRORS,
                                            &ulObjType,
                                            (LPUNKNOWN *) &pDistList);

    EXIT_IF_FAILED(hr);

    //
    // Get the contents table of the address entry
    //

    hr = MAPICALL(pDistList)->GetContentsTable(pDistList,
                                               MAPI_DEFERRED_ERRORS,
                                               &pMapiTable);

    EXIT_IF_FAILED(hr);

    //
    // Limit the query to only the properties we're interested in
    //

    hr = MAPICALL(pMapiTable)->SetColumns(pMapiTable, (LPSPropTagArray) &sPropTags, 0);

    EXIT_IF_FAILED(hr);

    //
    // Get the total number of rows
    //

    hr = MAPICALL(pMapiTable)->GetRowCount(pMapiTable, 0, &cRows);

    EXIT_IF_FAILED(hr);

    //
    // Get the individual entries of the distribution list
    //

    hr = MAPICALL(pMapiTable)->SeekRow(pMapiTable, BOOKMARK_BEGINNING, 0, NULL);

    EXIT_IF_FAILED(hr);

    hr = MAPICALL(pMapiTable)->QueryRows(pMapiTable, cRows, 0, &pRows);

    EXIT_IF_FAILED(hr);

    hr = S_OK;
    entriesUsed = 0;

    if (pRows && pRows->cRows) {

        //
        // Handle each entry of the distribution list in turn:
        //  for simple entries, call InterpretSimpleAddress
        //  for embedded distribution list, call this function recursively
        //

        for (cRows = 0; cRows < pRows->cRows; cRows++) {

            LPSPropValue lpProps = pRows->aRow[cRows].lpProps;
            LPSTR   pType, pName, pAddress;
            INT     result;

            pType = lpProps[1].Value.lpszA;
            pName = lpProps[2].Value.lpszA;
            pAddress = lpProps[3].Value.lpszA;

            Verbose(("    %s: %s", pType, pName));

            switch (DetermineAddressType(pType)) {

            case ADDRTYPE_FAX:

                if ((pAddress != NULL) &&
                    (lpProps[3].ulPropTag == PR_EMAIL_ADDRESS_A) &&
                    (pAddress = ConcatTypeWithAddress(pType, pAddress)))
                {
                    Verbose((", %s\n", pAddress));

                    result = InterpretSimpleAddress(pUserMem, hwndLV, pName, pAddress);
                    MemFree(pAddress);

                } else {

                    Verbose(("\nBad address.\n"));
                    result = -1;
                }
                break;

            case ADDRTYPE_MAPIPDL:
            case ADDRTYPE_NULL:

                Verbose(("\n"));

                result = InterpretDistList(pUserMem,
                                           hwndLV,
                                           lpProps[0].Value.bin.cb,
                                           lpProps[0].Value.bin.lpb);
                break;

            default:

                Verbose(("\nUnknown address type.\n"));
                result = 0;
                break;
            }

            if (result < 0)
                hr = -1;
            else
                entriesUsed += result;
        }
    }

ExitDistList:

    //
    // Perform necessary clean up before returning to caller
    //

    if (pRows) {

        for (cRows = 0; cRows < pRows->cRows; cRows++)
            lpfnMAPIFreeBuffer(pRows->aRow[cRows].lpProps);

        lpfnMAPIFreeBuffer(pRows);
    }

    if (pMapiTable)
        MAPICALL(pMapiTable)->Release(pMapiTable);

    if (pDistList)
        MAPICALL(pDistList)->Release(pDistList);

    if (FAILED(hr)) {

        Error(("InterpretDistList failed: 0x%x\n", hr));
        return -1;

    } else
        return entriesUsed;
}



BOOL
InterpretSelectedAddresses(
    HWND            hDlg,
    PUSERMEM        pUserMem,
    HWND            hwndLV,
    ULONG           nRecips,
    lpMapiRecipDesc pRecips
    )

/*++

Routine Description:

    Expand the selected addresses and insert them into the recipient list view

Arguments:

    hDlg - Handle to the send fax wizard window
    pUserMem - Points to user mode memory structure
    hwndLV - Handle to the recipient list view window
    nRecips - Number of selected recipients
    pRecips - Information about selected recipients

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     discarded = 0;

    //
    // Remove all existing entries in the recipient list view
    //

    if (! ListView_DeleteAllItems(hwndLV))
        return FALSE;

    FreeRecipientList(pUserMem);

    Verbose(("Recipients returned from MAPIAddress:\n"));

    for ( ; nRecips--; pRecips++) {

        INT result;

        Verbose(("  %s, %s\n", pRecips->lpszName, pRecips->lpszAddress));

        switch (DetermineAddressType(pRecips->lpszAddress)) {

        case ADDRTYPE_FAX:

            result = InterpretSimpleAddress(pUserMem,
                                            hwndLV,
                                            pRecips->lpszName,
                                            pRecips->lpszAddress);
            break;

        case ADDRTYPE_MAPIPDL:
        case ADDRTYPE_NULL:

            result = InterpretDistList(pUserMem,
                                       hwndLV,
                                       pRecips->ulEIDSize,
                                       pRecips->lpEntryID);
            break;

        default:

            Verbose(("Unknown address type.\n"));
            result = 0;
            break;
        }

        if (result <= 0)
            discarded++;
    }

    if (discarded)
        DisplayMessageDialog(hDlg, 0, 0, IDS_BAD_ADDRESS_TYPE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\faxui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.h

Abstract:

    Fax driver user interface header file

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXUI_H_
#define _FAXUI_H_

#include <windows.h>
#include <winfax.h>

#include "faxlib.h"

#include <winddiui.h>
#include <commctrl.h>
#include <windowsx.h>
#include <prsht.h>

#ifdef FAX_SCAN_ENABLED
#include <twain.h>
#endif

#include "registry.h"
#include "timectrl.h"
#include "coverpg.h"
#include "resource.h"

#include "faxcfgrs.h"

//
// Data structure maintained by the fax driver user interface
//

typedef struct {

    PVOID           startSign;
    HANDLE          hPrinter;
    HANDLE          hheap;
    DRVDEVMODE      devmode;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hFaxOptsPage;
    BOOL            hasPermission;
    BOOL            configDefault;
    LPTSTR          pHelpFile;

    INT             cForms;
    LPTSTR          pFormNames;
    PWORD           pPapers;
    PVOID           endSign;

} UIDATA, *PUIDATA;

//
// Check if a UIDATA structure is valid
//

#define ValidUiData(p) ((p) && (p) == (p)->startSign && (p) == (p)->endSign)

//
// Combine DEVMODE information:
//  start with the driver default
//  then merge with the system default
//  then merge with the user default
//  finally merge with the input devmode
//

VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    );

//
// Fill in the data structure used by the fax driver user interface
//

PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    );

//
// Calling common UI DLL entry point dynamically
//

LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    );

//
// Retrieves a list of supported paper sizes
//

DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

#define CCHBINNAME          24      // max length for bin names
#define CCHPAPERNAME        64      // max length for form names

//
// Display an error message dialog
//

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     formatStrId,
    INT     titleStrId,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_FORMAT_LEN      128
#define MAX_MESSAGE_LEN     512

//
// Information about each recipient
//

typedef struct {

    PVOID       pNext;          // Points to next recipient
    LPTSTR      pName;          // Recipient name
    LPTSTR      pAddress;       // Recipient address
} RECIPIENT, *PRECIPIENT;

//
// Data structure used by the user mode DLL to associate private
// information with a printer device context (PDEV to be exactly)
//

typedef struct {

    DRVDEVMODE      devmode;                // The first field must be a current version devmode
    PVOID           pNext;                  // Points to the next item in the linked list
    HANDLE          hPrinter;               // Handle to the printer object
    HDC             hdc;                    // Handle to the device context
    LPTSTR          pPrinterName;           // name of the printer
    BOOL            isLocalPrinter;         // whether the printer is local
    INT             pageCount;              // Number of pages in the document
    BOOL            finishPressed;          // User pressed Finish in fax wizard pages
    DWORD           jobId;                  // Current job ID
    PRECIPIENT      pRecipients;            // List of recipients
    LPTSTR          pSubject;               // Subject string
    LPTSTR          pNoteMessage;           // Note message string
    TCHAR           coverPage[MAX_PATH];    // Cover page filename
    BOOL            noteOnCover;            // Whether to send note message on the cover page
    INT             jobType;                // Job type
    PVOID           pCPInfo;                // For managing cover pages
    BOOL            directPrinting;         // Direct printing and skip the fax wizard
    LPVOID          lpWabInit;              // pointer to wab object
    DWORD           noteSubjectFlag;        // Whether note/subject fields are present on cover page
    SHORT           cpPaperSize;            // Cover page paper size
    SHORT           cpOrientation;          // Cover page orientation
    PVOID           pEnvVar;                // fax attachment variable
    LPTSTR          pPrintFile;             // print to file file name
    BOOL            ServerCPOnly;           //
    HANDLE          hFaxSvcEvent;           // signals fax service query complete    
    HANDLE          hTapiEvent;             // signals tapi enumeration complete
    HANDLE          hMutex;                 //
    HFONT           hLargeFont;             // large bold font for wizard 97
#ifdef FAX_SCAN_ENABLED
    HWND            hDlgScan;               // scanning wizard page
    HMODULE         hTwain;                 // module handle for twain dll
    DSMENTRYPROC    pDsmEntry;              // pointer to the twain data source manager proc
    TW_IDENTITY     AppId;                  // application id/handle for twain
    TW_IDENTITY     DataSource;             // application id/handle for twain
    HWND            hWndTwain;              // window handle for twain
    HANDLE          hEvent;                 //
    HANDLE          hEventQuit;             //
    HANDLE          hEventXfer;             //
    HANDLE          hThread;                //
    BOOL            TwainCancelled;         // TRUE if twain UI was cancelled
    HANDLE          hTwainEvent;            // signals twain detection complete
    
    BOOL            TwainAvail;             //
    BOOL            TwainActive;            //
    DWORD           BufferSize;             //
    LPBYTE          ScanBuffer;             //
    DWORD           State;                  //
    float           dxResDefault;           //
    float           dyResDefault;           //
    TW_IMAGELAYOUT  twImageLayoutDefault;   //
    WCHAR           FileName[MAX_PATH];     //
    DWORD           PageCount;              //    
#endif
    PVOID         signature;              // Signature

} USERMEM, *PUSERMEM;

//
// Validate a user mode memory structure
//

#define ValidPDEVUserMem(p) \
        ((p) && (p) == (p)->signature && (p) == (p)->devmode.dmPrivate.pUserMem)

//
// Mark the user mode memory structure
//

#define MarkPDEVUserMem(p)  \
        { (p)->signature = (p)->devmode.dmPrivate.pUserMem = (p); }

//
// Different types of print job
//

#define JOBTYPE_DIRECT  0
#define JOBTYPE_NORMAL  1

//
// Free up the list of recipients associated with each fax job
//

VOID
FreeRecipientList(
    PUSERMEM    pUserMem
    );

#define FreeRecipient(pRecipient) { \
            MemFree(pRecipient->pName); \
            MemFree(pRecipient->pAddress); \
            MemFree(pRecipient); \
        }

//
// Free up the user mode memory associated with each PDEV
//

VOID
FreePDEVUserMem(
    PUSERMEM    pUserMem
    );

//
// Global variable declarations
//

extern CRITICAL_SECTION faxuiSemaphore;
extern HANDLE   ghInstance;
extern BOOL     oleInitialized;
extern PUSERMEM gUserMemList;

#define EnterDrvSem() EnterCriticalSection(&faxuiSemaphore)
#define LeaveDrvSem() LeaveCriticalSection(&faxuiSemaphore)

INT_PTR
UserInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

DWORD
AsyncWizardThread(
    PBYTE param
    );

BOOL
InitializeTwain(
    PUSERMEM pUserMem
    );



#define MyHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#endif // !_FAXUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\mapiwrap.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapiwrap.h

Abstract:

    Utility functions for working with MAPI

Environment:

	Windows NT fax driver user interface

Revision History:

	09/18/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _MAPIWRAP_H_
#define _MAPIWRAP_H_

#include <mapix.h>
#include <mapi.h>

#define MAPICALL(p) (p)->lpVtbl


//
// MAPI address type for fax addresses
//

#define FAX_ADDRESS_TYPE    TEXT("FAX:")

//
// Determine whether MAPI is available
//

BOOL
IsMapiAvailable(
    VOID
    );

//
// Initialize Simple MAPI services if necessary
//

BOOL
InitMapiService(
    HWND    hDlg
    );

//
// Deinitialize Simple MAPI services if necessary
//

VOID
DeinitMapiService(
    VOID
    );

//
// Call MAPIAddress to display the address dialog
//

BOOL
CallMapiAddress(
    HWND            hDlg,
    PUSERMEM        pUserMem,
    PULONG          pnRecips,
    lpMapiRecipDesc *ppRecips
    );

//
// Expanded the selected addresses and insert them into the recipient list view
//

BOOL
InterpretSelectedAddresses(
    HWND            hDlg,
    PUSERMEM        pUserMem,
    HWND            hwndLV,
    ULONG           nRecips,
    lpMapiRecipDesc pRecips
    );

//
// Function points to Simple MAPI entrypoints
//

typedef SCODE (*LPSCMAPIXFROMSMAPI)(LHANDLE, ULONG, LPCIID, LPMAPISESSION *);

extern LPMAPILOGON          lpfnMAPILogon;
extern LPMAPILOGOFF         lpfnMAPILogoff;
extern LPMAPIADDRESS        lpfnMAPIAddress;
extern LPMAPIFREEBUFFER     lpfnMAPIFreeBuffer;
extern LPSCMAPIXFROMSMAPI   lpfnScMAPIXFromSMAPI;
extern ULONG                lhMapiSession;
extern LPMAPISESSION        lpMapiSession;

#endif	// !_MAPIWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\prnprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnprop.c

Abstract:

    Implementation of DDI entry points:
        DrvDevicePropertySheets
        PrinterProperties

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include <shellapi.h>
#include <faxreg.h>



LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Printer Properties" dialog

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DEVICEPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PROPSHEETPAGE           psp;

    //
    // Validate input parameters
    //

    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit)) {

        Assert(FALSE);
        return -1;
    }

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:

        //
        // "Printer Properties" dialog only has one dummy tab
        //

        memset(&psp, 0, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.hInstance = ghInstance;
        psp.lParam = 0;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USER_INFO);
        psp.pfnDlgProc = UserInfoDlgProc;

        if (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                       CPSFUNC_ADD_PROPSHEETPAGE,
                                       (LPARAM) &psp,
                                       0))
        {
            pPSUIInfo->UserData = 0;
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }

        break;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInstance;
            pPSUIHdr->IconID = IDI_CPSUI_FAX;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:

        pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
        return 1;

    case PROPSHEETUI_REASON_DESTROY:
        return 1;
    }

    return -1;
}



BOOL
PrinterProperties(
    HWND    hwnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    Displays a printer-properties dialog box for the specified printer

Arguments:

    hwnd - Identifies the parent window of the dialog box
    hPrinter - Identifies a printer object

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

[Note:]

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    DEVICEPROPERTYHEADER devPropHdr;
    DWORD                result;

    memset(&devPropHdr, 0, sizeof(devPropHdr));
    devPropHdr.cbSize = sizeof(devPropHdr);
    devPropHdr.hPrinter = hPrinter;
    devPropHdr.pszPrinterName = NULL;

    //
    // Decide if the caller has permission to change anything
    //

    if (! SetPrinterDataDWord(hPrinter, PRNDATA_PERMISSION, 1))
        devPropHdr.Flags |= DPS_NOPERMISSION;

    CallCompstui(hwnd, DrvDevicePropertySheets, (LPARAM) &devPropHdr, &result);

    return result > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\tapiutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.h

Abstract:

    Utility functions for working with TAPI

Environment:

        Windows NT fax driver user interface

Revision History:

        09/18/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <tapi.h>
#include <shellapi.h>


//
// Initialize TAPI services if necessary
//

BOOL
InitTapiService(
    VOID
    );

//
// Deinitialize TAPI services if necessary
//

VOID
DeinitTapiService(
    VOID
    );

//
// Get a list of locations from TAPI
//

LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    );

//
// Change the default TAPI location
//

BOOL
SetCurrentLocation(
    DWORD   locationID
    );

//
// Initialize the country list box
//

VOID
InitCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode,
    DWORD   countryCode
    );

//
// Handle selection changes in the country list box
//

VOID
SelChangeCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode
    );

//
// Return the current selection of country list box
//

DWORD
GetCountryListBoxSel(
    HWND    hwndList
    );

//
// Return the default country ID for the current location
//

DWORD
GetDefaultCountryID(
    VOID
    );

//
// Given a LINECOUNTRYENTRY structure, determine if area code is needed in that country
//

INT
AreaCodeRules(
    LPLINECOUNTRYENTRY  pLineCountryEntry
    );

#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

//
// Find the specified country from a list of all countries and
// return a pointer to the corresponding LINECOUNTRYENTRY structure
//

LPLINECOUNTRYENTRY
FindCountry(
    DWORD   countryId
    );

//
// Assemble a canonical phone number given the following:
//  country code, area code, and phone number
//

VOID
AssemblePhoneNumber(
    LPTSTR  pAddress,
    DWORD   countryCode,
    LPTSTR  pAreaCode,
    LPTSTR  pPhoneNumber
    );

//
// bring up the telephony control panel
//
BOOL
DoTapiProps(
    HWND hDlg
    );

#endif  // !_TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Definition of resource ID constants

Environment:

        Fax driver user interface

Revision History:

        02/26/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//
#define IDS_WIZ_COVERPAGE_TITLE_1       243
#define IDS_WIZ_COVERPAGE_SUB_1         244
#define IDS_WIZ_COVERPAGE_TITLE_2       245
#define IDS_WIZ_COVERPAGE_SUB_2         246
#define IDS_ERR_TAPI_CPL_LAUNCH         247
#define IDS_SEND_SPECIFIC               248
#define IDS_MULTIPLE_RECIPIENTS         249
#define IDS_NONE                        250
#define IDS_SCAN_ERROR_TITLE            251
#define IDS_SCAN_ERROR_BW               252
#define IDS_WIZARD_TITLE                253
#define IDS_WIZ_CPL_LAUNCH              254
#define IDS_ERR_CPL_LAUNCH              255
#define IDS_SLOT_ONLYONE                256
#define IDS_QUALITY_NORMAL              257
#define IDS_QUALITY_DRAFT               258
#define IDS_NO_COUNTRY                  259
#define IDS_ERROR_DLGTITLE              260
#define IDS_BAD_RECIPIENT_NAME          262
#define IDS_BAD_RECIPIENT_NUMBER        263
#define IDS_BAD_RECIPIENT_AREACODE      264
#define IDS_BAD_ADDRESS_TYPE            265
#define IDS_COVERPAGE_FOR               266
#define IDS_CPRENDER_FAILED             267
#define IDS_FAXCLIENT_SETUP             268
#define IDS_FAXCLIENT_SETUP_FAILED      269
#define IDS_RUNDLL32_FAILED             270
#define IDS_NOTE_SUBJECT_EMPTY          271
#define IDS_COLUMN_RECIPIENT_NAME       272
#define IDS_COLUMN_RECIPIENT_NUMBER     273
#define IDS_FAX_SERVER                  274
#define IDS_SERVERCP_SUFFIX             275
#define IDS_USERCP_SUFFIX               276
#define IDS_NO_FAXSERVER                277
#define IDS_HOME                        278
#define IDS_BUSINESS                    279
#define IDS_ERROR_RECIPIENT_NAME        280
#define IDS_ERROR_FAX_NUMBER            281
#define IDS_ERROR_AREA_CODE             282
#define IDS_WIZ_RECIPIENT_TITLE         283
#define IDS_WIZ_RECIPIENT_SUB           284
//#define IDS_WIZ_COVERPAGE_TITLE         285
//#define IDS_WIZ_COVERPAGE_SUB           286
#define IDS_WIZ_SCAN_TITLE              287
#define IDS_WIZ_SCAN_SUB                288
#define IDS_WIZ_FAXOPTS_TITLE           289
#define IDS_WIZ_FAXOPTS_SUB             290
#define IDS_WIZ_FINISH_TITLE            291
#define IDS_WIZ_FINISH_SUB              292
#define IDS_WIZ_WELCOME_TITLE           293
#define IDS_WIZ_WELCOME_SUB             294
#define IDS_WIZ_TIME_FORMAT             295
#define IDS_LARGEFONT_NAME              296
#define IDS_LARGEFONT_SIZE              297
#define IDS_SEND_DISCOUNT               298
#define IDS_SEND_ASAP                   299




//
// Icon and bitmap resource IDs
//

#define IDI_FAX_OPTIONS                 1001
#define IDI_ARROW                       1002
#define IDB_FAXWIZ_BITMAP               1003
#define IDB_WATERMARK_16                1004
#define IDB_WATERMARK_256               1005
#define IDB_FAXWIZ_WATERMARK            1006
#define IDI_YELLOW                      1007

//
// Dialog resource IDs
//

#define IDD_DOCPROP                     100



#define IDC_STATIC                      -1


#define IDC_SEND_ASAP                   300
#define IDC_SEND_AT_CHEAP               301
#define IDC_SEND_AT_TIME                302
#define IDC_PAPER_SIZE                  303
#define IDC_IMAGE_QUALITY               304
#define IDC_PORTRAIT                    305
#define IDC_LANDSCAPE                   306
#define IDC_BILLING_CODE                307
#define IDC_RUN_FAXCFG                  308
#define IDC_EMAIL                       309

#define IDC_SENDTIME                    310

#define IDC_TITLE                       326
#define IDC_FAX_SEND_GRP                327
#define IDC_DEFAULT_PRINT_SETUP_GRP     328
#define IDC_ORIENTATION                 329


#define IDD_WIZARD_WELCOME              1000
#define IDD_WIZARD_CHOOSE_WHO           1001
#define IDD_WIZARD_CHOOSE_CP            1002
#define IDD_WIZARD_SCAN                 1003
#define IDD_WIZARD_FAXOPTS              1004
#define IDD_WIZARD_CONGRATS             1005
#define IDD_CHOOSE_FAXNUMBER            1006
#define IDD_WIZFIRSTTIME                1007
#define IDD_WIZFIRSTTIMEPRINT           1008

#define IDC_BITMAP_STATIC               1300

#define IDC_WIZ_WELCOME_BMP             1301
#define IDC_WIZ_WELCOME_TITLE           1302
#define IDC_WIZ_WELCOME_DESCR           1303
#define IDC_WIZ_WELCOME_FAXSEND         1304
#define IDC_WIZ_WELCOME_FAXSEND_CONT    1305
#define IDC_WIZ_WELCOME_NOFAXSEND       1306

#define IDC_CHOOSE_NAME_EDIT            1311
#define IDC_CHOOSE_ADDRBOOK             1312
#define IDC_CHOOSE_COUNTRY_COMBO        1313
#define IDC_CHOOSE_AREA_CODE_EDIT       1314
#define IDC_CHOOSE_NUMBER_EDIT          1315
//#define IDC_DIAL_AS_ENTERED             1316
#define IDC_CHOOSE_ADD                  1317
#define IDC_CHOOSE_REMOVE               1318
#define IDC_CHOOSE_RECIPIENT_LIST       1319
#define IDC_LOCATION_PROMPT             1320
#define IDC_LOCATION_LIST               1321
#define IDC_TAPI_PROPS                  1322
#define IDC_USE_DIALING_RULES           1323
#define IDC_STATIC_CHOOSE_COUNTRY_COMBO 1324

#define IDC_CHOOSE_CP_CHECK             1400
#define IDC_CHOOSE_CP_LIST              1401
#define IDC_STATIC_CHOOSE_CP_SUBJECT    1402
#define IDC_CHOOSE_CP_SUBJECT           1403
#define IDC_STATIC_CHOOSE_CP_NOTE       1404
#define IDC_CHOOSE_CP_NOTE              1405
#define IDC_STATIC_CHOOSE_CP_NOCHECK    1406
#define IDC_STATIC_CHOOSE_CP            1407

#define IDC_STATIC_WIZ_FAXOPTS_WHEN     1500
#define IDC_WIZ_FAXOPTS_ASAP            1501
#define IDC_WIZ_FAXOPTS_DISCOUNT        1502
#define IDC_WIZ_FAXOPTS_SPECIFIC        1503
#define IDC_WIZ_FAXOPTS_SENDTIME        1504
#define IDC_STATIC_WIZ_FAXOPTS_BILLING  1505
#define IDC_WIZ_FAXOPTS_BILLING         1506
#define IDC_STATIC_FAXOPTS_DATE         1507
#define IDC_WIZ_FAXOPTS_DATE            1508

#define IDC_SCAN_PAGE                   1601
#define IDC_PAGE_COUNT                  1602
#define IDC_DATA_SOURCE                 1603
#define IDC_STATIC_DATA_SOURCE          1604

#define IDC_DISPLAY_NAME                1700
#define IDC_BUSINESS_FAX                1701
#define IDC_HOME_FAX                    1702
#define IDC_ALLBUS                      1703
#define IDC_ALLHOME                     1704
#define IDC_ALWAYS_OPTION               1705

#define IDC_WIZ_CONGRATS_BMP            1800
#define IDC_STATIC_WIZ_CONGRATS_READY   1801
#define IDC_STATIC_WIZ_CONGRATS_FROM    1802
#define IDC_WIZ_CONGRATS_FROM           1803
#define IDC_STATIC_WIZ_CONGRATS_TO      1804
#define IDC_WIZ_CONGRATS_TO             1805
#define IDC_STATIC_WIZ_CONGRATS_TIME    1806
#define IDC_WIZ_CONGRATS_TIME           1807
#define IDC_STATIC_WIZ_CONGRATS_NUMBER  1808
#define IDC_WIZ_CONGRATS_NUMBER         1809
#define IDC_WIZ_CONGRATS_SUBJECT        1810
#define IDC_STATIC_WIZ_CONGRATS_SUBJECT 1811
#define IDC_STATIC_WIZ_CONGRATS_COVERPG 1812
#define IDC_WIZ_CONGRATS_COVERPG        1813
#define IDC_WIZ_CONGRATS_BILLING        1814
#define IDC_STATIC_WIZ_CONGRATS_BILLING 1815

#define IDC_EDIT_USERINFO_NOW           1900
#define IDC_KEEP_USERINFO_NOW           1901

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\devmode.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devmode.h

Abstract:

    DEVMODE related declarations and definitions

Environment:

        Fax driver, user and kernel mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _DEVMODE_H_
#define _DEVMODE_H_

//
// Driver version number and signatures
//

#define DRIVER_VERSION      0x400   // driver version number
#define DRIVER_SIGNATURE    'xafD'  // driver signature
#ifndef WIN95
#define DRIVER_NAME         L"Windows NT Fax Driver"
#else
#define DRIVER_NAME         "Microsoft Fax Client"

typedef struct _FAX_TIME {

    WORD    hour;                   // hour: 0 - 23
    WORD    minute;                 // minute: 0 - 59

} FAX_TIME, *PFAX_TIME;
#endif

//
// Maximum length of some strings in the private portion of devmode
//

#define MAX_BILLING_CODE        16
#define MAX_SENDER_NAME         64
#define MAX_RECIPIENT_NAME      64
#define MAX_RECIPIENT_NUMBER    64
#define MAX_SUBJECT_LINE        128
#define MAX_EMAIL_ADDRESS       128

//
// PostScript driver private devmode fields
//

typedef struct {

    DWORD       signature;          // private devmode signature
    DWORD       flags;              // flag bits
    INT         sendCoverPage;      // whether to send cover page
    INT         whenToSend;         // "Time to send" option
    FAX_TIME    sendAtTime;         // specific time to send
    DWORD       reserved[8];        // reserved

    //
    // Private fields used for passing info between kernel and user mode DLLs
    //  pointer to user mode memory
    //

    PVOID       pUserMem;

    //
    // Billing code
    //

    WCHAR       billingCode[MAX_BILLING_CODE];

    //
    // email address for delivery reports
    //

    WCHAR       emailAddress[MAX_EMAIL_ADDRESS];

} DMPRIVATE, *PDMPRIVATE;

typedef struct {

    DEVMODE     dmPublic;           // public devmode fields
    DMPRIVATE   dmPrivate;          // private devmode fields

} DRVDEVMODE, *PDRVDEVMODE;

//
// Check if a devmode structure is current version
//

#define CurrentVersionDevmode(pDevmode) \
        ((pDevmode) != NULL && \
         (pDevmode)->dmSpecVersion == DM_SPECVERSION && \
         (pDevmode)->dmDriverVersion == DRIVER_VERSION && \
         (pDevmode)->dmSize == sizeof(DEVMODE) && \
         (pDevmode)->dmDriverExtra == sizeof(DMPRIVATE))

//
// Constants representing different "Time to send" option
//

#define SENDFAX_ASAP        0       // send as soon as possible
#define SENDFAX_AT_CHEAP    1       // send during discount rate hours
#define SENDFAX_AT_TIME     2       // send at specific time

//
// Constant flag bits for DMPRIVATE.flags field
//

#define FAXDM_NO_HALFTONE    0x0001 // don't halftone bitmap images
#define FAXDM_1D_ENCODING    0x0002 // use group3 1D encoding
#define FAXDM_NO_WIZARD      0x0004 // bypass wizard
#define FAXDM_DRIVER_DEFAULT 0x0008 // driver default devmode

//
// Default form names and form sizes
//

#define FORMNAME_LETTER     TEXT("Letter")
#define FORMNAME_A4         TEXT("A4")

#define LETTER_WIDTH        215900  // 8.5" in microns
#define LETTER_HEIGHT       279400  // 11" in microns
#define A4_WIDTH            210000  // 210mm in microns
#define A4_HEIGHT           297000  // 297mm in microns

//
// Default resolutions for fax output
//

#define FAXRES_HORIZONTAL   200
#define FAXRES_VERTICAL     200
#define FAXRES_VERTDRAFT    100

//
// Maximum allowable bitmap size (in pixels) for fax output
//

#define MAX_WIDTH_PIXELS    1728
#define MAX_HEIGHT_PIXELS   2800

//
// Retrieve driver default devmode
//

VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    );

//
// Merge the source devmode into the destination devmode
//

BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    );

//
// NOTE: These are defined in printers\lib directory. Declare them here to
// avoid including libproto.h and dragging in lots of other junk.
//

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifdef KERNEL_MODE

extern DEVHTINFO DefDevHTInfo;
extern COLORADJUSTMENT DefHTClrAdj;

#endif

#endif // !_DEVMODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\wizard.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Send fax wizard dialogs

Environment:

    Fax driver user interface

Revision History:

    01/19/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "tapiutil.h"
#include "prtcovpg.h"
#include "tiff.h"
#include "cwabutil.h"
#include  <shellapi.h>

#include  <imm.h>

#ifdef FAX_SCAN_ENABLED

#define TWRESMIN            0
#define TWRESMAX            1
#define TWRESSCAL           2
#define TWRESCUR            3
#define TWRESDEFAULT        4
#define TWRESCLOSEST        5

#define AUTOSCANPREV        0
#define AUTOSCANFINAL       1
#define CUSTOMSCAN          2
#define CANCELLED           3
#define FINALCANCELLED      4
#define AUTOSCANSHEETFED    5
#define CUSTOMDIGITALCAMERA 6
#define DCCANCELLED         7

#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

#define WM_PAGE_COMPLETE        (WM_USER+1000)

#define NUM_IFD_ENTRIES         18

#define IFD_SUBFILETYPE         0                // 254
#define IFD_IMAGEWIDTH          1                // 256
#define IFD_IMAGELENGTH         2                // 257
#define IFD_BITSPERSAMPLE       3                // 258
#define IFD_COMPRESSION         4                // 259
#define IFD_PHOTOMETRIC         5                // 262
#define IFD_FILLORDER           6                // 266
#define IFD_STRIPOFFSETS        7                // 273
#define IFD_SAMPLESPERPIXEL     8                // 277
#define IFD_ROWSPERSTRIP        9                // 278
#define IFD_STRIPBYTECOUNTS     10               // 279
#define IFD_XRESOLUTION         11               // 281
#define IFD_YRESOLUTION         12               // 282
#define IFD_GROUP3OPTIONS       13               // 292
#define IFD_RESOLUTIONUNIT      14               // 296
#define IFD_PAGENUMBER          15               // 297
#define IFD_SOFTWARE            16               // 305
#define IFD_CLEANFAXDATA        17               // 327


typedef struct {
    WORD        wIFDEntries;
    TIFF_TAG    ifd[NUM_IFD_ENTRIES];
    DWORD       nextIFDOffset;
    DWORD       filler;
    DWORD       xresNum;
    DWORD       xresDenom;
    DWORD       yresNum;
    DWORD       yresDenom;
    CHAR        software[32];
} FAXIFD, *PFAXIFD;


#define SoftwareStr             "Windows NT Fax Driver"
#define DRIVER_SIGNATURE        'xafD'

FAXIFD FaxIFDTemplate = {

    NUM_IFD_ENTRIES,

    {
        { TIFFTAG_SUBFILETYPE,     TIFF_LONG,     1,                     0                       },
        { TIFFTAG_IMAGEWIDTH,      TIFF_LONG,     1,                     0                       },
        { TIFFTAG_IMAGELENGTH,     TIFF_LONG,     1,                     0                       },
        { TIFFTAG_BITSPERSAMPLE,   TIFF_SHORT,    1,                     1                       },
        { TIFFTAG_COMPRESSION,     TIFF_SHORT,    1,                     COMPRESSION_NONE        },
        { TIFFTAG_PHOTOMETRIC,     TIFF_SHORT,    1,                     PHOTOMETRIC_MINISWHITE  },
        { TIFFTAG_FILLORDER,       TIFF_SHORT,    1,                     FILLORDER_MSB2LSB       },
        { TIFFTAG_STRIPOFFSETS,    TIFF_LONG,     1,                     0                       },
        { TIFFTAG_SAMPLESPERPIXEL, TIFF_SHORT,    1,                     1                       },
        { TIFFTAG_ROWSPERSTRIP,    TIFF_LONG,     1,                     0                       },
        { TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG,     1,                     0                       },
        { TIFFTAG_XRESOLUTION,     TIFF_RATIONAL, 1,                     0                       },
        { TIFFTAG_YRESOLUTION,     TIFF_RATIONAL, 1,                     0                       },
        { TIFFTAG_GROUP3OPTIONS,   TIFF_LONG,     1,                     0                       },
        { TIFFTAG_RESOLUTIONUNIT,  TIFF_SHORT,    1,                     RESUNIT_INCH            },
        { TIFFTAG_PAGENUMBER,      TIFF_SHORT,    2,                     0                       },
        { TIFFTAG_SOFTWARE,        TIFF_ASCII,    sizeof(SoftwareStr)+1, 0                       },
        { TIFFTAG_CLEANFAXDATA,    TIFF_SHORT,    1,                     0                       },
    },

    0,
    DRIVER_SIGNATURE,
    0,
    1,
    0,
    1,
    SoftwareStr
};

#endif



VOID
FillInPropertyPage(
    PROPSHEETPAGE  *psp,
    INT             dlgId,
    DLGPROC         dlgProc,
    PUSERMEM        pUserMem,
    INT             TitleId,
    INT             SubTitleId
    )

/*++

Routine Description:

    Fill out a PROPSHEETPAGE structure with the supplied parameters

Arguments:

    psp - Points to the PROPSHEETPAGE structure to be filled out
    dlgId - Dialog template resource ID
    dlgProc - Dialog procedure
    pUserMem - Pointer to the user mode memory structure
    TitleId - resource id for wizard subtitle
    SubTitleId - resource id for wizard subtitle

Return Value:

    NONE

--*/

{
    LPTSTR WizardTitle;
    LPTSTR WizardSubTitle;

    
    psp->dwSize = sizeof(PROPSHEETPAGE);
    //
    // Don't show titles if it's the first or last page
    //
    if (TitleId==0 && SubTitleId ==0) {
        psp->dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;;
    } else {
        psp->dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    }
    psp->hInstance = ghInstance;
    psp->pszTemplate = MAKEINTRESOURCE(dlgId);
    psp->pfnDlgProc = dlgProc;
    psp->lParam = (LPARAM) pUserMem;

    WizardTitle    = MemAlloc(200* sizeof(TCHAR) );
    WizardSubTitle = MemAlloc(200* sizeof(TCHAR) );
    LoadString(ghInstance,TitleId,WizardTitle,200);
    LoadString(ghInstance,SubTitleId,WizardSubTitle,200);

    psp->pszHeaderTitle = WizardTitle;
    psp->pszHeaderSubTitle = WizardSubTitle;
}



LPTSTR
GetTextStringValue(
    HWND    hwnd
    )

/*++

Routine Description:

    Retrieve the string value in a text field

Arguments:

    hwnd - Handle to a text window

Return Value:

    Pointer to a string representing the current content of the text field
    NULL if the text field is empty or if there is an error

--*/

{
    INT     length;
    LPTSTR  pString;

    //
    // Find out how many characters are in the text field
    // and allocate enough memory to hold the string value
    //

    if ((length = GetWindowTextLength(hwnd)) == 0 ||
        (pString = MemAlloc(sizeof(TCHAR) * (length + 1))) == NULL)
    {
        return NULL;
    }

    //
    // Actually retrieve the string value
    //

    if (GetWindowText(hwnd, pString, length + 1) == 0) {

        MemFree(pString);
        return NULL;
    }

    return pString;
}



VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}



VOID
SaveLastRecipientInfo(
    LPTSTR  pName,
    LPTSTR  pAreaCode,
    LPTSTR  pPhoneNumber,
    DWORD   countryId,
    BOOL    useDialingRules
    )

/*++

Routine Description:

    Save the information about the last recipient in the registry

Arguments:

    pName - Specifies the recipient name
    pAreaCode - Specifies the recipient area code
    pPhoneNumber - Specifies the recipient phone number
    countryId - Specifies the recipient country ID
    useDialingRules - Whether use dialing rules is checked

Return Value:

    NONE

--*/

{
    HKEY    hRegKey;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)) {

        SetRegistryString(hRegKey, REGVAL_LAST_RECNAME, pName);
        SetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, pPhoneNumber);
        SetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES, useDialingRules);

        if (useDialingRules) {
            SetRegistryString(hRegKey, REGVAL_LAST_RECAREACODE, pAreaCode);
            SetRegistryDword(hRegKey, REGVAL_LAST_COUNTRYID, countryId);
        }
        RegCloseKey(hRegKey);
    }
}



VOID
RestoreLastRecipientInfo(
    HWND    hDlg,
    PDWORD  pCountryId
    )

/*++

Routine Description:

    Restore the information about the last recipient from the registry

Arguments:

    hDlg - Specifies a handle to the fax recipient wizard page
    pCountryId - Returns the last selected country ID

Return Value:

    NONE

--*/

{
    HKEY    hRegKey;
    LPTSTR  buffer;
    //TCHAR   buffer[MAX_STRING_LEN];

    *pCountryId = GetDefaultCountryID();

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) {

        buffer = GetRegistryString(hRegKey, REGVAL_LAST_RECNAME, TEXT(""));
        if (buffer) {
            SetDlgItemText(hDlg, IDC_CHOOSE_NAME_EDIT, buffer);
            MemFree(buffer);
        }

        buffer = GetRegistryString(hRegKey, REGVAL_LAST_RECAREACODE, TEXT(""));
        if (buffer) {
            SetDlgItemText(hDlg, IDC_CHOOSE_AREA_CODE_EDIT, buffer);
            MemFree(buffer);
        }

        buffer = GetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, TEXT(""));
        if (buffer) {
            SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, buffer);
            MemFree(buffer);
        }

        CheckDlgButton(hDlg,
                       IDC_USE_DIALING_RULES,
                       GetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES));

        *pCountryId = GetRegistryDword(hRegKey, REGVAL_LAST_COUNTRYID);

        RegCloseKey(hRegKey);
    }
}



PUSERMEM
CommonWizardProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    DWORD   buttonFlags
    )

/*++

Routine Description:

    Common procedure for handling wizard pages:

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information
    buttonFlags - Indicate which buttons should be enabled

Return Value:

    NULL - Message is processed and the dialog procedure should return FALSE
    Otherwise - Message is not completely processed and
        The return value is a pointer to the user mode memory structure

--*/

{
    PUSERMEM    pUserMem;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Store the pointer to user mode memory structure
        //

        lParam = ((PROPSHEETPAGE *) lParam)->lParam;
        pUserMem = (PUSERMEM) lParam;
        Assert(ValidPDEVUserMem(pUserMem));
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        break;

    case WM_NOTIFY:

        pUserMem = (PUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
        Assert(ValidPDEVUserMem(pUserMem));

        switch (((NMHDR *) lParam)->code) {

        case PSN_WIZFINISH:

            pUserMem->finishPressed = TRUE;
            break;

        case PSN_SETACTIVE:

            PropSheet_SetWizButtons(GetParent(hDlg), buttonFlags);
            break;

        case PSN_RESET:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_KILLACTIVE:
        case LVN_KEYDOWN:

            break;

        default:

            return NULL;
        }

        break;

    case WM_COMMAND:

        pUserMem = (PUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
        Assert(ValidPDEVUserMem(pUserMem));
        break;

    default:

        return NULL;
    }

    return pUserMem;
}



/*
 *  IsStringACSII
 *
 *  Purpose: 
 *          This function determines whether a string contains ONLY ASCII characters.
 *
 *  Arguments:
 *          ptszString - points to the string to test.
 *
 *  Returns:
 *          TRUE - indicates that the string contains only ASCII characters.
 *
 */

BOOL IsStringASCII( LPTSTR ptszString )
{
   BOOL     fReturnValue = (BOOL) TRUE;

   // Determine whether the contents of the edit control are legal.

   while ( (*ptszString != (TCHAR) TEXT('\0')) &&
           ( fReturnValue == (BOOL) TRUE) )
   {
      if ( (*ptszString < (TCHAR) 0x0020) || (*ptszString > (TCHAR) MAXCHAR) )
      {
         // The string contains at least one non-ASCII character.

         fReturnValue = (BOOL) FALSE;
      }

      ptszString = _tcsinc( ptszString );
   }   // end of while loop

   return ( fReturnValue );
}



INT
GetCurrentRecipient(
    HWND        hDlg,
    PRECIPIENT *ppRecipient
    )

/*++

Routine Description:

    Extract the current recipient information in the dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    ppRecipient - Buffer to receive a pointer to a newly created RECIPIENT structure
        NULL if caller is only interested in the validity of recipient info

Return Value:

    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    LPLINECOUNTRYENTRY  pLineCountryEntry;
    DWORD               countryId, countryCode;
    PRECIPIENT          pRecipient;
    TCHAR               areaCode[MAX_RECIPIENT_NUMBER];
    TCHAR               phoneNumber[MAX_RECIPIENT_NUMBER];
    INT                 nameLen, areaCodeLen, numberLen;
    LPTSTR              pName, pAddress;
    INT                 useDialingRules;

    //
    // Default value in case of error
    //

    if (ppRecipient)
        *ppRecipient = NULL;

    //
    // Find the current country code
    //

    countryCode = 0;
    pLineCountryEntry = NULL;
    countryId = GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO));
    useDialingRules = IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULES);

    if ((useDialingRules == BST_CHECKED) &&
        (pLineCountryEntry = FindCountry(countryId)))
    {
        countryCode = pLineCountryEntry->dwCountryCode;
    }

    nameLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));
    areaCodeLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT));
    numberLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT));

    //
    // Validate the edit text fields
    //

    if (nameLen <= 0)
        return IDS_BAD_RECIPIENT_NAME;

    if (numberLen <= 0 || numberLen >= MAX_RECIPIENT_NUMBER)
        return IDS_BAD_RECIPIENT_NUMBER;

    if ((areaCodeLen <= 0 && AreaCodeRules(pLineCountryEntry) == AREACODE_REQUIRED) ||
        (areaCodeLen >= MAX_RECIPIENT_NUMBER))
    {
        return IDS_BAD_RECIPIENT_AREACODE;
    }

    if (ppRecipient == NULL)
        return 0;

    //
    // Calculate the amount of memory space we need and allocate it
    //

    pRecipient = MemAllocZ(sizeof(RECIPIENT));
    pName = MemAllocZ((nameLen + 1) * sizeof(TCHAR));
    pAddress = MemAllocZ((areaCodeLen + numberLen + 20) * sizeof(TCHAR));

    if (!pRecipient || !pName || !pAddress) {

        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return -1;
    }

    *ppRecipient = pRecipient;
    pRecipient->pName = pName;
    pRecipient->pAddress = pAddress;

    //
    // Get the recipient's name
    //

    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT), pName, nameLen+1);

    //
    // Get the recipient's number
    //  AddressType
    //  [+ CountryCode Space]
    //  [( AreaCode ) Space]
    //  SubscriberNumber
    //

    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), areaCode, MAX_RECIPIENT_NUMBER);

    if ( IsStringASCII( areaCode ) == (BOOL) FALSE )
    {
       return ( (INT) IDS_ERROR_AREA_CODE );
    }
    
    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT), phoneNumber, MAX_RECIPIENT_NUMBER);

    if ( IsStringASCII( phoneNumber ) == (BOOL) FALSE )
    {
       return ( (INT) IDS_ERROR_FAX_NUMBER );
    }

    AssemblePhoneNumber(pAddress,
                        countryCode,
                        areaCode,
                        phoneNumber);

    //
    // Save the information about the last recipient as a convenience
    //

    SaveLastRecipientInfo(pName,
                          areaCode,
                          phoneNumber,
                          countryId,
                          useDialingRules == BST_CHECKED);

    return 0;
}



VOID
InitRecipientListView(
    HWND    hwndLV
    )

/*++

Routine Description:

    Initialize the recipient list view on the first page of Send Fax wizard

Arguments:

    hwndLV - Window handle to the list view control

Return Value:

    NONE

--*/

{
    LV_COLUMN   lvc;
    RECT        rect;
    TCHAR       buffer[MAX_TITLE_LEN];

    if (hwndLV == NULL)
        return;

    GetClientRect(hwndLV, &rect);

    ZeroMemory(&lvc, sizeof(lvc));

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = buffer;
    lvc.cx = (rect.right - rect.left) / 2;

    lvc.iSubItem = 0;
    LoadString(ghInstance, IDS_COLUMN_RECIPIENT_NAME, buffer, MAX_TITLE_LEN);

    if (ListView_InsertColumn(hwndLV, 0, &lvc) == -1)
        Error(("ListView_InsertColumn failed\n"));

    lvc.cx -= GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 1;
    LoadString(ghInstance, IDS_COLUMN_RECIPIENT_NUMBER, buffer, MAX_TITLE_LEN);

    if (ListView_InsertColumn(hwndLV, 1, &lvc) == -1)
        Error(("ListView_InsertColumn failed\n"));
}



BOOL
InsertRecipientListItem(
    HWND        hwndLV,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Insert an item into the recipient list view

Arguments:

    hwndLV - Window handle to the recipient list view
    pRecipient - Specifies the recipient to be inserted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LV_ITEM lvi;
    INT     index;

    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.lParam = (LPARAM) pRecipient;
    lvi.pszText = pRecipient->pName;
    lvi.state = lvi.stateMask = LVIS_SELECTED;

    if ((index = ListView_InsertItem(hwndLV, &lvi)) == -1) {

        Error(("ListView_InsertItem failed\n"));
        return FALSE;
    }

    lvi.mask = LVIF_TEXT;
    lvi.iItem = index;
    lvi.iSubItem = 1;
    lvi.pszText = pRecipient->pAddress;

    if (! ListView_SetItem(hwndLV, &lvi))
        Error(("ListView_SetItem failed\n"));

    return TRUE;
}



PRECIPIENT
GetRecipientListItem(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Retrieve the recipient associated with an item in the list view

Arguments:

    hwndLV - Window handle to the recipient list view
    index - Specifies the index of the interested item

Return Value:

    Pointer to the requested recipient information
    NULL if there is an error

--*/

{
    LV_ITEM lvi;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;
    lvi.iItem = index;

    if (ListView_GetItem(hwndLV, &lvi))
        return (PRECIPIENT) lvi.lParam;

    Error(("ListView_GetItem failed\n"));
    return NULL;
}



INT
AddRecipient(
    HWND        hDlg,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Add the current recipient information entered by the user
    into the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pUserMem - Points to user mode memory structure

Return Value:

    Same meaning as return value from GetCurrentRecipient, i.e.
    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    PRECIPIENT  pRecipient;
    INT         errId;
    HWND        hwndLV;

    //
    // Collect information about the current recipient
    //

    if ((errId = GetCurrentRecipient(hDlg, &pRecipient)) != 0)
        return errId;

    //
    // Insert the current recipient to the recipient list
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)) &&
        InsertRecipientListItem(hwndLV, pRecipient))
    {
        errId = 0;
        pRecipient->pNext = pUserMem->pRecipients;
        pUserMem->pRecipients = pRecipient;

        //
        // Clear the name and number fields after successfully
        // adding the recipient to the internal list
        //

        SetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT), TEXT(""));
        SetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), TEXT(""));
        SetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT), TEXT(""));

        //CheckDlgButton(hDlg, IDC_USE_DIALING_RULES, FALSE);

    } else {

        FreeRecipient(pRecipient);
        errId = -1;
    }

    return errId;
}



BOOL
DoAddressBook(
    HWND        hDlg,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Display the MAPI address book dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HWND            hwndLV;
    BOOL            result;
    PRECIPIENT      pNewRecip = NULL;
    PRECIPIENT      tmpRecip;

    if (! pUserMem->lpWabInit && 
        ! (pUserMem->lpWabInit = InitializeWAB(ghInstance))) 
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADDRBOOK), FALSE);
        return FALSE;
    }

    //
    // Get a handle to the recipient list window
    //

    if (! (hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
        return FALSE;

    //
    // Add current recipient to the list if necessary
    //

    AddRecipient(hDlg, pUserMem);

    result = CallWabAddress(
                hDlg,
                pUserMem,
                &pNewRecip
                );
                
    FreeRecipientList(pUserMem);
    
    pUserMem->pRecipients = pNewRecip;

    ListView_DeleteAllItems(hwndLV);

    for (tmpRecip = pNewRecip; tmpRecip; tmpRecip = tmpRecip->pNext) {
        InsertRecipientListItem(hwndLV, tmpRecip);
    }

    if (!result) {
        DisplayMessageDialog( hDlg, MB_OK, 0, IDS_BAD_ADDRESS_TYPE );
    }
    
    return result;
}



BOOL
ValidateRecipients(
    HWND        hDlg,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Validate the list of fax recipients entered by the user

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT errId;

    //
    // Add current recipient to the list if necessary
    //

    errId = AddRecipient(hDlg, pUserMem);

    //
    // There must be at least one recipient
    //

    if (pUserMem->pRecipients)
        return TRUE;

    //
    // Display an error message
    //

    if (errId > 0)
        DisplayMessageDialog(hDlg, 0, 0, errId);
    else
        MessageBeep(MB_OK);

    //
    // Set current focus to the appropriate text field as a convenience
    //

    switch (errId) {

    case IDS_ERROR_FAX_NUMBER:
        SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, L"");
    case IDS_BAD_RECIPIENT_NUMBER:    

        errId = IDC_CHOOSE_NUMBER_EDIT;
        break;

    case IDS_ERROR_AREA_CODE:
        SetDlgItemText(hDlg, IDC_CHOOSE_AREA_CODE_EDIT, L"");
    case IDS_BAD_RECIPIENT_AREACODE:

        errId = IDC_CHOOSE_AREA_CODE_EDIT;
        break;

    case IDS_BAD_RECIPIENT_NAME:
    default:

        errId = IDC_CHOOSE_NAME_EDIT;
        break;
    }

    SetFocus(GetDlgItem(hDlg, errId));
    return FALSE;
}



PRECIPIENT *
FindRecipient(
    PUSERMEM    pUserMem,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Check if the specified recipient is in the list of recipients

Arguments:

    pUserMem - Points to user mode memory structure
    pRecipient - Specifies the recipient to be found

Return Value:

    Address of the link pointer to the specified recipient
    NULL if the specified recipient is not found

--*/

{
    PRECIPIENT  pCurrent, *ppPrevNext;

    //
    // Search for the specified recipient in the list
    //

    ppPrevNext = (PRECIPIENT *) &pUserMem->pRecipients;
    pCurrent = pUserMem->pRecipients;

    while (pCurrent && pCurrent != pRecipient) {

        ppPrevNext = (PRECIPIENT *) &pCurrent->pNext;
        pCurrent = pCurrent->pNext;
    }

    //
    // Return the address of the link pointer to the specified recipient
    // or NULL if the specified recipient is not found
    //

    return pCurrent ? ppPrevNext : NULL;
}



BOOL
RemoveRecipient(
    HWND        hDlg,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Remove the currently selected recipient from the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PRECIPIENT  pRecipient, *ppPrevNext;
    INT         selIndex;
    HWND        hwndLV;

    //
    // Get the currently selected recipient, and
    // Find the current recipient in the list, then
    // Delete the current recipient and select the next one below it
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)) &&
        (selIndex = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) != -1 &&
        (pRecipient = GetRecipientListItem(hwndLV, selIndex)) &&
        (ppPrevNext = FindRecipient(pUserMem, pRecipient)) &&
        ListView_DeleteItem(hwndLV, selIndex))
    {
        ListView_SetItemState(hwndLV,
                              selIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED);

        //
        // Delete the recipient from the internal list
        //

        *ppPrevNext = pRecipient->pNext;
        FreeRecipient(pRecipient);

        return TRUE;
    }

    MessageBeep(MB_ICONHAND);
    return FALSE;
}



VOID
LocationListInit(
    HWND        hDlg,
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Initialize the list of TAPI locations

Arguments:

    hDlg - Handle to "Compose New Fax" wizard window
    pUserMem - Pointer to user mode memory structure

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    DWORD   index;
    LRESULT listIdx;
    LPTSTR  pLocationName, pSelectedName = NULL;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;
    LPLINELOCATIONENTRY pLocationEntry;

    //
    // For remote printers, hide the location combo-box
    //

    if (! pUserMem->isLocalPrinter) {

        ShowWindow(GetDlgItem(hDlg, IDC_LOCATION_PROMPT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOCATION_LIST), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_TAPI_PROPS), SW_HIDE);
        return;
    }

    //
    // Get the list of locations from TAPI and use it
    // to initialize the location combo-box.
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_LOCATION_LIST)) &&
        (pTranslateCaps = GetTapiLocationInfo(hDlg)))
    {
        SendMessage(hwndList, CB_RESETCONTENT, 0, 0);

        pLocationEntry = (LPLINELOCATIONENTRY)
            ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);

        for (index=0; index < pTranslateCaps->dwNumLocations; index++) {

            pLocationName = (LPTSTR)
                ((PBYTE) pTranslateCaps + pLocationEntry->dwLocationNameOffset);

            if (pLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID)
                pSelectedName = pLocationName;

            listIdx = SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) pLocationName);

            if (listIdx != CB_ERR) {

                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            listIdx,
                            pLocationEntry->dwPermanentLocationID);
            }

            pLocationEntry++;
        }

        if (pSelectedName != NULL)
            SendMessage(hwndList, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) pSelectedName);
    }

    MemFree(pTranslateCaps);
}



VOID
LocationListSelChange(
    HWND    hDlg
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    hDlg - Handle to "Compose New Fax" wizard window

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    LRESULT selIndex;
    DWORD locationID;

    if ((hwndList = GetDlgItem(hDlg, IDC_LOCATION_LIST)) &&
        (selIndex = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR &&
        (locationID = (DWORD)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0)) != CB_ERR)
    {
        SetCurrentLocation(locationID);
    }
}



VOID
UpdateCountryCombobox(
    HWND    hDlg,
    DWORD   countryId
    )

/*++

Routine Description:

    Update the country/region combobox

Arguments:

    hDlg - Handle to recipient wizard page
    countryId -  country id

Return Value:

    NONE

--*/

{
    HWND hwndUseDialingRultes = GetDlgItem(hDlg, IDC_USE_DIALING_RULES);
    HWND hwndDialingLocation = GetDlgItem(hDlg, IDC_LOCATION_LIST);
    HWND hwndDialingLocationStatic = GetDlgItem(hDlg, IDC_LOCATION_PROMPT);
    HWND hwndLocation = GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO);
    HWND hwndLocationStatic = GetDlgItem(hDlg, IDC_STATIC_CHOOSE_COUNTRY_COMBO);
    HWND hwndProp = GetDlgItem(hDlg, IDC_TAPI_PROPS);
    static int OldCountryCode = 0;

    if (IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULES) != BST_CHECKED) {
        //
        // user unchecked use dialing rules
        // remember the old country code and area code and clear out the UI
        //
        OldCountryCode = GetCountryListBoxSel(hwndLocation);
        if (OldCountryCode == -1) {
            OldCountryCode = countryId != -1 ? countryId : 0;
        }
        SendMessage(hwndLocation, CB_RESETCONTENT, FALSE, 0);
        EnableWindow(hwndLocation, FALSE);
        EnableWindow(hwndLocationStatic, FALSE);
        EnableWindow(hwndDialingLocation, FALSE);
        EnableWindow(hwndDialingLocationStatic, FALSE);
        EnableWindow(hwndProp, FALSE);
    }
    else {
        //
        // user checked use dialing rules
        // enable country combo, restore settings
        //
        EnableWindow(hwndLocation, TRUE);
        EnableWindow(hwndLocationStatic, TRUE);
        InitCountryListBox(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                           GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                           countryId != -1 ? countryId : OldCountryCode);
        EnableWindow(hwndDialingLocation, TRUE);
        EnableWindow(hwndDialingLocationStatic, TRUE);
        EnableWindow(hwndProp, TRUE);
    }    

    SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                            GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT));
}

INT_PTR
CALLBACK
firstdlgproc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(iMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, IDC_EDIT_USERINFO_NOW, TRUE);
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD( wParam )) {
                case IDOK:
                    if (IsDlgButtonChecked(hDlg, IDC_EDIT_USERINFO_NOW) == BST_CHECKED) {
                        EndDialog( hDlg, IDYES );
                    }
                    else {
                        EndDialog( hDlg, IDNO );
                    }
                    return TRUE;
            }
            break;
    }

    return FALSE;
}

INT_PTR
CALLBACK
firstprintdlgproc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(iMsg) {
        
        case WM_COMMAND:
            EndDialog( hDlg, LOWORD( wParam ));
            break;
    }

    return FALSE;
}


BOOL
DoFirstTimeInitStuff(
    HWND hDlg,
    BOOL bWelcomePage
    )
{
   BOOL bInitialized = TRUE;
   HKEY hRegKey;
 //  TCHAR MessageBuffer[1024],TitleBuffer[100];
   SHELLEXECUTEINFO shellExeInfo = {
        sizeof(SHELLEXECUTEINFO),
        SEE_MASK_NOCLOSEPROCESS,
        hDlg,
        L"Open",
        L"rundll32",
        L"shell32.dll,Control_RunDLL fax.cpl",
        NULL,
        SW_SHOWNORMAL,
    };

    TCHAR ScratchCmdLine[MAX_PATH];
    PCTSTR PrinterCmdLine = TEXT("rundll32.exe printui.dll,PrintUIEntry /il"); 
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
   
   //
   // print or fax first time?
   //
   if (bWelcomePage && !GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0)) {
       DWORD PrinterCount = 1;
       PRINTER_INFO_4 *pPrinterInfo4;

       if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) {

           bInitialized = GetRegistryDword(hRegKey, REGVAL_PRINTER_INITIALIZED);
           RegCloseKey(hRegKey);

       }

       if (bInitialized) {
           return TRUE;      
       }


       //
       // if there is more than one printer don't confuse the user by asking
       // to add a printer since one is already installed.
       //
       pPrinterInfo4 = MyEnumPrinters(
                        NULL, 
                        4,
                        &PrinterCount,
                        PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);
           
       if (pPrinterInfo4) {
           MemFree(pPrinterInfo4);
           if (PrinterCount > 1) {
               if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)) {

                   SetRegistryDword(hRegKey, REGVAL_PRINTER_INITIALIZED , 1);
                   RegCloseKey(hRegKey);

               }

               return(TRUE);
           }
       }
       
   
       if (DialogBoxParam(ghInstance,
                     MAKEINTRESOURCE( IDD_WIZFIRSTTIMEPRINT ),
                     hDlg,
                     firstprintdlgproc,
                     (LPARAM)NULL) != IDOK) {
           //
           // if they said "print", then launch the add/remove printer wizard
           //
           ZeroMemory(&si,sizeof(si));
           GetStartupInfo(&si);
           lstrcpy(ScratchCmdLine,PrinterCmdLine);
           if (CreateProcess(
                        NULL,
                        ScratchCmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        )) {
               CloseHandle( pi.hThread );
               CloseHandle( pi.hProcess );
           }
           
           return(FALSE);
       } else {
           if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)) {

               SetRegistryDword(hRegKey, REGVAL_PRINTER_INITIALIZED , 1);
               RegCloseKey(hRegKey);

           }

           return(TRUE);
       }

   } else if (!bWelcomePage) {
   
       if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) {

           bInitialized = GetRegistryDword(hRegKey, REGVAL_WIZARD_INITIALIZED);
           RegCloseKey(hRegKey);

       }

       if (bInitialized) {
           return TRUE;      
       }


       //
       // show the user a dialog
       //
       if (DialogBoxParam(ghInstance,
                          MAKEINTRESOURCE( IDD_WIZFIRSTTIME ),
                          hDlg,
                          firstdlgproc,
                          (LPARAM)NULL) == IDYES) {
           //
           // if they said yes, then launch the control panel applet
           //
           if (!ShellExecuteEx(&shellExeInfo)) {
              DisplayMessageDialog(hDlg, 0, 0, IDS_ERR_CPL_LAUNCH);
              return FALSE;
           }
    
           WaitForSingleObject( shellExeInfo.hProcess, INFINITE );
           CloseHandle( shellExeInfo.hProcess ) ;
    
       }
           
       //
       // set the reg key so this doesn't come up again
       //
       if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)) {
    
           SetRegistryDword(hRegKey, REGVAL_WIZARD_INITIALIZED , 1 );
           RegCloseKey(hRegKey);
    
       }

   }
   
   return(TRUE);

}

INT_PTR
RecipientWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page: selecting the fax recipient

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

#define UpdateAddToListButton() \
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADD), GetCurrentRecipient(hDlg, NULL) == 0)

#define UpdateRemoveFromListButton(__BoolFlag) \
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE),__BoolFlag)

{
    PUSERMEM    pUserMem;
    DWORD       countryId;
    INT         cmd;
    NMHDR      *pNMHdr;
    
    DWORD  dwErrorCode;

    HANDLE hEditControl;

    TCHAR  tszBuffer[MAX_STRING_LEN];

    //
    // Maximum length for various text fields
    //

    static INT  textLimits[] = {

        IDC_CHOOSE_NAME_EDIT,       64,
        IDC_CHOOSE_AREA_CODE_EDIT,  11,
        IDC_CHOOSE_NUMBER_EDIT,     51,
        0
    };

    //
    // Handle common messages shared by all wizard pages
    //

    if (! (pUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT)))
        return FALSE;

    switch (message) {

    case WM_INITDIALOG:

        //
        // check if the user has run the wizard before so they can fill in the coverpage info.
        //
        DoFirstTimeInitStuff(hDlg, FALSE);                

        //
        // tapi is asynchronously initialized, wait for it to finish spinning up.
        //
        WaitForSingleObject( pUserMem->hTapiEvent, INFINITE );

        //
        // Restore the last recipient information as a convenience
        //        

        RestoreLastRecipientInfo(hDlg, &countryId);

        //
        // Initialize the list of countries
        //

        UpdateCountryCombobox(hDlg, countryId);

        //
        // Check if MAPI is installed - we need it for address book features
        //

//        if (! IsMapiAvailable())
//            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADDRBOOK), FALSE);

        LimitTextFields(hDlg, textLimits);

        //
        // Initialize the recipient list view
        //

        InitRecipientListView(GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST));

        //
        // Initialize the location combo-box
        //

        LocationListInit(hDlg, pUserMem);

        // Disable the IME for the area code edit control.
    
        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_AREA_CODE_EDIT );
    
        if ( hEditControl != (HWND) INVALID_HANDLE_VALUE )
        {
           ImmAssociateContext( hEditControl, (HIMC) NULL );
        }

        // Disable the IME for the fax phone number edit control.
    
        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_NUMBER_EDIT );
    
        if ( hEditControl != (HWND) INVALID_HANDLE_VALUE )
        {
           ImmAssociateContext( hEditControl, (HIMC) NULL );
        }

        break;

    case WM_NOTIFY:

        pNMHdr = (NMHDR *) lParam;

        switch (pNMHdr->code) {

        case LVN_KEYDOWN:

            if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST) &&
                ((LV_KEYDOWN *) pNMHdr)->wVKey == VK_DELETE)
            {
                RemoveRecipient(hDlg, pUserMem);                
            }
            break;

        case PSN_WIZNEXT:

            if (! ValidateRecipients(hDlg, pUserMem)) {

                //
                // Validate the list of recipients and prevent the user
                // from advancing to the next page if there is a problem
                //

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }
            break;

        case PSN_SETACTIVE:
            //
            // make sure the remove button has the correct state
            //
            UpdateRemoveFromListButton(pUserMem->pRecipients ? TRUE : FALSE);
            break;
        }

        return FALSE;

    case WM_COMMAND:

        cmd = GET_WM_COMMAND_CMD(wParam, lParam);

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_CHOOSE_COUNTRY_COMBO:

            if (cmd == CBN_SELCHANGE) {

                //
                // Update the area code edit box if necessary
                //

                SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                                        GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT));

                UpdateAddToListButton();
                
            }
            break;

        case IDC_CHOOSE_NAME_EDIT:

            if (cmd == EN_CHANGE)
            {
               UpdateAddToListButton();
               
            }

            break;

        case IDC_CHOOSE_AREA_CODE_EDIT:

            if (cmd == EN_CHANGE)
            {
               UpdateAddToListButton();
               
               // Look for DBCS in the edit control.
 
               // Read the text from the edit control.
            
               if ( GetDlgItemText( hDlg, IDC_CHOOSE_AREA_CODE_EDIT, tszBuffer,
                    MAX_STRING_LEN ) != 0 )
               {
                  // Determine whether the contents of the edit control are legal.

                  if ( IsStringASCII( tszBuffer ) != (BOOL) TRUE )
                  {
                     LoadString(ghInstance, IDS_ERROR_AREA_CODE,
                                tszBuffer, MAX_STRING_LEN);

                     MessageBox( hDlg, tszBuffer, NULL,
                                 (UINT) (MB_ICONSTOP | MB_OK) );

                     SetDlgItemText(hDlg, IDC_CHOOSE_AREA_CODE_EDIT, L"");
                  }                  

               }
               else
               {
                  dwErrorCode = GetLastError();
            
                  if ( dwErrorCode != (DWORD) ERROR_SUCCESS )
                  {
                     // Error reading the edit control.
                  }
               }
            }

            break;

        case IDC_CHOOSE_NUMBER_EDIT:

            if (cmd == EN_CHANGE)
            {
               UpdateAddToListButton();

               // Look for DBCS in the edit control.
 
               // Read the text from the edit control.
            
               if ( GetDlgItemText( hDlg, IDC_CHOOSE_NUMBER_EDIT, tszBuffer,
                    MAX_STRING_LEN ) != 0 )
               {
                  // Determine whether the contents of the edit control are legal.

                  if ( IsStringASCII( tszBuffer ) != (BOOL) TRUE )
                  {
                     LoadString(ghInstance, IDS_ERROR_FAX_NUMBER,
                                tszBuffer, MAX_STRING_LEN);

                     MessageBox( hDlg, tszBuffer, NULL,
                                 (UINT) (MB_ICONSTOP | MB_OK) );

                     SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, L"");
                  }
               }
               else
               {
                  dwErrorCode = GetLastError();
            
                  if ( dwErrorCode != (DWORD) ERROR_SUCCESS )
                  {
                     // Error reading the edit control.
                  }
               }
            }

            break;

        case IDC_USE_DIALING_RULES:

            UpdateCountryCombobox(hDlg, -1);
            UpdateAddToListButton();            

            break;

        case IDC_CHOOSE_ADDRBOOK:

            DoAddressBook(hDlg, pUserMem);
            UpdateRemoveFromListButton(pUserMem->pRecipients ? TRUE : FALSE);
            break;

        case IDC_TAPI_PROPS:

            DoTapiProps(hDlg);            
            LocationListInit(hDlg, pUserMem);
            break;

        case IDC_LOCATION_LIST:

            if (cmd == CBN_SELCHANGE)
                LocationListSelChange(hDlg);
            break;

        case IDC_CHOOSE_ADD:

            if ((cmd = AddRecipient(hDlg, pUserMem)) != 0) {

                if (cmd > 0)
                    DisplayMessageDialog(hDlg, 0, 0, cmd);
                else
                    MessageBeep(MB_OK);

            } else {            
                SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));
                //
                // enable the remove button
                //
                UpdateRemoveFromListButton(TRUE);
            }
            break;
         case IDC_CHOOSE_REMOVE:
            RemoveRecipient(hDlg, pUserMem);
            //
            // disable the remove button if there are no more recipients
            //
            if (!pUserMem->pRecipients) {
                UpdateRemoveFromListButton(FALSE);
            }
        }
        break;
    }

    return TRUE;
}



VOID
ValidateSelectedCoverPage(
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    If a cover page is selected, then do the following:
        if the cover page file is a link resolve it
        check if the cover page file contains note/subject fields

Arguments:

    pUserMem - Points to user mode memory structure

Return Value:

    NONE

--*/

{
    TCHAR       filename[MAX_PATH];
    COVDOCINFO  covDocInfo;
    DWORD       ec;

    if (ResolveShortcut(pUserMem->coverPage, filename))
        _tcscpy(pUserMem->coverPage, filename);

    Verbose(("Cover page selected: %ws\n", pUserMem->coverPage));

    ec = PrintCoverPage(NULL, NULL, pUserMem->coverPage, &covDocInfo);
    if (!ec) {

        pUserMem->noteSubjectFlag = covDocInfo.Flags;
        pUserMem->cpPaperSize = covDocInfo.PaperSize;
        pUserMem->cpOrientation = covDocInfo.Orientation;

    } else {

        Error(("Cannot examine cover page file '%ws': %d\n",
               pUserMem->coverPage,
               ec));
    }
}



INT_PTR
CoverPageWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the second wizard page:
    selecting cover page and setting other fax options

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    static INT  textLimits[] = {

        IDC_CHOOSE_CP_SUBJECT,   256,
        IDC_CHOOSE_CP_NOTE,   8192,
        0
    };

    PUSERMEM    pUserMem;
    PDMPRIVATE  pdmPrivate;
    WORD        cmdId;
    HKEY        hRegKey;



    //
    // Handle common messages shared by all wizard pages
    //

    if (! (pUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
        return FALSE;

    //
    // Handle anything specific to the current wizard page
    //

    pdmPrivate = &pUserMem->devmode.dmPrivate;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Retrieve the most recently used cover page settings
        //

        if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) {
            LPTSTR tmp;
            pdmPrivate->sendCoverPage =
                GetRegistryDword(hRegKey, REGVAL_SEND_COVERPG);

                tmp = GetRegistryString(hRegKey, REGVAL_COVERPG, TEXT("") );
                if (tmp) {
                    lstrcpy(pUserMem->coverPage, tmp );
                    MemFree(tmp);
                }
            RegCloseKey(hRegKey);
        }

        //
        // Initialize the list of cover pages
        //

        WaitForSingleObject( pUserMem->hFaxSvcEvent, INFINITE );
        if (pUserMem->pCPInfo = AllocCoverPageInfo(pUserMem->hPrinter, pUserMem->ServerCPOnly)) {

            InitCoverPageList(pUserMem->pCPInfo,
                              GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                              pUserMem->coverPage);
        }

        //
        // Indicate whether cover page should be sent
        //

        if (SendDlgItemMessage(hDlg, IDC_CHOOSE_CP_LIST, CB_GETCOUNT, 0, 0) <= 0) {
            pdmPrivate->sendCoverPage = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_CHECK), FALSE);
        }

        CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, pdmPrivate->sendCoverPage);
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST), pdmPrivate->sendCoverPage);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), pdmPrivate->sendCoverPage);
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), pdmPrivate->sendCoverPage);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), pdmPrivate->sendCoverPage);
        EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), pdmPrivate->sendCoverPage);

        //
        // make sure the user selects a coverpage if this is the fax send utility
        //
        if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0)) {
            pdmPrivate->sendCoverPage = TRUE;
            CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, TRUE);
            // hide the checkbox
            MyHideWindow(GetDlgItem(hDlg,IDC_CHOOSE_CP_CHECK) );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), TRUE);
        } else {
           MyHideWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOCHECK) );
        }

        LimitTextFields(hDlg, textLimits);
                                                         
        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_CHOOSE_CP_CHECK:
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP), IsDlgButtonChecked(hDlg, cmdId) );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST), IsDlgButtonChecked(hDlg, cmdId) );
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), IsDlgButtonChecked(hDlg, cmdId) );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), IsDlgButtonChecked(hDlg, cmdId) );
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), IsDlgButtonChecked(hDlg, cmdId) );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), IsDlgButtonChecked(hDlg, cmdId) );

            break;


        };

        break;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT) {

            //
            // Remember the cover page settings selected
            //

            pUserMem->noteSubjectFlag = 0;
            pUserMem->cpPaperSize = 0;
            pUserMem->cpOrientation = 0;
            pdmPrivate->sendCoverPage = IsDlgButtonChecked(hDlg, IDC_CHOOSE_CP_CHECK);

            GetSelectedCoverPage(pUserMem->pCPInfo,
                                 GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                                 pUserMem->coverPage);

            if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)) {

                SetRegistryDword(hRegKey, REGVAL_SEND_COVERPG, pdmPrivate->sendCoverPage);
                SetRegistryString(hRegKey, REGVAL_COVERPG, pUserMem->coverPage);
                RegCloseKey(hRegKey);
            }

            //
            // If a cover page is selected, then do the following:
            //  if the cover page file is a link resolve it
            //  check if the cover page file contains note/subject fields
            //

            if (pdmPrivate->sendCoverPage)
                ValidateSelectedCoverPage(pUserMem);

            //
            // Collect the current values of other dialog controls
            //

            if (pUserMem->pSubject) MemFree(pUserMem->pSubject);
            if (pUserMem->pNoteMessage) MemFree(pUserMem->pNoteMessage);
            pUserMem->pSubject = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
            pUserMem->pNoteMessage = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE));

            //
            // If the current application is "Send Note" utility, then
            // the note field must not be empty.
            //

            if (pUserMem->pSubject == NULL &&
                pUserMem->pNoteMessage == NULL &&
                GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
            {
                DisplayMessageDialog(hDlg, 0, 0, IDS_NOTE_SUBJECT_EMPTY);
                SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);                
                return TRUE;
            }

        }

        return FALSE;
    }

    return TRUE;
}



INT_PTR
FaxOptsWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page: entering subject and note information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    //
    // Maximum length for various text fields
    //

    static INT  textLimits[] = {

        IDC_WIZ_FAXOPTS_BILLING,   16,        
        0
    };

    PUSERMEM    pUserMem;
    PDMPRIVATE  pdmPrivate;
    WORD        cmdId;
 //   TCHAR       TimeFormat[32];
    TCHAR           Is24H[2], IsRTL[2], *pszTimeFormat = TEXT("h : mm tt");
    static HWND hTimeControl;
    SYSTEMTIME  st;

    if (! (pUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
        return FALSE;


    pdmPrivate = &pUserMem->devmode.dmPrivate;
    switch (message) {

    case WM_INITDIALOG:
        

        //LoadString(ghInstance,IDS_WIZ_TIME_FORMAT,TimeFormat,sizeof(TimeFormat));
        hTimeControl = GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_SENDTIME);

        if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIME, Is24H,sizeof(Is24H) ) && Is24H[0] == TEXT('1')) {
            pszTimeFormat = TEXT("H : mm");
        }
        else if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIMEMARKPOSN, IsRTL,sizeof(IsRTL) ) && IsRTL[0] == TEXT('1')) {
            pszTimeFormat = TEXT("tt h : mm");
        }
        
        LimitTextFields(hDlg, textLimits);

        DateTime_SetFormat( hTimeControl,pszTimeFormat );

        
    
    

        //
        // restore time to send controls
        //
        cmdId = (pdmPrivate->whenToSend == SENDFAX_AT_CHEAP) ? IDC_WIZ_FAXOPTS_DISCOUNT : 
                (pdmPrivate->whenToSend == SENDFAX_AT_TIME) ? IDC_WIZ_FAXOPTS_SPECIFIC :
                IDC_WIZ_FAXOPTS_ASAP;

        CheckDlgButton(hDlg, cmdId, TRUE);
        
        EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
                    
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_FAXOPTS_DATE), (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );

        GetLocalTime(&st);
        st.wHour = pdmPrivate->sendAtTime.Hour;
        st.wMinute = pdmPrivate->sendAtTime.Minute;
        DateTime_SetSystemtime( hTimeControl, GDT_VALID, &st );
                    
        SetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_BILLING, pdmPrivate->billingCode);
        
        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT) {
            //
            // retrieve the billing code
            //
            if (! GetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_BILLING, pdmPrivate->billingCode, MAX_BILLING_CODE)) {
                pdmPrivate->billingCode[0] = NUL;
            }
            
            //
            // retrieve the sending time
            //
            pdmPrivate->whenToSend = IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_DISCOUNT) ? SENDFAX_AT_CHEAP :
                                     IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_SPECIFIC) ? SENDFAX_AT_TIME :
                                     SENDFAX_ASAP;

            if (pdmPrivate->whenToSend == SENDFAX_AT_TIME) {
                DWORD rVal;
                SYSTEMTIME SendTime;                
                TCHAR TimeBuffer[128];

                
                //
                // get specific time
                //                
                rVal = DateTime_GetSystemtime(hTimeControl, &SendTime);
                pdmPrivate->sendAtTime.Hour = SendTime.wHour;
                pdmPrivate->sendAtTime.Minute = SendTime.wMinute;
            
                    
                rVal = GetDateFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    0,
                    &SendTime,
                    NULL,
                    TimeBuffer,
                    sizeof(TimeBuffer)
                    );
                
                TimeBuffer[rVal - 1] = TEXT(' ');

                GetTimeFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    0,
                    &SendTime,
                    NULL,
                    &TimeBuffer[rVal],
                    sizeof(TimeBuffer)
                    );
                
                Verbose(("faxui - Fax Send time %ws", TimeBuffer));
            }

        }

        break;
    
    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_WIZ_FAXOPTS_SPECIFIC:
        case IDC_WIZ_FAXOPTS_DISCOUNT:
        case IDC_WIZ_FAXOPTS_ASAP:
            EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_FAXOPTS_DATE), (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );

            break;

        };

        break;
    default: 
        return FALSE;
    } ;
    return TRUE;
}


#ifdef FAX_SCAN_ENABLED

BOOL
CloseDataSource(
    PUSERMEM pUserMem,
    TW_IDENTITY * TwIdentity
    );

BOOL
OpenDataSource(
    PUSERMEM pUserMem,
    TW_IDENTITY * TwIdentity
    );

BOOL
DisableDataSource(
    PUSERMEM pUserMem,
    TW_USERINTERFACE * TwUserInterface
    );

BOOL
EnableDataSource(
    PUSERMEM pUserMem,
    TW_USERINTERFACE * TwUserInterface
    );

BOOL
SetCapability(
    PUSERMEM pUserMem,
    USHORT Capability,
    USHORT Type,
    LPVOID Value
    );


BOOL
Scan_SetCapabilities( 
    PUSERMEM pUserMem
    );

#define WM_SCAN_INIT            WM_APP
#define WM_SCAN_OPENDSM         WM_APP+1
#define WM_SCAN_CLOSEDSM        WM_APP+2
#define WM_SCAN_GETDEFAULT      WM_APP+3
#define WM_SCAN_GETFIRST        WM_APP+4
#define WM_SCAN_GETNEXT         WM_APP+5

#define WM_SCAN_OPENDS          WM_APP+10
#define WM_SCAN_CLOSEDS         WM_APP+11
#define WM_SCAN_ENABLEDS        WM_APP+12
#define WM_SCAN_DISABLEDS       WM_APP+13

#define WM_SCAN_CONTROLGET      WM_APP+20
#define WM_SCAN_CONTROLGETDEF   WM_APP+21
#define WM_SCAN_CONTROLRESET    WM_APP+22
#define WM_SCAN_CONTROLSET      WM_APP+23
#define WM_SCAN_CONTROLENDXFER  WM_APP+24

#define WM_SCAN_IMAGEGET        WM_APP+30

#define Scan_Init(_pUserMem)    (SendMessage(_pUserMem->hWndTwain, WM_SCAN_INIT,0,(LPARAM)_pUserMem))
#define Scan_OpenDSM(_pUserMem) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_OPENDSM,0,(LPARAM)&_pUserMem->hWndTwain))
#define Scan_CloseDSM(_pUserMem) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CLOSEDSM,0,(LPARAM)&_pUserMem->hWndTwain))

#define Scan_GetDefault(_pUserMem,_TwIdentity) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_GETDEFAULT,0,(LPARAM)_TwIdentity))
#define Scan_GetFirst(_pUserMem,_TwIdentity) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_GETFIRST,0,(LPARAM)_TwIdentity))
#define Scan_GetNext(_pUserMem,_TwIdentity) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_GETNEXT,0,(LPARAM)_TwIdentity))

#define Scan_OpenDS(_pUserMem,_TwIdentity)  (SendMessage(_pUserMem->hWndTwain, WM_SCAN_OPENDS,0,(LPARAM)_TwIdentity))
#define Scan_CloseDS(_pUserMem,_TwIdentity) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CLOSEDS,0,(LPARAM)_TwIdentity))
#define Scan_EnableDS(_pUserMem,_TwUi)      (SendMessage(_pUserMem->hWndTwain, WM_SCAN_ENABLEDS,0,(LPARAM)_TwUi))
#define Scan_DisableDS(_pUserMem,_TwUi)     (SendMessage(_pUserMem->hWndTwain, WM_SCAN_DISABLEDS,0,(LPARAM)_TwUi))

#define Scan_ControlGet(_pUserMem,_What,_Data) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CONTROLGET,(WPARAM)_What,(LPARAM)_Data))
#define Scan_ControlGetDef(_pUserMem,_What,_Data) (SendMessage(_pUserMem->hWndTwain, WM_SCAN_CONTROLGETDEF,(WPARAM)_What,(LPARAM)_Data))
#define Scan_ControlReset(_pUserMem,_What,_Data) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CONTROLRESET,(WPARAM)_What,(LPARAM)_Data))
#define Scan_ControlSet(_pUserMem,_What,_Data) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CONTROLSET,(WPARAM)_What,(LPARAM)_Data))
#define Scan_ControlEndXfer(_pUserMem,_What,_Data) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_CONTROLENDXFER,(WPARAM)_What,(LPARAM)_Data))

#define Scan_ImageGet(_pUserMem,_What,_Data) ((DWORD)SendMessage(_pUserMem->hWndTwain, WM_SCAN_IMAGEGET,(WPARAM)_What,(LPARAM)_Data))

//#define WM_SCAN_GETEVENT        WM_APP+7



DWORD
CallTwain(
    PUSERMEM  pUserMem,
    TW_UINT32 DG,
    TW_UINT16 DAT,
    TW_UINT16 MSG,
    TW_MEMREF pData
    )
{
    DWORD TwResult = 0;
    TW_STATUS TwStatus = {0};

    __try {

        TwResult = pUserMem->pDsmEntry(
            &pUserMem->AppId,
            NULL,
            DG,
            DAT,
            MSG,
            pData
            );

        if (TwResult) {

            pUserMem->pDsmEntry(
                &pUserMem->AppId,
                NULL,
                DG_CONTROL,
                DAT_STATUS,
                MSG_GET,
                (TW_MEMREF) &TwStatus
                );
            if (TwStatus.ConditionCode) {
                TwResult = TwStatus.ConditionCode;
            }

            Verbose(( "CallTwain failed, ec=%d\n", TwResult ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        TwResult = GetExceptionCode();
        Verbose(( "CallTwain crashed, ec=0x%08x\n", TwResult ));

    }

    return TwResult;
}


DWORD
CallTwainDataSource(
    PUSERMEM  pUserMem,
    TW_UINT32 DG,
    TW_UINT16 DAT,
    TW_UINT16 MSG,
    TW_MEMREF pData
    )
{
    DWORD TwResult = 0;
    TW_STATUS TwStatus = {0};

    __try {

        TwResult = pUserMem->pDsmEntry(
            &pUserMem->AppId,
            &pUserMem->DataSource,
            DG,
            DAT,
            MSG,
            pData
            );

        if (TwResult) {

            pUserMem->pDsmEntry(
                &pUserMem->AppId,
                &pUserMem->DataSource,
                DG_CONTROL,
                DAT_STATUS,
                MSG_GET,
                (TW_MEMREF) &TwStatus
                );
            if (TwStatus.ConditionCode) {
                TwResult = TwStatus.ConditionCode;
            }

            //Verbose(( "CallTwainDataSource failed, ec=%d\n", TwResult ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        TwResult = GetExceptionCode();
        Verbose(( "CallTwainDataSource crashed, ec=0x%08x\n", TwResult ));

    }

    return TwResult;
}


LRESULT
WINAPI
TwainWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD TwResult = 0;
    static PUSERMEM pUserMem = NULL;

    switch (uMsg) {
        
        case WM_SCAN_INIT:
            pUserMem = (PUSERMEM)lParam;
            return(TRUE);
            break;
                    
        case WM_SCAN_OPENDSM :
            TwResult = CallTwain(
                            pUserMem,
                            DG_CONTROL,
                            DAT_PARENT,
                            MSG_OPENDSM,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_OPENDSM (DAT_PARENT) failed, ec = %d\n", TwResult ));
            }
            return(TwResult);
            break;

        case WM_SCAN_CLOSEDSM:
            TwResult = CallTwain(
                            pUserMem,
                            DG_CONTROL,
                            DAT_PARENT,
                            MSG_CLOSEDSM,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_CLOSEDSM (DAT_PARENT) failed, ec = %d\n", TwResult ));
            } 
            return(TwResult);
            break;

        case WM_SCAN_GETDEFAULT:
            TwResult = CallTwain(
                            pUserMem,
                            DG_CONTROL,
                            DAT_IDENTITY,
                            MSG_GETDEFAULT,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GETDEFAULT (DAT_IDENTITY) failed, ec = %d\n", TwResult ));
            }
            return(TwResult);
            break;

        case WM_SCAN_GETFIRST:
            TwResult = CallTwain(
                            pUserMem,
                            DG_CONTROL,
                            DAT_IDENTITY,
                            MSG_GETFIRST,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GETFIRST (DAT_IDENTITY) failed, ec = %d\n", TwResult ));
            }
            return(TwResult);
            break;
            
        case WM_SCAN_GETNEXT:
            TwResult = CallTwain(
                            pUserMem,
                            DG_CONTROL,
                            DAT_IDENTITY,
                            MSG_GETNEXT,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS && TwResult != TWRC_ENDOFLIST) {
                Verbose(( "MSG_GETNEXT (DAT_IDENTITY) failed, ec = %d\n", TwResult ));
            }
            return(TwResult);
            break;
            
        case WM_SCAN_OPENDS:
            if (OpenDataSource( pUserMem,  (TW_IDENTITY *)lParam ) &&
                Scan_SetCapabilities( pUserMem )) {
                return TRUE;
            }
            return(FALSE);
        
        case WM_SCAN_CLOSEDS:
            return (CloseDataSource( pUserMem, (TW_IDENTITY *)lParam ));
        
        case WM_SCAN_ENABLEDS:
            return (EnableDataSource( pUserMem, (TW_USERINTERFACE *)lParam ));
        
        case WM_SCAN_DISABLEDS:
            return (DisableDataSource( pUserMem, (TW_USERINTERFACE *)lParam ));
        
        case WM_SCAN_CONTROLGET:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_CONTROL,
                            (TW_UINT16)wParam,
                            MSG_GET,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GET (%d)failed, ec = %d\n", wParam, TwResult ));
            }
            return(TwResult);
            break;
        case WM_SCAN_CONTROLGETDEF:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_CONTROL,
                            (TW_UINT16)wParam,
                            MSG_GETDEFAULT,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GETDEFAULT (%d)failed, ec = %d\n", wParam, TwResult ));
            }
            return(TwResult);
            break;
        case WM_SCAN_CONTROLRESET:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_CONTROL,
                            (TW_UINT16)wParam,
                            MSG_RESET,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_RESET (%d)failed, ec = %d\n", wParam, TwResult ));
            }
            return(TwResult);
            break;
        case WM_SCAN_CONTROLSET:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_CONTROL,
                            (TW_UINT16)wParam,
                            MSG_SET,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_SET (%d)failed, ec = %d\n", wParam, TwResult ));
            }
            return(TwResult);
            break;
        case WM_SCAN_CONTROLENDXFER:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_CONTROL,
                            (TW_UINT16)wParam,
                            MSG_ENDXFER,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_ENDXFER (%d)failed, ec = %d\n", wParam, TwResult ));
            }
            return(TwResult);
            break;
    
        case WM_SCAN_IMAGEGET:
            TwResult = CallTwainDataSource(
                            pUserMem,
                            DG_IMAGE,
                            (TW_UINT16)wParam,
                            MSG_GET,
                            (TW_MEMREF) lParam
                            );
            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GET (DAT_IMAGEINFO) failed, ec = %d\n", TwResult ));
            }
            return(TwResult);
            break;
    
    default:

        return DefWindowProc( hwnd, uMsg, wParam, lParam );


    };

    Assert(FALSE);
    return FALSE;
        
}


DWORD
TwainMessagePumpThread(
    PUSERMEM pUserMem
    )
{
    WNDCLASS wc;
    MSG msg;
    HWND hWnd;
    DWORD WaitObj;
    TW_EVENT TwEvent;
    DWORD TwResult;


    wc.style = CS_OWNDC;
    wc.lpfnWndProc = (WNDPROC)TwainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L"FaxWizTwainWindow";

    if (RegisterClass( &wc ) == 0) {
        SetEvent( pUserMem->hEvent );
        return 0;
    }

    hWnd = CreateWindow(
        L"FaxWizTwainWindow",
        L"FaxWizTwainWindow",
        WS_DISABLED,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (hWnd == NULL) {
        SetEvent( pUserMem->hEvent );
        return 0;
    }

    pUserMem->hWndTwain = hWnd;

    Scan_Init(pUserMem);

    SetEvent( pUserMem->hEvent );

    while (TRUE) {
        WaitObj = MsgWaitForMultipleObjectsEx( 1, &pUserMem->hEventQuit, INFINITE, QS_ALLINPUT, 0 );
        if (WaitObj == WAIT_OBJECT_0) {
            return 0;
        }
        
        // PeekMessage instead of GetMessage so we drain the message queue
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE )) {
            if (msg.message == WM_QUIT) {
                return 0;
            }
        


            if (pUserMem->TwainAvail) {
    
                TwEvent.pEvent = (TW_MEMREF) &msg;
                TwEvent.TWMessage = MSG_NULL;
    
                TwResult = CallTwainDataSource(
                    pUserMem,
                    DG_CONTROL,
                    DAT_EVENT,
                    MSG_PROCESSEVENT,
                    (TW_MEMREF) &TwEvent
                    );

                //if (TwResult != TWRC_SUCCESS && TwResult != TWRC_NOTDSEVENT) {
                //    Verbose(( "MSG_PROCESSEVENT (DAT_EVENT) failed, ec=%d\n", TwResult ));
                //}
    
                switch (TwEvent.TWMessage) {
                    case MSG_XFERREADY:
                        //
                        // transition from state 5 to state 6
                        //
                        Verbose(( "received MSG_XFERREADY, setting hEventXfer\n" ));
                        SetEvent( pUserMem->hEventXfer );
                        break;
    
                    case MSG_CLOSEDSREQ:
                        //
                        // transition from state 5 to 4 to 3
                        //
                        
                        pUserMem->TwainCancelled = TRUE;
                        Verbose(( "received MSG_CLOSEDSREQ, setting hEventXfer\n" ));
                        SetEvent( pUserMem->hEventXfer );
                        break;
    
                    case MSG_NULL:
                        break;
                }
    
                if (TwResult == TWRC_NOTDSEVENT) {
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                }
            }
        }
    }

    return 0;
}


VOID
TerminateTwain(
    PUSERMEM pUserMem
    )
{
    DWORD TwResult;

    Verbose(( "entering TerminateTwain, state = %d\n", pUserMem->State ));

    //Scan_CloseDS( pUserMem, &pUserMem->DataSource );
    CloseDataSource( pUserMem, &pUserMem->DataSource );

    if (pUserMem->State == 3) {

        TwResult = Scan_CloseDSM( pUserMem );

        if (TwResult == TWRC_SUCCESS) {
            pUserMem->State = 2;
            Verbose(( "entering state 2\n" ));
        }
    }

    if (pUserMem->hWndTwain) {
        DestroyWindow( pUserMem->hWndTwain );
    }

    SetEvent( pUserMem->hEventQuit );

    WaitForSingleObject( pUserMem->hThread, INFINITE );

    if (pUserMem->hTwain) {
        FreeLibrary( pUserMem->hTwain );
    }

    CloseHandle( pUserMem->hThread );
}


#if 0
BOOL
SetCapability(
    PUSERMEM pUserMem,
    USHORT Capability,
    USHORT Type,
    LPVOID Value
    )
{
    DWORD TwResult;
    TW_CAPABILITY TwCapability;
    TW_ONEVALUE *TwOneValue;
    TW_FIX32 *TwFix32;



    TwCapability.Cap = Capability;
    TwCapability.ConType = TWON_ONEVALUE;
    TwCapability.hContainer = GlobalAlloc( GHND, sizeof(TW_ONEVALUE) );

    TwOneValue = (TW_ONEVALUE*) GlobalLock( TwCapability.hContainer );

    TwOneValue->ItemType = Type;

    if (Type == TWTY_FIX32) {
        TwFix32 = (TW_FIX32*)Value;
        CopyMemory( &TwOneValue->Item, TwFix32, sizeof(TW_FIX32) );
    } else {
        TwOneValue->Item = (DWORD)Value;
    }

    GlobalUnlock( TwCapability.hContainer );

    //
    // bugbug called in opendatasource
    //
    TwResult  = CallTwainDataSource(
                    pUserMem,
                    DG_CONTROL,
                    DAT_CAPABILITY,
                    MSG_SET,
                    (TW_MEMREF) &TwCapability
                    );
    
    GlobalFree( TwCapability.hContainer );

    if (TwResult != TWRC_SUCCESS) {
        Verbose(( "Could not set capability 0x%04x\n", Capability ));
        return FALSE;
    }

    return TRUE;
}
#else
BOOL
SetCapability(
    PUSERMEM pUserMem,
    USHORT Capability,
    USHORT Type,
    LPVOID Value
    )
{
    DWORD TwResult;
    TW_CAPABILITY TwCapability;
    TW_ONEVALUE *TwOneValue;
    TW_FIX32 *TwFix32;



    TwCapability.Cap = Capability;
    TwCapability.ConType = TWON_ONEVALUE;
    TwCapability.hContainer = GlobalAlloc( GHND, sizeof(TW_ONEVALUE) );

    TwOneValue = (TW_ONEVALUE*) GlobalLock( TwCapability.hContainer );

    TwOneValue->ItemType = Type;

    if (Type == TWTY_FIX32) {
        TwFix32 = (TW_FIX32*)Value;
        CopyMemory( &TwOneValue->Item, TwFix32, sizeof(TW_FIX32) );
    } else {
        TwOneValue->Item = PtrToUlong(Value);
    }

    GlobalUnlock( TwCapability.hContainer );

    //
    // bugbug called in opendatasource
    //
    TwResult = Scan_ControlSet(pUserMem, DAT_CAPABILITY, &TwCapability);
    
    GlobalFree( TwCapability.hContainer );

    if (TwResult != TWRC_SUCCESS) {
        Verbose(( "Could not set capability 0x%04x\n", Capability ));
        return FALSE;
    }

    return TRUE;
}
#endif

float
FIX32ToFloat(
    TW_FIX32 fix32
    )
{
    float   floater;
    floater = (float) fix32.Whole + (float) fix32.Frac / (float) 65536.0;
    return floater;
}


BOOL
OpenDataSource(
    PUSERMEM pUserMem,
    TW_IDENTITY * TwIdentity

    )
{
    DWORD TwResult;

    Verbose(( "entering OpenDataSource, state = %d\n", pUserMem->State ));

    if (pUserMem->State == 3) {

        //
        // open the data source
        //

        TwResult = CallTwain(
            pUserMem,
            DG_CONTROL,
            DAT_IDENTITY,
            MSG_OPENDS,
            (TW_MEMREF) TwIdentity
            );
        if (TwResult != TWRC_SUCCESS) {
            return FALSE;
        }

        pUserMem->State = 4;
        Verbose(( "entering state 4\n" ));
    }

    return TRUE;

}

BOOL
Scan_SetCapabilities(
    PUSERMEM  pUserMem
    )
{
    //
    // set the capabilities
    //

    SetCapability( pUserMem, CAP_XFERCOUNT,           TWTY_INT16,  (LPVOID)1               );
    SetCapability( pUserMem, ICAP_PIXELTYPE,          TWTY_INT16,  (LPVOID)TWPT_BW         );
    SetCapability( pUserMem, ICAP_BITDEPTH,           TWTY_INT16,  (LPVOID)1               );
    SetCapability( pUserMem, ICAP_BITORDER,           TWTY_INT16,  (LPVOID)TWBO_MSBFIRST   );
    SetCapability( pUserMem, ICAP_PIXELFLAVOR,        TWTY_INT16,  (LPVOID)TWPF_VANILLA    );
    SetCapability( pUserMem, ICAP_XFERMECH,           TWTY_INT16,  (LPVOID)TWSX_MEMORY     );

    return TRUE;
}


BOOL
EnableDataSource(
    PUSERMEM  pUserMem,
    TW_USERINTERFACE *TwUserInterface
    )
{
    DWORD TwResult;
    
    if (pUserMem->State == 4) {

        ResetEvent( pUserMem->hEventXfer );

        //
        // enable the data source's user interface
        //

        pUserMem->TwainCancelled = FALSE;
        
        TwResult = CallTwainDataSource(
            pUserMem,
            DG_CONTROL,
            DAT_USERINTERFACE,
            MSG_ENABLEDS,
            (TW_MEMREF) TwUserInterface
            );
        if (TwResult != TWRC_SUCCESS) {
            Verbose(( "MSG_ENABLEDS (DAT_USERINTERFACE) failed, ec=%d\n",TwResult ));
            return FALSE;
        }

        pUserMem->State = 5;

        Verbose(( "entering state 5\n" ));
    }

    return TRUE;
}

BOOL
DisableDataSource(
    PUSERMEM pUserMem,
    TW_USERINTERFACE * TwUserInterface
    )
{
    DWORD TwResult;
    
    Verbose(( "entering DisableDataSource, state = %d\n",pUserMem->State ));

    if (pUserMem->State == 5) {

        //
        // disable the data source
        //

        TwResult = CallTwainDataSource(
            pUserMem,
            DG_CONTROL,
            DAT_USERINTERFACE,
            MSG_DISABLEDS,
            (TW_MEMREF) TwUserInterface
            );
        if (TwResult != TWRC_SUCCESS) {
            Verbose(( "MSG_DISABLEDS (DAT_USERINTERFACE) failed, ec = %d\n", TwResult ));
            return FALSE;
        }

        pUserMem->State = 4;

        Verbose(( "entering state 4\n" ));
    }

    return TRUE;
}


BOOL
CloseDataSource(
    PUSERMEM pUserMem,
    TW_IDENTITY * TwIdentity
    )
{
    DWORD TwResult;
 
    Verbose(( "entering CloseDataSource, state = %d\n",pUserMem->State ));
 
    if (pUserMem->State == 4) {

        //
        // close the data source
        //

        TwResult = CallTwain(
            pUserMem,
            DG_CONTROL,
            DAT_IDENTITY,
            MSG_CLOSEDS,
            (TW_MEMREF) TwIdentity
            );
        if (TwResult != TWRC_SUCCESS) {
            Verbose(( "MSG_CLOSEDS (DAT_IDENTIFY) failed, ec = %d\n", TwResult ));
            return FALSE;
        }

        pUserMem->State = 3;

        Verbose(( "entering state 3\n" ));
    }

    Verbose(( "leaving CloseDataSource, state = %d\n",pUserMem->State ));

    return TRUE;
}


BOOL
InitializeTwain(
    PUSERMEM pUserMem
    )
{
    BOOL Rval = FALSE;
    DWORD TwResult;
    DWORD ThreadId;


    HKEY hKey;
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, REG_READONLY );
    if (hKey) {
        if (GetRegistryDword( hKey, REGVAL_SCANNER_SUPPORT ) != 0) {
            RegCloseKey( hKey );
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    pUserMem->State = 1;
    Verbose(( "entering state 1\n" ));

    pUserMem->hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    pUserMem->hEventQuit = CreateEvent( NULL, TRUE, FALSE, NULL );
    pUserMem->hEventXfer = CreateEvent( NULL, TRUE, FALSE, NULL );

    pUserMem->hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)TwainMessagePumpThread,
        pUserMem,
        0,
        &ThreadId
        );
    if (!pUserMem->hThread) {
        goto exit;
    }

    WaitForSingleObject( pUserMem->hEvent, INFINITE );

    if (pUserMem->hWndTwain == NULL) {
        goto exit;
    }

    pUserMem->hTwain = LoadLibrary( L"twain_32.dll" );
    if (pUserMem->hTwain) {
        pUserMem->pDsmEntry = (DSMENTRYPROC) GetProcAddress( pUserMem->hTwain, "DSM_Entry" );
    }

    if (pUserMem->pDsmEntry == NULL) {
        goto exit;
    }

    pUserMem->State = 2;

    Verbose(( "entering state 2\n" ));

    //
    // open the data source manager
    //

    pUserMem->AppId.Id = 0;
    pUserMem->AppId.Version.MajorNum = 1;
    pUserMem->AppId.Version.MinorNum = 0;
    pUserMem->AppId.Version.Language = TWLG_USA;
    pUserMem->AppId.Version.Country = TWCY_USA;
    strcpy( pUserMem->AppId.Version.Info, "Fax Print Wizard" );
    pUserMem->AppId.ProtocolMajor = TWON_PROTOCOLMAJOR;
    pUserMem->AppId.ProtocolMinor = TWON_PROTOCOLMINOR;
    pUserMem->AppId.SupportedGroups = DG_IMAGE | DG_CONTROL;
    strcpy( pUserMem->AppId.Manufacturer, "Microsoft" );
    strcpy( pUserMem->AppId.ProductFamily, "Windows" );
    strcpy( pUserMem->AppId.ProductName, "Windows" );

    TwResult = Scan_OpenDSM( pUserMem );

    if (TwResult != TWRC_SUCCESS) {
        Verbose(( "MSG_OPENDSM (DAT_PARENT) failed, ec = %d\n", TwResult ));
        goto exit;
    }

    pUserMem->State = 3;
    
    Verbose(( "entering state 3\n" ));

    //
    // select the default data source
    //

    TwResult = Scan_GetDefault(pUserMem, &pUserMem->DataSource);
        
    if (TwResult != TWRC_SUCCESS) {
        Verbose(( "MSG_GETDEFAULT (DAT_IDENTITY) failed, ec = %d\n", TwResult )); 
        goto exit;
    }

    //
    // return success
    //

    Rval = TRUE;
    pUserMem->TwainAvail = TRUE;

exit:

    if (!Rval) {

        //
        // part of the initialization failed
        // so lets clean everything up before exiting
        //

        TerminateTwain( pUserMem );
    }

    return Rval;
}


DWORD
ScanningThread(
    PUSERMEM pUserMem
    )
{
    DWORD               TwResult;
    TW_SETUPMEMXFER     TwSetupMemXfer;
    TW_IMAGEMEMXFER     TwImageMemXfer;
    TW_PENDINGXFERS     TwPendingXfers;
    TW_USERINTERFACE    TwUserInterface;
    TW_IMAGEINFO        TwImageInfo;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    TIFF_HEADER         TiffHdr;
    DWORD               FileBytes = 0;
    DWORD               BytesWritten;
    LPBYTE              Buffer1 = NULL;
    LPBYTE              CurrBuffer;
    LPBYTE              p = NULL;
    DWORD               LineSize;
    DWORD               i;
    DWORD               Lines;
    LPBYTE              ScanBuffer = NULL;
    DWORD               IfdOffset;
    DWORD               NextIfdSeekPoint;
    WORD                NumDirEntries;
    DWORD               DataOffset;
    BOOL                FirstTime = TRUE;


    Verbose(( "Entering ScanningThread, state = %d\n", pUserMem->State ));
    pUserMem->TwainActive = TRUE;

    if (pUserMem->State == 5) {

        while (pUserMem->State == 5) {
            //
            // wait for the MSG_XFERREADY message to be
            // delivered to the message pump.  this moves
            // us to state 6
            //

            WaitForSingleObject( pUserMem->hEventXfer, INFINITE );
            ResetEvent( pUserMem->hEventXfer );
            Verbose(( "hEventXfer signalled\n" ));
            if (pUserMem->TwainCancelled) {
                Verbose(( "twain cancelled\n" ));
                TwUserInterface.ShowUI  = FALSE;
                TwUserInterface.ModalUI = FALSE;
                TwUserInterface.hParent = NULL;
                Scan_DisableDS(pUserMem, &TwUserInterface);                
                goto exit;
            }

            //
            // get the image info
            //

            TwResult = Scan_ImageGet(pUserMem,DAT_IMAGEINFO,&TwImageInfo);

            if (TwResult != TWRC_SUCCESS) {
                Verbose(( "MSG_GET (DAT_IMAGEINFO) failed, ec=%d\n", TwResult ));
                goto exit;
            }

            //
            // we only allow monochrome images
            //

            if (TwImageInfo.BitsPerPixel > 1) {

                DisplayMessageDialog( NULL, 
                                      MB_ICONASTERISK | MB_OK | MB_SETFOREGROUND,
                                      IDS_SCAN_ERROR_TITLE, 
                                      IDS_SCAN_ERROR_BW );

                //
                // go back to state 5
                //

                TwResult = Scan_ControlReset(pUserMem,DAT_PENDINGXFERS,&TwPendingXfers);

                if (TwResult != TWRC_SUCCESS) {
                    Verbose(( "MSG_RESET (DAT_PENDINGXFERS) failed, ec=%d\n", TwResult ));
                    goto exit;
                }

            } else {
                pUserMem->State = 6;
                Verbose(( "entering state 6\n" ));
            }
        }

        //
        // setup the memory buffer sizes
        //
        
        TwResult = Scan_ControlGet(pUserMem,DAT_SETUPMEMXFER, &TwSetupMemXfer);

        if (TwResult != TWRC_SUCCESS) {
            Verbose(( "MSG_GET (DAT_SETUPMEMXFER) failed, ec=%d\n", TwResult ));
            goto exit;
        }

        Buffer1 = (LPBYTE) MemAlloc( TwSetupMemXfer.Preferred );

        TwImageMemXfer.Compression      = TWON_DONTCARE16;
        TwImageMemXfer.BytesPerRow      = TWON_DONTCARE32;
        TwImageMemXfer.Columns          = TWON_DONTCARE32;
        TwImageMemXfer.Rows             = TWON_DONTCARE32;
        TwImageMemXfer.XOffset          = TWON_DONTCARE32;
        TwImageMemXfer.YOffset          = TWON_DONTCARE32;
        TwImageMemXfer.BytesWritten     = TWON_DONTCARE32;
        TwImageMemXfer.Memory.Flags     = TWMF_APPOWNS | TWMF_POINTER;
        TwImageMemXfer.Memory.Length    = TwSetupMemXfer.Preferred;
        TwImageMemXfer.Memory.TheMem    = Buffer1;
    }

    Verbose(( "begin transferring image... " ));
    Verbose(( "entering state 7, TwResult = %d\n", TwResult ));

    while (TwResult != TWRC_XFERDONE) {
try_again:    
        pUserMem->State = 7;
        
        TwResult = Scan_ImageGet(pUserMem,DAT_IMAGEMEMXFER,&TwImageMemXfer);

        if (TwResult == 0) {
            if (ScanBuffer == NULL) {
                ScanBuffer = VirtualAlloc(
                    NULL,
                    TwImageMemXfer.BytesPerRow * (TwImageInfo.ImageLength + 16),
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );
                if (ScanBuffer == NULL) {
                    goto exit;
                }
                p = ScanBuffer;
            }
            CopyMemory( p, Buffer1, TwImageMemXfer.BytesWritten );
            p += TwImageMemXfer.BytesWritten;
            FileBytes += TwImageMemXfer.BytesWritten;
        } else if ( TwResult != TWRC_XFERDONE) {
            Verbose(( "MGS_GET (DAT_IMAGEMEMXFER) failed, ec = %d ", TwResult ));
            goto exit;
        }
    }

    
    Assert( TwResult == TWRC_XFERDONE );

    if (!ScanBuffer || !FileBytes) {
        //
        // we didn't really scan anything...
        //
        Verbose(( "asked for tranfer, but nothing was transferred\n" ));
        if (FirstTime) {
            FirstTime = FALSE;
            goto try_again;
        }   

        TwResult = Scan_ControlEndXfer(pUserMem,DAT_PENDINGXFERS, &TwPendingXfers);
        
        pUserMem->State = 5;

        //
        // disable the data source's user interface
        //
    
        TwUserInterface.ShowUI  = FALSE;
        TwUserInterface.ModalUI = FALSE;
        TwUserInterface.hParent = NULL;
    
        Scan_DisableDS(pUserMem, &TwUserInterface);
        
        pUserMem->State = 4;
    
        Verbose(( "entering state 4\n" ));

        goto exit;
    }

    pUserMem->PageCount += 1;

    Verbose(( "...finished transferring image\n" ));

    hFile = CreateFile(
        pUserMem->FileName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        Verbose(( "CreateFile failed, ec=%d\n", GetLastError() ));
        goto exit;
    }

    if (pUserMem->PageCount == 1) {
        TiffHdr.Identifier = TIFF_LITTLEENDIAN;
        TiffHdr.Version = TIFF_VERSION;
        TiffHdr.IFDOffset = 0;
        WriteFile( hFile, &TiffHdr, sizeof(TiffHdr), &BytesWritten, NULL );
    } else {
        ReadFile( hFile, &TiffHdr, sizeof(TiffHdr), &BytesWritten, NULL );
        NextIfdSeekPoint = TiffHdr.IFDOffset;
        while (NextIfdSeekPoint) {
            SetFilePointer( hFile, NextIfdSeekPoint, NULL, FILE_BEGIN );
            ReadFile( hFile, &NumDirEntries, sizeof(NumDirEntries), &BytesWritten, NULL );
            SetFilePointer( hFile, NumDirEntries*sizeof(TIFF_TAG), NULL, FILE_CURRENT );
            ReadFile( hFile, &NextIfdSeekPoint, sizeof(NextIfdSeekPoint), &BytesWritten, NULL );
        }
    }

    NextIfdSeekPoint = SetFilePointer( hFile, 0, NULL, FILE_CURRENT ) - sizeof(NextIfdSeekPoint);
    SetFilePointer( hFile, 0, NULL, FILE_END );
    DataOffset = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );

    LineSize = TwImageInfo.ImageWidth / 8;
    LineSize += (TwImageInfo.ImageWidth % 8) ? 1 : 0;

    Lines = FileBytes / TwImageMemXfer.BytesPerRow;

    CurrBuffer = ScanBuffer;
    for (i=0; i<Lines; i++) {
        WriteFile( hFile, CurrBuffer, LineSize, &BytesWritten, NULL );
        CurrBuffer += TwImageMemXfer.BytesPerRow;
    }

    IfdOffset = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );

    FaxIFDTemplate.xresNum = (DWORD) FIX32ToFloat( TwImageInfo.XResolution );
    FaxIFDTemplate.yresNum = (DWORD) FIX32ToFloat( TwImageInfo.YResolution );

    FaxIFDTemplate.ifd[IFD_PAGENUMBER].DataOffset = MAKELONG( pUserMem->PageCount-1, 0);
    FaxIFDTemplate.ifd[IFD_IMAGEWIDTH].DataOffset = TwImageInfo.ImageWidth;
    FaxIFDTemplate.ifd[IFD_IMAGELENGTH].DataOffset = Lines;
    FaxIFDTemplate.ifd[IFD_ROWSPERSTRIP].DataOffset = Lines;
    FaxIFDTemplate.ifd[IFD_STRIPBYTECOUNTS].DataOffset = Lines * LineSize;
    FaxIFDTemplate.ifd[IFD_STRIPOFFSETS].DataOffset = DataOffset;
    FaxIFDTemplate.ifd[IFD_XRESOLUTION].DataOffset = IfdOffset + FIELD_OFFSET( FAXIFD, xresNum );
    FaxIFDTemplate.ifd[IFD_YRESOLUTION].DataOffset = IfdOffset + FIELD_OFFSET( FAXIFD, yresNum );
    FaxIFDTemplate.ifd[IFD_SOFTWARE].DataOffset = IfdOffset + FIELD_OFFSET( FAXIFD, software );

    WriteFile( hFile, &FaxIFDTemplate, sizeof(FaxIFDTemplate), &BytesWritten, NULL );

    SetFilePointer( hFile, NextIfdSeekPoint, NULL, FILE_BEGIN );
    WriteFile( hFile, &IfdOffset, sizeof(DWORD), &BytesWritten, NULL );

    //
    // end the transfer
    //

    TwResult = Scan_ControlEndXfer(pUserMem,DAT_PENDINGXFERS, &TwPendingXfers);
        
    if (TwResult != TWRC_SUCCESS) {
        Verbose(( "MSG_ENDXFER (DAT_PENDINGXFERS) failed, ec=%d\n", TwResult ));
        goto exit;
    }

    pUserMem->State = 5;
    Verbose(( "entering state 5\n" ));

    //
    // disable the data source's user interface
    //

    TwUserInterface.ShowUI  = FALSE;
    TwUserInterface.ModalUI = FALSE;
    TwUserInterface.hParent = NULL;

    Scan_DisableDS(pUserMem, &TwUserInterface);
    
    pUserMem->State = 4;

    Verbose(( "entering state 4\n" ));

    PostMessage( pUserMem->hDlgScan, WM_PAGE_COMPLETE, 0, 0 );

exit:
    if (ScanBuffer) {
        VirtualFree( ScanBuffer, 0, MEM_RELEASE);
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle( hFile );
    }

    MemFree( Buffer1 );    

    Verbose(( "leaving scanning thread, state = %d\n", pUserMem->State ));

    pUserMem->TwainActive = FALSE;

    return 0;
}


BOOL
EnumerateDataSources(
    PUSERMEM pUserMem,
    HWND ComboBox,
    HWND StaticText
    )
{
    DWORD TwResult;
    TW_IDENTITY TwIdentity;
    TW_IDENTITY *pDataSource;
    DWORD i;
    DWORD Count = 0;


    TwResult = Scan_GetFirst( pUserMem, &TwIdentity );
        
    if (TwResult != TWRC_SUCCESS) {
        return FALSE;
    }

    do {
        i = (DWORD)SendMessageA( ComboBox, CB_ADDSTRING, 0, (LPARAM)TwIdentity.ProductName );

        pDataSource = (TW_IDENTITY*) MemAlloc( sizeof(TW_IDENTITY) );
        if (pDataSource) {
            CopyMemory( pDataSource, &TwIdentity, sizeof(TW_IDENTITY) );
            SendMessageA( ComboBox, CB_SETITEMDATA, i, (LPARAM)pDataSource );
        }

        Count += 1;

        TwResult = Scan_GetNext( pUserMem, &TwIdentity );

    } while (TwResult == 0);

    i = (DWORD)SendMessageA( ComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM)pUserMem->DataSource.ProductName );
    if (i == CB_ERR) {
        i = 0;
    }

    SendMessageA( ComboBox, CB_SETCURSEL, i, 0 );

    if (Count == 1) {
        EnableWindow( StaticText, FALSE );
        EnableWindow( ComboBox, FALSE );
    }

    return TRUE;
}



INT_PTR
ScanWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page: entering subject and note information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    PUSERMEM pUserMem;
    HANDLE hThread;
    DWORD ThreadId;
    WCHAR TempPath[MAX_PATH];
    //TW_PENDINGXFERS     TwPendingXfers;
    TW_USERINTERFACE    TwUserInterface;


    pUserMem = (PUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {
            
        case WM_INITDIALOG:
            lParam = ((PROPSHEETPAGE *) lParam)->lParam;
            pUserMem = (PUSERMEM) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            if (GetEnvironmentVariable(L"NTFaxSendNote", TempPath, sizeof(TempPath)) == 0 || TempPath[0] != L'1') {
                pUserMem->TwainAvail = FALSE;
                return TRUE;
            }
            if (pUserMem->TwainAvail) {
                EnumerateDataSources( pUserMem, GetDlgItem( hDlg, IDC_DATA_SOURCE ), GetDlgItem( hDlg, IDC_STATIC_DATA_SOURCE) );
            } else {
                pUserMem->TwainAvail = FALSE;
                return TRUE;
            }
            if (GetTempPath( sizeof(TempPath)/sizeof(WCHAR), TempPath )) {
                if (GetTempFileName( TempPath, L"fax", 0, pUserMem->FileName )) {
                    SetEnvironmentVariable( L"ScanTifName", pUserMem->FileName );
                }
            }
            pUserMem->hDlgScan = hDlg;
            return TRUE;

        case WM_NOTIFY:
            switch ( ((NMHDR *) lParam)->code) {
                case PSN_SETACTIVE:            
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
                    if (!pUserMem->TwainAvail) {
                        //
                        // jump to next page
                        //
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    }
                    
                    return FALSE;
                    break;
                case PSN_WIZNEXT:
                
                    if (!pUserMem->PageCount) {
                        //
                        // we didn't actually scan any pages
                        //
                        DeleteFile( pUserMem->FileName ) ;
                        SetEnvironmentVariable( L"ScanTifName", NULL );
        
                    }

                    //Scan_CloseDS( pUserMem, &pUserMem->DataSource );
                    CloseDataSource( pUserMem, &pUserMem->DataSource );
                    Assert(pUserMem->State == 3);
                    pUserMem->State = 3;

                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_WIZARD_FAXOPTS );
                    return TRUE;
                    break;
                case PSN_QUERYCANCEL:                    
                    //
                    // we didn't actually scan any pages
                    //
                    DeleteFile( pUserMem->FileName ) ;    
                    if (pUserMem->TwainActive) {
                         
                        TwUserInterface.ShowUI  = FALSE;
                        TwUserInterface.ModalUI = FALSE;
                        TwUserInterface.hParent = NULL;
                        DisableDataSource( pUserMem, &TwUserInterface );
                        
                    }

                    CloseDataSource( pUserMem, &pUserMem->DataSource );

                    break;
                default:
                    break;
            }

            break;

        case WM_PAGE_COMPLETE:
            SetDlgItemInt( hDlg, IDC_PAGE_COUNT, pUserMem->PageCount, FALSE );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == CBN_SELCHANGE) {
                TW_IDENTITY *pDataSource;
                DWORD i;


                i = (DWORD)SendDlgItemMessage( hDlg, IDC_DATA_SOURCE, CB_GETCURSEL, 0, 0 );
                pDataSource = (TW_IDENTITY *) SendDlgItemMessage( hDlg, IDC_DATA_SOURCE, CB_GETITEMDATA, i, 0 );

                CopyMemory( &pUserMem->DataSource, pDataSource, sizeof(TW_IDENTITY) );
            }

            if (HIWORD(wParam) == BN_CLICKED) {

                //
                // scan a page
                //
                TW_USERINTERFACE  TwUserInterface;
                
                TwUserInterface.ShowUI  = TRUE;
                TwUserInterface.ModalUI = TRUE;
                TwUserInterface.hParent = GetParent(pUserMem->hDlgScan);

                if ( !pUserMem->TwainActive 
                     && Scan_OpenDS( pUserMem, &pUserMem->DataSource) 
                     //&& Scan_SetCapabilities( pUserMem )
                     && Scan_EnableDS( pUserMem, &TwUserInterface )) {
                
                    EnableWindow( GetDlgItem( hDlg, IDC_DATA_SOURCE ), FALSE );

                    hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)ScanningThread,
                        pUserMem,
                        0,
                        &ThreadId
                        );
                    if (hThread) {
                        CloseHandle( hThread );
                    }
                }                
            }
            break;

        case WM_DESTROY:
            if (pUserMem->TwainAvail) {
                TerminateTwain( pUserMem );
            }
            break;
        /* case WM_ACTIVATE:
            if (LOWORD(wParam) == WA_ACTIVE) {
                if (!pUserMem->TwainActive) {
                    EnableWindow( hDlg, TRUE );
                    return TRUE;
                }
            } */
            
    }

    return FALSE;
}

#endif


LPTSTR 
FormatTime(
    WORD Hour,
    WORD Minute,
    LPTSTR Buffer,
    DWORD BufferSize)
{
    SYSTEMTIME SystemTime;

    ZeroMemory(&SystemTime,sizeof(SystemTime));
    SystemTime.wHour = Hour;
    SystemTime.wMinute = Minute;
    GetTimeFormat(LOCALE_USER_DEFAULT,
                  TIME_NOSECONDS,
                  &SystemTime,
                  NULL,
                  Buffer,
                  BufferSize
                  );

    return Buffer;
}


INT_PTR
FinishWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the last wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PUSERMEM    pUserMem;    
    TCHAR       RecipientNameBuffer[64];
    TCHAR       RecipientNumberBuffer[64];
    TCHAR       TmpTimeBuffer[64];
    TCHAR       TimeBuffer[64];
    TCHAR       SendTimeBuffer[64];
    TCHAR       NoneBuffer[64];
    LPTSTR      SenderName;    
    TCHAR       CoverpageBuffer[64];
    LPTSTR      Coverpage;
    HKEY        hKey;

    if (! (pUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_FINISH)) )
        return FALSE;

    switch (message) {


    case WM_NOTIFY:
        if (((NMHDR *) lParam)->code != PSN_SETACTIVE) break;
    case WM_INITDIALOG:    
        LoadString(ghInstance,IDS_NONE,NoneBuffer,sizeof(NoneBuffer)/sizeof(TCHAR) );
        
        //
        // large title font on last page
        //
        SetWindowFont(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_READY), pUserMem->hLargeFont, TRUE);
        
        //
        // set the sender name if it exists
        //
        if ( (hKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO,TRUE) ) &&
             (SenderName = GetRegistryString(hKey,REGVAL_FULLNAME,TEXT("")) )
           ) {
                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, SenderName );
                EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),TRUE);
                MemFree(SenderName);
        } else {
                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, NoneBuffer );
                EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),FALSE);
        }

        //
        // set the recipient name
        //
        if (pUserMem->pRecipients && pUserMem->pRecipients->pNext) {
            //
            // more than one user, just put "Multiple" in the text
            //
            LoadString(ghInstance,IDS_MULTIPLE_RECIPIENTS,RecipientNameBuffer,sizeof(RecipientNameBuffer)/sizeof(TCHAR) );
            LoadString(ghInstance,IDS_MULTIPLE_RECIPIENTS,RecipientNumberBuffer,sizeof(RecipientNumberBuffer)/sizeof(TCHAR) );
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_TO, RecipientNameBuffer );
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_NUMBER, RecipientNumberBuffer );
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_TO),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_TO),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_NUMBER),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_NUMBER),FALSE);
        } else {
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_TO, pUserMem->pRecipients->pName );
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_NUMBER, pUserMem->pRecipients->pAddress );
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_TO),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_TO),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_NUMBER),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_NUMBER),TRUE);
        }

        //
        // when to send
        //
        switch (pUserMem->devmode.dmPrivate.whenToSend) {
        case SENDFAX_AT_TIME:
            LoadString(ghInstance,IDS_SEND_SPECIFIC,TmpTimeBuffer,sizeof(TmpTimeBuffer)/sizeof(TCHAR) );
            wsprintf(SendTimeBuffer,
                     TmpTimeBuffer,
                     FormatTime(pUserMem->devmode.dmPrivate.sendAtTime.Hour,
                                pUserMem->devmode.dmPrivate.sendAtTime.Minute,
                                TimeBuffer,
                                sizeof(TimeBuffer)) );
            break;
        case SENDFAX_AT_CHEAP:
            LoadString(ghInstance,IDS_SEND_DISCOUNT,SendTimeBuffer,sizeof(SendTimeBuffer)/sizeof(TCHAR) );
            break;
        case SENDFAX_ASAP:
            LoadString(ghInstance,IDS_SEND_ASAP,SendTimeBuffer,sizeof(SendTimeBuffer)/sizeof(TCHAR) );
        };
        
        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_TIME, SendTimeBuffer );

        //
        // Coverpage
        //
        if (pUserMem->devmode.dmPrivate.sendCoverPage) {
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),TRUE);
            
            //
            // format the coverpage for display to the user
            //

            // drop path
            Coverpage = _tcsrchr(pUserMem->coverPage,TEXT(PATH_SEPARATOR));
            if (!Coverpage) {
                Coverpage = pUserMem->coverPage;
            } else {
                Coverpage++;
            }
            _tcscpy(CoverpageBuffer,Coverpage);

            // crop file extension
            Coverpage = _tcschr(CoverpageBuffer,TEXT(FILENAME_EXT));
            
            if (Coverpage && *Coverpage) {
                *Coverpage = (TCHAR) NUL;
            }

            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, CoverpageBuffer );
            if (pUserMem->pSubject) {
                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, pUserMem->pSubject ); 
            } else {
                EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );
            }            
        } else {
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, NoneBuffer );
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );

            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
        }

        //
        // Billing Code
        //
        if (pUserMem->devmode.dmPrivate.billingCode[0]) {
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_BILLING), TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_BILLING),TRUE);
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_BILLING, pUserMem->devmode.dmPrivate.billingCode );
        } else {
            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_BILLING), FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_BILLING),        FALSE);
            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_BILLING, NoneBuffer );
        }

        return TRUE;

    default:
        return FALSE;        
    } ;

    return TRUE;
    
}

INT_PTR
WelcomeWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the last wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    
    PUSERMEM    pUserMem;    

    if (! (pUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_NEXT)))
        return FALSE;

    switch (message) {

    case WM_INITDIALOG:
        //
        // set the large fonts
        //
        SetWindowFont(GetDlgItem(hDlg,IDC_WIZ_WELCOME_TITLE), pUserMem->hLargeFont, TRUE);        

        //
        // show this text only if we're running the send wizard
        //
        if (!GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0)) {
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_FAXSEND) );
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_FAXSEND_CONT) );
        }

        return TRUE;
    } ;

    return FALSE;
}



BOOL
GetFakeRecipientInfo(
    PUSERMEM    pUserMem,
    DWORD       nRecipients
    )

/*++

Routine Description:

    Skip send fax wizard and get faked recipient information from the registry

Arguments:

    pUserMem - Points to the user mode memory structure
    nRecipients - Total number of faked recipient entries

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LPTSTR  pRecipientEntry;
    DWORD   index;
    TCHAR   buffer[MAX_STRING_LEN];
    BOOL    success = FALSE;
    HKEY    hRegKey;

    //
    // Retrieve information about the next fake recipient entry
    //

    Verbose(("Send Fax Wizard skipped...\n"));

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE))
        index = GetRegistryDword(hRegKey, REGVAL_STRESS_INDEX);
    else
        index = 0;

    if (index >= nRecipients)
        index = 0;

    wsprintf(buffer, TEXT("FakeRecipient%d"), index);
    pRecipientEntry = GetPrinterDataStr(pUserMem->hPrinter, buffer);

    if (hRegKey) {

        //
        // Update an index so that next time around we'll pick a different fake recipient
        //

        if (++index >= nRecipients)
            index = 0;

        SetRegistryDword(hRegKey, REGVAL_STRESS_INDEX, index);
        RegCloseKey(hRegKey);
    }

    //
    // Each fake recipient entry is a REG_MULTI_SZ of the following format:
    //  recipient name #1
    //  recipient fax number #1
    //  recipient name #2
    //  recipient fax number #2
    //  ...
    //

    if (pRecipientEntry) {

        __try {

            PRECIPIENT  pRecipient;
            LPTSTR      pName, pAddress, p = pRecipientEntry;

            while (*p) {

                pName = p;
                pAddress = pName + _tcslen(pName) + 1;
                p = pAddress + _tcslen(pAddress) + 1;

                pRecipient = MemAllocZ(sizeof(RECIPIENT));
                pName = DuplicateString(pName);

                pAddress = DuplicateString(pAddress);

                if (!pRecipient || !pName || !pAddress) {

                    Error(("Invalid fake recipient information\n"));
                    MemFree(pRecipient);
                    MemFree(pName);
                    MemFree(pAddress);
                    break;
                }

                pRecipient->pNext = pUserMem->pRecipients;
                pUserMem->pRecipients = pRecipient;
                pRecipient->pName = pName;
                pRecipient->pAddress = pAddress;
            }

        } __finally {

            if (success = (pUserMem->pRecipients != NULL)) {

                //
                // Determine whether a cover page should be used
                //

                LPTSTR  pCoverPage;

                pCoverPage = GetPrinterDataStr(pUserMem->hPrinter, TEXT("FakeCoverPage"));

                if (pUserMem->devmode.dmPrivate.sendCoverPage = (pCoverPage != NULL))
                    CopyString(pUserMem->coverPage, pCoverPage, MAX_PATH);

                MemFree(pCoverPage);
            }
        }
    }

    MemFree(pRecipientEntry);
    return success;
}



BOOL
SendFaxWizard(
    PUSERMEM    pUserMem
    )

/*++

Routine Description:

    Present the Send Fax Wizard to the user. This is invoked
    during CREATEDCPRE document event.

Arguments:

    pUserMem - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error or the user pressed Cancel.

--*/
#ifdef FAX_SCAN_ENABLED
    #define NUM_PAGES   6   // Number of wizard pages
#else
    #define NUM_PAGES   5   // Number of wizard pages
#endif

{
    PROPSHEETPAGE  *ppsp;
    PROPSHEETHEADER psh;
    INT             result;
    DWORD           nRecipients;
    HDC             hdc;
    int             i;
    LOGFONT         LargeFont;
    NONCLIENTMETRICS ncm = {0};
    TCHAR           FontName[100];
    TCHAR           FontSize[30];
    int             iFontSize;
    DWORD           ThreadId;
    HANDLE          hThread;
    

    Assert(pUserMem->pRecipients == NULL);

    //
    // A shortcut to skip fax wizard for debugging/testing purposes
    //

    if (nRecipients = GetPrinterDataDWord(pUserMem->hPrinter, TEXT("FakeRecipientCount"), 0))
        return GetFakeRecipientInfo(pUserMem, nRecipients);

    Verbose(("Presenting Send Fax Wizard...\n"));

    if (! (ppsp = MemAllocZ(sizeof(PROPSHEETPAGE) * NUM_PAGES))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // fire off a thread to do some slow stuff later on in the wizard.
    //
    pUserMem->hFaxSvcEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    pUserMem->hTapiEvent   = CreateEvent(NULL,FALSE,FALSE,NULL);
#ifdef FAX_SCAN_ENABLED
    pUserMem->hTwainEvent  = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (!pUserMem->hFaxSvcEvent || !pUserMem->hTapiEvent || !pUserMem->hTwainEvent) {
       Error(("CreateEvent for async events failed\n"));
       return FALSE;
    }
#else
    if (!pUserMem->hFaxSvcEvent || !pUserMem->hTapiEvent) {
       Error(("CreateEvent for async events failed\n"));
       return FALSE;
    }
#endif
    


    hThread = CreateThread(NULL,0,AsyncWizardThread,pUserMem,0,&ThreadId);
    if (hThread) {
       CloseHandle(hThread);
    } else {
       return FALSE;
    }

    //
    // Fill out one PROPSHEETPAGE structure for every page:
    //  The first page is a welcome page
    //  The first page is for choose the fax recipient
    //  The second page is for choosing cover page, subject and note
    //  The third page is for entering time to send and other options
    //  The fourth page is for scanning pages
    //  The last page gives the user a chance to confirm or cancel the dialog
    //

    FillInPropertyPage( ppsp,   IDD_WIZARD_WELCOME,    WelcomeWizProc,    pUserMem ,0,0);
    FillInPropertyPage( ppsp+1, IDD_WIZARD_CHOOSE_WHO, RecipientWizProc,  pUserMem ,IDS_WIZ_RECIPIENT_TITLE,IDS_WIZ_RECIPIENT_SUB);

    //
    // set second page title correctly if we're running as faxsend or from file print
    if (!GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0)) {
        FillInPropertyPage( ppsp+2, IDD_WIZARD_CHOOSE_CP,  CoverPageWizProc,  pUserMem ,IDS_WIZ_COVERPAGE_TITLE_2,IDS_WIZ_COVERPAGE_SUB_2 );
    }
    else {
        FillInPropertyPage( ppsp+2, IDD_WIZARD_CHOOSE_CP,  CoverPageWizProc,  pUserMem ,IDS_WIZ_COVERPAGE_TITLE_1,IDS_WIZ_COVERPAGE_SUB_1 );
    }


#ifdef FAX_SCAN_ENABLED
    FillInPropertyPage( ppsp+3, IDD_WIZARD_SCAN,       ScanWizProc,       pUserMem ,IDS_WIZ_SCAN_TITLE,IDS_WIZ_SCAN_SUB);
    FillInPropertyPage( ppsp+4, IDD_WIZARD_FAXOPTS,    FaxOptsWizProc,    pUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
    FillInPropertyPage( ppsp+5, IDD_WIZARD_CONGRATS,   FinishWizProc,     pUserMem ,0,0);
#else
    FillInPropertyPage( ppsp+3, IDD_WIZARD_FAXOPTS,    FaxOptsWizProc,    pUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
    FillInPropertyPage( ppsp+4, IDD_WIZARD_CONGRATS,   FinishWizProc,     pUserMem ,0,0);
#endif

    //
    // Fill out the PROPSHEETHEADER structure
    //

    ZeroMemory(&psh, sizeof(psh));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    psh.hwndParent = GetActiveWindow();
    psh.hInstance = ghInstance;
    psh.hIcon = NULL;
    psh.pszCaption = TEXT("");
    psh.nPages = NUM_PAGES;
    psh.nStartPage = 0;
    psh.ppsp = ppsp;
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK);
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK_16);

    if(hdc = GetDC(NULL)) {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8) {
            psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK_256);
        }
        ReleaseDC(NULL,hdc);
    }

    
    //
    // get the large fonts for wizard97
    // 
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    CopyMemory((LPVOID* )&LargeFont,(LPVOID *) &ncm.lfMessageFont,sizeof(LargeFont) );

    
    LoadString(ghInstance,IDS_LARGEFONT_NAME,FontName,sizeof(FontName)/sizeof(TCHAR) );
    LoadString(ghInstance,IDS_LARGEFONT_SIZE,FontSize,sizeof(FontSize)/sizeof(TCHAR) );

    iFontSize = _tcstoul( FontSize, NULL, 10 );

    // make sure we at least have some basic font
    if (*FontName == 0 || iFontSize == 0) {
        lstrcpy(FontName,TEXT("MS Shell Dlg") );
        iFontSize = 18;
    }

    lstrcpy(LargeFont.lfFaceName, FontName);        
    LargeFont.lfWeight   = FW_BOLD;

    if (hdc = GetDC(NULL)) {
        LargeFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * iFontSize / 72);
        pUserMem->hLargeFont = CreateFontIndirect(&LargeFont);
        ReleaseDC( NULL, hdc);
    }


    //
    // Display the wizard pages
    //    
    if (PropertySheet(&psh) > 0)
        result = pUserMem->finishPressed;
    else
        result = FALSE;

    //
    // Cleanup properly before exiting
    //

    //
    // free headings
    //    
    for (i = 0; i< NUM_PAGES; i++) {
        MemFree( (PVOID)(ppsp+i)->pszHeaderTitle );
        MemFree( (PVOID)(ppsp+i)->pszHeaderSubTitle );
    }

    if (pUserMem->lpWabInit) {

        UnInitializeWAB( pUserMem->lpWabInit);
    }

    DeinitTapiService();
    MemFree(ppsp);

    DeleteObject(pUserMem->hLargeFont);

    FreeCoverPageInfo(pUserMem->pCPInfo);
    pUserMem->pCPInfo = NULL;

#ifdef FAX_SCAN_ENABLED
    //
    // if the user pressed cancel, cleanup leftover scanned file.
    //
    if (!pUserMem->finishPressed && pUserMem->TwainAvail && pUserMem->FileName) {
        DeleteFile( pUserMem->FileName ) ;
        SetEnvironmentVariable( L"ScanTifName", NULL );        
    }
#endif

    Verbose(("Wizard finished...\n"));
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\tapiutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.c

Abstract:

    Utility functions for working with TAPI

Environment:

    Windows NT fax driver user interface

Revision History:

    09/18/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "tapiutil.h"

//
// Global variables used for accessing TAPI services
//

static INT               tapiRefCount = 0;
static HLINEAPP          tapiLineApp = 0;
static DWORD             tapiVersion = 0x00020000; //TAPI_CURRENT_VERSION;
static LPLINECOUNTRYLIST pLineCountryList = NULL;



BOOL
GetCountries(
    VOID
    )

/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

NOTE:

    We cache the result of lineGetCountry here since it's incredibly slow.
    This function must be invoked inside a critical section since it updates
    globally shared information.

--*/

#define INITIAL_SIZE_ALL_COUNTRY    22000

{
    DWORD   cbNeeded;
    LONG    status;
    INT     repeatCnt = 0;

    if (pLineCountryList == NULL) {

        //
        // Initial buffer size
        //

        cbNeeded = INITIAL_SIZE_ALL_COUNTRY;

        while (TRUE) {

            MemFree(pLineCountryList);

            if (! (pLineCountryList = MemAlloc(cbNeeded))) {

                Error(("Memory allocation failed\n"));
                break;
            }

            pLineCountryList->dwTotalSize = cbNeeded;
            status = lineGetCountryW(0, tapiVersion, pLineCountryList);

            if ((pLineCountryList->dwNeededSize > pLineCountryList->dwTotalSize) &&
                (status == NO_ERROR ||
                 status == LINEERR_STRUCTURETOOSMALL ||
                 status == LINEERR_NOMEM) &&
                (repeatCnt++ == 0))
            {
                cbNeeded = pLineCountryList->dwNeededSize + 1;
                Warning(("LINECOUNTRYLIST size: %d\n", cbNeeded));
                continue;
            }

            if (status != NO_ERROR) {

                Error(("lineGetCountry failed: %x\n", status));
                MemFree(pLineCountryList);
                pLineCountryList = NULL;

            } else
                Verbose(("Number of countries: %d\n", pLineCountryList->dwNumCountries));

            break;
        }
    }

    return pLineCountryList != NULL;
}



VOID CALLBACK
TapiLineCallback(
    DWORD     hDevice,
    DWORD     dwMessage,
    ULONG_PTR dwInstance,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    ULONG_PTR dwParam3
    )

/*++

Routine Description:

    TAPI line callback function: Even though we don't actually have anything
    to do here, we must provide a callback function to keep TAPI happy.

Arguments:

    hDevice     - Line or call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO index
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    NONE

--*/

{
}



BOOL
InitTapiService(
    VOID
    )

/*++

Routine Description:

    Initialize the TAPI service if necessary

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Every call to this function must be balanced by a call to DeinitTapiService.

--*/

{
    EnterDrvSem();
    tapiRefCount++;

    //
    // Perform TAPI initialization if necessary
    //

    if (!tapiLineApp) {

        DWORD   nLineDevs;
        LONG    status;
        LINEINITIALIZEEXPARAMS lineInitParams;

        ZeroMemory(&lineInitParams, sizeof(lineInitParams));
        lineInitParams.dwTotalSize =
        lineInitParams.dwNeededSize =
        lineInitParams.dwUsedSize = sizeof(lineInitParams);

        status = lineInitializeExW(&tapiLineApp,
                                   ghInstance,
                                   TapiLineCallback,
                                   L"Fax Configuration",
                                   &nLineDevs,
                                   &tapiVersion,
                                   &lineInitParams);

        if (status != NO_ERROR) {

            Error(("lineInitializeEx failed: %x\n", status));
            tapiLineApp = 0;
        }
    }

    //
    // Get the list of countries from TAPI and cache it
    //

    if (tapiLineApp && !pLineCountryList) {

        DWORD   startTimer;

        startTimer = GetCurrentTime();
        GetCountries();
        Verbose(("lineGetCountryW took %d milliseconds\n", GetCurrentTime() - startTimer));
    }

    LeaveDrvSem();

    if (! tapiLineApp)
        Error(("TAPI initialization failed\n"));

    return tapiLineApp ? TRUE : FALSE;
}



VOID
DeinitTapiService(
    VOID
    )

/*++

Routine Description:

    Deinitialize the TAPI service if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    EnterDrvSem();

    if (tapiRefCount > 0 && --tapiRefCount == 0) {

        if (tapiLineApp) {

            lineShutdown(tapiLineApp);
            tapiLineApp = 0;
        }

        MemFree(pLineCountryList);
        pLineCountryList = NULL;
    }

    LeaveDrvSem();
}



DWORD
GetDefaultCountryID(
    VOID
    )

/*++

Routine Description:

    Return the default country ID for the current location

Arguments:

    NONE

Return Value:

    The current ID for the current location

--*/

{
    //
    // We assume the correct information has already been saved to the
    // registry during the installation process.
    //

    return 0;
}



LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    )

/*++

Routine Description:

    Get a list of locations from TAPI

Arguments:

    NONE

Return Value:

    Pointer to a LINETRANSLATECAPS structure,
    NULL if there is an error

--*/

#define INITIAL_LINETRANSLATECAPS_SIZE  5000

{
    DWORD               cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;
    LONG                status;
    INT                 repeatCnt = 0;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;

    if (!tapiLineApp)
        return NULL;

    while (TRUE) {

        //
        // Free any existing buffer and allocate a new one with larger size
        //

        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = MemAlloc(cbNeeded))) {

            Error(("Memory allocation failed\n"));
            return NULL;
        }

        //
        // Get the LINETRANSLATECAPS structure from TAPI
        //

        pTranslateCaps->dwTotalSize = cbNeeded;
        status = lineGetTranslateCapsW(tapiLineApp, tapiVersion, pTranslateCaps);

        //
        // try to bring up UI if there are no locations.
        // 
        if (status == LINEERR_INIFILECORRUPT) {
            if (lineTranslateDialog( tapiLineApp, 0, tapiVersion, hWnd, NULL )) {
                MemFree(pTranslateCaps);
                return NULL;
            }
            continue;
        }

        //
        // Retry if our initial estimated buffer size was too small
        //

        if ((pTranslateCaps->dwNeededSize > pTranslateCaps->dwTotalSize) &&
            (status == NO_ERROR ||
             status == LINEERR_STRUCTURETOOSMALL ||
             status == LINEERR_NOMEM) &&
            (repeatCnt++ == 0))
        {
            cbNeeded = pTranslateCaps->dwNeededSize;
            Warning(("LINETRANSLATECAPS size: %d\n", cbNeeded));
            continue;
        }

        break;
    }

    if (status != NO_ERROR) {

        Error(("lineGetTranslateCaps failed: %x\n", status));
        MemFree(pTranslateCaps);
        pTranslateCaps = NULL;
    }

    return pTranslateCaps;
}



BOOL
SetCurrentLocation(
    DWORD   locationID
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    locationID - The permanant ID for the new default TAPI location

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (tapiLineApp && (lineSetCurrentLocation(tapiLineApp, locationID) == NO_ERROR))
    {
        Verbose(("Current location changed: ID = %d\n", locationID));
        return TRUE;

    } else {

        Error(("Couldn't change current TAPI location\n"));
        return FALSE;
    }
}



LPLINECOUNTRYENTRY
FindCountry(
    DWORD   countryId
    )

/*++

Routine Description:

    Find the specified country from a list of all countries and
    return a pointer to the corresponding LINECOUNTRYENTRY structure

Arguments:

    countryId - Specifies the country ID we're interested in

Return Value:

    Pointer to a LINECOUNTRYENTRY structure corresponding to the specified country ID
    NULL if there is an error

--*/

{
    LPLINECOUNTRYENTRY  pEntry;
    DWORD               index;

    if (pLineCountryList == NULL || countryId == 0)
        return NULL;

    //
    // Look at each LINECOUNTRYENTRY structure and compare its country ID with
    // the specified country ID
    //

    pEntry = (LPLINECOUNTRYENTRY)
        ((PBYTE) pLineCountryList + pLineCountryList->dwCountryListOffset);

    for (index=0; index < pLineCountryList->dwNumCountries; index++, pEntry++) {

        if (pEntry->dwCountryID == countryId)
            return pEntry;
    }

    return NULL;
}



INT
AreaCodeRules(
    LPLINECOUNTRYENTRY  pEntry
    )

/*++

Routine Description:

    Given a LINECOUNTRYENTRY structure, determine if area code is needed in that country

Arguments:

    pEntry - Points to a LINECOUNTRYENTRY structure

Return Value:

    AREACODE_DONTNEED - Area code is not used in the specified country
    AREACODE_OPTIONAL - Area code is optional in the specified country
    AREACODE_REQUIRED - Area code is required in the specified country

--*/

{
    if ((pEntry != NULL) &&
        (pEntry->dwLongDistanceRuleSize != 0) &&
        (pEntry->dwLongDistanceRuleOffset != 0))
    {
        LPTSTR  pLongDistanceRule;

        //
        // Get the long distance rules for the specified country
        //

        Assert(pLineCountryList != NULL);

        pLongDistanceRule = (LPTSTR)
            ((PBYTE) pLineCountryList + pEntry->dwLongDistanceRuleOffset);

        //
        // Area code is required in this country
        //

        if (_tcschr(pLongDistanceRule, TEXT('F')) != NULL)
            return AREACODE_REQUIRED;

        //
        // Area code is not needed in this country
        //

        if (_tcschr(pLongDistanceRule, TEXT('I')) == NULL)
            return AREACODE_DONTNEED;
    }

    //
    // Default case: area code is optional in this country
    //

    return AREACODE_OPTIONAL;
}



VOID
AssemblePhoneNumber(
    LPTSTR  pAddress,
    DWORD   countryCode,
    LPTSTR  pAreaCode,
    LPTSTR  pPhoneNumber
    )

/*++

Routine Description:

    Assemble a canonical phone number given the following:
        country code, area code, and phone number

Arguments:

    pAddress - Specifies a buffer to hold the resulting fax address
    countryCode - Specifies the country code
    pAreaCode - Specifies the area code string
    pPhoneNumber - Specifies the phone number string

Return Value:

    NONE

Note:

    We assume the caller has allocated a large enough destination buffer.

--*/

{
    //
    // Country code if neccessary
    //

    if (countryCode != 0) {

        *pAddress++ = TEXT('+');
        wsprintf(pAddress, TEXT("%d "), countryCode);
        pAddress += _tcslen(pAddress);
    }

    //
    // Area code if necessary
    //

    if (pAreaCode && !IsEmptyString(pAreaCode)) {

        if (countryCode != 0)
            *pAddress++ = TEXT('(');

        _tcscpy(pAddress, pAreaCode);
        pAddress += _tcslen(pAddress);

        if (countryCode != 0)
            *pAddress++ = TEXT(')');

        *pAddress++ = TEXT(' ');
    }

    //
    // Phone number at last
    //

    Assert(pPhoneNumber != NULL);
    _tcscpy(pAddress, pPhoneNumber);
}



VOID
UpdateAreaCodeField(
    HWND    hwndAreaCode,
    DWORD   countryId
    )

/*++

Routine Description:

    Update any area code text field associated with a country list box

Arguments:

    hwndAreaCode - Specifies the text field associated with the country list box
    countryId - Currently selected country ID

Return Value:

    NONE

--*/

{
    static TCHAR AreaCode[11] = TEXT("");
    static BOOL  bGetAreaCode = TRUE;

    if (hwndAreaCode == NULL)
        return;

    if ((countryId == -1) || (AreaCodeRules(FindCountry(countryId)) == AREACODE_DONTNEED)) {
        if (bGetAreaCode == TRUE) {
            bGetAreaCode = FALSE;
            SendMessage(hwndAreaCode, WM_GETTEXT, sizeof(AreaCode) / sizeof(TCHAR), (LPARAM) AreaCode);
        }
        SendMessage(hwndAreaCode, WM_SETTEXT, 0, (LPARAM) TEXT(""));
        EnableWindow(hwndAreaCode, FALSE);

    } else {
        EnableWindow(hwndAreaCode, TRUE);
        if (bGetAreaCode == FALSE) {
            bGetAreaCode = TRUE;
            SendMessage(hwndAreaCode, WM_SETTEXT, 0, (LPARAM) AreaCode);
        }
    }
}



VOID
InitCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode,
    DWORD   countryId
    )

/*++

Routine Description:

    Initialize the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field
    countryId - Initially selected country ID

Return Value:

    NONE

--*/

#define MAX_COUNTRY_NAME    256

{
    DWORD               index;
    TCHAR               buffer[MAX_COUNTRY_NAME];
    LPLINECOUNTRYENTRY  pEntry;

    //
    // Disable redraw on the list box and reset its content
    //

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Loop through LINECOUNTRYENTRY structures and add the available selections to
    // the country list box.
    //

    if (pLineCountryList != NULL) {

        pEntry = (LPLINECOUNTRYENTRY)
            ((PBYTE) pLineCountryList + pLineCountryList->dwCountryListOffset);

        for (index=0; index < pLineCountryList->dwNumCountries; index++, pEntry++) {

            if (pEntry->dwCountryNameSize && pEntry->dwCountryNameOffset) {

                wsprintf(buffer, TEXT("%s (%d)"),
                         (PBYTE) pLineCountryList + pEntry->dwCountryNameOffset,
                         pEntry->dwCountryCode);

                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer),
                            pEntry->dwCountryID);
            }
        }
    }

    //
    // Insert None as the very first selection
    //

    //LoadString(ghInstance, IDS_NO_COUNTRY, buffer, MAX_COUNTRY_NAME);
    //SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) buffer);
    //SendMessage(hwndList, CB_SETITEMDATA, 0, 0);

    //
    // Figure out which item in the list should be selected
    //

    if (pLineCountryList != NULL) {

        for (index=0; index <= pLineCountryList->dwNumCountries; index++) {

            if ((DWORD) SendMessage(hwndList, CB_GETITEMDATA, index, 0) == countryId)
                break;
        }

        if (index > pLineCountryList->dwNumCountries)
            index = countryId = 0;

    } else
        index = countryId = 0;

    SendMessage(hwndList, CB_SETCURSEL, index, 0);
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    //
    // Update the associated area code text field
    //
    //UpdateAreaCodeField(hwndAreaCode, countryId);
}



VOID
SelChangeCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode
    )

/*++

Routine Description:

    Handle dialog selection changes in the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field

Return Value:

    NONE

--*/

{
    UpdateAreaCodeField(hwndAreaCode, GetCountryListBoxSel(hwndList));
}



DWORD
GetCountryListBoxSel(
    HWND    hwndList
    )

/*++

Routine Description:

    Return the current selection of country list box

Arguments:

    hwndList - Handle to the country list box window

Return Value:

    Currently selected country ID

--*/

{
    INT msgResult;

    if ((msgResult = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR ||
        (msgResult = (INT)SendMessage(hwndList, CB_GETITEMDATA, msgResult, 0)) == CB_ERR)
    {
        return -1;
    }

    return msgResult;
}

BOOL
DoTapiProps(
    HWND hDlg
    )
{
    SHELLEXECUTEINFO shellExeInfo = {
         sizeof(SHELLEXECUTEINFO),
         SEE_MASK_NOCLOSEPROCESS,
         hDlg,
         L"Open",
         L"rundll32",
         L"shell32.dll,Control_RunDLL  telephon.cpl",
         NULL,
         SW_SHOWNORMAL,
    };

    //
    // if they said yes, then launch the control panel applet
    //
    if (!ShellExecuteEx(&shellExeInfo)) {
       DisplayMessageDialog(hDlg, 0, 0, IDS_ERR_TAPI_CPL_LAUNCH);
       return FALSE;
    }

    WaitForSingleObject( shellExeInfo.hProcess, INFINITE );
    CloseHandle( shellExeInfo.hProcess ) ;

    return TRUE;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxui\prnevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnevent.c

Abstract:

    Implementation of DrvPrinterEvent

Environment:

    Fax driver user interface

Revision History:

    05/10/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include <gdispool.h>
#include <winsprlp.h>


typedef BOOL (WINAPI *PFAXPOINTPRINTINSTALL)(LPWSTR,LPWSTR);





LPTSTR
GetFaxServerDirectory(
    LPTSTR ServerName
    )
/*++

Routine Description:

    Find the directory containing the client setup software

Arguments:

    pServerName - Specifies the name of the print/fax server

Return Value:

    Pointer to name of the directory containing the client setup software
    NULL if there is an error

--*/

#define FAX_SHARE_NAME   TEXT("\\Fax$\\")

{

    LPTSTR Dir = MemAllocZ( SizeOfString(ServerName) + SizeOfString(FAX_SHARE_NAME) + 16 );
    if (Dir) {
        _tcscpy( Dir, ServerName );
        _tcscat( Dir, FAX_SHARE_NAME );
    }

    return Dir;
}



LPTSTR
GetClientSetupDir(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    )

/*++

Routine Description:

    Find the directory containing the client setup software

Arguments:

    pServerName - Specifies the name of the print server
    pEnvironment - Specifies the client's machine architecture

Return Value:

    Pointer to name of the directory containing the client setup software
    NULL if there is an error

--*/

#define DRIVERENV_I386      TEXT("Windows NT x86")
#define DRIVERENV_ALPHA     TEXT("Windows NT Alpha_AXP")

#define ARCHSUFFIX_I386     TEXT("Clients\\i386\\")
#define ARCHSUFFIX_ALPHA    TEXT("Clients\\alpha\\")


{
    LPTSTR  pClientDir, pServerDir, pArchSuffix;

    //
    // Determine the client machine's architecture
    //

    pClientDir = pServerDir = pArchSuffix = NULL;

    if (pEnvironment != NULL) {

        if (_tcsicmp(pEnvironment, DRIVERENV_I386) == EQUAL_STRING)
            pArchSuffix = ARCHSUFFIX_I386;
        else if (_tcsicmp(pEnvironment, DRIVERENV_ALPHA) == EQUAL_STRING)
            pArchSuffix = ARCHSUFFIX_ALPHA;
    }

    if (pArchSuffix == NULL) {

        Error(("Bad driver envirnment: %ws\n", pEnvironment));
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return NULL;
    }

    //
    // Get the server name and the driver directory on the server
    //

    if ((pServerName != NULL) &&
        (pServerDir = GetFaxServerDirectory(pServerName)) &&
        (pClientDir = MemAllocZ(SizeOfString(pServerDir) + SizeOfString(pArchSuffix))))
    {
        //
        // Copy the server driver directory string and truncate the last component
        //

        _tcscpy(pClientDir, pServerDir);
        _tcscat(pClientDir, pArchSuffix);

        Verbose(("Fax client setup directory: %ws\n", pClientDir));
    }

    MemFree(pServerDir);

    return pClientDir;
}



BOOL
IsMetricCountry(
    VOID
    )

/*++

Routine Description:

    Determine if the current country is using metric system.

Arguments:

    NONE

Return Value:

    TRUE if the current country uses metric system, FALSE otherwise

--*/

{
    INT     cch;
    PVOID   pstr = NULL;
    LONG    countryCode = CTRY_UNITED_STATES;

    //
    // Determine the size of the buffer needed to retrieve locale information.
    // Allocate the necessary space.
    //
    //

    if ((cch = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, NULL, 0)) > 0 &&
        (pstr = MemAlloc(sizeof(TCHAR) * cch)) &&
        (cch == GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, pstr, cch)))
    {
        countryCode = _ttol(pstr);
    }

    MemFree(pstr);
    Verbose(("Default country code: %d\n", countryCode));

    //
    // This is the Win31 algorithm based on AT&T international dialing codes.
    //

    return ((countryCode == CTRY_UNITED_STATES) ||
            (countryCode == CTRY_CANADA) ||
            (countryCode >=  50 && countryCode <  60) ||
            (countryCode >= 500 && countryCode < 600)) ? FALSE : TRUE;
}



BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    int     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
)

/*++

Routine Description:

    Implementation of DrvPrinterEvent entrypoint

Arguments:

    pPrinterName - Specifies the name of the printer involved
    DriverEvent - Specifies what happened
    Flags - Specifies misc. flag bits
    lParam - Event specific parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/

#define FaxClientSetupError(errMesg) { \
            Error(("%s failed: %d\n", errMesg, GetLastError())); \
            status = IDS_FAXCLIENT_SETUP_FAILED; \
            goto ExitDrvPrinterEvent; \
        }

{
    HKEY                    hRegKey = NULL;
    HANDLE                  hPrinter = NULL;
    PDRIVER_INFO_2          pDriverInfo2 = NULL;
    PPRINTER_INFO_2         pPrinterInfo2 = NULL;
    HINSTANCE               hInstFaxOcm = NULL;
    PFAXPOINTPRINTINSTALL   FaxPointPrintInstall = NULL;
    LPTSTR                  pClientSetupDir = NULL;
    INT                     status = 0;
    TCHAR                   FaxOcmPath[MAX_PATH];
    TCHAR                   DestPath[MAX_PATH];


    Verbose(("DrvPrinterEvent: %d\n", DriverEvent));

    DestPath[0] = 0;

    //
    // Ignore any event other than Initialize and AddConnection
    //

    if (DriverEvent == PRINTER_EVENT_INITIALIZE) {

        static PRINTER_DEFAULTS printerDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
        HANDLE  hPrinter;

        if (OpenPrinter(pPrinterName, &hPrinter, &printerDefault)) {

            SetPrinterDataDWord(hPrinter, PRNDATA_ISMETRIC, IsMetricCountry());
            ClosePrinter(hPrinter);

        } else
            Error(("OpenPrinter failed: %d\n", GetLastError()));

    } else if (DriverEvent == PRINTER_EVENT_ADD_CONNECTION) {


        if (Flags & PRINTER_EVENT_FLAG_NO_UI)
            Error(("PRINTER_EVENT_FLAG_NO_UI set!\n"));

        //
        // Check if client installation was ever done before
        //

        if (! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE))) {

            Error(("GetUserInfoRegKey failed: %d\n", GetLastError()));
            status = IDS_FAXCLIENT_SETUP_FAILED;

        } else if (! GetRegistryDword(hRegKey, REGVAL_FAXINSTALLED)) {

            if (! OpenPrinter(pPrinterName, &hPrinter, NULL) ||
                ! (pDriverInfo2 = MyGetPrinterDriver(hPrinter, 2)) ||
                ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)))
            {
                FaxClientSetupError("OpenPrinter");
            }

            //
            // Locate faxocm.dll and load it into memory
            //

            if (!(pClientSetupDir = GetClientSetupDir(pPrinterInfo2->pServerName,pDriverInfo2->pEnvironment))) {
                FaxClientSetupError("GetClientSetupDir");
            }

            _tcscpy( FaxOcmPath, pClientSetupDir );
            _tcscat( FaxOcmPath, TEXT("faxocm.dll") );

            GetTempPath( sizeof(DestPath)/sizeof(TCHAR), DestPath );
            if (DestPath[_tcslen(DestPath)-1] != TEXT('\\')) {
                _tcscat( DestPath, TEXT("\\") );
            }
            _tcscat( DestPath, TEXT("faxocm.dll") );

            if (!CopyFile( FaxOcmPath, DestPath, FALSE )) {
                FaxClientSetupError("CopyFile");
            }

            if (!(hInstFaxOcm = LoadLibrary(DestPath))) {
                FaxClientSetupError("LoadLibrary");
            }

            FaxPointPrintInstall = (PFAXPOINTPRINTINSTALL) GetProcAddress(hInstFaxOcm, "FaxPointPrintInstall");
            if (FaxPointPrintInstall == NULL) {
                FaxClientSetupError("GetProcAddress");
            }

            //
            // Find the directory containing the client setup software
            // and then run the install procedure in faxocm.dll
            //

            if (!FaxPointPrintInstall(pClientSetupDir, pPrinterName))
            {
                FaxClientSetupError("GetClientSetupDir");

            } else {

                //
                // Indicate the client setup has been run
                //

                SetRegistryDword(hRegKey, REGVAL_FAXINSTALLED, 1);
            }
        }

    ExitDrvPrinterEvent:

        //
        // Cleanup properly before returning
        //

        if (status != 0) {

            DeletePrinterConnection(pPrinterName);
            DisplayMessageDialog(NULL, 0, 0, status);
        }

        MemFree(pClientSetupDir);
        MemFree(pDriverInfo2);
        MemFree(pPrinterInfo2);

        if (hInstFaxOcm)
            FreeLibrary(hInstFaxOcm);

        if (hPrinter)
            ClosePrinter(hPrinter);

        if (hRegKey)
            RegCloseKey(hRegKey);

        if (DestPath[0])
            DeleteFile( DestPath );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\faxlib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxlib.h

Abstract:

    Fax driver library header file

Environment:

        Fax driver, kernel and user mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXLIB_H_
#define _FAXLIB_H_

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <tchar.h>
#include <shlobj.h>

#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <faxreg.h>

#define FAXUTIL_ADAPTIVE
#define FAXUTIL_DEBUG
#include <faxutil.h>


#else   // !KERNEL_MODE

#include <winddi.h>

#ifdef USERMODE_DRIVER
    
#include <windows.h>
#include <winspool.h>

#endif

#endif


#ifndef _FAXAPI_
typedef struct _FAX_TIME {
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;
#endif

#include "devmode.h"
#include "prndata.h"
#include "registry.h"

//
// Nul terminator for a character string
//

#define NUL             0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)

#define AllocString(cch)    MemAlloc(sizeof(TCHAR) * (cch))
#define AllocStringZ(cch)   MemAllocZ(sizeof(TCHAR) * (cch))

//
// Result of string comparison
//

#define EQUAL_STRING    0

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif

//
// Path separator character
//

#define PATH_SEPARATOR  '\\'

//
// Filename extension character
//

#define FILENAME_EXT    '.'

//
// Deal with the difference between user and kernel mode functions
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    #define WritePrinter        EngWritePrinter
    #define GetPrinterData      EngGetPrinterData
    #define EnumForms           EngEnumForms
    #define GetPrinter          EngGetPrinter
    #define GetForm             EngGetForm
    #define SetLastError        EngSetLastError
    #define GetLastError        EngGetLastError
    #define MulDiv              EngMulDiv
    
    #define MemAlloc(size)      EngAllocMem(0, size, DRIVER_SIGNATURE)
    #define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, DRIVER_SIGNATURE)
    #define MemFree(ptr)        { if (ptr) EngFreeMem(ptr); }

#else // !KERNEL_MODE

    #ifndef MemAlloc  
        #define MemAlloc(size)      ((PVOID) LocalAlloc(LPTR, (size)))
    #endif    
    #ifndef MemAllocZ 
        #define MemAllocZ(size)     ((PVOID) MemAlloc((size)))
    #endif
    #ifndef MemFree   
        #define MemFree(ptr)        { if (ptr) LocalFree((HLOCAL) (ptr)); }
    #endif        

#endif


//
// Copy Unicode or ANSI string from source to destination
//

VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    );

VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    );

#ifdef  UNICODE
#define CopyString  CopyStringW
#else   // !UNICODE
#define CopyString  CopyStringA
#endif

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Strip the directory prefix from a filename (ANSI version)
//

PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    );

//
// Wrapper function for GetPrinter spooler API
//

PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriver spooler API
//

PVOID
MyGetPrinterDriver(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriverDirectory spooler API
//

LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    );


//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  A variable which controls the amount of debug messages. To generate
//  lots of debug messages, enter the following line in the debugger:
//
//      ed _debugLevel 1
//
// Verbose
//  Display a debug message if VERBOSE is set to non-zero.
//
//      Verbose(("Entering XYZ: param = %d\n", param));
//
// Error
//  Display an error message along with the filename and the line number
//  to indicate where the error occurred.
//
//      Error(("XYZ failed"));
//
// ErrorIf
//  Display an error message if the specified condition is true.
//
//      ErrorIf(error != 0, ("XYZ failed: error = %d\n", error));
//
// Assert
//  Verify a condition is true. If not, force a breakpoint.
//
//      Assert(p != NULL && (p->flags & VALID));

#if DBG

extern ULONG __cdecl DbgPrint(CHAR *, ...);
extern INT _debugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
#define DbgBreakPoint EngDebugBreak
#else
extern VOID DbgBreakPoint(VOID);
#endif

#define Warning(arg) {\
            DbgPrint("WRN %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Error(arg) {\
            DbgPrint("ERR %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Verbose(arg) { if (_debugLevel > 0) DbgPrint arg; }
#define ErrorIf(cond, arg) { if (cond) Error(arg); }
#define Assert(cond) {\
            if (! (cond)) {\
                DbgPrint("ASSERT: file %s, line %d\n", StripDirPrefixA(__FILE__), __LINE__);\
                DbgBreakPoint();\
            }\
        }

#else   // !DBG

#define Verbose(arg)
#define ErrorIf(cond, arg)
#define Assert(cond)
#define Warning(arg)
#define Error(arg)

#endif

#endif  //!_FAXLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\registry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reguser.h

Abstract:

    For accessing information stored under registry key:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _REGISTRY_H_
#define _REGISTRY_H_

//
// Maximum length allowed for a string value (including the null terminator)
//

#define MAX_STRING_LEN      MAX_PATH

//
// Open a handle to the specified registry key
//

#define REG_READONLY    KEY_READ
#define REG_READWRITE   KEY_ALL_ACCESS

#define GetUserInfoRegKey(pKeyName, readOnly) \
        OpenRegistryKey(HKEY_CURRENT_USER, pKeyName, FALSE,readOnly)



//
// Get a EXPAND_SZ value from the user info registry key
//

LPTSTR
GetRegistryExpandStr(
    HKEY    hRootKey,
    LPTSTR  pKeyName,
    LPTSTR  pValueName
    );

//
// Get per-user devmode information
//

PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    );

//
// Save per-user devmode information
//

VOID
SavePerUserDevmode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDevmode
    );

//
// Find the cover page editor executable filename
//

LPTSTR
GetCoverPageEditor(
    VOID
    );

//
// Find the directories under which user cover pages are stored
//

LPTSTR
GetUserCoverPageDir(
    VOID
    );

#endif // !_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\faxdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdm.c

Abstract:

    Functions for dealing with devmodes

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    )

/*++

Routine Description:

    Return the driver's default devmode

Arguments:

    pdm - Specifies a buffer for storing driver default devmode
    pDeviceName - Points to device name string
    hPrinter - Handle to the printer object

Return Value:

    NONE

--*/

{
#ifndef KERNEL_MODE
    PDMPRIVATE dmPrivate;
    PDRVDEVMODE dmSource;    
#endif


    //
    // Default value for public devmode fields
    //

    memset(pdm, 0, sizeof(DRVDEVMODE));

    if (pDeviceName == NULL)
        pDeviceName = DRIVER_NAME;

    CopyString(pdm->dmPublic.dmDeviceName, pDeviceName, CCHDEVICENAME);

    pdm->dmPublic.dmDriverVersion = DRIVER_VERSION;
    pdm->dmPublic.dmSpecVersion = DM_SPECVERSION;
    pdm->dmPublic.dmSize = sizeof(DEVMODE);
    pdm->dmPublic.dmDriverExtra = sizeof(DMPRIVATE);

    pdm->dmPublic.dmFields = DM_ORIENTATION  |
                             DM_PAPERSIZE    |
                             DM_FORMNAME     |
                             DM_COPIES       |
                             DM_PRINTQUALITY |
                             DM_YRESOLUTION  |
                             DM_DEFAULTSOURCE;

    pdm->dmPublic.dmOrientation = DMORIENT_PORTRAIT;
    pdm->dmPublic.dmCopies = 1;
    pdm->dmPublic.dmScale = 100;
    pdm->dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
    pdm->dmPublic.dmYResolution = FAXRES_VERTICAL;
    pdm->dmPublic.dmDuplex = DMDUP_SIMPLEX;
    pdm->dmPublic.dmCollate = DMCOLLATE_FALSE;
    pdm->dmPublic.dmTTOption = DMTT_BITMAP;
    pdm->dmPublic.dmColor = DMCOLOR_MONOCHROME;
    pdm->dmPublic.dmDefaultSource = DMBIN_ONLYONE;

    if (hPrinter && GetPrinterDataDWord(hPrinter, PRNDATA_ISMETRIC, 0)) {

        pdm->dmPublic.dmPaperSize = DMPAPER_A4;
        CopyString(pdm->dmPublic.dmFormName, FORMNAME_A4, CCHFORMNAME);

    } else {

        pdm->dmPublic.dmPaperSize = DMPAPER_LETTER;
        CopyString(pdm->dmPublic.dmFormName, FORMNAME_LETTER, CCHFORMNAME);
    }

    //
    // Private devmode fields
    //
#ifdef KERNEL_MODE
    pdm->dmPrivate.signature = DRIVER_SIGNATURE;
    pdm->dmPrivate.flags = 0;
    pdm->dmPrivate.sendCoverPage = TRUE;
    pdm->dmPrivate.whenToSend = SENDFAX_ASAP;    
#else
    dmSource = (PDRVDEVMODE) GetPerUserDevmode(NULL);
    if (!dmSource) {
        //
        // default values
        //
        pdm->dmPrivate.signature = DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = 0;
        pdm->dmPrivate.sendCoverPage = TRUE;
        pdm->dmPrivate.whenToSend = SENDFAX_ASAP;    
    } else {
        dmPrivate = &dmSource->dmPrivate;
        pdm->dmPrivate.signature = dmPrivate->signature;//DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = dmPrivate->flags;// 0;
        pdm->dmPrivate.sendCoverPage = dmPrivate->sendCoverPage; //TRUE;
        pdm->dmPrivate.whenToSend = dmPrivate->whenToSend;//SENDFAX_ASAP;
        pdm->dmPrivate.sendAtTime = dmPrivate->sendAtTime;
        CopyString(pdm->dmPrivate.billingCode,dmPrivate->billingCode,MAX_BILLING_CODE);
        CopyString(pdm->dmPrivate.emailAddress,dmPrivate->emailAddress,MAX_EMAIL_ADDRESS);
        MemFree(dmSource);
    }
    
#endif
}



BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    )

/*++

Routine Description:

    Merge the source devmode into the destination devmode

Arguments:

    pdmDest - Specifies the destination devmode
    pdmSrc - Specifies the source devmode
    publicOnly - Only merge public portion of the devmode

Return Value:

    TRUE if successful, FALSE if the source devmode is invalid

[Note:]

    pdmDest must point to a valid current-version devmode

--*/

#define BadDevmode(reason) { Error(("Invalid DEVMODE: %s\n", reason)); valid = FALSE; }

{
    PDEVMODE    pdmIn, pdmOut, pdmAlloced = NULL;
    PDMPRIVATE  pdmPrivate;
    BOOL        valid = TRUE;

    //
    // If there is no source devmode, levae destination devmode untouched
    //

    if ((pdmIn = pdmSrc) == NULL)
        return TRUE;

    //
    // Convert source devmode to current version if necessary
    //

    if (! CurrentVersionDevmode(pdmIn)) {

        Warning(("Converting non-current version DEVMODE ...\n"));
        
        if (! (pdmIn = pdmAlloced = MemAlloc(sizeof(DRVDEVMODE)))) {
    
            Error(("Memory allocation failed\n"));
            return FALSE;
        }
    
        Assert(pdmDest->dmPublic.dmSize == sizeof(DEVMODE) &&
               pdmDest->dmPublic.dmDriverExtra == sizeof(DMPRIVATE));
    
        memcpy(pdmIn, pdmDest, sizeof(DRVDEVMODE));
    
        if (ConvertDevmode(pdmSrc, pdmIn) <= 0) {
    
            Error(("ConvertDevmode failed\n"));
            MemFree(pdmAlloced);
            return FALSE;
        }
    }

    //
    // If the input devmode is the same as the driver default,
    // there is no need to merge it.
    //

    pdmPrivate = &((PDRVDEVMODE) pdmIn)->dmPrivate;

    if (pdmPrivate->signature == DRIVER_SIGNATURE &&
        (pdmPrivate->flags & FAXDM_DRIVER_DEFAULT))
    {
        Verbose(("Merging driver default devmode.\n"));
    }
    else
    {

        //
        // Merge source devmode into destination devmode
        //

        pdmOut = &pdmDest->dmPublic;

        //
        // Device name: Always the same as printer name
        //

        // CopyString(pdmOut->dmDeviceName, pdmIn->dmDeviceName, CCHDEVICENAME);

        //
        // Orientation
        //

        if (pdmIn->dmFields & DM_ORIENTATION) {

            if (pdmIn->dmOrientation == DMORIENT_PORTRAIT ||
                pdmIn->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pdmOut->dmFields |= DM_ORIENTATION;
                pdmOut->dmOrientation = pdmIn->dmOrientation;

            } else
                BadDevmode("orientation");
        }

        //
        // Form selection
        //

        if (pdmIn->dmFields & DM_PAPERSIZE) {

            if (pdmIn->dmPaperSize >= DMPAPER_FIRST) {

                pdmOut->dmFields |= DM_PAPERSIZE;
                pdmOut->dmFields &= ~DM_FORMNAME;
                pdmOut->dmPaperSize = pdmIn->dmPaperSize;
                CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);

            } else
                BadDevmode("paper size");

        } else if (pdmIn->dmFields & DM_FORMNAME) {

            pdmOut->dmFields |= DM_FORMNAME;
            pdmOut->dmFields &= ~DM_PAPERSIZE;
            CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);
        }

        //
        // Copies
        //

        if (pdmIn->dmFields & DM_COPIES) {

            if (pdmIn->dmCopies > 0)
                pdmOut->dmCopies = pdmIn->dmCopies;
            else
                BadDevmode("copy count");
        }

        //
        // Paper source
        //

        if (pdmIn->dmFields & DM_DEFAULTSOURCE) {

            if (pdmIn->dmDefaultSource == DMBIN_ONLYONE) {

                pdmOut->dmFields |= DM_DEFAULTSOURCE;
                pdmOut->dmDefaultSource = pdmIn->dmDefaultSource;

            } else
                BadDevmode("paper source");
        }

        //
        // Print quality
        //

        if ((pdmIn->dmFields & DM_PRINTQUALITY) &&
            (pdmIn->dmPrintQuality != FAXRES_HORIZONTAL))
        {
            BadDevmode("print quality");
        }

        if (pdmIn->dmFields & DM_YRESOLUTION)
        {
            if (pdmIn->dmYResolution <= FAXRES_VERTDRAFT)
                pdmOut->dmYResolution = FAXRES_VERTDRAFT;
            else
                pdmOut->dmYResolution = FAXRES_VERTICAL;
        }

        //
        // Private devmode fields
        //

        Assert(pdmDest->dmPrivate.signature == DRIVER_SIGNATURE);

        if (pdmPrivate->signature == DRIVER_SIGNATURE) {

            if (! publicOnly)
                memcpy(&pdmDest->dmPrivate, pdmPrivate, sizeof(DMPRIVATE));

        } else
            BadDevmode("bad signature");
    }

    pdmDest->dmPrivate.flags &= ~FAXDM_DRIVER_DEFAULT;
    MemFree(pdmAlloced);
    return valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\devmode.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    devmode.c


Abstract:

    This module contains devmode conversion


Author:

    08-Jun-1995 Thu 13:47:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI printer drivers, user and kernel mode


[Notes:]


Revision History:

    11/09/95 -davidx-
        New conversion routines

--*/


#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <libproto.h>


//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

//
// size of a device name string
//

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _devicemode320A {
    BYTE    dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    BYTE    dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320A, *PDEVMODE320A, *NPDEVMODE320A, *LPDEVMODE320A;

typedef struct _devicemode320W {
    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320W, *PDEVMODE320W, *NPDEVMODE320W, *LPDEVMODE320W;



#ifdef UNICODE

typedef DEVMODE320W     DEVMODE320;
typedef PDEVMODE320W    PDEVMODE320;
typedef NPDEVMODE320W   NPDEVMODE320;
typedef LPDEVMODE320W   LPDEVMODE320;

#else

typedef DEVMODE320A     DEVMODE320;
typedef PDEVMODE320A    PDEVMODE320;
typedef NPDEVMODE320A   NPDEVMODE320;
typedef LPDEVMODE320A   LPDEVMODE320;

#endif // UNICODE


typedef struct _DMEXTRA400 {
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
} DMEXTRA400;


typedef struct _DMEXTRA401 {
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DMEXTRA401;


#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))

// Current version devmode size - public portion only

#ifdef  UNICODE
#define DM_SIZE_CURRENT sizeof(DEVMODEW)
#else
#define DM_SIZE_CURRENT sizeof(DEVMODEA)
#endif



WORD
CheckDevmodeVersion(
    PDEVMODE pdm
    )

/*++

Routine Description:

    Verify dmSpecVersion and dmSize fields of a devmode

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    0 if the input devmode is unacceptable
    Otherwise, return the expected dmSpecVersion value

--*/

{
    WORD    expectedVersion;

    if (pdm == NULL)
        return 0;

    // Check against known devmode sizes

    switch (pdm->dmSize) {

    case DM_SIZE320:
        expectedVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        expectedVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        expectedVersion = DM_SPECVERSION401;
        break;

    default:
        expectedVersion = pdm->dmSpecVersion;
        break;
    }


    return expectedVersion;
}



LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Convert an input devmode to a different version devmode.

    Whenever driver gets an input devmode, it should call this
    routine to convert it to current version.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized/valid output devmode

Return Value:

    Total number of bytes copied
    -1 if either input or output devmode is invalid

--*/

{
    WORD    dmSpecVersion, dmDriverVersion;
    WORD    dmSize, dmDriverExtra;
    LONG    cbCopied = 0;

    // Look for inconsistency between dmSpecVersion and dmSize

    if (! CheckDevmodeVersion(pdmIn) ||
        ! (dmSpecVersion = CheckDevmodeVersion(pdmOut)))
    {
        return -1;
    }

    // Copy public devmode fields

    dmDriverVersion = pdmOut->dmDriverVersion;
    dmSize = pdmOut->dmSize;
    dmDriverExtra = pdmOut->dmDriverExtra;

    cbCopied = min(dmSize, pdmIn->dmSize);
    memcpy(pdmOut, pdmIn, cbCopied);

    pdmOut->dmSpecVersion = dmSpecVersion;
    pdmOut->dmDriverVersion = dmDriverVersion;
    pdmOut->dmSize = dmSize;
    pdmOut->dmDriverExtra = dmDriverExtra;

    // Copy private devmode fields

    cbCopied += min(dmDriverExtra, pdmIn->dmDriverExtra);
    memcpy((PBYTE) pdmOut + pdmOut->dmSize,
           (PBYTE) pdmIn + pdmIn->dmSize,
           min(dmDriverExtra, pdmIn->dmDriverExtra));

    return cbCopied;
}



#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Copy a source devmode to an output devmode buffer.

    Driver should call this routine before it returns to the caller
    of DrvDocumentProperties.

Arguments:

    pdmSrc - Points to a current version source devmode
    pdmIn - Points to input devmode passed to DrvDocumentProperties
    pdmOut - Output buffer pointer passed to DrvDocumentProperties

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (pdmIn == NULL) {

        memcpy(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;

    } else {

        // We have to deal with the public fields and private fields
        // separately. Also remember pdmIn and pdmOut may point to
        // the same buffer.

        // Public fields: take dmSpecVersion and dmSize from
        // the smaller of pdmSrc and pdmIn

        if (pdmIn->dmSize < pdmSrc->dmSize) {

            pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
            pdmOut->dmSize        = pdmIn->dmSize;

        } else {

            pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
            pdmOut->dmSize        = pdmSrc->dmSize;
        }

        // Similarly for private fields

        if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra) {

            pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;

        } else {

            pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
        }

        return ConvertDevmode(pdmSrc, pdmOut) > 0;
    }
}



INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    )

/*++

Routine Description:

    Library routine to handle common cases of DrvConvertDevMode

Arguments:

    pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode
        Correspond to parameters passed to DrvConvertDevMode
    pDriverVersions - Specifies driver version numbers and private devmode sizes

Return Value:

    CDM_RESULT_TRUE
        If the case is handled by the library routine and driver
        shoud return TRUE to the caller of DrvConvertDevMode.

    CDM_RESULT_FALSE
        If the case is handled by the library routine and driver
        shoud return FALSE to the caller of DrvConvertDevMode.

    CDM_RESULT_NOT_HANDLED
        The case is NOT handled by the library routine and driver
        should continue on with whatever it needs to do.

--*/

{
    LONG    size;

    // Make sure pcbNeeded parameter is not NULL

    if (pcbNeeded == NULL) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return CDM_RESULT_FALSE;
    }

    switch (fMode) {

    case CDM_CONVERT:

        // Convert any input devmode to any output devmode.
        // Both input and output must be valid.

        if (pdmOut != NULL &&
            *pcbNeeded >= (pdmOut->dmSize + pdmOut->dmDriverExtra) &&
            ConvertDevmode(pdmIn, pdmOut) > 0)
        {
            *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
            return CDM_RESULT_TRUE;
        }
        break;

    case CDM_CONVERT351:

        // Convert any input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE320 + pDriverVersions->dmDriverExtra351;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // Do the conversion from input devmode to 3.51 devmode

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = pDriverVersions->dmDriverVersion351;
        pdmOut->dmDriverExtra = pDriverVersions->dmDriverExtra351;

        if (ConvertDevmode(pdmIn, pdmOut) > 0) {

            *pcbNeeded = size;
            return CDM_RESULT_TRUE;
        }

        break;

    case CDM_DRIVER_DEFAULT:

        // Convert any input devmode to current version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE_CURRENT + pDriverVersions->dmDriverExtra;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // This case (getting driver-default devmode) is not handled
        // by the library routine.

        *pcbNeeded = size;

        // FALL THROUGH TO THE DEFAULT CASE!

    default:
        return CDM_RESULT_NOT_HANDLED;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return CDM_RESULT_FALSE;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\prndata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.h

Abstract:

    Funtions for dealing with printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _PRNDATA_H_
#define _PRNDATA_H_

//
// Default discount rate period: 8:00pm to 7:00am
//

#define DEFAULT_STARTCHEAP  MAKELONG(20, 0)
#define DEFAULT_STOPCHEAP   MAKELONG(7, 0)

#define PRNDATA_PERMISSION  TEXT("Permission")
#define PRNDATA_ISMETRIC    TEXT("IsMetric")

//
// Get a string value from the PrinterData registry key
//

LPTSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey
    );

//
// Save a string value to the PrinterData registry key
//

BOOL
SetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    LPTSTR  pValue
    );

//
// Get a DWORD value from the registry
//

DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   defaultValue
    );

//
// Save a DWORD value to the registry
//

BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   value
    );

#endif // !_PRNDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\forms.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.h

Abstract:

    Declaration of functions for dealing with forms

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FORMS_H_
#define _FORMS_H_

//
// This is defined in winspool.h but we cannot include it from
// kernel mode source. Define it here until DDI header files are fixed.
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

typedef struct _FORM_INFO_1 {

    DWORD   Flags;
    PWSTR   pName;
    SIZEL   Size;
    RECTL   ImageableArea;

} FORM_INFO_1, *PFORM_INFO_1;

#define FORM_BUILTIN    0x00000001

typedef struct _PRINTER_INFO_2 {

    PWSTR   pServerName;
    PWSTR   pPrinterName;
    PWSTR   pShareName;
    PWSTR   pPortName;
    PWSTR   pDriverName;
    PWSTR   pComment;
    PWSTR   pLocation;
    PDEVMODEW pDevMode;
    PWSTR   pSepFile;
    PWSTR   pPrintProcessor;
    PWSTR   pDatatype;
    PWSTR   pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;

} PRINTER_INFO_2, *PPRINTER_INFO_2;

#endif // KERNEL_MODE && !USERMODE_DRIVER

//
// We use the highest order bit of FORM_INFO_1.Flags.
// Make sure the spooler is not using this bits.
//

#define FORM_SUPPORTED      0x80000000

#define IsSupportedForm(pForm)  ((pForm)->Flags & FORM_SUPPORTED)
#define SetSupportedForm(pForm) ((pForm)->Flags |= FORM_SUPPORTED)

//
// Our internal unit for measuring paper size and imageable area is microns.
// Following macros converts between microns and pixels, given a resolution
// measured in dots-per-inch.
//

#define MicronToPixel(micron, dpi)  MulDiv(micron, dpi, 25400)

//
// Validate the form specification in a devmode
//

BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    );

//
// Return a collection of forms in the system database
//

PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    );

#endif // !_FORMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\timectrl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timectrl.h

Abstract:

    For implementing a dialog control for setting time values

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _TIMECTRL_H_
#define _TIMECTRL_H_

//
// A time control consist of the following components:
//  a static text field with WS_EX_CLIENTEDGE style - encloses all other fields
//  an editable text field - hour
//  a static text field - time separator
//  an editable text field - minute
//  a listbox - AM/PM
//  a spin control - up/down arrow
//
// A time control is identified by the item ID of the first static text field.
// Rest of the items must have consecutive IDs starting from that.
//

#define TC_BORDER       0
#define TC_HOUR         1
#define TC_TIME_SEP     2
#define TC_MINUTE       3
#define TC_AMPM         4
#define TC_ARROW        5

//
// Enable or disable a time control
//

VOID
EnableTimeControl(
    HWND    hDlg,
    INT     id,
    BOOL    enabled
    );

//
// Setting the current value of a time control
//

VOID
InitTimeControl(
    HWND     hDlg,
    INT      id,
    PFAX_TIME pTimeVal
    );

//
// Retrieve the current value of a time control
//

VOID
GetTimeControlValue(
    HWND     hDlg,
    INT      id,
    PFAX_TIME pTimeVal
    );

//
// Handle dialog messages intended for a time control
//

BOOL
HandleTimeControl(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    INT     id,
    INT     part
    );

#endif // !_TIMECTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\inc\libproto.h ===
/******************** Function Prototypes file ***************************
 *  libproto.h
 *      Function prototypes for NT printer drivers library.  Also includes
 *      a brief description of the function.
 *
 *  11:04 on Wed 14 Nov 1990    -by-    Lindsay Harris   [lindsayh]
 *
 * Copyright (C) Microsoft Corporation,  1990 - 1992
 *
 ************************************************************************/

#ifndef __LIBPROTO_H__
#define __LIBPROTO_H__

#if defined(NTGDIKM) && !defined(KERNEL_MODE)
#define KERNEL_MODE
#endif

#ifdef NTGDIKM

extern ULONG gulMemID;
#define DbgPrint         DrvDbgPrint
#define HeapAlloc(hHeap,Flags,Size)    DRVALLOC( Size )
#define HeapFree( hHeap, Flags, VBits )  DRVFREE( VBits )

#ifndef FillMemory
#define FillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#endif

//#define DRVALLOC(c) EngAllocMem(0, c,gulMemID)
//#define DRVFREE(p)  EngFreeMem(p)

#endif

/*
 *   Until there is proper error logging:-
 *      WinSetError( "String" );
 *   The String appears on the debug terminal.  A \n is appended.
 */
void  WinSetError( LPSTR );

/*
 *   Function to add a copy of a string to a heap.  Returns address of copy
 *  of string (if successful) or 0 if memory cannot be allocated.
 */

LPSTR   StrToHeap( HANDLE, LPSTR );
PWSTR   StrToWHeap( HANDLE, LPSTR );            /* Expand to Wide too! */
PWSTR   WstrToHeap( HANDLE, PWSTR );            /* WIDE version */

/*
 *   Convert an ascii style string to WCHAR format, appending it to the
 *  end of the wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcat2WChar( PWSTR, LPSTR );


/*
 *   Convert an ascii style string to WCHAR format, copying it to the
 *  wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcpy2WChar( PWSTR, LPSTR );


/*
 *   The WCHAR world's equivalent of strlen():  returns the number of WCHARs
 *  in the string passed in.
 */

int  wchlen( PWSTR );

/*
 *   Concatenate a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcat( PWSTR, PWSTR );

/*
 *   Copy a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcpy( PWSTR, PWSTR );

PVOID MapFile(PWSTR);

#if NTGDIKM
/*
 *   check if two strings are identical
 */

BOOL bSameStringW(
    PWCHAR pwch1,
    PWCHAR pwch2);

/*
 *   Some system function prototypes have vanished - replace them here.
 */

void  DrvDbgPrint( char *, ... );

#if DBG
#define RIP(x) {DrvDbgPrint((PSZ)(x)); EngDebugBreak();}
#define WARNING(s) DrvDbgPrint("warning: %s",(PSZ)(s))

BOOL
SetAllocCounters(
    VOID
    );

#else
#define RIP(x)
#define WARNING(s)
#endif


LPVOID
DRVALLOC(
    DWORD  cbAlloc
    );

BOOL
DRVFREE(
    LPVOID pMem
    );

#else //NTGDIKM

/*
 *   Break into the debugger - Ye olde RIP.
 */
VOID DoRip( LPSTR );

#if DBG

#define WARNING(s) DbgPrint("warning: %s",(PSZ)(s))

#ifdef FIREWALLS
#define RIP(x) DoRip( (PSZ)(x) )
#else
#define RIP(x) {DbgPrint((PSZ)(x)); DbgBreakPoint();}
#endif

#else

#define WARNING(s)
#define RIP(x)

#endif //DBG

//
// Define kernel debugger print prototypes and macros.
// These are defined in ntrtl.h which we should include
// instead. For now, redefine them here to avoid breaking
// other components.
//

#if DBG

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

#endif



PVOID MapFile(PWSTR);


#endif //NTGDIKM

/*
 *   A simplified write function.  Returns TRUE if the WriteFile()
 * call returns TRUE and the number of bytes written equals the
 * number requested.
 *
 *  bWrite( file_handle,  address_of_data,  number_of_bytes );
 */

BOOL   bWrite( HANDLE, void  *, int );

/*
 *  Function to copy the contents of one file to another.  The files
 * are referenced via file handles.  No positioning is done - that is
 * up to the user.
 *  The second form also allows a byte count to limit the amount of data
 * copied.
 */


long  lFICopy( HANDLE, HANDLE );
long  lFInCopy( HANDLE, HANDLE, long );


/*
 *   Spooler interaction functions.  These allow drivers to call the
 * spooler directly,  without going through engine stub functions.
 */

BOOL  bSplGetFormW( HANDLE, PWSTR, DWORD, BYTE *, DWORD, DWORD * );


DWORD dwSplGetPrinterDataW( HANDLE, PWSTR, BYTE *, DWORD, DWORD * );


BOOL  bSplWrite( HANDLE, ULONG,  VOID  * );



/*  Function needed to allow the driver to reach the spooler */

BOOL   bImpersonateClient( void );


/************************** HACK ***************************************
 *   The following function is only required until the DEVMODE contains
 *   a form name rather than an index.  And even then it might be required.
 *
 ***********************************************************************/

char  *_IndexToName( int );

//
// COLORADJUSTMENT validating
//

BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    );

// Generic devmode conversion routine

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifndef KERNEL_MODE

// Copy DEVMODE to an output buffer before return to the
// caller of DrvDocumentProperties

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

// Library routine to handle common cases of DrvConvertDevmode

typedef struct {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 version private devmode

} DRIVER_VERSION_INFO, *PDRIVER_VERSION_INFO;

#define CDM_RESULT_FALSE        0
#define CDM_RESULT_TRUE         1
#define CDM_RESULT_NOT_HANDLED  2

INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    );


UINT
cdecl
DQPsprintf(
    HINSTANCE   hInst,
    LPWSTR      pwBuf,
    DWORD       cchBuf,
    LPDWORD     pcchNeeded,
    LPWSTR      pwszFormat,
    ...
    );

#endif // KERNEL_MODE

#endif // !__LIBPROTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\forms.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.c

Abstract:

    Functions for manipulating forms

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"
#include "forms.h"



BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    )

/*++

Routine Description:

    Validate the form specification in a devmode

Arguments:

    hPrinter - Handle to the printer object
    pdm - Pointer to the input devmode
    pFormInfo - FORM_INFO_1 structure for returning form information

Return Value:

    TRUE if the input devmode specifies a valid logical form
    FALSE otherwise

--*/

{
    PFORM_INFO_1 pForm, pFormDB;
    DWORD        cForms;

    //
    // Get a list of forms in the system
    //

    if (! (pForm = pFormDB = GetFormsDatabase(hPrinter, &cForms))) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    if ((pdm->dmFields & DM_PAPERSIZE) && pdm->dmPaperSize >= DMPAPER_FIRST) {

        //
        // Devmode is specifying a form using paper size index
        //

        DWORD index = pdm->dmPaperSize - DMPAPER_FIRST;

        if (index < cForms)
            pForm = pFormDB + index;
        else
            pForm = NULL;

    } else if (pdm->dmFields & DM_FORMNAME) {

        //
        // Devmode is specifying a form using form name: go through the forms database
        // and check if the requested form name matches that of a form in the database
        //

        while (cForms && _tcsicmp(pForm->pName, pdm->dmFormName) != EQUAL_STRING) {

            pForm++;
            cForms--;
        }

        if (cForms == 0)
            pForm = NULL;
    }

    if (pForm && IsSupportedForm(pForm)) {

        if (pFormInfo)
            *pFormInfo = *pForm;

        //
        // Convert paper size unit from microns to 0.1mm
        //

        pdm->dmPaperWidth = (SHORT)(pForm->Size.cx / 100);
        pdm->dmPaperLength = (SHORT)(pForm->Size.cy / 100);

        if ((pdm->dmFields & DM_FORMNAME) == 0) {

            pdm->dmFields |= DM_FORMNAME;
            CopyString(pdm->dmFormName, pForm->pName, CCHFORMNAME);
        }
    }

    MemFree(pFormDB);
    return pForm != NULL;
}



PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    )

/*++

Routine Description:

    Return a collection of forms in the spooler database

Arguments:

    hPrinter - Handle to a printer object
    pCount - Points to a variable for returning total number of forms

Return Value:

    Pointer to an array of FORM_INFO_1 structures if successful
    NULL otherwise

--*/

{
    PFORM_INFO_1 pFormDB = NULL;
    DWORD        cb;

    if (!EnumForms(hPrinter, 1, NULL, 0, &cb, pCount) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pFormDB = MemAlloc(cb)) != NULL &&
        EnumForms(hPrinter, 1, (PBYTE) pFormDB, cb, &cb, pCount))
    {
        PFORM_INFO_1 pForm;
        DWORD        count;
        LONG         maxX, maxY;

        //
        // Calculate the maximum allowable form width and height (in microns)
        //

        maxX = MulDiv(MAX_WIDTH_PIXELS, 25400, FAXRES_HORIZONTAL);
        maxY = MulDiv(MAX_HEIGHT_PIXELS, 25400, FAXRES_VERTICAL);

        for (count=*pCount, pForm=pFormDB; count--; pForm++) {

            //
            // Make sure the highest order bits are not used by the spooler
            //

            Assert(! IsSupportedForm(pForm));

            //
            // Determine if the form in question is supported on the device
            //

            if (pForm->ImageableArea.right - pForm->ImageableArea.left <= maxX &&
                pForm->ImageableArea.bottom - pForm->ImageableArea.top <= maxY)
            {
                SetSupportedForm(pForm);
            }
        }

        return pFormDB;
    }

    Error(("EnumForms failed\n"));
    MemFree(pFormDB);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\halftone.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    halftone.c


Abstract:

    This module contains data and function to validate the COLORADJUSTMENT


Author:

    27-Oct-1995 Fri 15:48:17 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifdef NTGDIKM
#include        <stddef.h>
#include        <stdarg.h>
#include        <windef.h>
#include        <wingdi.h>
#include        <winddi.h>
#else
#include        <stddef.h>
#include        <windows.h>
#include        <winddi.h>
#endif

DEVHTINFO    DefDevHTInfo = {

        HT_FLAG_HAS_BLACK_DYE,
        HT_PATSIZE_6x6_M,
        0,                                  // DevPelsDPI

        {
            { 6380, 3350,       0 },        // xr, yr, Yr
            { 2345, 6075,       0 },        // xg, yg, Yg
            { 1410,  932,       0 },        // xb, yb, Yb
            { 2000, 2450,       0 },        // xc, yc, Yc Y=0=HT default
            { 5210, 2100,       0 },        // xm, ym, Ym
            { 4750, 5100,       0 },        // xy, yy, Yy
            { 3127, 3290,       0 },        // xw, yw, Yw=0=default

            12500,                          // R gamma
            12500,                          // G gamma
            12500,                          // B gamma, 12500=Default

            585,   120,                     // M/C, Y/C
              0,     0,                     // C/M, Y/M
              0, 10000                      // C/Y, M/Y  10000=default
        }
    };


COLORADJUSTMENT  DefHTClrAdj = {

        sizeof(COLORADJUSTMENT),
        0,
        ILLUMINANT_DEVICE_DEFAULT,
        10000,
        10000,
        10000,
        REFERENCE_BLACK_MIN,
        REFERENCE_WHITE_MAX,
        0,
        0,
        0,
        0
    };



#define ADJ_CA(p,a,i,x) if ((p->a<i)||(p->a>x)){Ok=FALSE;p->a=DefHTClrAdj.a;}



BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    )

/*++

Routine Description:

    This function validate and adjust the invalid color adjustment fields

Arguments:

    pca - Pointer to the COLORADJUSTMENT data structure


Return Value:

    TRUE if everything in the range FALSE otherwise


Author:

    02-Dec-1993 Thu 22:45:59 created  -by-  Daniel Chou (danielc)


Revision History:

    02-Apr-1995 Sun 11:19:04 updated  -by-  Daniel Chou (danielc)
        Update the RGB_GAMMA_MIN/MAX checking and make default to 1.0


--*/

{
    BOOL    Ok = TRUE;

    //
    // Validate the color adjustment
    //

    if ((pca->caSize != sizeof(COLORADJUSTMENT)) ||
        (pca->caFlags & ~(CA_NEGATIVE | CA_LOG_FILTER))) {

        *pca = DefHTClrAdj;
        return(FALSE);
    }

    ADJ_CA(pca, caIlluminantIndex,  0,                  ILLUMINANT_MAX_INDEX);
    ADJ_CA(pca, caRedGamma,         RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caGreenGamma,       RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caBlueGamma,        RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caReferenceBlack,   0,                  REFERENCE_BLACK_MAX );
    ADJ_CA(pca, caReferenceWhite,   REFERENCE_WHITE_MIN,10000               );
    ADJ_CA(pca, caContrast,         COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caBrightness,       COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caColorfulness,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caRedGreenTint,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\prndata.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    Functions for accessing printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



LPTSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey
    )

/*++

Routine Description:

    Get a string value from the PrinterData registry key

Arguments:

    hPrinter - Identifies the printer object
    pRegKey - Specifies the name of registry value

Return Value:

    pBuffer

--*/

{
    DWORD   type, cb;
    PVOID   pBuffer = NULL;

    //
    // We should really pass NULL for pData parameter here. But to workaround
    // a bug in the spooler API GetPrinterData, we must pass in a valid pointer here.
    //

    if (GetPrinterData(hPrinter, pRegKey, &type, (PBYTE) &type, 0, &cb) == ERROR_MORE_DATA &&
        (pBuffer = MemAlloc(cb)) &&
        GetPrinterData(hPrinter, pRegKey, &type, pBuffer, cb, &cb) == ERROR_SUCCESS &&
        (type == REG_SZ || type == REG_MULTI_SZ || type == REG_EXPAND_SZ))
    {
        return pBuffer;
    }

    Error(("Couldn't get printer data string %ws: %d\n", pRegKey, GetLastError()));
    MemFree(pBuffer);
    return NULL;
}



DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    PWSTR   pRegKey,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    defaultValue - Specifies the default value to be used if no data exists in registry

Return Value:

    Current value for the requested registry key

--*/

{
    DWORD   value, type, cb;

    if (GetPrinterData(hPrinter,
                       pRegKey,
                       &type,
                       (PBYTE) &value,
                       sizeof(value),
                       &cb) == ERROR_SUCCESS)
    {
        return value;
    }

    return defaultValue;
}



PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

#ifdef SPOOLERBUG
    if (level == 9) {
        cbNeeded = sizeof(DRVDEVMODE);
        pPrinterInfo = MemAlloc( cbNeeded );
        if (GetPrinter(hPrinter,9,pPrinterInfo,cbNeeded,&cbNeeded)) {
            return pPrinterInfo;
        }
        
    } else
#endif

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    Error(("GetPrinter failed: %d\n", GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}



#ifndef KERNEL_MODE

BOOL
SetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    LPTSTR  pValue
    )

/*++

Routine Description:

    Save a string value to the PrinterData registry key

Arguments:

    hPrinter - Identifies the printer object
    pRegKey - Specifies the name of registry value
    pValue - Points to string value to be saved

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_SZ,
                       (PBYTE) pValue,
                       sizeof(TCHAR) * (_tcslen(pValue) + 1)) != ERROR_SUCCESS)
    {
        Error(("Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}



BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    PWSTR   pRegKey,
    DWORD   value
    )

/*++

Routine Description:

    Save a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    value - Specifies the value to be saved

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_DWORD,
                       (PBYTE) &value,
                       sizeof(value)) != ERROR_SUCCESS)
    {
        Error(("Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}



PVOID
MyGetPrinterDriver(
    HANDLE      hPrinter,
    DWORD       level
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriver spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of DRIVER_INFO_x structure requested

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pDriverInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinterDriver(hPrinter, NULL, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = MemAlloc(cbNeeded)) &&
        GetPrinterDriver(hPrinter, NULL, level, pDriverInfo, cbNeeded, &cbNeeded))
    {
        return pDriverInfo;
    }

    Error(("GetPrinterDriver failed: %d\n", GetLastError()));
    MemFree(pDriverInfo);
    return NULL;
}



LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriverDirectory spooler API

Arguments:

    pServerName - Specifies the name of the print server, NULL for local machine
    pEnvironment - Specifies the processor architecture

Return Value:

    Pointer to the printer driver directory on the specified print server
    NULL if there is an error

--*/

{
    PVOID   pDriverDir = NULL;
    DWORD   cb;
    
    if (! GetPrinterDriverDirectory(pServerName, pEnvironment, 1, NULL, 0, &cb) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverDir = MemAlloc(cb)) &&
        GetPrinterDriverDirectory(pServerName, pEnvironment, 1, pDriverDir, cb, &cb))
    {
        return pDriverDir;
    }

    Error(("GetPrinterDriverDirectory failed: %d\n", GetLastError()));
    MemFree(pDriverDir);
    return NULL;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

PRINTERS=$(BASEDIR)\private\ntos\w32\ntgdi\printers

SOURCES=..\runtime.c    \
        ..\faxdm.c      \
        ..\forms.c      \
        ..\prndata.c    \
        ..\devmode.c    \
        ..\halftone.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\timectrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timectrl.c

Abstract:

    For implementing a dialog control for setting time values

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"
#include "timectrl.h"
#include <commctrl.h>
#include <windowsx.h>

//
// Static time format information
//

static BOOL timeCtrlInitialized = FALSE;
static UINT use24Hour;
static UINT hourLeadingZero;

static TCHAR timeSep[8];
static TCHAR amSuffix[8];
static TCHAR pmSuffix[8];

static TCHAR intlApplet[] = TEXT("Intl");
static TCHAR use24HourKey[] = TEXT("iTime");
static TCHAR hourLeadingZeroKey[] = TEXT("iTLZero");
static TCHAR timeSepKey[] = TEXT("sTime");
static TCHAR amSuffixKey[] = TEXT("s1159");
static TCHAR pmSuffixKey[] = TEXT("s2359");

static TCHAR timeSepDefault[] = TEXT(":");
static TCHAR amSuffixDefault[] = TEXT("AM");
static TCHAR pmSuffixDefault[] = TEXT("PM");



VOID
InitStaticValues(
    VOID
    )

/*++

Routine Description:

    One time initialization of the time control module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (! timeCtrlInitialized) {

        //
        // We only need to perform the initialization once.
        // Make sure to modify the global data inside a critical section.
        //

        use24Hour = GetProfileInt(intlApplet, use24HourKey, FALSE);
        hourLeadingZero = GetProfileInt(intlApplet, hourLeadingZeroKey, TRUE);

        GetProfileString(intlApplet,
                         timeSepKey,
                         timeSepDefault,
                         timeSep,
                         sizeof(timeSep) / sizeof(TCHAR));

        GetProfileString(intlApplet,
                         amSuffixKey,
                         amSuffixDefault,
                         amSuffix,
                         sizeof(amSuffix) / sizeof(TCHAR));

        GetProfileString(intlApplet,
                         pmSuffixKey,
                         pmSuffixDefault,
                         pmSuffix,
                         sizeof(pmSuffix) / sizeof(TCHAR));

        timeCtrlInitialized = TRUE;

        Verbose(("Use 24-hour format: %d\n", use24Hour));
        Verbose(("Hour leading zero: %d\n", hourLeadingZero));
        Verbose(("Time separator: %ws\n", timeSep));
        Verbose(("AM suffix: %ws\n", amSuffix));
        Verbose(("PM suffix: %ws\n", pmSuffix));
    }
}


VOID
EnableTimeControl(
    HWND    hDlg,
    INT     id,
    BOOL    enabled
    )

/*++

Routine Description:

    Enable or disable a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    enabled - Whether to enable or disable the time control

Return Value:

    NONE

--*/

{
//    EnableWindow(GetDlgItem(hDlg, IDC_SENDTIME), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_HOUR), enabled);
    InvalidateRect(GetDlgItem(hDlg, id+TC_TIME_SEP), NULL, FALSE);
    EnableWindow(GetDlgItem(hDlg, id+TC_MINUTE), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_AMPM), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_ARROW), enabled);
}



VOID
SetHourMinuteValue(
    HWND    hDlg,
    INT     id,
    INT     part,
    INT     value
    )

/*++

Routine Description:

    Set the hour or minute value

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    part - Whether we're setting hour or minute value
    value - Specifies the new hour or minute value

Return Value:

    NONE

--*/

{
    TCHAR   buffer[4];

    if (value < 0 || value > ((part == TC_MINUTE) ? 59 : 23))
        value = 0;

    if (part == TC_HOUR && !use24Hour) {

        SendDlgItemMessage(hDlg, id+TC_AMPM, LB_SETTOPINDEX, value / 12, 0);

        if ((value %= 12) == 0)
            value = 12;
    }

    wsprintf(buffer,
             (part == TC_MINUTE || hourLeadingZero) ? TEXT("%02d") : TEXT("%d"),
             value);

    SetDlgItemText(hDlg, id+part, buffer);
}



VOID
InitTimeControl(
    HWND      hDlg,
    INT       id,
    PFAX_TIME pTimeVal
    )

/*++

Routine Description:

    Setting the current value of a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    pTimeVal - Specifies the new value for the time control

Return Value:

    NONE

--*/

{
    HWND    hwnd, hwndArrow;

    //
    // Make sure the static global information is initialized
    //

    InitStaticValues();

    //
    // Display the time separator
    //

    SetDlgItemText(hDlg, id+TC_TIME_SEP, timeSep);

    //
    // Display the AM/PM suffix if necessary
    //

    if (hwnd = GetDlgItem(hDlg, id+TC_AMPM)) {

        if (! use24Hour) {

            SendMessage(hwnd, LB_INSERTSTRING, 0, (LPARAM) &amSuffix[0]);
            SendMessage(hwnd, LB_INSERTSTRING, 1, (LPARAM) &pmSuffix[0]);

        } else
            EnableWindow(hwnd, FALSE);
    }

    //
    // Display hour and minute values
    //

    SetHourMinuteValue(hDlg, id, TC_HOUR, pTimeVal->Hour);
    SetHourMinuteValue(hDlg, id, TC_MINUTE, pTimeVal->Minute);

    //
    // Connect the updown arrow to the minute field by default
    //

    if ((hwnd = GetDlgItem(hDlg, id+TC_MINUTE)) && (hwndArrow = GetDlgItem(hDlg, id+TC_ARROW))) {

        UDACCEL udAccel[2];

        udAccel[0].nSec = 0;
        udAccel[0].nInc = 1;
        udAccel[1].nSec = 2;
        udAccel[1].nInc = 5;

        SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(59, 0));
        SendMessage(hwndArrow, UDM_SETACCEL, 2, (LPARAM) &udAccel[0]);
        SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
    }
}



BOOL
GetHourMinuteValue(
    HWND    hDlg,
    INT     id,
    INT     part,
    PWORD   pValue
    )

/*++

Routine Description:

    Retrieve the current hour or minute value

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    part - Whether we're interest in hour or minute value
    pValue - Buffer for storing the current hour value

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT     value, minVal, maxVal;
    BOOL    success;

    //
    // Read the text field as an integer value
    //

    value = GetDlgItemInt(hDlg, id+part, &success, FALSE);

    //
    // Make sure the input value is valid
    //

    if (! success)
        value = 0;
    else {

        if (part == TC_MINUTE)
            minVal = 0, maxVal = 59;
        else if (use24Hour)
            minVal = 0, maxVal = 23;
        else
            minVal = 1, maxVal = 12;

        success = FALSE;

        if (value < minVal)
            value = minVal;
        else if (value > maxVal)
            value = maxVal;
        else
            success = TRUE;
    }

    //
    // Convert AM/PM hours to absolute number between 0-23
    //

    if (part == TC_HOUR && !use24Hour) {

        if (SendDlgItemMessage(hDlg, id+TC_AMPM, LB_GETTOPINDEX, 0, 0)) {

            // PM

            if (value != 12)
                value += 12;

        } else {

            // AM

            if (value == 12)
                value = 0;
        }
    }

    *pValue = (WORD) value;
    return success;
}



VOID
GetTimeControlValue(
    HWND      hDlg,
    INT       id,
    PFAX_TIME pTimeVal
    )

/*++

Routine Description:

    Retrieve the current value of a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    pTimeVal - Buffer for storing the current time value

Return Value:

    NONE

--*/

{
    GetHourMinuteValue(hDlg, id, TC_HOUR, &pTimeVal->Hour);
    GetHourMinuteValue(hDlg, id, TC_MINUTE, &pTimeVal->Minute);
}



BOOL
HandleTimeControl(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    INT     id,
    INT     part
    )

/*++

Routine Description:

    Handle dialog messages intended for a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    message, wParam, lParam - Parameters passed to the dialog procedure
    id - Identifies the time control
    part - Identifies what part of the time control in question

Return Value:

    TRUE if the message is handled, FALSE otherwise

--*/

{
    HWND    hwnd, hwndArrow;
    UDACCEL udAccel[2];
    WORD    wMax, wMin;

    switch (message) {

    case WM_COMMAND:

        //
        // Make sure the control is indeed ours
        //

        hwnd = GetDlgItem(hDlg, id+part);
        hwndArrow = GetDlgItem(hDlg, id+TC_ARROW);

        if (hwnd != GET_WM_COMMAND_HWND(wParam, lParam)) {

            Warning(("Bad window handle\n"));
            return FALSE;
        }

        switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

        case LBN_SETFOCUS:

            //
            // AM/PM list box is coming into focus
            //

            Assert(part == TC_AMPM);

            udAccel[0].nSec = 0;
            udAccel[0].nInc = 1;
            SendMessage(hwnd, LB_SETCURSEL, SendMessage(hwnd, LB_GETTOPINDEX, 0, 0), 0);
            SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(1, 0));
            SendMessage(hwndArrow, UDM_SETACCEL, 1, (LPARAM) &udAccel[0]);
            SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
            break;

        case LBN_KILLFOCUS:

            //
            // Leaving AM/PM listbox
            //

            Assert(part == TC_AMPM);

            SendMessage(hwnd, LB_SETCURSEL, (WPARAM) -1, 0);
            SendMessage(hwndArrow, UDM_SETBUDDY, 0, 0);
            break;

        case EN_SETFOCUS:

            //
            // Entering hour or minute text field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            udAccel[0].nSec = 0;
            udAccel[0].nInc = 1;
            udAccel[1].nSec = 2;

            if (part == TC_MINUTE) {

                wMin = 0, wMax = 59;
                udAccel[1].nInc = 5;

            } else {

                udAccel[1].nInc = 1;

                if (use24Hour)
                    wMin = 0, wMax = 23;
                else
                    wMin = 1, wMax = 12;
            }

            SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(wMax, wMin));
            SendMessage(hwndArrow, UDM_SETACCEL, 2, (LPARAM) &udAccel[0]);
            SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
            SendMessage(hwnd, EM_SETSEL, 0, -1);
            break;

        case EN_CHANGE:

            //
            // Changing hour or minute field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            if (!GetHourMinuteValue(hDlg, id, part, &wMax) && GetWindowTextLength(hwnd)) {

                MessageBeep(MB_ICONASTERISK);
                SendMessage(hwnd, EM_UNDO, 0, 0);
            }
            break;

        case EN_KILLFOCUS:

            //
            // Leaving hour or minute text field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            GetHourMinuteValue(hDlg, id, part, &wMax);
            SetHourMinuteValue(hDlg, id, part, wMax);
            SendMessage(hwndArrow, UDM_SETBUDDY, 0, 0);
            break;
        }
        return TRUE;

    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLOR:

        //
        // Set the background color of the time control to the color of editable text
        // or static text depending on whether the control is disabled or enabled
        //

        hwnd = GET_WM_CTLCOLOR_HWND(wParam, lParam, message);

        if (hwnd == GetDlgItem(hDlg, id + TC_HOUR) ||
            hwnd == GetDlgItem(hDlg, id + TC_MINUTE) ||
            hwnd == GetDlgItem(hDlg, id + TC_TIME_SEP) ||
            hwnd == GetDlgItem(hDlg, id + TC_AMPM))
        {
            message = part ? WM_CTLCOLOREDIT : WM_CTLCOLORSTATIC;
            return (BOOL)DefWindowProc(hDlg, message, wParam, lParam);
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\runtime.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    runtime.c

Abstract:

    Implementation of runtime library functions

Environment:

    Fax driver, kernel and user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Unicode string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PWSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Ansi string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     strSize;

    if (pSrcStr != NULL) {

        strSize = SizeOfString(pSrcStr);

        if (pDestStr = MemAlloc(strSize))
            CopyMemory(pDestStr, pSrcStr, strSize);
        else
            Error(("Memory allocation failed\n"));

    } else
        pDestStr = NULL;

    return pDestStr;
}



PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pFilename   Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    LPCSTR  pstr;

    if (pstr = strrchr(pFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\km\kmfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    kmfuncs.c

Abstract:

    Kernel-mode specific library functions

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



#if DBG

//
// Variable to control the amount of debug messages generated
//

INT _debugLevel = 0;


#ifndef USERMODE_DRIVER

//
// Functions for outputting debug messages
//

ULONG __cdecl
DbgPrint(
    CHAR *  format,
    ...
    )

{
    va_list ap;

    va_start(ap, format);
    EngDebugPrint("", format, ap);
    va_end(ap);

    return 0;
}

#endif // !USERMODE_DRIVER
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Functions for accessing registry information under:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

        Windows NT fax driver user interface

Revision History:

        01/29/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxlib.h"
#include "registry.h"


        

LPTSTR
GetRegistryExpandStr(
    HKEY    hRootKey,
    LPTSTR  pKeyName,
    LPTSTR  pValueName
    )

/*++

Routine Description:

    Get a EXPAND_SZ value from the registry

Arguments:

    hRootKey - Specifies a handle to the root registry key
    pKeyName - Specifies the name of the sub registry key
    pValueName - Specifies the name of the registry value

Return Value:

    Pointer to an expanded string, NULL if there is an error

--*/

{
    DWORD   size, type;
    LONG    status;
    HKEY    hRegKey;
    LPTSTR  pRegStr = NULL, pExpandedStr;

    //
    // Get a handle to the user info registry key
    //

    if (! (hRegKey = OpenRegistryKey(hRootKey, pKeyName, FALSE, REG_READONLY)))
        return NULL;

    //
    // Figure out how much memory to allocate
    //

    size = 0;
    status = RegQueryValueEx(hRegKey, pValueName, NULL, &type, NULL, &size);

    if ((status == ERROR_SUCCESS) &&
        (type == REG_EXPAND_SZ || type == REG_SZ) &&
        (pRegStr = MemAlloc(size)))
    {
        //
        // Read the registry value
        //

        status = RegQueryValueEx(hRegKey, pValueName, NULL, NULL, (PBYTE) pRegStr, &size);

        if (status != ERROR_SUCCESS || IsEmptyString(pRegStr)) {

            MemFree(pRegStr);
            pRegStr = NULL;

        } else if (type == REG_EXPAND_SZ) {

            //
            // Substitute any environment variables
            //

            if ((size = ExpandEnvironmentStrings(pRegStr, NULL, 0)) == 0 ||
                (pExpandedStr = MemAlloc(sizeof(TCHAR) * size)) == NULL)
            {
                MemFree(pRegStr);
                pRegStr = NULL;

            } else {

                if (ExpandEnvironmentStrings(pRegStr, pExpandedStr, size) == 0)
                    *pExpandedStr = NUL;

                MemFree(pRegStr);
                pRegStr = pExpandedStr;
            }
        }
    }

    RegCloseKey(hRegKey);
    return pRegStr;
}
        

PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Get per-user devmode information for the specified printer

Arguments:

    pPrinterName - Specifies the name of the printer we're interested in

Return Value:

    Pointer to per-user devmode information read from the registry

--*/

{
    PVOID  pDevmode = NULL;
    HANDLE hPrinter;
    PPRINTER_INFO_9 pPrinterInfo;
    TCHAR  PrinterBuffer[64];
    
    //
    // Make sure the printer name is valid
    //

    if (pPrinterName == NULL) {
        _tcscpy(PrinterBuffer,L"Fax");
    } else {
        _tcscpy(PrinterBuffer,pPrinterName);
    }

    //
    // Open the printer
    //
    if (!OpenPrinter(PrinterBuffer,&hPrinter,NULL) ) {
        return NULL;
    }

    pPrinterInfo = MyGetPrinter(hPrinter,9);
    if (!pPrinterInfo || !pPrinterInfo->pDevMode) {
        ClosePrinter(hPrinter);
        return NULL;
    }

    pDevmode = MemAlloc(sizeof(DRVDEVMODE) );

    if (!pDevmode) {
        MemFree(pPrinterInfo);
        ClosePrinter(hPrinter);
        return NULL;
    }
    
    CopyMemory((PVOID) pDevmode,
               (PVOID) pPrinterInfo->pDevMode,
                sizeof(DRVDEVMODE) );

    MemFree( pPrinterInfo );
    ClosePrinter( hPrinter );
    
    return pDevmode;
}


VOID
SavePerUserDevmode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDevmode
    )

/*++

Routine Description:

    Save per-user devmode information for the specified printer

Arguments:

    pPrinterName - Specifies the name of the printer we're interested in
    pDevmode - Points to the devmode to be saved

Return Value:

    NONE

--*/

{
    HKEY    hRegKey;
    INT     size;

    //
    // Make sure the printer name is valid
    //

    if (pPrinterName == NULL) {

        Error(("Bad printer name\n"));
        return;
    }

    //
    // Open the registry key for write access
    //

    if (! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_DEVMODE, REG_READWRITE)))
        return;

    //
    // Save the devmode information as binary data
    //

    size = pDevmode->dmSize + pDevmode->dmDriverExtra;
    RegSetValueEx(hRegKey, pPrinterName, 0, REG_BINARY, (PBYTE) pDevmode, size);
    RegCloseKey(hRegKey);
}


LPTSTR
GetUserCoverPageDir(
    VOID
    )
{
    LPTSTR CpDirTmp = NULL;
    LPTSTR CpDir = MemAlloc(MAX_PATH*sizeof(TCHAR));

    SHGetSpecialFolderPath(NULL, CpDir , CSIDL_PERSONAL, FALSE);

    CpDirTmp = GetRegistryExpandStr(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_LOCATION);
    if (CpDirTmp == NULL) {
        HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_SETUP,FALSE, REG_READONLY);
        if (hKey) {
            SetRegistryStringExpand(hKey,REGVAL_CP_LOCATION,DEFAULT_COVERPAGE_DIR);
            RegCloseKey(hKey);            
            CpDirTmp = GetRegistryExpandStr(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_LOCATION);
        }
    }

    if (CpDir && CpDirTmp) {
        _tcscat( CpDir, TEXT("\\") );
        _tcscat( CpDir, CpDirTmp );
    }
    
    if (CpDirTmp) {
        MemFree(CpDirTmp);
    }

    return CpDir;
}


LPTSTR
GetCoverPageEditor(
    VOID
    )
{
    LPTSTR CpEd = GetRegistryStringExpand(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_EDITOR);
    if (CpEd == NULL) {
        HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_SETUP,FALSE, REG_READWRITE);
        if (hKey) {
            SetRegistryStringExpand(hKey,REGVAL_CP_EDITOR,DEFAULT_COVERPAGE_EDITOR);
            RegCloseKey(hKey);
            return GetRegistryExpandStr(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_EDITOR);
        }
    }
    return CpEd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\lib\um\umfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umfuncs.c

Abstract:

    User-mode specific library functions

Environment:

    Fax driver, user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\sendnote\sendnote.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendnote.h

Abstract:

    Send fax utility header file

Environment:

    Window NT fax driver

Revision History:

    02/15/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _SENDNOTE_H_
#define _SENDNOTE_H_

#include "faxlib.h"
#include <windowsx.h>

//
// String resource IDs
//

#define IDS_NO_FAX_PRINTER      256
#define IDS_CREATEDC_FAILED     257
#define IDS_SENDNOTE            258

//
// Icon resource IDs
//

#define IDI_FAX_NOTE            256

//
// Dialog resource IDs
//

#define IDD_SELECT_FAXPRINTER   100
#define IDC_STATIC              -1
#define IDC_FAXPRINTER_LIST     1000

#endif // !_SENDNOTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\test\decode\decode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdump.c

Abstract:

    Extract a single page out of the fax driver output file

Environment:

	Fax driver, utility

Revision History:

	01/11/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"

typedef PVOID PDEVDATA;
#include "faxtiff.h"
#include "faxtable.h"

static const CODETABLE MMRCodes[] = {

    {  7, 0x02 },   // VL3
    {  6, 0x02 },   // VL2
    {  3, 0x02 },   // VL1
    {  1, 0x01 },   // V0
    {  3, 0x03 },   // VR1
    {  6, 0x03 },   // VR2
    {  7, 0x03 },   // VR3
    {  4, 0x01 },   // PASSCODE
    {  3, 0x01 },   // HORZCODE
};

typedef const CODETABLE *PCODETABLE;

#define MMR_TABLE_SIZE  (sizeof(MMRCodes) / sizeof(CODETABLE))
#define RUN_TABLE_SIZE  (sizeof(BlackRunCodes) / sizeof(CODETABLE))

#define BYTEBITS        8
#define DWORDBITS       32
#define ErrorExit(arg)  { printf arg; DebugBreak(); }



INT
FindCode(
    PCODETABLE  pCodeTable,
    INT         tableSize,
    DWORD       code,
    DWORD       bitcnt
    )

{
    INT     index;

    for (index=0; index < tableSize; index++) {

        if (bitcnt >= pCodeTable[index].length &&
            pCodeTable[index].code == (code >> (32 - pCodeTable[index].length)))
        {
            return index;
        }
    }

    return -1;
}



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line 
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {
    
        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;
        
        //
        // Align to a DWORD boundary first
        //

        while ((DWORD) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];
            
            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}



INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line 
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {
    
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;
        
        //
        // Align to a DWORD boundary first
        //

        while ((DWORD) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];
            
            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}



VOID
OutputRun(
    PBYTE   plinebuf,
    INT     startbit,
    INT     run,
    INT     color
    )

{
    //
    // Since the line buffer is always zero initalized, we don't
    // need to do anything when output a white run.
    //

    if (color == 0 || run == 0)
        return;

    plinebuf += (startbit >> 3);

    if ((startbit &= 7) != 0) {
    
        if (run >= 8 - startbit) {

            *plinebuf++ |= 0xff >> startbit;
            run -= 8 - startbit;

        } else {

            *plinebuf |= 0xff >> startbit;
            startbit += run;
            *plinebuf &= ~(0xff >> startbit);
            return;
        }
    }
    
    while (run >= 8) {

        *plinebuf++ = 0xff;
        run -= 8;
    }

    if (run > 0)
        *plinebuf = 0xff << (8 - run);
}



VOID
DecodeMMR(
    PBYTE   pBuffer,
    LONG    bytecnt,
    LONG    width,
    LONG    height
    )

#define ReadCompressedBits() \
        while (bitCount <= 24 && bytecnt > 0) { \
            codeValue |= *pBuffer++ << (24 - bitCount); \
            bitCount += 8; \
            bytecnt--; \
        }

{
    PBYTE       prefline, plinebuf;
    LONG        lineByteCnt, lineIndex;
    DWORD       codeValue, bitCount;
    INT         codeTableIndex, color, run, horiz;
    INT         a0, a1, b1, b2;
    PCODETABLE  pCodeTable;

    lineByteCnt = (width + 7) / 8;
    prefline = (PBYTE) LocalAlloc(LPTR, lineByteCnt);
    plinebuf = (PBYTE) LocalAlloc(LPTR, lineByteCnt);

    if (!prefline || !plinebuf)
        ErrorExit(("Memory allocation failed\n"));

    bitCount = codeValue = 0;

    for (lineIndex=0; lineIndex < height; lineIndex++) {

        color = 0;
        a0 = 0;
        b1 = GetBit(prefline, 0) ? 0 : NextChangingElement(prefline, 0, width, 0);

        while (TRUE) {

            b2 = (b1 >= width) ? width :
                NextChangingElement(prefline, b1, width, GetBit(prefline, b1));

            ReadCompressedBits();
            
            codeTableIndex = FindCode(MMRCodes, MMR_TABLE_SIZE, codeValue, bitCount);
    
            if (codeTableIndex == -1)
                ErrorExit(("Unrecognized code on line %d\n", lineIndex));
    
            bitCount -= MMRCodes[codeTableIndex].length;
            codeValue <<= MMRCodes[codeTableIndex].length;
    
            switch (codeTableIndex) {
    
            case 0:     // VL3
            case 1:     // VL2
            case 2:     // VL1
            case 3:     // V0
            case 4:     // VR1
            case 5:     // VR2
            case 6:     // VR3
    
                a1 = b1 + codeTableIndex - 3;
                OutputRun(plinebuf, a0, a1 - a0, color);
                color ^= 1;
                a0 = a1;
                break;

            case 7:     // PASSCODE

                OutputRun(plinebuf, a0, b2 - a0, color);
                a0 = b2;
                break;

            case 8:     // HORZCODE

                for (horiz=0; horiz < 2; horiz++) {

                    pCodeTable = color ? BlackRunCodes : WhiteRunCodes;

                    do {
                        ReadCompressedBits();
    
                        codeTableIndex = FindCode(pCodeTable, RUN_TABLE_SIZE, codeValue, bitCount);

                        if (codeTableIndex == -1)
                            ErrorExit(("Unrecognized code on line %d\n", lineIndex));

                        bitCount -= pCodeTable[codeTableIndex].length;
                        codeValue <<= pCodeTable[codeTableIndex].length;

                        run = (codeTableIndex < 64) ? codeTableIndex : (codeTableIndex - 63) * 64;
                        OutputRun(plinebuf, a0, run, color);
                        a0 += run;

                    } while (run >= 64);

                    color ^= 1;
                }
                break;
            }

            if (a0 == width)
                break;
            
            if (a0 > width)
                ErrorExit(("Too many pixels on line %d: %d\n", lineIndex, a0));

            b1 = NextChangingElement(prefline, a0, width, color ^ 1);
            b1 = NextChangingElement(prefline, b1, width, color);
        }

        CopyMemory(prefline, plinebuf, lineByteCnt);
        ZeroMemory(plinebuf, lineByteCnt);
    }

    ReadCompressedBits();

    if (codeValue != 0x00100100)
        ErrorExit(("Missing EOB after the last scanline: 0x%x\n", codeValue));

    while (bytecnt-- > 0) {

        if (*pBuffer++)
            ErrorExit(("Unused bits at the end\n"));
    }

    LocalFree((HLOCAL) prefline);
    LocalFree((HLOCAL) plinebuf);
}



VOID
ReverseBitOrder(
    PBYTE   pBuffer,
    LONG    count
    )

/*++

Routine Description:

    Reverse the bit order of compressed bitmap data

Arguments:

    pBuffer - Points to the compressed bitmap data buffer
    count - Specifies the size of the buffer

Return Value:

    NONE

--*/

{
    static const BYTE BitReverseTable[256] = {

        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
    };

    while (count-- > 0) {

        *pBuffer = BitReverseTable[*pBuffer];
        pBuffer++;
    }
}



INT _cdecl
main(
    INT     argc,
    CHAR  **argv
    )

{
    CHAR           *pInputFilename;
    INT             pageIndex;
    HANDLE          hFile;
    DWORD           nextIFDOffset, cb;
    TIFFFILEHEADER  tiffFileHeader;

    if (argc != 2) {

        printf("usage: %s filename\n", *argv);
        exit(-1);
    }

    pInputFilename = argv[1];

    //
    // Open the input file
    //

    hFile = CreateFile(pInputFilename,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        ErrorExit(("Failed to open input file: %s\n", pInputFilename));

    //
    // Read the TIFF file header information
    //

    if (!ReadFile(hFile, &tiffFileHeader, sizeof(tiffFileHeader), &cb, NULL) ||
        tiffFileHeader.magic1 != TIFF_MAGIC1 ||
        tiffFileHeader.magic2 != TIFF_MAGIC2 ||
        tiffFileHeader.signature != DRIVER_SIGNATURE)
    {
        ErrorExit(("Not an NT fax driver output file: %s\n", pInputFilename));
    }

    pageIndex = 1;
    nextIFDOffset = tiffFileHeader.firstIFD;

    do {

        FAXIFD  faxIFD;
        LONG    compressedBytes, compressedDataOffset;
        LONG    imageWidth, imageHeight;
        PBYTE   pBuffer;

        //
        // Read the IFD information
        //

        if (SetFilePointer(hFile,
                           nextIFDOffset - offsetof(FAXIFD, wIFDEntries),
                           NULL,
                           FILE_BEGIN) == 0xffffffff)
        {
            ErrorExit(("Couldn't locate the next IFD\n"));
        }

        if (! ReadFile(hFile, &faxIFD, sizeof(faxIFD), &cb, NULL))
            ErrorExit(("Couldn't read IFD entries\n"));

        if (faxIFD.wIFDEntries != NUM_IFD_ENTRIES ||
            faxIFD.filler != DRIVER_SIGNATURE && faxIFD.filler != 0)
        {
            ErrorExit(("Not an NT fax driver output file\n"));
        }

        nextIFDOffset = faxIFD.nextIFDOffset;

        compressedBytes = faxIFD.ifd[IFD_STRIPBYTECOUNTS].value;
        compressedDataOffset = faxIFD.ifd[IFD_STRIPOFFSETS].value;
        imageWidth = faxIFD.ifd[IFD_IMAGEWIDTH].value;
        imageHeight = faxIFD.ifd[IFD_IMAGEHEIGHT].value;

        printf("Page #%d:\n", pageIndex++);
        printf("    width: %d\n", imageWidth);
        printf("    height: %d\n", imageHeight);
        printf("    compressed bytes: 0x%x\n", compressedBytes);

        if ((pBuffer = (PBYTE) LocalAlloc(LPTR, compressedBytes)) == NULL ||
            SetFilePointer(hFile, compressedDataOffset, NULL, FILE_BEGIN) == 0xffffffff ||
            !ReadFile(hFile, pBuffer, compressedBytes, &cb, NULL))
        {
            ErrorExit(("Couldn't read compressed bitmap data\n"));
        }

        //
        // If the fill order is LSB, reverse it to MSB
        //

        if (faxIFD.ifd[IFD_FILLORDER].value == FILLORDER_LSB)
            ReverseBitOrder(pBuffer, compressedBytes);

        //
        // Decode compressed MMR data
        //

        DecodeMMR(pBuffer, compressedBytes, imageWidth, imageHeight);

        LocalFree((HLOCAL) pBuffer);

    } while (nextIFDOffset);

    CloseHandle(hFile);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\test\mapi\mapitest.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <mapi.h>

#define Assert(cond) { \
            if (! (cond)) { \
                printf("Error on line: %d\n", __LINE__); \
                exit(-1); \
            } \
        }

#define Error(arg) printf arg
#define ErrorExit(arg) { printf arg; exit(-1); }

//
// Global variables used for accessing MAPI services
//

static HINSTANCE        hLibMapi = NULL;
ULONG                   lhMapiSession = 0;
LPMAPILOGON             lpfnMAPILogon = NULL;
LPMAPILOGOFF            lpfnMAPILogoff = NULL;
LPMAPIADDRESS           lpfnMAPIAddress = NULL;
LPMAPIFREEBUFFER        lpfnMAPIFreeBuffer = NULL;

//
// Global variables used for accessing MAPI services
//

static HINSTANCE        hLibMAPI = NULL;



BOOL
InitMapiServices(
    VOID
    )

/*++

Routine Description:

    Initialize Simple MAPI services if necessary

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    //
    // Load MAPI32.DLL into memory if necessary
    //

    if (hLibMapi == NULL && (hLibMapi = LoadLibrary(TEXT("MAPI32.DLL")))) {

        //
        // Get pointers to various Simple MAPI functions
        //

        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress(hLibMapi, "MAPILogon");
        lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(hLibMapi, "MAPILogoff");
        lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress(hLibMapi, "MAPIAddress");
        lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(hLibMapi, "MAPIFreeBuffer");

        if (!lpfnMAPILogon || !lpfnMAPILogoff || !lpfnMAPIAddress || !lpfnMAPIFreeBuffer) {

            //
            // Clean up properly in case of error
            //

            FreeLibrary(hLibMapi);
            hLibMapi = NULL;
        }
    }

    return hLibMapi != NULL;
}



VOID
DeinitMapiServices(
    VOID
    )

/*++

Routine Description:

    Deinitialize Simple MAPI services if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (hLibMapi) {


        if (lhMapiSession)
            lpfnMAPILogoff(lhMapiSession, 0, 0, 0);

        lhMapiSession = 0;
        FreeLibrary(hLibMapi);
        hLibMapi = NULL;
    }
}



VOID
DoMapiLogon(
    HWND        hDlg
    )

/*++

Routine Description:

    Logon MAPI to in order to access address book

Arguments:

    hDlg - Handle to the fax recipient wizard page

Return Value:

    NONE

Note:

    _TODO_
    MAPI is not Unicoded enabled on NT!!!
    Must revisit this code once that's fixed.

--*/

{
    //
    // Check if we're already logged on to MAPI
    //


    if (lpfnMAPILogon(0,
                      "davidx",
                      NULL,
                      MAPI_LOGON_UI,
                      0,
                      &lhMapiSession) != SUCCESS_SUCCESS)
    {
        Error(("MAPI logon failed\n"));
        lhMapiSession = 0;
    }
}



VOID
DoAddressBook(
    VOID
    )

{
    lpMapiRecipDesc pNewRecips;
    ULONG           nNewRecips, recipIndex;
    LONG            status;

    //
    // Initialize MAPI services
    //

    if (! InitMapiServices()) {

        Error(("InitMapiServices failed\n"));
        return;
    }

    //
    // Logon to MAPI
    //

    DoMapiLogon(NULL);

    //
    // Present the address dialog
    //

    status = lpfnMAPIAddress(lhMapiSession, 0, NULL, 1, NULL, 0, NULL,
                             MAPI_LOGON_UI, 0, &nNewRecips, &pNewRecips);

    if (status != SUCCESS_SUCCESS) {

        Error(("MAPIAddress failed: %d\n", status));
        return;
    }

    //
    // Dump out each selected recipient
    //

    for (recipIndex=0; recipIndex < nNewRecips; recipIndex++) {

        printf("Name: %s, Address: %s\n",
               pNewRecips[recipIndex].lpszName,
               pNewRecips[recipIndex].lpszAddress);
    }

    if (pNewRecips)
        lpfnMAPIFreeBuffer(pNewRecips);
}

INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    INT buffer[1024], index;

    for (index=0; index < 1024; index++)
        buffer[index] = index ^ 0x12345678;

    DoAddressBook();
    DeinitMapiServices();

    for (index=0; index < 1024; index++)
        Assert(buffer[index] == (index ^ 0x12345678));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\test\addfax\adddrv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    adddrv.c

Abstract:

    Add a fax printer to the system
    Usage: adddrv printer-name port-name driver-directory environment

Environment:

	Windows NT fax driver

Revision History:

	02/20/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winspool.h>

#define Assert(cond) { \
            if (! (cond)) { \
                printf("Error on line: %d\n", __LINE__); \
                exit(-1); \
            } \
        }

#define Error(arg) { printf arg; exit(-1); }

#define FAX_DRIVER_NAME "Windows NT Fax Driver"

PSTR pPrinterName;
PSTR pPortName;
PSTR pDriverDirectory;
PSTR pEnvironment;

//
// Add the driver files to the system
//

VOID
AddFaxPrinterDriver(
    VOID
    )

{
    DRIVER_INFO_2 driverInfo2 = {

        2,
        FAX_DRIVER_NAME,
        pEnvironment,
        "faxdrv.dll",   // driverFile,
        "faxwiz.dll",   // dataFile,
        "faxui.dll",    // configFile
    };

    if (! AddPrinterDriver(NULL, 2, (LPBYTE) &driverInfo2))
        Error(("AddPrinterDriver failed: %d\n", GetLastError()));
}

//
// Add a fax printer to the system
//

VOID
AddFaxPrinter(
    VOID
    )

{
    PRINTER_INFO_2  printerInfo2 = {

        NULL,
        pPrinterName,
        NULL,
        pPortName,
        FAX_DRIVER_NAME,
        NULL,
        NULL,
        NULL,
        NULL,
        "winprint",
        "RAW",
        NULL,
        NULL,
    };

    HANDLE  hPrinter;

    if (! (hPrinter = AddPrinter(NULL, 2, (LPBYTE) &printerInfo2)))
        Error(("AddPrinter failed: %d\n", GetLastError()));

    PrinterProperties(NULL, hPrinter);
    ClosePrinter(hPrinter);
}

INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    if (argc != 5)
        Error(("Usage: %s printer-name port-name driver-directory environment\n", *argv));

    pPrinterName = *++argv;
    pPortName = *++argv;
    pDriverDirectory = *++argv;
    pEnvironment = *++argv;

    AddFaxPrinterDriver();
    AddFaxPrinter();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\sendnote\sendnote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendnote.c

Abstract:

    Utility program to send fax notes

Environment:

        Windows NT fax driver

Revision History:

        02/15/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "sendnote.h"
#include "tiff.h"
#include "tifflib.h"

#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

//
// Data structure used to pass parameters to "Select Fax Printer" dialog
//

typedef struct {

    LPTSTR          pPrinterName;
    INT             cPrinters;
    PRINTER_INFO_2 *pPrinterInfo2;

} DLGPARAM, *PDLGPARAM;

//
// Global instance handle
//

HMODULE ghInstance = NULL;
INT     _debugLevel = 0;

//
// Maximum length of message strings
//

#define MAX_MESSAGE_LEN     256

//
// Maximum length for a printer name
//

#define MAX_PRINTER_NAME    MAX_PATH

//
// Window NT fax driver name - currently printer driver name cannot be localized
// so it shouldn't be put into the string resource.
//

static TCHAR faxDriverName[] = TEXT("Windows NT Fax Driver");



VOID
InitSelectFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )

/*++

Routine Description:

    Initialize the "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Insert all fax printers into a listbox. Note that we've already filtered
    // out non-fax printers earlier by setting their pDriverName field to NULL.
    //

    if (! (hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)))
        return;

    for (printerIndex=0; printerIndex < pDlgParam->cPrinters; printerIndex++) {

        if (pDlgParam->pPrinterInfo2[printerIndex].pDriverName) {

            selIndex = (INT)SendMessage(hwndList,
                                        LB_ADDSTRING,
                                        0,
                                        (LPARAM) pDlgParam->pPrinterInfo2[printerIndex].pPrinterName);

            if (selIndex != LB_ERR) {

                if (SendMessage(hwndList, LB_SETITEMDATA, selIndex, printerIndex) == LB_ERR)
                    SendMessage(hwndList, LB_DELETESTRING, selIndex, 0);
            }
        }
    }

    //
    // Select the first fax printer in the list by default
    //

    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
}



BOOL
GetSelectedFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )

/*++

Routine Description:

    Remember the name of currently selected fax printer

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Get current selection index
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)) == NULL ||
        (selIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
    {
        return FALSE;
    }

    //
    // Retrieve the selected printer index
    //

    printerIndex = (INT)SendMessage(hwndList, LB_GETITEMDATA, selIndex, 0);

    if (printerIndex < 0 || printerIndex >= pDlgParam->cPrinters)
        return FALSE;

    //
    // Remember the selected fax printer name
    //

    _tcsncpy(pDlgParam->pPrinterName,
             pDlgParam->pPrinterInfo2[printerIndex].pPrinterName,
             MAX_PRINTER_NAME);

    return TRUE;
}



VOID
CenterWindowOnScreen(
    HWND    hwnd
    )

/*++

Routine Description:

    Place the specified windows in the center of the screen

Arguments:

    hwnd - Specifies a window to be centered

Return Value:

    NONE

--*/

{
    HWND    hwndDesktop;
    RECT    windowRect, screenRect;
    INT     windowWidth, windowHeight, screenWidth, screenHeight;

    //
    // Get screen dimension
    //

    hwndDesktop = GetDesktopWindow();
    GetWindowRect(hwndDesktop, &screenRect);
    screenWidth = screenRect.right - screenRect.left;
    screenHeight = screenRect.bottom - screenRect.top;

    //
    // Get window position
    //

    GetWindowRect(hwnd, &windowRect);
    windowWidth = windowRect.right - windowRect.left;
    windowHeight = windowRect.bottom - windowRect.top;

    //
    // Center the window on screen
    //

    MoveWindow(hwnd,
               screenRect.left + (screenWidth - windowWidth) / 2,
               screenRect.top + (screenHeight - windowHeight) / 2,
               windowWidth,
               windowHeight,
               FALSE);
}



INT_PTR CALLBACK
SelectPrinterDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   )

/*++

Routine Description:

    Dialog procedure for handling "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the dialog window
    uMsg, wParam, lParam - Dialog message and message parameters

Return Value:

    Depends on dialog message

--*/

{
    PDLGPARAM   pDlgParam;

    switch (uMsg) {

    case WM_INITDIALOG:

        //
        // Remember the pointer to DLGPARAM structure
        //

        pDlgParam = (PDLGPARAM) lParam;
        Assert(pDlgParam != NULL);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        CenterWindowOnScreen(hDlg);
        InitSelectFaxPrinter(hDlg, pDlgParam);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_FAXPRINTER_LIST:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                break;

            //
            // Fall through - double-clicking in the fax printer list
            // is treated the same as clicking OK button
            //

        case IDOK:

            //
            // User pressed OK to proceed
            //

            pDlgParam = (PDLGPARAM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pDlgParam != NULL);

            if (GetSelectedFaxPrinter(hDlg, pDlgParam))
                EndDialog(hDlg, IDOK);
            else
                MessageBeep(MB_OK);

            return TRUE;

        case IDCANCEL:

            //
            // User pressed Cancel to dismiss the dialog
            //

            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        break;
    }

    return FALSE;
}



VOID
DisplayErrorMessage(
    INT     errId
    )

/*++

Routine Description:

    Display an error message dialog

Arguments:

    errId - Specifies the resource ID of the error message string

Return Value:

    NONE

--*/

{
    TCHAR   errMsg[MAX_MESSAGE_LEN];

    LoadString(ghInstance, errId, errMsg, MAX_MESSAGE_LEN);
    MessageBox(NULL, errMsg, NULL, MB_OK | MB_ICONERROR);
}



BOOL
SelectFaxPrinter(
    LPTSTR      pPrinterName
    )

/*++

Routine Description:

    Select a fax printer to send note to

Arguments:

    pPrinterName - Points to a buffer for storing selected printer name

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PRINTER_INFO_2 *pPrinterInfo2;
    DWORD           index, cPrinters, cFaxPrinters;
    DLGPARAM        dlgParam;

    //
    // Enumerate the list of printers available on the system
    //

    pPrinterInfo2 = MyEnumPrinters(NULL, 2, &cPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);

    if (pPrinterInfo2 == NULL || cPrinters == 0) {

        MemFree(pPrinterInfo2);
        DisplayErrorMessage(IDS_NO_FAX_PRINTER);
        return FALSE;
    }

    //
    // Find out how many fax printers there are:
    //  case 1: no fax printer at all - display an error message
    //  case 2: only one fax printer - use it
    //  case 3: more than one fax printer - display a dialog to let user choose one
    //

    cFaxPrinters = 0;

    for (index=0; index < cPrinters; index++) {

        if (_tcscmp(pPrinterInfo2[index].pDriverName, faxDriverName) != EQUAL_STRING)
            pPrinterInfo2[index].pDriverName = NULL;
        else if (cFaxPrinters++ == 0)
            _tcsncpy(pPrinterName, pPrinterInfo2[index].pPrinterName, MAX_PRINTER_NAME);
    }

    switch (cFaxPrinters) {

    case 0:

        //
        // No fax printer is installed - display an error message
        //

        DisplayErrorMessage(IDS_NO_FAX_PRINTER);
        break;

    case 1:

        //
        // Exactly one fax printer is installed - use it
        //

        break;

    default:

        //
        // More than one fax printer is available - let use choose one
        //

        dlgParam.pPrinterInfo2 = pPrinterInfo2;
        dlgParam.cPrinters = cPrinters;
        dlgParam.pPrinterName = pPrinterName;

        if (DialogBoxParam(ghInstance,
                           MAKEINTRESOURCE(IDD_SELECT_FAXPRINTER),
                           NULL,
                           SelectPrinterDlgProc,
                           (LPARAM) &dlgParam) != IDOK)
        {
            cFaxPrinters = 0;
        }
        break;
    }

    pPrinterName[MAX_PRINTER_NAME-1] = NUL;
    MemFree(pPrinterInfo2);
    return cFaxPrinters > 0;
}


#ifdef FAX_SCAN_ENABLED

#if 0


BOOL
PrintTifFile(
    HDC PrinterDC,
    LPWSTR FileName
    )
{
    BOOL            Rval = TRUE;
    HANDLE          hFile;
    HANDLE          hMap;
    DWORD           i,j;
    INT             HorzRes;
    INT             VertRes;
    BOOL            Result = FALSE;
    DWORD           VertResFactor = 1;
    PTIFF_HEADER    TiffHdr;
    DWORD           NextIfdSeekPoint;
    WORD            NumDirEntries = 0;
    PTIFF_TAG       TiffTags = NULL;
    DWORD           ImageWidth = 0;
    DWORD           ImageHeight = 0;
    DWORD           DataSize = 0;
    DWORD           DataOffset = 0;
    DWORD           XRes = 0;
    DWORD           YRes = 0;
    LPBYTE          FileBytes;
    LPBYTE          Bitmap;
    LPBYTE          dPtr;
    LPBYTE          sPtr;
    INT             DestWidth;
    INT             DestHeight;
    FLOAT           ScaleX;
    FLOAT           ScaleY;
    FLOAT           Scale;
    DWORD           LineSize;
    DWORD           dontcare;
    PBITMAPINFO     SrcBitmapInfo;


    SrcBitmapInfo = (PBITMAPINFO) MemAlloc( sizeof(BITMAPINFO) + (sizeof(RGBQUAD)*32) );
    if (SrcBitmapInfo == NULL) {
        return FALSE;
    }

    SrcBitmapInfo->bmiHeader.biSize             = sizeof(BITMAPINFOHEADER);
    SrcBitmapInfo->bmiHeader.biWidth            = 0;
    SrcBitmapInfo->bmiHeader.biHeight           = 0;
    SrcBitmapInfo->bmiHeader.biPlanes           = 1;
    SrcBitmapInfo->bmiHeader.biBitCount         = 1;
    SrcBitmapInfo->bmiHeader.biCompression      = BI_RGB;
    SrcBitmapInfo->bmiHeader.biSizeImage        = 0;
    SrcBitmapInfo->bmiHeader.biXPelsPerMeter    = 7874;
    SrcBitmapInfo->bmiHeader.biYPelsPerMeter    = 7874;
    SrcBitmapInfo->bmiHeader.biClrUsed          = 0;
    SrcBitmapInfo->bmiHeader.biClrImportant     = 0;

    SrcBitmapInfo->bmiColors[0].rgbBlue         = 255;
    SrcBitmapInfo->bmiColors[0].rgbGreen        = 255;
    SrcBitmapInfo->bmiColors[0].rgbRed          = 255;
    SrcBitmapInfo->bmiColors[0].rgbReserved     = 0;
    SrcBitmapInfo->bmiColors[1].rgbBlue         = 0;
    SrcBitmapInfo->bmiColors[1].rgbGreen        = 0;
    SrcBitmapInfo->bmiColors[1].rgbRed          = 0;
    SrcBitmapInfo->bmiColors[1].rgbReserved     = 0;

    HorzRes = GetDeviceCaps( PrinterDC, HORZRES );
    VertRes = GetDeviceCaps( PrinterDC, VERTRES );

    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        Rval = FALSE;
        goto exit;
    }

    //
    // make sure the file is non-zero length
    //
    if (GetFileSize(hFile,&dontcare) == 0) {
    Rval = FALSE;    
        goto exit;
    }

    hMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
        );
    if (hMap == NULL) {
        Rval = FALSE;
        goto exit;
    }

    FileBytes = MapViewOfFile(
        hMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (FileBytes == NULL) {
        Rval = FALSE;
        goto exit;
    }

    TiffHdr = (PTIFF_HEADER) FileBytes;

    NextIfdSeekPoint = TiffHdr->IFDOffset;
    while (NextIfdSeekPoint) {
        NumDirEntries = *(LPWORD)(FileBytes+NextIfdSeekPoint);
        TiffTags = (PTIFF_TAG)(FileBytes+NextIfdSeekPoint+sizeof(WORD));
        NextIfdSeekPoint = *(LPDWORD)(TiffTags+NumDirEntries);
        for (i=0; i<NumDirEntries; i++) {
            switch (TiffTags[i].TagId) {
                case TIFFTAG_IMAGEWIDTH:
                    ImageWidth = TiffTags[i].DataOffset;
                    break;

                case TIFFTAG_IMAGELENGTH:
                    ImageHeight = TiffTags[i].DataOffset;
                    break;

                case TIFFTAG_STRIPBYTECOUNTS:
                    DataSize = TiffTags[i].DataOffset;
                    break;

                case TIFFTAG_STRIPOFFSETS:
                    DataOffset = TiffTags[i].DataOffset;
                    break;

                case TIFFTAG_XRESOLUTION:
                    XRes = *(LPDWORD)(FileBytes+TiffTags[i].DataOffset);
                    break;

                case TIFFTAG_YRESOLUTION:
                    YRes = *(LPDWORD)(FileBytes+TiffTags[i].DataOffset);
                    break;
            }
        }
        if (YRes <= 100) {
            SrcBitmapInfo->bmiHeader.biYPelsPerMeter /= 2;
            VertResFactor = 2;
        }
        LineSize = ImageWidth / 8;
        LineSize += (ImageWidth % 8) ? 1 : 0;
        Bitmap = (LPBYTE) VirtualAlloc( NULL, DataSize+(ImageHeight*sizeof(DWORD)), MEM_COMMIT, PAGE_READWRITE );
        if (Bitmap) {
            sPtr = FileBytes + DataOffset;
            dPtr = Bitmap;
            for (j=0; j<ImageHeight; j++) {
                CopyMemory( dPtr, sPtr, LineSize );
                sPtr += LineSize;
                dPtr = (LPBYTE) Align( 4, (ULONG_PTR)dPtr+LineSize );
            }
            StartPage( PrinterDC );
            ScaleX = (FLOAT) ImageWidth / (FLOAT) HorzRes;
            ScaleY = ((FLOAT) ImageHeight * VertResFactor) / (FLOAT) VertRes;
            Scale = ScaleX > ScaleY ? ScaleX : ScaleY;
            DestWidth = (int) ((FLOAT) ImageWidth / Scale);
            DestHeight = (int) (((FLOAT) ImageHeight * VertResFactor) / Scale);
            SrcBitmapInfo->bmiHeader.biWidth = ImageWidth;
            SrcBitmapInfo->bmiHeader.biHeight = - (INT) ImageHeight;
            StretchDIBits(
                PrinterDC,
                0,
                0,
                DestWidth,
                DestHeight,
                0,
                0,
                ImageWidth,
                ImageHeight,
                Bitmap,
                (BITMAPINFO *) &SrcBitmapInfo,
                DIB_RGB_COLORS,
                SRCCOPY
                );
            EndPage( PrinterDC );
            VirtualFree( Bitmap, 0, MEM_RELEASE );
        } else {
            Rval = FALSE;
        }
    }

exit:
    if (FileBytes) {
        UnmapViewOfFile( FileBytes );
    }
    if (hMap) {
        CloseHandle( hMap );
    }
    if (hFile) {
        CloseHandle( hFile );
    }
    if (SrcBitmapInfo) {
        MemFree( SrcBitmapInfo );
    }

    return Rval;
}

#endif

#endif



INT
wWinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )

/*++

Routine Description:

    Application entry point

Arguments:

    hInstance - Identifies the current instance of the application
    hPrevInstance - Identifies the previous instance of the application
    lpCmdLine - Specifies the command line for the application.
    nCmdShow - Specifies how the window is to be shown

Return Value:

    0

--*/

{
    TCHAR       printerName[MAX_PRINTER_NAME];
    HDC         hdc;
    TCHAR       sendNote[100];
    DOCINFO     docInfo = {

        sizeof(DOCINFO),
        NULL,
        NULL,
        NULL,
        0,
    };

    ghInstance = hInstance;
    sendNote[0] = TEXT(' ');
    LoadString( ghInstance, IDS_SENDNOTE, sendNote, sizeof(sendNote)/sizeof(TCHAR) );
    docInfo.lpszDocName = sendNote ;

    //
    // Check if a printer name is specified on the command line
    //

    ZeroMemory(printerName, sizeof(printerName));

    if (lpCmdLine) {

        _tcsncpy(printerName, lpCmdLine, MAX_PRINTER_NAME);
        printerName[MAX_PRINTER_NAME-1] = NUL;
    }

    //
    // Select a fax printer to send note to if necessary
    //

    if (IsEmptyString(printerName) && !SelectFaxPrinter(printerName))
        return 0;

    Verbose(("Send note to fax printer: %ws\n", printerName));

    //
    // Set an environment variable so that the driver knows
    // the current application is "Send Note" utility.
    //

    SetEnvironmentVariable(TEXT("NTFaxSendNote"), TEXT("1"));

    //
    // Create a printer DC and print an empty job
    //

    if (! (hdc = CreateDC(NULL, printerName, NULL, NULL))) {

        DisplayErrorMessage(IDS_CREATEDC_FAILED);

    } else {

        if (StartDoc(hdc, &docInfo) > 0) {
#ifdef FAX_SCAN_ENABLED
            TCHAR       FileName[MAX_PATH];
            if (GetEnvironmentVariable( TEXT("ScanTifName"), FileName, sizeof(FileName)/sizeof(TCHAR) )) {
                PrintTiffFile( hdc, FileName );
                DeleteFile( FileName );
            }
#endif
            EndDoc(hdc);
        }

        DeleteDC(hdc);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\test\tapi\tapitest.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <tapi.h>

//
// Fake various macros
//

#define MemAlloc(size) ((PVOID) LocalAlloc(LMEM_FIXED, size))
#define MemFree(p) { if (p) LocalFree((HLOCAL) (p)); }
#define Verbose(arg) printf arg
#define Warning(arg) printf arg
#define Error(arg) printf arg
#define Assert(cond) { \
            if (! (cond)) { \
                printf("Error on line: %d\n", __LINE__); \
                exit(-1); \
            } \
        }

//
// Default TAPI version number
//

#define TAPI_VERSION    0x00020000

//
// Global variables used for accessing TAPI services
//

static HLINEAPP          tapiLineApp = NULL;
static DWORD             tapiVersion = TAPI_VERSION;
static LPLINECOUNTRYLIST pLineCountryList = NULL;

//
// Global instance handle
//

HMODULE ghInstance;



VOID CALLBACK
TapiLineCallback(
    DWORD   hDevice,
    DWORD   dwMessage,
    DWORD   dwInstance,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
    )

/*++

Routine Description:

    TAPI line callback function: Even though we don't actually have anything
    to do here, we must provide a callback function to keep TAPI happy.

Arguments:

    hDevice     - Line or call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO index
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    NONE

--*/

{
}



BOOL
GetCountries(
    VOID
    )

/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

NOTE:

    We cache the result of lineGetCountry here since it's incredibly slow.
    This function must be invoked inside a critical section since it updates
    globally shared information.

--*/

#define INITIAL_SIZE_ALL_COUNTRY    17000

{
    DWORD   cbNeeded;
    LONG    status;
    INT     repeatCnt = 0;

    if (pLineCountryList == NULL) {

        //
        // Initial buffer size
        //

        cbNeeded = INITIAL_SIZE_ALL_COUNTRY;

        while (TRUE) {

            MemFree(pLineCountryList);

            if (! (pLineCountryList = MemAlloc(cbNeeded))) {

                Error(("Memory allocation failed\n"));
                return FALSE;
            }

            pLineCountryList->dwTotalSize = cbNeeded;
            status = lineGetCountry(0, tapiVersion, pLineCountryList);

            if ((pLineCountryList->dwNeededSize > pLineCountryList->dwTotalSize) &&
                (status == NO_ERROR ||
                 status == LINEERR_STRUCTURETOOSMALL ||
                 status == LINEERR_NOMEM) &&
                (repeatCnt++ == 0))
            {
                cbNeeded = pLineCountryList->dwNeededSize + 1;
                Warning(("LINECOUNTRYLIST size: %d\n", cbNeeded));
                continue;
            }

            if (status != NO_ERROR) {

                Error(("lineGetCountry failed: %x\n", status));
                MemFree(pLineCountryList);
                pLineCountryList = NULL;

            } else
                Verbose(("Number of countries: %d\n", pLineCountryList->dwNumCountries));

            break;
        }
    }

    return pLineCountryList != NULL;
}



BOOL
InitTapiService(
    VOID
    )

/*++

Routine Description:

    Initialize the TAPI service if necessary

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   nLineDevs;
    LONG    status;
    DWORD   startTimer;

    if (tapiLineApp == NULL) {

        startTimer = GetCurrentTime();
        status = lineInitialize(&tapiLineApp,
                                ghInstance,
                                TapiLineCallback,
                                "Fax Driver",
                                &nLineDevs);

        if (status != NO_ERROR) {

            Error(("lineInitialize failed: %x\n", status));
            tapiLineApp = NULL;

        } else {

            //
            // Don't call lineNegotiateAPIVersion if nLineDevs is 0.
            //

            Verbose(("Number of lines: %d\n", nLineDevs));

            if (nLineDevs > 0) {

                LINEEXTENSIONID lineExtensionID;

                status = lineNegotiateAPIVersion(tapiLineApp,
                                                 0,
                                                 TAPI_VERSION,
                                                 TAPI_VERSION,
                                                 &tapiVersion,
                                                 &lineExtensionID);

                if (status != NO_ERROR) {

                    Error(("lineNegotiateAPIVersion failed: %x\n", status));
                    tapiVersion = TAPI_VERSION;
                }
            }

            printf("TAPI initialization took %d milliseconds\n", GetCurrentTime() - startTimer);

            //
            // Get a list of countries from TAPI
            //

            startTimer = GetCurrentTime();
            GetCountries();
            printf("lineGetCountry took %d milliseconds\n", GetCurrentTime() - startTimer);
        }
    }

    return tapiLineApp != NULL;
}



VOID
DeinitTapiServices(
    VOID
    )

/*++

Routine Description:

    Deinitialize the TAPI service if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    MemFree(pLineCountryList);
    pLineCountryList = NULL;

    if (tapiLineApp) {

        lineShutdown(tapiLineApp);
        tapiLineApp = NULL;
    }
}



DWORD
GetDefaultCountryID(
    VOID
    )

/*++

Routine Description:

    Return the default country ID for the current location

Arguments:

    NONE

Return Value:

    The current ID for the current location

--*/

#define INITIAL_LINETRANSLATECAPS_SIZE  2600

{
    DWORD               cbNeeded, countryId = 0;
    LONG                status;
    INT                 repeatCnt = 0;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;

    if (tapiLineApp == NULL)
        return 0;

    //
    // Get the LINETRANSLATECAPS structure from TAPI
    //

    cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;

    while (TRUE) {

        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = MemAlloc(cbNeeded))) {

            Error(("Memory allocation failed\n"));
            return 0;
        }

        pTranslateCaps->dwTotalSize = cbNeeded;

        if ((status = lineGetTranslateCaps(tapiLineApp, tapiVersion, pTranslateCaps)) == NO_ERROR)
            break;

        if ((status != LINEERR_STRUCTURETOOSMALL && status != LINEERR_NOMEM) ||
            (repeatCnt++ != 0))
        {

            Error(("lineGetTranslateCaps failed: %x\n", status));
            MemFree(pTranslateCaps);
            return 0;
        }

        cbNeeded = pTranslateCaps->dwNeededSize;
        Warning(("LINETRANSLATECAPS size: %d\n", cbNeeded));
    }

    //
    // Find the current location entry
    //

    if (pTranslateCaps->dwLocationListSize && pTranslateCaps->dwLocationListOffset) {

        LPLINELOCATIONENTRY pLineLocationEntry;
        DWORD               index;

        pLineLocationEntry = (LPLINELOCATIONENTRY)
            ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);

        for (index=0; index < pTranslateCaps->dwNumLocations; index++, pLineLocationEntry++) {

            if (pLineLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID) {

                countryId = pLineLocationEntry->dwCountryID;
                break;
            }
        }
    }

    MemFree(pTranslateCaps);
    return countryId;
}



INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    ghInstance = GetModuleHandle(NULL);
    InitTapiService();
    printf("Default country ID: %d\n", GetDefaultCountryID());
    DeinitTapiServices();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\test\faxdump\faxdump.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdump.c

Abstract:

    Extract a single page out of the fax driver output file

Environment:

	Fax driver, utility

Revision History:

	01/11/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"

typedef PVOID PDEVDATA;
#include "faxtiff.h"

#include <ctype.h>
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#define ErrorExit(arg)  { printf arg; exit(-1); }

VOID usage(CHAR *);



INT _cdecl
main(
    INT     argc,
    CHAR  **argv
    )

{
    CHAR           *pProgramName, *pInputFilename, *pChar;
    INT             pageNumber, pageIndex;
    INT             infile, outfile;
    CHAR            outputFilename[MAX_PATH], *pOutputFilenameSuffix;
    DWORD           nextIFDOffset;
    TIFFFILEHEADER  tiffFileHeader;

    pProgramName = *argv++;
    argc--;
    pageNumber = 1;

    //
    // Parse command line options
    //

    while (argc && (**argv == '-' || **argv == '/')) {

        pChar = (*argv) + 1;
        argv++; argc--;

        if (isdigit(*pChar)) {

            pageNumber = atoi(pChar);

        } else {

            usage(pProgramName);
        }
    }

    if (argc != 1)
        usage(pProgramName);

    pInputFilename = *argv;

    //
    // Generate output filename
    //

    strcpy(outputFilename, pInputFilename);

    pChar = outputFilename;
    pOutputFilenameSuffix = NULL;

    while (*pChar) {

        if (*pChar == '.')
            pOutputFilenameSuffix = pChar;

        pChar++;
    }

    if (pOutputFilenameSuffix == NULL)
        pOutputFilenameSuffix = pChar;

    //
    // Open the input file
    //

    if ((infile = _open(pInputFilename, O_BINARY|O_RDONLY, 0)) == -1)
        ErrorExit(("Failed to open input file: %s\n", pInputFilename));

    //
    // Read the TIFF file header information
    //

    if (_read(infile, &tiffFileHeader, sizeof(tiffFileHeader)) != sizeof(tiffFileHeader) ||
        tiffFileHeader.magic1 != TIFF_MAGIC1 ||
        tiffFileHeader.magic2 != TIFF_MAGIC2 ||
        tiffFileHeader.signature != DRIVER_SIGNATURE)
    {
        ErrorExit(("Not an NT fax driver output file: %s\n", pInputFilename));
    }

    pageIndex = 1;
    nextIFDOffset = tiffFileHeader.firstIFD;

    do {

        FAXIFD  faxIFD;

        //
        // Read the IFD information
        //

        if (_lseek(infile, nextIFDOffset - offsetof(FAXIFD, wIFDEntries), SEEK_SET) == -1)
            ErrorExit(("Couldn't locate the next IFD\n"));

        if (_read(infile, &faxIFD, sizeof(faxIFD)) != sizeof(faxIFD))
            ErrorExit(("Couldn't read IFD entries\n"));

        if (faxIFD.wIFDEntries != NUM_IFD_ENTRIES ||
            faxIFD.filler != DRIVER_SIGNATURE && faxIFD.filler != 0)
        {
            ErrorExit(("Not an NT fax driver output file\n"));
        }

        nextIFDOffset = faxIFD.nextIFDOffset;
        
        //
        // Create an output TIFF file if the page number matches what's specified
        //

        if (pageNumber == 0 || pageNumber == LOWORD(faxIFD.ifd[IFD_PAGENUMBER].value)+1) {

            LONG    offset, compressedBytes, compressedDataOffset;
            PBYTE   pBuffer;

            //
            // Generate output filename
            //
            
            sprintf(pOutputFilenameSuffix, "%d.tif", pageIndex);
            outfile = _open(outputFilename, O_CREAT|O_TRUNC|O_WRONLY|O_BINARY, _S_IWRITE);
            
            if (outfile == -1)
                ErrorExit(("Failed to create output file: %s\n", outputFilename));

            //
            // Output TIFF file header information
            //

            tiffFileHeader.firstIFD = sizeof(tiffFileHeader) + offsetof(FAXIFD, wIFDEntries);

            if (_write(outfile, &tiffFileHeader, sizeof(tiffFileHeader)) != sizeof(tiffFileHeader))
                ErrorExit(("Couldn't write TIFF file header information\n"));

            //
            // Munge the IFD information read from the input file
            // and calculate new offsets for composite values
            //

            offset = sizeof(tiffFileHeader);
            compressedBytes = faxIFD.ifd[IFD_STRIPBYTECOUNTS].value;
            compressedDataOffset = faxIFD.ifd[IFD_STRIPOFFSETS].value;

            faxIFD.ifd[IFD_PAGENUMBER].value = 0;
            faxIFD.ifd[IFD_STRIPOFFSETS].value = offset + sizeof(faxIFD);
            faxIFD.ifd[IFD_XRESOLUTION].value = offset + offsetof(FAXIFD, xresNum);
            faxIFD.ifd[IFD_YRESOLUTION].value = offset + offsetof(FAXIFD, yresNum);
            faxIFD.ifd[IFD_SOFTWARE].value = offset + offsetof(FAXIFD, software);

            faxIFD.nextIFDOffset = faxIFD.filler = 0;

            //
            // Write new IFD information to the output file
            //

            if (_write(outfile, &faxIFD, sizeof(faxIFD)) != sizeof(faxIFD))
                ErrorExit(("Couldn't write TIFF IFD information\n"));

            //
            // Copy the compressed bitmap data to the output file
            //

            if ((pBuffer = malloc(compressedBytes)) == NULL ||
                _lseek(infile, compressedDataOffset, SEEK_SET) == -1 ||
                _read(infile, pBuffer, compressedBytes) != compressedBytes ||
                _write(outfile, pBuffer, compressedBytes) != compressedBytes)
            {
                ErrorExit(("Couldn't copy compressed bitmap data\n"));
            }

            free(pBuffer);
            _close(outfile);
        }

    } while (nextIFDOffset && pageIndex++ != pageNumber);

    _close(infile);
    return 0;
}



VOID
usage(
    CHAR   *pProgramName
    )

{
    printf("usage: %s -N filename\n", pProgramName);
    printf("    where N is the page number to be extracted\n");
    printf("    use 0 to specify all pages in the file\n");
    exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\cl2and20\cl2spec.h ===
#define STARTSENDMODE_TIMEOUT 40000L     // Sending Timeout needs to be pretty long!!!
#define LOCALCOMMAND_TIMEOUT  6000L    // for commands sent to modem  but not when connected
#define ANS_LOCALCOMMAND_TIMEOUT  1000L    // for commands sent to modem when answering (during ringing)

#define         CLASS2_BAUDRATE         19200
#define         NUMBER_OF_DIS_VALUES    8
#define         NUMBER_OF_DCS_VALUES    8
#define         MORE_PAGES              10
#define         NO_MORE_PAGES           20

// Note this comes from icomfile.h!!!!
#define         MAXUSERATCMDLEN         80



//  Class 2 DCE Response Codes.
#define CL2DCE_CONNECT          1
#define CL2DCE_OK               2
#define CL2DCE_XON              3
#define CL2DCE_FDCS             4
#define CL2DCE_FDIS             5
#define CL2DCE_FDTC             6
#define CL2DCE_FPOLL            7
#define CL2DCE_FCFR             8
#define CL2DCE_FTSI             9
#define CL2DCE_FCSI             10
#define CL2DCE_FCIG             11
#define CL2DCE_FNSF             12
#define CL2DCE_FNSS             13
#define CL2DCE_FNSC             14
#define CL2DCE_FHT              15
#define CL2DCE_FHR              16
#define CL2DCE_FCON             17
#define CL2DCE_FVOICE           18
#define CL2DCE_FET              19
#define CL2DCE_FPTS             20
#define CL2DCE_FHNG             21
#define CL2DCE_FDM              22


#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03


BOOL ParseFPTS_SendAck(PThrdGlbl pTG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\cl2and20\cl2and20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Classes 2 and 2.0 fax-modem T.30 driver
    
Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    

Revision History:

--*/

                                              
                                              
                                              
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"



WORD Class2CodeToBPS[16] =
{
/* V27_2400             0 */    2400,
/* V27_4800             1 */    4800,
/* V29_V17_7200         2 */    7200,
/* V29_V17_9600         3 */    9600,
/* V33_V17_12000        4 */    12000,
/* V33_V17_14400        5 */    14400,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
};
          
// Speeds for Class2HayesSyncSpeed to try
UWORD rguwClass2Speeds[] = {19200, 9600, 2400, 1200, 0};





BOOL ParseFPTS_SendAck(PThrdGlbl pTG)
{
        BOOL fPageAck = FALSE;
        UWORD count;

        // Acknowledge that we sent the page
        // Parse the FPTS response and see if the page is good or bad.
        pTG->class2_commands.parameters[0][1] = 0;
        pTG->class2_commands.parameters[1][1] = 0;
        pTG->class2_commands.parameters[2][1] = 0;

        if (pTG->ModemClass == MODEM_CLASS2) {
           Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }
        else {
           Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }

        for(count=0; count < pTG->class2_commands.comm_count; ++count)
        {
                switch (pTG->class2_commands.command[count])
                {
                        case  CL2DCE_FPTS:
                                if( pTG->class2_commands.parameters[count][0] == 1)
                                {
                                        (MyDebugPrint (pTG, LOG_ALL, "Found good FPTS\n\r"));
                                        fPageAck = TRUE;
                                        // Exar hack!!!
                                        // Exar modems give FPTS:1 for good pages and
                                        // FPTS:1,2,0,0 for bad. So, look for the 1,2
                                        // if this is an EXAR. Otherwise, 1 means good.
                                        if (pTG->CurrentMFRSpec.bIsExar)
                                        {
                                                if( pTG->class2_commands.parameters[count][1] == 2)
                                                {
                                                        (MyDebugPrint (pTG, LOG_ALL, "Nope - really Found bad FPTS\n\r"));
                                                        fPageAck = FALSE;
                                                }
                                        }
                                }
                                else if (pTG->class2_commands.parameters[count][0] == 2 )
                                {
                                        (MyDebugPrint (pTG, LOG_ALL, "Found bad FPTS\n\r"));
                                        fPageAck = FALSE;
                                }
                                break;
                        default:
                                break;
                }
        }
        ICommSendPageAck(pTG, fPageAck);
        return fPageAck;
}





USHORT Class2Dial(PThrdGlbl pTG, LPSTR lpszDial)
{
        UWORD uwLen, uwDialStringLen;
        ULONG ulTimeout;
        SWORD swLen;
        USHORT  uRet;
        BYTE    bBuf[DIALBUFSIZE];
        char chMod = pTG->NCUParams2.chDialModifier;


        BG_CHK(lpszDial);

        //// faxTlog(("Entering Class 2 Dial\r\n"));

        // Send the predial command
        if(pTG->lpCmdTab->szPreDial && (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreDial)))
        {
                if(Class2iModemDialog(pTG, (LPSTR)pTG->lpCmdTab->szPreDial, swLen,
                        10000L, TRUE, 0,
                        pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR)NULL) != 1)
                {
                  (MyDebugPrint (pTG, LOG_ALL, "<<WARNING>> Error on User's PreDial string: %s\r\n", (LPSTR)pTG->lpCmdTab->szPreDial));

                }
        }

#if 1
        // If the dial string already has a T or P prefix, we use that
        // instead.
        {
                char c=0;
                while((c=*lpszDial) && c==' ') *lpszDial++;
                if (c=='t'|| c=='T' || c=='p'|| c=='P')
                {
                        chMod = c;
                        lpszDial++;
                        while((c=*lpszDial) && c==' ') *lpszDial++;
                }

        }
#endif //1

        uwLen = (UWORD)wsprintf(bBuf, pTG->cbszCLASS2_DIAL,
                       chMod, (LPSTR)lpszDial);

// Need to set an approriate timeout here. A minimum of 15secs is too short
// (experiment calling machines within a PABX), plus one has to give extra
// time for machines that pick up after 2 or 4 rings and also for long distance
// calls. I take a minumum of 30secs and add 3secs for each digits over 7
// (unless it's pulse dial in which case I add 8secs/digit).
// (I'm assuming that a long-distance call will take a minimum of 8 digits
// anywhere in ths world!). Fax machines I've tested wait about 30secs
// independent of everything.

        uwDialStringLen = (UWORD)_fstrlen(lpszDial);
        ulTimeout = 60000L;
        if(uwDialStringLen > 7)
        ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000) * (uwDialStringLen - 7);

        if(pTG->NCUParams2.AnswerTimeout != -1 &&
                (((ULONG)pTG->NCUParams2.AnswerTimeout * 1000L) > ulTimeout))
                        ulTimeout = 1000L * (ULONG)pTG->NCUParams2.AnswerTimeout;

        (MyDebugPrint (pTG, LOG_ALL, "\n\rDial String: %s size is %d\n\r",(LPB)bBuf,uwLen));

        if(pTG->fAbort)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2Dial--aborting\r\n"));
                pTG->fAbort = FALSE;
                Class2ModemHangup(pTG );
                return CONNECT_ERROR;
        }

        ICommStatus(pTG, T30STATS_DIALING, 0, 0, 0);

        uRet = Class2iModemDialog(pTG, (LPB)bBuf, uwLen,
                ulTimeout, TRUE, 0,
                pTG->cbszFCON, pTG->cbszCLASS2_BUSY, pTG->cbszCLASS2_NOANSWER,
                pTG->cbszCLASS2_NODIALTONE, pTG->cbszCLASS2_ERROR, (NPSTR)NULL);


        //// faxTlog(pTG, ("\n\rModemDial -- got %d response from Dialog\r\n", uRet));

        // If it was "ERROR", try again - maybe the predial command screwed
        // up somehow and left and ERROR hanging around?
        if (uRet == 5)
        {
          uRet = Class2iModemDialog(pTG, (LPB)bBuf, uwLen,
                ulTimeout, TRUE, 0,
                pTG->cbszFCON, pTG->cbszCLASS2_BUSY, pTG->cbszCLASS2_NOANSWER,
                pTG->cbszCLASS2_NODIALTONE, pTG->cbszCLASS2_ERROR, (NPSTR)NULL);


          //// faxTlog(pTG, ("\n\rModemDial -- 2nd %d response from Dialog\r\n", uRet));
        }


#if ((CONNECT_TIMEOUT==NCUDIAL_ERROR) && (CONNECT_BUSY==NCUDIAL_BUSY) && (CONNECT_NOANSWER==NCUDIAL_NOANSWER))
#       if ((CONNECT_NODIALTONE==NCUDIAL_NODIALTONE) && (CONNECT_ERROR==NCUDIAL_MODEMERROR))
#               pragma message("verified CONNECT defines")
#       else
#               error CONNECT defines not correct
#       endif
#else
#       error CONNECT defines not correct
#endif


        switch(uRet)
        {

        case CONNECT_TIMEOUT:
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got timeout\r\n")); 
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_NO_ANSWER);

           break;

        case CONNECT_OK: 
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got CONNECT\r\n"));
             
           break;


        case CONNECT_BUSY:  
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got BUSY\r\n"));
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_BUSY);
             
           break;

        case CONNECT_NOANSWER: 
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got NOANSWER\r\n")); 
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_NO_ANSWER);
             
           break;


        case CONNECT_NODIALTONE:
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got NODIALTONE\r\n"));
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_NO_DIAL_TONE);

           break;


        case CONNECT_ERROR:
           (MyDebugPrint (pTG, LOG_ALL, "Dial: Got an ERROR\r\n"));
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_NO_ANSWER);
            
           break;


        default:  
           uRet = CONNECT_ERROR;
           BG_CHK(FALSE);
           break;
        }

        BG_CHK(uRet>=0 && uRet<=5);

        if(uRet != CONNECT_OK)
        {
            if(!Class2ModemHangup(pTG ))
                    return CONNECT_ERROR;
        }

        return uRet;
}


// ACTIVESLICE defined in msched.h
#define IDLESLICE       500

#ifdef WFWBG
#  ifdef NOPRE
#    define MySleep(x)                                                                                          \
                BG_CHK(x==IDLESLICE); IFSetTimeSlice(IDLESLICE);                        \
                ExitDLLCritSection(); IFDllSleep(0); EnterDLLCritSection();     \
                IFSetTimeSlice(ACTIVESLICE);
#  else
#    define MySleep(x)                                                                          \
                BG_CHK(x==IDLESLICE); IFSetTimeSlice(IDLESLICE);        \
                IFDllSleep(0); IFSetTimeSlice(ACTIVESLICE);
#  endif
#endif //WFWBG


#if defined(WIN32) && defined(THREAD)
#       define MySleep(x) BG_CHK(x); Sleep(x);
#endif //WIN32 && THREAD

#ifdef IFK
#       define MySleep(x)       IFProcSleep(x)
#endif





// fImmediate indicates a manual answer
USHORT Class2Answer(PThrdGlbl pTG, BOOL fImmediate)
{

        USHORT  uRet;
        SWORD   swLen;
        int     i, PrevRings, Rings;
        NPSTR   sz;
        ULONG   ulWaitTime;


        (MyDebugPrint (pTG, LOG_ALL, "Entering Class2Answer\r\n"));


        // Default time we will wait after getting right number of rings
        // to allow input buffer to flush
        ulWaitTime = 500L;
        if(!fImmediate && pTG->NCUParams2.RingsBeforeAnswer>3)
        {
                startTimeOut(pTG, &pTG->toAnswer, (6000L * (pTG->NCUParams2.RingsBeforeAnswer-3)));
                for(PrevRings=0;;)
                {
                        if(pTG->fAbort)
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "Class2Answer--aborting\r\n"));
                                pTG->fAbort = FALSE;
                                Class2ModemHangup(pTG);
                                return CONNECT_ERROR;
                        }

                        // get S1 value & check it here.
                        // If we get an error don't look
                        // at return value. Just try again
                        if( (uRet=Class2iModemDialog(pTG, pTG->cbszQUERY_S1,
                          (UWORD) (strlen(pTG->cbszQUERY_S1) ),
                          2000L, TRUE, 0,
                          pTG->cbszCLASS2_OK, pTG->cbszZERO, pTG->cbszRING, pTG->cbszCLASS2_ERROR,
                                                        (C2PSTR)NULL) ) > 2)
                                goto xxxx;

                        // If the OK was matched, the answer to the ATS1 is in pTG->bLastReply2.
                        // If a string like "001" was matched, the answer is in
                        // pTG->bFoundReply.
                        if (uRet == 2) sz=pTG->bFoundReply;
                        else sz=pTG->bLastReply2;
                        for(i=0, Rings=0;
                                i<REPLYBUFSIZE && sz[i]; i++)
                        {
                                if(sz[i] >= '0' &&  sz[i] <= '9')
                                        Rings = Rings*10 + (sz[i] - '0');
                                // ignore all non-numeric chars
                        }
                        (MyDebugPrint (pTG, LOG_ALL, "Got %d Rings. Want %d\r\n", Rings, pTG->NCUParams2.RingsBeforeAnswer));


                        // See if the number of rings we have is more than the
                        // Autoanswer number of rings. Also, for those
                        // modems that always return 000 to ATS1, we will answer
                        // right away. 000 cannot be correct, and we don't want
                        // to get stuck looking at 000.
                        if( Rings >= (pTG->NCUParams2.RingsBeforeAnswer-3))
                                break;

                        // If we saw a 000, estimate how much time we had to wait
                        // to get to the total number of rings we wanted. Figure
                        // we were already at three rings or so.
                        // If we counted the rings, we will still wait 1/2 second
                        // to allow any "OK" that might be coming from the modem to
                        // appear. We then will flush the queue.
                        if (Rings == 0)
                        {
                                if (pTG->NCUParams2.RingsBeforeAnswer >= 4)
                                        ulWaitTime = (pTG->NCUParams2.RingsBeforeAnswer-3)*6000L;
                                else ulWaitTime = 500L;
                                break;
                        }

                        MySleep(IDLESLICE);

                xxxx:
                        if((Rings < PrevRings) || !checkTimeOut(pTG, &pTG->toAnswer))
                                break; 

                        PrevRings = Rings;
                }
        }

        // We may still have an "OK" coming from the modem as a result of the
        // ATS1 command. We need to wait a bit and flush it. In most cases we
        // just wait 500 milliseconds. But, if we saw a 000 from the ATS1, we
        // broke immediately out of the loop above, setting ulWaitTime to be
        // the approximate wait we need before answering the phone.

        startTimeOut(pTG, &pTG->toAnswer, ulWaitTime);
        while (checkTimeOut(pTG, &pTG->toAnswer)) {}
        FComFlush(pTG );


        // Send the preanswer command
        if(pTG->lpCmdTab->szPreAnswer &&
                        (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreAnswer)))
        {
                if(Class2iModemDialog(pTG, (LPSTR)pTG->lpCmdTab->szPreAnswer, swLen,
                        10000L, TRUE, 0,
                        pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR)NULL) != 1)
                {
                  (MyDebugPrint (pTG, LOG_ALL, "<<WARNING>> Error on User's PreAnswer str: %s\r\n", (LPSTR)pTG->lpCmdTab->szPreAnswer));

                }
        }


#define ANSWER_TIMEOUT 35000
// Need to wait reasonably long, so that we don't give up too easily
// 7/25/95 JosephJ This used to be 15000. Changed to 35000 because
// MWAVE devices needed that timeout. Also, T.30 says that callee
// should try to negotiate for T1 seconds. T1 = 35 +/- 5s.

        /*
        * Send ATA command. The result will be stored in the global
        * variable pTG->lpbResponseBuf2. We will parse that in the Class2Receive
        * routine.
        */

        ICommStatus(pTG, T30STATR_ANSWERING, 0, 0, 0);

        // Look for ERROR return first and try again if it happened
        if(( uRet = Class2iModemDialog(pTG, pTG->cbszATA, (UWORD) (strlen(pTG->cbszATA) ),
                ANSWER_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR,
                                pTG->cbszCLASS2_FHNG, (C2PSTR) NULL)) == 2)
        {
                (MyDebugPrint (pTG, LOG_ALL, "ATA returned ERROR on first try!\n\r"));
                // dunno why we try this a 2nd time. But this time if we get ERROR
                // dont exit. The Racal modem (bug#1982) gives ERROR followed by a
                // good response! Cant ignore ERROR the first time otherwise we'll
                // change the ATA--ERROR--ATA(repeat) behaviour which seems to be
                // explicitly desired for some cases. However we dont take any
                // action based on the return value of the 2nd try, so it's safe to
                // ignore ERROR here. Worst case we take longer to timeout.
                uRet = Class2iModemDialog(pTG, pTG->cbszATA, (UWORD) (strlen(pTG->cbszATA) ),
                 ANSWER_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_FHNG, (C2PSTR) NULL);
        }

        if (uRet != 1) // a '1' return indicates OK.
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2Answer: Can't get OK after ATA\r\n"));

                // try to hangup and sync with modem. This should work
                // even if phone is not really off hook

                if(!Class2ModemHangup(pTG ))
                {
                        // In WFW this can occur if an external modem has been
                        // powered down. so just drop thru & return ERROR
                        (MyDebugPrint (pTG, LOG_ALL, "Can't Hangup after ANSWERFAIL\r\n"));
                }
                return CONNECT_ERROR;
        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2Answer: SUCCESS!!!\n\r"));
                (MyDebugPrint (pTG, LOG_ALL, "ATA Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));
                return CONNECT_OK;
        }
}

#ifdef OBSOLETE_CODE
BOOL Class2ModemGoClass0(PThrdGlbl pTG)
{
        int i;

        for(i=0; i<3; i++)
        {
                if(!FComDirectSyncWriteFast(pTG,  (LPB)pTG->cbszCLASS2_GO_CLASS0,
                                strlen(pTG->cbszCLASS2_GO_CLASS0) ))
                        break;
                Class2TwiddleThumbs(pTG, 50L);
                FComSetBaudRate(pTG, 2400);
                FComFlush(pTG, );
                if(Class2ModemSync(pTG, ) >= 0)
                        return TRUE;
        }

        (MyDebugPrint (pTG, LOG_ALL, "Cant go to 2400 Baud/Data mode\r\n"));
        return FALSE;
}
#endif // OBSOLETE_CODE




SWORD Class2ModemSync(PThrdGlbl pTG)
{
        // The command used here must be guaranteed to be harmless,
        // side-effect free & non-dstructive. i.e. we can issue it
        // at any point in command mode without chnageing the state
        // of teh modem or disrupting anything.
        // ATZ does not qualify. AT does, I think.....
        SWORD ret_value;

        (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMSYNC: CALLING CLASS2HAYESSYNC.\r\n"));
        ret_value = Class2HayesSyncSpeed(pTG,  TRUE, pTG->cbszCLASS2_ATTEN,
                                        (UWORD) (strlen(pTG->cbszCLASS2_ATTEN) ) );
        (MyDebugPrint (pTG, LOG_ALL, "RETURN VALUE FROM HAYESSYNCSPEED: %d\r\n",ret_value));
        return ret_value;
}






BOOL Class2ModemHangup(PThrdGlbl pTG)
{

        (MyDebugPrint (pTG, LOG_ALL, "IN HANGUP.\r\n"));
        if(Class2HayesSyncSpeed(pTG,  TRUE, pTG->cbszCLASS2_HANGUP,
                        (UWORD) (strlen(pTG->cbszCLASS2_HANGUP) ) ) < 0)
        {
                (MyDebugPrint (pTG, LOG_ALL, "CLASS2 HANGUP: FAILED ONCE\r\n"));

                FComDTR(pTG, FALSE);          // Lower DTR on stubborn hangups in ModemHangup
                MY_TWIDDLETHUMBS(1000); // pause 1 second
                FComDTR(pTG, TRUE);           // raise it again. Some modems return to cmd state
                                                         // only when this is raised again

                if(Class2HayesSyncSpeed(pTG, TRUE, pTG->cbszCLASS2_HANGUP,
                                (UWORD) (strlen(pTG->cbszCLASS2_HANGUP) ) ) < 0)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "HANGUP: FAILED AGAIN\r\n"));
                        return FALSE;
                }
        }
        (MyDebugPrint (pTG, LOG_ALL, "---->HANGUP:  Completed Class2HayesSyncSpeed.\r\n"));

        if(!iModemGoClass(pTG, 0)) return FALSE;
        // Can also ignore this return value. Just for tidier cleanup
        (MyDebugPrint (pTG, LOG_ALL, "HANGUP:  Completed GoClass0.\r\n"));

        // Bug1982: Racal modem, doesnt accept ATA. So we send it a PreAnswer
        // command of ATS0=1, i.r. turning ON autoanswer. And we ignore the
        // ERROR response it gives to the subsequent ATAs. It then answers
        // 'automatically' and gives us all the right responses. On hangup
        // however we need to send an ATS0=0 to turn auto-answer off. The
        // ExitCommand is not sent at all in Class2 and in Class1 it is only
        // sent on releasing the modem, not between calls. So send an S0=0
        // after ATH0. If the modem doesnt like it we ignore the resp anyway.
        Class2iModemDialog(pTG, pTG->cbszCLASS2_CALLDONE, (UWORD) (strlen(pTG->cbszCLASS2_CALLDONE) ) ,
                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR,
                         (C2PSTR)NULL);

        return TRUE;
}





void Class2GetRecvPageAck(PThrdGlbl pTG)
{
        // Called by icomfile after a page has been received
        // If the page was good, the argument will be TRUE. The
        // global variable pTG->fRecvPageOK is set to the passed in
        // value.

    if (pTG->fPageIsBad) {
       pTG->fRecvPageOK = 0;
    }
    else {
       pTG->fRecvPageOK = 1;
    }

    // RSL: ICommGetRecvPageAck is irrelevant- pTG->fRecvPageOK is the real status from rx_thrd.
    // pTG->fRecvPageOK = ICommGetRecvPageAck(pTG, TRUE);    // sleep until we get it
    (MyDebugPrint (pTG, LOG_ALL, "Class2RecvPageAck: Page check =%d\n\r", pTG->fRecvPageOK));

    switch(pTG->fRecvPageOK)
        {
                case 0:
                case 1: break;
                default:
                        pTG->fRecvPageOK = 0;
                        Class2Abort(pTG, TRUE);
                        BG_CHK( FALSE);
                        break;
        }
}





void Class2Abort(PThrdGlbl pTG, BOOL fEnable)
{
        // Called when user invokes an abort - simply set the
        // abort flag to be true. Various places in the code look
        // for this flag and perform an abort. Flag was originally
        // set to false in LibMain (called upon startup).

        (MyDebugPrint (pTG, LOG_ALL, "Class2Abort: %s...\n\r", ((LPSTR)(fEnable?"Aborting":"Abort Done")) ));
        pTG->fAbort = fEnable;
}






BOOL Class2ModemAbort(PThrdGlbl pTG)
{
        // Try to abort modem in reasonable fashion - send the
        // abort command and then send hangup. The abort command
        // should hangup, but I am not convinced it always does!!!
        // It should not hurt to hang up again (I hope).

        // We'll use a long timeout here to let the abort take place.
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_ABORT, (UWORD) (strlen(pTG->cbszCLASS2_ABORT) ),
                        STARTSENDMODE_TIMEOUT, TRUE, 1, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                //Ignore failure
                (MyDebugPrint (pTG, LOG_ALL, "Class2ModemAbort: FK Failed!\n\r"));
        }

        return Class2ModemHangup(pTG );

}



#ifdef OBSOLETE_CODE
BOOL Class2ModemGoClass2(PThrdGlbl pTG)
{
        int i, speed;
        for(i=0; i<3; i++)
        {
                (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMGOCLASS2: Iteration %d\r\n",i));
                if(!FComDirectSyncWriteFast(pTG,  (LPB)pTG->cbszGO_CLASS2,
                                        strlen(pTG->cbszGO_CLASS2) ))
                        goto error;
                Class2TwiddleThumbs(50L);
                (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMGOCLASS2: SETTING BAUD RATE.\r\n"));
                FComSetBaudRate(pTG, CLASS2_BAUDRATE);
                (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMGOCLASS2: FLUSHING.\r\n"));
                FComFlush(pTG, );
                (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMGOCLASS2: SYNCING.\r\n"));
                speed=Class2ModemSync(pTG, );

                if(speed==0)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "CLASS2MODEMGOCLASS2: RETURNING TRUE.\r\n"));
                        return TRUE;
                }
                else if(speed==CLASS2_BAUDRATE)
                {
                  (MyDebugPrint (pTG, LOG_ALL, "Go Class-2. Didn't sync the first time!!??\r\n"));
                  return TRUE;
                }
        }
error:
        // error is already set to ERR_NO_RESPONSE inside Class2HayesSync()
        (MyDebugPrint (pTG, LOG_ALL, "Cant go to 19.2 kBaud/Fax mode\r\n"));
        return FALSE;
}
#endif // OBSOLETE_CODE






SWORD Class2HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, C2PSTR cbszCommand, UWORD uwLen)
{
        /* Internal routine to synchronize with the modem's speed.  Tries to
           get a response from the modem by trying the speeds in rglSpeeds
           in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
           a response before trying to reset the speeds.

           Returns the speed it found, 0 if they're in sync upon entry (only
           checked if fTryCurrent!=0), or -1 if it couldn't sync.
        */
        // short i;

        /*  This was initially set to -1, which has to be wrong, since you
            do a BG_CHK to make sure fTryCurrent is TRUE, meaning you want
            to try the current speed.  In this case, -1 would be an invalid
            index.   KDB  */
        short ilWhich = 0;

        BG_CHK( fTryCurrent);
        // has to be TRUE, or we won't work with autobauding modems

        /*  I don't understand how this would ever get executed.  KDB */
        if (!fTryCurrent)
                if(!FComSetBaudRate(pTG,  rguwClass2Speeds[++ilWhich]))
                        return -1;

        for(;;)
        {
                //// faxTlog(("Sync Trying: ilWhich=%d  speed=%d\r\n", ilWhich, rguwClass2Speeds[ilWhich]));


                if(Class2SyncModemDialog(pTG,  cbszCommand, uwLen, pTG->cbszCLASS2_OK))
                {
                //// faxTlog(("Succeeded in Syncing at Speed = %d (il=%d)\r\n",rguwClass2Speeds[ilWhich], ilWhich));

                    return (ilWhich>=0 ? rguwClass2Speeds[ilWhich] : 0);
                }

                /* failed.  try next speed. */
                if (rguwClass2Speeds[++ilWhich]==0)
                {
                        // Tried all speeds. No response
                        (MyDebugPrint (pTG, LOG_ALL, "Cannot Sync with Modem on Command %s\r\n", (LPSTR)cbszCommand));
                    return -1;
                }
                if(!FComSetBaudRate(pTG,  rguwClass2Speeds[ilWhich]))
                        return -1;
        }
}






USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout)
{
        USHORT uRet;

        *lplpbf = MyAllocBuf(pTG, MY_BIGBUF_SIZE);

        // //// faxTlog(("In ModemRecvBuf lplpbf=%08lx uTimeout=%d\r\n", lplpbf, uTimeout));

        uRet = Class2ModemRecvData(pTG,  (*lplpbf)->lpbBegBuf,
                        (*lplpbf)->wLengthBuf, uTimeout, &((*lplpbf)->wLengthData));

        if(!((*lplpbf)->wLengthData))
        {
                MyFreeBuf(pTG, *lplpbf);
                *lplpbf = NULL;
        }
        else
        {
                // If necessary, bit-reverse...

                if (pTG->CurrentMFRSpec.fSWFBOR && pTG->CurrentMFRSpec.iReceiveBOR==1)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "<<WARNING>> SWFBOR Enabled. bit-reversing data\r\n"));
                        cl2_flip_bytes( (*lplpbf)->lpbBegBuf, ((*lplpbf)->wLengthData));
                }
        }

/*
        if(*lplpbf)
                //// faxTlog(("Ex ModemRecvBuf lpbf=%08lx uCount=%d uRet=%d\r\n",
                *lplpbf, (*lplpbf)->wLengthData, uRet));
        else
                //// faxTlog(("Ex ModemRecvBuf lpbf=null uRet=%d\r\n", uRet));
*/
        return uRet;
}





USHORT Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout, USHORT far* lpcbRecv)
{
        SWORD   swEOF;

        BG_CHK(lpb && cbMax && lpcbRecv);

        startTimeOut(pTG, &pTG->toRecv, uTimeout);
        // 4th arg must be TRUE for Class2
        *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &pTG->toRecv, TRUE, &swEOF);

        switch(swEOF)
        {
        case 1: // Class1 eof
        case -1:// Class2 eof
                        return RECV_EOF;
        case 0:
                        return RECV_OK;
        default:
                        BG_CHK(FALSE);
                        // fall through
        case -2:
                        return RECV_ERROR;
        case -3:
                        return RECV_TIMEOUT;
        }
}






BOOL  Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount)
{
        BG_CHK(lpb);

        (MyDebugPrint (pTG, LOG_ALL, "SENDING data....\r\n"));
        if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
        {
                goto error;
        }

        return TRUE;

error:
        (MyDebugPrint (pTG, LOG_ALL, "Failed on AsyncWrite in Class2ModemSendMem\n\r"));
        FComOutFilterClose(pTG);
        FComXon(pTG, FALSE);
        return FALSE;
}




BOOL Class2ModemDrain(PThrdGlbl pTG)
{
        //// faxTlog((pTG, "Entering Class2ModemDrain\r\n"));

        if(!FComDrain(pTG, TRUE, TRUE))
                return FALSE;

        // Must turn XON/XOFF off immediately *after* drain, but before we
        // send the next AT command, since Received frames have 0x13 or
        // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

        if(!Class2iModemDialog(pTG, NULL, 0,
           STARTSENDMODE_TIMEOUT, FALSE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to terminate page with DLE-ETX\n\r"));
                return FALSE;
        }

        // Must change FlowControl State *after* getting OK because in Windows
        // this call takes 500 ms & resets chips, blows away data etc.
        // So do this *only* when you *know* both RX & TX are empty.

        // Turn off flow control.
        FComXon(pTG, FALSE);

        return TRUE;
}






void Class2TwiddleThumbs( ULONG ulTime)
{
        MY_TWIDDLETHUMBS(ulTime);
}






LPSTR Class2_fstrstr(LPSTR sz1, LPSTR sz2)
{
        int i, len1, len2;

        len1 = _fstrlen(sz1);
        len2 = _fstrlen(sz2);

        for(i=0; i<=(len1-len2); i++)
        {
                if(_fmemcmp(sz1+i, sz2, len2) == 0)
                        return sz1+i;
        }
        return NULL;
}




                           
                                                      

UWORD   Class2iModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                  BOOL fMultiLine, UWORD uwRepeatCount, ...)
{
/** Takes a command string, and it's lengt writes it out to the modem
    and tries to get one of the allowed responses. It writes the command
        out, waits ulTimeOut millisecs for a response. If it gets one of the
        expected responses it returns immediately.

        If it gets an unexpected/illegal response it tries (without any
        waiting) for subsequent lines to the same response.     When all the
        lines (if > 1) of the response lines are exhausted, if none is among the
        expected responses, it writes the command again and tries again,
        until ulTimeout has expired. Note that if no response is received,
        the command will be written just once.

        The whole above thing will be repeated upto uwRepeatCount times
        if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

        It returns when (a) one of the specified responses is received or
        (b) uwRepeatCount tries have failed (each having returned an
        illegal response or having returned no response in ulTimeout
        millsecs) or (c) the command write failed, in which
        case it returns immediately.

        It flushes the modem inque before each Command Write.

        Returns 0 on failure and the 1 based index of the successful
        response on     success.

        This can be used in the following way:-

        for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
        value, of the order of the transmission time of the longest
        possible (erroneous or correct) line of response plus the size
        of the command. eg. at 1200baud we have about 120cps = about
        10ms/char. Therefore a timeout of about 500ms is more than
        adequate, except for really long command lines.

        for Local Sync dialogs, used to sync up with the modem which may
        be in an unsure state, use the same timeout, but also a repeat
        count of 2 or 3.

        for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
        after the flags have been received, and which may incur a delay
        before a response (ATDT is teh same. CONNECT is issued after a
        long delay & anything the DTE sends will abort the process).
        For these cases the caller should supply a long timeout and
        probably a repeatcount of 1, so that the
        routine will timeout after one try but go on issuing teh command
        as long as an error repsonse is received.

        For +FRH etc, the long timeout should be T1 or T2 in teh case of
        CommandRecv and ResponseRecv respectively.

**/


        BYTE bReply[REPLYBUFSIZE];
        UWORD   i, j, uwRet, uwWantCount;
        SWORD   swNumRead;
        C2PSTR  rgcbszWant[10];
        va_list args;
        LPTO    lpto, lptoRead, lpto0;
        BOOL    fTimedOut;


        // extract the (variable length) list of acceptable responses.
        // each is a C2SZ, code based 2 byte ptr

        va_start(args, uwRepeatCount);  // Ansi Defintion

        for(j=1; j<10; j++)
        {
                if((rgcbszWant[j] = va_arg(args, C2PSTR)) == NULL)
                        break;
        }
        uwWantCount = j-1;
        va_end(args);

        pTG->lpbResponseBuf2[0] = 0;
        BG_CHK(uwWantCount>0);

#if 0   //// RSL
ST_DIA(
        if(szSend)
        {
                faxT2log(("Dialog: Send (%s\r\n) len=%d WantCount=%d time=%ld rep=%d\r\n", (LPSTR)szSend,
                        uwLen, uwWantCount, ulTimeout, uwRepeatCount));
        }
        else
        {
                faxT2log(("Response: WantCount=%d time=%ld rep=%d\r\n",
                        uwWantCount, ulTimeout, uwRepeatCount));
        }
        for(j=1; j<=uwWantCount; j++)
                faxT2log(pTG, ("Want %s\r\n", (LPSTR)(rgcbszWant[j])));
);
#endif

        lpto = &pTG->toDialog;
        lpto0 = &pTG->toZero;
        // Try the dialog upto uwRepeatCount times
        for(uwRet=0, i=0; i<=uwRepeatCount; i++)
        {
                startTimeOut(pTG, lpto, ulTimeout);
                fTimedOut = FALSE;
                do
                {

                        if(fTimedOut)
                        {
                                // Need to send anychar to abort the previous command.
                                // We could recurse on this function, but the function
                                // uses static (lpto vars etc)!!

                                fTimedOut = FALSE;
                                BG_CHK(swNumRead == 0);
                                // use random 20ms timeout
                                FComDirectSyncWriteFast(pTG, "\r", 1);
                                startTimeOut(pTG, lpto0, 500);
                                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
                                (MyDebugPrint (pTG, LOG_ALL, "AnykeyAbort got<<%s>>\r\n", (LPSTR)bReply));
                        }

                        if(szSend)
                        {
                                // If a command is supplied, write it out, flushing input
                                // first to get rid of spurious input.

                                // FComInputFlush();
                                FComFlush(pTG, );            // Need to flush output too?

                                // Need to check that we are sending only ASCII or pre-stuffed data here
                                (MyDebugPrint (pTG, LOG_ALL, "WRITING THE FOLLOWING COMMAND: %s\r\n",(LPSTR)szSend));
                                if(!FComDirectSyncWriteFast(pTG,  szSend, uwLen))
                                {
                                        (MyDebugPrint (pTG, LOG_ALL, "Modem Dialog Write timed Out\r\n"));
                                        uwRet = 0;
                                        goto done;
                                        // If Write fails, fail & return immediately.
                                        // SetMyError() will already have been called.
                                }
                        }

                        // Try to get a response until timeout or bad response

                        pTG->bLastReply2[0] = 0;
                        for(lptoRead=lpto;;startTimeOut(pTG, lpto0, ulTimeout), lptoRead=lpto0)
                        {

                                // First, check for abort. If we are aborting,
                                // return failure from here. That will cause
                                // many commands to stop.

                                if (pTG->fAbort)
                                {
                                        (MyDebugPrint (pTG, LOG_ALL, "ABORTING...\n\r"));
                                        pTG->fAbort = FALSE;
                                        uwRet = 0;
                                        goto end;
                                }

                                // get a CR-LF terminated line
                                // for the first line use macro timeout, for multi-line
                                // responses use 0 timeout.

                                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);
                                if(swNumRead < 0)
                                        swNumRead = (-swNumRead);       // error-but lets see what we got anyway
                                else if(swNumRead == 0)
                                        break;                                          // Timeout -- restart dialog or exit
                                if(swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                                        continue;                                       // blank line -- throw away & get another

                                // COPIED THIS FROM DUP FUNCTION IN MODEM.C!!
                                // Fix Bug#1226. Elsa Microlink returns this garbage line in
                                // response to AT+FDIS?, followed by the real reply. Since
                                // we only look at the first line, we see only this garbage line
                                // and we never see the real reply
                                if(swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                                        continue;

                                for(bReply[REPLYBUFSIZE-1]=0, j=1; j<=uwWantCount; j++)
                                {
                                        if(Class2_fstrstr(bReply, rgcbszWant[j]) != NULL)
                                        {
                                                uwRet = j;
                                                // It matched!!!
                                                // Save this reply. This is used when checking
                                                // ATS1 responses
                                                _fmemcpy(pTG->bFoundReply, bReply, REPLYBUFSIZE);
                                                goto end;
                                        }
                                }
                                if(!fMultiLine)
                                        continue;
                                // go to ulTimeout check. i.e. *don't* set fTimedOut
                                // but don't exit either. Retry command and response until
                                // timeout


                                // We reach here it IFF we got a non blank reply, but it wasn't what
                                // we wanted. Squirrel teh first line away somewhere so that we can
                                // retrieve is later. We use this hack to get multi-line informational
                                // responses to things like +FTH=? Very important to ensure that
                                // blank-line replies don't get recorded here. (They may override
                                // the preceding line that we need!).

                                // Use the far pointer version
                                _fmemcpy(pTG->bLastReply2, bReply, REPLYBUFSIZE);
                                // In pTG->lpbResponseBuf2, all received lines are
                                // saved, not just the last one. This is used
                                // for multiline responses, like the response
                                // to a Class 2 ATD command
                                // pTG->lpbResponseBuf2[0] was initialized at the
                                // start of this routine.
                                // Ignore lines past the buffer size...
                                // no valid response would be that long anyway
                                if ( (_fstrlen((LPB)pTG->lpbResponseBuf2)+
                                   _fstrlen((LPB)bReply) ) < RESPONSE_BUF_SIZE)
                                                _fstrcat((LPB)pTG->lpbResponseBuf2, (LPB)bReply);
                                else
                                {
                                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> ModemDialog:Response too long!\n\r"));
                                        uwRet = 0;
                                        goto end;
                                }
                        }
                        // we come here only on timeout.
                        fTimedOut = TRUE;
                }
                while(checkTimeOut(pTG, lpto));
        }

end:
        if(uwRet == 0)
        {
                (MyDebugPrint (pTG, LOG_ALL, "ModemDialog: (%s\r\n) --> (%d)(%s, etc) Failed\r\n", 
                        (LPSTR)(szSend?szSend:"null"), uwWantCount,
                        (LPSTR)rgcbszWant[1]));
        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "ModemDialog: GOT IT %d (%s)\r\n", uwRet, (LPSTR)(rgcbszWant[uwRet])));
        }

done:
        (MyDebugPrint (pTG, LOG_ALL, "returning from ModemDialog....\n\r"));
        return uwRet;
}


/* Converts the code for a speed to the speed in BPS */
// These are in the same order as the return values
// for DIS/DCS frames defined in the Class 2 spec in
// Table 8.4


/* Converts a DCS min-scan field code into millisecs */
// One array is for normal (100 dpi) res, the other for high (200 dpi) res...
// The ordering of the arraies is based on the values that
// are defined in filet30.h - THEY ARE NOT THE SAME AS THE VALUES
// RETURNED IN THE DCS FRAME!!!! This is inconsistent with baud rate
// but it is consistent with the Class 1 code...
BYTE msPerLineNormalRes[8] = { 20, 5, 10, 20, 40, 40, 10, 0 };
BYTE msPerLineHighRes[8] =   { 20, 5, 10, 10, 40, 20, 5, 0 };





USHORT Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution)
{
        USHORT uStuff;
        BYTE ms;

        uStuff = Class2CodeToBPS[Baud];
        BG_CHK(uStuff);
        if ( Resolution & AWRES_mm080_077)
                ms = msPerLineHighRes[Minscan];
        else ms = msPerLineNormalRes[Minscan];
        uStuff /= 100;          // StuffBytes = (BPS * ms)/8000
        uStuff *= ms;           // take care not to use longs
        uStuff /= 80;           // or overflow WORD or lose precision
        uStuff += 1;            // Rough fix for truncation problems

        (MyDebugPrint (pTG, LOG_ALL, "Stuffing %d bytes\n\r", uStuff));
        return uStuff;
}

// Convert the SEND_CAPS or SEND_PARAMS BC structure into values used by
// the +FDCC, +FDIS, and +FDT commands

                            
                                                        
                                                                                    
void Class2SetDIS_DCSParams(PThrdGlbl pTG, BCTYPE bctype, LPUWORD Encoding, LPUWORD Resolution,
        LPUWORD PageWidth, LPUWORD PageLength, LPSTR szID)
{
        LPBC lpbc;

        (MyDebugPrint (pTG, LOG_ALL, "Class2SetDIS_DCSParamas: entering. Type = %d\n\r", (USHORT)bctype));

        if (bctype == SEND_PARAMS)
                lpbc = (LPBC)&pTG->bcSendParams;
        else
                lpbc = (LPBC)&pTG->bcSendCaps;

        // Set the ID
        szID[0] = '\0';

        BG_CHK(lpbc->wTotalSize >= sizeof(BC));
        BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendCaps));
        BG_CHK(sizeof(pTG->bcSendCaps) == sizeof(pTG->bcSendParams));

        // GetNumId(lpbc, szID, 21); else
        //GetTextId(lpbc, szID, 21); // 20 + 1 for 0-term

        if (pTG->LocalID) {
           strcpy (szID, pTG->LocalID);
        }

        switch(lpbc->Fax.Encoding)
        {
                case MH_DATA:
                        *Encoding = 0;
                        break;
                case MR_DATA:
                case (MR_DATA | MH_DATA):
                        *Encoding = 1;
                        break;
                case MMR_DATA:
                case (MMR_DATA | MH_DATA):
                case (MMR_DATA | MR_DATA):
                case (MMR_DATA | MR_DATA | MH_DATA):
                        *Encoding = 3;
                        break;
                default:
                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Bad Encoding type %x\n\r",lpbc->Fax.Encoding));
                        break;
        }

        if( (lpbc->Fax.AwRes) & AWRES_mm080_077) *Resolution = 1;
        else if( (lpbc->Fax.AwRes) & AWRES_mm080_038) *Resolution = 0;
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Bad Resolution type %x\n\r", lpbc->Fax.AwRes));
        }

        switch(lpbc->Fax.PageWidth & 0x3)
        {
                case WIDTH_A4:  // 1728 pixels
                        *PageWidth = 0;
                        break;
                case WIDTH_B4:  // 2048 pixels
                        *PageWidth = 1;
                        break;
                case WIDTH_A3:  // 2432 pixels
                        *PageWidth = 2;
                        break;
                default:
                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Bad PageWidth type %x\n\r", lpbc->Fax.PageWidth));
                   break;
        }

        switch(lpbc->Fax.PageLength)
        {
                case LENGTH_A4:
                        *PageLength = 0;
                        break;
                case LENGTH_B4:
                        *PageLength = 1;
                        break;
                case LENGTH_UNLIMITED:
                        *PageLength = 2;
                        break;
                default:
                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Bad PageLength type %x\n\r", lpbc->Fax.PageLength));
                   break;
        }

}




BOOL Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb)
{

        USHORT           count, i;
        BOOL                    fFoundDIS_DCS;

        fFoundDIS_DCS = FALSE;

        (MyDebugPrint (pTG, LOG_ALL, "Class2ResponseAction: entering\n\r"));
        _fmemset(lpPcb, 0, sizeof(PCB));

        if (pTG->ModemClass == MODEM_CLASS2) {
            Class2Parse( pTG, &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }
        else {
           Class20Parse( pTG, &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }

        (MyDebugPrint (pTG, LOG_ALL, "Number of commands is %d\n\r",pTG->class2_commands.comm_count));
        for(count=0; count < pTG->class2_commands.comm_count; ++count)
        {
        // (MyDebugPrint (pTG, LOG_ALL, "Loading PCB for command %d\n\r",
        // pTG->class2_commands.command[count]));
        switch (pTG->class2_commands.command[count])
            {
                case  CL2DCE_FDIS:
                case  CL2DCE_FDCS:

                        (MyDebugPrint (pTG, LOG_ALL, "Found DCS or DIS \n\r"));
                        fFoundDIS_DCS = TRUE;
                        //  Assign resolution.
                        if( pTG->class2_commands.parameters[count][0] == 0)
                                lpPcb->Resolution = AWRES_mm080_038;
                        else if (pTG->class2_commands.parameters[count][0] == 1 )
                        {
                        // Resolution when reported by a DIS frame indicates
                        // it accepts either fine or normal. When reported
                        // in a DCS, it means the negotiated value is FINE.
                                if (pTG->class2_commands.command[count] ==
                                        CL2DCE_FDIS)
                                   lpPcb->Resolution = AWRES_mm080_038 | AWRES_mm080_077;
                                else
                                   lpPcb->Resolution = AWRES_mm080_077;
                        }
                        else
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "FAILED TO ASSIGN RESOLUTION.\r\n"));
                                return FALSE;
                        }

                        //  Assign encoding scheme.
                        if( pTG->class2_commands.parameters[count][4] == 0)
                        {
                                lpPcb->Encoding = MH_DATA;
                        }
                        else if ((pTG->class2_commands.parameters[count][4] == 1) ||
                                 (pTG->class2_commands.parameters[count][4] == 2) ||
                                 (pTG->class2_commands.parameters[count][4] == 3) )
                        {
                                lpPcb->Encoding = MH_DATA | MR_DATA;
                        }
                        else
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "FAILED TO ASSIGN ENCODING.\r\n"));
                                return FALSE;
                        }

                        //  Assign page width.
                        if( pTG->class2_commands.parameters[count][2] == 0)
                                lpPcb->PageWidth = WIDTH_A4;
                        else if (pTG->class2_commands.parameters[count][2] == 1)
                                lpPcb->PageWidth = WIDTH_B4;
                        else if (pTG->class2_commands.parameters[count][2] == 2)
                                lpPcb->PageWidth = WIDTH_A3;
                        // We don't support 3 and 4 (A5, A6)
                        // but we'll still allow them and map them to A4
                        // This is for Elliot bug #1252 - it should have
                        // no deleterious effect, since this width field
                        // is not used for anything at the point in where
                        // bug 1252 occurs. FrankFi
                        else if (pTG->class2_commands.parameters[count][2] == 3)
                                lpPcb->PageWidth = WIDTH_A4;
                        else if (pTG->class2_commands.parameters[count][2] == 4)
                                lpPcb->PageWidth = WIDTH_A4;
                        else
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "FAILED TO ASSIGN WIDTH.\r\n"));
                                return FALSE;
                        }

                        //  Assign page length.
                        if( pTG->class2_commands.parameters[count][3] == 0)
                                lpPcb->PageLength = LENGTH_A4;
                        else if (pTG->class2_commands.parameters[count][3] == 1)
                                lpPcb->PageLength = LENGTH_B4;
                        else if (pTG->class2_commands.parameters[count][3] == 2)
                                lpPcb->PageLength = LENGTH_UNLIMITED;
                        else
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "INVALID LENGTH.\r\n"));
                                // assume it is unlimited! Some modems
                                // mess up on length.
                                lpPcb->PageLength = LENGTH_UNLIMITED;
                        }

                        //  Assign baud rate
                        //  For now, we will use the raw numbers returned in the
                        //  DCS command. Dangerous - should fix later!
                        //  These numbers will be tied to the baud rate array in
                        //  the routine that figures out zero byte stuffing from
                        //  the scan line and baud rate.

                        // Fixed the Hack--added a Baud field
                        lpPcb->Baud = pTG->class2_commands.parameters[count][1];


                        //  Assign minimum scan time - the first number
                        //  in the MINSCAN_num_num_num constant
                        //  refers to scan time in ms for 100dpi, the
                        //  second for 200dpi, and the last for 400dpi
                        //  Class 2 does not use the 400dpi number,
                        //  but these variables are shared with Class 1
                        if( pTG->class2_commands.parameters[count][7] == 0)
                                lpPcb->MinScan = MINSCAN_0_0_0;
                        else if (pTG->class2_commands.parameters[count][7] == 1)
                                lpPcb->MinScan = MINSCAN_5_5_5;
                        else if (pTG->class2_commands.parameters[count][7] == 2)
                                lpPcb->MinScan = MINSCAN_10_5_5;
                        else if (pTG->class2_commands.parameters[count][7] == 3)
                                lpPcb->MinScan = MINSCAN_10_10_10;
                        else if (pTG->class2_commands.parameters[count][7] == 4)
                                lpPcb->MinScan = MINSCAN_20_10_10;
                        else if (pTG->class2_commands.parameters[count][7] == 5)
                                lpPcb->MinScan = MINSCAN_20_20_20;
                        else if (pTG->class2_commands.parameters[count][7] == 6)
                                lpPcb->MinScan = MINSCAN_40_20_20;
                        else if (pTG->class2_commands.parameters[count][7] == 7)
                                lpPcb->MinScan = MINSCAN_40_40_40;
                        break;

                case  CL2DCE_FCSI:
                case  CL2DCE_FTSI:
                        for( i = 0; (lpPcb->szID[i] =
                         pTG->class2_commands.parameters[count][i]) != '\0'; ++i)
                                        ;

                        // prepare CSID for logging by FaxSvc

                        pTG->RemoteID = AnsiStringToUnicodeString(lpPcb->szID);
                        if (pTG->RemoteID) {
                            pTG->fRemoteIdAvail = 1;
                        }
                        break;
                default:
                        // (MyDebugPrint (pTG, LOG_ALL, "Class2ResponseAction: Unknown token.\r\n"));
                        break;
            }
        }


        return fFoundDIS_DCS;
}







USHORT Class2EndPageResponseAction(PThrdGlbl pTG)
{

        USHORT            csi_count = 0,
                        count;


        if (pTG->ModemClass == MODEM_CLASS2) {
            Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }
        else {
           Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
        }

        for(count=0; count < pTG->class2_commands.comm_count; ++count)
        {
        if (pTG->class2_commands.command[count] == CL2DCE_FET )
                {
                        if (pTG->class2_commands.parameters[count][0] == 0)
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "More pages coming\n\r"));
                                return MORE_PAGES;
                        }
                        else
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "No more pages coming\n\r"));
                                return NO_MORE_PAGES;
                        }
                }
        }
        return FALSE;

}





void Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype)
{
        _fmemset(lpbc, 0, uSize);
        lpbc->bctype = bctype;
        lpbc->wBCVer = VER_AWFXPROT100;
        lpbc->wBCSize = sizeof(BC);
        lpbc->wTotalSize = sizeof(BC);

/********* This is incorrect ****************************
        lpbc->Std.GroupNum              = GROUPNUM_STD;
        lpbc->Std.GroupLength   = sizeof(BCSTD);
        // set Protocol Ver etc (everything else) to 00
        // set all IDs to 0 also. Fax stuff set later
********* This is incorrect ****************************/

/**
        lpbc->Fax.AwRes = (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300);
        lpbc->Fax.Encoding   = MH_DATA;    // ENCODE_ALL eventually!
        lpbc->Fax.PageWidth  = WIDTH_A4;
        lpbc->Fax.PageLength = LENGTH_UNLIMITED;
        lpbc->Fax.MinScan    = MINSCAN_0_0_0;
**/

}





void Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb)
{
        USHORT uLen;

        lpbc->Fax.AwRes = lppcb->Resolution;
        lpbc->Fax.Encoding   = lppcb->Encoding;
        lpbc->Fax.PageWidth  = lppcb->PageWidth;
        lpbc->Fax.PageLength = lppcb->PageLength;
        // lpbc->Fax.MinScan = lppcb->MinScan;

        BG_CHK(lpbc->wTotalSize >= sizeof(BC));
        BG_CHK(lpbc->wTotalSize < uMaxSize);

        if(uLen = (USHORT)_fstrlen(lppcb->szID))
        {
                PutTextId( lpbc, uMaxSize, lppcb->szID, uLen, TEXTCODE_ASCII);
                // PutNumId(lpbc, szID, uLen);
        }
}




BOOL Class2GetBC(PThrdGlbl pTG, BCTYPE bctype)
{
        USHORT  uLen;
        LPBC    lpbc;

        if(bctype == BC_NONE)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2GetBC: entering, type = BC_NONE\n\r", bctype));
                Class2InitBC(pTG, (LPBC)&pTG->bcSendCaps, sizeof(pTG->bcSendCaps), SEND_CAPS);
                pTG->bcSendCaps.Fax.AwRes      = (AWRES_mm080_038 | AWRES_mm080_077);
                pTG->bcSendCaps.Fax.Encoding   = MH_DATA;
                pTG->bcSendCaps.Fax.PageWidth  = WIDTH_A4;
                pTG->bcSendCaps.Fax.PageLength = LENGTH_UNLIMITED;
                return TRUE;
        }

        if(!(lpbc = ICommGetBC(pTG, bctype, TRUE)))
        {
                BG_CHK(FALSE);
                return FALSE;
        }

        (MyDebugPrint (pTG, LOG_ALL, "Class2GetBC: entering, type = %d\n\r", bctype));
        (MyDebugPrint (pTG, LOG_ALL, "Some params: encoding = %d, res = %d\n\r", lpbc->Fax.Encoding, lpbc->Fax.AwRes));

        // Depending on the type, pick the correct global BC structure

        BG_CHK(lpbc->wTotalSize >= sizeof(BC));

        if (bctype == SEND_CAPS)
        {
                BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendCaps));
                uLen = min(sizeof(pTG->bcSendCaps), lpbc->wTotalSize);
                _fmemcpy(&pTG->bcSendCaps, lpbc, uLen);
                return TRUE;
        }
        else if (bctype == SEND_PARAMS)
        {
                BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendParams));
                uLen = min(sizeof(pTG->bcSendParams), lpbc->wTotalSize);
                _fmemcpy(&pTG->bcSendParams, lpbc, uLen);
                return TRUE;
        }
        else
                return FALSE;
}




BOOL  Class2NCUSet(PThrdGlbl pTG, LPNCUPARAMS NCUParams2)
{
        BG_CHK(NCUParams2);

        (MyDebugPrint (pTG, LOG_ALL, "In Class2NCUSet\r\n"));

        // Copy params into our local pTG->NCUParams2 struct
        pTG->NCUParams2 = *NCUParams2;

        return TRUE;
}




BOOL Class2SetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp)
{
        pTG->ProtParams2 = *lp;

        (MyDebugPrint (pTG, LOG_ALL, "Set Class2ProtParams: fV17Send=%d fV17Recv=%d uMinScan=%d\r\n", 
                        "HighestSend=%d LowestSend=%d\r\n",
                        pTG->ProtParams2.fEnableV17Send, pTG->ProtParams2.fEnableV17Recv,
                        pTG->ProtParams2.uMinScan, pTG->ProtParams2.HighestSendSpeed,
                        pTG->ProtParams2.LowestSendSpeed));

        return TRUE;
}




void iNCUParamsReset(PThrdGlbl pTG)
{
        _fmemset(&pTG->NCUParams2, 0, sizeof(pTG->NCUParams2));
        pTG->lpCmdTab = 0;

        pTG->NCUParams2.uSize = sizeof(pTG->NCUParams2);
        // These are used to set S regs etc.
        // -1 means leave modem at default
        pTG->NCUParams2.DialtoneTimeout = -1;
        pTG->NCUParams2.DialPauseTime   = pTG->NCUParams2.FlashTime         = -1;
        // pTG->NCUParams2.PulseMakeBreak  = pTG->NCUParams2.DialBlind         = -1;
        pTG->NCUParams2.DialBlind         = -1;
        pTG->NCUParams2.SpeakerVolume   = pTG->NCUParams2.SpeakerControl    = -1;
        pTG->NCUParams2.SpeakerRing     = -1;

        // should be used in answer
        pTG->NCUParams2.RingsBeforeAnswer = 0;
        // should be used in Dial
        pTG->NCUParams2.AnswerTimeout = 60;
        // used in Dial
        pTG->NCUParams2.chDialModifier  = 'T';
}








BYTE rgbFlip256[256]  = {
        0x0,    0x80,   0x40,   0xc0,   0x20,   0xa0,   0x60,   0xe0,
        0x10,   0x90,   0x50,   0xd0,   0x30,   0xb0,   0x70,   0xf0,
        0x8,    0x88,   0x48,   0xc8,   0x28,   0xa8,   0x68,   0xe8,
        0x18,   0x98,   0x58,   0xd8,   0x38,   0xb8,   0x78,   0xf8,
        0x4,    0x84,   0x44,   0xc4,   0x24,   0xa4,   0x64,   0xe4,
        0x14,   0x94,   0x54,   0xd4,   0x34,   0xb4,   0x74,   0xf4,
        0xc,    0x8c,   0x4c,   0xcc,   0x2c,   0xac,   0x6c,   0xec,
        0x1c,   0x9c,   0x5c,   0xdc,   0x3c,   0xbc,   0x7c,   0xfc,
        0x2,    0x82,   0x42,   0xc2,   0x22,   0xa2,   0x62,   0xe2,
        0x12,   0x92,   0x52,   0xd2,   0x32,   0xb2,   0x72,   0xf2,
        0xa,    0x8a,   0x4a,   0xca,   0x2a,   0xaa,   0x6a,   0xea,
        0x1a,   0x9a,   0x5a,   0xda,   0x3a,   0xba,   0x7a,   0xfa,
        0x6,    0x86,   0x46,   0xc6,   0x26,   0xa6,   0x66,   0xe6,
        0x16,   0x96,   0x56,   0xd6,   0x36,   0xb6,   0x76,   0xf6,
        0xe,    0x8e,   0x4e,   0xce,   0x2e,   0xae,   0x6e,   0xee,
        0x1e,   0x9e,   0x5e,   0xde,   0x3e,   0xbe,   0x7e,   0xfe,
        0x1,    0x81,   0x41,   0xc1,   0x21,   0xa1,   0x61,   0xe1,
        0x11,   0x91,   0x51,   0xd1,   0x31,   0xb1,   0x71,   0xf1,
        0x9,    0x89,   0x49,   0xc9,   0x29,   0xa9,   0x69,   0xe9,
        0x19,   0x99,   0x59,   0xd9,   0x39,   0xb9,   0x79,   0xf9,
        0x5,    0x85,   0x45,   0xc5,   0x25,   0xa5,   0x65,   0xe5,
        0x15,   0x95,   0x55,   0xd5,   0x35,   0xb5,   0x75,   0xf5,
        0xd,    0x8d,   0x4d,   0xcd,   0x2d,   0xad,   0x6d,   0xed,
        0x1d,   0x9d,   0x5d,   0xdd,   0x3d,   0xbd,   0x7d,   0xfd,
        0x3,    0x83,   0x43,   0xc3,   0x23,   0xa3,   0x63,   0xe3,
        0x13,   0x93,   0x53,   0xd3,   0x33,   0xb3,   0x73,   0xf3,
        0xb,    0x8b,   0x4b,   0xcb,   0x2b,   0xab,   0x6b,   0xeb,
        0x1b,   0x9b,   0x5b,   0xdb,   0x3b,   0xbb,   0x7b,   0xfb,
        0x7,    0x87,   0x47,   0xc7,   0x27,   0xa7,   0x67,   0xe7,
        0x17,   0x97,   0x57,   0xd7,   0x37,   0xb7,   0x77,   0xf7,
        0xf,    0x8f,   0x4f,   0xcf,   0x2f,   0xaf,   0x6f,   0xef,
        0x1f,   0x9f,   0x5f,   0xdf,   0x3f,   0xbf,   0x7f,   0xff
};

#define FLIP(index) (lpb[(index)] = rgbFlip256[lpb[(index)]])

void    cl2_flip_bytes(LPB lpb, DWORD dw)
{
        while (dw>8)
        {
                FLIP(0); FLIP(1); FLIP(2); FLIP(3);
                FLIP(4); FLIP(5); FLIP(6); FLIP(7);
                dw-=8;
                lpb+=8;
        }

        while(dw)
        {
                FLIP(0);
                dw--;
                lpb++;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\cl2and20\class20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Class2.0 specific functions for fax-modem T.30 driver

Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    
       
Revision History:

--*/



               
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];
          
BYTE   bClass20DLE_nextpage[3] = { DLE, 0x2c, 0 };
BYTE   bClass20DLE_enddoc[3] =   { DLE, 0x2e, 0 };
BYTE   bMRClass20RTC[10] =  { 0x01, 0x30, 0x00, 0x06, 0xc0, 0x00, 0x18, 0x00, 0x03, 0x00};
BYTE   bMHClass20RTC[9] =   { 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00, 0x08, 0x00};



void
Class20Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;


   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszINITIAL_FDT,  "AT+FDT=%%1d,%%1d,%%1d,%%1d\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFNR,          "AT+FNR=1,1,1,1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0,0\r" );
   sprintf( pTG->cbszFLO,          "AT+FLO=1\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBO=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FCC=1,%%d,,,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FDCC=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=1,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FIS" );
   sprintf( pTG->cbszFDIS,          "AT+FIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszZERO,          "0" );
   sprintf( pTG->cbszONE,           "1" );
   sprintf( pTG->cbszQUERY_S1,      "ATS1?\r" );
   sprintf( pTG->cbszRING,          "RING" );
   
   
   sprintf( pTG->cbszCLASS2_ATI,        "ATI\r" );
   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMI?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMM?\r" );
   sprintf( pTG->cbszCLASS2_FREV,       "AT+FMR?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFDT_CNTL_Q,        "" );
   sprintf( pTG->cbszFCON,              "+FCO" );
   sprintf( pTG->cbszGO_CLASS2,         "AT+FCLASS=2.0\r" );
   sprintf( pTG->cbszFLID,              "AT+FLI=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_QUERY_CLASS,"AT+FCLASS=?\r" );
   sprintf( pTG->cbszCLASS2_GO_CLASS0,  "AT+FCLASS=0\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszCLASS2_RESET,      "AT&F\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIALTONE");

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );      
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );    
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FKS\r" );     
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );  
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIALTONE" ); 
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );        
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );   
   sprintf( pTG->cbszCLASS2_OK,         "OK" );          
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHNG" );    
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );
   sprintf( pTG->cbszCLASS2_ATE0,       "ATE0\r" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}




BOOL
T30Cl20Tx(
   PThrdGlbl  pTG,
   LPSTR      szPhone
)

//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
//
{
        LPSTR   lpszSection = pTG->FComModem.rgchKey;
        USHORT  uRet1, uRet2;
        
        BYTE    bBuf[200],
                bTempBuf[200+RESPONSE_BUF_SIZE];
        
        LPBYTE  lpbyte;

        UWORD   Encoding, Res, PageWidth, PageLength, uwLen, uwRet;
        BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
        CHAR    szTSI[max(MAXTOTALIDLEN,20)+4];
        BOOL    fBaudChanged;
        BOOL    RetCode;


        uRet2 = 0;
        if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
        {

                (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Class20Caller: iModemGetCmdTabPtr failed.\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // first get SEND_CAPS if possible. If using PSI (IFAX/Winpad) then we
        // can't make callback this on the Sender. Only on Receiver! Otherwise
        // we deadlock & hang in PSI

#ifdef PSI
    if(!Class2GetBC(pTG, BC_NONE)) // Set it to some defaults!
#else
    if(!Class2GetBC(pTG, SEND_CAPS)) // get send caps
#endif
        {
            uRet1 = T30_CALLFAIL;
        
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;

            goto done;
        }

        // Go to Class2.0
        if(!iModemGoClass(pTG, 3))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class20Caller: Failed to Go to Class 2.0 \n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // Begin by checking for manufacturer and ATI code.
        // Look this up against the modem specific table we
        // have and set up the send strings needed for
        // this modem.
        if(!Class20GetModemMaker(pTG ))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Call to GetModemMaker failed\n\r"));
                // Ignore failure!!!
        }


        // Get the capabilities of the software. I am only using this
        // right now for the TSI field (below where I send +FLID).
        // Really, this should also be used instead of the hardcoded DIS
        // values below.
        // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
        // A "RING" COULD APPEAR AT ANY TIME!

        _fmemset((LPB)szTSI, 0, strlen(szTSI));
        Class2SetDIS_DCSParams(pTG, SEND_CAPS, (LPUWORD)&Encoding, (LPUWORD)&Res,
                (LPUWORD)&PageWidth, (LPUWORD)&PageLength, (LPSTR) szTSI);

        bIDBuf[0] = '\0';
        uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);
        
        if(!Class2iModemDialog(pTG, bIDBuf, uwLen,
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Local ID failed\n\r"));
                // ignore failure
        }

        // // Turn off ECM - don't do for sierra type modems!
        // if (!pTG->CurrentMFRSpec.bIsSierra)
        //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
        //              LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
        //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        //      {
        //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
        //              // Ignore ECM failure!!!
        //      }


        if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS, (UWORD) (strlen(pTG->cbszFDIS_IS) ),
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
          {
                (MyDebugPrint (pTG, LOG_ALL, "FDIS failed\n\r"));
                // ignore
          }

        // See if the reply was ERROR or timeout, if so try a different command
        // Exar modems, for example, don't take AT+FDIS?
        if ( uwRet == 2) 
        {
             if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS,
                     (UWORD) (strlen(pTG->cbszFDIS_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                     pTG->cbszCLASS2_OK, (C2PSTR) NULL)))
             {
                     // No FDIS, FDCC worked - quit!
                     (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> No FDIS? or FDCC? worked\n\r"));
                     uRet1 = T30_CALLFAIL;

                     pTG->fFatalErrorWasSignaled = 1;
                     SignalStatusChange(pTG, FS_FATAL_ERROR);
                     RetCode = FALSE;

                     goto done;
             }

                // If the first character in the reply before a number
                // is a ',', insert a '1' for normal & fine res (Exar hack)
                for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
                {
                        if (*lpbyte == ',')
                        {
                                // found a leading comma
                                bTempBuf[0] = '\0';
                                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,
                                                lpbyte);
                                _fstrcpy(lpbyte, bTempBuf);
                                (MyDebugPrint (pTG, LOG_ALL, "Leading comma in DCC string =\n\r", (LPSTR)&pTG->lpbResponseBuf2));
                        }

                        if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) break;
                }

        }



        // If the repsonse was just a number string without "+FDIS" in front
        // of it, add the +FDIS. Some modem reply with it, some do not. The
        // general parsing algorithm used below in Class2ResponseAction needs
        // to know the command that the numbers refer to.
        if ( pTG->lpbResponseBuf2[0] != '\0' &&
           (Class2_fstrstr((LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
        {
                // did not get the FDIS in the response!
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
                wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,
                                (LPSTR)pTG->lpbResponseBuf2);
                _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
        }

        (MyDebugPrint (pTG, LOG_ALL, "\n\rReceived %s from FDIS\r\n", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Process default DIS to see if we have to send a DCC to change
        // it. Some modems react badly to just sending a DCC with ",,,"
        // so we can't rely on the modem keeping DIS parameters unchanged
        // after a DCC like that. We'll use the FDISResponse routine to load
        // the default DIS values into a PCB structure
        if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDIS Response\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        (MyDebugPrint (pTG, LOG_ALL, "pTG->DISPcb baud value is %d\n\r", pTG->DISPcb.Baud));

        fBaudChanged = FALSE;
        // See if we have to change the baud rate to a lower value.
        // This only happens if the user set an ini string constraining
        // the high end speed or if the user turned off V.17 for sending
        // Check the V.17 inhibit and lower baud if necessary
        if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Send) )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Lowering baud from %d for V.17 inihibit\n\r", CodeToBPS[pTG->DISPcb.Baud]));

                pTG->DISPcb.Baud = 3; //9600 won't use V.17
                fBaudChanged = TRUE;
        }

// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }


        // Now see if the high end baud rate has been constrained
        if  ( (pTG->ProtParams2.HighestSendSpeed != 0) &&
                (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Have to lower baud from %d to %d\n\r", CodeToBPS[pTG->DISPcb.Baud], pTG->ProtParams2.HighestSendSpeed));

                fBaudChanged = TRUE;
                switch (pTG->ProtParams2.HighestSendSpeed)
                {
                        case 2400:
                                pTG->DISPcb.Baud = 0;
                                break;
                        case 4800:
                                pTG->DISPcb.Baud = 1;
                                break;
                        case 7200:
                                pTG->DISPcb.Baud = 2;
                                break;
                        case 9600:
                                pTG->DISPcb.Baud = 3;
                                break;
                        case 12000:
                                pTG->DISPcb.Baud = 4;
                                break;
                        default:
                                (MyDebugPrint (pTG, LOG_ALL, "Bad HighestSpeed\n\r"));
                                
                                uRet1 = T30_CALLFAIL;
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_FATAL_ERROR);
                                RetCode = FALSE;
                                goto done;

                                break;
                }
        }


        uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
        if(!Class2iModemDialog(pTG, bBuf, uwLen,
                      LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                      (C2PSTR) NULL))
        {
              uRet1 = T30_CALLFAIL;

              pTG->fFatalErrorWasSignaled = 1;
              SignalStatusChange(pTG, FS_FATAL_ERROR);
              RetCode = FALSE;

              goto done;
        }


        // Do BOR based on the value from the modem table set in
        // Class2SetMFRSpecific
        uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
        if(!Class2iModemDialog(pTG, bBuf, uwLen, LOCALCOMMAND_TIMEOUT, TRUE,
                        0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FBOR failed\n\r"));
                // Ignore BOR failure!!!
        }

        if(!Class2iModemDialog(pTG, pTG->cbszFNR, (UWORD) (strlen(pTG->cbszFNR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                           pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ERR, "FNR failed\n\r"));
                // ignore error
        }


        // Dial the number

                // have to call hangup on every path out of here
                // after Dial is called. If Dial fails, it calls Hangup
                // if it succeeds we have to call Hangup when we're done


        SignalStatusChange(pTG, FS_DIALING);

        if((uRet2 = Class2Dial(pTG, szPhone)) != CONNECT_OK)
        {
                uRet1 = T30_DIALFAIL;

                if (! pTG->fFatalErrorWasSignaled) {
                     pTG->fFatalErrorWasSignaled = 1;
                     SignalStatusChange(pTG, FS_FATAL_ERROR);
                }

                RetCode = FALSE;

                goto done;
        }

        ICommGotAnswer(pTG );
        // we should be using the sender msg here but that says Training
        // at speed=xxxx etc which we don't know, so we just use the
        // Recvr message which just says "negotiating"
        ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

        // Send the data
        uRet1 = (USHORT)Class20Send(pTG );
        if ( uRet1 == T30_CALLDONE)
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, ALL OK\r\n"));
                ICommStatus(pTG, T30STATS_SUCCESS, 0, 0, 0);

                // have to call hangup on every path out of here
                // we have to call Hangup here
                Class2ModemHangup(pTG );

                SignalStatusChange(pTG, FS_COMPLETED);
                RetCode = TRUE;

        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, **** FAILED *****\r\n"));
                ICommStatus(pTG, T30STATS_FAIL, 0, 0, 0);

                // Make sure Modem is in OK state
                FComOutFilterClose(pTG );
                FComXon(pTG, FALSE);
                // have to call hangup on every path out of here
                // Class2ModemABort calls Hangup
                Class2ModemAbort(pTG );

                if (! pTG->fFatalErrorWasSignaled)  {
                   pTG->fFatalErrorWasSignaled = 1;
                   SignalStatusChange(pTG, FS_FATAL_ERROR);
                }

                RetCode = FALSE;

        }
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;

done:
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);
        
        return RetCode;
}




BOOL Class20Send(PThrdGlbl pTG)
{
        LPBUFFER        lpbf;
        SWORD           swRet;
        ULONG           lTotalLen=0;
        PCB             Pcb;
        USHORT          uTimeout=30000, PagesSent;
        BOOL            err_status, fAllPagesOK = TRUE;
        BCwithTEXT      bc;

        UWORD           Encoding, Res, PageWidth, PageLength, uwLen;
        BYTE            bFDISBuf[200];
        CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
        BYTE            bNull = 0;
        DWORD           TiffConvertThreadId;

        // FComCriticalNeg(TRUE);

        /*
        * We have just dialed... Now we have to look for the FDIS response from
        * the modem. It will be followed by an OK - hunt for the OK.
        */

        if(!Class2iModemDialog(pTG, NULL, 0, STARTSENDMODE_TIMEOUT, TRUE, 0,
                        pTG->cbszCLASS2_OK, (C2PSTR) NULL))
        {
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // The response will be in pTG->lpbResponseBuf2 - this is loaded in
        // Class2iModemDialog.

        // (MyDebugPrint (pTG, LOG_ALL, "Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Parse through the received strings, looking for the DIS, CSI,
        // NSF

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process ATD Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

        Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
        Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

        // Class2 modems do their own negotiation & we need to stay in sync
        // Otherwise, we might send MR data while the modem sends a DCS
        // saying it is MH. This happens a lot with Exar modems because
        // they dont accept an FDIS= command during the call.
        // FIX: On all Class2 sends force remote caps to always be MH
        // Then in efaxrun we will always negotiate MH & encode MH
        // We are relying on the fact that (a) it seems that all/most
        // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
        // negotiate MH and (c) We will override all non-Exar modem's
        // intrinsic negotiation by sending an AT+FDIS= just before the FDT
        // Also (d) This change makes our behaviour match Snowball exactly
        // so we will work no better or worse than it :-)
        bc.Fax.Encoding = MH_DATA;

        if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed return from ICommRecvCaps.\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // now get the SEND_PARAMS
        if(!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
        {
        err_status = T30_CALLFAIL;
                return err_status;
        }


#ifdef FILET30
        // Send the raw capabilities string - most values
        // will be null, since CAS does not tell us things like
        // DIS, NSF, etc. But, we can put in the CSI.
        ICommRawCaps(pTG, (LPBYTE) &bNull, (LPBYTE) &bNull, 0, NULL, 0);
#endif

        ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);


        // Turn off flow control.
        FComXon(pTG, FALSE);

        // The Send params were set during the call to Class2GetBC
        // We'll use these to set the ID (for the TSI) and the DCS params

        // Send the FDT and get back the DCS. The FDT must be followed by
        // CONNECT and a ^Q (XON)
        // The FDT string must have the correct resolution and encoding
        // for this session. FDT=Encoding, Res, width, length
        // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
        // Res 0=200x100 (normal), 1=200x200 (fine)
        // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
        //              3=1216/151,4=864/107
        // PageLength 0=A4,1=B4,2=unlimited

        Class2SetDIS_DCSParams(pTG, SEND_PARAMS, (LPUWORD)&Encoding,
          (LPUWORD)&Res, (LPUWORD)&PageWidth, (LPUWORD)&PageLength,
                        (LPSTR) szTSI);



        //
        // Current Win95 version of Class2 TX is limited to MH only.
        // While not changing this, we will at least allow MR selection in future.
        //

        if (!pTG->fTiffThreadCreated) {

             if (Encoding) {
               pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
             }
             else {
               pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
             }
            
            
             if (Res) {
               pTG->TiffConvertThreadParams.HiRes = 1;
             }
             else {
               pTG->TiffConvertThreadParams.HiRes = 0;
            
               // use LoRes TIFF file prepared by FaxSvc
            
               // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
            
             }
   
             _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
             pTG->TiffConvertThreadParams.lpszLineID[8] = 0;



             (MyDebugPrint(pTG,  LOG_ALL, "Creating TIFF helper thread \r\n"));
             pTG->hThread = CreateThread(
                           NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                           (LPVOID) pTG,
                           0,
                           &TiffConvertThreadId
                           );

             if (!pTG->hThread) {
                 (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> TiffConvertThread create FAILED\r\n"));
                 
                 err_status = T30_CALLFAIL;
                 return err_status;
             }

             pTG->fTiffThreadCreated = 1;
             pTG->AckTerminate = 0;
             pTG->fOkToResetAbortReqEvent = 0;

             if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) {
                 T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
                 T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                                 (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                 sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

             }
        }


        // Even modems that take FDT=x,x,x,x don't seem to really do it
        // right. So, for now, just send FDIS followed by FDT except for
        // the EXAR modems!!
        uwLen = (UWORD)wsprintf(bFDISBuf, pTG->cbszFDIS, Res,
                 min(Pcb.Baud, pTG->DISPcb.Baud), PageWidth, PageLength, Encoding);
        if(!Class2iModemDialog(pTG, bFDISBuf, uwLen, LOCALCOMMAND_TIMEOUT,
          TRUE, 0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed get response from FDIS!!\r\n"));
                // Ignore it -we are going to send what we have!
        }

        if(!Class2iModemDialog(pTG, pTG->cbszFDT, (UWORD) (strlen(pTG->cbszFDT) ),
                   STARTSENDMODE_TIMEOUT, TRUE, 0,
                        pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FDT Received %s\r\n",(LPSTR)(&(pTG->lpbResponseBuf2))));

                (MyDebugPrint (pTG, LOG_ALL, "FDT to start first PAGE Failed!\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        (MyDebugPrint (pTG, LOG_ALL, "FDT Received %s\r\n", (LPSTR)(&(pTG->lpbResponseBuf2))));


        // Turn on flow control.
        FComXon(pTG, TRUE);

        // Search through Response for the DCS frame - need it so set
        // the correct zero stuffing

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDT Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // Got a response - see if baud rate is OK
        (MyDebugPrint (pTG, LOG_ALL, "Negotiated Baud Rate = %d, lower limit is %d\n\r", Pcb.Baud, pTG->ProtParams2.LowestSendSpeed));

        if (CodeToBPS[Pcb.Baud] < (WORD)pTG->ProtParams2.LowestSendSpeed)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Aborting due to too low baud rate!\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        // Use values obtained from the DCS frame to set zero stuffing.
        // (These were obtained by call to Class2ResponseAction above).
        // Zero stuffing is a function of minimum scan time (determined
        // by resolution and the returned scan minimum) and baud.
        // Fixed the Hack--added a Baud field

        // Init must be BEFORE SetStuffZero!
        FComOutFilterInit(pTG );
        FComSetStuffZERO(pTG, Class2MinScanToBytesPerLine(pTG, Pcb.MinScan, (BYTE) Pcb.Baud, Pcb.Resolution));


        PagesSent = 0;
        err_status =  T30_CALLDONE;


        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
        {

          (MyDebugPrint (pTG, LOG_ALL, "IN MULTIPAGE WHILE LOOP. Pages Sent = %d\n\r", PagesSent));

          //// faxTlog(("SENDING Reams of Page Data.....\r\n"));

          lTotalLen = 0;

          FComOverlappedIO(pTG, TRUE); // TRUE
          while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
          {
                BG_CHK(lpbf && lpbf->wLengthData > 0);

                lTotalLen += lpbf->wLengthData;
                (MyDebugPrint (pTG, LOG_ALL, "TOTAL LENGTH: %ld\r\n", lTotalLen));

                if(!(Class2ModemSendMem(pTG, lpbf->lpbBegData,
                     lpbf->wLengthData) & (MyFreeBuf(pTG, lpbf))))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Class2ModemSendBuf Failed\r\n"));
                        err_status =  T30_CALLFAIL;
                        FComOverlappedIO(pTG, FALSE);
                        return err_status;
                }

                if (pTG->fAbort)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Abort during Send loop\r\n"));
                        pTG->fAbort = FALSE;
                        err_status =  T30_CALLFAIL;
                        FComOverlappedIO(pTG, FALSE);
                        return err_status;
                }



          } // end of SEND_SEQ while

          //
          // Send RTC (Class2.0 specific)
          //

          if (Encoding) {
             if (! FComDirectAsyncWrite(pTG, bMRClass20RTC, 10) ) {
                  MyDebugPrint (pTG, LOG_ERR, "Failed to terminate page with MR RTC \n\r");
                  err_status =  T30_CALLFAIL;
                  return err_status;
             }
          }
          else {
             if (! FComDirectAsyncWrite(pTG, bMHClass20RTC, 9) ) {
                  MyDebugPrint (pTG, LOG_ERR, "Failed to terminate page with MH RTC\n\r");
                  err_status =  T30_CALLFAIL;
                  return err_status;
             }
          }


          MyDebugPrint( pTG, LOG_ALL, "OUT OF WHILE SEND_SEQ LOOP. \r\n");
          MyDebugPrint (pTG, LOG_ALL, "TOTAL LENGTH: %ld\r\n", lTotalLen);
                
          // Acknowledge that we sent the page
          ICommSendPageAck(pTG, TRUE);
          PagesSent++;

          //See if more pages to send...
          if ( ICommNextSend(pTG) == NEXTSEND_MPS )
          {
                // Terminate the Page with DLE-,
                MyDebugPrint (pTG, LOG_ALL, "Another page to send...\n\r");

                // Terminate the Page with DLE-ETX
                if(!FComDirectAsyncWrite(pTG, bClass20DLE_nextpage, 2))
                {
                        MyDebugPrint (pTG, LOG_ERR, "Failed to terminate page with DLE-ETX\n\r");
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Flow control is turned off inside of ModemDrain.
                if(!Class2ModemDrain(pTG))
                {
                        MyDebugPrint (pTG, LOG_ERR, "Failed to drain\n\r");
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Now, Send the FDT to start the next page (this was done for
                // the first page before entering the multipage loop).

                if(!Class2iModemDialog(pTG, pTG->cbszFDT, (UWORD) strlen(pTG->cbszFDT), 
                           STARTSENDMODE_TIMEOUT, TRUE, 0, 
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        MyDebugPrint (pTG, LOG_ERR, "FDT to start next PAGE Failed!\n\r");
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Turn on flow control.
                FComXon(pTG, TRUE);

          } //if we do not have another page, do the else...
          else break; // All done sending pages...

          if ( err_status == T30_CALLFAIL) break;

        } //End of multipage while


        MyDebugPrint (pTG, LOG_ALL, "OUT OF WHILE MULTIPAGE LOOP.  ABOUT TO SEND FINAL.\r\n");

        //
        // Purge input COM queue to purge all OKs 
        //

        FComFlushInput(pTG);


        // Send end of message sequence
        // Terminate the document with DLE-0x2e
        if(!FComDirectAsyncWrite(pTG, bClass20DLE_enddoc, 2))
        {
                MyDebugPrint (pTG, LOG_ERR, "Failed to terminate doc with DLE-x2e\n\r");
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        if(!Class2ModemDrain(pTG))
        {
                MyDebugPrint (pTG, LOG_ERR, "Failed to drain after DLE-x2e\n\r");
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);

        // If *any* page failed to send correctly, the call failed!
        if (!fAllPagesOK) err_status = T30_CALLFAIL;
        return err_status;

}






/**************************************************************
        Receive specific routines start here
***************************************************************/

BOOL  T30Cl20Rx (PThrdGlbl pTG)

//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
{
        LPSTR           lpszSection = pTG->FComModem.rgchKey;
        USHORT          uRet1, uRet2;
        BYTE            bBuf[200],
                        bTempBuf[200+RESPONSE_BUF_SIZE];
        UWORD           uwLen, uwRet;
        UWORD           Encoding, Res, PageWidth, PageLength;
        BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
        CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
        LPBYTE          lpbyte;
        BOOL            fBaudChanged;
        BOOL            RetCode;



        (MyDebugPrint (pTG, LOG_ALL, "Entering Class2 Callee\n\r"));

        uRet2 = 0;
        if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG )))
        {
                (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Class20Callee: iModemGetCmdTabPtr failed.\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // first get SEND_CAPS
        if(!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
        {
               uRet1 = T30_CALLFAIL;

               pTG->fFatalErrorWasSignaled = 1;
               SignalStatusChange(pTG, FS_FATAL_ERROR);
               RetCode = FALSE;

               goto done;
        }

        // Go to Class2.0
        if(!iModemGoClass(pTG, 3))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class20Callee: Failed to Go to Class 2.0 \n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // Begin by checking for manufacturer and ATI code.
        // Look this up against the modem specific table we
        // have and set up the receive strings needed for
        // this modem.
        if(!Class20GetModemMaker(pTG ))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Call to GetModemMaker failed\n\r"));
                // Ignore failure!!!
        }

        // set manufacturer specific strings

        Class2SetMFRSpecific(pTG, lpszSection);

        // Get the capabilities of the software. I am only using this
        // right now for the CSI field (below where I send +FLID).
        // Really, this should also be used instead of the hardcoded DIS
        // values below.
        // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
        // A "RING" COULD APPEAR AT ANY TIME!
        _fmemset((LPB)szCSI, 0, sizeof(szCSI));
        Class2SetDIS_DCSParams(pTG, SEND_CAPS, (LPUWORD)&Encoding, (LPUWORD)&Res,
                (LPUWORD)&PageWidth, (LPUWORD)&PageLength, (LPSTR) szCSI);

        // Find out what the default DIS is
        if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS, (UWORD) (strlen(pTG->cbszFDIS_IS) ),
              LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                      pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
        {
              (MyDebugPrint (pTG, LOG_ALL, "FDIS? failed\n\r"));
              // ignore
        }

        // See if the reply was ERROR or timeout, if so try a different command
        if ( uwRet == 2) 
        {
               if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS,
                       (UWORD) (strlen(pTG->cbszFDIS_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                       pTG->cbszCLASS2_OK, (C2PSTR) NULL)))
               {
                       // No FDIS, FDCC worked - quit!
                       (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> No FDIS? or FDCC? worked\n\r"));
                       uRet1 = T30_CALLFAIL;

                       pTG->fFatalErrorWasSignaled = 1;
                       SignalStatusChange(pTG, FS_FATAL_ERROR);
                       RetCode = FALSE;

                       goto done;
               }
               
               

                // If the first character in the reply before a number
                // is a ',', insert a '1' for normal & fine res (Exar hack)
                for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
                {
                        if (*lpbyte == ',')
                        {
                                // found a leading comma
                                bTempBuf[0] = '\0';
                                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,
                                                lpbyte);
                                _fstrcpy(lpbyte, bTempBuf);
                                (MyDebugPrint (pTG, LOG_ALL, "Leading comma in DCC string =\n\r", (LPSTR)&pTG->lpbResponseBuf2));

                        }

                        if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) break;
                }

        }

        // If the repsonse was just a number string without "+FDIS" in front
        // of it, add the +FDIS. Some modem reply with it, some do not. The
        // general parsing algorithm used below in Class2ResponseAction needs
        // to know the command that the numbers refer to.
        if ( pTG->lpbResponseBuf2[0] != '\0' &&
           (Class2_fstrstr( (LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
        {
                // did not get the FDIS in the response!
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
                wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,
                                (LPSTR)pTG->lpbResponseBuf2);
                _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received %s from FDIS?\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Process default DIS to see if we have to send a DCC to change
        // it. Some modems react badly to just sending a DCC with ",,,"
        // so we can't rely on the modem keeping DIS parameters unchanged
        // after a DCC like that. We'll use the FDISResponse routine to load
        // the default DIS values into a PCB structure
        if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDIS Response\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;
                
                goto done;
        }

        fBaudChanged = FALSE;
        // See if we have to change the baud rate to a lower value.
        // This only happens if the user set an ini string inhibiting
        // V.17 receive
        if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Recv) )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Lowering baud from %d for V.17 receive inihibit\n\r", CodeToBPS[pTG->DISPcb.Baud]));

                pTG->DISPcb.Baud = 3; //9600 won't use V.17
                fBaudChanged = TRUE;
        }
// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }

        // Now, look and see if any of the values in the DIS are "bad"
        // That is, make sure we can receive high res and we are not
        // claiming that we are capable of MR or MMR. Also, see if we changed
        // the baud rate. Also make sure we can receive wide pages.

        // Set the current session parameters
        uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
        if(!Class2iModemDialog(pTG, bBuf, uwLen, 
                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, 
                                (C2PSTR) NULL))
        {
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }


        // Enable Reception
        if(!Class2iModemDialog(pTG, pTG->cbszFCR, (UWORD) (strlen(pTG->cbszFCR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                           pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FCR failed\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        if(!Class2iModemDialog(pTG, pTG->cbszFNR, (UWORD) (strlen(pTG->cbszFNR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                           pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ERR, "FNR failed\n\r"));
                // ignore error
        }


        // // Turn off ECM - don't do for sierra type modems!
        // if (!pTG->CurrentMFRSpec.bIsSierra)
        //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
        //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
        //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        //      {
        //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
        //              // Ignore ECM failure!!!
        //      }

        // Turn off Copy Quality Checking - also skip for Sierra type modems
        if(!Class2iModemDialog(pTG, pTG->cbszFCQ, (UWORD) (strlen(pTG->cbszFCQ) ),
                ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FCQ failed\n\r"));
                // Ignore CQ failure!!!
        }


        // Set the local ID - need ID from above to do this.
        bIDBuf[0] = '\0';
        uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
        if(!Class2iModemDialog(pTG, bIDBuf, uwLen,
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Local ID failed\n\r"));
                // ignore failure
        }


        // Answer the phone

                // have to call hangup on every path out of here
                // after Answer is called. If Answer fails, it calls Hangup.
                // if it succeeds we have to call Hangup when we're done


        SignalStatusChange(pTG, FS_ANSWERED);

        if((uRet2 = Class2Answer(pTG, FALSE)) != CONNECT_OK)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Answer failed\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        (MyDebugPrint (pTG, LOG_ALL, "Done with Class2 Answer - succeeded!!\n\r"));
        ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);


        // Receive the data
        uRet1 = (USHORT)Class20Receive(pTG );
        if ( uRet1 == T30_CALLDONE)
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, ALL OK\r\n"));
                ICommStatus(pTG, T30STATR_SUCCESS, 0, 0, 0);

                // have to call hangup on every path out of here
                // we have to call Hangup here
                Class2ModemHangup(pTG );

                SignalStatusChange(pTG, FS_COMPLETED);
                RetCode = TRUE;

        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, **** FAILED *****\r\n"));
                ICommStatus(pTG, T30STATR_FAIL, 0, 0, 0);

                // Make sure modem is in an OK state!
                FComXon(pTG, FALSE);
                // have to call hangup on every path out of here
                // Abort calls Hangup
                Class2ModemAbort(pTG );

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

        }
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;

done:
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);
        
        return RetCode;
}



BOOL Class20Receive(PThrdGlbl pTG)
{
        LPBUFFER        lpbf;
        SWORD           swRet;
        UWORD           uwLen;
        ULONG           lTotalLen=0;
        PCB             Pcb;
        USHORT          uTimeout=30000, uRet, PagesReceived, uFPTSarg;
        BOOL            err_status;
        BCwithTEXT      bc;
        BYTE            bBuf[200];
        DWORD           tiffCompression;
        LPSTR           lpsTemp;
        DWORD           HiRes;


        // FComCriticalNeg(TRUE);

        //// faxTlog(("\r\n\r\n\r\n\r\n\r\n======================= Entering Class 2 Receive*** ==============================\r\n\r\n\r\n\r\n"));

        /*
        * We have just answered!
        */

        // The repsonse to the ATA command is in the global variable
        // pTG->lpbResponseBuf2.

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process ATA Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        //Now that pcb is set up, call ICommReceiveParams to tell icomfile

        Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
        Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

        if( ICommRecvParams(pTG, (LPBC)&bc) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed return from ICommRecvParams.\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        //
        // once per RX - create TIFF file as soon as we know the compression / resolution.
        //

        pTG->Encoding   = Pcb.Encoding;
        pTG->Resolution = Pcb.Resolution;



        if (Pcb.Encoding == MR_DATA) {
            tiffCompression =  TIFF_COMPRESSION_MR;
        }
        else {
            tiffCompression =  TIFF_COMPRESSION_MH;
        }

        if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) {
            HiRes = 1;
        }
        else {
            HiRes = 0;
        }


        if ( !pTG->fTiffOpenOrCreated) {
            //
            // top 32bits of 64bit handle are guaranteed to be zero
            //
            pTG->Inst.hfile =  PtrToUlong (TiffCreateW ( pTG->lpwFileName,
                                                 tiffCompression,
                                                 1728,
                                                 FILLORDER_LSB2MSB,
                                                 HiRes
                                                 ) );

            if (! (pTG->Inst.hfile)) {

                lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't create tiff file %s compr=%d \n",
                                           lpsTemp,
                                           tiffCompression);

                MemFree(lpsTemp);
                err_status =  T30_CALLFAIL;
                return err_status;

            }

            pTG->fTiffOpenOrCreated = 1;

            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

            MyDebugPrint(pTG, LOG_ALL, "Created tiff file %s compr=%d HiRes=%d \n",
                                       lpsTemp,  tiffCompression, HiRes);

            MemFree(lpsTemp);
        }

        // we set buffer sizes and recv mode (ECM/non-ECM) here
        //ICommSetRecvMode(pTG, FALSE);        // always non-ECM?

        // **** Apparently, we don't want flow control on, so we'll turn
        // it off. Is this true???? If I turn it on, fcom.c fails a
        // debug check in filterreadbuf.
        FComXon(pTG, FALSE);


        // Send the FDR. The FDR must be responded to by a CONNECT.

        if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
           STARTSENDMODE_TIMEOUT, TRUE, 0,
                        pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed get response from initial FDR!!\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        (MyDebugPrint (pTG, LOG_ALL, "FDR Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Might have to search through FDR response, but I doubt it.

        // Now we need to send a DC2 (0x12) to tell the modem it is OK
        // to give us data.
        // Some modems use ^Q instead of ^R - The correct value was written
        // into the DC@ string in Class20Callee where we checked for
        // manufacturer

        FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);


        // Now we can receive the data and give it to the icomfile routine

        PagesReceived = 0;
        err_status =  T30_CALLDONE;

        while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
        {

          (MyDebugPrint (pTG, LOG_ALL, "IN MULTIPAGE WHILE LOOP. Pages Received = %d\n\r", PagesReceived));


          //// faxTlog(("Receiving Reams of Page Data.....\r\n"));
        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
#define READ_TIMEOUT    15000

          lTotalLen = 0;
          do
          {
                (MyDebugPrint (pTG, LOG_ALL, "In receiving a page loop\n\r"));
                uRet=Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);

                if(lpbf)
                {
                        lTotalLen += lpbf->wLengthData;
                        (MyDebugPrint (pTG, LOG_ALL, "In lpbf if. Total Length %ld\n\r", lTotalLen));

                        if(!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "Bad return - PutRecvBuf in page\r\n"));
                                err_status=T30_CALLFAIL;
                                return err_status;
                        }
                        lpbf = 0;
                }
          }
          while(uRet == RECV_OK);

          (MyDebugPrint (pTG, LOG_ALL, "Out of RECV_SEQ do loop\n\r"));

          if(uRet == RECV_EOF)
          {
                (MyDebugPrint (pTG, LOG_ALL, "Got EOF from RecvBuf\n\r"));
                // FComCriticalNeg(TRUE);

                
                // RSL needed interface to TIFF thread
                pTG->fLastReadBlock = 1;
                ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
                
                
          }
          else
          {
                // Timeout from ModemRecvBuf
                (MyDebugPrint (pTG, LOG_ALL, "ModemRecvBuf Timeout or Error=%d\r\n", uRet));
                err_status = T30_CALLFAIL;
                return err_status;
          }

          //// faxTlog(pTG, ("Page Recv Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));


          PagesReceived++;

          // Set the FPTS parameter based on the global pTG->fRecvPageOK variable.
          // This variable was set during the call to Class2GetRecvPageAck above.
          // The quality of the page was checked during that call.
          // This command will cause an the next FDR command to send either
          // "MCF" or "RTN".

          if (pTG->fRecvPageOK) uFPTSarg = 1; // 1 indicates a good page
          else uFPTSarg = 2; // 2 indicates a bad page, retrain requested.


          // See if more pages to receive by parsing the FDR response...
          // After the DLEETX was received by Class2ModemRecvBuf, the
          // FPTS and FET response should be coming from the modem, terminated
          // by an OK. Let's go read that!

          if(!Class2iModemDialog(pTG, NULL, 0,
                   STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
          {

                (MyDebugPrint (pTG, LOG_ALL, "END PAGE Processing Failed!\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
          }

          (MyDebugPrint (pTG, LOG_ALL, "EOP Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

          // Process the response and see if more pages are coming

          if (Class2EndPageResponseAction(pTG ) == MORE_PAGES)
          {

                ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);

                // Send the FPTS - don't do this for Exar modems!
                if (0)
                {
                        uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, uFPTSarg);
                        if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "FPTS= failed\n\r"));
                                // Ignore FPTS failure!!!
                        }
                }

                // Now, Send the FDR to start the next page (this was done for
                // the first page before entering the multipage loop).

                if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
                           STARTSENDMODE_TIMEOUT, TRUE, 0,
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FDR to start next PAGE Failed!\n\r"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Now send the correct DC2 string set in Class20Callee
                // (DC2 is standard, some use ^q instead)
                FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

          } //if we do not have another page, do the else...
          else break; // All done receiving pages...

        } //End of multipage while

        (MyDebugPrint (pTG, LOG_ALL, "OUT OF WHILE MULTIPAGE LOOP. ABOUT TO SEND FINAL FDR.\r\n"));
        //RSL
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
        

        // Send end of message sequence
        // Send the last FPTS - do we really need to do this???
#if 0
        uwLen = wsprintf(bBuf, pTG->cbszFPTS, uFPTSarg);
        if(!Class2iModemDialog(pTG, bBuf, uwLen, LOCALCOMMAND_TIMEOUT, TRUE,
                0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FPTS= failed\n\r"));
                // Ignore FPTS failure!!!
        }
#endif        

        // Send last FDR
        if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
           STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
        {

                err_status =  T30_CALLFAIL;
                return err_status;
        }


        FComXon(pTG, FALSE);

        return err_status;

}

// ACTIVESLICE defined in msched.h
#define IDLESLICE       500

#ifdef WFWBG
#  ifdef NOPRE
#    define MySleep(x)                                                                                          \
                BG_CHK(x==IDLESLICE); IFSetTimeSlice(IDLESLICE);                        \
                ExitDLLCritSection(); IFDllSleep(0); EnterDLLCritSection();     \
                IFSetTimeSlice(ACTIVESLICE);
#  else
#    define MySleep(x)                                                                          \
                BG_CHK(x==IDLESLICE); IFSetTimeSlice(IDLESLICE);        \
                IFDllSleep(0); IFSetTimeSlice(ACTIVESLICE);
#  endif
#endif //WFWBG


#if defined(WIN32) && defined(THREAD)
#       define MySleep(x) BG_CHK(x); Sleep(x);
#endif //WIN32 && THREAD

#ifdef IFK
#       define MySleep(x)       IFProcSleep(x)
#endif





BOOL Class20GetModemMaker(PThrdGlbl pTG)
{
        USHORT i;

        // Initialize the current modem variable's (global) strings.
        pTG->CurrentMFRSpec.szATI[0] = '\0';
        pTG->CurrentMFRSpec.szMFR[0] = '\0';
        pTG->CurrentMFRSpec.szMDL[0] = '\0';
        // pTG->CurrentMFRSpec.szREV[0] = '\0';

//      // Get the ATI - repsonse is in pTG->lpbResponseBuf2
//      // For all responses, "ERROR" may come back - that is OK - we will
//      // never match ERROR to an acceptable modem manufacturer name, model,
//      // revision, etc.
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_ATI, (UWORD) strlen(pTG->cbszCLASS2_ATI),
                      ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                      pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "ATI failed\n\r"));
                // Ignore ATI failure!!!
        }
        else
        {
                // copy ATI answer into ATI variable
                for (i=0; i<MFR_SIZE; i++)
                        pTG->CurrentMFRSpec.szATI[i] = pTG->lpbResponseBuf2[i];
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received ATI %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));


        // Get the FMFR - repsonse is in pTG->lpbResponseBuf2
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_FMFR, (UWORD) (strlen(pTG->cbszCLASS2_FMFR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FMFR failed\n\r"));
                // Ignore FMFR failure!!!
        }
        else
        {
                // copy FMFR answer into FMFR variable
                for (i=0; i<MFR_SIZE; i++)
                        pTG->CurrentMFRSpec.szMFR[i] = pTG->lpbResponseBuf2[i];
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received FMFR %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Get the FMDL - repsonse is in pTG->lpbResponseBuf2
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_FMDL, (UWORD) (strlen(pTG->cbszCLASS2_FMDL) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FMDL failed\n\r"));
                // Ignore FMDL failure!!!
        }
        else
        {
                // copy FMDL answer into FMDL variable
                for (i=0; i<MFR_SIZE; i++)
                        pTG->CurrentMFRSpec.szMDL[i] = pTG->lpbResponseBuf2[i];
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received FMDL %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Get the FREV - repsonse is in pTG->lpbResponseBuf2
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_FREV, (UWORD) strlen (pTG->cbszCLASS2_FREV),
                     ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                     pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
             (MyDebugPrint (pTG, LOG_ALL, "FREV failed\n\r"));
             // Ignore FREV failure!!!
        }
        else
        {
             // copy FREV answer into REV variable
             for (i=0; i<MFR_SIZE; i++)
                     pTG->CurrentMFRSpec.szREV[i] = pTG->lpbResponseBuf2[i];
        }
        (MyDebugPrint (pTG, LOG_ALL, "Received REV %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        return TRUE;
}




                           
                                                      

BOOL Class20Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
        int     i,
                j,
                comm_numb = 0,
                parameters;
        BYTE    switch_char,
                char_1,
                char_2;
        char    c;

        BOOL    found_command = FALSE;

        #define STRING_PARAMETER        1
        #define NUMBER_PARAMETERS       2
        for(i = 0; lpbBuf[i] != '\0'; ++i)
        {
                switch ( lpbBuf[i] )
                {
                        case 'C':
                                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                                {
                                        cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                                        for(; lpbBuf[i] != '\r'; ++i )
                                                ;
                                }
                                else
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad First C values\n\r"));
                                                return FALSE;
                                }
                                break;

                        case 'O':
                                if (lpbBuf[++i] == 'K' )
                                {
                                        cl2_comm->command[comm_numb++] = CL2DCE_OK;
                                        for(; lpbBuf[i] != '\r'; ++i )
                                                ;
                                }
                                else
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad O values\n\r"));
                                                return FALSE;
                                }
                                break;

                        case 0x11:
                                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                                break;

                        case '+':
                                if( lpbBuf[++i] != 'F' )
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad + values\n\r"));
                                                return FALSE;
                                }
                                switch_char = lpbBuf[++i];
                                char_1 = lpbBuf[++i];
                                char_2 = lpbBuf[++i];
                                // (MyDebugPrint (pTG, LOG_ALL, "Parse: in + command - %c%c%c \n\r",
                                //      switch_char, char_1, char_2));
                                switch ( switch_char )
                                {
                                        case 'C':
                                                //  Connect Message +FCON.
                                                if ( char_1 == 'O' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCON;
                                                        parameters = FALSE;
                                                }

                                                // Report of Remote ID. +FCIG.
                                                else if (char_1 == 'I' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                // Report DCS frame information +FCS - Clanged for Class2.0
                                                else if ( char_1 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }

                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad C values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'D':
                                                if ( char_1 == 'M' )
                                                {
                                                      cl2_comm->command[comm_numb] = CL2DCE_FDM;
                                                      parameters = NUMBER_PARAMETERS;
                                                }
                                                else 
                                                {
                                                              ERRMSG(("Parse: Bad D values\n\r"));
                                                              return FALSE;
                                                }
                                                break;
                                                
                                           

                                        case 'E':
                                                // Post page message report. +FET.
                                                if ( char_1 == 'T' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FET;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad E values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'H':
                                        // Debug report transmitted HDLC frames +FHT
                                                if ( char_1 == 'T' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHT;
                                                        parameters = STRING_PARAMETER;
                                                }
                                        // Debug report received HDLC frames +FHR
                                                if ( char_1 == 'R' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHR;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                // Report hang up.  +FHNG.
                                                else if ( char_1 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad H values\n\r"));
                                                                return FALSE;
                                                }
                                                break;


                                        case 'I':
                                                // Report DIS frame information +FIS - Changed for Class2.0
                                                if ( char_1 == 'S' )
                                                {
                                                      cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                                                      parameters = NUMBER_PARAMETERS;
                                                }                                               
                                                else 
                                                {
                                                              ERRMSG(("Parse: Bad I values\n\r"));
                                                              return FALSE;
                                                }
                                                break;






                                        case 'N':
                                                // Report NSF frame reciept.
                                                if ( char_1 == 'F' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report NSS frame reciept.
                                                else if ( char_1 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report NSC frame reciept.
                                                else if ( char_1 == 'C' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad N values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                       case 'P':


                                                // Report of Remote ID. +FPI - Changed for Class2.0
                                                if (char_1 == 'I')
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                // Report poll request. +FPO - Changed for Class2.0
                                                else if ( char_1 == 'O' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                                                        parameters = FALSE;
                                                }
                                                // Page Transfer Status Report +FPS - Changed for Class2.0
                                                else if ( char_1 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else 
                                                {
                                                                ERRMSG(("Parse: Bad P values\n\r"));
                                                                return FALSE;
                                                }
                                                break;


                                        case 'T':

                                                // Report DTC frame information +FTC - Changed for Class2.0
                                                if ( char_1 == 'C' )
                                                {
                                                      cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                                                      parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report remote ID +FTI - Changed for Class2.0
                                                else if ( char_1 == 'I' )
                                                {
                                                      cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                                                      parameters = STRING_PARAMETER;
                                                }
                                                else 
                                                {
                                                              ERRMSG(("Parse: Bad T values\n\r"));
                                                              return FALSE;
                                                }
                                                break;






                                        case 'V':
                                                // Report voice request +FVOICE.
                                                if ( char_1 == 'O' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                                                        parameters = FALSE;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad V values\n\r"));
                                                                return FALSE;
                                                }
                                }

                                //  Transfer the associated paramters to the parameter array.
                                if ( parameters == NUMBER_PARAMETERS)
                                {
                                        for(i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                                        {
                                                //  Skip past the non numeric characters.
                                                if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' ) continue;

                                                /*  Convert the character representation of the numeric
                                                         parameter into a true number, and store in the
                                                        parameter list.  */
                                                cl2_comm->parameters[comm_numb][j] = 0;
                                                for(; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                                                {
                                                        cl2_comm->parameters[comm_numb][j] *= 10;
                                                        cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                                                }
                                                i--; // the last for loop advanced 'i' past the numeric.
                                                j++; // get set up for next parameter
                                        }
                                }
                                else if (parameters == STRING_PARAMETER )
                                {
                                        // Skip the : that follows the +f command (eg +FTSI:)
                                        if (lpbBuf[i+1] == ':') i++;
                                        // Also skip the " that follows the :
                                        if (lpbBuf[i+1] == '\"') i++;
                                        // Also skip leading blanks
                                        while (lpbBuf[i+1] == ' ') i++;
                                        for(i+=1, j=0; (c = lpbBuf[i])  != '\r' && c != '\n' &&
                                                c != '\0'; ++i, ++j)
                                        {
                                                cl2_comm->parameters[comm_numb][j] = c;
                                        }
                                        // Skip the trailing "
                                        if ((j > 0) && (cl2_comm->parameters[comm_numb][j - 1] == '\"')) j--;
                                        // Also skip the trailing blanks
                                        for ( ; (j > 0) && (cl2_comm->parameters[comm_numb][j - 1] == ' '); j--);
                                        cl2_comm->parameters[comm_numb][j] = '\0';
                                }

                                //  No parameters, so just skip to end of line.
                                else
                                {
                                        for(; (c=lpbBuf[i]) != '\r'
                                                && c != '\n' && c != '\0'; ++i)
                                                ;
                                }

                                //  Increment command count.
                                ++comm_numb;
                                break;

                        default:
                                break;
                }
        }
        cl2_comm->comm_count = (USHORT)comm_numb;
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\crc.c ===
/***************************************************************************
 Name     :     CRC.C
 Comment  :     HDLC encoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"



#include "decoder.h"
#include "debug.h"

#include "glbproto.h"

#define FILEID                  FILEID_CRC

WORD CODEBASED CRCTab[16] =
        {       0x0000, 0x1081, 0x2102, 0x3183,
                0x4204, 0x5285, 0x6306, 0x7387,
                0x8408, 0x9489, 0xa50a, 0xb58b,
                0xc60c, 0xd68d, 0xe70e, 0xf78f };







WORD SWECMEXP CalcCRC(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc)
{

#if !defined(PORTABLE_CODE) || defined(CLASS1_TEST_HOOKS)
        WORD    wRet;
#endif

#ifdef PORTABLE_CODE
        USHORT   wTempChar=0, j=0, wTempCRC=(USHORT)-1;
        USHORT SourceIndex;
        LPBYTE SourceAddress;

        SourceAddress = lpbSrc;

        for(SourceIndex = cbSrc;SourceIndex > 0; SourceIndex--) {
            wTempChar = (USHORT) *SourceAddress++;
            j = (wTempCRC ^ wTempChar) & 0x0f;
            wTempCRC = (wTempCRC >> 4) ^ CRCTab[j];
            wTempChar >>= 4;
            j = (wTempCRC ^ wTempChar) & 0x0f;
            wTempCRC = (wTempCRC >> 4) ^ CRCTab[j];
            }

        wTempCRC = ~wTempCRC;
#endif


#ifdef CLASS1_TEST_HOOKS
if (wRet == wTempCRC) {
//   DEBUGMSG(1,("CalcCRC: Assembly and C CRC both = %X\n", wTempCRC));
   }
else
   ERRORMSG(("CalcCRC: Assembly CRC = %X; C CRC = %X\n", wRet, wTempCRC));
#endif

#ifdef PORTABLE_CODE
   return wTempCRC;
#else
        return wRet;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\ddi.c ===
/***************************************************************************
        Name      :     DDI.C

        Copyright (c) Microsoft Corp. 1991 1992 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#pragma warning(disable:4100)   // unreferenced formal param

#include "prep.h"

#include "mmsystem.h"
#include "comdevi.h"
#include "class1.h"
// #include "modem.h"
#include "debug.h"
#include "decoder.h"

///RSL
#include "glbproto.h"


#define faxTlog(m)              DEBUGMSG(ZONE_DDI, m)
#define faxT2log(m)             DEBUGMSG(ZONE_FRAMES, m)
#define FILEID                  FILEID_DDI

/* Converts a the T30 code for a speed to the Class1 code
 * Generates V.17 with Long Training.
 * Add 1 to V.17 codes to get teh Short-train version
 */
BYTE T30toC1[16] =
{
/* V27_2400             0 */    24,
/* V29_9600             1 */    96,
/* V27_4800             2 */    48,
/* V29_7200             3 */    72,
/* V33_14400    4 */    145,    // 144, // V33==V17_long_train FTM=144 is illegal
                                                0,
/* V33_12000    6 */    121,    // 120, // V33==V17_long_train FTM=120 is illegal
/* V21 squeezed in */   3,
/* V17_14400    8 */    145,
/* V17_9600             9 */    97,
/* V17_12000    10 */   121,
/* V17_7200             11 */   73,
                                                0,
                                                0,
                                                0,
                                                0
};



int T30toSpeed[16] =
{
/* V27_2400             0 */    2400,
/* V29_9600             1 */    9600,
/* V27_4800             2 */    4800,
/* V29_7200             3 */    7200,
/* V33_14400    4 */    14400,    // 144, // V33==V17_long_train FTM=144 is illegal
                                                0,
/* V33_12000    6 */    12000,    // 120, // V33==V17_long_train FTM=120 is illegal
/* V21 squeezed in */   300,
/* V17_14400    8 */    14400,
/* V17_9600             9 */    9600,
/* V17_12000    10 */   12000,
/* V17_7200             11 */   7200,
                                                0,
                                                0,
                                                0,
                                                0
};

// used only for checking

static BYTE SpeedtoCap[16] =
{
/* V27_2400             0 */    0,
/* V29_9600             1 */    V29,    // 1
/* V27_4800             2 */    V27,    // 2
/* V29_7200             3 */    V29,    // 1
/* V33_14400    4 */    V33,    // 4
                                                0,
/* V33_12000    6 */    V33,    // 4
/* V21 squeezed in */   0,
/* V17_14400    8 */    V17,    // 8
/* V17_9600             9 */    V17,    // 8
/* V17_12000    10 */   V17,    // 8
/* V17_7200             11 */   V17,    // 8
                                                0,
                                                0,
                                                0,
                                                0
};


CBSZ cbszFTH3   = "AT+FTH=3\r";
CBSZ cbszFRH3   = "AT+FRH=3\r";

CBSZ cbszFRS    = "AT+FRS=%d\r";
CBSZ cbszFTS    = "AT+FTS=%d\r";
CBSZ cbszFTM    = "AT+FTM=%d\r";
CBSZ cbszFRM    = "AT+FRM=%d\r";

#ifdef MDRV
        CBSZ cbszOK, cbszCONNECT, cbszNOCARRIER, cbszERROR, cbszFCERROR;
#else //MDRV

// echo off, verbose response, no auto answer, hangup on DTR drop
// 30 seconds timer on connect, speaker always off, speaker volume=0
// busy&dialtone detect enabled
extern  CBSZ cbszOK       ;
extern  CBSZ cbszCONNECT   ;
extern  CBSZ cbszNOCARRIER  ;
extern  CBSZ cbszERROR       ;
extern  CBSZ cbszFCERROR      ;

#endif //MDRV



#define         ST_MASK         (0x8 | ST_FLAG)         // 8 selects V17 only. 16 selects ST flag

/******************** Global Vars *********/
BYTE                            bDLEETX[3] = { DLE, ETX, 0 };
BYTE                            bDLEETXOK[9] = { DLE, ETX, '\r', '\n', 'O', 'K', '\r', '\n', 0 };
/******************** Global Vars *********/




/****************** begin prototypes from ddi.c *****************/
void iModemParamsReset(PThrdGlbl pTG);
void iModemInitGlobals(PThrdGlbl pTG);

// If defined, iModemRecvFrame retries FTH until timeout,
// if it receiving a null frame followed by ERROR or NO_CARRIER.
//#define USR_HACK

#ifdef USR_HACK
USHORT iModemFRHorM(PThrdGlbl pTG, ULONG ulTimeout);
#endif // USR_HACK

/****************** begin prototypes from ddi.c *****************/


#ifndef MDRV

#ifdef DEBUG
        DBGPARAM dpCurSettings = {
                "Modem Driver", 0x0000, {
                "DDI", "Frames", "", "",
                "Class0", "", "", "",
                "", "", "SW Framing", "SW Framing Hi"
                "Debug", "", "", "" },
                // 0x00000FFF
                // 0x00000001
                // 0x0000000F0
                // 0x00000400   // too much for 14400 ECM
                // 0x00000F01
                0x00000000
                // 0xFFFFFFFF
        };
#endif


#define szMODULENAME    "awcl1_32"


#endif //MDRV










void iModemInitGlobals(PThrdGlbl pTG)
{

        _fmemset(&pTG->Class1Modem, 0, sizeof(CLASS1_MODEM));
        _fmemset(&pTG->Class1Status, 0, sizeof(CLASS1_STATUS));

        pTG->Class1Modem.eRecvFCS = RECV_FCS_NO;

#if 0 /// RSL #ifndef MDDI
        {
                LPCMDTAB lpCmdTab = iModemGetCmdTabPtr(pTG);
                pTG->Class1Modem.eRecvFCS = RECV_FCS_DUNNO;
                if (lpCmdTab)
                {
                        if (lpCmdTab->dwFlags&fMDMSP_C1_FCS_NO)
                                pTG->Class1Modem.eRecvFCS = RECV_FCS_NO;
                        else if (lpCmdTab->dwFlags&fMDMSP_C1_FCS_YES_BAD)
                                pTG->Class1Modem.eRecvFCS = RECV_FCS_NOCHK;
                }
        }
#endif //!MDDI

}













void iModemParamsReset(PThrdGlbl pTG)
{
        _fmemset(&pTG->ModemParams, 0 , sizeof(pTG->ModemParams));

        pTG->ModemParams.uSize = sizeof(pTG->ModemParams);
        pTG->ModemParams.Class = FAXCLASS1;

        // Don't use this. Need differnet number of flags according to speed
        // pTG->ModemParams.PreambleFlags = 400;     // 200ms @ 14400bps
        pTG->ModemParams.InterframeFlags = 3;        // random. one or two may do!
        // pTG->ModemParams.InterframeFlags = 10;    // too much!

        // must be **less* than 50, so need a
        // different length for each speed
        // pTG->ModemParams.ClosingFlags = 50;
        // pTG->ModemParams.fCEDOff = 0;
        // pTG->ModemParams.fCNGOff = 0;
        // pTG->ModemParams.InactivityTimer = 0;

        // pTG->ModemParams.cbLineMin = 0;
        // pTG->ModemParams.hJob = 0;
}














// added for CLASS0
BOOL   ModemSetParams(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParams)
{
        BG_CHK((uModem==1||uModem==5) && lpParams->uSize >= sizeof(MODEMPARAMS));

        if(lpParams->Class && lpParams->Class != (-1))
        {
#ifdef CL0
                BG_CHK(lpParams->Class == FAXCLASS1 || lpParams->Class == FAXCLASS0);
#else //CL0
                BG_CHK(lpParams->Class == FAXCLASS1);
#endif //CL0

                pTG->ModemParams.Class = lpParams->Class;
        }
        return TRUE;
}

















USHORT   NCUDial(PThrdGlbl pTG, HLINE hLine, LPSTR szPhoneNum)
{
        USHORT uRet;

        D_PrintDDI("NCUDial", (USHORT)hLine, 0);
        IF_BG_CHK(hLine==HLINE_2);
        IF_BG_CHK(pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);

        iModemInitGlobals(pTG);

#ifndef CL0
        pTG->ModemParams.Class = FAXCLASS1;
#endif

        if((uRet = iModemDial(pTG, szPhoneNum, pTG->ModemParams.Class)) == CONNECT_OK)
                pTG->Class1Modem.ModemMode = FRH;

        return uRet;
}
















USHORT   NCULink(PThrdGlbl pTG, HLINE hLine, HMODEM hModem, USHORT uHandset, USHORT uFlags)
{
        USHORT uRet;

        D_PrintDDI("NCULink", (USHORT)hLine, (USHORT)hModem);
        D_PrintDDI("NCULink", uHandset, uFlags);
        IF_BG_CHK(hLine==HLINE_2);
        IF_BG_CHK(pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse);

        switch(uFlags & NCULINK_MODEMASK)
        {
        case NCULINK_HANGUP:
                                        if(iModemHangup(pTG))
                                        {
                                                MDDISTMT(pTG->pTG->DDI.fNCUModemLinked = FALSE);
                                                uRet = CONNECT_OK;
                                        }
                                        else
                                                uRet = CONNECT_ERROR;
                                        break;

        case NCULINK_TX:
                                        MDDISTMT(pTG->DDI.fNCUModemLinked = TRUE);
                                        uRet = CONNECT_OK;
                                        break;
        case NCULINK_RX:
                                        iModemInitGlobals(pTG);

#                                       ifdef MDDI
                                                pTG->ModemParams.Class = FAXCLASS1;
#                                       endif //MDDI

                                        pTG->ModemParams.Class = FAXCLASS1;  //RSL
                                        if((uRet = iModemAnswer(pTG, (uFlags & NCULINK_IMMEDIATE), pTG->ModemParams.Class)) == CONNECT_OK)
                                        {
                                                MDDISTMT(pTG->DDI.fNCUModemLinked = TRUE);
                                                pTG->Class1Modem.ModemMode = FTH;
                                        }
                                        break;

        case NCULINK_OFFHOOK:
                                        // fall through. Can't handle yet
        default:                BG_CHK(FALSE);
                                        uRet = CONNECT_ERROR;
                                        break;
        }
//done:
        MDDISTMT((MyDebugPrint(pTG,  LOG_ALL,  "NCULink: uRet=%d Linked=%d\r\n", uRet, pTG->DDI.fNCUModemLinked)));
        return uRet;
}







// dangerous. May get 2 OKs, may get one. Generally avoid
// CBSZ cbszATAT                        = "AT\rAT\r";
CBSZ cbszAT1                    = "AT\r";

BOOL iModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags);






BOOL   ModemSync(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout)
{
        return iModemSyncEx(pTG, hModem, ulTimeout, 0);
}





#ifndef MDDI
BOOL   ModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags)
{
        return iModemSyncEx(pTG, hModem, ulTimeout, dwFlags);
}
#endif // !MDDI












BOOL iModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags)
{
        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        faxIFlog(("In ModemSync fModemOpen=%d fLineInUse=%d\r\n", pTG->DDI.fModemOpen, pTG->DDI.fLineInUse));

        ///// Do cleanup of global state //////
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        SWFramingSendSetup(pTG, FALSE);
        SWFramingRecvSetup(pTG, FALSE);
        FComXon(pTG, FALSE);
        EndMode(pTG);
        ///// Do cleanup of global state //////

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return TRUE;
#endif //CL0

        {
                LPCMDTAB lpCmdTab = iModemGetCmdTabPtr(pTG);
                if (
#ifndef MDDI
                        (dwFlags & fMDMSYNC_DCN) &&
#endif  //MDDI
                                pTG->Class1Modem.ModemMode == COMMAND
                        &&  lpCmdTab
                    &&  (lpCmdTab->dwFlags&fMDMSP_C1_NO_SYNC_IF_CMD) )
                {
                        ERRMSG((SZMOD "<<WARNING>> ModemSync: NOT Syching modem (MSPEC)\r\n"));
#ifdef WIN32
                        Sleep(100); // +++ 4/12 JosephJ -- try to elim this -- it's juse
#endif // WIN32
                                                // that we used to always issue an AT here, which
                                                // we now don't, so I issue a 100ms delay here instead.
                                                // MOST probably unnessary. The AT was issued by
                                                // accident on 4/94 -- as a side effect of
                                                // a change in T.30 code -- when ModemSync was
                                                // called just before a normal dosconnect. Unfortunately
                                                // we discovered in 4/95, 2 weeks before code freeze,
                                                // that the AT&T DataPort express (TT14), didn't
                                                // like this AT.
                        return TRUE;
                }
                else
                {
                        return (iModemPauseDialog(pTG, (LPSTR)cbszAT1, sizeof(cbszAT1)-1, ulTimeout, cbszOK)==1);
                }

        }
}












// Does nothing in this driver
BOOL   ModemFlush(PThrdGlbl pTG, HMODEM hModem)
{
        D_PrintDDI("ModemFlush", (USHORT)hModem, 0);
        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        return TRUE;
}

// #if (PAGE_PREAMBLE_DIV != 0)

// length of TCF = 1.5 * bpscode * 100 / 8 == 75 * bpscode / 4
USHORT TCFLen[16] =
{
/* V27_2400             0 */    450,
/* V29_9600             1 */    1800,
/* V27_4800             2 */    900,
/* V29_7200             3 */    1350,
/* V33_14400    4 */    2700,
                                                0,
/* V33_12000    6 */    2250,
                                                0,
/* V17_14400    8 */    2700,
/* V17_9600             9 */    1800,
/* V17_12000    10 */   2250,
/* V17_7200             11 */   1350,
                                                0,
                                                0,
                                                0,
                                                0
};


#define min(x,y)        (((x) < (y)) ? (x) : (y))













void SendZeros1(PThrdGlbl pTG, USHORT uCount)
{
#define         ZERO_BUFSIZE    256
        BYTE    bZero[ZERO_BUFSIZE];
        short   i;              // must be signed

        _fmemset(bZero, 0, ZERO_BUFSIZE);
        for(i=uCount; i>0; i -= ZERO_BUFSIZE)
        {
                // no need to stuff. They're all zeros!
                FComDirectAsyncWrite(pTG, bZero, (UWORD)(min((UWORD)i, (UWORD)ZERO_BUFSIZE)));
        }
        TRACE((SZMOD "Sent %d zeros\r\n", uCount));
}
// #endif //PAGE_PREAMBLE_DIV != 0















BOOL   ModemSendMode(PThrdGlbl pTG, HMODEM hModem, USHORT uMod, BOOL fHDLC, USHORT ifrHint)
{
#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return Class0ModemSendMode(pTG, hModem, fHDLC);
#endif //CL0

        BG_CHK(ifrHint && ifrHint < ifrEND);
        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);

        pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

        pTG->CurrentCommSpeed = T30toSpeed[uMod & 0xF];

        BG_CHK(pTG->Class1Modem.CurMod);

        if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
                pTG->Class1Modem.CurMod++;
        // BG_CHK((pTG->Class1Modem.CurMod>24 && ModemCaps.uSendSpeeds!=V27_V29_V33_V17) ?
        //                      (SpeedtoCap[uMod & 0xF] & ModemCaps.uSendSpeeds) : 1);

        (MyDebugPrint(pTG,  LOG_ALL,  "In ModemSendMode uMod=%d CurMod=%d fHDLC=%d\r\n", uMod, pTG->Class1Modem.CurMod, fHDLC));

        if(uMod == V21_300)
        {
                BG_CHK(pTG->Class1Modem.CurMod == 3);
                _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFTH3);
                pTG->Class1Modem.uCmdLen = sizeof(cbszFTH3)-1;
                pTG->Class1Modem.fHDLC = TRUE;
                FComXon(pTG, FALSE);                 // for safety. _May_ be critical
        }
        else
        {
                pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFTM, pTG->Class1Modem.CurMod);
                pTG->Class1Modem.fHDLC = FALSE;
                FComXon(pTG, TRUE);          // critical!! Start of PhaseC
                // no harm doing it here(i.e before issuing +FTM)

                if(fHDLC)
                {
                        if(!SWFramingSendSetup(pTG, TRUE))
                        {
                                BG_CHK(FALSE);
                                goto error2;
                        }
                }
        }
        FComOutFilterInit(pTG);    // _not_ used for 300bps HDLC
                                                        // but here just in case

        // want to do all the work _before_ issuing command

        pTG->Class1Modem.DriverMode = SEND;
        pTG->Class1Status.ifrHint = ifrHint; // need this before ModemDialog

        if(pTG->Class1Modem.ModemMode == FTH)
        {
                // already in send mode. This happens on Answer only
                BG_CHK(fHDLC && uMod==V21_300);
                BG_CHK(pTG->Class1Modem.CurMod==3 && pTG->Class1Modem.fHDLC == TRUE);
                return TRUE;
        }

#define STARTSENDMODE_TIMEOUT 5000                              // Random Timeout

        //// Try to cut down delay between getting CONNECT and writing the
        // first 00s (else modems can quit because of underrun).
        // Can do this by not sleeping in this. Only in fatal
        // cases will it lock up for too long (max 5secs). In those cases
        // the call is trashed too.

        FComCritical(pTG, TRUE);     // start Crit in ModemSendMode

        if(!iModemNoPauseDialog(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, STARTSENDMODE_TIMEOUT, cbszCONNECT))
        {
                FComCritical(pTG, FALSE);    // end Crit in ModemSendMode
                goto error;
        }

        // can't set this earlier. We'll trash previous value
        pTG->Class1Modem.ModemMode = ((uMod==V21_300) ? FTH : FTM);

        // Turn OFF overlapped I/O if in V.21 else ON
        FComOverlappedIO(pTG, uMod != V21_300);

        if(pTG->Class1Modem.fSendSWFraming)  // set in SWFramingSendSetup
        {
                SWFramingSendPreamble(pTG, pTG->Class1Modem.CurMod);
        }
#if (PAGE_PREAMBLE_DIV != 0)
        else if(pTG->Class1Modem.ModemMode == FTM)
        {
                // don't send 00s if ECM
                BG_CHK(ifrHint==ifrPIX_MH || ifrHint==ifrPIX_MR || ifrHint==ifrTCF);
                BG_CHK(PAGE_PREAMBLE_DIV);
                SendZeros1(pTG, (USHORT)(TCFLen[uMod & 0x0F] / PAGE_PREAMBLE_DIV));
        }
#else
        else if(ifrHint==ifrPIX_MH || ifrHint==ifrPIX_MR)
        {
                // even if MDDI is on need to send some 00s otherwise
                // some modems underrun and hangup
                SendZeros1(pTG, TCFLen[uMod & 0x0F] / 2);
        }
#endif

        // FComDrain(-,FALSE) causes fcom to write out any internally-
        // maintained buffers, but not to drain the comm-driver buffers.
        FComDrain(pTG, TRUE,FALSE);


        FComCritical(pTG, FALSE);    // end Crit in ModemSendMode

        TRACE((SZMOD "Starting Send at %d\r\n", pTG->Class1Modem.CurMod));
        return TRUE;

error:
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        SWFramingSendSetup(pTG, FALSE);
error2:
        FComXon(pTG, FALSE);         // important. Cleanup on error
        EndMode(pTG);
        return FALSE;
}





















BOOL iModemDrain(PThrdGlbl pTG)
{
        (MyDebugPrint(pTG,  LOG_ALL,  "Entering iModemDrain\r\n"));

        if(!FComDrain(pTG, TRUE, TRUE))
                return FALSE;

                // Must turn XON/XOFF off immediately *after* drain, but before we
                // send the next AT command, since recieved frames have 0x13 or
                // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

// increase this---see bug number 495. Must be big enough for
// COM_OUTBUFSIZE to safely drain at 2400bps(300bytes/sec = 0.3bytes/ms)
// let's say (COM_OUTBUFSIZE * 10 / 3) == (COM_OUTBUFSIZE * 4)
// can be quite long, because on failure we just barf anyway

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return TRUE;
#endif //CL0

#define POSTPAGEOK_TIMEOUT (10000L + (((ULONG)COM_OUTBUFSIZE) << 2))

        // Here we were looking for OK only, but some modems (UK Cray Quantun eg)
        // give me an ERROR after sending TCF or a page (at speeds < 9600) even
        // though the page was sent OK. So we were timing out here. Instead look
        // for ERROR (and NO CARRIER too--just in case!), and accept those as OK
        // No point returning ERROR from here, since we just abort. We can't/don't
        // recover from send errors
        // if(!iModemResp1(POSTPAGEOK_TIMEOUT, cbszOK))

        if(iModemResp3(pTG, POSTPAGEOK_TIMEOUT, cbszOK, cbszERROR, cbszNOCARRIER) == 0)
                return FALSE;

                // Must change FlowControl State *after* getting OK because in Windows
                // this call takes 500 ms & resets chips, blows away data etc.
                // So do this *only* when you *know* both RX & TX are empty.
                // check this in all usages of this function

        return TRUE;
}


BOOL iModemSendData(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
        BG_CHK((uFlags & SEND_ENDFRAME) == 0);
        BG_CHK(lpb);
        BG_CHK(!pTG->Class1Modem.fSendSWFraming);

        // if(uFlags & SEND_STUFF)
        {
                // always DLE-stuff here. Sometimes zero-stuff

                (MyDebugPrint(pTG,  LOG_ALL,  "In ModemSendData calling FComFilterAsyncWrite at %ld \n", GetTickCount() ) );

                if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
                        goto error;
        }
/*******
        else
        {
                if(!FComDirectAsyncWrite(pTG, lpb, uCount))
                        goto error;
        }
*******/

        if(uFlags & SEND_FINAL)
        {
                (MyDebugPrint(pTG,  LOG_ALL,  "In ModemSendData calling FComDIRECTAsyncWrite at %ld \n", GetTickCount() ) );

                // if(!FComDirectAsyncWrite(bDLEETXCR, 3))
                if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                        goto error;

                if(!iModemDrain(pTG))
                        goto error;

                FComOutFilterClose(pTG);
            FComOverlappedIO(pTG, FALSE);
                FComXon(pTG, FALSE);         // critical. End of PhaseC
                                                        // must come after Drain
                EndMode(pTG);
        }
        return TRUE;

error:
        FComXon(pTG, FALSE);                 // critical. End of PhaseC (error)
        FComFlush(pTG);                    // clean out the bad stuff if we got an error
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        EndMode(pTG);
        return FALSE;
}























BOOL iModemSendFrame(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
        UWORD   uwResp=0;

        (MyDebugPrint(pTG,  LOG_ALL,  "Entering iModemSendFrame\r\n"));

        BG_CHK(uFlags & SEND_ENDFRAME);
        BG_CHK(lpb && uCount);
        BG_CHK(!pTG->Class1Modem.fSendSWFraming);

        // always DLE-stuff here. Never zero-stuff
        // This is only called for 300bps HDLC
        BG_CHK(pTG->Class1Modem.fHDLC && pTG->Class1Modem.CurMod == 3);

        if(pTG->Class1Modem.ModemMode != FTH)        // Special case on just answering!!
        {
#define FTH_TIMEOUT 5000                                // Random Timeout
                if(!iModemNoPauseDialog(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, FTH_TIMEOUT, cbszCONNECT))
                        goto error;
        }

        // if(uFlags & SEND_STUFF)
        {
                // always DLE-stuff here. Never zero-stuff
                if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEONLY))
                        goto error;
        }
/***
        else
        {
                if(!FComDirectAsyncWrite(pTG, lpb, uCount))
                        goto error;
        }
***/


        // if(uFlags & SEND_STUFF)
        {
                // SyncWrite call Drain here which we should not need
                // as we are immediately waiting for a response
                // if(!FComDirectSyncWrite(bDLEETX, 2))
                //              goto error;

                if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                        goto error;
        }

// 2000 is too short because PPRs can be 32+7 bytes long and
// preamble is 1 sec, so set this to 3000
// 3000 is too short because NSFs and CSIs can be arbitrarily long
// MAXFRAMESIZE is defined in et30type.h. 30ms/byte at 300bps
// async (I think V.21 is syn though), so use N*30+1000+slack

#define WRITEFRAMERESP_TIMEOUT  (1000+30*MAXFRAMESIZE+500)
        if(!(uwResp = iModemResp2(pTG, WRITEFRAMERESP_TIMEOUT, cbszOK, cbszCONNECT)))
                goto error;
        pTG->Class1Modem.ModemMode = ((uwResp == 2) ? FTH : COMMAND);


        if(uFlags & SEND_FINAL)
        {
                FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
                // FComXon(FALSE);      // at 300bps. no Xon-Xoff in use

                // in some weird cases (Practical Peripherals PM14400FXMT) we get
                // CONNECT<cr><lf>OK, but we get the CONNECT here. Should we
                // just set pTG->Class1Modem.ModemMode=COMMAND?? (EndMode does that)
                // Happens on PP 144FXSA also. Ignore it & just set mode to COMMAND
                // BG_CHK(pTG->Class1Modem.ModemMode == COMMAND);
                EndMode(pTG);
        }
        // ST_FRAMES(TRACE((SZMOD "FRAME SENT-->\r\n")); D_PrintFrame(lpb, uCount));
        return TRUE;

error:
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        FComXon(pTG, FALSE);         // just for safety. cleanup on error
        EndMode(pTG);
        return FALSE;
}






















BOOL   ModemSendMem(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT uCount, USHORT uFlags)
{
#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return Class0ModemSendMem(pTG, hModem, lpb, uCount, uFlags);
#endif //CL0

        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        BG_CHK(pTG->Class1Modem.CurMod);
        BG_CHK(lpb);
        (MyDebugPrint(pTG,  LOG_ALL,  "In ModemSendMem lpb=%08lx uCount=%d wFlags=%04x\r\n", lpb, uCount, uFlags));

        if(pTG->Class1Modem.DriverMode != SEND)
        {
                BG_CHK(FALSE);
                return FALSE;
        }

        if(pTG->Class1Modem.fSendSWFraming)
                return SWFramingSendFrame(pTG, lpb, uCount, uFlags);
        else if(pTG->Class1Modem.fHDLC)
                return iModemSendFrame(pTG, lpb, uCount, uFlags);
        else
                return iModemSendData(pTG, lpb, uCount, uFlags);
}
















void TwiddleThumbs(ULONG ulTime);

#ifndef MDRV
void TwiddleThumbs(ULONG ulTime)
{
        MY_TWIDDLETHUMBS(ulTime);
}
#endif //MDRV























BOOL   ModemSendSilence(PThrdGlbl pTG, HMODEM hModem, USHORT uMillisecs, ULONG ulTimeout)
{
        //USHORT uTemp;

        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        (MyDebugPrint(pTG,  LOG_ALL,  "Before ModemSendSilence uMillsecs=%d ulTimeout=%ld at %ld\r\n",
                       uMillisecs, ulTimeout, GetTickCount() ));

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return TRUE;
#endif //CL0

        // we're so slow it seems we don't need to and should not do this
        // I measured teh dealy due to this (FTS=10) to be about 500ms,
        // all of it on our side (dunno why?) except exactly the 100ms
        // by the modem. If we really want to insert teh delay we should
        // use TwiddleThumbs
        // Can't just return here, because we do _need_ the delay between
        // send DCS and send TCF so that receiver is not overwhelmed
        // return TRUE;

        // use TwiddleThumbs
        TwiddleThumbs(uMillisecs);

        (MyDebugPrint(pTG,  LOG_ALL,  "After ModemSendSilence  at %ld\r\n", GetTickCount() ));


        return TRUE;

        // uTemp = wsprintf(pTG->Class1Modem.bCmdBuf, cbszFTS, uMillisecs/10);
        // return (iModemNoPauseDialog((LPB)pTG->Class1Modem.bCmdBuf, uTemp, ulTimeout, cbszOK) == 1);
}






















BOOL   ModemRecvSilence(PThrdGlbl pTG, HMODEM hModem, USHORT uMillisecs, ULONG ulTimeout)
{
        // USHORT  uTemp;
        // CBPSTR  cbpstr;

        D_PrintDDI("RecvSilence", (USHORT)hModem, uMillisecs);
        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        (MyDebugPrint(pTG,  LOG_ALL,  "Before ModemRecvSilence uMillsecs=%d ulTimeout=%ld  at %ld \r\n",
                   uMillisecs, ulTimeout, GetTickCount() ));

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return TRUE;
#endif //CL0

        // can't use AT+FRS -- see above for why. Basically, we take so long
        // sending the command and getting teh reply etc, that we can't use
        // it accurately. So use TwiddleThumbs.

        TwiddleThumbs(uMillisecs);

        (MyDebugPrint(pTG,  LOG_ALL,  "After ModemRecvSilence at %ld \r\n", GetTickCount() ));

        return TRUE;

        // uTemp = wsprintf(pTG->Class1Modem.bCmdBuf, cbpstr, uMillisecs/10);
        // return (iModemNoPauseDialog((LPB)pTG->Class1Modem.bCmdBuf, uTemp, ulTimeout, cbszOK)==1);
}





#define MINRECVMODETIMEOUT      500
#define RECVMODEPAUSE           200




















USHORT   ModemRecvMode(PThrdGlbl pTG, HMODEM hModem, USHORT uMod, BOOL fHDLC, ULONG ulTimeout, USHORT ifrHint)
{
        USHORT  uRet;
        ULONG ulBefore, ulAfter, ulDelta;

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return Class0ModemRecvMode(pTG, hModem, fHDLC, ulTimeout);
#endif //CL0

        // Here we should watch for a different modulation scheme from what we expect.
        // Modems are supposed to return a +FCERROR code to indicate this condition,
        // but I have not seen it from any modem yet, so we just scan for ERROR
        // (this will catch +FCERROR too since iiModemDialog does not expect whole
        // words or anything like that!), and treat both the same.

        pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

        pTG->CurrentCommSpeed = T30toSpeed[uMod & 0xF];

        BG_CHK(pTG->Class1Modem.CurMod);
        if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
                pTG->Class1Modem.CurMod++;

        if(uMod == V21_300)
        {
                BG_CHK(fHDLC && pTG->Class1Modem.CurMod==3);
                _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFRH3);
                pTG->Class1Modem.uCmdLen = sizeof(cbszFRH3)-1;
        }
        else
        {
                pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFRM, pTG->Class1Modem.CurMod);
        }

        pTG->Class1Status.ifrHint = ifrHint; // need this before ModemDialog

        if(pTG->Class1Modem.ModemMode == FRH)
        {
                // already in receive mode. This happens upon Dial only
                BG_CHK(fHDLC && uMod==V21_300);
                BG_CHK(pTG->Class1Modem.CurMod == 3);

                pTG->Class1Modem.fHDLC = TRUE;
                pTG->Class1Modem.DriverMode = RECV;
                pTG->Class1Modem.fRecvNotStarted = TRUE;     // fNoFlags = FALSE;
                // pTG->Class1Modem.sRecvBufSize = sBufSize;
                FComInFilterInit(pTG);
                return RECV_OK;
        }


#ifdef WIN32
        // On Win32, we have a problem going into 2400baud recv.
        // +++ remember to put this into iModemFRHorM when that code is enabled.
        if (pTG->Class1Modem.CurMod==24) TwiddleThumbs(80);
#endif // WIN32

#ifdef USR_HACK
        uRet = iModemFRHorM(pTG, ulTimeout);
#else // !USR_HACK (iModemFRHorM contains the following code..)
retry:

        ulBefore=GetTickCount();
        // Don't look for NO CARRIER. Want it to retry until FRM timeout on NO CARRIER
        // ----This is changed. See below----
        uRet = iModemNoPauseDialog3(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR, cbszNOCARRIER);
        // uRet = iModemNoPauseDialog2(pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR);
        ulAfter=GetTickCount();

        if(uRet==2 || uRet==3)  // uRet==FCERROR or uRet==NOCARRIER
        {
                ulDelta = (ulAfter >= ulBefore) ? (ulAfter - ulBefore) : (0xFFFFFFFFL - ulBefore) + ulAfter;

                if(ulTimeout < (ulDelta + MINRECVMODETIMEOUT))
                {
                        ERRMSG((SZMOD "<<WARNING>> Giving up on RecvMode. uRet=%d ulTimeout=%ld\r\n", uRet, ulTimeout));
                }
                else
                {
                        ulTimeout -= (ulAfter-ulBefore);

                        // need this pause for NO CARRIER for USR modems. See bug#1516
                        // for the RC229DP, dunno if it's reqd because I dunno why theyre
                        // giving the FCERROR. Don't want to miss the carrier so currently
                        // don't pause. (Maybe we can achieve same effect by simply taking
                        // FCERROR out of the response list above--but that won't work for
                        // NOCARRIER because we _need_ teh pause. iiModemDialog is too fast)
                        if(uRet == 3)
                                TwiddleThumbs(RECVMODEPAUSE);
                        BG_CHK(ulTimeout >= MINRECVMODETIMEOUT);

                        goto retry;
                }
        }
#endif // !USR_HACK

        (MyDebugPrint(pTG,  LOG_ALL,  "Ex ModemRecvMode uMod=%d CurMod=%d fHDLC=%d ulTimeout=%ld: Got=%d\r\n", uMod, pTG->Class1Modem.CurMod, fHDLC, ulTimeout, uRet));
        if(uRet != 1)
        {
                EndMode(pTG);
                if(uRet == 2)
                {
                        ERRMSG((SZMOD "<<WARNING>> RecvMode:: Got FCERROR after %ldms\r\n", ulAfter-ulBefore));
                        return RECV_WRONGMODE;  // need to return quickly
                }
                else
                {
                        BG_CHK(uRet == 0);
                        ERRMSG((SZMOD "<<WARNING>> RecvMode:: Got Timeout after %ldms\r\n", ulAfter-ulBefore));
                        return RECV_TIMEOUT;
                }
        }

        BG_CHK(ifrHint && ifrHint < ifrEND);
        IF_BG_CHK(hModem==HMODEM_3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        BG_CHK(pTG->Class1Modem.CurMod);
        // BG_CHK((pTG->Class1Modem.CurMod>24 && ModemCaps.uRecvSpeeds!=V27_V29_V33_V17) ?
        //                      (SpeedtoCap[uMod & 0xF] & ModemCaps.uRecvSpeeds) : 1);

        if(uMod==V21_300)
        {
                pTG->Class1Modem.ModemMode = FRH;
                pTG->Class1Modem.fHDLC = TRUE;
        }
        else
        {
                pTG->Class1Modem.ModemMode = FRM;
                pTG->Class1Modem.fHDLC = FALSE;
                if(fHDLC)
                {
                        if(!SWFramingRecvSetup(pTG, TRUE))
                        {
                                BG_CHK(FALSE);
                                EndMode(pTG);
                                return RECV_ERROR;
                        }
                }
        }
        // pTG->Class1Modem.sRecvBufSize = sBufSize;
        pTG->Class1Modem.DriverMode = RECV;
        pTG->Class1Modem.fRecvNotStarted = TRUE;     // fNoFlags = FALSE;
        FComInFilterInit(pTG);
        TRACE((SZMOD "Starting Recv at %d\r\n", pTG->Class1Modem.CurMod));
        return RECV_OK;
}








#ifdef CL0
void   ModemEndRecv(PThrdGlbl pTG, HMODEM hModem)
{
#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                Class0ModemEndRecv(pTG, hModem);
#endif //CL0
}
#endif //CL0
























USHORT iModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
        SWORD   swEOF;
        USHORT  uRet;

        BG_CHK(pTG->Class1Modem.ModemMode == FRM);
        BG_CHK(lpb && cbMax && lpcbRecv);
        BG_CHK(!pTG->Class1Modem.fRecvSWFraming);

        startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
        // 4th arg must be FALSE for Class1
        *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv), FALSE, &swEOF);
        if(swEOF == -1)
        {
                // we got a DLE-ETX _not_ followed by OK or NO CARRIER. So now
                // we have to decide whether to (a) declare end of page (swEOF=1)
                // or (b) ignore it & assume page continues on (swEOF=0).
                //
                // The problem is that some modems produce spurious EOL during a page
                // I believe this happens due a momentary loss of carrier that they
                // recover from. For example IFAX sending to the ATI 19200. In those
                // cases we want to do (b). The opposite problem is that we'll run
                // into a modem whose normal response is other than OK or NO CARRIER.
                // Then we want to do (a) because otherwise we'll _never_ work with
                // that modem.
                //
                // So we have to either do (a) always, or have an INI setting that
                // can force (a), which could be set thru the AWMODEM.INF file. But
                // we also want to do (b) if possible because otehrwise we'll not be
                // able to recieve from weak or flaky modems or machines or whatever
                //
                // Snowball does (b). I believe best soln is an INI setting, with (b)
                // as default

                // option (a)
                // ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Assuming END OF PAGE!!!\r\n"));
                // swEOF = 1;

                // option (b)
                ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Ignoring\r\n"));
                swEOF = 0;
        }
        BG_CHK(swEOF == 0 || swEOF == 1 || swEOF == -2 || swEOF == -3);

        switch(swEOF)
        {
        case 1:         uRet = RECV_EOF; break;
        case 0:         return RECV_OK;
        default:        BG_CHK(FALSE);  // fall through
        case -2:        uRet = RECV_ERROR; break;
        case -3:        uRet = RECV_TIMEOUT; break;
        }

        EndMode(pTG);
        return uRet;
}


const static BYTE LFCRETXDLE[4] = { LF, CR, ETX, DLE };























USHORT iModemRecvFrame(PThrdGlbl pTG, LPB lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
        SWORD swRead, swRet;
        USHORT i;
        BOOL fRestarted=0;
        USHORT uRet;
        BOOL fGotGoodCRC = 0;   // see comment-block below

        /** Sometimes modems give use ERROR even when thr frame is good.
                Happens a lot from Thought to PP144MT on CFR. So we check
                the CRC. If the CRc was good and everything else looks good
                _except_ the "ERROR" response from teh modem then return
                RECV_OK, not RECV_BADFRAME.
                This should fix BUG#1218
        **/

        BG_CHK(lpb && cbMax && lpcbRecv);
restart:
        *lpcbRecv=0;
        if(pTG->Class1Modem.ModemMode!= FRH)
        {
#ifdef USR_HACK
                swRet = iModemFRHorM(pTG, ulTimeout);
#else // !USR_HACK
                swRet=iModemNoPauseDialog2(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszNOCARRIER);
#endif // !USR_HACK
                if(swRet==2||swRet==3)
                {
                        (MyDebugPrint(pTG,  LOG_ALL,  "Got NO CARRIER from FRH=3\r\n"));
                        EndMode(pTG);
                        return RECV_EOF;
                }
                else if(swRet != 1)
                {
                        ERRMSG((SZMOD "<<WARNING>> Can't get CONNECT from FRH=3\r\n"));
                        EndMode(pTG);
                        return RECV_TIMEOUT;    // may not need this, since we never got flags??
                        // actually we dont know what the heck we got!!
                }
        }


        pTG->Class1Modem.fRecvNotStarted = FALSE;    // fNoFlags = FALSE;

        /*** Got CONNECT (i.e. flags). Now try to get a frame ***/

        /****************************************************************
         * Using 3 secs here is a misinterpretation of the T30 CommandReceived?
         * flowchart. WE want to wait here until we get something or until T2
         * or T4 timeout. It would have been best if we started T2 ot T4 on
         * entry into the search routine (t30.c), but starting it here is good
         * enough.
         * Using this 3secs timeout fails when Genoa simulates a bad frame
         * because Zoom PKT modem gives us a whole raft of bad frames for one
         * bad PPS-EOP and then gives a CONNECT that we timeout below exactly
         * as the sender's T4 timeout expires and he re-sends the PPS-EOP
         * so we miss all of them.
         * Alternately, we could timeout here on 2sec & retry. But that's risky
         * If less than 2sec then we'll timeout on modems that give connect
         * first flag, then 2sec elapse before CR-LF (1sec preamble & 1sec for
         * long frames, e.g. PPR!)
         ****************************************************************/

        // #define TIMEOUT_3SECS        3000L
        // startTimeOut(&(pTG->Class1Modem.toRecv), TIMEOUT_3SECS);

        startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
        swRead = FComFilterReadLine(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv));

        pTG->Class1Modem.ModemMode = COMMAND;
        // may change this to FRH if we get CONNECT later.
        // but set it here just in case we short circuit out due to errors


        if(swRead<=0)
        {
                // Timeout
                ERRMSG((SZMOD "<<WARNING>> Can't get frame after connect. Got-->\r\n"));
                D_HexPrint(lpb, (WORD)-swRead);
                EndMode(pTG);
                *lpcbRecv = -swRead;
                return RECV_ERROR;              // goto error;
        }

        faxT2log(("FRAME>>> \r\n"));
        ST_FRAMES(D_HexPrint(lpb, swRead));


        for(i=0, swRead--; i<4 && swRead>=0; i++, swRead--)
        {
                if(lpb[swRead] != LFCRETXDLE[i])
                        break;
        }
        // exits when swRead is pointing to last non-noise char
        // or swRead == -1
        // incr by 1 to give actual non-noise data size.
        // (size = ptr to last byte + 1!)
        swRead++;


        // Hack for AT&T AK144 modem that doesn't send us the CRC
        // only lop off last 2 bytes IFF the frame is >= 5 bytes long
        // that will leave us at least the FF 03/13 FCF
        // if(i==4 && swRead>=2)        // i.e. found all of DLE-ETX_CR-LF

   // 09/25/95 This code was changed to never lop of the CRC.
   // All of the routines except NSxtoBC can figure out the correct length,
   // and that way if the modem doesn't pass on the CRC, we no longer
   // lop off the data.
   // NSxtoBC has been changed to expect the CRC.

        // we really want this CRC-checking in the MDDI case too
// #ifdef MDDI
//      if(i==4 && swRead>=5)   // i.e. found all of DLE-ETX_CR-LF
//      {
//              swRead -= 2;            // get rid of CRC
//              uRet = RECV_OK;
//      }
// #else //MDDI
        if(i==4)                                // i.e. found all of DLE-ETX_CR-LF
        {
                // Determine if the frame has the CRC or not..
                // (AT&T and NEC modems don't have them)
                if (pTG->Class1Modem.eRecvFCS != RECV_FCS_NO)
                {
                        if (swRead > 2)
                        {

#ifdef PORTABLE_CODE
                                WORD wCRCgot = *(UNALIGNED WORD FAR*)(lpb+swRead-2); // +++alignment
#else
                                WORD wCRCgot = *(LPWORD)(lpb+swRead-2); // +++alignment
#endif
                            WORD wCRCcalc;

// Elliot bug 1811: TI PCMCIA modem TI1411 sends control byte twice
// instead of address (0xff) followed by control.
// So we correct for that here...
                                if  (lpb[0]==lpb[1] && (*lpb==0x3 || *lpb==0x13))
                                {
                                        ERRMSG((SZMOD
                                        "<<WARNING>> V.21 w/ wrong address:%04x.\r\n"
                                        "\t\tZapping 1st byte with 0xff.\r\n",
                                                (unsigned)*lpb));
                                        *lpb = 0xff;
                                }

                            wCRCcalc = CalcCRC(pTG, lpb, (USHORT) (swRead-2));
                            if  (wCRCgot==wCRCcalc)
                            {
//                                      swRead -=2;
                                        fGotGoodCRC = TRUE;
                            }
                            else
                            {
#define MUNGECRC(crc) MAKEWORD(LOBYTE(crc),\
                                                        (HIBYTE(crc)<<2)|(LOBYTE(crc)>>6))
                                        ERRMSG((SZMOD
                                                "<<WARNING>> V.21 CRC mismatch. Got 0x%04x."
                                                                                                                        " Want 0x%04x\r\n",
                                                (unsigned) wCRCgot, (unsigned) wCRCcalc ));
                                        // MC1411, MH9611 hack...
                                        if (wCRCgot == MUNGECRC(wCRCcalc))
                                        {
                                        ERRMSG((SZMOD
                                                        "<<WARNING>> mutant V.21 CRC:%04x\r\n",
                                                                        MUNGECRC(wCRCcalc)));
//                                              swRead -=2;
                                                fGotGoodCRC = TRUE;
                                        }
// Elliot bug 2659: PP PM288MT II V.34 adds a flag (0x7e) to the END
// Of every V.21 flag it receives! So we check for this special case.
                                        else if (swRead>3 && *(lpb+swRead-1)==0x7e)
                                        {
                                        ERRMSG((SZMOD
                                                        "<<WARNING>> Last byte == 0x7e\r\n"));

#ifdef PORTABLE_CODE
                                                wCRCgot = *(UNALIGNED WORD FAR*)(lpb+swRead-3);
#else
                                                wCRCgot = *(LPWORD)(lpb+swRead-3);
#endif
                                                wCRCcalc = CalcCRC(pTG, lpb, (USHORT) (swRead-3));
                                        ERRMSG((SZMOD
                                                        "<<WARNING>> Final flag? New Calc:%04x;Got=%04x\r\n",
                                                                        (unsigned) wCRCcalc,
                                                                        (unsigned) wCRCgot));
                                                if (wCRCgot==wCRCcalc)
                                                {
//                                                      swRead -=3;
                     swRead--;
                                                        fGotGoodCRC = TRUE;
                                                }
                                        }
                                        else if (pTG->Class1Modem.eRecvFCS == RECV_FCS_NOCHK)
                                        {
                                        ERRMSG((SZMOD
                                                        "<<WARNING>> ASSUMING BAD V.21 CRC\r\n"));
//                                              swRead -=2;
                                        }
                                        else
                                        {
                                        ERRMSG((SZMOD
                                                        "<<WARNING>> no/bad V.21 CRC\r\n"));
                                        }
                            }
                        }
                }

                uRet = RECV_OK;
        }
// #endif //MDDI
        else
        {
                ERRMSG((SZMOD "<<WARNING>> Frame doesn't end in dle-etx-cr-lf\r\n"));
                // leave tast two bytes in. We don't *know* it's a CRC, since
                // frame ending was non-standard
                uRet = RECV_BADFRAME;
        }
        *lpcbRecv = swRead;

        // check if it is the NULL frame (i.e. DLE-ETX-CR-LF) first.
        // (check is: swRead==0 and uRet==RECV_OK (see above))
        // if so AND if we get OK or CONNECT or ERROR below then ignore
        // it completely. The Thought modem and the PP144MT generate
        // this poor situation! Keep a flag to avoid a possible
        // endless loop

        // broaden this so that we Restart on either a dle-etx-cr-lf
        // NULL frame or a simple cr-lf NULL frame. But then we need
        // to return an ERROR (not BADFRAME) after restarting once,
        // otheriwse there is an infinite loop with T30 calling us
        // again and again (see bug#834)

        // chnage yet again. This takes too long, and were trying to tackle
        // a specific bug (the PP144MT) bug here, so let's retsrat only
        // on dle-etx-cr-lf (not just cr-lf), and in teh latter case
        // return a response according to what we get


        BG_CHK(uRet==RECV_OK || uRet==RECV_BADFRAME);

        /*** Got Frame. Now try to get OK or ERROR. Timeout=0! ***/

        switch(swRet = iModemResp4(pTG, 0, cbszOK, cbszCONNECT, cbszNOCARRIER, cbszERROR))
        {
        case 2: pTG->Class1Modem.ModemMode = FRH;
                        // fall through and do exactly like OK!!
        case 1: // ModemMode already == COMMAND
                        if(swRead<=0 && uRet==RECV_OK && !fRestarted)
                        {
                                ERRMSG((SZMOD "<<WARNING>> Got %d after frame. RESTARTING\r\n", swRet));
                                fRestarted = 1;
                                goto restart;
                        }
                        //uRet already set
                        break;

        case 3: // NO CARRIER. If got null-frame or no frame return
                        // RECV_EOF. Otherwise if got OK frame then return RECV_OK
                        // and return frame as usual. Next time around it'll get a
                        // NO CARRIER again (hopefully) or timeout. On a bad frame
                        // we can return RECV_EOF, but this will get into trouble if
                        // the recv is not actually done. Or return BADFRAME, and hope
                        // for a NO CARRIER again next time. But next time we may get a
                        // timeout. ModemMode is always set to COMMAND (already)
                        ERRMSG((SZMOD "<<WARNING>> Got NO CARRIER after frame. swRead=%d uRet=%d\r\n", swRead, uRet));
                        if(swRead <= 0)
                                uRet = RECV_EOF;
                        // else uRet is already BADFRAME or OK
                        break;

                        // this is bad!!
                        // alternately:
                        // if(swRead<=0 || uRet==RECV_BADFRAME)
                        // {
                        //              uRet = RECV_EOF;
                        //              *lpcbRecv = 0;          // must return 0 bytes with RECV_EOF
                        // }

        case 4: // ERROR
                        if(swRead<=0)
                        {
                                // got no frame
                                if(uRet==RECV_OK && !fRestarted)
                                {
                                        // if we got dle-etx-cr-lf for first time
                                        ERRMSG((SZMOD "<<WARNING>> Got ERROR after frame. RESTARTING\r\n"));
                                        fRestarted = 1;
#ifdef USR_HACK
                                        TwiddleThumbs(RECVMODEPAUSE);
#endif //USR_HACK
                                        goto restart;
                                }
                                else
                                        uRet = RECV_ERROR;
                        }
                        else
                        {
                                // if everything was OK until we got the "ERROR" response from
                                // the modem and we got a good CRC then treat it as "OK"
                                // This should fix BUG#1218
                                if(uRet==RECV_OK && fGotGoodCRC)
                                        uRet = RECV_OK;
                                else
                                        uRet = RECV_BADFRAME;
                        }

                        ERRMSG((SZMOD "<<WARNING>> Got ERROR after frame. swRead=%d uRet=%d\r\n", swRead, uRet));
                        break;

        case 0: // timeout
                        ERRMSG((SZMOD "<<WARNING>> Got TIMEOUT after frame. swRead=%d uRet=%d\r\n", swRead, uRet));
                        // if everything was OK until we got the timeout from
                        // the modem and we got a good CRC then treat it as "OK"
                        // This should fix BUG#1218
                        if(uRet==RECV_OK && fGotGoodCRC)
                                uRet = RECV_OK;
                        else
                                uRet = RECV_BADFRAME;
                        break;
        }
        return uRet;
}





























USHORT   ModemRecvMem(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
        USHORT uRet;

#ifdef CL0
        if(pTG->ModemParams.Class == FAXCLASS0)
                return Class0ModemRecvMem(pTG, hModem, lpb, cbMax, ulTimeout, lpcbRecv);
#endif //CL0

        IF_BG_CHK((WORD)hModem==3 && pTG->DDI.uComPort && pTG->DDI.fModemOpen && pTG->DDI.fLineInUse && pTG->DDI.fNCUModemLinked);
        BG_CHK(pTG->Class1Modem.CurMod);
        BG_CHK(lpb && cbMax && lpcbRecv);
        (MyDebugPrint(pTG,  LOG_ALL,  "In ModemRecvMem lpb=%08lx cbMax=%d ulTimeout=%ld\r\n", lpb, cbMax, ulTimeout));

        if(pTG->Class1Modem.DriverMode != RECV)
        {
                BG_CHK(FALSE);
                return RECV_ERROR;      // see bug#1492
        }
        *lpcbRecv=0;

        if(pTG->Class1Modem.fRecvSWFraming)
                uRet = SWFramingRecvFrame(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
        else if(pTG->Class1Modem.fHDLC)
                uRet = iModemRecvFrame(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
        else
                uRet = iModemRecvData(pTG, lpb, cbMax, ulTimeout, lpcbRecv);

        (MyDebugPrint(pTG,  LOG_ALL,  "Ex ModemRecvMem lpbf=%08lx uCount=%d uRet=%d\r\n", lpb, *lpcbRecv, uRet));
        return uRet;
}






















#ifdef USR_HACK
USHORT iModemFRHorM(PThrdGlbl pTG, ULONG ulTimeout)
{
        ULONG   ulBefore, ulAfter, ulDelta;
        USHORT uRet;

retry:

        ulBefore=GetTickCount();

        // Don't look for NO CARRIER. Want it to retry until FRM timeout on NO CARRIER
        // ----This is changed. See below----
        uRet = iModemNoPauseDialog3(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR, cbszNOCARRIER);
        // uRet = iModemNoPauseDialog2(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR);
        ulAfter=GetTickCount();

        if(uRet==2 || uRet==3)  // uRet==FCERROR or uRet==NOCARRIER
        {
                ulDelta = (ulAfter >= ulBefore) ? (ulAfter - ulBefore) : (0xFFFFFFFFL - ulBefore) + ulAfter;

                if(ulTimeout < (ulDelta + MINRECVMODETIMEOUT))
                {
                        ERRMSG((SZMOD "<<WARNING>> Giving up on RecvMode. uRet=%d ulTimeout=%ld\r\n", uRet, ulTimeout));
                }
                else
                {
                        ulTimeout -= (ulAfter-ulBefore);

                        // need this pause for NO CARRIER for USR modems. See bug#1516
                        // for the RC229DP, dunno if it's reqd because I dunno why theyre
                        // giving the FCERROR. Don't want to miss the carrier so currently
                        // don't pause. (Maybe we can achieve same effect by simply taking
                        // FCERROR out of the response list above--but that won't work for
                        // NOCARRIER because we _need_ teh pause. iiModemDialog is too fast)
                        if(uRet == 3)
                                TwiddleThumbs(RECVMODEPAUSE);
                        BG_CHK(ulTimeout >= MINRECVMODETIMEOUT);

                        goto retry;
                }
        }

        return uRet;
}
#endif // USR_HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\debug.h ===
#define	SZMOD			"Class1: "

#ifdef DEBUG
	extern DBGPARAM dpCurSettings;
#endif

#define ZONE_DDI		((1L << 0) & dpCurSettings.ulZoneMask)
#define ZONE_FRAMES		((1L << 1) & dpCurSettings.ulZoneMask)
#define ZONE_CLASS0		((1L << 4) & dpCurSettings.ulZoneMask)

#define ZONE_SWFRAME	((1L << 10) & dpCurSettings.ulZoneMask)
#define ZONE_SWFRAME2	((1L << 11) & dpCurSettings.ulZoneMask)


#ifdef DEBUG
#	define ST_FRAMES(x)	if(ZONE_FRAMES) { x; }
#else
#	define ST_FRAMES(x)	{ }
#endif

#ifdef MDDI
#		define	IF_BG_CHK(x)		BG_CHK(x)
#		define	faxIFlog(x)			faxTlog(x)
#else
#		define	IF_BG_CHK(x)
#		define	faxIFlog(x)
#endif

#if defined(DEBUG)  && defined(MDDI)
	extern void D_PrintDDI(LPSTR lpsz, USHORT, USHORT);
#else //DEBUG && MDDI
#	define D_PrintDDI(lpsz, u, v)
#endif //DEBUG && MDDI


#define TRACE(m)	DEBUGMSG(1, m)

#define MODID		MODID_MODEMDRV

#define FILEID_DDI		1
#define FILEID_CRC		2
#define FILEID_DECODER	3
#define FILEID_ENCODER	4
#define FILEID_FRAMING	5
#define FILEID_IFDDI	6
#define FILEID_CLASS0	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\decoder.h ===
/***************************************************************************
 Name     :     DECODER.H
 Comment  :     HDLC decoding structs

        Copyright (c) Microsoft Corp. 1991 1992 1993

***************************************************************************/

#ifdef WIN32
#       define CODEBASED
#else
#       define CODEBASED        __based(__segname("_CODE"))
#endif

#ifdef SWECM
#       define SWECMEXP _export FAR PASCAL
#else
#       define SWECMEXP
#endif




USHORT SWECMEXP HDLC_Decode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, USHORT far* lpcbDst, LPDECODESTATE lpState);
#define InitDecoder(pTG, State)      { State.carry=State.dec_width=State.len=0; State.flagabort=NORMAL; }


/***------------------ also prototype from crc.c --------------------***/

WORD SWECMEXP CalcCRC(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\decoder.c ===
/***************************************************************************
 Name     :     DECODER.C
 Comment  :     HDLC decoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------

***************************************************************************/


#include "prep.h"


#include "decoder.h"
#include "debug.h"


#include "glbproto.h"



#define FILEID                  FILEID_DECODER

extern  BYTE CODEBASED DecLen[8][256], CODEBASED DecOut[8][256], CODEBASED DecWidth[8][256];





USHORT SWECMEXP HDLC_Decode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, USHORT far* lpcbDst, LPDECODESTATE lpState)
{

   BYTE FlagAbort = lpState->flagabort != FALSE;

#ifdef PORTABLE_CODE
   BYTE StateLen = lpState->len;
   BYTE StateWidth = lpState->dec_width;
   USHORT SrcSize;
   BYTE InByte;
   LPBYTE CurrentSrc = lpbSrc;
   LPBYTE CurrentDst = lpbDst;
   USHORT ProcessWord = (USHORT) lpState->carry;      //carry-in at the start of each loop iteration
   BYTE TmpLen;
   USHORT ExitLoop = FALSE;

#ifdef CLASS1_TEST_HOOKS
   BYTE TstlpbDst[512];
   DECODESTATE TstState;
   LPDECODESTATE TstlpState = &TstState;
   USHORT TstcbSrc;
   USHORT TstcbDst;
   USHORT *TstlpcbDst = &TstcbDst;
   USHORT i;
   USHORT BadFlag = FALSE;
   CurrentDst = TstlpbDst;
#endif //CLASS1_TEST_HOOKS

        // Processes input bytes until flag, abort or idle or cbSrc
        // Returns number of bytes written to lpbDst in *lpcbDst
        // Return value is number of bytes read
        // Returns reason in lpState->flagabort


   for (SrcSize = cbSrc;((SrcSize > 0) && !ExitLoop); SrcSize--) {
      InByte = *CurrentSrc++;
      ProcessWord |=   (((USHORT) DecOut[StateLen][InByte]) << StateWidth);  //Processed Inbyte Leftshift width or carryin
      StateWidth += DecWidth[StateLen][InByte];
      TmpLen = DecLen[StateLen][InByte];
      if ( TmpLen < 8)  {                 //Normal Case
         StateLen = TmpLen;
         if (StateWidth >= 8) {
            *CurrentDst++ = LOBYTE(ProcessWord);
            ProcessWord >>= 8;
            FlagAbort = 0;
            StateWidth -= 8;
         }
      }
      else {                                     //GotFlagAbort
         ProcessWord = (USHORT) DecOut[StateLen][InByte];
         StateWidth = DecWidth[StateLen][InByte];
         StateLen = TmpLen & 0x3f;
         switch (TmpLen & 0xc0) {
         case 0x40:
            if (FlagAbort != ABORT) {
               FlagAbort = ABORT;
               ExitLoop = TRUE;
            }
            break;
         case 0x80:
            if (StateWidth > 8) {
               DebugBreak();
               // ERRMSG((SZMOD "<<ERROR>> AssertFailed in decoder.c\r\n"));
                    BG_CHK(FALSE);
            }
            else {
               if (FlagAbort != FLAG) {
                  FlagAbort = FLAG;
                  ExitLoop = TRUE;
               }
            }
            break;
         default:
                // only time 0x40 and 0x80 are together is when inlen=7 and inbyte=0x7E.
            DebugBreak();
            // ERRMSG((SZMOD "<<ERROR>> AssertFailed in decoder.c\r\n"));
                 BG_CHK(FALSE);
            break;
         }
      }
   }

#ifdef CLASS1_TEST_HOOKS
   TstlpState->carry = LOBYTE(ProcessWord);
   TstlpState->dec_width = StateWidth;
   TstlpState->len = StateLen;
   TstlpState->flagabort = FlagAbort;
   *TstlpcbDst = CurrentDst - TstlpbDst;
   TstcbSrc = CurrentSrc - lpbSrc;
#else
   lpState->carry = LOBYTE(ProcessWord);
   lpState->dec_width = StateWidth;
   lpState->len = StateLen;
   lpState->flagabort = FlagAbort;
   *lpcbDst = (USHORT)(CurrentDst - lpbDst);
   cbSrc = (USHORT)(CurrentSrc - lpbSrc);
#endif
#endif //PORTABLE_CODE


#ifdef  CLASS1_TEST_HOOKS
for (i = 0; (i < *lpcbDst) && !BadFlag; i++) {
   if (lpbDst[i] != TstlpbDst[i]) {
      BadFlag = TRUE;
   }
}

if (BadFlag || (cbSrc != TstcbSrc) || (*TstlpcbDst != *lpcbDst) || (lpState->carry != TstlpState->carry) || (lpState->len != TstlpState->len) ||
   (lpState->dec_width != TstlpState->dec_width) || lpState->flagabort != TstlpState->flagabort ){
   ERRORMSG(("HDLC_Decode: Assembly Decode != C Decode\n"));
   DebugBreak();
}
#endif //CLASS1_TEST_HOOKS

        return cbSrc;

#if !defined(PORTABLE_CODE) || defined(CLASS1_TEST_HOOKS)
AssertFail:
#ifndef WIN32
        _asm    pop             ds
#endif
        _asm int 3
        // ERRMSG((SZMOD "<<ERROR>> AssertFailed in decoder.c\r\n"));
        BG_CHK(FALSE);
#endif // !defined(PORTABLE_CODE) || defined(CLASS1_TEST_HOOKS)
}


BYTE CODEBASED DecLen[8][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 130,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 66,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 131, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 3
{0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65,
 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 66, 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 66,
 3, 3, 3, 3, 3, 3, 3, 131, 3, 3, 3, 3, 3, 3, 3, 67, 4, 4, 4, 4, 4, 4, 4, 132, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 4
{0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 128, 64,
 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65,
 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65,
 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66,
 3, 3, 3, 131, 3, 3, 3, 67, 3, 3, 3, 131, 3, 3, 3, 67, 4, 4, 4, 132, 4, 4, 4, 68, 5, 5, 5, 133, 6, 6, 7, 71 },
// Input Len = 5
{0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 128, 64,
 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65,
 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65,
 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66,
 3, 131, 3, 67, 3, 131, 3, 67, 3, 131, 3, 67, 3, 131, 3, 67, 4, 132, 4, 68, 4, 132, 4, 68, 5, 133, 5, 69, 6, 134, 7, 71 },
// Input Len = 6
{128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65,
 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65,
 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66,
 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 132, 68, 132, 68, 132, 68, 132, 68, 133, 69, 133, 69, 134, 70, 135, 71 },
// Input Len = 7
{64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 71, 71 }
}; // Len


BYTE CODEBASED DecOut[8][256] = {
// Input Len = 0
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x3f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x5f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x01,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x7f,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 1
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x1f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x2f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x01,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x3f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x4f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x02,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0x5f,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0x6f,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x03,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x7f,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 2
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x00,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x0f, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x17, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x01,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x1f, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x27, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x02,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x2f, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x02,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x37, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x03,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x3f, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x47, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x04,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x4f, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x04,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0x57, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0x05,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0x5f, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0x67, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0x06,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0x6f, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x06,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0x77, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x07,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x7f, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 3
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x08, 0x09, 0x0a, 0x07, 0x0c, 0x0d, 0x0e, 0x00,
 0x10, 0x11, 0x12, 0x0b, 0x14, 0x15, 0x16, 0x01, 0x18, 0x19, 0x1a, 0x0f, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x13, 0x24, 0x25, 0x26, 0x02, 0x28, 0x29, 0x2a, 0x17, 0x2c, 0x2d, 0x2e, 0x02,
 0x30, 0x31, 0x32, 0x1b, 0x34, 0x35, 0x36, 0x03, 0x38, 0x39, 0x3a, 0x1f, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x23, 0x44, 0x45, 0x46, 0x04, 0x48, 0x49, 0x4a, 0x27, 0x4c, 0x4d, 0x4e, 0x04,
 0x50, 0x51, 0x52, 0x2b, 0x54, 0x55, 0x56, 0x05, 0x58, 0x59, 0x5a, 0x2f, 0x5c, 0x5d, 0x5e, 0x02,
 0x60, 0x61, 0x62, 0x33, 0x64, 0x65, 0x66, 0x06, 0x68, 0x69, 0x6a, 0x37, 0x6c, 0x6d, 0x6e, 0x06,
 0x70, 0x71, 0x72, 0x3b, 0x74, 0x75, 0x76, 0x07, 0x78, 0x79, 0x7a, 0x3f, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x43, 0x84, 0x85, 0x86, 0x08, 0x88, 0x89, 0x8a, 0x47, 0x8c, 0x8d, 0x8e, 0x08,
 0x90, 0x91, 0x92, 0x4b, 0x94, 0x95, 0x96, 0x09, 0x98, 0x99, 0x9a, 0x4f, 0x9c, 0x9d, 0x9e, 0x04,
 0xa0, 0xa1, 0xa2, 0x53, 0xa4, 0xa5, 0xa6, 0x0a, 0xa8, 0xa9, 0xaa, 0x57, 0xac, 0xad, 0xae, 0x0a,
 0xb0, 0xb1, 0xb2, 0x5b, 0xb4, 0xb5, 0xb6, 0x0b, 0xb8, 0xb9, 0xba, 0x5f, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0x63, 0xc4, 0xc5, 0xc6, 0x0c, 0xc8, 0xc9, 0xca, 0x67, 0xcc, 0xcd, 0xce, 0x0c,
 0xd0, 0xd1, 0xd2, 0x6b, 0xd4, 0xd5, 0xd6, 0x0d, 0xd8, 0xd9, 0xda, 0x6f, 0xdc, 0xdd, 0xde, 0x06,
 0xe0, 0xe1, 0xe2, 0x73, 0xe4, 0xe5, 0xe6, 0x0e, 0xe8, 0xe9, 0xea, 0x77, 0xec, 0xed, 0xee, 0x0e,
 0xf0, 0xf1, 0xf2, 0x7b, 0xf4, 0xf5, 0xf6, 0x0f, 0xf8, 0xf9, 0xfa, 0x7f, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 4
{0x00, 0x01, 0x02, 0x00, 0x04, 0x03, 0x06, 0x00, 0x08, 0x05, 0x0a, 0x01, 0x0c, 0x07, 0x0e, 0x00,
 0x10, 0x09, 0x12, 0x02, 0x14, 0x0b, 0x16, 0x02, 0x18, 0x0d, 0x1a, 0x03, 0x1c, 0x0f, 0x1e, 0x00,
 0x20, 0x11, 0x22, 0x04, 0x24, 0x13, 0x26, 0x04, 0x28, 0x15, 0x2a, 0x05, 0x2c, 0x17, 0x2e, 0x02,
 0x30, 0x19, 0x32, 0x06, 0x34, 0x1b, 0x36, 0x06, 0x38, 0x1d, 0x3a, 0x07, 0x3c, 0x1f, 0x3e, 0x00,
 0x40, 0x21, 0x42, 0x08, 0x44, 0x23, 0x46, 0x08, 0x48, 0x25, 0x4a, 0x09, 0x4c, 0x27, 0x4e, 0x04,
 0x50, 0x29, 0x52, 0x0a, 0x54, 0x2b, 0x56, 0x0a, 0x58, 0x2d, 0x5a, 0x0b, 0x5c, 0x2f, 0x5e, 0x02,
 0x60, 0x31, 0x62, 0x0c, 0x64, 0x33, 0x66, 0x0c, 0x68, 0x35, 0x6a, 0x0d, 0x6c, 0x37, 0x6e, 0x06,
 0x70, 0x39, 0x72, 0x0e, 0x74, 0x3b, 0x76, 0x0e, 0x78, 0x3d, 0x7a, 0x0f, 0x7c, 0x3f, 0x00, 0x00,
 0x80, 0x41, 0x82, 0x10, 0x84, 0x43, 0x86, 0x10, 0x88, 0x45, 0x8a, 0x11, 0x8c, 0x47, 0x8e, 0x08,
 0x90, 0x49, 0x92, 0x12, 0x94, 0x4b, 0x96, 0x12, 0x98, 0x4d, 0x9a, 0x13, 0x9c, 0x4f, 0x9e, 0x04,
 0xa0, 0x51, 0xa2, 0x14, 0xa4, 0x53, 0xa6, 0x14, 0xa8, 0x55, 0xaa, 0x15, 0xac, 0x57, 0xae, 0x0a,
 0xb0, 0x59, 0xb2, 0x16, 0xb4, 0x5b, 0xb6, 0x16, 0xb8, 0x5d, 0xba, 0x17, 0xbc, 0x5f, 0x7e, 0x02,
 0xc0, 0x61, 0xc2, 0x18, 0xc4, 0x63, 0xc6, 0x18, 0xc8, 0x65, 0xca, 0x19, 0xcc, 0x67, 0xce, 0x0c,
 0xd0, 0x69, 0xd2, 0x1a, 0xd4, 0x6b, 0xd6, 0x1a, 0xd8, 0x6d, 0xda, 0x1b, 0xdc, 0x6f, 0xde, 0x06,
 0xe0, 0x71, 0xe2, 0x1c, 0xe4, 0x73, 0xe6, 0x1c, 0xe8, 0x75, 0xea, 0x1d, 0xec, 0x77, 0xee, 0x0e,
 0xf0, 0x79, 0xf2, 0x1e, 0xf4, 0x7b, 0xf6, 0x1e, 0xf8, 0x7d, 0xfa, 0x1f, 0xfc, 0x7f, 0xfe, 0x00 },
// Input Len = 5
{0x00, 0x00, 0x01, 0x00, 0x02, 0x01, 0x03, 0x00, 0x04, 0x02, 0x05, 0x02, 0x06, 0x03, 0x07, 0x00,
 0x08, 0x04, 0x09, 0x04, 0x0a, 0x05, 0x0b, 0x02, 0x0c, 0x06, 0x0d, 0x06, 0x0e, 0x07, 0x0f, 0x00,
 0x10, 0x08, 0x11, 0x08, 0x12, 0x09, 0x13, 0x04, 0x14, 0x0a, 0x15, 0x0a, 0x16, 0x0b, 0x17, 0x02,
 0x18, 0x0c, 0x19, 0x0c, 0x1a, 0x0d, 0x1b, 0x06, 0x1c, 0x0e, 0x1d, 0x0e, 0x1e, 0x0f, 0x1f, 0x00,
 0x20, 0x10, 0x21, 0x10, 0x22, 0x11, 0x23, 0x08, 0x24, 0x12, 0x25, 0x12, 0x26, 0x13, 0x27, 0x04,
 0x28, 0x14, 0x29, 0x14, 0x2a, 0x15, 0x2b, 0x0a, 0x2c, 0x16, 0x2d, 0x16, 0x2e, 0x17, 0x2f, 0x02,
 0x30, 0x18, 0x31, 0x18, 0x32, 0x19, 0x33, 0x0c, 0x34, 0x1a, 0x35, 0x1a, 0x36, 0x1b, 0x37, 0x06,
 0x38, 0x1c, 0x39, 0x1c, 0x3a, 0x1d, 0x3b, 0x0e, 0x3c, 0x1e, 0x3d, 0x1e, 0x3e, 0x1f, 0x00, 0x00,
 0x40, 0x20, 0x41, 0x20, 0x42, 0x21, 0x43, 0x10, 0x44, 0x22, 0x45, 0x22, 0x46, 0x23, 0x47, 0x08,
 0x48, 0x24, 0x49, 0x24, 0x4a, 0x25, 0x4b, 0x12, 0x4c, 0x26, 0x4d, 0x26, 0x4e, 0x27, 0x4f, 0x04,
 0x50, 0x28, 0x51, 0x28, 0x52, 0x29, 0x53, 0x14, 0x54, 0x2a, 0x55, 0x2a, 0x56, 0x2b, 0x57, 0x0a,
 0x58, 0x2c, 0x59, 0x2c, 0x5a, 0x2d, 0x5b, 0x16, 0x5c, 0x2e, 0x5d, 0x2e, 0x5e, 0x2f, 0x3f, 0x02,
 0x60, 0x30, 0x61, 0x30, 0x62, 0x31, 0x63, 0x18, 0x64, 0x32, 0x65, 0x32, 0x66, 0x33, 0x67, 0x0c,
 0x68, 0x34, 0x69, 0x34, 0x6a, 0x35, 0x6b, 0x1a, 0x6c, 0x36, 0x6d, 0x36, 0x6e, 0x37, 0x6f, 0x06,
 0x70, 0x38, 0x71, 0x38, 0x72, 0x39, 0x73, 0x1c, 0x74, 0x3a, 0x75, 0x3a, 0x76, 0x3b, 0x77, 0x0e,
 0x78, 0x3c, 0x79, 0x3c, 0x7a, 0x3d, 0x7b, 0x1e, 0x7c, 0x3e, 0x7d, 0x3e, 0x7e, 0x3f, 0x7f, 0x00 },
// Input Len = 6
{0x00, 0x00, 0x01, 0x00, 0x02, 0x02, 0x03, 0x00, 0x04, 0x04, 0x05, 0x02, 0x06, 0x06, 0x07, 0x00,
 0x08, 0x08, 0x09, 0x04, 0x0a, 0x0a, 0x0b, 0x02, 0x0c, 0x0c, 0x0d, 0x06, 0x0e, 0x0e, 0x0f, 0x00,
 0x10, 0x10, 0x11, 0x08, 0x12, 0x12, 0x13, 0x04, 0x14, 0x14, 0x15, 0x0a, 0x16, 0x16, 0x17, 0x02,
 0x18, 0x18, 0x19, 0x0c, 0x1a, 0x1a, 0x1b, 0x06, 0x1c, 0x1c, 0x1d, 0x0e, 0x1e, 0x1e, 0x1f, 0x00,
 0x20, 0x20, 0x21, 0x10, 0x22, 0x22, 0x23, 0x08, 0x24, 0x24, 0x25, 0x12, 0x26, 0x26, 0x27, 0x04,
 0x28, 0x28, 0x29, 0x14, 0x2a, 0x2a, 0x2b, 0x0a, 0x2c, 0x2c, 0x2d, 0x16, 0x2e, 0x2e, 0x2f, 0x02,
 0x30, 0x30, 0x31, 0x18, 0x32, 0x32, 0x33, 0x0c, 0x34, 0x34, 0x35, 0x1a, 0x36, 0x36, 0x37, 0x06,
 0x38, 0x38, 0x39, 0x1c, 0x3a, 0x3a, 0x3b, 0x0e, 0x3c, 0x3c, 0x3d, 0x1e, 0x3e, 0x3e, 0x00, 0x00,
 0x40, 0x40, 0x41, 0x20, 0x42, 0x42, 0x43, 0x10, 0x44, 0x44, 0x45, 0x22, 0x46, 0x46, 0x47, 0x08,
 0x48, 0x48, 0x49, 0x24, 0x4a, 0x4a, 0x4b, 0x12, 0x4c, 0x4c, 0x4d, 0x26, 0x4e, 0x4e, 0x4f, 0x04,
 0x50, 0x50, 0x51, 0x28, 0x52, 0x52, 0x53, 0x14, 0x54, 0x54, 0x55, 0x2a, 0x56, 0x56, 0x57, 0x0a,
 0x58, 0x58, 0x59, 0x2c, 0x5a, 0x5a, 0x5b, 0x16, 0x5c, 0x5c, 0x5d, 0x2e, 0x5e, 0x5e, 0x3f, 0x02,
 0x60, 0x60, 0x61, 0x30, 0x62, 0x62, 0x63, 0x18, 0x64, 0x64, 0x65, 0x32, 0x66, 0x66, 0x67, 0x0c,
 0x68, 0x68, 0x69, 0x34, 0x6a, 0x6a, 0x6b, 0x1a, 0x6c, 0x6c, 0x6d, 0x36, 0x6e, 0x6e, 0x6f, 0x06,
 0x70, 0x70, 0x71, 0x38, 0x72, 0x72, 0x73, 0x1c, 0x74, 0x74, 0x75, 0x3a, 0x76, 0x76, 0x77, 0x0e,
 0x78, 0x78, 0x79, 0x3c, 0x7a, 0x7a, 0x7b, 0x1e, 0x7c, 0x7c, 0x7d, 0x3e, 0x7e, 0x7e, 0x7f, 0x00 },
// Input Len = 7
{0x00, 0x00, 0x02, 0x00, 0x04, 0x02, 0x06, 0x00, 0x08, 0x04, 0x0a, 0x02, 0x0c, 0x06, 0x0e, 0x00,
 0x10, 0x08, 0x12, 0x04, 0x14, 0x0a, 0x16, 0x02, 0x18, 0x0c, 0x1a, 0x06, 0x1c, 0x0e, 0x1e, 0x00,
 0x20, 0x10, 0x22, 0x08, 0x24, 0x12, 0x26, 0x04, 0x28, 0x14, 0x2a, 0x0a, 0x2c, 0x16, 0x2e, 0x02,
 0x30, 0x18, 0x32, 0x0c, 0x34, 0x1a, 0x36, 0x06, 0x38, 0x1c, 0x3a, 0x0e, 0x3c, 0x1e, 0x3e, 0x00,
 0x40, 0x20, 0x42, 0x10, 0x44, 0x22, 0x46, 0x08, 0x48, 0x24, 0x4a, 0x12, 0x4c, 0x26, 0x4e, 0x04,
 0x50, 0x28, 0x52, 0x14, 0x54, 0x2a, 0x56, 0x0a, 0x58, 0x2c, 0x5a, 0x16, 0x5c, 0x2e, 0x5e, 0x02,
 0x60, 0x30, 0x62, 0x18, 0x64, 0x32, 0x66, 0x0c, 0x68, 0x34, 0x6a, 0x1a, 0x6c, 0x36, 0x6e, 0x06,
 0x70, 0x38, 0x72, 0x1c, 0x74, 0x3a, 0x76, 0x0e, 0x78, 0x3c, 0x7a, 0x1e, 0x7c, 0x3e, 0x00, 0x00,
 0x80, 0x40, 0x82, 0x20, 0x84, 0x42, 0x86, 0x10, 0x88, 0x44, 0x8a, 0x22, 0x8c, 0x46, 0x8e, 0x08,
 0x90, 0x48, 0x92, 0x24, 0x94, 0x4a, 0x96, 0x12, 0x98, 0x4c, 0x9a, 0x26, 0x9c, 0x4e, 0x9e, 0x04,
 0xa0, 0x50, 0xa2, 0x28, 0xa4, 0x52, 0xa6, 0x14, 0xa8, 0x54, 0xaa, 0x2a, 0xac, 0x56, 0xae, 0x0a,
 0xb0, 0x58, 0xb2, 0x2c, 0xb4, 0x5a, 0xb6, 0x16, 0xb8, 0x5c, 0xba, 0x2e, 0xbc, 0x5e, 0x7e, 0x02,
 0xc0, 0x60, 0xc2, 0x30, 0xc4, 0x62, 0xc6, 0x18, 0xc8, 0x64, 0xca, 0x32, 0xcc, 0x66, 0xce, 0x0c,
 0xd0, 0x68, 0xd2, 0x34, 0xd4, 0x6a, 0xd6, 0x1a, 0xd8, 0x6c, 0xda, 0x36, 0xdc, 0x6e, 0xde, 0x06,
 0xe0, 0x70, 0xe2, 0x38, 0xe4, 0x72, 0xe6, 0x1c, 0xe8, 0x74, 0xea, 0x3a, 0xec, 0x76, 0xee, 0x0e,
 0xf0, 0x78, 0xf2, 0x3c, 0xf4, 0x7a, 0xf6, 0x1e, 0xf8, 0x7c, 0xfa, 0x3e, 0xfc, 0x7e, 0xfe, 0x00 }
}; // End of Squeeze


BYTE CODEBASED DecWidth[8][256] = {
// Input Len = 0
{8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 1
{8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 2
{8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 3
{8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 7, 2,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 7, 7, 0, 1,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 7, 2,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 0 },
// Input Len = 4
{8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 7, 2,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 7, 6, 0, 1,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 7, 2,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 0 },
// Input Len = 5
{7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 6, 2,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 6, 5, 0, 1,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 6, 2,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 0 },
// Input Len = 6
{7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 6, 2,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 6, 6, 0, 1,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 6, 2,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 0 },
// Input Len = 7
{8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 7, 2,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 7, 6, 0, 1,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 7, 2,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 0 }
}; // width
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\cl2and20\class2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class2.c

Abstract:

    This is the main source for Class2 specific functions for fax-modem T.30 driver

Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    
                     
Revision History:

--*/

 
 
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];

          
// Here is the table we are using so far for manufacturer specific stuff

MFRSPEC Class2ModemTable[] = {
        { "", "Practical Peripherals", "PM14400FXPPM", "", 1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "Practical Peripherals", "PM9600FXMT", "",   1, 2, "", FALSE, FALSE, FALSE ,FALSE},
        { "", "Everex Systems", "Everfax 24/96E", "",      0, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "ROCKWELL", "V.32AC", "",                    1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "ROCKWELL", "RC9624AC", "",                  1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "Multi-Tech", "MT1432BA", "",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "", "SIERRA", "SX196", "",                       1, 0, "", TRUE,  FALSE, FALSE, FALSE },
        { "", "EXAR", "ROCKWELL 144DP", "",                1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "ELSA", "MicroLink 2460TL", "",              1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "GVC", "ROCKWELL 144DP", "",                 1, 0, "", FALSE, TRUE,  TRUE , FALSE }, // Intel144Ex
        { "", "ADC", "SL144V32", "",                       1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "UMC", "", "",                               1, 0, "", FALSE, TRUE,  FALSE ,FALSE},
        { "", "NetComm", "", "",                           1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "HALCYON", "Bit Blitzer", "",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "", "", "", "",                                  1, 0, "", FALSE, FALSE, FALSE, FALSE }
        };




void
Class2Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;


   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszINITIAL_FDT,  "AT+FDT=%%1d,%%1d,%%1d,%%1d\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPTS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBOR=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FDCC=1,%%d,,,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FDCC=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=1,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FDIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FDCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FDIS" );
   sprintf( pTG->cbszFDIS,          "AT+FDIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszZERO,          "0" );
   sprintf( pTG->cbszONE,           "1" );
   sprintf( pTG->cbszQUERY_S1,      "ATS1?\r" );
   sprintf( pTG->cbszRING,          "RING" );
   
   
   sprintf( pTG->cbszCLASS2_ATI,        "ATI\r" );
   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMFR?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMDL?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFDT_CNTL_Q,        "" );
   sprintf( pTG->cbszFCON,              "+FCON" );
   sprintf( pTG->cbszGO_CLASS2,         "AT+FCLASS=2\r" );
   sprintf( pTG->cbszFLID,              "AT+FLID=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_QUERY_CLASS,"AT+FCLASS=?\r" );
   sprintf( pTG->cbszCLASS2_GO_CLASS0,  "AT+FCLASS=0\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIALTONE");

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );      
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );    
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FK\r" );     
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );  
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIALTONE" ); 
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );        
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );   
   sprintf( pTG->cbszCLASS2_OK,         "OK" );          
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHNG" );    
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}




BOOL 
T30Cl2Tx(
   PThrdGlbl  pTG,
   LPSTR      szPhone
)

//  If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
//
{
        LPSTR   lpszSection = pTG->FComModem.rgchKey;
        USHORT  uRet1, uRet2;
        
        BYTE    bBuf[200],
                bTempBuf[200+RESPONSE_BUF_SIZE];
        
        LPBYTE  lpbyte;

        UWORD   Encoding, Res, PageWidth, PageLength, uwLen, uwRet;
        BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
        CHAR    szTSI[max(MAXTOTALIDLEN,20)+4];
        BOOL    fBaudChanged;
        BOOL    RetCode;


        uRet2 = 0;
        if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
        {

                (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Class2Caller: iModemGetCmdTabPtr failed.\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // first get SEND_CAPS if possible. If using PSI (IFAX/Winpad) then we
        // can't make callback this on the Sender. Only on Receiver! Otherwise
        // we deadlock & hang in PSI

#ifdef PSI
    if(!Class2GetBC(pTG, BC_NONE)) // Set it to some defaults!
#else
    if(!Class2GetBC(pTG, SEND_CAPS)) // get send caps
#endif
        {
               uRet1 = T30_CALLFAIL;

               pTG->fFatalErrorWasSignaled = 1;
               SignalStatusChange(pTG, FS_FATAL_ERROR);
               RetCode = FALSE;

               goto done;
        }

        // Go to Class2
        if(!iModemGoClass(pTG, 2))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2Caller: Failed to Go to Class 2 \n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // Begin by checking for manufacturer and ATI code.
        // Look this up against the modem specific table we
        // have and set up the send strings needed for
        // this modem.
        if(!Class2GetModemMaker(pTG ))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Call to GetModemMaker failed\n\r"));
                // Ignore failure!!!
        }

        // set manufacturer specific strings

        Class2SetMFRSpecific(pTG, lpszSection);

        // Get the capabilities of the software. I am only using this
        // right now for the TSI field (below where I send +FLID).
        // Really, this should also be used instead of the hardcoded DIS
        // values below.
        // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
        // A "RING" COULD APPEAR AT ANY TIME!

        _fmemset((LPB)szTSI, 0, strlen(szTSI));
        Class2SetDIS_DCSParams(pTG, SEND_CAPS, (LPUWORD)&Encoding, (LPUWORD)&Res,
                (LPUWORD)&PageWidth, (LPUWORD)&PageLength, (LPSTR) szTSI);

        bIDBuf[0] = '\0';
        uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);
        
        if(!Class2iModemDialog(pTG, bIDBuf, uwLen,
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Local ID failed\n\r"));
                // ignore failure
        }

        // // Turn off ECM - don't do for sierra type modems!
        // if (!pTG->CurrentMFRSpec.bIsSierra)
        //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
        //              LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
        //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        //      {
        //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
        //              // Ignore ECM failure!!!
        //      }

        // Turn off Bug mode
        if(!Class2iModemDialog(pTG, pTG->cbszFBUG, (UWORD) (strlen(pTG->cbszFBUG) ),
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                        (MyDebugPrint (pTG, LOG_ALL, "FBUG failed\n\r"));
                        // Ignore FBUG failure!!!
        }

        // Find out what the default DIS is
        if (!pTG->CurrentMFRSpec.bIsExar)
        {
          if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS, (UWORD) (strlen(pTG->cbszFDIS_IS) ),
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
          {
                (MyDebugPrint (pTG, LOG_ALL, "FDIS failed\n\r"));
                // ignore
          }
        }

        // See if the reply was ERROR or timeout, if so try a different command
        // Exar modems, for example, don't take AT+FDIS?
        if ( ( uwRet == 2) || (uwRet == 0) || pTG->CurrentMFRSpec.bIsExar)
        {
                // FDIS did not work!!! Try FDCC?
                if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDCC_IS,
                        (UWORD) (strlen(pTG->cbszFDCC_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                        pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                {
                        // Ignore
                }

                if ( (uwRet == 2) || (uwRet == 0 ) )
                {
                        // The FDCC failed - maybe it is an Exar that likes FDIS?
                        // try that
                        if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS,
                                (UWORD) (strlen(pTG->cbszFDIS_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                        {
                                //ignore
                        }
                        // Maybe it is the Class 2 modem referred to in
                        // Elliot bug #1238 that wants FDIS without a
                        // question mark
                        if ( (uwRet == 2) || (uwRet == 0 ) )
                        {
                                if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_NOQ_IS,
                                        (UWORD) (strlen(pTG->cbszFDIS_NOQ_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                        pTG->cbszCLASS2_OK, (C2PSTR) NULL)))
                                {
                                        // No FDIS, FDCC worked - quit!
                                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> No FDIS? or FDCC? worked\n\r"));
                                        uRet1 = T30_CALLFAIL;

                                        pTG->fFatalErrorWasSignaled = 1;
                                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                                        RetCode = FALSE;

                                        goto done;
                                }
                        }
                }

                // If the first character in the reply before a number
                // is a ',', insert a '1' for normal & fine res (Exar hack)
                for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
                {
                        if (*lpbyte == ',')
                        {
                                // found a leading comma
                                bTempBuf[0] = '\0';
                                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,
                                                lpbyte);
                                _fstrcpy(lpbyte, bTempBuf);
                                (MyDebugPrint (pTG, LOG_ALL, "Leading comma in DCC string =\n\r", (LPSTR)&pTG->lpbResponseBuf2));
                        }

                        if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) break;
                }

        }



        // If the repsonse was just a number string without "+FDIS" in front
        // of it, add the +FDIS. Some modem reply with it, some do not. The
        // general parsing algorithm used below in Class2ResponseAction needs
        // to know the command that the numbers refer to.
        if ( pTG->lpbResponseBuf2[0] != '\0' &&
           (Class2_fstrstr((LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
        {
                // did not get the FDIS in the response!
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
                wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,
                                (LPSTR)pTG->lpbResponseBuf2);
                _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
        }

        (MyDebugPrint (pTG, LOG_ALL, "\n\rReceived %s from FDIS\r\n", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Process default DIS to see if we have to send a DCC to change
        // it. Some modems react badly to just sending a DCC with ",,,"
        // so we can't rely on the modem keeping DIS parameters unchanged
        // after a DCC like that. We'll use the FDISResponse routine to load
        // the default DIS values into a PCB structure
        if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDIS Response\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        (MyDebugPrint (pTG, LOG_ALL, "pTG->DISPcb baud value is %d\n\r", pTG->DISPcb.Baud));

        fBaudChanged = FALSE;
        // See if we have to change the baud rate to a lower value.
        // This only happens if the user set an ini string constraining
        // the high end speed or if the user turned off V.17 for sending
        // Check the V.17 inhibit and lower baud if necessary
        if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Send) )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Lowering baud from %d for V.17 inihibit\n\r", CodeToBPS[pTG->DISPcb.Baud]));

                pTG->DISPcb.Baud = 3; //9600 won't use V.17
                fBaudChanged = TRUE;
        }

// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }


        // Now see if the high end baud rate has been constrained
        if  ( (pTG->ProtParams2.HighestSendSpeed != 0) &&
                (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Have to lower baud from %d to %d\n\r", CodeToBPS[pTG->DISPcb.Baud], pTG->ProtParams2.HighestSendSpeed));

                fBaudChanged = TRUE;
                switch (pTG->ProtParams2.HighestSendSpeed)
                {
                        case 2400:
                                pTG->DISPcb.Baud = 0;
                                break;
                        case 4800:
                                pTG->DISPcb.Baud = 1;
                                break;
                        case 7200:
                                pTG->DISPcb.Baud = 2;
                                break;
                        case 9600:
                                pTG->DISPcb.Baud = 3;
                                break;
                        case 12000:
                                pTG->DISPcb.Baud = 4;
                                break;
                        default:
                                (MyDebugPrint (pTG, LOG_ALL, "Bad HighestSpeed\n\r"));
                                
                                uRet1 = T30_CALLFAIL;
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_FATAL_ERROR);
                                RetCode = FALSE;
                                goto done;                                               
                                
                                break;
                }
        }


        // Now, look and see if any of the values in the DIS are "bad"
        // That is, make sure we can send high res and we are not
        // claiming that we are sending MR or MMR. Also, see if we changed
        // the baud rate.

        if ((pTG->DISPcb.Resolution & AWRES_mm080_077) && ( pTG->DISPcb.Encoding == MH_DATA)
                && (!fBaudChanged) )
        {
                //Do nothing - leave DIS alone!
                (MyDebugPrint (pTG, LOG_ALL, "no need to change DIS\n\r"));
        }
        else
        {
                // Send DCC command to the modem to set it up
                // Do the minimum necessary - only set resoultion if possible
                // (Again, this is because some modems don't like FDCC).
                if ( (pTG->DISPcb.Encoding == MH_DATA) && (!fBaudChanged) )
                {
                  if(!Class2iModemDialog(pTG, pTG->cbszFDCC_RES, (UWORD) (strlen(pTG->cbszFDCC_RES) ),
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL))
                  {
                        uRet1 = T30_CALLFAIL;

                        pTG->fFatalErrorWasSignaled = 1;
                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                        RetCode = FALSE;

                        goto done;
                  }
                }
                else if ( (pTG->DISPcb.Encoding == MH_DATA) && (fBaudChanged) )
                {
                        // Changed the baud rate, but Encoding is OK.
                        uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
                        if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL))
                        {
                                uRet1 = T30_CALLFAIL;

                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_FATAL_ERROR);
                                RetCode = FALSE;

                                goto done;
                        }
                }
                else // the encoding format has changed
                {
                  uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
                  if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL))
                  {
                        uRet1 = T30_CALLFAIL;

                        pTG->fFatalErrorWasSignaled = 1;
                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                        RetCode = FALSE;

                        goto done;
                  }
                }
        }


        // Do BOR based on the value from the modem table set in
        // Class2SetMFRSpecific
        uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
        if(!Class2iModemDialog(pTG, bBuf, uwLen, LOCALCOMMAND_TIMEOUT, TRUE,
                        0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FBOR failed\n\r"));
                // Ignore BOR failure!!!
        }

        // Dial the number

                // have to call hangup on every path out of here
                // after Dial is called. If Dial fails, it calls Hangup
                // if it succeeds we have to call Hangup when we're done

        SignalStatusChange(pTG, FS_DIALING);

        if((uRet2 = Class2Dial(pTG, szPhone)) != CONNECT_OK)
        {
                uRet1 = T30_DIALFAIL;

                if (! pTG->fFatalErrorWasSignaled) {
                   pTG->fFatalErrorWasSignaled = 1;
                   SignalStatusChange(pTG, FS_FATAL_ERROR);
                }

                RetCode = FALSE;

                goto done;
        }

        ICommGotAnswer(pTG );
        // we should be using the sender msg here but that says Training
        // at speed=xxxx etc which we don't know, so we just use the
        // Recvr message which just says "negotiating"
        ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

        // Send the data
        uRet1 = (USHORT)Class2Send(pTG );
        if ( uRet1 == T30_CALLDONE)
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, ALL OK\r\n"));
                ICommStatus(pTG, T30STATS_SUCCESS, 0, 0, 0);

                // have to call hangup on every path out of here
                // we have to call Hangup here
                Class2ModemHangup(pTG );

                SignalStatusChange(pTG, FS_COMPLETED);
                RetCode = TRUE;

        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, **** FAILED *****\r\n"));
                ICommStatus(pTG, T30STATS_FAIL, 0, 0, 0);

                // Make sure Modem is in OK state
                FComOutFilterClose(pTG );
                FComXon(pTG, FALSE);
                // have to call hangup on every path out of here
                // Class2ModemABort calls Hangup
                Class2ModemAbort(pTG );

                if (! pTG->fFatalErrorWasSignaled)  {
                   pTG->fFatalErrorWasSignaled = 1;
                   SignalStatusChange(pTG, FS_FATAL_ERROR);
                }
                
                RetCode = FALSE;

        }
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;

done:
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);

        return RetCode;
}



   


BOOL Class2Send(PThrdGlbl pTG)
{
        LPBUFFER        lpbf;
        SWORD           swRet;
        ULONG           lTotalLen=0;
        PCB             Pcb;
        USHORT          uTimeout=30000, PagesSent;
        BOOL            err_status, fAllPagesOK = TRUE;
        BCwithTEXT      bc;

        UWORD           Encoding, Res, PageWidth, PageLength, uwLen;
        BYTE            bFDISBuf[200];
        CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
        BYTE            bNull = 0;
        DWORD           TiffConvertThreadId;

        /*
        * We have just dialed... Now we have to look for the FDIS response from
        * the modem. It will be followed by an OK - hunt for the OK.
        */

        if(!Class2iModemDialog(pTG, NULL, 0, STARTSENDMODE_TIMEOUT, TRUE, 0,
                        pTG->cbszCLASS2_OK, (C2PSTR) NULL))
        {
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // The response will be in pTG->lpbResponseBuf2 - this is loaded in
        // Class2iModemDialog.

        // (MyDebugPrint (pTG, LOG_ALL, "Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Parse through the received strings, looking for the DIS, CSI,
        // NSF

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process ATD Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

        Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
        Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

        // Class2 modems do their own negotiation & we need to stay in sync
        // Otherwise, we might send MR data while the modem sends a DCS
        // saying it is MH. This happens a lot with Exar modems because
        // they dont accept an FDIS= command during the call.
        // FIX: On all Class2 sends force remote caps to always be MH
        // Then in efaxrun we will always negotiate MH & encode MH
        // We are relying on the fact that (a) it seems that all/most
        // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
        // negotiate MH and (c) We will override all non-Exar modem's
        // intrinsic negotiation by sending an AT+FDIS= just before the FDT
        // Also (d) This change makes our behaviour match Snowball exactly
        // so we will work no better or worse than it :-)
        bc.Fax.Encoding = MH_DATA;

        if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed return from ICommRecvCaps.\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // now get the SEND_PARAMS
        if(!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
        {
                err_status = T30_CALLFAIL;
                return err_status;
        }


#ifdef FILET30
        // Send the raw capabilities string - most values
        // will be null, since CAS does not tell us things like
        // DIS, NSF, etc. But, we can put in the CSI.
        ICommRawCaps(pTG, (LPBYTE) &bNull, (LPBYTE) &bNull, 0, NULL, 0);
#endif

        ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);


        // Turn off flow control.
        FComXon(pTG, FALSE);

        // The Send params were set during the call to Class2GetBC
        // We'll use these to set the ID (for the TSI) and the DCS params

        // Send the FDT and get back the DCS. The FDT must be followed by
        // CONNECT and a ^Q (XON)
        // The FDT string must have the correct resolution and encoding
        // for this session. FDT=Encoding, Res, width, length
        // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
        // Res 0=200x100 (normal), 1=200x200 (fine)
        // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
        //              3=1216/151,4=864/107
        // PageLength 0=A4,1=B4,2=unlimited

        Class2SetDIS_DCSParams(pTG, SEND_PARAMS, (LPUWORD)&Encoding,
          (LPUWORD)&Res, (LPUWORD)&PageWidth, (LPUWORD)&PageLength,
                        (LPSTR) szTSI);


        //
        // Current Win95 version of Class2 TX is limited to MH only.
        // While not changing this, we will at least allow MR selection in future.
        //

        if (!pTG->fTiffThreadCreated) {

             if (Encoding) {
               pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
             }
             else {
               pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
             }
            
            
             if (Res) {
               pTG->TiffConvertThreadParams.HiRes = 1;
             }
             else {
               pTG->TiffConvertThreadParams.HiRes = 0;
            
               // use LoRes TIFF file prepared by FaxSvc
            
               // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
            
             }
   
             _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
             pTG->TiffConvertThreadParams.lpszLineID[8] = 0;



             (MyDebugPrint(pTG,  LOG_ALL, "Creating TIFF helper thread \r\n"));
             pTG->hThread = CreateThread(
                           NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                           (LPVOID) pTG,
                           0,
                           &TiffConvertThreadId
                           );

             if (!pTG->hThread) {
                 (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> TiffConvertThread create FAILED\r\n"));
                 
                 err_status = T30_CALLFAIL;
                 return err_status;
             }

             pTG->fTiffThreadCreated = 1;
             pTG->AckTerminate = 0;
             pTG->fOkToResetAbortReqEvent = 0;

             if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) {
                 T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
                 T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                                 (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                 sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

             }
        }



        // Even modems that take FDT=x,x,x,x don't seem to really do it
        // right. So, for now, just send FDIS followed by FDT except for
        // the EXAR modems!!
        if (pTG->CurrentMFRSpec.bIsExar)
        {
                if(!Class2iModemDialog(pTG, pTG->cbszFDT, (UWORD) (strlen(pTG->cbszFDT) ),
                           STARTSENDMODE_TIMEOUT, TRUE, 0,
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Failed get response from initial FDT!!\r\n"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }
                // (MyDebugPrint (pTG, LOG_ALL, "FDT Received %s\r\n", (LPSTR)(&(pTG->lpbResponseBuf2))));
        }
        else
        {
                uwLen = (WORD)wsprintf(bFDISBuf, pTG->cbszFDIS, Res,
                         min(Pcb.Baud, pTG->DISPcb.Baud), PageWidth, PageLength, Encoding);
                if(!Class2iModemDialog(pTG, bFDISBuf, uwLen, LOCALCOMMAND_TIMEOUT,
                  TRUE, 0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Failed get response from FDIS!!\r\n"));
                        // Ignore it -we are going to send what we have!
                }

                if(!Class2iModemDialog(pTG, pTG->cbszFDT, (UWORD) (strlen(pTG->cbszFDT) ),
                           STARTSENDMODE_TIMEOUT, TRUE, 0,
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FDT Received %s\r\n",(LPSTR)(&(pTG->lpbResponseBuf2))));

                        (MyDebugPrint (pTG, LOG_ALL, "FDT to start first PAGE Failed!\n\r"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                (MyDebugPrint (pTG, LOG_ALL, "FDT Received %s\r\n", (LPSTR)(&(pTG->lpbResponseBuf2))));
        }

        if (pTG->CurrentMFRSpec.fSkipCtrlQ)
        {
                (MyDebugPrint (pTG, LOG_ALL, "WARNING!! Skipping cntl-q - sending immedaitely after CONNECT\n\r"));
        }
        // Get the  from the COMM driver
        else if(!FComGetOneChar(pTG, 0x11))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Couldn't Get cntl q - we'll go ahead anyway\n\r"));
        }

        // Turn on flow control.
        FComXon(pTG, TRUE);

        // Search through Response for the DCS frame - need it so set
        // the correct zero stuffing

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDT Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // Got a response - see if baud rate is OK
        (MyDebugPrint (pTG, LOG_ALL, "Negotiated Baud Rate = %d, lower limit is %d\n\r", Pcb.Baud, pTG->ProtParams2.LowestSendSpeed));

        if (CodeToBPS[Pcb.Baud] < (WORD)pTG->ProtParams2.LowestSendSpeed)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Aborting due to too low baud rate!\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        // Use values obtained from the DCS frame to set zero stuffing.
        // (These were obtained by call to Class2ResponseAction above).
        // Zero stuffing is a function of minimum scan time (determined
        // by resolution and the returned scan minimum) and baud.
        // Fixed the Hack--added a Baud field

        // Init must be BEFORE SetStuffZero!
        FComOutFilterInit(pTG );
        FComSetStuffZERO(pTG, Class2MinScanToBytesPerLine(pTG, Pcb.MinScan, (BYTE) Pcb.Baud, Pcb.Resolution));


        PagesSent = 0;
        err_status =  T30_CALLDONE;
        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
        {

          (MyDebugPrint (pTG, LOG_ALL, "IN MULTIPAGE WHILE LOOP. Pages Sent = %d\n\r", PagesSent));

          //// faxTlog(("SENDING Reams of Page Data.....\r\n"));

          lTotalLen = 0;

          FComOverlappedIO(pTG, TRUE); // TRUE
          while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
          {
                BG_CHK(lpbf && lpbf->wLengthData > 0);

                lTotalLen += lpbf->wLengthData;
                (MyDebugPrint (pTG, LOG_ALL, "TOTAL LENGTH: %ld\r\n", lTotalLen));

                if(!(Class2ModemSendMem(pTG, lpbf->lpbBegData,
                     lpbf->wLengthData) & (MyFreeBuf(pTG, lpbf))))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Class2ModemSendBuf Failed\r\n"));
                        err_status =  T30_CALLFAIL;
                        FComOverlappedIO(pTG, FALSE);
                        return err_status;
                }

                if (pTG->fAbort)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "Abort during Send loop\r\n"));
                        pTG->fAbort = FALSE;
                        err_status =  T30_CALLFAIL;
                        FComOverlappedIO(pTG, FALSE);
                        return err_status;
                }



          } // end of SEND_SEQ while

          FComOverlappedIO(pTG, FALSE);
          (MyDebugPrint (pTG, LOG_ALL, "OUT OF WHILE SEND_SEQ LOOP. \r\n"));
          (MyDebugPrint (pTG, LOG_ALL, "TOTAL LENGTH: %ld\r\n", lTotalLen));

          // Terminate the Page with DLE-ETX
          if(!FComDirectAsyncWrite(pTG, pTG->Class2bDLEETX, 2))
          {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to terminate page with DLE-ETX\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
          }

          if(!Class2ModemDrain(pTG ))
          {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to drain\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
          }

          //See if more pages to send...
          if ( ICommNextSend(pTG) == NEXTSEND_MPS )
          {
                // We are about to send a second or more page. Terminate the
                // last page with FET=0, signalling a new one to come

                if(!Class2iModemDialog(pTG, pTG->cbszENDPAGE, (UWORD) (strlen(pTG->cbszENDPAGE) ),
                   STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
                {

                        (MyDebugPrint (pTG, LOG_ALL, "END PAGE Processing Failed!\n\r"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Acknowledge that we sent the page
                // Parse the FPTS response and see if the page is good or bad.
                // Keep track of any bad pages in fAllPagesOK
                if (!ParseFPTS_SendAck(pTG ))
                    fAllPagesOK = FALSE;
                
                PagesSent++;



                // Now, Send the FDT to start the next page (this was done for
                // the first page before entering the multipage loop).

                if(!Class2iModemDialog(pTG, pTG->cbszFDT, (UWORD) (strlen(pTG->cbszFDT) ),
                           STARTSENDMODE_TIMEOUT, TRUE, 0,
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FDT to start next PAGE Failed!\n\r"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Get the  from the COMM driver
                if(!FComGetOneChar(pTG, 0x11))
                {
                 (MyDebugPrint (pTG, LOG_ALL, "Couldn't Get cntl q - we'll go ahead anyway\n\r"));
                }

                // Turn on flow control.
                FComXon(pTG, TRUE);

          } //if we do not have another page, do the else...
          else break; // All done sending pages...

          if ( err_status == T30_CALLFAIL) break;

        } //End of multipage while


        (MyDebugPrint (pTG, LOG_ALL, "OUT OF WHILE MULTIPAGE LOOP.  ABOUT TO SEND FINAL.\r\n"));

        //
        // Purge input COM queue to purge all OKs 
        //

        FComFlushInput(pTG);


        // Send end of message sequence

        if(!Class2iModemDialog(pTG, pTG->cbszENDMESSAGE, (UWORD) (strlen(pTG->cbszENDMESSAGE) ),
           STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
        {

                (MyDebugPrint (pTG, LOG_ALL, "End message failed\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        // Acknowledge that we sent the page
        // Parse the FPTS response and see if the page is good or bad.
        if (!ParseFPTS_SendAck(pTG )) fAllPagesOK = FALSE;
        PagesSent++;


        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);

        // If *any* page failed to send correctly, the call failed!
        if (!fAllPagesOK) err_status = T30_CALLFAIL;
        return err_status;

}





/**************************************************************
        Receive specific routines start here
***************************************************************/

BOOL  T30Cl2Rx (PThrdGlbl pTG)

//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
{
        LPSTR           lpszSection = pTG->FComModem.rgchKey;
        USHORT          uRet1, uRet2;
        BYTE            bBuf[200],
                        bTempBuf[200+RESPONSE_BUF_SIZE];
        UWORD           uwLen, uwRet;
        UWORD           Encoding, Res, PageWidth, PageLength;
        BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
        CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
        LPBYTE          lpbyte;
        BOOL            fBaudChanged;
        BOOL            RetCode;


        (MyDebugPrint (pTG, LOG_ALL, "Entering Class2 Callee\n\r"));

        uRet2 = 0;
        if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG )))
        {
                (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> Class2Callee: iModemGetCmdTabPtr failed.\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // first get SEND_CAPS
        if(!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
        {
        uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // Go to Class2
        // Elliot Bug#3421 -- incoming RING sometimes clobbers AT+FCLASS=1/2 cmd.
        if(pTG->lpCmdTab->dwFlags & fMDMSP_ANS_GOCLASS_TWICE) iModemGoClass(pTG, 2);
        if(!iModemGoClass(pTG, 2))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Class2Callee: Failed to Go to Class 2 \n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        // Begin by checking for manufacturer and ATI code.
        // Look this up against the modem specific table we
        // have and set up the receive strings needed for
        // this modem.
        if(!Class2GetModemMaker(pTG ))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Call to GetModemMaker failed\n\r"));
                // Ignore failure!!!
        }

        // set manufacturer specific strings

        Class2SetMFRSpecific(pTG, lpszSection);

        // Get the capabilities of the software. I am only using this
        // right now for the CSI field (below where I send +FLID).
        // Really, this should also be used instead of the hardcoded DIS
        // values below.
        // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
        // A "RING" COULD APPEAR AT ANY TIME!
        _fmemset((LPB)szCSI, 0, sizeof(szCSI));
        Class2SetDIS_DCSParams(pTG, SEND_CAPS, (LPUWORD)&Encoding, (LPUWORD)&Res,
                (LPUWORD)&PageWidth, (LPUWORD)&PageLength, (LPSTR) szCSI);

        // Find out what the default DIS is
        if (!pTG->CurrentMFRSpec.bIsExar)
        {
          if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS, (UWORD) (strlen(pTG->cbszFDIS_IS) ),
                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
          {
                (MyDebugPrint (pTG, LOG_ALL, "FDIS? failed\n\r"));
                // ignore
          }
        }

        // See if the reply was ERROR or timeout, if so try a different command
        // Exar modems, for example, don't take AT+FDIS?
        if ( ( uwRet == 2) || (uwRet == 0) || pTG->CurrentMFRSpec.bIsExar)
        {
                // FDIS did not work!!! Try FDCC?
                if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDCC_IS,
                        (UWORD) (strlen(pTG->cbszFDCC_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                        pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                {
                        // Ignore
                }

                if ( (uwRet == 2) || (uwRet == 0 ) )
                {
                        // The FDCC failed - maybe it is an Exar that likes FDIS?
                        // try that
                        if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_IS,
                                (UWORD) (strlen(pTG->cbszFDIS_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                        {
                                //ignore
                        }
                        // Maybe it is the Class 2 modem referred to in
                        // Elliot bug #1238 that wants FDIS without a
                        // question mark
                        if ( (uwRet == 2) || (uwRet == 0 ) )
                        {
                                if(!(uwRet=Class2iModemDialog(pTG, pTG->cbszFDIS_NOQ_IS,
                                        (UWORD) (strlen(pTG->cbszFDIS_NOQ_IS) ), LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                        pTG->cbszCLASS2_OK, (C2PSTR) NULL)))
                                {
                                        // No FDIS, FDCC worked - quit!
                                        (MyDebugPrint (pTG, LOG_ALL, "<<ERROR>> No FDIS? or FDCC? worked\n\r"));
                                        uRet1 = T30_CALLFAIL;

                                        pTG->fFatalErrorWasSignaled = 1;
                                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                                        RetCode = FALSE;

                                        goto done;
                                }
                        }
                }

                // If the first character in the reply before a number
                // is a ',', insert a '1' for normal & fine res (Exar hack)
                for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
                {
                        if (*lpbyte == ',')
                        {
                                // found a leading comma
                                bTempBuf[0] = '\0';
                                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,
                                                lpbyte);
                                _fstrcpy(lpbyte, bTempBuf);
                                (MyDebugPrint (pTG, LOG_ALL, "Leading comma in DCC string =\n\r", (LPSTR)&pTG->lpbResponseBuf2));

                        }

                        if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) break;
                }

        }

        // If the repsonse was just a number string without "+FDIS" in front
        // of it, add the +FDIS. Some modem reply with it, some do not. The
        // general parsing algorithm used below in Class2ResponseAction needs
        // to know the command that the numbers refer to.
        if ( pTG->lpbResponseBuf2[0] != '\0' &&
           (Class2_fstrstr( (LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
        {
                // did not get the FDIS in the response!
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
                wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,
                                (LPSTR)pTG->lpbResponseBuf2);
                _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received %s from FDIS?\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Process default DIS to see if we have to send a DCC to change
        // it. Some modems react badly to just sending a DCC with ",,,"
        // so we can't rely on the modem keeping DIS parameters unchanged
        // after a DCC like that. We'll use the FDISResponse routine to load
        // the default DIS values into a PCB structure
        if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process FDIS Response\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        fBaudChanged = FALSE;
        // See if we have to change the baud rate to a lower value.
        // This only happens if the user set an ini string inhibiting
        // V.17 receive
        if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Recv) )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Lowering baud from %d for V.17 receive inihibit\n\r", CodeToBPS[pTG->DISPcb.Baud]));

                pTG->DISPcb.Baud = 3; //9600 won't use V.17
                fBaudChanged = TRUE;
        }
// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }

        // Now, look and see if any of the values in the DIS are "bad"
        // That is, make sure we can receive high res and we are not
        // claiming that we are capable of MR or MMR. Also, see if we changed
        // the baud rate. Also make sure we can receive wide pages.

        if ((pTG->DISPcb.Resolution & AWRES_mm080_077) && ( pTG->DISPcb.Encoding == MH_DATA)
                && (!fBaudChanged)
                && (pTG->DISPcb.PageLength == 2) && (pTG->DISPcb.PageWidth == 2) )
        {
                //Do nothing - leave DIS alone!
                (MyDebugPrint (pTG, LOG_ALL, "no need to change DIS\n\r"));
        }
        else
        {
                // Send DCC command to the modem to set it up
                // Do the minimum necessary - only set resoultion if possible
                // (Again, this is because some modems don't like FDCC).
                if ( (pTG->DISPcb.Encoding == MH_DATA) && (!fBaudChanged)
                && (pTG->DISPcb.PageLength == 2) && (pTG->DISPcb.PageWidth == 2) )
                {
                  if(!Class2iModemDialog(pTG, pTG->cbszFDCC_RES, (UWORD) (strlen(pTG->cbszFDCC_RES) ),
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL))
                  {
                        //Ignore it
                  }
                }
                else if ( (pTG->DISPcb.Encoding == MH_DATA) && (fBaudChanged)
                && (pTG->DISPcb.PageLength == 2) && (pTG->DISPcb.PageWidth == 2) )
                {
                        // Changed the baud rate, but Encoding is OK.
                        uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
                        if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL))
                        {
                                //Ignore it
                        }
                }
                else // the encoding format has changed or page size is bad
                {
                  uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_RECV_ALL, pTG->DISPcb.Baud);
                  if(!(uwRet=Class2iModemDialog(pTG, bBuf, uwLen,
                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                  {
                        // ignore it.
                  }

                  // If the FDCC failed, try FDIS.
                  if ( (uwRet == 0) || (uwRet == 2) )
                  {
                          uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_RECV_ALL, pTG->DISPcb.Baud);
                          if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                                pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                          {
                                // ignore it.
                          }

                      // if the above failed, try just setting the baud
                      // rate and resolution with FDCC.
                      if ( (uwRet == 0) || (uwRet == 2) )
                      {
                                uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
                        if(!(uwRet=Class2iModemDialog(pTG, bBuf, uwLen,
                                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                                {
                                        // Ignore it
                                }
                      }

                      // if the above failed, try just setting the baud
                      // rate and resolution with FDIS.
                      if ( (uwRet == 0) || (uwRet == 2) )
                      {
                                uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_BAUD, pTG->DISPcb.Baud);
                        if(!(uwRet=Class2iModemDialog(pTG, bBuf, uwLen,
                                        LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL)))
                                {
                                        // Ignore it
                                }
                      }
                   }
                }
        }

        // Enable Reception
        if(!Class2iModemDialog(pTG, pTG->cbszFCR, (UWORD) (strlen(pTG->cbszFCR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                           pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FCR failed\n\r"));
                // ignore failure
        }


        // // Turn off ECM - don't do for sierra type modems!
        // if (!pTG->CurrentMFRSpec.bIsSierra)
        //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
        //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
        //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        //      {
        //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
        //              // Ignore ECM failure!!!
        //      }

        // Turn off Copy Quality Checking - also skip for Sierra type modems
        if (!pTG->CurrentMFRSpec.bIsSierra)
                if(!Class2iModemDialog(pTG, pTG->cbszFCQ, (UWORD) (strlen(pTG->cbszFCQ) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FCQ failed\n\r"));
                        // Ignore CQ failure!!!
                }

        // Turn off Bug mode
        if(!Class2iModemDialog(pTG, pTG->cbszFBUG, (UWORD) (strlen(pTG->cbszFBUG) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                        (MyDebugPrint (pTG, LOG_ALL, "FBUG failed\n\r"));
                        // Ignore FBUG failure!!!
        }

        // Do BOR based on the value from the modem table set in
        // Class2SetMFRSpecific
        bBuf[0] = '\0';
        {
                UINT uBOR = pTG->CurrentMFRSpec.iReceiveBOR;


                if (pTG->CurrentMFRSpec.fSWFBOR && uBOR==1)
                {
                        (MyDebugPrint (pTG, LOG_ALL, "<<WARNING>> SWFBOR Enabled. Using AT+FBOR=0 instead of AT+FBOR=1\r\n"));
                        uBOR=0;
                }
                uwLen = (USHORT)wsprintf(bBuf, pTG->cbszSET_FBOR, uBOR);
        }
        if(!Class2iModemDialog(pTG, bBuf, uwLen, ANS_LOCALCOMMAND_TIMEOUT, TRUE,
                        0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FBOR failed\n\r"));
                // Ignore BOR failure!!!
        }

        // Set the local ID - need ID from above to do this.
        bIDBuf[0] = '\0';
        uwLen = (USHORT)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
        if(!Class2iModemDialog(pTG, bIDBuf, uwLen,
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Local ID failed\n\r"));
                // ignore failure
        }


        // Answer the phone

                // have to call hangup on every path out of here
                // after Answer is called. If Answer fails, it calls Hangup.
                // if it succeeds we have to call Hangup when we're done


        SignalStatusChange(pTG, FS_ANSWERED);

        if((uRet2 = Class2Answer(pTG, FALSE)) != CONNECT_OK)
        {
                (MyDebugPrint (pTG, LOG_ALL, "Answer failed\n\r"));
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
        }

        (MyDebugPrint (pTG, LOG_ALL, "Done with Class2 Answer - succeeded!!\n\r"));
        ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);


        // Receive the data
        uRet1 = (USHORT)Class2Receive(pTG );
        if ( uRet1 == T30_CALLDONE)
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, ALL OK\r\n"));
                ICommStatus(pTG, T30STATR_SUCCESS, 0, 0, 0);

                // have to call hangup on every path out of here
                // we have to call Hangup here
                Class2ModemHangup(pTG );

                SignalStatusChange(pTG, FS_COMPLETED);
                RetCode = TRUE;

        }
        else
        {
                (MyDebugPrint (pTG, LOG_ALL, "******* DONE WITH CALL, **** FAILED *****\r\n"));
                ICommStatus(pTG, T30STATR_FAIL, 0, 0, 0);

                // Make sure modem is in an OK state!
                FComXon(pTG, FALSE);
                // have to call hangup on every path out of here
                // Abort calls Hangup
                Class2ModemAbort(pTG );

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

        }
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;

done:
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);
        
        return RetCode;
}




BOOL Class2Receive(PThrdGlbl pTG)
{
        LPBUFFER        lpbf;
        SWORD           swRet;
        UWORD           uwLen;
        ULONG           lTotalLen=0;
        PCB             Pcb;
        USHORT          uTimeout=30000, uRet, PagesReceived, uFPTSarg;
        BOOL            err_status;
        BCwithTEXT      bc;
        BYTE            bBuf[200];
        DWORD           tiffCompression;
        LPSTR           lpsTemp;
        DWORD           HiRes;



        // FComCriticalNeg(TRUE);

        //// faxTlog(("\r\n\r\n\r\n\r\n\r\n======================= Entering Class 2 Receive*** ==============================\r\n\r\n\r\n\r\n"));

        /*
        * We have just answered!
        */

        // The repsonse to the ATA command is in the global variable
        // pTG->lpbResponseBuf2.

        if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed to process ATA Response\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        //Now that pcb is set up, call ICommReceiveParams to tell icomfile

        Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
        Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

        if( ICommRecvParams(pTG, (LPBC)&bc) == FALSE )
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed return from ICommRecvParams.\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }


        //
        // once per RX - create TIFF file as soon as we know the compression / resolution.
        //

        pTG->Encoding   = Pcb.Encoding;
        pTG->Resolution = Pcb.Resolution;

        if (Pcb.Encoding == MR_DATA) {
            tiffCompression =  TIFF_COMPRESSION_MR;
        }
        else {
            tiffCompression =  TIFF_COMPRESSION_MH;
        }

        if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) {
            HiRes = 1;
        }
        else {
            HiRes = 0;
        }


        if ( !pTG->fTiffOpenOrCreated) {
            //
            // top 32bits of 64bit handle are guaranteed to be zero
            //
            pTG->Inst.hfile =  PtrToUlong( TiffCreateW ( pTG->lpwFileName,
                                                         tiffCompression,
                                                         1728,
                                                         FILLORDER_LSB2MSB,
                                                         HiRes
                                                         ) );

            if (! (pTG->Inst.hfile)) {

                lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't create tiff file %s compr=%d \n",
                                           lpsTemp,
                                           tiffCompression);

                MemFree(lpsTemp);
                err_status =  T30_CALLFAIL;
                return err_status;

            }

            pTG->fTiffOpenOrCreated = 1;

            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

            MyDebugPrint(pTG, LOG_ALL, "Created tiff file %s compr=%d HiRes=%d \n",
                                       lpsTemp,  tiffCompression, HiRes);

            MemFree(lpsTemp);
        }

        // we set buffer sizes and recv mode (ECM/non-ECM) here
        ICommSetRecvMode(pTG, FALSE);        // always non-ECM?

        // **** Apparently, we don't want flow control on, so we'll turn
        // it off. Is this true???? If I turn it on, fcom.c fails a
        // debug check in filterreadbuf.
        FComXon(pTG, FALSE);


        // Send the FDR. The FDR must be responded to by a CONNECT.

        if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
           STARTSENDMODE_TIMEOUT, TRUE, 0,
                        pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "Failed get response from initial FDR!!\r\n"));
                err_status =  T30_CALLFAIL;
                return err_status;
        }

        (MyDebugPrint (pTG, LOG_ALL, "FDR Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Might have to search through FDR response, but I doubt it.

        // Now we need to send a DC2 (0x12) to tell the modem it is OK
        // to give us data.
        // Some modems use ^Q instead of ^R - The correct value was written
        // into the DC@ string in Class2Callee where we checked for
        // manufacturer

        FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);


        // Now we can receive the data and give it to the icomfile routine

        PagesReceived = 0;
        err_status =  T30_CALLDONE;

        while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
        {

          (MyDebugPrint (pTG, LOG_ALL, "IN MULTIPAGE WHILE LOOP. Pages Received = %d\n\r", PagesReceived));


          //// faxTlog(("Receiving Reams of Page Data.....\r\n"));
        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
#define READ_TIMEOUT    15000

          lTotalLen = 0;
          do
          {
                (MyDebugPrint (pTG, LOG_ALL, "In receiving a page loop\n\r"));
                uRet=Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);
                
                (MyDebugPrint(pTG, LOG_ALL, "Class2ModemRecvBuf: uRet=%x\n\r", uRet ));
                
                if(lpbf)
                {
                        lTotalLen += lpbf->wLengthData;
                        (MyDebugPrint (pTG, LOG_ALL, "In lpbf if. length = %ld, Total Length %ld\n\r", lpbf->wLengthData, lTotalLen));

                        if(!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "Bad return - PutRecvBuf in page\r\n"));
                                err_status=T30_CALLFAIL;
                                return err_status;
                        }
                        lpbf = 0;
                }
          }
          while(uRet == RECV_OK);

          (MyDebugPrint (pTG, LOG_ALL, "Out of RECV_SEQ do loop\n\r"));

          if(uRet == RECV_EOF)
          {
                (MyDebugPrint (pTG, LOG_ALL, "Got EOF from RecvBuf\n\r"));
                // FComCriticalNeg(TRUE);

                
                // RSL needed interface to TIFF thread
                pTG->fLastReadBlock = 1;
                ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
                
                
          }
          else
          {
                // Timeout from ModemRecvBuf
                (MyDebugPrint (pTG, LOG_ALL, "ModemRecvBuf Timeout or Error=%d\r\n", uRet));
                err_status = T30_CALLFAIL;
                return err_status;
          }

          //// faxTlog(pTG, ("Page Recv Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));


          PagesReceived++;

          Class2GetRecvPageAck(pTG );

          // Set the FPTS parameter based on the global pTG->fRecvPageOK variable.
          // This variable was set during the call to Class2GetRecvPageAck above.
          // The quality of the page was checked during that call.
          // This command will cause an the next FDR command to send either
          // "MCF" or "RTN".

          if (pTG->fRecvPageOK) uFPTSarg = 1; // 1 indicates a good page
          else uFPTSarg = 2; // 2 indicates a bad page, retrain requested.


          // See if more pages to receive by parsing the FDR response...
          // After the DLEETX was received by Class2ModemRecvBuf, the
          // FPTS and FET response should be coming from the modem, terminated
          // by an OK. Let's go read that!

          if(!Class2iModemDialog(pTG, NULL, 0,
                   STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
          {

                (MyDebugPrint (pTG, LOG_ALL, "END PAGE Processing Failed!\n\r"));
                err_status =  T30_CALLFAIL;
                return err_status;
          }

          (MyDebugPrint (pTG, LOG_ALL, "EOP Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

          // Process the response and see if more pages are coming

          if (Class2EndPageResponseAction(pTG ) == MORE_PAGES)
          {

                ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);

                // Send the FPTS - don't do this for Exar modems!
                if (!pTG->CurrentMFRSpec.bIsExar)
                {
                        uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, uFPTSarg);
                        if(!Class2iModemDialog(pTG, bBuf, uwLen,
                                LOCALCOMMAND_TIMEOUT, TRUE, 0,
                                pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                        {
                                (MyDebugPrint (pTG, LOG_ALL, "FPTS= failed\n\r"));
                                // Ignore FPTS failure!!!
                        }
                }

                // Now, Send the FDR to start the next page (this was done for
                // the first page before entering the multipage loop).

                if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
                           STARTSENDMODE_TIMEOUT, TRUE, 0,
                                pTG->cbszFDT_CONNECT,(C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FDR to start next PAGE Failed!\n\r"));
                        err_status =  T30_CALLFAIL;
                        return err_status;
                }

                // Now send the correct DC2 string set in Class2Callee
                // (DC2 is standard, some use ^q instead)
                FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

          } //if we do not have another page, do the else...
          else break; // All done receiving pages...

        } //End of multipage while

        (MyDebugPrint (pTG, LOG_ALL, "OUT OF WHILE MULTIPAGE LOOP. ABOUT TO SEND FINAL FDR.\r\n"));
        //RSL
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
        

        // Send end of message sequence
        // Send the last FPTS - do we really need to do this???

        if (!pTG->CurrentMFRSpec.bIsExar)
        {
                uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, uFPTSarg);
                if(!Class2iModemDialog(pTG, bBuf, uwLen, LOCALCOMMAND_TIMEOUT, TRUE,
                        0, pTG->cbszCLASS2_OK, pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
                {
                        (MyDebugPrint (pTG, LOG_ALL, "FPTS= failed\n\r"));
                        // Ignore FPTS failure!!!
                }
        }

        // Send last FDR
        if(!Class2iModemDialog(pTG, pTG->cbszFDR, (UWORD) (strlen(pTG->cbszFDR) ),
           STARTSENDMODE_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK, (C2PSTR)NULL))
        {

                err_status =  T30_CALLFAIL;
                return err_status;
        }


        FComXon(pTG, FALSE);

        ICommGotDisconnect(pTG );

        return err_status;

}


BOOL Class2GetModemMaker(PThrdGlbl pTG)
{
        USHORT i;

        // Initialize the current modem variable's (global) strings.
        pTG->CurrentMFRSpec.szATI[0] = '\0';
        pTG->CurrentMFRSpec.szMFR[0] = '\0';
        pTG->CurrentMFRSpec.szMDL[0] = '\0';
        // pTG->CurrentMFRSpec.szREV[0] = '\0';

//      // Get the ATI - repsonse is in pTG->lpbResponseBuf2
//      // For all responses, "ERROR" may come back - that is OK - we will
//      // never match ERROR to an acceptable modem manufacturer name, model,
//      // revision, etc.
//      if(!Class2iModemDialog(cbszCLASS2_ATI, sizeof(cbszCLASS2_ATI)-1,
//                      ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, cbszCLASS2_OK,
//                      cbszCLASS2_ERROR, (C2PSTR) NULL))
//      {
//              (MyDebugPrint (pTG, LOG_ALL, "ATI failed\n\r"));
//              // Ignore ATI failure!!!
//      }
//      else
//      {
//              // copy ATI answer into ATI variable
//              for (i=0; i<MFR_SIZE; i++)
//                      pTG->CurrentMFRSpec.szATI[i] = pTG->lpbResponseBuf2[i];
//      }
//
//      (MyDebugPrint (pTG, LOG_ALL, "Received ATI %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));


        // Get the FMFR - repsonse is in pTG->lpbResponseBuf2
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_FMFR, (UWORD) (strlen(pTG->cbszCLASS2_FMFR) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FMFR failed\n\r"));
                // Ignore FMFR failure!!!
        }
        else
        {
                // copy FMFR answer into FMFR variable
                for (i=0; i<MFR_SIZE; i++)
                        pTG->CurrentMFRSpec.szMFR[i] = pTG->lpbResponseBuf2[i];
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received FMFR %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // Get the FMDL - repsonse is in pTG->lpbResponseBuf2
        if(!Class2iModemDialog(pTG, pTG->cbszCLASS2_FMDL, (UWORD) (strlen(pTG->cbszCLASS2_FMDL) ),
                        ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
        {
                (MyDebugPrint (pTG, LOG_ALL, "FMDL failed\n\r"));
                // Ignore FMDL failure!!!
        }
        else
        {
                // copy FMDL answer into FMDL variable
                for (i=0; i<MFR_SIZE; i++)
                        pTG->CurrentMFRSpec.szMDL[i] = pTG->lpbResponseBuf2[i];
        }

        (MyDebugPrint (pTG, LOG_ALL, "Received FMDL %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        // // Get the FREV - repsonse is in pTG->lpbResponseBuf2
        // if(!Class2iModemDialog(cbszCLASS2_FREV, sizeof(cbszCLASS2_FREV)-1,
        //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, cbszCLASS2_OK,
        //              cbszCLASS2_ERROR, (C2PSTR) NULL))
        // {
        //      (MyDebugPrint (pTG, LOG_ALL, "FREV failed\n\r"));
        //      // Ignore FREV failure!!!
        // }
        // else
        // {
        //      // copy FREV answer into REV variable
        //      for (i=0; i<MFR_SIZE; i++)
        //              pTG->CurrentMFRSpec.szREV[i] = pTG->lpbResponseBuf2[i];
        // }
        // (MyDebugPrint (pTG, LOG_ALL, "Received REV %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

        return TRUE;
}










void Class2SetMFRSpecific(PThrdGlbl pTG, LPSTR lpszSection)
{

        USHORT iIndex, iFoundMFR,iFoundMDL;
        LPMFRSPEC lpmfrMatched;

        (MyDebugPrint (pTG, LOG_ALL, "Entering Class2SetMFRSpecific\n\r"));

        // Find the index into the table that corresponds most closely
        // to the modem. If we can't find the mfr and model, find a mfr
        // that matches (use the last one). If neither, use the default
        // last entry.

        // Look for Manufacturer name
        iIndex = 0;
        iFoundMFR = 0;
        iFoundMDL = 0;
        (MyDebugPrint (pTG, LOG_ALL, "Entering search table loop\n\r"));
        while (Class2ModemTable[iIndex].szMFR[0] != '\0')
        {
                lpmfrMatched = &(Class2ModemTable[iIndex]);
                // Look and see if the current name matches
                // the name in the list.
                if(Class2_fstrstr( (LPSTR) pTG->CurrentMFRSpec.szMFR,
                        (LPSTR) lpmfrMatched->szMFR) != NULL)
                {
                        // Found a match!
                        (MyDebugPrint (pTG, LOG_ALL, "MATCHED MANUFACTURER NAME: %s %s\n\r",
                            (LPSTR)(&pTG->CurrentMFRSpec.szMFR),
                            (LPSTR)(&(lpmfrMatched->szMFR)) ));

                        iFoundMFR=iIndex;
                        //Now see if this matches the model number, too.
                        if(Class2_fstrstr( (LPSTR) pTG->CurrentMFRSpec.szMDL,
                           (LPSTR) lpmfrMatched->szMDL) != NULL)
                        {
                                //Got a MDL match, too! Stop looking.
                                iFoundMDL = iIndex;
                                (MyDebugPrint (pTG, LOG_ALL, "MATCHED MODEL: %s %s\n\r", (LPSTR)(&pTG->CurrentMFRSpec.szMDL), (LPSTR)(&(lpmfrMatched->szMDL)) ));
                                break;
                        }
                }

                iIndex++;
        }


        // We now either have the modem match or are using the defaults!
        if (iFoundMFR != 0) lpmfrMatched = &Class2ModemTable[iFoundMFR];
        else lpmfrMatched = &Class2ModemTable[iIndex];

        // Set proper BOR for receive and send

        pTG->CurrentMFRSpec.iSendBOR = lpmfrMatched->iSendBOR;
        pTG->CurrentMFRSpec.iReceiveBOR = lpmfrMatched->iReceiveBOR;
        pTG->CurrentMFRSpec.fSWFBOR  = lpmfrMatched->fSWFBOR;

        // Set the DC2 string - this is used in receive mode
        // after sending the FDR to tell the modem we are ready
        // to receive data. The standard says it should be a Dc2
        // (^R). But, some modems use ^Q

        pTG->CurrentMFRSpec.szDC2[0] = lpmfrMatched->szDC2[0];

        // Set the Sierra  and Exar flags flag

        pTG->CurrentMFRSpec.bIsSierra = lpmfrMatched->bIsSierra;
        pTG->CurrentMFRSpec.bIsExar = lpmfrMatched->bIsExar;
        pTG->CurrentMFRSpec.fSkipCtrlQ = lpmfrMatched->fSkipCtrlQ;

        (MyDebugPrint (pTG, LOG_ALL, "Leaving Class2SetMFRSpecific\n\r"));
}


BOOL Class2Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
        int     i,
                j,
                comm_numb = 0,
                parameters;
        BYTE    switch_char,
                char_1,
                char_2;
        char    c;

        BOOL    found_command = FALSE;

        #define STRING_PARAMETER        1
        #define NUMBER_PARAMETERS       2
        for(i = 0; lpbBuf[i] != '\0'; ++i)
        {
                switch ( lpbBuf[i] )
                {
                        case 'C':
                                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                                {
                                        cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                                        for(; lpbBuf[i] != '\r'; ++i )
                                                ;
                                }
                                else
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad First C values\n\r"));
                                                return FALSE;
                                }
                                break;

                        case 'O':
                                if (lpbBuf[++i] == 'K' )
                                {
                                        cl2_comm->command[comm_numb++] = CL2DCE_OK;
                                        for(; lpbBuf[i] != '\r'; ++i )
                                                ;
                                }
                                else
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad O values\n\r"));
                                                return FALSE;
                                }
                                break;

                        case 0x11:
                                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                                break;

                        case '+':
                                if( lpbBuf[++i] != 'F' )
                                {
                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad + values\n\r"));
                                                return FALSE;
                                }
                                switch_char = lpbBuf[++i];
                                char_1 = lpbBuf[++i];
                                char_2 = lpbBuf[++i];
                                // (MyDebugPrint (pTG, LOG_ALL, "Parse: in + command - %c%c%c \n\r",
                                //      switch_char, char_1, char_2));
                                switch ( switch_char )
                                {
                                        case 'C':
                                                //  Connect Message +FCON.
                                                if ( char_1 == 'O' && char_2 == 'N' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCON;
                                                        parameters = FALSE;
                                                }

                                                // Report of Remote ID. +FCIG.
                                                else if (char_1 == 'I' && char_2 == 'G' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                                                        parameters = STRING_PARAMETER;
                                                }

                                                // Prepare to receive prompt.  +FCFR.
                                                else if ( char_1 == 'F' && char_2 == 'R' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCFR;
                                                        parameters = FALSE;
                                                }
                                                // Report the Remote ID CSI +FCSI.
                                                else if ( char_1 == 'S' && char_2 == 'I' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad C values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'D':
                                                // Report DCS frame information +FDCS.
                                                if ( char_1 == 'C' && char_2 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report DIS frame information +FDIS.
                                                else if ( char_1 == 'I' && char_2 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report DTC frame information +FDTC.
                                                else if ( char_1 == 'T' && char_2 == 'C' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad D values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'E':
                                                // Post page message report. +FET.
                                                if ( char_1 == 'T' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FET;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad E values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'H':
                                        // Debug report transmitted HDLC frames +FHT
                                                if ( char_1 == 'T' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHT;
                                                        parameters = STRING_PARAMETER;
                                                }
                                        // Debug report received HDLC frames +FHR
                                                else if ( char_1 == 'R' )
                                                {
                                                        --i;
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHR;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                // Report hang up.  +FHNG.
                                                else if ( char_1 == 'N' && char_2 == 'G' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad H values\n\r"));
                                                                return FALSE;
                                                }
                                                break;
                                        case 'N':
                                                // Report NSF frame reciept.
                                                if ( char_1 == 'S' && char_2 == 'F' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report NSS frame reciept.
                                                else if ( char_1 == 'S' && char_2 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                // Report NSC frame reciept.
                                                else if ( char_1 == 'S' && char_2 == 'C' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad N values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'P':
                                                // Report poll request. +FPOLL
                                                if ( char_1 == 'O' && char_2 == 'L' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                                                        parameters = FALSE;
                                                }
                                                // Page Transfer Status Report +FPTS.
                                                else if ( char_1 == 'T' && char_2 == 'S' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                                                        parameters = NUMBER_PARAMETERS;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad P values\n\r"));
                                                                return FALSE;
                                                }
                                                break;
                                        case 'T':
                                                // Report remote ID +FTSI.
                                                if ( char_1 == 'S' && char_2 == 'I' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                                                        parameters = STRING_PARAMETER;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad T values\n\r"));
                                                                return FALSE;
                                                }
                                                break;

                                        case 'V':
                                                // Report voice request +FVOICE.
                                                if ( char_1 == 'O' && char_2 == 'I' )
                                                {
                                                        cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                                                        parameters = FALSE;
                                                }
                                                else
                                                {
                                                                (MyDebugPrint (pTG, LOG_ALL, "Parse: Bad V values\n\r"));
                                                                return FALSE;
                                                }
                                }

                                //  Transfer the associated paramters to the parameter array.
                                if ( parameters == NUMBER_PARAMETERS)
                                {
                                        for(i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                                        {
                                                //  Skip past the non numeric characters.
                                                if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' ) continue;

                                                /*  Convert the character representation of the numeric
                                                         parameter into a true number, and store in the
                                                        parameter list.  */
                                                cl2_comm->parameters[comm_numb][j] = 0;
                                                for(; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                                                {
                                                        cl2_comm->parameters[comm_numb][j] *= 10;
                                                        cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                                                }
                                                i--; // the last for loop advanced 'i' past the numeric.
                                                j++; // get set up for next parameter
                                        }
                                }
                                else if (parameters == STRING_PARAMETER )
                                {
                                        // Skip the : that follows the +f command (eg +FTSI:)
                                        if (lpbBuf[i+1] == ':') i++;
                                        // Also skip the " that follows the :
                                        if (lpbBuf[i+1] == '\"') i++;
                                        // Also skip leading blanks
                                        while (lpbBuf[i+1] == ' ') i++;
                                        for(i+=1, j=0; (c = lpbBuf[i])  != '\r' && c != '\n' &&
                                                c != '\0'; ++i, ++j)
                                        {
                                                cl2_comm->parameters[comm_numb][j] = c;
                                        }
                                        // Skip the trailing "
                                        if ((j > 0) && (cl2_comm->parameters[comm_numb][j - 1] == '\"')) j--;
                                        // Also skip the trailing blanks
                                        for ( ; (j > 0) && (cl2_comm->parameters[comm_numb][j - 1] == ' '); j--);
                                        cl2_comm->parameters[comm_numb][j] = '\0';
                                }

                                //  No parameters, so just skip to end of line.
                                else
                                {
                                        for(; (c=lpbBuf[i]) != '\r'
                                                && c != '\n' && c != '\0'; ++i)
                                                ;
                                }

                                //  Increment command count.
                                ++comm_numb;
                                break;

                        default:
                                break;
                }
        }
        cl2_comm->comm_count = (USHORT)comm_numb;
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\class1.h ===
/***************************************************************************
 Name     :     CLASS1.H
 Comment  :     Main include file for Windows Comm Class-1 Modem driver

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 60 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 60+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/



/**---------------------- #define of other things ---------------------

        FAX_CLASSn      is used in Modem.FaxClass.

        CHECK_PATTERN is used in the Guard elements.
        ECM_FRAMESIZE in T30.C

---------------------- #define of other things ---------------------**/

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03







#ifdef MDDI
#       define MDDISTMT(x)              x
#       define HLINE_2                  ((HLINE)2)
#       define HMODEM_3                 ((HMODEM)3)
#else // MDDI
#       define MDDISTMT(x)
#endif //MDDI


extern BYTE                             bDLEETX[];
extern BYTE                             bDLEETXOK[];


#define EndMode(pTG)         { pTG->Class1Modem.DriverMode = IDLE;      \
                                                pTG->Class1Modem.ModemMode = COMMAND;        \
                                                pTG->Class1Modem.CurMod = 0; }


/****************** begin prototypes from framing.c *****************/
BOOL SWFramingSendSetup(PThrdGlbl pTG, BOOL fOn);
BOOL SWFramingRecvSetup(PThrdGlbl pTG, BOOL fOn);
BOOL SWFramingSendFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount, USHORT uFlags);
BOOL SWFramingSendFlags(PThrdGlbl pTG, USHORT uHowMany);
USHORT SWFramingRecvFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
BOOL SWFramingSendPreamble(PThrdGlbl pTG, USHORT uCurMod);
BOOL SWFramingSendPostamble(PThrdGlbl pTG, USHORT uCurMod);
/***************** end of prototypes from framing.c *****************/

// from ddi.c
void SendZeros1(PThrdGlbl pTG, USHORT uCount);

BOOL iModemDrain(PThrdGlbl pTG);


#define iModemNoPauseDialog(pTG, s, l, t, w)                 \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemNoPauseDialog2(pTG, s, l, t, w1, w2)   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemNoPauseDialog3(pTG, s, l, t, w1, w2, w3)       \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))

#define iModemPauseDialog(pTG, s, l, t, w)                   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemPauseDialog2(pTG, s, l, t, w1, w2)     \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemPauseDialog3(pTG, s, l, t, w1, w2, w3) \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))


#define iModemResp1( pTG, t, w)                              \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemResp2(pTG, t, w1, w2)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemResp3(pTG,  t, w1, w2, w3)             \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))
#define iModemResp4( pTG, t, w1, w2, w3, w4)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)w4, (CBPSTR)(NULL))


#ifdef CL0

/****************** begin prototypes from class0.c *****************/
BOOL Class0ModemSendMode(PThrdGlbl pTG, HMODEM hModem, BOOL fHDLC);
BOOL Class0ModemSendMem(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT uCount, USHORT uFlags);
USHORT Class0ModemRecvMode(PThrdGlbl pTG, HMODEM hModem, BOOL fHDLC, ULONG ulTimeout);
USHORT Class0ModemRecvMem(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
BOOL Class0SendData(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags);
USHORT Class0RecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
void Class0ModemEndRecv(PThrdGlbl pTG, HMODEM hModem);
/***************** end of prototypes from class0.c *****************/

#endif //CL0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\encoder.c ===
/***************************************************************************
 Name     :     ENCODER.C
 Comment  :     HDLC encoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#include "prep.h"

#include "encoder.h"
#include "debug.h"


#include "glbproto.h"

#define faxTlog(m)              DEBUGMSG(ZONE_SWFRAME, m)
#define FILEID                  FILEID_ENCODER

extern  BYTE CODEBASED EncLen[5][256], CODEBASED EncWidth[5][256];
extern  WORD CODEBASED EncOut[5][256];












USHORT SWECMEXP HDLC_Encode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, LPENCODESTATE lpState)
{
        // Processes all cbSrc input bytes
        // Returns number of bytes written to lpbDst

        USHORT  cbDst;

#ifdef PORTABLE_CODE
   BYTE StateLen = lpState->len;
   BYTE StateCarry = lpState->carry;
   BYTE StateWidth = lpState->enc_width;
   USHORT SrcSize;
   BYTE InByte;
   LPBYTE CurrentSrc = lpbSrc;
   LPBYTE CurrentDst = lpbDst;
   ULONG EncodeWord;                //must be ULONG because value can be up to 17 bits


#ifdef CLASS1_TEST_HOOKS
   BYTE TstlpbDst[((USHORT)(((4 + 256 + 2) * 1.2) + 10))];     //Size = FRAMEBUFINITIALSIZE from framing.c
   ENCODESTATE TstState;
   LPENCODESTATE TstlpState = & TstState;
   USHORT TstcbDst;
   USHORT i;
   USHORT BadFlag = FALSE;
   CurrentDst = TstlpbDst;
#endif //CLASS1_TEST_HOOKS


   for (SrcSize = cbSrc; SrcSize > 0; SrcSize--) {
      InByte = *CurrentSrc++;
      EncodeWord = (((ULONG)EncOut[StateLen][InByte]) << StateWidth) | StateCarry;
      *CurrentDst++ = LOBYTE(EncodeWord);
      EncodeWord >>= 8;
      StateWidth += EncWidth[StateLen][InByte];
      StateLen = EncLen[StateLen][InByte];
      if (StateWidth < 8) {
         StateCarry = LOBYTE(EncodeWord);
      }
      else {
         *CurrentDst++ = LOBYTE(EncodeWord);
         StateCarry = HIBYTE(EncodeWord);
         StateWidth -= 8;
      }
   }

#ifdef CLASS1_TEST_HOOKS
   TstlpState->carry = StateCarry;
   TstlpState->enc_width = StateWidth;
   TstlpState->len = StateLen;
   TstcbDst = CurrentDst - TstlpbDst;
#else
   lpState->carry = StateCarry;
   lpState->enc_width = StateWidth;
   lpState->len = StateLen;
   cbDst = (USHORT)(CurrentDst - lpbDst);
#endif
#endif //PORTABLE_CODE




#ifdef  CLASS1_TEST_HOOKS
for (i = 0;( i < cbDst) && !BadFlag; i++) {
   if (lpbDst[i] != TstlpbDst[i]) {
      BadFlag = TRUE;
   }
}

if (BadFlag || (TstcbDst != cbDst) || (lpState->carry != TstlpState->carry) || (lpState->len != TstlpState->len) ||
   (lpState->enc_width != TstlpState->enc_width)){
   ERRORMSG(("HDLC_Encode: Assembly Encode != C Encode\n"));
   DebugBreak();
}
#endif //CLASS1_TEST_HOOKS

        return cbDst;
}


BYTE RotFlag[8] = { 0x7e, 0xfc, 0xf9, 0xf3, 0xe7, 0xcf, 0x9f, 0x3f };
BYTE LowBits[8] = { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f };






USHORT SWECMEXP HDLC_AddFlags(PThrdGlbl pTG, LPBYTE lpbDst, USHORT cbFlags, LPENCODESTATE lpState)
{
        USHORT i;

        // faxTlog((SZMOD "iAddF c=%02x w=%d l=%d\r\n", lpState->carry, lpState->enc_width, lpState->len));
        BG_CHK(lpState->enc_width < 8);

        *lpbDst         =  lpState->carry;
        *lpbDst++       |= (0x7E << lpState->enc_width);

        lpState->len = 0;
        lpState->carry = RotFlag[lpState->enc_width];
        // lpState->enc_width   is unchanged

        for(i=0; i<cbFlags-1; i++)
        {
                *lpbDst++ = lpState->carry;
        }
        // zap out high (8-width) bits of carry
        lpState->carry &= LowBits[lpState->enc_width];

        // faxTlog((SZMOD "xAddF c=%02x w=%d l=%d\r\n", lpState->carry, lpState->enc_width, lpState->len));
        return cbFlags;
}



BYTE CODEBASED EncLen[5][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 3 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 4 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 0 },
// Input Len = 3
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 1 },
// Input Len = 4
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 2 }

}; // Len


BYTE CODEBASED EncWidth[5][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2 },
// Input Len = 3
{0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 2,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 2 },
// Input Len = 4
{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 2, 1, 2, 1, 2 }

}; // W2

WORD CODEBASED EncOut[5][256] = {
// Input Len = 0
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x01f,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x02f,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x037,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x05f,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x047,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x04f,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x057,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x09f,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x067,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x06f,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x077,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0df,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x087,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x08f,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x097,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x11f,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x0a7,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x0af,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x0b7,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x15f,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x0c7,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x0cf,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x0d7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x19f,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x0e7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x0ef,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x0f7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1df },
// Input Len = 1
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x02f,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x04f,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x037,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x06f,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x047,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x08f,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x057,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x0af,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x067,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x0cf,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x077,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0ef,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x087,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x10f,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x097,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x12f,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x0a7,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x14f,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x0b7,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x16f,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x0c7,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x18f,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x0d7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x1af,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x0e7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x1cf,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x0f7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1ef },
// Input Len = 2
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x017,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x027,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x037,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x047,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x057,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x067,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x077,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x087,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x097,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x0a7,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x0b7,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x0c7,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x0d7,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x0e7,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0f7,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x107,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x117,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x127,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x137,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x147,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x157,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x167,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x177,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x187,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x197,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x1a7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x1b7,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x1c7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x1d7,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x1e7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1f7 },
// Input Len = 3
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x00b,
 0x008, 0x009, 0x00a, 0x013, 0x00c, 0x00d, 0x00e, 0x01b,
 0x010, 0x011, 0x012, 0x023, 0x014, 0x015, 0x016, 0x02b,
 0x018, 0x019, 0x01a, 0x033, 0x01c, 0x01d, 0x01e, 0x03b,
 0x020, 0x021, 0x022, 0x043, 0x024, 0x025, 0x026, 0x04b,
 0x028, 0x029, 0x02a, 0x053, 0x02c, 0x02d, 0x02e, 0x05b,
 0x030, 0x031, 0x032, 0x063, 0x034, 0x035, 0x036, 0x06b,
 0x038, 0x039, 0x03a, 0x073, 0x03c, 0x03d, 0x03e, 0x07b,
 0x040, 0x041, 0x042, 0x083, 0x044, 0x045, 0x046, 0x08b,
 0x048, 0x049, 0x04a, 0x093, 0x04c, 0x04d, 0x04e, 0x09b,
 0x050, 0x051, 0x052, 0x0a3, 0x054, 0x055, 0x056, 0x0ab,
 0x058, 0x059, 0x05a, 0x0b3, 0x05c, 0x05d, 0x05e, 0x0bb,
 0x060, 0x061, 0x062, 0x0c3, 0x064, 0x065, 0x066, 0x0cb,
 0x068, 0x069, 0x06a, 0x0d3, 0x06c, 0x06d, 0x06e, 0x0db,
 0x070, 0x071, 0x072, 0x0e3, 0x074, 0x075, 0x076, 0x0eb,
 0x078, 0x079, 0x07a, 0x0f3, 0x07c, 0x07d, 0x0be, 0x0fb,
 0x080, 0x081, 0x082, 0x103, 0x084, 0x085, 0x086, 0x10b,
 0x088, 0x089, 0x08a, 0x113, 0x08c, 0x08d, 0x08e, 0x11b,
 0x090, 0x091, 0x092, 0x123, 0x094, 0x095, 0x096, 0x12b,
 0x098, 0x099, 0x09a, 0x133, 0x09c, 0x09d, 0x09e, 0x13b,
 0x0a0, 0x0a1, 0x0a2, 0x143, 0x0a4, 0x0a5, 0x0a6, 0x14b,
 0x0a8, 0x0a9, 0x0aa, 0x153, 0x0ac, 0x0ad, 0x0ae, 0x15b,
 0x0b0, 0x0b1, 0x0b2, 0x163, 0x0b4, 0x0b5, 0x0b6, 0x16b,
 0x0b8, 0x0b9, 0x0ba, 0x173, 0x0bc, 0x0bd, 0x13e, 0x17b,
 0x0c0, 0x0c1, 0x0c2, 0x183, 0x0c4, 0x0c5, 0x0c6, 0x18b,
 0x0c8, 0x0c9, 0x0ca, 0x193, 0x0cc, 0x0cd, 0x0ce, 0x19b,
 0x0d0, 0x0d1, 0x0d2, 0x1a3, 0x0d4, 0x0d5, 0x0d6, 0x1ab,
 0x0d8, 0x0d9, 0x0da, 0x1b3, 0x0dc, 0x0dd, 0x0de, 0x1bb,
 0x0e0, 0x0e1, 0x0e2, 0x1c3, 0x0e4, 0x0e5, 0x0e6, 0x1cb,
 0x0e8, 0x0e9, 0x0ea, 0x1d3, 0x0ec, 0x0ed, 0x0ee, 0x1db,
 0x0f0, 0x0f1, 0x0f2, 0x1e3, 0x0f4, 0x0f5, 0x0f6, 0x1eb,
 0x0f8, 0x0f9, 0x0fa, 0x1f3, 0x17c, 0x17d, 0x1be, 0x2fb },
// Input Len = 4
{0x000, 0x001, 0x002, 0x005, 0x004, 0x009, 0x006, 0x00d,
 0x008, 0x011, 0x00a, 0x015, 0x00c, 0x019, 0x00e, 0x01d,
 0x010, 0x021, 0x012, 0x025, 0x014, 0x029, 0x016, 0x02d,
 0x018, 0x031, 0x01a, 0x035, 0x01c, 0x039, 0x01e, 0x03d,
 0x020, 0x041, 0x022, 0x045, 0x024, 0x049, 0x026, 0x04d,
 0x028, 0x051, 0x02a, 0x055, 0x02c, 0x059, 0x02e, 0x05d,
 0x030, 0x061, 0x032, 0x065, 0x034, 0x069, 0x036, 0x06d,
 0x038, 0x071, 0x03a, 0x075, 0x03c, 0x079, 0x03e, 0x07d,
 0x040, 0x081, 0x042, 0x085, 0x044, 0x089, 0x046, 0x08d,
 0x048, 0x091, 0x04a, 0x095, 0x04c, 0x099, 0x04e, 0x09d,
 0x050, 0x0a1, 0x052, 0x0a5, 0x054, 0x0a9, 0x056, 0x0ad,
 0x058, 0x0b1, 0x05a, 0x0b5, 0x05c, 0x0b9, 0x05e, 0x0bd,
 0x060, 0x0c1, 0x062, 0x0c5, 0x064, 0x0c9, 0x066, 0x0cd,
 0x068, 0x0d1, 0x06a, 0x0d5, 0x06c, 0x0d9, 0x06e, 0x0dd,
 0x070, 0x0e1, 0x072, 0x0e5, 0x074, 0x0e9, 0x076, 0x0ed,
 0x078, 0x0f1, 0x07a, 0x0f5, 0x07c, 0x0f9, 0x0be, 0x17d,
 0x080, 0x101, 0x082, 0x105, 0x084, 0x109, 0x086, 0x10d,
 0x088, 0x111, 0x08a, 0x115, 0x08c, 0x119, 0x08e, 0x11d,
 0x090, 0x121, 0x092, 0x125, 0x094, 0x129, 0x096, 0x12d,
 0x098, 0x131, 0x09a, 0x135, 0x09c, 0x139, 0x09e, 0x13d,
 0x0a0, 0x141, 0x0a2, 0x145, 0x0a4, 0x149, 0x0a6, 0x14d,
 0x0a8, 0x151, 0x0aa, 0x155, 0x0ac, 0x159, 0x0ae, 0x15d,
 0x0b0, 0x161, 0x0b2, 0x165, 0x0b4, 0x169, 0x0b6, 0x16d,
 0x0b8, 0x171, 0x0ba, 0x175, 0x0bc, 0x179, 0x13e, 0x27d,
 0x0c0, 0x181, 0x0c2, 0x185, 0x0c4, 0x189, 0x0c6, 0x18d,
 0x0c8, 0x191, 0x0ca, 0x195, 0x0cc, 0x199, 0x0ce, 0x19d,
 0x0d0, 0x1a1, 0x0d2, 0x1a5, 0x0d4, 0x1a9, 0x0d6, 0x1ad,
 0x0d8, 0x1b1, 0x0da, 0x1b5, 0x0dc, 0x1b9, 0x0de, 0x1bd,
 0x0e0, 0x1c1, 0x0e2, 0x1c5, 0x0e4, 0x1c9, 0x0e6, 0x1cd,
 0x0e8, 0x1d1, 0x0ea, 0x1d5, 0x0ec, 0x1d9, 0x0ee, 0x1dd,
 0x0f0, 0x1e1, 0x0f2, 0x1e5, 0x0f4, 0x1e9, 0x0f6, 0x1ed,
 0x0f8, 0x1f1, 0x0fa, 0x1f5, 0x17c, 0x2f9, 0x1be, 0x37d }

}; // Out
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\fdebug.h ===
/***************************************************************************
 Name     :     FDEBUG.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/****************** begin prototypes from debug.c *****************/
void InitCommErrCount(PThrdGlbl pTG);
extern void   far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs);
extern void   far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid);
extern void   far D_HexPrint(LPB b1, UWORD incnt);

#ifdef DEBUG
        void D_ChkMsg(LPSTR func, LPMSG lpmsg, UWORD wTimer, UWORD errevents, UWORD expected);
        void D_PrintIE(int err);        
        void D_PrintCE(int err);
        void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs);
        void D_PrintEvent(UWORD uwEvent);
        void D_FComCheck(PThrdGlbl pTG, LONG_PTR nCid);
        void D_FComDumpFlush(PThrdGlbl pTG, int nCid, int queue);
        void D_SafePrint(PThrdGlbl pTG, LPB b1, UWORD incnt);
        void D_PrintFrame(LPB npb, UWORD cb);
#else
#       define D_ChkMsg(f, l, t, er, ex)        {}
#       define D_PrintIE(err)                           {}
#       define D_PrintCE(err)                           {}
#       define D_PrintCOMSTAT(pTG, lpcs)                     {}
#       define D_PrintEvent(uwEvent)            {}
// #    define D_GotError(nCid, err, lpcs)      {}
#       define D_FComCheck(pTG, nCid)                        {}
// #    define D_FComPrint(nCid)                        {}
#       define D_FComDumpFlush(pTG, nCid, queue)     {}
#       define D_SafePrint(PTG, b1, incnt)           {}
// #    define D_HexPrint(b1, incnt)            {}
#       define D_PrintFrame(npb, cb)            {}
#endif
/***************** end of prototypes from debug.c *****************/



#ifndef MON3
#       define  PUTEVENT(wFlags, ID, SubID, dw0, dw1, lpsz) 0
#ifdef MON


#       define MONBUFSIZE       0x00010000L             // 65536 decimal

/****
#       define MONBUFSIZE       0x00004000L             // 16384 decimal
#       define CHKMONMASK       0x00003FFFL             // want it aligned to multiple of it's size
#       define WRAPMONMASK      (~(MONBUFSIZE)) // zap the 15th bit
****/
        extern void InitMonBufs(PThrdGlbl pTG);
        extern void PutMonBufs(PThrdGlbl pTG);
        extern void FreeMonBufs(PThrdGlbl pTG);

#ifdef MON2
#       define INMON(pTG, lpb, cb)   { lpbCurrIn = WrapCopy(pTG,lpbCurrIn,lpb,cb, lpbMonIn);             \
                                                          lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#       define OUTMON(pTG, lpb, cb)  { lpbCurrOut = WrapCopy(pTG,lpbCurrOut,lpb,cb, lpbMonOut);  \
                                                          lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#else //MON2
#       define INMON(pTG, lpb, cb)   { lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#       define OUTMON(pTG, lpb, cb)  { lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#endif //MON2

        extern LPBYTE   lpbCurrIn, lpbCurrOut, lpbCurrInOut;
        extern LPB              WrapCopy(PThrdGlbl pTG, LPB lpbDest, LPB lpbSrc, UWORD cbSrc, LPB lpbStart);
#else
#       define InitMonBufs()                            {}
#       define PutMonBufs()                                     {}
#       define FreeMonBufs()                            {}
#       define INMON(lpb, cb)   { }
#       define OUTMON(lpb, cb)  { }
#endif // MON
#endif //!MON3




#define SZMOD                   "FCom: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;
#endif

// #define ZONE_FRAMES          ((1L << 1) & dpCurSettings.ulZoneMask)
#define ZONE_FC                 ((1L << 2) & dpCurSettings.ulZoneMask)
#define ZONE_FC2                ((1L << 3) & dpCurSettings.ulZoneMask)
#define ZONE_FC3                ((1L << 4) & dpCurSettings.ulZoneMask)
#define ZONE_FC4                ((1L << 5) & dpCurSettings.ulZoneMask)
#define ZONE_MD                 ((1L << 6) & dpCurSettings.ulZoneMask)
#define ZONE_DIA                ((1L << 7) & dpCurSettings.ulZoneMask)

#define ZONE_FIL                ((1L << 9) & dpCurSettings.ulZoneMask)
#define ZONE_ID                 ((1L << 10) & dpCurSettings.ulZoneMask)
#define ZONE_ID2                        ((1L << 11) & dpCurSettings.ulZoneMask)

#define ZONE_DB                 ((1L << 12) & dpCurSettings.ulZoneMask)
#define ZONE_DB3                ((1L << 13) & dpCurSettings.ulZoneMask)
#define ZONE_TIMEOUT    ((1L << 14) & dpCurSettings.ulZoneMask)
#define ZONE_TO                 ((1L << 15) & dpCurSettings.ulZoneMask)

// #ifdef DEBUG
// #    define ST_FRAMES(x)     if(ZONE_FRAMES) { x; }
// #else
// #    define ST_FRAMES(x)     { }
// #endif



#define TRACE(m)                DEBUGMSG(1, m)

#define MODID                   MODID_MODEMDRV

#define FILEID_FCOM                     21
#define FILEID_FDEBUG           22
#define FILEID_FILTER           23
#define FILEID_IDENTIFY         24
#define FILEID_MODEM            25
#define FILEID_NCUPARMS         26
#define FILEID_TIMEOUTS         27
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\encoder.h ===
/***************************************************************************
 Name     :     ENCODER.H
 Comment  :     HDLC encoding structs

        Copyright (c) Microsoft Corp. 1991 1992 1993

***************************************************************************/

#ifdef WIN32
#       define CODEBASED
#else
#       define CODEBASED        __based(__segname("_CODE"))
#endif

#ifdef SWECM
#       define SWECMEXP _export FAR PASCAL
#else
#       define SWECMEXP
#endif


USHORT SWECMEXP HDLC_Encode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, LPENCODESTATE lpState);
USHORT SWECMEXP HDLC_AddFlags(PThrdGlbl pTG, LPBYTE lpbDst, USHORT cbFlags, LPENCODESTATE lpState);

/******
#define HDLC_End(lpbDst, lpState)                                                                       \
        {       (lpState)->len = 0;                                                                                     \
                *lpbDst = (lpState)->carry;                                                                     \
                *lpbDst++ |= (0xFF << ((lpState)->enc_width));                                  \
                (lpState)->carry = (lpState)->enc_width = 0; }
******/

#define InitEncoder(pTG, State)      { State.carry=State.enc_width=State.len=0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\class1\framing.c ===
/***************************************************************************
 Name     :     FRAMING.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"

#include "encoder.h"
#include "decoder.h"

#include "class1.h"
#include "debug.h"


#include "glbproto.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_SWFRAME, m)
#define         faxT2log(m)             DEBUGMSG(ZONE_SWFRAME2, m)
#define         FILEID                  FILEID_FRAMING


#ifdef DEBUG
#       define  ST_SWFRAME2(x)                  if(ZONE_SWFRAME2) { x; }
#else
#       define  ST_SWFRAME2(x)                  { }
#endif



BOOL FramingBufSetup(PThrdGlbl pTG, BOOL fOn);








BOOL SWFramingSendSetup(PThrdGlbl pTG, BOOL fOn)
{
        // If fOn=TRUE, Check that Recv framing is not ON.
        // Can't use Recv and Send framing simultaneously
        BG_CHK(!(fOn && pTG->Class1Modem.fRecvSWFraming));

        if(fOn)
        {
                BG_CHK(!pTG->Class1Modem.fSendSWFraming);
        }
        else if(!pTG->Class1Modem.fSendSWFraming)
        {
                TRACE((SZMOD "<<WARNING>> SWFramingSendSetup(FALSE) called when not inited. Ignoring\r\n"));
                return TRUE;
        }

        if(!FramingBufSetup(pTG, fOn))
                return FALSE;

        pTG->Class1Modem.fSendSWFraming = fOn;
        InitEncoder(pTG, pTG->Framing.EncodeState);
        return TRUE;
}













BOOL SWFramingRecvSetup(PThrdGlbl pTG, BOOL fOn)
{
        // if fOn=TRUE Check that Send framing is not ON.
        // Can't use Recv and Send framing simultaneously
        BG_CHK(!(fOn && pTG->Class1Modem.fSendSWFraming));

        if(fOn)
        {
                BG_CHK(!pTG->Class1Modem.fRecvSWFraming);
        }
        else if(!pTG->Class1Modem.fRecvSWFraming)
        {
                TRACE((SZMOD "<<WARNING>> SWFramingRecvSetup(FALSE) called when not inited. Ignoring\r\n"));
                return TRUE;
        }

        if(!FramingBufSetup(pTG, fOn))
                return FALSE;

        pTG->Class1Modem.fRecvSWFraming = fOn;
        InitDecoder(pTG, pTG->Framing.DecodeState);
        return TRUE;
}








BOOL FramingBufSetup(PThrdGlbl pTG, BOOL fOn)
{
        // UWORD uwJunk;

        if(fOn)
        {
#ifdef SMM
                pTG->Framing.lpbBuf = pTG->bStaticFramingBuf;
                pTG->Framing.cbBufSize = FRAMEBUFINITIALSIZE;
#else
#error NYI ERROR: Code Not Complete--Have to pick GMEM_ flags (FIXED? SHARE?)
                ...also have to call IFProcSetResFlags(hinstMe).....
                BG_CHK(pTG->Framing.lpbBuf==0);
                if(!(pTG->Framing.lpbBuf = IFMemAlloc(0, FRAMEBUFINITIALSIZE, &uwJunk)))
                {
                        ERRMSG((SZMOD "<<ERROR>> Out of global memory!!));
                        // iModemSetError(MODEMERR_RESOURCES, ERR_OUT_OF_MEMORY, 0);
                        return FALSE;
                }
                pTG->Framing.cbBufSize = uwJunk;
#endif
        }
        else
        {
                BG_CHK(fOn == FALSE);
#ifndef SMM
                BG_CHK(pTG->Framing.lpbBuf);
                IFMemFree(pTG->Framing.lpbBuf);
#endif
                pTG->Framing.lpbBuf = 0;
                pTG->Framing.cbBufSize = 0;
        }
        pTG->Framing.cbBufCount = 0;
        pTG->Framing.lpbBufSrc = pTG->Framing.lpbBuf;
        pTG->Framing.swEOF = 0;
        return TRUE;
}










BOOL SWFramingSendFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount, USHORT uFlags)
{
        WORD    wCRC;
        USHORT  cbDst;

        (MyDebugPrint(pTG, LOG_ALL, "iSW: lpb=%08lx c=%d f=%02x ", lpb, uCount, uFlags, lpb[0]));

        // always DLE-stuff here. Never zero-stuff
        BG_CHK(uFlags & SEND_ENDFRAME);
        BG_CHK(lpb && uCount);

        BG_CHK(uCount <= 260);  // can add stuff to realloc the Dst buffer
                                                                // to a bigger one as needed here

        wCRC = CalcCRC(pTG, lpb, uCount);
        faxT2log((SZMOD "CRC=%04x ", wCRC));

        cbDst = HDLC_Encode(pTG, lpb, uCount, pTG->Framing.lpbBuf, &pTG->Framing.EncodeState);
        faxT2log((SZMOD "D1=%d ", cbDst));

        cbDst += HDLC_Encode(pTG, (LPB)(&wCRC), 2, pTG->Framing.lpbBuf+cbDst, &pTG->Framing.EncodeState);
        faxT2log((SZMOD "D2=%d\r\n", cbDst));

        BG_CHK(cbDst + pTG->ModemParams.InterframeFlags <= pTG->Framing.cbBufSize);
        cbDst += HDLC_AddFlags(pTG, pTG->Framing.lpbBuf+cbDst, pTG->ModemParams.InterframeFlags, &pTG->Framing.EncodeState);
        faxT2log((SZMOD "D3=%d f=%02x l=%02x\r\n", cbDst, pTG->Framing.lpbBuf[0], pTG->Framing.lpbBuf[cbDst-1]));

        // always DLE-stuff here. Never zero-stuff
        if(!FComFilterAsyncWrite(pTG, pTG->Framing.lpbBuf, cbDst, FILTER_DLEONLY))
        {
                ERRMSG((SZMOD "<<ERROR>> DataWrite Timeout\r\n"));
                goto error;
        }

        if(uFlags & SEND_FINAL)
        {
                if(!SWFramingSendPostamble(pTG, pTG->Class1Modem.CurMod))
                        goto error;

#ifdef CL0
                if(pTG->ModemParams.Class == FAXCLASS0)
                {
                        if(!FComDirectAsyncWrite(pTG, bDLEETXOK, 8))
                                goto error;
                }
                else
#endif //CL0
                {
                        // if(!FComDirectAsyncWrite(bDLEETXCR, 3))
                        if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                                goto error;
                }

                if(!iModemDrain(pTG))
                        goto error;

                SWFramingSendSetup(pTG, FALSE);
                FComOutFilterClose(pTG);
            FComOverlappedIO(pTG, FALSE);
                FComXon(pTG, FALSE);         // critical. End of PhaseC
                EndMode(pTG);
        }
        return TRUE;

error:
        SWFramingSendSetup(pTG, FALSE);
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        FComXon(pTG, FALSE);                 // critical. End of PhaseC (err)
        EndMode(pTG);
        return FALSE;
}







BOOL SWFramingSendFlags(PThrdGlbl pTG, USHORT uHowMany)
{
        int cb, i;      // must be signed

        (MyDebugPrint(pTG, LOG_ALL,  "SENDING ECM Flags (%d).....\r\n", uHowMany));

        for(i=0, cb = uHowMany; cb>0; i++, cb -= pTG->Framing.cbBufSize)
        {
                if(i<=1)
                        HDLC_AddFlags(pTG, pTG->Framing.lpbBuf, pTG->Framing.cbBufSize, &pTG->Framing.EncodeState);

                // always DLE-stuff here. Never zero-stuff
                if(!FComFilterAsyncWrite(pTG, pTG->Framing.lpbBuf,(USHORT) min((USHORT)pTG->Framing.cbBufSize, (USHORT)cb), FILTER_DLEONLY))
                {
                        ERRMSG((SZMOD "<<ERROR>> PreFlagDataWrite Timeout\r\n"));
                        return FALSE;
                }
        }
        return TRUE;
}
















USHORT SWFramingRecvFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
        USHORT  cbDst, cbProduce, cbConsume, uRet;
        LPB             lpbDst;

        (MyDebugPrint(pTG, LOG_ALL,  "iSW: Buf=%08lx Src=%08lx cbSrc=%d cbMax=%d\r\n", pTG->Framing.lpbBuf, pTG->Framing.lpbBufSrc, pTG->Framing.cbBufCount, cbMax));
/**/
        BG_CHK(pTG->Class1Modem.ModemMode == FRM);
        BG_CHK(pTG->Class1Modem.fRecvSWFraming);
        startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
/**/
        BG_CHK(lpb && cbMax && lpcbRecv);

        *lpcbRecv = 0;

        for(lpbDst=lpb, cbDst=cbMax ;; )
        {
                if(pTG->Framing.cbBufCount == 0)
                {
                        if(pTG->Framing.swEOF == 0)
                        {
                                pTG->Framing.lpbBufSrc = pTG->Framing.lpbBuf;
                                // 4th arg must be FALSE for Class1
                                pTG->Framing.cbBufCount = FComFilterReadBuf(pTG, pTG->Framing.lpbBufSrc, pTG->Framing.cbBufSize, &(pTG->Class1Modem.toRecv), FALSE, &pTG->Framing.swEOF);
                                faxT2log((SZMOD "f=%02x l=%02x\r\n", pTG->Framing.lpbBufSrc[0], pTG->Framing.lpbBufSrc[pTG->Framing.cbBufCount-1]));
                                if(pTG->Framing.swEOF == -1)
                                {

#ifdef CL0
                                        if(pTG->ModemParams.Class == FAXCLASS0)
                                        {
                                                TRACE((SZMOD "Got Class0 DLE-ETX\r\n"));
                                                pTG->Framing.swEOF = 1;
                                        }
                                        else
#endif //CL0
                                        {

                                                // See LONG comment under DDI.C ModemRecvData()
                                                // option (a)
                                                // ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Assuming END OF PAGE!!!\r\n"));
                                                // pTG->Framing.swEOF = 1;

                                                // option (b)
                                                ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Ignoring\r\n"));
                                                pTG->Framing.swEOF = 0;
                                        }
                                }
                                BG_CHK(pTG->Framing.swEOF == 0 || pTG->Framing.swEOF == 1 ||
                                                 pTG->Framing.swEOF == -2 || pTG->Framing.swEOF == -3);

                                // check for progress
                                BG_CHK(pTG->Framing.cbBufCount!=0 || pTG->Framing.swEOF!=0);
                        }
                        else
                        {
                                // pTG->Framing.swEOF != 0

                                BG_CHK(pTG->Framing.swEOF == 1 || pTG->Framing.swEOF == -2 || pTG->Framing.swEOF == -3);

                                if(cbDst != cbMax)
                                {
                                        ERRMSG((SZMOD "<<WARNING>> SWFramingRecv: Got EOF with partial frame %d bytes\r\n", cbMax-cbDst));
                                        ST_SWFRAME2(D_HexPrint(lpb, (USHORT)(cbMax-cbDst)));
                                        uRet = RECV_BADFRAME;
                                        goto done;
                                }


                                if(pTG->Framing.swEOF == 1)  // class1 eof
                                {
                                        SWFramingRecvSetup(pTG, FALSE);
                                        EndMode(pTG);
                                        uRet = RECV_EOF;
                                        goto done;
                                }
                                else if(pTG->Framing.swEOF < 0)      // error or timeout
                                {
                                        SWFramingRecvSetup(pTG, FALSE);
                                        EndMode(pTG);
                                        uRet = ((pTG->Framing.swEOF == -2) ? RECV_ERROR : RECV_TIMEOUT);
                                        goto done;
                                }
                        }
                }

                // cbDst=space left in destination                      lpbDst=start of space
                // pTG->Framing.cbBufCount=bytes left in source      pTG->Framing.lpbBufSrc=start of bytes

                cbConsume = HDLC_Decode(pTG, pTG->Framing.lpbBufSrc,(USHORT) min(pTG->Framing.cbBufCount, cbDst), lpbDst, &cbProduce, &pTG->Framing.DecodeState);
                BG_CHK(cbConsume <= pTG->Framing.cbBufCount && pTG->Framing.lpbBufSrc+cbConsume<=pTG->Framing.lpbBuf+pTG->Framing.cbBufSize);
                BG_CHK(cbProduce <= cbDst && lpbDst+cbProduce <= lpb+cbMax);


                faxT2log((SZMOD "iSW: C=%d P=%d fa=%d\r\n", cbConsume, cbProduce, pTG->Framing.DecodeState.flagabort));
                pTG->Framing.cbBufCount      -= cbConsume;
                pTG->Framing.lpbBufSrc       += cbConsume;
                cbDst   -= cbProduce;
                lpbDst  += cbProduce;

                // check for progress.
                BG_CHK(pTG->Framing.DecodeState.flagabort==FLAG ||           // exits below
                                        cbProduce || cbConsume ||                       // exits eventually
                                        pTG->Framing.cbBufCount==0);         // exits or continues above

                if(pTG->Framing.DecodeState.flagabort == FLAG)
                {
                        if((cbMax-cbDst)>=2 && (CalcCRC(pTG, lpb, (USHORT)(cbMax-cbDst)) == ((WORD)(~0xF0B8))) )
                        {
                                cbDst += 2;
                                if(cbMax <= cbDst)
                                {
                                        ERRMSG(("GOOD Frame BAD Length!! cbMax=%d cbDst=%d, lpb[0]=%02x lpb[1]=%02x, CRC=%04x\r\n",
                                                cbMax, cbDst, lpb[0], lpb[1], CalcCRC(pTG, lpb, (USHORT)(cbMax+2-cbDst))));
                                        BG_CHK(FALSE);  // can't get good frame of 0 length!
                                        // must return RECV_BADFRAME here otherwise we break.
                                        // In HDLC.C the (RECV_OK swRead==0) pair gets converted
                                        // to RECV_ERROR and we quit receiving. On some modems
                                        // this can happen often. See BUG#1684
                                        uRet = RECV_BADFRAME;
                                }
                                else
                                        uRet = RECV_OK;
                        }
                        else
                        {
                                BG_CHK(cbMax >= cbDst);
#ifdef DEBUG
                                if (cbMax-cbDst)
                                {
                                ERRMSG((SZMOD "<<WARNING>> BADFR: SWFrRecvFr: CbMax-cbDst = %d bytes\r\n", cbMax-cbDst));
                                }
#endif

                                ST_SWFRAME2(D_HexPrint(lpb, (USHORT)(cbMax-cbDst)));
                                uRet = RECV_BADFRAME;
                        }
                        goto done;
                }
                else if(pTG->Framing.DecodeState.flagabort == ABORT)
                {
                        lpbDst=lpb;     cbDst=cbMax;
                }
                else if(cbDst == 0)
                {
                        // bad frames can be very long
                        ERRMSG((SZMOD "<<WARNING>> SWFramingRecv: Overflow. Got %d chars -- no flag\r\n", cbMax));
                        uRet = RECV_BADFRAME;
                        goto done;
                }
        }

done:
        *lpcbRecv = cbMax-cbDst;
        (MyDebugPrint(pTG, LOG_ALL,  "xSW: uR=%d *lpcbR=%d\r\n", uRet, *lpcbRecv));
        return uRet;
}











/*********************

        ECM Preamble and PostAmble: In T.4 appendix A it says
        that the Preamble must be 200ms +/1 100ms of flags,
        and the postamble must be 50ms max.

        However we also have recving modems that don't know they
        are getting ECM and need the 6eols to tell them when to
        stop recving. Also some of them lose large chunks of data
        at the end of PhaseC due to "carrier squelch", i.e. whne
        they lose carrier, they throw away the contents of their
        recv buffer.

        To get 240ms of flags, just multiply CurMod by 3
        // #define SWFramingSendPreamble(b)     \
        //      (FComDirectAsyncWrite(b00EOL, 2), SWFramingSendFlags(b + b + b))

        Postamble must have *max* 50ms of flags, so let's say 30ms, which is
        9 flags at 2400 and 54 at 14400. Just multiply CurMod by (3/8)
        to get correct number of flags
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags((b+b+b) >> 3)
        but with carrier squelch and all that, so few may not be safe.
        Murata sends out 44 flags at 2400 baud on closing. So lets
        just send out 80ms (just CurMod flags)

        This is the 80ms postamble
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags(b)

        // Fix for DSI bug -- drops last 500 bytes or so ////
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags(600)

*********************/


BYTE                            b00EOL[3] = { 0x00, 0x80, 0 };
BYTE b6EOLs[10] = { 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00 };

BOOL SWFramingSendPreamble(PThrdGlbl pTG, USHORT uCurMod)
{
        BOOL fRet = TRUE;

#ifdef CL0
        if(pTG->ModemParams.Class != FAXCLASS0)
#endif //CL0
        {
                // fix bug#1762. DataRace modem misses leading EOL unless
                // preceded by some zeros, and it then chews up all data
                // until an EOL, thereby eating up part of the first frame
                SendZeros1(pTG, 100);
                fRet = fRet && FComDirectAsyncWrite(pTG, b00EOL, 2);
        }
        fRet = fRet && SWFramingSendFlags(pTG, (USHORT)(uCurMod + uCurMod + uCurMod));

        return fRet;
}











BOOL SWFramingSendPostamble(PThrdGlbl pTG, USHORT uCurMod)
{
        BYTE bZero[50];
        USHORT i;
        BOOL fRet = TRUE;

        // send 80ms of flags
        fRet &= SWFramingSendFlags(pTG, uCurMod);

#ifdef CL0
        if(pTG->ModemParams.Class != FAXCLASS0)
#endif //CL0
        {
                // then send 6EOLs
                fRet &= FComDirectAsyncWrite(pTG, b6EOLs, 9);

                // then send 250 or so 00s
                _fmemset(bZero, 0, 50);

                for (i=0; i<5; i++)
                        fRet &= FComDirectAsyncWrite(pTG, bZero, 50);

        }
        return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\fcomint.h ===
/***************************************************************************
        Name      :     FCOMINt.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define WRITEQUANTUM    (pTG->Comm.cbOutSize / 8)            // totally arbitrary

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03





#define FComGetError(pTG)                                                                                                          \
        { GetCommErrorNT ( pTG, (HANDLE) pTG->Comm.nCid, &pTG->Comm.CommErr, &(pTG->Comm.comstat));                    \
          if(pTG->Comm.CommErr) D_GotError(pTG, pTG->Comm.nCid, pTG->Comm.CommErr, &(pTG->Comm.comstat));\
                iModemSetError(pTG, MODEMERR_COMPORT, 0, 0); }

#ifdef WIN32 // WIN32 Overlapped I/O internal routines...
BOOL            ov_init(PThrdGlbl pTG);
BOOL            ov_deinit(PThrdGlbl pTG);
OVREC *         ov_get(PThrdGlbl pTG);
BOOL            ov_write(PThrdGlbl  pTG, OVREC *lpovr, LPDWORD lpdwcbWrote);
BOOL            ov_drain(PThrdGlbl pTG, BOOL fLongTO);
BOOL            ov_unget(PThrdGlbl pTG, OVREC *lpovr);
BOOL            iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO);
#endif // WIN32

        BOOL FComGetSettings(PThrdGlbl pTG, LPFCOMSETTINGS);
        BOOL FComSetSettings(PThrdGlbl pTG, LPFCOMSETTINGS);
// nothing
#define iModemSetError(pTG, a,b,c)

#ifdef WIN32
#       define MONINBASE
#       define MONOUTBASE
#       define MONINOUTBASE
#else
#       define MONINBASE        __based(__segname("_MONIN"))
#       define MONOUTBASE       __based(__segname("_MONOUT"))
#       define MONINOUTBASE     __based(__segname("_MONINOUT"))
#endif





/****************** begin prototypes from filter.c *****************/
/****************** end of prototypes from filter.c *****************/


/****************** begin prototypes from ncuparms.c *****************/
void iNCUParamsReset(PThrdGlbl pTG);
void FComInitGlobals(PThrdGlbl pTG);
/***************** end of prototypes from ncuparms.c *****************/

#ifdef DEBUG
# ifndef WIN32
#       define SLIPMULT         2
#       define SLIPDIV          2
# else
#       define SLIPMULT         1
#       define SLIPDIV          4
# endif
#       define BEFORESLEEP       DWORD t1, t2; t1=GetTickCount();
#       define AFTERSLEEP(x) t2=GetTickCount();                         \
                if((t2-t1) > (((x)*SLIPMULT)+((x)/SLIPDIV)))    \
                        DEBUGMSG(1, ("!!!SLEPT %ld. Wanted only %d!!!\r\n", (t2-t1), (x)));
#else
#       define BEFORESLEEP
#       define AFTERSLEEP(arg)
#endif

////////// Variables controlling Sleep ///////////
//
// Comm.fBG -- used only in WFW, because can't call DllSleep in FG!
// Comm.bDontYield -- enabled during T30 "critical" sections. In non-premptive
//                                              systems this should disable sleeping completely
//
//////////////////////////////////////////////////

// ACTIVESLICE defined in mysched.h
#define IDLESLICE       500




#if defined(WIN32) && defined(THREAD)
#       define MySleep(x)                                                                                                       \
                {BG_CHK(x);                                                                                                             \
                { BEFORESLEEP; Sleep(pTG->Comm.bDontYield?0:(x)); AFTERSLEEP(x); }}
// Note. Until 12/9/94, we used to call Sleep(1) if bDontYield as in :
//      if (Comm.bDontYield) { BEFORESLEEP; Sleep(1); AFTERSLEEP(x); }
#endif //WIN32 && THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\fcom.c ===
/***************************************************************************
        Name      :     FCOM.C
        Comment   :     Functions for dealing with Windows Comm driver

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "prep.h"


#include <comdevi.h>
#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


#ifdef MDRV                             // to check for conflicts
#include "..\class1\class1.h"
#endif
#include <filet30.h>    // for registry info.

///RSL
#include "t30gl.h"
#include "glbproto.h"



#ifdef ADAPTIVE_ANSWER
#       pragma message("Compiling with ADAPTIVE_ANSWER")
#endif

#ifdef DEBUG
        void d_TimeStamp(LPSTR lpsz, DWORD dwID);
#       define TIMESTAMP(str, id)\
                d_TimeStamp(str, (DWORD)(id))
#else // !DEBUG
#       define TIMESTAMP(str, id)
#endif // !DEBUG


// in ms
#define  TIME_CONTROL     50



#ifdef DEBUG
#       define ST_FC(x)         if(ZONE_FC) { x; }
#else
#       define ST_FC(x)         { }
#endif

#define faxTlog(m)              DEBUGMSG(ZONE_FC, m)
#define faxT2log(m)             DEBUGMSG(ZONE_FC2, m)
#define faxT3log(m)             DEBUGMSG(ZONE_FC3, m)
#define faxT4log(m)             DEBUGMSG(ZONE_FC4, m)



/***------------- Local Vars and defines ------------------***/



#define LONG_DEADCOMMTIMEOUT                 60000L
#define SHORT_DEADCOMMTIMEOUT                10000L

#define WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT   120000
#define WAIT_FCOM_FILTER_READBUF_TIMEOUT     120000


// don't want DEADCOMMTIMEOUT to be greater than 32767, so make sure
// buf sizes are always 9000 or less. maybe OK.

#ifdef WIN32
// Our COMM timeout settings, used in call to SetCommTimeouts. These
// values (expect read_interval_timeout) are the default values for
// Daytona NT Beta 2, and seem to work fine..
#define READ_INTERVAL_TIMEOUT                           100
#define READ_TOTAL_TIMEOUT_MULTIPLIER           0
#define READ_TOTAL_TIMEOUT_CONSTANT                     0
#define WRITE_TOTAL_TIMEOUT_MULTIPLIER          0
#define WRITE_TOTAL_TIMEOUT_CONSTANT            LONG_DEADCOMMTIMEOUT
#endif

#define         CTRL_P          0x10
#define         CTRL_Q          0x11
#define         CTRL_S          0x13



#define MYGETCOMMERROR_FAILED 117437834L







BOOL   FComDTR(PThrdGlbl pTG, BOOL fEnable)
{
        (MyDebugPrint(pTG, LOG_ALL, "FComDTR = %d\r\n", fEnable));

        if(MyGetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        (MyDebugPrint(pTG, LOG_ALL, "FaxDTR Before: %02x\r\n", pTG->Comm.dcb.fDtrControl));
        pTG->Comm.dcb.fDtrControl = (fEnable ? DTR_CONTROL_ENABLE : DTR_CONTROL_DISABLE);

        if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        (MyDebugPrint(pTG, LOG_ALL, "After: %02x\r\n", pTG->Comm.dcb.fDtrControl));

        return TRUE;

error:
        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> FaxDTR --- Can't Set/Get DCB\r\n"));
        FComGetError(pTG);
        return FALSE;
}










BOOL   FComClose(PThrdGlbl pTG)
{
        // Note: even if FComClose fails, pTG->Comm.nCid, pTG->Comm.fCommOpen,
        //                                      and pTG->Comm.fExternalHandle are all reset.
        int nRet;       // MUST be 16bit in WIN16 and 32bit in WIN32
        BOOL fRet = TRUE;

        (MyDebugPrint(pTG, LOG_ALL, "Closing Comm pTG->Comm.nCid=%d\r\n", pTG->Comm.nCid));

        //
        // handoff
        //
        if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) {
            My2ndCloseComm(pTG->Comm.nCid, &nRet);
            goto lEnd;
        }


        ST_FC(D_FComCheck(pTG, pTG->Comm.nCid));

#if 1
        // We flush our internal buffer here...
        if (pTG->Comm.lpovrCur)
        {
                int nNumWrote; // Must be 32bits in WIN32
                if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
                {
                   // error...
                   (MyDebugPrint(pTG,  LOG_ERR, "FComClose: 1st ov_write failed at %ld\n", GetTickCount() ));

                }
                BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                          || pTG->Comm.lpovrCur->eState==eIO_PENDING);
                pTG->Comm.lpovrCur=NULL;
                (MyDebugPrint(pTG,  LOG_ALL, "FComClose: done writing mybuf.\r\n"));
        }
        
        ov_drain(pTG, FALSE);
#endif


#ifdef METAPORT
        if (1) // RSL pTG->Comm.fExternalHandle)
        {
                // Here we will restore settings to what it was when we
                // took over the port. Currently (9/23/94) we (a) restore the
                // DCB to pTG->Comm.dcbOrig and (b) If DTR was originally ON,
                // try to sync the modem to
                // the original speed by issueing "AT" -- because unimodem does
                // only a half-hearted attempt at synching before giving up.

#ifdef ADAPTIVE_ANSWER
                if(pTG->Comm.fStateChanged && (!pTG->Comm.fEnableHandoff || !pTG->Comm.fDataCall))
#else // !ADAPTIVE_ANSWER
                if(pTG->Comm.fStateChanged)
#endif // !ADAPTIVE_ANSWER
                {
                        if (MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcbOrig)))
                        {
                                (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> FComClose --- Couldn't restor state.  Err=0x%lx\r\n",
                                                (unsigned long) GetLastError()));
                        }

                        (MyDebugPrint(pTG,  LOG_ALL, "FComClose restored DCB to Baud=%d, fOutxCtsFlow=%d, fDtrControl=%d, fOutX=%d\n",
                                  pTG->Comm.dcbOrig.BaudRate,
                                  pTG->Comm.dcbOrig.fOutxCtsFlow,
                                  pTG->Comm.dcbOrig.fDtrControl,
                                  pTG->Comm.dcbOrig.fOutX));


                        pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcbOrig.BaudRate;

                        if (pTG->Comm.dcbOrig.fDtrControl==DTR_CONTROL_ENABLE)
                        {


                                // Try to pre-sync modem at new speed before we hand
                                // it back to TAPI. Can't call iiSyncModemDialog here because
                                // it's defined at a higher level. We don't really care
                                // to determine if we get an OK response anyway...

#define AT              "AT"
#define cr              "\r"

#define  iSyncModemDialog2(pTG, s, l, w1, w2)                                                        \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

                                if (!iSyncModemDialog2(pTG, AT cr,sizeof(AT cr)-1,"OK", "0")) {
                                   (MyDebugPrint(pTG,  LOG_ERR, "ERROR: couldn't sync AT command at %ld\n"), GetTickCount() );
                                }
                                else {
                                   (MyDebugPrint(pTG,  LOG_ERR, "Sync AT command OK at %ld\n"), GetTickCount() );

                                   // We flush our internal buffer here...
                                   if (pTG->Comm.lpovrCur)
                                   {
                                           int nNumWrote; // Must be 32bits in WIN32
                                           if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
                                           {
                                                // error...
                                                (MyDebugPrint(pTG,  LOG_ERR, "FComClose: 2nd ov_write failed at %ld\n", GetTickCount() ));
                                           }
                                           BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                                                     || pTG->Comm.lpovrCur->eState==eIO_PENDING);
                                           pTG->Comm.lpovrCur=NULL;
                                           (MyDebugPrint(pTG,  LOG_ALL, "FComClose: done writing mybuf.\r\n"));
                                   }
                                   
                                   ov_drain(pTG, FALSE);

                                }

                        }
                }
                pTG->Comm.fStateChanged=FALSE;
#ifdef ADAPTIVE_ANSWER
                pTG->Comm.fDataCall=FALSE;
#endif // ADAPTIVE_ANSWER

        }
        // RSL else
#endif // METAPORT
        {



                (MyDebugPrint(pTG, LOG_ALL, "Closing Comm pTG->Comm.nCid=%d. \n", pTG->Comm.nCid));
                // FComDTR(pTG, FALSE);         // drop DTR before closing port

                My2ndCloseComm(pTG->Comm.nCid, &nRet);
                if(nRet)
                {
                        DEBUGSTMT(D_PrintIE(nRet));
                        FComGetError(pTG);
                        fRet=FALSE;
                }
        }


#ifndef MON3 //!MON3
#ifdef MON
        PutMonBufs(pTG);
#endif
#endif //!MON3


lEnd:

#ifdef WIN32
        if (pTG->Comm.ovAux.hEvent) CloseHandle(pTG->Comm.ovAux.hEvent);
        _fmemset(&pTG->Comm.ovAux, 0, sizeof(pTG->Comm.ovAux));
        ov_deinit(pTG);
#endif

        pTG->Comm.nCid = (-1);
        pTG->Comm.fCommOpen = FALSE;

#ifdef METAPORT
        pTG->Comm.fExternalHandle=FALSE;
#endif

#ifdef WIN32
        pTG->Comm.fDoOverlapped=FALSE;
#endif

        return fRet;
}












/////////////////////////////////////////////////////////////////////////////////////////////
BOOL
T30ComInit  (
            PThrdGlbl pTG,
            HANDLE   hComm
            )
{

        if (pTG->fCommInitialized) {
           goto lSecondInit;
        }


        pTG->Comm.fDataCall=FALSE;

#ifdef METAPORT
        BG_CHK(!pTG->Comm.fCommOpen && !pTG->Comm.fExternalHandle && !pTG->Comm.fStateChanged);
#endif
        BG_CHK(!pTG->Comm.ovAux.hEvent);



                (MyDebugPrint(pTG, LOG_ALL, "Opening Comm Port=%x\r\n", hComm));

                pTG->CommCache.dwMaxSize = 4096;

                ClearCommCache(pTG);
                pTG->CommCache.fReuse = 0;

                (MyDebugPrint(pTG, LOG_ALL, "OPENCOMM:: bufs in=%d out=%d\r\n", COM_INBUFSIZE, COM_OUTBUFSIZE));


                pTG->Comm.nCid = (LONG_PTR) hComm;


                if(pTG->Comm.nCid < 0)
                {
                        (MyDebugPrint(pTG, LOG_ERR, "OPENCOMM failed. nRet=%d\r\n", pTG->Comm.nCid));
                        //DEBUGSTMT(D_PrintIE(pTG->Comm.nCid));
                        goto error;
                }

                (MyDebugPrint(pTG, LOG_ALL, "OPENCOMM succeeded nCid=%d\r\n", pTG->Comm.nCid));
                pTG->Comm.fCommOpen = TRUE;

                pTG->Comm.cbInSize = COM_INBUFSIZE;
                pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

        // Reset Comm timeouts...
        {
                COMMTIMEOUTS cto;
                _fmemset(&cto, 0, sizeof(cto));


                // Out of curiosity, see what they are set at currently...
                if (!GetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto))
                {
                        (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> GetCommTimeouts fails for handle=0x%lx\r\n",
                                (unsigned long) pTG->Comm.nCid));
                }
                else
                {
                        (MyDebugPrint(pTG,  LOG_ALL, "GetCommTimeouts: cto={%lu, %lu, %lu, %lu, %lu}\r\n",
                                (unsigned long) cto.ReadIntervalTimeout,
                                (unsigned long) cto.ReadTotalTimeoutMultiplier,
                                (unsigned long) cto.ReadTotalTimeoutConstant,
                                (unsigned long) cto.WriteTotalTimeoutMultiplier,
                                (unsigned long) cto.WriteTotalTimeoutConstant));
                }


                cto.ReadIntervalTimeout =  READ_INTERVAL_TIMEOUT;
                cto.ReadTotalTimeoutMultiplier =  READ_TOTAL_TIMEOUT_MULTIPLIER;
                cto.ReadTotalTimeoutConstant =  READ_TOTAL_TIMEOUT_CONSTANT;
                cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
                cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
                if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto))
                {
                        (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> SetCommTimeouts fails for handle=0x%lx\r\n",
                                (unsigned long) pTG->Comm.nCid));
                }
        }

        pTG->Comm.fCommOpen = TRUE;

        pTG->Comm.cbInSize = COM_INBUFSIZE;
        pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

        _fmemset(&(pTG->Comm.comstat), 0, sizeof(COMSTAT));

        if(MyGetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error2;

#ifdef METAPORT
        pTG->Comm.dcbOrig = pTG->Comm.dcb; // structure copy.
        pTG->Comm.fStateChanged=TRUE;
#endif



lSecondInit:


        // Use of 2400/ 8N1 and 19200 8N1 is not actually specified
        // in Class1, but seems to be adhered to be universal convention
        // watch out for modems that break this!

        if (pTG->SerialSpeedInit) {
           pTG->Comm.dcb.BaudRate = pTG->SerialSpeedInit;
        }
        else {
           pTG->Comm.dcb.BaudRate = 19200;     // default              
        }

        pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcb.BaudRate;

        pTG->Comm.dcb.ByteSize       = 8;
        pTG->Comm.dcb.Parity         = NOPARITY;
        pTG->Comm.dcb.StopBits               = ONESTOPBIT;

        pTG->Comm.dcb.fBinary                = 1;
        pTG->Comm.dcb.fParity                = 0;

        /************************************
                Pins assignments, & Usage

                Protective Gnd                                  --              1
                Transmit TxD (DTE to DCE)               3               2
                Recv     RxD (DCE to DTE)               2               3
                RTS (Recv Ready--DTE to DCE)    7               4
                CTS (TransReady--DCE to DTE)    8               5
                DSR                      (DCE to DTE)           6               6
                signal ground                                   5               7
                CD                       (DCE to DTR)           1               8
                DTR                      (DTE to DCE)           4               20
                RI                       (DCE to DTE)           9               22

                Many 9-pin adaptors & cables use only 6 pins, 2,3,4,5, and 7.
                We need to worry about this because some modems actively
                        use CTS, ie. pin 8.
                We don't care about RI and CD (Unless a really weird modem
                uses CD for flow control). We ignore DSR, but some (not so
                weird, but not so common either) modems use DSR for flow
                control.

                Thought :: Doesn't generate DSR. Seems to tie CD and CTS together
                DOVE    :: Generates only CTS. But the Appletalk-9pin cable
                                   only passes 1-5 and pin 8.
                GVC             :: CTS, DSR and CD
        ************************************/

                // CTS -- dunno. There is some evidence that the
                // modem actually uses it for flow control
        
        
        if (pTG->fEnableHardwareFlowControl) {
           pTG->Comm.dcb.fOutxCtsFlow = 1;      // Using it hangs the output sometimes...
        }
        else {
           pTG->Comm.dcb.fOutxCtsFlow = 0;
        }
                                                                                // Try ignoring it and see if it works?
        pTG->Comm.dcb.fOutxDsrFlow = 0;      // Never use this??

        pTG->Comm.dcb.fRtsControl    = RTS_CONTROL_ENABLE;   // Current code seems to leave this ON
        pTG->Comm.dcb.fDtrControl    =  (pTG->Comm.fExternalHandle)
                                                          ?     pTG->Comm.dcbOrig.fDtrControl
                                                          :     DTR_CONTROL_DISABLE;
                                                          // If external handle, we preserve the
                                                          // previous state, else we
                                                          // keep it off until we need it.

        pTG->Comm.dcb.fErrorChar             = 0;
        pTG->Comm.dcb.ErrorChar              = 0;
        // Can't change this cause SetCommState() resets hardware.
        pTG->Comm.dcb.EvtChar                = ETX;          // set this when we set an EventWait

        pTG->Comm.dcb.fOutX          = 0;    // Has to be OFF during HDLC recv phase
        pTG->Comm.dcb.fInX           = 0;    // Will this do any good??
                                                                // Using flow-control on input is only a good
                                                                // idea if the modem has a largish buffer
        pTG->Comm.dcb.fNull          = 0;


        pTG->Comm.dcb.XonChar        = CTRL_Q;
        pTG->Comm.dcb.XoffChar       = CTRL_S;
        pTG->Comm.dcb.XonLim         = 100;                  // Need to set this when BufSize is set
        pTG->Comm.dcb.XoffLim        = 50;                   // Set this when BufSize is set
                // actually we *never* use XON/XOFF in recv, so don't worry about this
                // right now. (Later, when we have smart modems with large buffers, &
                // we are worried about our ISR buffer filling up before our windows
                // process gets run, we can use this). Some tuning will be reqd.
        pTG->Comm.dcb.EofChar                = 0;

        pTG->Comm.dcb.fAbortOnError  = 0;   // RSL don't fail if minor problems

        if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error2;



        if (pTG->fCommInitialized) {
           return TRUE;
        }





#ifdef METAPORT
        pTG->Comm.fStateChanged=TRUE;
#endif

        MySetCommMask(pTG->Comm.nCid, 0);                            // all events off


        BG_CHK(!pTG->Comm.lpovrCur);
        pTG->Comm.lpovrCur=NULL;

        _fmemset(&pTG->Comm.ovAux,0, sizeof(pTG->Comm.ovAux));
        pTG->Comm.ovAux.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (pTG->Comm.ovAux.hEvent==NULL)
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> FComOpen: couldn't create event\r\n"));
                goto error2;
        }
        if (!ov_init(pTG))
        {
                CloseHandle(pTG->Comm.ovAux.hEvent);
                pTG->Comm.ovAux.hEvent=0;
                goto error2;
        }


        return TRUE;

error:
        //DEBUGSTMT(D_PrintIE(pTG->Comm.nCid));        
error2:
        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> FComOpen failed\r\n"));
        FComGetError(pTG);
        if (pTG->Comm.fCommOpen)
        {
                FComClose(pTG);
                BG_CHK(!pTG->Comm.fCommOpen);
#ifdef METAPORT
                BG_CHK(!pTG->Comm.fExternalHandle && !pTG->Comm.fStateChanged);
#endif
        }
        return FALSE;
}













BOOL   FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate)
{
        TRACE(("Setting BAUDRATE=%d\r\n", uwBaudRate));

        if(MyGetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        pTG->Comm.dcb.BaudRate  = uwBaudRate;
        pTG->CurrentSerialSpeed = uwBaudRate;

        if(MySetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        return TRUE;

error:
        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> Set Baud Rate --- Can't Get/Set DCB\r\n"));
        FComGetError(pTG);
        return FALSE;
}









BOOL FComInXOFFHold(PThrdGlbl pTG)
{
        int     err;    // _must_ be 32bits in Win32 

        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
        DEBUGSTMT(if(err)       D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat)););


#ifndef WIN32
        BG_CHK(!(pTG->Comm.comstat.status &
                                (CSTF_CTSHOLD|CSTF_DSRHOLD|CSTF_RLSDHOLD)));
        if((pTG->Comm.comstat.status & CSTF_XOFFHOLD) != 0)
#else //!WIN32
        BG_CHK(!(pTG->Comm.comstat.fCtsHold || pTG->Comm.comstat.fDsrHold || pTG->Comm.comstat.fRlsdHold));
        if(pTG->Comm.comstat.fXoffHold)
#endif //!WIN32
        {
                (MyDebugPrint(pTG,  LOG_ALL, "In XOFF hold\r\n"));
                return TRUE;
        }
        else
                return FALSE;
}










BOOL   FComXon(PThrdGlbl pTG, BOOL fEnable)
{

         if (pTG->fEnableHardwareFlowControl) {
            (MyDebugPrint(pTG, LOG_ALL, "FComXon = %d IGNORED : h/w flow control \r\n", fEnable));
            return TRUE;
         }


        (MyDebugPrint(pTG, LOG_ALL, "FComXon = %d\r\n", fEnable));

// enables/disables flow control
// returns TRUE on success, false on failure


        if(MyGetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        (MyDebugPrint(pTG, LOG_ALL, "FaxXon Before: %02x\r\n", pTG->Comm.dcb.fOutX));

        pTG->Comm.dcb.fOutX  = fEnable;

        if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
                goto error;

        (MyDebugPrint(pTG, LOG_ALL, "After: %02x\r\n", pTG->Comm.dcb.fOutX));
        return TRUE;

error:
        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> FaxXon --- Can't Set/Get DCB\r\n"));
        FComGetError(pTG);
        return FALSE;
}

















void   FComFlushQueue(PThrdGlbl pTG, int queue)
{
        int     nRet;
        DWORD   lRet;

        (MyDebugPrint(pTG, LOG_ALL, "FlushQue = %d\r\n", queue));
        ST_FC(D_FComCheck(pTG, pTG->Comm.nCid));
//RSL        ST_FC(D_FComDumpFlush(pTG, pTG->Comm.nCid, queue));
        BG_CHK(queue == 0 || queue == 1);

        if (queue == 1) {

            MyDebugPrint(pTG, LOG_ALL, "ClearCommCache in FComFlushQueue\n");
            ClearCommCache(pTG);

        }

        if(nRet = MyFlushComm(pTG->Comm.nCid, queue))
        {
                DEBUGSTMT(D_PrintIE(nRet));
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> FlushComm failed nRet=%d\r\n", nRet));
                FComGetError(pTG);
                // Throwing away errors that happen here.
                // No good reason for it!
        }
        if(queue == 1)
        {
                FComInFilterInit(pTG);
        }
        else // (queue == 0)
        {

                // Let's dump any stuff we may have in *our* buffer.
                if (pTG->Comm.lpovrCur && pTG->Comm.lpovrCur->dwcb)
                {
                        (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> FComFlushQueue:"
                                        "Clearing NonNULL pTG->Comm.lpovrCur->dwcb=%lx\r\n",
                                        (unsigned long) pTG->Comm.lpovrCur->dwcb));
                        pTG->Comm.lpovrCur->dwcb=0;
                        ov_unget(pTG, pTG->Comm.lpovrCur);
                        pTG->Comm.lpovrCur=NULL;
                }

                // Lets "drain" -- should always return immediately, because
                // we have just purged the output comm buffers.
                if (pTG->Comm.fovInited) {
                        BEFORECALL("FLUSH:ov_drain");
                        ov_drain(pTG, FALSE);
                        AFTERCALL("FLUSH:ov_drain",0);
                }

                // just incase it got stuck due to a mistaken XOFF
                if(lRet = MySetXON(pTG->Comm.nCid))
                {
                        // Returns the comm error value CE!!
                        // DEBUGSTMT(D_PrintIE(nRet));
                        TRACE(("EscapeCommFunc(SETXON) returned %d\r\n", lRet));
                        FComGetError(pTG);
                }
        }
}




#ifdef NTF

#define EV_ALL (EV_BREAK|EV_CTS|EV_CTSS|EV_DSR|EV_ERR|EV_PERR|EV_RING|EV_RLSD \
                                |EV_DSRS|EV_RLSDS|EV_RXCHAR|EV_RXFLAG|EV_TXEMPTY|EV_RINGTE)


#define         ALWAYSEVENTS    (EV_BREAK | EV_ERR)

        // errors + TXEMPTY. Ignore incoming chars
#define         DRAINEVENTS             (ALWAYSEVENTS | EV_TXEMPTY)
        // errors and TXEMPTY (also an error!)
#define         WRITEEVENTS             (ALWAYSEVENTS | EV_TXEMPTY)
        // errors and RXCHAR
#define         READLINEEVENTS  (ALWAYSEVENTS | EV_RXCHAR)
        // errors and RXFLAG (EvtChar already set to ETX)
#define         READBUFEVENTS   (ALWAYSEVENTS | EV_RXFLAG)

















BOOL FComEnableNotify(PThrdGlbl pTG, UWORD uwInTrig, UWORD uwOutTrig, UWORD events)
{
        HANDLE  h;

        // Used incrementally, so don't clear events!
        faxT4log(("EnableCommNotif(hwnd=%d uwIn=%d uwOUt=%d events=%d)\r\n", pTG->FComModem.hwndNotify, uwInTrig, uwOutTrig, events));
        h = pTG->FComModem.hwndNotify;

        if(!h)
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> Can't set Notif -- hwnd=%d\r\n", h));
                return TRUE;    // Continue anyway
        }


        if((pTG->Comm.lpEventWord = SetCommEventMask(pTG, pTG->Comm.nCid, events)) &&
                EnableCommNotification(pTG, pTG->Comm.nCid, h, uwInTrig, uwOutTrig))
        {
                // Both return non-zero on success
                faxT4log(("ECN succ: %d %d %d %d\r\n", pTG->Comm.nCid, h, uwInTrig, uwOutTrig));
                return TRUE;
        }
        else
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> ECN fail: %d %d %d %d\r\n", pTG->Comm.nCid, h, uwInTrig, uwOutTrig));
                FComGetError(pTG);
                return FALSE;
        }
}
#endif  // NTF













/***************************************************************************
        Name      :     FComDrain(BOOL fLongTO, BOOL fDrainComm)
        Purpose   :     Drain internal buffers. If fDrainComm, wait for Comm
                                ISR Output buffer to drain.
                                Returns when buffer is drained or if no progress is made
                                for DRAINTIMEOUT millisecs. (What about XOFFed sections?
                                Need to set     Drain timeout high enough)
        Parameters:
        Returns   :     TRUE on success (buffer drained)
                                FALSE on failure (error or timeout)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it in a new incarnation
***************************************************************************/

// This timeout has to be low at time and high at others. We want it low
// so we don't spend too much time trying to talk to a non-existent modem
// during Init/Setup. However in PhaseC, when the timer expires all we
// do is abort and kill everything. So it serves no purpose to make it
// too low. With the Hayes ESP FIFO card long stretches can elapse without
// any visible "progress", so we fail with that card because we think
// "no progress" is being made


//    So....make it short for init/install
// but not too short. Some cmds (e.g. AT&F take a long time)
// Used to be 800ms & seemed to work then, so leave it at that
#define SHORT_DRAINTIMEOUT      800

//    So....make it long for PhaseC
// 4secs should be about long enough
#define LONG_DRAINTIMEOUT       4000






BOOL   FComDrain(PThrdGlbl pTG, BOOL fLongTO, BOOL fDrainComm)
{
        WORD    wTimer = 0;
        UWORD   cbPrevOut = 0xFFFF;
        BOOL    fStuckOnce=FALSE;
        BOOL    fRet=FALSE;



        (MyDebugPrint(pTG, LOG_ALL, "Entering Drain\r\n"));


        ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));
        /** BG_CHK(uwCurrMsg == 0); **/


        // We flush our internal buffer here...
        if (pTG->Comm.lpovrCur)
        {
                int nNumWrote; // Must be 32bits in WIN32
                if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
                        goto done;
                BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                          || pTG->Comm.lpovrCur->eState==eIO_PENDING);
                pTG->Comm.lpovrCur=NULL;
                (MyDebugPrint(pTG,  LOG_ALL, "FComDrain: done writing mybuf.\r\n"));
        }

        if (!fDrainComm) {fRet=TRUE; goto done;}

        // +++ Here we drain all our overlapped events..
        // If we setup the system comm timeouts properly, we
        // don't need to do anything else, except for the XOFF/XON
        // stuff...
        fRet =  ov_drain(pTG, fLongTO);
        goto done;


done:

        return fRet;  //+++ was (cbOut == 0);
}














/***************************************************************************
        Name      :     FComDirectWrite(, lpb, cb)
        Purpose   :     Write cb bytes starting from lpb to pTG->Comm. If Comm buffer
                                is full, set up notifications and timers and wait until space
                                is available. Returns when all bytes have been written to
                                the Comm buffer or if no progress is made
                                for WRITETIMEOUT millisecs. (What about XOFFed sections?
                                Need to set     timeout high enough)
        Parameters:     , lpb, cb
        Returns   :     Number of bytes written, i.e. cb on success and <cb on timeout,
                                or error.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// This is WRONG -- see below!!
// totally arbitrary should be no more than the time as it would
// take to write WRITEQUANTUM out at the fastest speed
// (say 14400 approx 2 bytes/ms)
// #define      WRITETIMEOUT    min((WRITEQUANTUM / 2), 200)

// This timeout was too low. We wanted it low so we don't spend too much
// time trying to talk to a non-existent modem during Init/Setup. But in
// those cases we _never_ reach full buffer, so we don't wait here
// we wait in FComDrain(). Here we wait _only_ in PhaseC, so when the
// timer expires all we do is abort and kill everything. So it serves
// no purpose to make it too low. With the Hayes ESP FIFO card long
// stretches can elapse without any visible "progress", so we fail with
// that card because we think "no progress" is being made
//    So....make it long
// 2secs should be about long enough
#define         WRITETIMEOUT    2000


UWORD   FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb)
{
        DWORD   cbLeft = cb;

        (MyDebugPrint(pTG, LOG_ALL, "Entering (WIN32) DirectWrite(lpb=0x%08lx cb=%d)\r\n", lpb, cb));
        D_SafePrint(pTG, lpb, cb);
        ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));


        while(cbLeft)
        {
                DWORD dwcbCopy;
                DWORD dwcbWrote;
                int err;

                if (!pTG->Comm.lpovrCur)
                {
                        pTG->Comm.lpovrCur = ov_get(pTG);
                        if (!pTG->Comm.lpovrCur) goto error;
                        BG_CHK(!pTG->Comm.lpovrCur->dwcb);
                }
                BG_CHK(pTG->Comm.lpovrCur->eState==eALLOC);
                BG_CHK(OVBUFSIZE>=pTG->Comm.lpovrCur->dwcb);

                dwcbCopy = OVBUFSIZE-pTG->Comm.lpovrCur->dwcb;

                if (dwcbCopy>cbLeft) dwcbCopy = cbLeft;

                // Copy as much as we can to the overlapped buffer...
                _fmemcpy(pTG->Comm.lpovrCur->rgby+pTG->Comm.lpovrCur->dwcb, lpb, dwcbCopy);
                cbLeft-=dwcbCopy; pTG->Comm.lpovrCur->dwcb+=dwcbCopy; lpb+=dwcbCopy;

                // Let's always update comstat here...
                GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
                DEBUGSTMT(if(err)       D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat)););

                (MyDebugPrint(pTG,  LOG_ALL, "DirectWrite:: OutQ has %d fDoOverlapped=%d at %ld \n",
                    pTG->Comm.comstat.cbOutQue, pTG->Comm.fDoOverlapped, GetTickCount()));

                // We write to comm if our buffer is full or the comm buffer is
                // empty or if we're not in overlapped mode...
                if (!pTG->Comm.fDoOverlapped ||
                        pTG->Comm.lpovrCur->dwcb>=OVBUFSIZE || !pTG->Comm.comstat.cbOutQue)
                {
                        BOOL fRet = ov_write(pTG, pTG->Comm.lpovrCur, &dwcbWrote);
                        BG_CHK(    pTG->Comm.lpovrCur->eState==eIO_PENDING
                                        || pTG->Comm.lpovrCur->eState==eFREE);
                        pTG->Comm.lpovrCur=NULL;
                        if (!fRet) goto error;
                }

        } // while (cbLeft)

        return cb;

error:
        return 0;

}









/***************************************************************************
        Name      :     FComFilterReadLine(, lpb, cbSize, pto)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                                lpb. If Comm buffer is empty, set up notifications and timers
                                and wait until characters are available.

                                Filters out DLE characters. i.e DLE-DLE is reduced to
                                a single DLE, DLE ETX is left intact and DLE-X is deleted.

                                Returns success (+ve bytes count) when CR-LF has been
                                encountered, and returns failure (-ve bytes count).
                                when either (a) cbSize bytes have been read (i.e. buffer is
                                full) or (b) PTO times out or an error is encountered.

                                It is critical that this function never returns a
                                timeout, as long as data
                                is still pouring/trickling in. This implies two things
                                (a) FIRST get all that is in the InQue (not more than a
                                line, though), THEN check the timeout.
                                (b) Ensure that at least 1 char-arrival-time at the
                                slowest Comm speed passes between the function entry
                                point and the last time we check for a byte, or between
                                two consecutive checks for a byte, before we return a timeout.

                                Therefor conditions to return a timeout are Macro timeout
                                over and inter-char timeout over.

                                In theory the slowest speed we need to worry about is 2400,
                                because that's the slowest we run the Comm at, but be paranoid
                                and assume the modem sends the chars at the same speed that
                                they come in the wire, so slowest is now 300. 1 char-arrival-time
                                is now 1000 / (300/8) == 26.67ms.

                                If pto expires, returns error, i.e. -ve of the number of
                                bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                                of bytes read on timeout. 0 is a timeout error with no bytes
                                read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// totally arbitrary
#define         READLINETIMEOUT         50

#define         ONECHARTIME                     (30 * 2)                // see above *2 to be safe

// void WINAPI OutputDebugStr(LPSTR);
// char szJunk[200];




SWORD   FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead)
{
        WORD           wTimer = 0;
        UWORD          cbIn = 0, cbGot = 0;
        LPB            lpbNext;
        BOOL           fPrevDLE = 0;
        SWORD          i, beg;

        (MyDebugPrint(pTG, LOG_ALL, "in FilterReadLine(lpb=0x%08lx cb=%d timeout=%lu)\r\n", lpb, cbSize, lptoRead->ulTimeout));
        BG_CHK(cbSize>2);
        ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));

        cbSize--;               // make room for terminal NULL
        lpbNext = lpb;  // we write the NULL to *lpbNext, so init this NOW!
        cbGot = 0;              // return value (even err return) is cbGot. Init NOW!!
        fPrevDLE=0;


        //
        // check the cache first.
        //

        if ( ! pTG->CommCache.dwCurrentSize) {
            MyDebugPrint(pTG, LOG_ALL, "Cache is empty. Resetting comm cache.\n");

            ClearCommCache(pTG);

            if ( ! FComFilterFillCache(pTG, cbSize, lptoRead) ) {
                MyDebugPrint(pTG, LOG_ERR,  "ERROR: FillCache failed \n");
                goto error;
            }
        }

        while (1) {
            if ( ! pTG->CommCache.dwCurrentSize) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: Cache is empty after FillCache\n");
                goto error;
            }


            MyDebugPrint(pTG, LOG_ALL, "Cache: size=%d, offset=%d\n", pTG->CommCache.dwCurrentSize, pTG->CommCache.dwOffset);

            lpbNext = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset;

            if (pTG->CommCache.dwCurrentSize >= 3) {
                MyDebugPrint(pTG, LOG_ALL, "1=%x 2=%x 3=%x 4=%x 5=%x 6=%x 7=%x 8=%x 9=%x / %d=%x, %d=%x, %d=%x \n",
                   *lpbNext, *(lpbNext+1), *(lpbNext+2), *(lpbNext+3), *(lpbNext+4), *(lpbNext+5), *(lpbNext+6), *(lpbNext+7), *(lpbNext+8),
                   pTG->CommCache.dwCurrentSize-3, *(lpbNext+ pTG->CommCache.dwCurrentSize-3),
                   pTG->CommCache.dwCurrentSize-2, *(lpbNext+ pTG->CommCache.dwCurrentSize-2),
                   pTG->CommCache.dwCurrentSize-1, *(lpbNext+ pTG->CommCache.dwCurrentSize-1) );
            }
            else {
                MyDebugPrint(pTG, LOG_ALL, "1=%x 2=%x \n", *lpbNext, *(lpbNext+1) );
            }



            for (i=0, beg=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) {

               if (i > 0 ) {
                   if ( ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i - 1) == CR ) &&
                        ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i)     == LF ) )  {

                      if ( i - beg >= cbSize)  {

                         // line too long.  try next one.

                         MyDebugPrint(pTG, LOG_ERR, "Line len=%d is longer than bufsize=%d Found in cache pos=%d, CacheSize=%d, Offset=%d \n",
                                     i-beg, cbSize, i+1, pTG->CommCache.dwCurrentSize, pTG->CommCache.dwOffset);
                      beg = i + 1;
                      continue;
                      }

                      // found the line.

                      CopyMemory (lpb, (pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + beg), (i - beg + 1) );

                      pTG->CommCache.dwOffset += (i+1);
                      pTG->CommCache.dwCurrentSize -= (i+1);
                      *(lpb+i-beg+1) = 0;


                      MyDebugPrint(pTG, LOG_ALL, "Found in cache pos=%d, CacheSize=%d, Offset=%d \n",
                                  i+1, pTG->CommCache.dwCurrentSize, pTG->CommCache.dwOffset);


                      return ( i-beg+1 );


                   }
               }
            }



            // we get here if we didn't find CrLf in Cache

            MyDebugPrint(pTG, LOG_ALL, "Cache wasn't empty but we didn't find CrLf\n");

            // if cache too big (and we have not found anything anyway) --> clean it

            if (pTG->CommCache.dwCurrentSize >= cbSize) {
               MyDebugPrint(pTG, LOG_ALL, "ClearCommCache\n");
               ClearCommCache(pTG);
            }
            else if ( ! pTG->CommCache.dwCurrentSize) {
                   MyDebugPrint(pTG, LOG_ALL, "Cache is empty. Resetting comm cache.\n");
                   ClearCommCache(pTG);
            }


            if ( ! FComFilterFillCache(pTG, cbSize, lptoRead) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: FillCache failed \n");
                goto error;
            }
        }


error:
        ClearCommCache(pTG);
        return (0);

}



int  FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead)
{


    WORD             wTimer = 0;
    UWORD            cbGot = 0, cbAvail = 0;
    DWORD            cbRequested = 0;
    char             lpBuffer[4096];
    LPB              lpbNext;
    int              nNumRead;       // _must_ be 32 bits in Win32!!
    LPOVERLAPPED     lpOverlapped;
    COMMTIMEOUTS     cto;
    DWORD            dwLastErr;
    DWORD            dwTimeoutRead;
    char             *pSrc;
    char             *pDest;
    DWORD            i, j;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;

    HandlesArray[1] = pTG->AbortReqEvent;


    dwTimeoutRead = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);
    if (dwTimeoutRead < 0) {
        dwTimeoutRead = 0;
    }



    lpbNext = lpBuffer;


    (MyDebugPrint(pTG, LOG_ALL, "in FilterReadCache:  cb=%d to=%d\r\n",
                                             cbSize, dwTimeoutRead));

    // we want to request the read such that we will be back
    // no much later than dwTimeOut either with the requested
     // amount of data or without it.

    cbRequested = cbSize;


    // use COMMTIMEOUTS to detect there are no more data

    cto.ReadIntervalTimeout =  50;   // 30 ms is during negotiation frames; del(ff, 2ndchar> = 54 ms with USR 28.8
    cto.ReadTotalTimeoutMultiplier =  0;
    cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY
    cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
    cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
    if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: SetCommTimeouts fails for handle %lx , le=%x\n",
                    (unsigned long) pTG->Comm.nCid, GetLastError());
    }

    lpOverlapped =  &pTG->Comm.ovAux;

    (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                        (lpOverlapped)->OffsetHigh = 0;

    if ((lpOverlapped)->hEvent)
        ResetEvent((lpOverlapped)->hEvent);

    nNumRead = 0;

    MyDebugPrint(pTG, LOG_ALL, "Before ReadFile Req=%d time=%ld \n", cbRequested, GetTickCount() );

    if (! ReadFile( (HANDLE) pTG->Comm.nCid, lpbNext, cbRequested, &nNumRead, &pTG->Comm.ovAux) ) {
        if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) {

            //
            // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
            //

            if (pTG->fAbortRequested) {

                if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) {
                    MyDebugPrint(pTG,  LOG_ALL,  "FComFilterFillCache RESETTING AbortReqEvent at %lx\n",GetTickCount() );
                    pTG->fAbortReqEventWasReset = 1;
                    ResetEvent(pTG->AbortReqEvent);
                }

                pTG->fUnblockIO = 1;
            }

            HandlesArray[0] = pTG->Comm.ovAux.hEvent;

            if (pTG->fUnblockIO) {
                NumHandles = 1;
            }
            else {
                NumHandles = 2;
            }

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: FComFilterFillCache: WaitForMultipleObjects TIMEOUT at %ld\n", GetTickCount() );

                ClearCommCache(pTG);
                goto error;
            }


            if (WaitResult == WAIT_FAILED) {
                MyDebugPrint(pTG, LOG_ERR, "FComFilterFillCache: WaitForMultipleObjects FAILED le=%lx NumHandles=%d at %ld \n",
                                            GetLastError(), NumHandles, GetTickCount() );

                ClearCommCache(pTG);
                goto error;
            }

            if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) {
                pTG->fUnblockIO = 1;
                MyDebugPrint(pTG, LOG_ALL, "FComFilterFillCache ABORTed at %ld \n", GetTickCount() );
                ClearCommCache(pTG);
                goto error;
            }

            if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, &pTG->Comm.ovAux, &nNumRead, TRUE) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: GetOverlappedResult le=%x at %ld \n", GetLastError(), GetTickCount() );
                if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: ClearCommError le=%x at %ld \n", GetLastError(), GetTickCount() );
                }
                else {
                    MyDebugPrint(pTG, LOG_ERR, "ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d In=%d Out=%d \n",
                         dwErr, ErrStat.fCtsHold, ErrStat.fDsrHold, ErrStat.fRlsdHold, ErrStat.fXoffHold, ErrStat.fXoffSent, ErrStat.fEof,
                         ErrStat.fTxim, ErrStat.cbInQue, ErrStat.cbOutQue);
                }

                goto error;
            }
        }
        else {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: ReadFile le=%x \n", GetTickCount() );
            goto error;
        }
    }
    else {
        MyDebugPrint(pTG, LOG_ALL, "WARNING: ReadFile returned w/o WAIT\n");
    }

    MyDebugPrint(pTG, LOG_ALL, "After ReadFile Req=%d Ret=%d time=%ld \n", cbRequested, nNumRead, GetTickCount() );


    cbAvail = (UWORD)nNumRead;

    if (!cbAvail) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: 0 read\n");
        goto error;
    }


    // filter DLE stuff

    pSrc  = lpbNext;
    pDest = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+ pTG->CommCache.dwCurrentSize;

    for (i=0, j=0; i<cbAvail; ) {

        if ( *(pSrc+i) == DLE)  {
            if ( *(pSrc+i+1) == DLE ) {
                *(pDest+j) =    DLE;
                j += 1;
                i += 2;
            }
            else if ( *(pSrc+i+1) == ETX ) {
                *(pDest+j) = DLE;
                *(pDest+j+1) = ETX;
                j += 2;
                i += 2;
            }
            else {
                i += 2;
            }
        }
        else {
            *(pDest+j) = *(pSrc+i);
            i++;
            j++;
        }
    }


    pTG->CommCache.dwCurrentSize += j;
    return TRUE;


error:
        return FALSE;

}






/***************************************************************************
        Name      :     FComDirectReadBuf(, lpb, cbSize, lpto, pfEOF)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                                lpb. If Comm buffer is empty, set up notifications and timers
                                and wait until characters are available.

                                Returns when success (+ve byte count) either (a) cbSize
                                bytes have been read or (b) DLE-ETX has been encountered
                                (in which case *pfEOF is set to TRUE).

                                Does no filtering. Reads the Comm buffer in large quanta.

                                If lpto expires, returns error, i.e. -ve of the number of
                                bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                                of bytes read on timeout. 0 is a timeout error with no bytes
                                read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// +++ #define          READBUFQUANTUM          (pTG->Comm.cbInSize / 8)
// totally arbitrary
// +++ #define  READBUFTIMEOUT                  200

// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout

UWORD   FComFilterReadBuf(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead, BOOL fClass2, LPSWORD lpswEOF)
{
        WORD             wTimer = 0;
        UWORD            cbGot = 0, cbAvail = 0;
        DWORD            cbRequested = 0;
        LPB              lpbNext;
        int              nNumRead;       // _must_ be 32 bits in Win32!!
        LPOVERLAPPED     lpOverlapped;
        COMMTIMEOUTS     cto;
        DWORD            dwLastErr;
        DWORD            dwTimeoutRead;
        DWORD            cbFromCache = 0;
        DWORD            dwErr;
        COMSTAT          ErrStat;
        DWORD            NumHandles=2;
        HANDLE           HandlesArray[2];
        DWORD            WaitResult;

        HandlesArray[1] = pTG->AbortReqEvent;


        dwTimeoutRead = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);
        if (dwTimeoutRead < 0) {
            dwTimeoutRead = 0;
        }

        (MyDebugPrint(pTG, LOG_ALL, "in FilterReadBuf: lpb=0x%08lx cb=%d to=%d\r\n",
                                                lpb, cbSize, dwTimeoutRead));

        BG_CHK((BOOL)pTG->Comm.dcb.fOutX == FALSE);
        // Dont want to take ^Q/^S from modem to
        // be XON/XOFF in the receive data phase!!

        // BG_CHK(lpb && cbSize>2 && lptoRead && lpswEOF && *lpswEOF == 0);
        BG_CHK(lpb && cbSize>3 && lptoRead && lpswEOF);

        *lpswEOF=0;

        ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));
        // BG_CHK(Filter.fStripDLE);    // Always on
        /** BG_CHK(uwCurrMsg == 0); **/

        // Leave TWO spaces at start to make sure Out pointer will
        // never get ahead of the In pointer in StripBuf, even
        // if the last byte of prev block was DLE & first byte
        // of this one is SUB (i.e need to insert two DLEs in
        // output).
        // Save a byte at end for the NULL terminator (Why? Dunno...)

        lpb += 2;
        cbSize -= 3;

        cbRequested = cbSize;


        for(lpbNext=lpb;;) {

            MyDebugPrint(pTG, LOG_ALL, "in FilterReadBuf LOOP cbSize=%d cbGot=%d cbAvail=%d at %ld\r\n",
                        cbSize, cbGot, cbAvail, GetTickCount() );

#if 0
            //
            // just in case. RSL 970123
            //

            if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: ClearCommError le=%x at %ld \n", GetLastError(), GetTickCount() );
            }
            else {
                MyDebugPrint(pTG, LOG_ERR, "ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d In=%d Out=%d \n",
                     dwErr, ErrStat.fCtsHold, ErrStat.fDsrHold, ErrStat.fRlsdHold, ErrStat.fXoffHold, ErrStat.fXoffSent, ErrStat.fEof,
                     ErrStat.fTxim, ErrStat.cbInQue, ErrStat.cbOutQue);
            }
#endif

            if((cbSize - cbGot) < cbAvail) {
                     cbAvail = cbSize - cbGot;
            }


            if( (!cbGot) && !checkTimeOut(pTG, lptoRead) ) {
                // No chars available *and* lptoRead expired
                MyDebugPrint(pTG, LOG_ERR, "ERROR: ReadLn:Timeout %ld-toRd=%ld start=%ld \n",
                        GetTickCount(), lptoRead->ulTimeout, lptoRead->ulStart);
                goto failure;
            }


            // check Comm cache first (AT+FRH leftovers)

            if ( pTG->CommCache.fReuse && pTG->CommCache.dwCurrentSize ) {
                MyDebugPrint(pTG, LOG_ALL, "CommCache will REUSE %d offset=%d 0=%x 1=%x \n",
                   pTG->CommCache.dwCurrentSize, pTG->CommCache.dwOffset,
                   *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset),
                   *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+1) );

                if ( pTG->CommCache.dwCurrentSize >= cbRequested)  {
                    CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbRequested);

                    pTG->CommCache.dwOffset +=  cbRequested;
                    pTG->CommCache.dwCurrentSize -=  cbRequested;

                    cbAvail =  (UWORD) cbRequested;
                    cbRequested = 0;

                    MyDebugPrint(pTG, LOG_ALL, "CommCache still left; no need to read\n");

                    goto l_merge;
                }
                else {
                    cbFromCache =  pTG->CommCache.dwCurrentSize;

                    CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbFromCache);

                    ClearCommCache(pTG);

                    cbRequested -= cbFromCache;

                    MyDebugPrint(pTG, LOG_ALL, "CommCache used all %d \n",  cbFromCache);
                }
            }



            // use COMMTIMEOUTS to detect there are no more data

            cto.ReadIntervalTimeout =  20;   // 0  RSL make 15 later
            cto.ReadTotalTimeoutMultiplier =  0;
            cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY
            cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
            cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
            if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto)) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: SetCommTimeouts fails for handle %lx , le=%x\n",
                            (unsigned long) pTG->Comm.nCid, GetLastError());
            }

            lpOverlapped =  &pTG->Comm.ovAux;

            (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                                (lpOverlapped)->OffsetHigh = 0;

            if ((lpOverlapped)->hEvent)
                ResetEvent((lpOverlapped)->hEvent);

            nNumRead = 0;

            MyDebugPrint(pTG, LOG_ALL, "Before ReadFile Req=%d time=%ld \n", cbRequested, GetTickCount() );

            if (! ReadFile( (HANDLE) pTG->Comm.nCid, lpbNext+cbFromCache, cbRequested, &nNumRead, &pTG->Comm.ovAux) ) {
                if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) {

                    // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
                    //

                    if (pTG->fAbortRequested) {

                        if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) {
                            MyDebugPrint(pTG,  LOG_ALL,  "FComFilterReadBuffer RESETTING AbortReqEvent at %lx\n",GetTickCount() );
                            pTG->fAbortReqEventWasReset = 1;
                            ResetEvent(pTG->AbortReqEvent);
                        }

                        pTG->fUnblockIO = 1;
                        *lpswEOF = -2;
                        return cbGot;

                    }

                    HandlesArray[0] = pTG->Comm.ovAux.hEvent;
                    HandlesArray[1] = pTG->AbortReqEvent;

                    if (pTG->fUnblockIO) {
                        NumHandles = 1;
                    }
                    else {
                        NumHandles = 2;
                    }

                    WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);

                    if (WaitResult == WAIT_TIMEOUT) {
                        MyDebugPrint(pTG, LOG_ERR, "ERROR: FComFilterReadBuf: WaitForMultipleObjects TIMEOUT at %ld\n", GetTickCount() );
                        ClearCommCache(pTG);

                        goto failure;
                    }


                    if (WaitResult == WAIT_FAILED) {
                        MyDebugPrint(pTG, LOG_ERR, "FComFilterReadBuf: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                                    GetLastError(), GetTickCount() );

                        ClearCommCache(pTG);

                        goto failure;

                    }

                    if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) {
                        pTG->fUnblockIO = 1;
                        MyDebugPrint(pTG, LOG_ALL, "FComFilterReadBuf ABORTed at %ld \n", GetTickCount() );
                        ClearCommCache(pTG);
                        *lpswEOF = -2;
                        return cbGot;
                    }

                    if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, &pTG->Comm.ovAux, &nNumRead, TRUE) ) {

                        MyDebugPrint(pTG, LOG_ERR, "ERROR: GetOverlappedResult le=%x at %ld \n", GetLastError(), GetTickCount() );
                        if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) {
                            MyDebugPrint(pTG, LOG_ERR, "ERROR: ClearCommError le=%x at %ld \n", GetLastError(), GetTickCount() );
                        }
                        else {
                            MyDebugPrint(pTG, LOG_ERR, "ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d In=%d Out=%d \n",
                                 dwErr, ErrStat.fCtsHold, ErrStat.fDsrHold, ErrStat.fRlsdHold, ErrStat.fXoffHold, ErrStat.fXoffSent, ErrStat.fEof,
                                 ErrStat.fTxim, ErrStat.cbInQue, ErrStat.cbOutQue);
                        }

                        goto failure;
                    }
                }
                else {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: ReadFile le=%x at %ld \n", dwLastErr, GetTickCount() );
                    goto failure;
                }
            }
            else {
                MyDebugPrint(pTG, LOG_ALL, "WARNING: ReadFile returned w/o WAIT\n");
            }

            MyDebugPrint(pTG, LOG_ALL, "After ReadFile Req=%d Ret=%d time=%ld \n", cbRequested, nNumRead, GetTickCount() );


            cbAvail = (UWORD) (nNumRead + cbFromCache);



l_merge:
            // RSL PUTBACK INMON(pTG, lpbNext, cbAvail);

            if(!cbAvail) {
                MyDebugPrint(pTG, LOG_ALL, "cbAvail = %d --> continue \n", cbAvail);
                continue;
            }
            // else we just drop through


            // try to catch COMM read problems

            MyDebugPrint(pTG, LOG_ALL, "DEBUG: Just read %d bytes, from cache =%d, log [%x .. %x], 1st=%x last=%x  \n",
                                        nNumRead, cbFromCache, pTG->CommLogOffset, (pTG->CommLogOffset+cbAvail),
                                        *lpbNext, *(lpbNext+cbAvail-1) );


            // RSL TEMP. Check T4 problems.

            if (gT30.T4LogLevel) {
                _lwrite(ghComLogFile, lpbNext, cbAvail);
            }

            pTG->CommLogOffset += cbAvail;



            cbAvail = FComStripBuf(pTG, lpbNext-2, lpbNext, cbAvail, fClass2, lpswEOF);
            BG_CHK(*lpswEOF == 0 || *lpswEOF == -1 || *lpswEOF == 1);

            MyDebugPrint(pTG, LOG_ALL, "After FComStripBuf cbAvail=%ld \n", cbAvail );


            cbGot += cbAvail;
            lpbNext += cbAvail;


            // RSL 970123. Dont wanna loop if got anything.

            if ( (*lpswEOF != 0) || (cbGot > 0) )    {   // some eof or full buf
                    goto done;
            }

        }
        BG_CHK(FALSE);


        *lpswEOF = -2;
        goto done;


failure:

        ;


//timeout:
        *lpswEOF = -3;
        // fall through to done


done:

        (MyDebugPrint(pTG, LOG_ALL,  "ex FilterReadBuf: cbGot=%d swEOF=%d\r\n", cbGot, *lpswEOF));
        return cbGot;
}














void   FComCritical(PThrdGlbl pTG, BOOL x)
{
        if (x)                                    pTG->Comm.bDontYield++;
        else if (pTG->Comm.bDontYield) pTG->Comm.bDontYield--;
        else                                      {BG_CHK(FALSE);}

#ifdef DEBUG
        if (pTG->Comm.bDontYield) {(MyDebugPrint(pTG, LOG_ALL,  "Exiting NESTED FComCritical\r\n"));}
#endif
}







#if !defined(WFW) && !defined(WFWBG)

BOOL   FComCheckRing(PThrdGlbl pTG)
{
        int     err;    // must be 32 bits in WIN32
        BOOL    fRet=0;
        COMSTAT comstatCheckActivity;

        BG_CHK(pTG->Comm.nCid >= 0);
        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &comstatCheckActivity);

        if(err)
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> NCUCheckRing: Got Comm Error %04x\r\n", err));
                D_GotError(pTG, pTG->Comm.nCid, err, &comstatCheckActivity);
        }


        fRet = (comstatCheckActivity.cbInQue > 0);

        // get rid of RING sitting in buffer,
        // or well wait until kingdom come with it
        // in some situations, like someone refuses to
        // answer or we have a full recv-filename-cache

        MyFlushComm(pTG->Comm.nCid, 0);
        MyFlushComm(pTG->Comm.nCid, 1);

        (MyDebugPrint(pTG, LOG_ALL,  "CheckRing: fRet=%d Q=%d\r\n", fRet, comstatCheckActivity.cbInQue));

        return fRet;
}

#endif //!WFWBG







BOOL
FComGetOneChar(
   PThrdGlbl pTG,
   UWORD ch
)

{
        BYTE             rgbRead[10];    // must be 3 or more. 10 for safety
        TO               toCtrlQ;
        int              nNumRead;               // _must_ be 32 bits in WIN32
        LPOVERLAPPED     lpOverlapped;
        DWORD            dwErr;
        COMSTAT          ErrStat;
        DWORD            NumHandles=2;
        HANDLE           HandlesArray[2];
        DWORD            WaitResult;
        DWORD            dwLastErr;
        SWORD            i;

        HandlesArray[1] = pTG->AbortReqEvent;

        //
        // check the cache first.
        //

        if ( ! pTG->CommCache.dwCurrentSize) {
            MyDebugPrint(pTG, LOG_ALL, "FComGetOneChar: Cache is empty. Resetting comm cache.\n");

            ClearCommCache(pTG);
        }
        else {
           for (i=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) {
              if ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i) == ch) {
                 // found in cache
                 
                 MyDebugPrint(pTG, LOG_ALL, "FComGetOneChar: Found XON in cache pos=%d total=%d\n", i, pTG->CommCache.dwCurrentSize);
                 
                 pTG->CommCache.dwOffset += (i+1);
                 pTG->CommCache.dwCurrentSize -= (i+1);

                 goto GotCtrlQ;

              }
           }

           MyDebugPrint(pTG, LOG_ALL, "FComGetOneChar: Cache wasn't empty. Didn't find XON. Resetting comm cache.\n");
           ClearCommCache(pTG);
        }




        // Send nothing - look for cntl-Q (XON) after connect
        BG_CHK(ch == 0x11);             // so far looking for just ctrlQ
        startTimeOut(pTG, &toCtrlQ, 1000);
        do
        {
                ////MyReadComm(Comm.nCid, rgbRead, 1, &nNumRead);

                lpOverlapped =  &pTG->Comm.ovAux;
    
                (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                                    (lpOverlapped)->OffsetHigh = 0;
    
                if ((lpOverlapped)->hEvent)
                    ResetEvent((lpOverlapped)->hEvent);
    
                nNumRead = 0;
    
                MyDebugPrint(pTG, LOG_ALL, "Before ReadFile Req=%d time=%ld \n", 1, GetTickCount() );

                if (! ReadFile( (HANDLE) pTG->Comm.nCid, rgbRead, 1, &nNumRead, &pTG->Comm.ovAux) ) {
                   if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) {
   
                       // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
                       //
   
                       if (pTG->fAbortRequested) {
   
                           if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) {
                               MyDebugPrint(pTG,  LOG_ALL,  "FComGetOneChar RESETTING AbortReqEvent at %lx\n",GetTickCount() );
                               pTG->fAbortReqEventWasReset = 1;
                               ResetEvent(pTG->AbortReqEvent);
                           }
   
                           pTG->fUnblockIO = 1;
                           goto error;
   
                       }
   
                       HandlesArray[0] = pTG->Comm.ovAux.hEvent;
                       HandlesArray[1] = pTG->AbortReqEvent;
   
                       if (pTG->fUnblockIO) {
                           NumHandles = 1;
                       }
                       else {
                           NumHandles = 2;
                       }
   
                       WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);
   
                       if (WaitResult == WAIT_TIMEOUT) {
                           MyDebugPrint(pTG, LOG_ERR, "ERROR: FComGetOneChar: WaitForMultipleObjects TIMEOUT at %ld\n", GetTickCount() );
                           ClearCommCache(pTG);
   
                           goto error;
                       }
   
   
                       if (WaitResult == WAIT_FAILED) {
                           MyDebugPrint(pTG, LOG_ERR, "FComGetOneChar: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                                       GetLastError(), GetTickCount() );
   
                           ClearCommCache(pTG);
   
                           goto error;
   
                       }
   
                       if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) {
                           pTG->fUnblockIO = 1;
                           MyDebugPrint(pTG, LOG_ALL, "FComGetOneChar ABORTed at %ld \n", GetTickCount() );
                           ClearCommCache(pTG);
                           goto error;
                       }
   
                       if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, &pTG->Comm.ovAux, &nNumRead, TRUE) ) {
   
                           MyDebugPrint(pTG, LOG_ERR, "ERROR: FComGetOneChar GetOverlappedResult le=%x at %ld \n", GetLastError(), GetTickCount() );
                           if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) {
                               MyDebugPrint(pTG, LOG_ERR, "ERROR: FComGetOneChar ClearCommError le=%x at %ld \n", GetLastError(), GetTickCount() );
                           }
                           else {
                               MyDebugPrint(pTG, LOG_ERR, "FComGetOneChar ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d In=%d Out=%d \n",
                                    dwErr, ErrStat.fCtsHold, ErrStat.fDsrHold, ErrStat.fRlsdHold, ErrStat.fXoffHold, ErrStat.fXoffSent, ErrStat.fEof,
                                    ErrStat.fTxim, ErrStat.cbInQue, ErrStat.cbOutQue);
                           }
   
                           goto error;
                       }
                   }
                   else {
                       MyDebugPrint(pTG, LOG_ERR, "ERROR: FComGetOneChar ReadFile le=%x at %ld \n", dwLastErr, GetTickCount() );
                       goto error;
                   }
               }
               else {
                   MyDebugPrint(pTG, LOG_ALL, "WARNING: FComGetOneChar ReadFile returned w/o WAIT\n");
               }
   
               MyDebugPrint(pTG, LOG_ALL, "After FComGetOneChar ReadFile Req=%d Ret=%d time=%ld \n", 1, nNumRead, GetTickCount() );


                switch(nNumRead)
                {
                case 0: break;          // loop until we get something
                case 1: // INMON(rgbRead, 1);
                        if(rgbRead[0] == ch)
                                goto GotCtrlQ;
                        else
                        {
                                ERRMSG(("<<ERROR>> GetCntlQ: Found non ^Q char\n\r"));
                                goto error;
                        }
                default:
                        BG_CHK(FALSE);
                        goto error;
                }
        }
        while(checkTimeOut(pTG, &toCtrlQ));
        ////ERRMSG(("<<ERROR>> GetCntlQ: Timed out\n\r"));
        goto error;

GotCtrlQ:
        ////TRACE(("GetCntlQ: YES!!! Found cntl q\n\r"));
        return TRUE;

error:
        return FALSE;
}







/*****
#ifdef USE_HWND
#       define MyGetMessage(x)                                                                                  \
          ( GetMessage(&x, NULL, 0, 0),                                                                 \
            (x.hwnd ? (DispatchMessage(&x), x.message=WM_NULL) : 0),    \
            (x.message != WM_QUIT) )

#       define MyPeekMessage(x)                                                                                         \
          ( (x.message=WM_NULL),                                                                                        \
                ( PeekMessage(&x, NULL, 0, 0, PM_RNOY) ?                                                \
                        (x.hwnd ? (DispatchMessage(&x), x.message=WM_NULL) : TRUE)      \
                          : FALSE ) )
#else

#       define MyGetMessage(x)   (      GetMessage(&x, NULL, 0, 0),                     \
                                                                BG_CHK(x.hwnd==0),                                      \
                                                                (x.message != IF_QUIT) )

#       define MyPeekMessage(x)  (      (x.message = WM_NULL),                                  \
                                                                PeekMessage(&x, NULL, 0, 0, PM_RNOY),   \
                                                                BG_CHK(x.hwnd==0),                                      \
                                                                (x.message != WM_NULL) )
#endif
*****/







#ifdef MDRV
extern void iModemParamsReset(PThrdGlbl pTG);
extern void iModemInitGlobals(PThrdGlbl pTG);
#endif



#define szMODULENAME    "awfxio32"







OVREC *ov_get(PThrdGlbl pTG)
{
        OVREC   *lpovr=NULL;

        (MyDebugPrint(pTG,  LOG_ALL, "In ov_get at %ld \n",  GetTickCount() ) );

        if (!pTG->Comm.covAlloced)
        {
                BG_CHK(!pTG->Comm.uovLast && !pTG->Comm.uovFirst);
                lpovr = pTG->Comm.rgovr;
                BG_CHK(lpovr->eState==eFREE);
                BG_CHK(!(lpovr->dwcb));
        }
        else
        {
                UINT uNewLast = (pTG->Comm.uovLast+1) % NUM_OVS;

                (MyDebugPrint(pTG,  LOG_ALL, "iov_flush: 1st=%d, last=%d \n", pTG->Comm.uovFirst, pTG->Comm.uovLast) );

                lpovr = pTG->Comm.rgovr+uNewLast;
                if (uNewLast != pTG->Comm.uovFirst)
                {
                        BG_CHK(lpovr->eState==eFREE);
                }
                else
                {
                        BG_CHK(lpovr->eState==eIO_PENDING);
                        if (!iov_flush(pTG, lpovr, TRUE))
                        {
                                BG_CHK(lpovr->eState==eALLOC);
                                ov_unget(pTG, lpovr);
                                lpovr=NULL; // We fail if a flush operation failed...
                        }
                        else
                        {
                                BG_CHK(lpovr->eState==eALLOC);
                                pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
                        }
                }
                if (lpovr) pTG->Comm.uovLast = uNewLast;
        }
        if (lpovr && lpovr->eState!=eALLOC)
        {
                BG_CHK(lpovr->eState==eFREE && !lpovr->dwcb);
                BG_CHK(pTG->Comm.covAlloced < NUM_OVS);
                pTG->Comm.covAlloced++;
                lpovr->eState=eALLOC;
        }
        return lpovr;
}








BOOL ov_unget(PThrdGlbl pTG, OVREC *lpovr)
{
        BOOL fRet = FALSE;

        (MyDebugPrint(pTG,  LOG_ALL, "In ov_UNget lpovr=%lx at %ld \n", lpovr, GetTickCount() ) );


        if (lpovr->eState!=eALLOC ||
                !pTG->Comm.covAlloced || lpovr!=(pTG->Comm.rgovr+pTG->Comm.uovLast))
        {
                (MyDebugPrint(pTG,  LOG_ERR, "ov_unget: invalid lpovr.\r\n"));
                BG_CHK(FALSE);
                goto end;
        }

        BG_CHK(!lpovr->dwcb);

        if (pTG->Comm.covAlloced==1)
        {
                BG_CHK(pTG->Comm.uovLast == pTG->Comm.uovFirst);
                pTG->Comm.uovLast = pTG->Comm.uovFirst = 0;
        }
        else
        {
                pTG->Comm.uovLast = (pTG->Comm.uovLast)?  (pTG->Comm.uovLast-1) : (NUM_OVS-1);
        }
        pTG->Comm.covAlloced--;
        lpovr->eState=eFREE;
        fRet = TRUE;

end:
        return fRet;
}











BOOL ov_write(PThrdGlbl pTG, OVREC *lpovr, LPDWORD lpdwcbWrote)
{
        // Write out the buffer associated with lpovr.
        BG_CHK(lpovr->eState==eALLOC);
        if (!lpovr->dwcb)
        {
                ov_unget(pTG, lpovr);
                lpovr=NULL;
        }
        else
        {
                BOOL fRet;
                DWORD dw;
                int err;
                OVERLAPPED *lpov = &(lpovr->ov);


                DWORD cbQueue;

                BG_CHK(lpovr->dwcb<=OVBUFSIZE);
                pTG->Comm.comstat.cbOutQue += lpovr->dwcb;


                GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));

                if(err)  {

                    (MyDebugPrint(pTG,  LOG_ERR, "ov_write GetCommError failed \n") );
                    D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
                }

                cbQueue = pTG->Comm.comstat.cbOutQue;


                OUTMON(pTG, lpovr->rgby, (USHORT)lpovr->dwcb);
                {
                        BEFORECALL;
                        INTERCALL("Write");

                        ( MyDebugPrint(pTG,  LOG_ALL, "Before WriteFile lpb=%x, cb=%d lpovr=%lx at %ld \n",
                              lpovr->rgby, lpovr->dwcb, lpovr,  GetTickCount() ) );

                        if (!(fRet = WriteFile((HANDLE)pTG->Comm.nCid, lpovr->rgby, lpovr->dwcb,
                                                                 lpdwcbWrote, lpov)))
                        {
                                dw=GetLastError();
                        }
                        AFTERCALL("Write",*lpdwcbWrote);

                        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));

                        if(err) {
                            (MyDebugPrint(pTG,  LOG_ERR, "ov_write GetCommError failed \n") );
                            D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
                        }

                        (MyDebugPrint(pTG,  LOG_ALL, "Queue before=%lu; after = %lu. n= %lu, *pn=%lu\r\n",
                                                        (unsigned long) cbQueue,
                                                        (unsigned long) (pTG->Comm.comstat.cbOutQue),
                                                        (unsigned long) lpovr->dwcb,
                                                        (unsigned long) *lpdwcbWrote));

                }
                if (fRet)
                {
                        // Write operation completed
                        (MyDebugPrint(pTG,  LOG_ALL, "WARNING: WriteFile returned w/o wait %ld\n", GetTickCount() ) );

                        OVL_CLEAR( lpov);
                        lpovr->dwcb=0;
                        ov_unget(pTG, lpovr);
                        lpovr=NULL;
                }
                else
                {
                        if (dw==ERROR_IO_PENDING)
                        {
                                (MyDebugPrint(pTG,  LOG_ALL, "WriteFile returned PENDING at %ld\n", GetTickCount() ));
                                *lpdwcbWrote = lpovr->dwcb; // We set *pn to n on success else 0.
                                lpovr->eState=eIO_PENDING;
                        }
                        else
                        {
                                (MyDebugPrint(pTG,  LOG_ERR, "WriteFile returns error 0x%lx",
                                                (unsigned long) dw));
                                OVL_CLEAR(lpov);
                                lpovr->dwcb=0;
                                ov_unget(pTG, lpovr);
                                lpovr=NULL;
                                goto error;
                        }
                }
        }

        BG_CHK(!lpovr || lpovr->eState==eIO_PENDING);
        return TRUE;

error:

        BG_CHK(!lpovr);
        return FALSE;
}










BOOL ov_drain(PThrdGlbl pTG, BOOL fLongTO)
{
        BOOL fRet = TRUE;
        UINT u = pTG->Comm.covAlloced;

        while(u--)
        {
                OVREC *lpovr = pTG->Comm.rgovr+pTG->Comm.uovFirst;
                OVERLAPPED *lpov = &(lpovr->ov);

                if (lpovr->eState==eIO_PENDING)
                {
                        if (!iov_flush(pTG, lpovr, fLongTO)) fRet=FALSE;
                        BG_CHK(lpovr->eState==eALLOC);
                        lpovr->eState=eFREE;
                        BG_CHK(pTG->Comm.covAlloced);
                        pTG->Comm.covAlloced--;
                        pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
                }
                else
                {
                        // Only the newest (last) structure can be still in the
                        // allocated state.
                        BG_CHK(lpovr->eState==eALLOC && !u);
                        BG_CHK(pTG->Comm.lpovrCur == lpovr); // Ugly check
                        (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> ov_drain:"
                                        " called when alloc'd structure pending\r\n"));

                }

        }

        if (!pTG->Comm.covAlloced) pTG->Comm.uovFirst=pTG->Comm.uovLast=0;
        else
        {
                BG_CHK(   pTG->Comm.covAlloced==1
                           && pTG->Comm.uovFirst==pTG->Comm.uovLast
                           && pTG->Comm.uovFirst<NUM_OVS
                           && pTG->Comm.rgovr[pTG->Comm.uovFirst].eState==eALLOC);
        }

        return fRet;
}














BOOL ov_init(PThrdGlbl pTG)
{
        UINT u;
        OVREC *lpovr = pTG->Comm.rgovr;

        // init overlapped structures, including creating events...
        if (pTG->Comm.fovInited)
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> ov_init: we're *already* inited.\r\n>>",
                                        (unsigned long) (pTG->Comm.covAlloced)));
                BG_CHK(FALSE);
                ov_deinit(pTG);
        }

        BG_CHK(!pTG->Comm.fovInited && !pTG->Comm.covAlloced);

        for (u=0;u<NUM_OVS;u++,lpovr++) {
                OVERLAPPED *lpov = &(lpovr->ov);
                BG_CHK(lpovr->eState==eDEINIT);
                BG_CHK(!(lpovr->dwcb));
                _fmemset(lpov, 0, sizeof(OVERLAPPED));
                lpov->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                if (lpov->hEvent==NULL)
                {
                        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> ov_init: couldn't create event #%lu\r\n",
                                                (unsigned long) u));
                        goto failure;
                }
                lpovr->eState=eFREE;
                lpovr->dwcb=0;
        }

        pTG->Comm.fovInited=TRUE;

        return TRUE;

failure:
        BG_CHK(!pTG->Comm.fovInited);
        while (u--)
          {--lpovr; CloseHandle(lpovr->ov.hEvent); lpovr->eState=eDEINIT;}
        return FALSE;

}
















BOOL ov_deinit(PThrdGlbl pTG)
{
        UINT u=NUM_OVS;
        OVREC *lpovr = pTG->Comm.rgovr;

        if (!pTG->Comm.fovInited)
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> ov_deinit: Already deinited.\r\n"));
                goto end;
        }


        //
        // if handoff ==> dont flush
        //
        if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) {
            goto lNext;
        }

        // deinit overlapped structures, including freeing events...
        if (pTG->Comm.covAlloced)
        {
                DWORD dw;
                (MyDebugPrint(pTG,  LOG_ERR, "<<WARNING>> ov_deinit: %lu IO's pending.\r\n",
                                (unsigned long) pTG->Comm.covAlloced));
                if (pTG->Comm.lpovrCur) {ov_write(pTG, pTG->Comm.lpovrCur,&dw); pTG->Comm.lpovrCur=NULL;}
                ov_drain(pTG, FALSE);
        }
        BG_CHK(!pTG->Comm.covAlloced);



lNext:

        while (u--)
        {
                BG_CHK(!(lpovr->dwcb));
                BG_CHK(lpovr->eState==eFREE);
                lpovr->eState=eDEINIT;
                if (lpovr->ov.hEvent) CloseHandle(lpovr->ov.hEvent);
                _fmemset(&(lpovr->ov), 0, sizeof(lpovr->ov));
                lpovr++;
        }

        pTG->Comm.fovInited=FALSE;

end:
        return TRUE;
}

















BOOL iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO)
// On return, state of lpovr is *always* eALLOC, but
// it returns FALSE if there was a comm error while trying
// to flush (i.e. drain) the buffer.
// If we timeout with the I/O operation still pending, we purge
// the output buffer and abort all pending write operations.
{
        DWORD dwcbPrev;
        DWORD dwStart = GetTickCount();
        BOOL  fRet=FALSE;
        DWORD dw;
        int err;


        (MyDebugPrint(pTG,  LOG_ALL, "In iov_flush fLongTo=%d lpovr=%lx at %ld \n", fLongTO, lpovr, GetTickCount() ) );


        BG_CHK(lpovr->eState==eIO_PENDING);

        if (pTG->Comm.nCid<0) {lpovr->eState=eALLOC; goto end;}

        // We call
        // WaitForSingleObject multiple times ... basically
        // the same logic as the code in the old FComDirectWrite...
        // fLongTO is TRUE except when initing
        // the modem (see comments for FComDrain).

        BG_CHK(lpovr->ov.hEvent);
        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
        DEBUGSTMT(if(err)       D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat)););
        dwcbPrev = pTG->Comm.comstat.cbOutQue;

        while(WaitForSingleObject(lpovr->ov.hEvent,
                                fLongTO? LONG_DRAINTIMEOUT : SHORT_DRAINTIMEOUT)==WAIT_TIMEOUT)
        {
            BOOL fStuckOnce=FALSE;

                (MyDebugPrint(pTG,  LOG_ALL, "After WaitForSingleObject TIMEOUT %ld \n", GetTickCount() ) );



                GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
                DEBUGSTMT(if(err)       D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat)););

                // Timed out -- check if any progress
                if (dwcbPrev == pTG->Comm.comstat.cbOutQue)
                {

                        (MyDebugPrint(pTG,  LOG_ALL, "WARNING: No progress %d %ld \n", dwcbPrev, GetTickCount() ) );

                        // No progress... If not in XOFFHold, we break....
                        if(!FComInXOFFHold(pTG))
                        {
                                if(fStuckOnce)
                                {
                                        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> iov_flush:: No Progress -- OutQ still %d at %lu\r\n", (int)pTG->Comm.comstat.cbOutQue, GetTickCount()));
                                        iModemSetError(pTG, MODEMERR_TIMEOUT, 0, MODEMERRFLAGS_TRANSIENT);
                                        goto done;
                                }
                                else
                                        fStuckOnce=TRUE;
                        }
                }
                else
                {
                        // Some progress...
                        dwcbPrev= pTG->Comm.comstat.cbOutQue;
                        fStuckOnce=FALSE;
                }

                // Independant deadcom timeout... I don't want
                // to use TO because of the 16bit limitation.
                {
                        DWORD dwNow = GetTickCount();
                        DWORD dwDelta =    (dwNow>dwStart)
                                                        ?  (dwNow-dwStart)
                                                        :  (0xFFFFFFFFL-dwStart) + dwNow;
                        if (dwDelta > (unsigned long)
                                                ((fLongTO)?LONG_DEADCOMMTIMEOUT:SHORT_DEADCOMMTIMEOUT))
                        {
                        (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> Drain:: Deadman Timer -- OutQ still %d at %lu\r\n", (int) pTG->Comm.comstat.cbOutQue, GetTickCount()));
                                goto end;
                        }
                }
        }

done:

        (MyDebugPrint(pTG,  LOG_ALL, "Before GetOverlappedResult %ld \n", GetTickCount() ) );

        if (GetOverlappedResult((HANDLE)pTG->Comm.nCid, &(lpovr->ov), &dw, FALSE))
        {

                fRet=TRUE;
        }
        else
        {
                dw = GetLastError();
                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> iov_flush:GetOverlappedResult returns error 0x%lx\r\n",
                                        (unsigned long) dw));
                if (dw==ERROR_IO_INCOMPLETE)
                {
                        // IO operation still pending, but we *have* to
                        // reuse this buffer -- what should we do?!-
                        // purge the output buffer and abort all pending
                        // write operations on it..

                        (MyDebugPrint(pTG,  LOG_ERR, "ERROR: Incomplete at %ld \n", GetTickCount() ) );
                        PurgeComm((HANDLE)pTG->Comm.nCid, PURGE_TXABORT);
                }
                fRet=FALSE;
        }
        OVL_CLEAR( &(lpovr->ov));
        lpovr->eState=eALLOC;
        lpovr->dwcb=0;

end:
        return fRet;
}













void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fBegin)
{
        (MyDebugPrint(pTG,  LOG_ALL, "Turning %s OVERLAPPED IO\r\n", (fBegin) ? "ON" : "OFF"));
        pTG->Comm.fDoOverlapped=fBegin;
}


#ifdef DEBUG
void d_TimeStamp(LPSTR lpsz, DWORD dwID)
{
        (MyDebugPrint(0,  LOG_ERR, "<<TS>> %s(%lu):%lu\r\n",
                (LPSTR) lpsz, (unsigned long) dwID, (unsigned long) GetTickCount()));
}
#endif







void
GetCommErrorNT(
    PThrdGlbl       pTG,
    HANDLE          h,
    int *           pn,
    LPCOMSTAT       pstat)


{
    
    if (!ClearCommError( h, pn, pstat) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR ClearComError(0x%lx) FAILS. Returns 0x%lu\n",
                        h,  GetLastError() );
        *(pn) =  MYGETCOMMERROR_FAILED;
    }

    

}


void
ClearCommCache(
    PThrdGlbl   pTG
    )

{
    pTG->CommCache.dwCurrentSize = 0;
    pTG->CommCache.dwOffset      = 0;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\fdebug.c ===
/***************************************************************************
        Name      :     fdebug.C
        Comment   :     Factored out debug code
        Functions :     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "prep.h"

#include <comdevi.h>

#ifndef MDDI
#       include "filet30.h"  //RSL just need t30fail.h
#       include "efaxcb.h"
#endif //MDDI



#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


#include "glbproto.h"


#define faxTlog(m)              DEBUGMSG(ZONE_DB, m)
#define faxT3log(m)             DEBUGMSG(ZONE_DB3, m)
#define FILEID                  FILEID_FDEBUG

#ifdef DEBUG
#       define ST_DB(x)         if(ZONE_DB) { x; }
#       define ST_DB3(x)        if(ZONE_DB3) { x; }
#else
#       define ST_DB(x)         { }
#       define ST_DB3(x)        { }
#endif

#define FLUSHBUFSIZE 256






void InitCommErrCount(PThrdGlbl pTG)
{
#ifndef MDDI
        T30FAILURECODE err;

        err = 0;
        if(pTG->Comm.uOtherErrorCount >= 20)
                err = T30FAIL_OTHERCOMM2;
        else if(pTG->Comm.uOtherErrorCount >= 10)
                err = T30FAIL_OTHERCOMM1;
        else if(pTG->Comm.uOtherErrorCount >= 5)
                err = T30FAIL_OTHERCOMM;
        if(err)
                ICommFailureCode(pTG, err);

        err = 0;
        if(pTG->Comm.uFramingBreakErrorCount >= 20)
                err = T30FAIL_FRAMING2;
        else if(pTG->Comm.uFramingBreakErrorCount >= 10)
                err = T30FAIL_FRAMING1;
        else if(pTG->Comm.uFramingBreakErrorCount >= 5)
                err = T30FAIL_FRAMING;
        if(err)
                ICommFailureCode(pTG, err);

        err = 0;
        if(pTG->Comm.uBufferOverflowCount >= 20)
                err = T30FAIL_BUFOVER2;
        else if(pTG->Comm.uBufferOverflowCount >= 10)
                err = T30FAIL_BUFOVER1;
        else if(pTG->Comm.uBufferOverflowCount >= 5)
                err = T30FAIL_BUFOVER;
        if(err)
                ICommFailureCode(pTG, err);

        err = 0;
        if(pTG->Comm.uInterruptOverunCount >= 20)
                err = T30FAIL_OVER2;
        else if(pTG->Comm.uInterruptOverunCount >= 10)
                err = T30FAIL_OVER1;
        else if(pTG->Comm.uInterruptOverunCount >= 5)
                err = T30FAIL_OVER;
        if(err)
                ICommFailureCode(pTG, err);
#endif //MDDI

        pTG->Comm.uInterruptOverunCount      = 0;
        pTG->Comm.uBufferOverflowCount       = 0;
        pTG->Comm.uFramingBreakErrorCount= 0;
        pTG->Comm.uOtherErrorCount           = 0;
}





void far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs)
{
        // int nCommEvt;           // MUST be 16bit in WIN16 and 32bit in WIN32

        if(err & CE_OVERRUN)
                pTG->Comm.uInterruptOverunCount++;
        if(err & CE_RXOVER)
                pTG->Comm.uBufferOverflowCount++;
        if(err & (CE_BREAK | CE_FRAME))
                pTG->Comm.uFramingBreakErrorCount++;
        if(err & (~(CE_OVERRUN | CE_RXOVER | CE_BREAK | CE_FRAME)))
                pTG->Comm.uOtherErrorCount++;

#ifdef DEBUG
        BG_CHK(err);
        D_PrintCE(err);

        D_PrintCOMSTAT(pTG, lpcs);

        // .... won't work in Win32.....
        // MyGetCommEvent(nCid, &nCommEvt);
        // Just get the events. Clears events according to mask.
        // Here NONE cleared. Avoid side effects.
        // D_PrintEvent(nCommEvt);
#endif // DEBUG
}














void far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid)
{
#ifdef DEBUG
        // int     nCommEvt;       // MUST be 16bit in WIN16 and 32bit in WIN32
        COMSTAT comstat;
        int             err;    // _must_ be 32bits in Win32

        GetCommErrorNT( pTG, (HANDLE) nCid, &err, &comstat);
        D_PrintCE(err);
        D_PrintCOMSTAT(pTG, &comstat);
        // .... won't work in Win32.....
        // MyGetCommEvent(nCid, &nCommEvt);
        // D_PrintEvent(nCommEvt);
#endif
}

void far D_HexPrint(LPB b1, UWORD incnt)
{
#ifdef DEBUG
        BYTE    b2[FLUSHBUFSIZE];
        UWORD   i, j;

        faxTlog(("In D_HexPrint: b1=0x%08lx incnt=%d\r\n", (LPSTR)b1, incnt));

        for(i=0; i<incnt;)
        {
                for(j=0; i<incnt && j<FLUSHBUFSIZE-6;)
                {
                        j += (UWORD)wsprintf(b2+j, "%02x ", (UWORD)(b1[i]));
                        i++;
                }
                b2[j] = 0;
                TRACE(("[ %s]\r\n", (LPSTR)b2));
        }
#endif
}

#ifdef DEBUG













void D_PrintIE(int err)
{
        switch(err)
        {
        case IE_BADID:          ERRMSG(("<<ERROR>> IE(%02x) Some Bad Com identifier\r\n", err)); break;
        case IE_BAUDRATE:       ERRMSG(("<<ERROR>> IE(%02x) Bad Baud Rate\r\n", err)); break;
        case IE_BYTESIZE:       ERRMSG(("<<ERROR>> IE(%02x) Invalid Byte Size\r\n", err)); break;
        case IE_DEFAULT:        ERRMSG(("<<ERROR>> IE(%02x) Error in default params\r\n", err)); break;
        case IE_HARDWARE:       ERRMSG(("<<ERROR>> IE(%02x) Missing Hardware\r\n", err)); break;
        case IE_MEMORY:         ERRMSG(("<<ERROR>> IE(%02x) Can't get memory\r\n", err)); break;
        case IE_NOPEN:          ERRMSG(("<<ERROR>> IE(%02x) Device not open\r\n", err)); break;
        case IE_OPEN:           ERRMSG(("<<ERROR>> IE(%02x) Device already open\r\n", err)); break;
        default:                        ERRMSG(("<<ERROR>> IE(%02x) No Comm Error!!!!\r\n", err)); break;
        }
}















void D_PrintCE(int err)
{
        if(err & CE_MODE)
        {
                ERRMSG(("<<ERROR>> CE(%02x) CE Mode -- or nCid is illegal\r\n", err));
                return;
        }
        if(err & CE_RXOVER)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Receive Buffer Overflow\r\n", err));
        }
        if(err & CE_OVERRUN)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Receive Overrun (not an error during startup) \r\n", err));
        }
        if(err & CE_RXPARITY)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Receive Parity error\r\n", err));
        }
        if(err & CE_FRAME)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Framing error (not an error during call startup or shutdown)\r\n", err));
        }
        if(err & CE_BREAK)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Break condition (not an error during call startup or shutdown) \r\n", err));
        }
        if(err & CE_TXFULL)
        {
                ERRMSG(("<<ERROR>> CE(%02x) Transmit Buffer full\r\n", err));
        }
        if(err & (CE_PTO | CE_IOE | CE_DNS | CE_OOP))
        {
                ERRMSG(("<<ERROR>> CE(%02x) Parallel Printer Errors!!!\r\n", err));
        }
}



















void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs)
{

        if((lpcs->cbInQue != pTG->PrevcbInQue) || (lpcs->cbOutQue != pTG->PrevcbOutQue) ||
           (lpcs->fXoffHold != (DWORD)pTG->PrevfXoffHold) ||
           (lpcs->fXoffSent != (DWORD)pTG->PrevfXoffSent))
                        (MyDebugPrint(pTG, LOG_ALL, "STAT::: InQ=%d PutQ=%d XoffHold=%d XoffSent=%d\r\n",
                                 lpcs->cbInQue, lpcs->cbOutQue,
                                         lpcs->fXoffHold, lpcs->fXoffSent));

        if(lpcs->fCtsHold || lpcs->fDsrHold || lpcs->fRlsdHold || lpcs->fEof || lpcs->fTxim)
                (MyDebugPrint(pTG, LOG_ALL, "???::: CTShold=%d DSRhold=%d RLShold=%d FOF=%d TXim=%d\r\n",
                        lpcs->fCtsHold, lpcs->fDsrHold, lpcs->fRlsdHold, lpcs->fEof, lpcs->fTxim));

        pTG->PrevfXoffHold = lpcs->fXoffHold;
        pTG->PrevfXoffSent = lpcs->fXoffSent;

        BG_CHK(lpcs->cbInQue < 0xffff);
        BG_CHK(lpcs->cbOutQue < 0xffff);

        pTG->PrevcbInQue = (USHORT) lpcs->cbInQue;
        pTG->PrevcbOutQue = (USHORT) lpcs->cbOutQue;
}














void D_PrintEvent(UWORD uwEvent)
{
        char sz[256];
        LPSTR szCurr;

        szCurr = sz;
        if(uwEvent & EV_RXCHAR) szCurr += wsprintf(szCurr, "1-RXCHAR ");
        if(uwEvent & EV_RXFLAG) szCurr += wsprintf(szCurr, "2-RXFLAG ");
        if(uwEvent & EV_TXEMPTY)        szCurr += wsprintf(szCurr, "4-TXEMPTY ");
        if(uwEvent & EV_CTS)            szCurr += wsprintf(szCurr, "8-CTSchange ");

        if(uwEvent & EV_DSR)            szCurr += wsprintf(szCurr, "16-DSRchange ");
        if(uwEvent & EV_RLSD)   szCurr += wsprintf(szCurr, "32-CDchange ");
        if(uwEvent & EV_BREAK)  szCurr += wsprintf(szCurr, "64-BREAK ");
        if(uwEvent & EV_ERR)            szCurr += wsprintf(szCurr, "128-LSRerror ");
        if(uwEvent & EV_RING)   szCurr += wsprintf(szCurr, "256-RING ");
        if(uwEvent & EV_PERR)   szCurr += wsprintf(szCurr, "512-LPTerror ");
        *szCurr = 0;

        if(szCurr > sz)
                faxTlog(("EVENT:::{%04x} %s\r\n", uwEvent, (LPSTR)sz));
}















void D_FComCheck(PThrdGlbl pTG, LONG_PTR nCid)
{
        // int             nCommEvt;       // MUST be 16bit in WIN16 and 32bit in WIN32
        COMSTAT         comstat;
        int             err;    // _must_ be 32bits in Win32

        GetCommErrorNT( pTG, (HANDLE) nCid, &err, &comstat);
        if(err != 0)
        {
                D_PrintCE(err);
                if(ZONE_DB)
                {
                        D_PrintCOMSTAT(pTG, &comstat);
                        // .... won't work in Win32.....
                        // MyGetCommEvent(nCid, &nCommEvt);
                        // Just get the events. Clears events according to mask.
                        // Here NONE cleared. Avoid side effects.
                        // D_PrintEvent(nCommEvt);
                }
        }
}
























void D_SafePrint(PThrdGlbl pTG, LPB b1, UWORD incnt)
{
        BYTE    b2[FLUSHBUFSIZE];
        UWORD   i, j;

        MyDebugPrint(pTG, LOG_ALL, "In D_SafePrint: b1=0x%08lx incnt=%d\r\n", (LPSTR)b1, incnt);

        for(i=0, j=0; i<incnt && j<FLUSHBUFSIZE-6; i++)
        {
                if(b1[i] < 32 || b1[i] >= 128)
                        j += (UWORD)wsprintf(b2+j, "{0x%02x}", (UWORD)(b1[i]));
                else
                        b2[j++] = b1[i];
        }
        b2[j] = 0;
        MyDebugPrint(pTG, LOG_ALL, "%s\r\n", (LPSTR)b2);
}

#endif //DEBUG








#ifdef MON3
// COMM MONITOR CODE
// 2/11/95      JosephJ Created
//
//      The functions MonInit, MonDeInit, MonPut and MonDump may be used
//  to  timestamp and log all reads from/writes using the comm apis.
//  MonDump creates two files, one a byte buffer, and the 2nd
//  an array of MONREC structures, each structure containing a timestamp
//  and an offset into the first file pointing to the actual comm data.



BOOL iMonWriteFrames(PThrdGlbl pTG, HFILE hfile, ULONG_PTR dwMROffset, DWORD dwcmr);
HFILE iMonOpenAndWriteHeader(PThrdGlbl pTG);


BOOL MonInit(PThrdGlbl pTG, LPMONOPTIONS lpmo)
{
        BOOL fRet=FALSE;
        DWORD dwPrefMRBufSize = lpmo->dwMRBufSize;
        DWORD dwPrefDataBufSize = lpmo->dwDataBufSize;

        if (pTG->gMonInfo.fInited) {BG_CHK(FALSE); goto end;}

        _fmemset(&pTG->gMonInfo, 0, sizeof(pTG->gMonInfo));
        GetLocalTime(&pTG->gMonInfo.stStart);
        pTG->gMonInfo.mo = *lpmo; //structure copy.


        // Try to allocate...

#define TRYALLOC(buffer, size, minsize, maxsize, ptrtype)\
                if ((size)<(minsize)) size=(minsize);\
                if ((size)>(maxsize)) size=(maxsize);\
                buffer = (ptrtype) MemAlloc((size));\
                if (!buffer)\
                {\
                        size = (minsize);\
                        buffer = (ptrtype) MemAlloc((size));\
                        if (!(buffer))\
                        {\
                                buffer=0;\
                                size=0;\
                        }\
                }

        BG_CHK(MIN_MRBUFSIZE>=sizeof(MONREC));
        BG_CHK(MIN_DATABUFSIZE>=sizeof(BYTE));
        TRYALLOC(pTG->gMonInfo.lpmrBuf, dwPrefMRBufSize,MIN_MRBUFSIZE,MAX_MRBUFSIZE,
                                                                                                                        LPMONREC);
        if (pTG->gMonInfo.lpmrBuf)
        {
        TRYALLOC(pTG->gMonInfo.lpbBuf,dwPrefDataBufSize,MIN_DATABUFSIZE,MAX_DATABUFSIZE,
                                                                                                                        LPBYTE);
                if (!pTG->gMonInfo.lpbBuf)
                {
                        MemFree(pTG->gMonInfo.lpmrBuf);
                        pTG->gMonInfo.lpmrBuf=0;
                        dwPrefMRBufSize=0;
                }
        }

        if (pTG->gMonInfo.lpmrBuf)
        {
                BG_CHK(dwPrefMRBufSize>=MIN_MRBUFSIZE);
                BG_CHK(pTG->gMonInfo.lpbBuf);
                BG_CHK(dwPrefDataBufSize>=MIN_DATABUFSIZE);

                pTG->gMonInfo.lpmrNext=pTG->gMonInfo.lpmrBuf;
                pTG->gMonInfo.dwcmrBuf= dwPrefMRBufSize/sizeof(MONREC);

                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf;
                pTG->gMonInfo.dwcbBuf = dwPrefDataBufSize;

                pTG->gMonInfo.fFreeOnExit=TRUE;
        }
        else
        {
                BG_CHK(!dwPrefMRBufSize);
                BG_CHK(!pTG->gMonInfo.lpbBuf);
                BG_CHK(!dwPrefDataBufSize);

                pTG->gMonInfo.lpmrNext=pTG->gMonInfo.lpmrBuf=NULL;
                pTG->gMonInfo.dwcmrBuf= 0;

                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf=NULL;
                pTG->gMonInfo.dwcbBuf = 0;

                pTG->gMonInfo.fFreeOnExit=FALSE;
                fRet=FALSE;
                goto end;
        }


        pTG->gMonInfo.fInited=TRUE;
        fRet=TRUE;

end:
        return fRet;
}

void MonDeInit(PThrdGlbl pTG)
{
        if (!pTG->gMonInfo.fInited) { BG_CHK(FALSE); return; }

        // Free monbuf and mr array, if allocated.
        if (pTG->gMonInfo.fFreeOnExit)
        {
                MemFree(pTG->gMonInfo.lpbBuf);
                MemFree(pTG->gMonInfo.lpmrBuf);
        }

        _fmemset(&pTG->gMonInfo, 0, sizeof(pTG->gMonInfo));
}


BOOL MonPutComm(PThrdGlbl pTG, WORD wFlags, LPBYTE lpb, WORD wcb)
// NOTE: special wFlags value (WORD)-1 indicates that
// lpb is actually an entire MONFRAME_EVENT structure
{
        DWORD    cb0 = (DWORD)(pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf -
                               pTG->gMonInfo.lpbNext);
        LPMONREC lpmrNext = pTG->gMonInfo.lpmrNext;

        if ((DWORD)wcb > pTG->gMonInfo.dwcbBuf) {BG_CHK(FALSE); return FALSE;}

        // +++Collapse into one bgchk after initial test.
        BG_CHK(pTG->gMonInfo.fInited);
        BG_CHK((pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf)>pTG->gMonInfo.lpbNext);
        BG_CHK(cb0<=pTG->gMonInfo.dwcbBuf);

        lpmrNext->dwTickCount=GetTickCount();
        lpmrNext->wFlags=wFlags;
        lpmrNext->wcb=wcb;
        // even on if !wcb we still keep the offset, for consistancy.
        lpmrNext->dwOffset=(DWORD)(pTG->gMonInfo.lpbNext-pTG->gMonInfo.lpbBuf);

        pTG->gMonInfo.dwNumBytes+=wcb;
        pTG->gMonInfo.dwNumPuts++;

        pTG->gMonInfo.lpmrNext++;
        if (pTG->gMonInfo.lpmrNext>=(pTG->gMonInfo.lpmrBuf+pTG->gMonInfo.dwcmrBuf))
                pTG->gMonInfo.lpmrNext = pTG->gMonInfo.lpmrBuf;
        if (wcb>cb0)
        {
                _fmemcpy(pTG->gMonInfo.lpbNext, lpb, cb0);
                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf;
                wcb-=(WORD)cb0;
                lpb+=cb0;
        }


        _fmemcpy(pTG->gMonInfo.lpbNext, lpb, wcb);
        pTG->gMonInfo.lpbNext+=wcb;
        if (pTG->gMonInfo.lpbNext >= (pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf))
                pTG->gMonInfo.lpbNext = pTG->gMonInfo.lpbBuf;

        return TRUE;
}

BOOL MonPutEvent(PThrdGlbl pTG, WORD wFlags, WORD wID, WORD wSubID,
                                        DWORD dwData0, DWORD dwData1, LPSTR lpszTxtMsg)
{
        // We actually call MonPutComm, with a "special" wFlag value of
        // (WORD) -1. MonDump looks for this special value and treates it
        // differently when writing out the record.


        char rgchBuf[sizeof(MONFRAME_EVENT)+MAX_TXTMSG_SIZE];
        LPMONFRAME_EVENT lpmfe=(LPMONFRAME_EVENT) rgchBuf;
        BOOL fRet=FALSE;

        lpmfe->wTxtMsgOff=
        lpmfe->wTotalSize=lpmfe->wHeaderSize=sizeof(MONFRAME_EVENT);
        lpmfe->wcbTxtMsg = (lpszTxtMsg) ? (WORD)lstrlen(lpszTxtMsg)+1:0;
        lpmfe->wTotalSize += lpmfe->wcbTxtMsg;
        if (lpmfe->wTotalSize>sizeof(rgchBuf)) goto end;
        lpmfe->wType = MFR_EVENT;
        lpmfe->wFlags = wFlags;
        lpmfe->dwTickCount = GetTickCount();
        lpmfe->wID=wID;
        lpmfe->wSubID=wSubID;
        lpmfe->dwInstanceID=pTG->gMonInfo.dwEventInstanceID++;
        lpmfe->dwData0=dwData0;
        lpmfe->dwData1=dwData1;
        GetLocalTime(&(lpmfe->st));
        if (lpmfe->wcbTxtMsg) _fmemcpy(((LPBYTE)lpmfe)+lpmfe->wTxtMsgOff,lpszTxtMsg, lpmfe->wcbTxtMsg);
        fRet = MonPutComm(pTG, (WORD)-1, (LPBYTE)lpmfe, lpmfe->wTotalSize);

end:
        return fRet;
}

void MonDump(PThrdGlbl pTG)
{
        HFILE hfile=HFILE_ERROR;
        LPMONREC lpmrFirst;
        DWORD dwcbBytesLeft;
        DWORD dwNumGoodMRs;

        if (!pTG->gMonInfo.fInited) {BG_CHK(FALSE); goto end;}

        GetLocalTime(&pTG->gMonInfo.stDump);

        hfile = iMonOpenAndWriteHeader(pTG);

        if (hfile==HFILE_ERROR) goto end;

        // Fixup offsets in MONREC structures to reflect the fact that
        // we're going to write starting from the oldest record onwards..
        //
        // This is a bit tricky because some of the MONREC structures may
        // not have associated data (the data could have been written over).
        // There may alternatively be data for which there are no MONREC structures
        // but that's OK.
        //
        // We start from the newest monrec structure and work our way backwards,
        // checking that the data is still valid and fixing up the offsets.

        if (pTG->gMonInfo.dwNumPuts<=pTG->gMonInfo.dwcmrBuf)
                lpmrFirst = pTG->gMonInfo.lpmrBuf;
       else
                lpmrFirst = pTG->gMonInfo.lpmrNext; // MONREC buffer rollover

        dwcbBytesLeft = pTG->gMonInfo.dwcbBuf; // we don't care if it's > than actually
                                                                          // in buffer.
        dwNumGoodMRs=0;
        if (pTG->gMonInfo.dwNumPuts && pTG->gMonInfo.dwNumBytes)
        {
                LPMONREC lpmr = pTG->gMonInfo.lpmrNext;

                // Starting with last monrec, work our way backwards...
                do
                {
                        if (lpmr>pTG->gMonInfo.lpmrBuf)
                                {lpmr--;}
                        else
                                {lpmr=pTG->gMonInfo.lpmrBuf+pTG->gMonInfo.dwcmrBuf-1;}

                        if (lpmr->wcb <= dwcbBytesLeft)
                        {
                                dwcbBytesLeft-=lpmr->wcb;
                        }
                        else
                        {
                                // we've nuked one-or-more of the earlier structures because
                                // their byte-data was overwritten.
                                // So we reset lpmrFirst to the next MR structure.
                                lpmrFirst=pTG->gMonInfo.lpmrBuf+
                                                                ((lpmr+1-pTG->gMonInfo.lpmrBuf)%pTG->gMonInfo.dwcmrBuf);
                                break;
                        }

                        dwNumGoodMRs++;

                } while (lpmr!=lpmrFirst);

        }

        iMonWriteFrames(pTG, hfile, (lpmrFirst-pTG->gMonInfo.lpmrBuf), dwNumGoodMRs);
        DosClose(hfile);


        pTG->gMonInfo.uRefCount++;
        pTG->gMonInfo.uRefCount&=0xf; // Limit number to 16

end:
        return;
}


void imon_write(HFILE hfile, LPBYTE lpb, DWORD dwcb)
{
        // Write out mon file, in chunks of 32K
        // -- because old mon code did that, perhaps a Win16 consideration.
#define WRITESIZE (0x1L<<15)

        while(dwcb>=WRITESIZE)
        {
                DosWrite(hfile, lpb, WRITESIZE);
                lpb+=WRITESIZE;
                dwcb-=WRITESIZE;
        }
        if (dwcb)
        {
                DosWrite(hfile, lpb, dwcb);
        }
}


// Create a single file which contains the combined info in the
// MONREC buffer and the byte buffer, in the form of MONFRAME
// structures.
// NOTE: special wFlags value (WORD)-1 indicates that
// lpb is actually an entire MONFRAME_EVENT structure
BOOL iMonWriteFrames(PThrdGlbl pTG, HFILE hfile, ULONG_PTR dwMROffset, DWORD dwcmr)
{

        //BG_CHK((!dwMROffset && !dwcmr) || dwcmr<dwMROffset);

        // Simple version: don't bother caching
        {
                BYTE bBuf[sizeof(MONFRAME_COMM)];
                LPMONFRAME_COMM lpmfc = (LPMONFRAME_COMM) bBuf;
                LPMONREC lpmr = pTG->gMonInfo.lpmrBuf+dwMROffset;
                BG_CHK(dwMROffset<pTG->gMonInfo.dwcmrBuf);
                BG_CHK(dwcmr<=pTG->gMonInfo.dwcmrBuf);
                BG_CHK(dwcmr<=pTG->gMonInfo.dwNumPuts);

                while(dwcmr--)
                {
                        DWORD dwcb0;
                        BG_CHK((lpmr->wcb+sizeof(MONFRAME_COMM))<(1L<<(8*sizeof(WORD))));
                        BG_CHK(lpmr->wcb<=pTG->gMonInfo.dwcbBuf);
                        BG_CHK(lpmr->dwOffset<=pTG->gMonInfo.dwcbBuf);
                        if (lpmr->wFlags != (WORD)-1) // See comment at head of function
                        {
                                lpmfc->wHeaderSize = sizeof(MONFRAME_COMM);
                                lpmfc->wTotalSize = sizeof(MONFRAME_COMM)+lpmr->wcb;
                                lpmfc->wType = MFR_COMMDATA;
                                lpmfc->wFlags = lpmr->wFlags;
                                lpmfc->dwTickCount = lpmr->dwTickCount;
                                lpmfc->wcb = lpmr->wcb;
                                imon_write(hfile, (LPBYTE)lpmfc, lpmfc->wHeaderSize);
                        }
                        dwcb0=pTG->gMonInfo.dwcbBuf-lpmr->dwOffset;
                        if (lpmr->wcb<=dwcb0)
                        {
                                imon_write(hfile, pTG->gMonInfo.lpbBuf+lpmr->dwOffset, lpmr->wcb);
                        }
                        else
                        {
                                imon_write(hfile, pTG->gMonInfo.lpbBuf+lpmr->dwOffset, dwcb0);
                                imon_write(hfile, pTG->gMonInfo.lpbBuf, lpmr->wcb-dwcb0);
                        }
                        if ( (lpmr+1-pTG->gMonInfo.lpmrBuf) < (long)pTG->gMonInfo.dwcmrBuf)
                                lpmr++;
                        else
                                lpmr=pTG->gMonInfo.lpmrBuf;
                }

        }

        return TRUE;
}


HFILE iMonOpenAndWriteHeader(PThrdGlbl pTG)
// Open file, if it's too big, rename old file and create file again.
// If file empty, put signature
// Put introductory timestamp text event.
{
        UINT uHeaderSize=0;
        LPSTR lpszPathPrefix=pTG->gMonInfo.mo.rgchDir;
        char rgchPath[64];
        HFILE hfile = HFILE_ERROR;
        LONG l=0;

        if (!*lpszPathPrefix || (_fstrlen(lpszPathPrefix)+8) > sizeof (rgchPath))
        {
                lpszPathPrefix= "c:\\";
        }
#define szMONFILESTUB "fax0"
#define szRENAMED_MONFILESTUB "old"
        wsprintf(rgchPath, "%s%s", (LPSTR) lpszPathPrefix,
                                        (LPSTR) szMONFILESTUB "." szMON_EXT);

        // Try to open existing file.
        hfile = DosOpen(rgchPath, OF_READWRITE|OF_SHARE_DENY_WRITE);

        // Check if size is too big -- if so rename.
        if (hfile!=HFILE_ERROR)
        {
                l = DosSeek(hfile, 0, FILE_END);
                if (l==HFILE_ERROR) {DosClose(hfile); hfile=HFILE_ERROR; goto end;}
                if ((DWORD)l>pTG->gMonInfo.mo.dwMaxExistingSize)
                {
                        char rgchRenamed[64];
                        DosClose(hfile); hfile=HFILE_ERROR;
                        wsprintf(rgchRenamed, "%s%s", (LPSTR) lpszPathPrefix,
                                                (LPSTR) szRENAMED_MONFILESTUB "." szMON_EXT);
                        DeleteFile(rgchRenamed);
                        MoveFile(rgchPath, rgchRenamed);
                }
        }

        if (hfile== HFILE_ERROR)
        {
                hfile = DosCreate(rgchPath, 0);
                if (hfile==HFILE_ERROR) goto end;
                l=0;
        }

        // Write header
        if (!l) {
                imon_write(hfile, szMONFRM_VER001 szMONFRM_DESC001,
                                                                        sizeof(szMONFRM_VER001 szMONFRM_DESC001));
        }

        // Create and write Text-frame with TIMESTAMP.
        {
                char rgchBuf[sizeof(MONFRAME_EVENT)+MAX_TXTMSG_SIZE];
                LPMONFRAME_EVENT lpmfe=(LPMONFRAME_EVENT) rgchBuf;
                UINT uTxtLen=0;

                lpmfe->wTxtMsgOff=
                lpmfe->wTotalSize=lpmfe->wHeaderSize=sizeof(MONFRAME_EVENT);
                lpmfe->wType = MFR_EVENT;
                lpmfe->wFlags = fEVENT_TRACELEVEL_0;
                lpmfe->dwTickCount = GetTickCount();
                lpmfe->wID= EVENT_ID_MON;
                lpmfe->wSubID= EVENT_SubID_MON_DUMP;
                lpmfe->dwInstanceID=pTG->gMonInfo.dwEventInstanceID++;
                lpmfe->dwData0=0;
                lpmfe->dwData1=0;
                GetLocalTime(&(lpmfe->st));

                uTxtLen = wsprintf(((LPBYTE)lpmfe)+lpmfe->wTxtMsgOff,
                                          "\tStarted: %02u/%02u/%04u %02u:%02u:%02u\r\n"
                                          "\t   Puts: %lu/%lu\r\n"
                                          "\t  Bytes: %lu/%lu\r\n",
                                        (unsigned) pTG->gMonInfo.stStart.wMonth&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wDay&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wYear&0xffff,
                                        (unsigned) pTG->gMonInfo.stStart.wHour&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wMinute&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wSecond&0xff,
                                        (unsigned) ((pTG->gMonInfo.dwcmrBuf>pTG->gMonInfo.dwNumPuts)
                                                          ? pTG->gMonInfo.dwNumPuts: pTG->gMonInfo.dwcmrBuf),
                                        (unsigned) pTG->gMonInfo.dwNumPuts,
                                        (unsigned) ((pTG->gMonInfo.dwcbBuf>pTG->gMonInfo.dwNumBytes)
                                                          ? pTG->gMonInfo.dwNumBytes: pTG->gMonInfo.dwcbBuf),
                                        (unsigned) pTG->gMonInfo.dwNumBytes);
                lpmfe->wcbTxtMsg = uTxtLen+1; // incuding zero.
                lpmfe->wTotalSize += lpmfe->wcbTxtMsg;
                BG_CHK(lpmfe->wTotalSize<=sizeof(rgchBuf));
                imon_write(hfile, (LPBYTE)lpmfe, lpmfe->wTotalSize);
        }

end:
        return  hfile;
}
#endif // MON3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\filter.c ===
/**************************************************************************
 Name     :     FILTER.C
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include "fdebug.h"
#include "fcomapi.h"
#include "fcomint.h"



#include "glbproto.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_FIL, m)
#define         FILEID                  FILEID_FILTER

#ifdef DEBUG
#       define ST_FIL(x)                if(ZONE_FIL) { x; }
#else
#       define ST_FIL(x)                { }
#endif


UWORD StuffZeroDLE(PThrdGlbl pTG, LPBYTE lpbIn, UWORD cbIn, LPBYTE lpbOut, UWORD cbOutSize, LPUWORD lpcbDone);

/**--------------------------Locals-----------------------------------**/




#define FILTERBUFSIZE  (WRITEQUANTUM * 2)



void  FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin)
{
        pTG->Filter.cbLineMin = cbLineMin;
        pTG->Filter.cbLineCount = 0;
}


void  FComOutFilterInit(PThrdGlbl pTG)
{
        // UWORD uwJunk;

        BG_CHK(pTG->Filter.lpbFilterBuf==0);

        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;
        pTG->Filter.bLastOutByte = 0xFF;

#ifdef SMM
        pTG->Filter.lpbFilterBuf = pTG->bStaticFilterBuf;
#else
#error NYI ERROR: Code Not Complete--Have to pick GMEM_ flags (FIXED? SHARE?)
        ...also have to call IFProcSetResFlags(hinstMe).....
        if(!(pTG->Filter.lpbFilterBuf = IFMemAlloc(0,  FILTERBUFSIZE, &uwJunk)))
        {
                ERRMSG(("<<ERROR>> Out of global memory!!));
                iModemSetError(MODEMERR_RESOURCES, ERR_OUT_OF_MEMORY, 0);
                return;
        }
#endif
}

void  FComOutFilterClose(PThrdGlbl pTG)
{
        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;

        if(!pTG->Filter.lpbFilterBuf)
        {
                TRACE(("<<WARNING>> OutFilterClose called when not open\r\n"));
                return;
        }

#ifndef SMM
        IFMemFree(pTG->Filter.lpbFilterBuf);
#endif

        pTG->Filter.lpbFilterBuf = 0;
}

void  FComInFilterInit(PThrdGlbl pTG)
{
        pTG->Filter.bPrevIn = 0;
        pTG->Filter.fGotDLEETX = 0;
        pTG->Filter.cbPost = 0;
}




/***************************************************************************
        Name      :     UWORD FComFilterWrite(LPB lpb, UWORD cb)
        Purpose   :     Filters bytes for DLE and ZERO stuffing and writes them out.
                                Returns when bytes are in the Comm ISR buffer.
                                DLE stuffing is always on. ZERO stuffing is usually on.
        Parameters:     lpb == data
                                cb == size of pb[]
        Returns   :     cb on success, 0 on failure

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/



UWORD  FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags)
{
        UWORD   cbIn, cbOut, cbDone;
        LPB             lpbIn;


        (MyDebugPrint(pTG, LOG_ALL, "In FilterWrite lpb=0x%08lx cb=%d lpbFilterBuf=0x%08lx\r\n",
                                lpb, cb, pTG->Filter.lpbFilterBuf));
        ST_FIL(D_FComPrint(pTG, pTG->Comm.nCid));
        BG_CHK(pTG->Filter.lpbFilterBuf);

        BG_CHK(flags==FILTER_DLEONLY || flags==FILTER_DLEZERO);
        BG_CHK(!(flags==FILTER_DLEONLY && pTG->Filter.cbLineMin));

#ifdef MDDI
        BG_CHK(!pTG->Filter.cbLineMin);
#endif //MDDI


        for(lpbIn=lpb, cbIn=cb; cbIn>0; lpbIn += cbDone, cbIn -= cbDone)
        {
                BG_CHK(cbIn);

                cbOut = StuffZeroDLE(pTG, lpbIn, cbIn, pTG->Filter.lpbFilterBuf,
                                          (UWORD)FILTERBUFSIZE, (LPUWORD)&cbDone);

                BG_CHK(cbDone && cbOut);        // need to make progress

                if(FComDirectWrite(pTG, pTG->Filter.lpbFilterBuf, cbOut) != cbOut)
                {
                        ERRMSG(("<<ERROR>> ex FilterWrite: Timeout\r\n"));
                        return 0;
                }
        }

        // Done....
        (MyDebugPrint(pTG, LOG_ALL, "Ex FilterWrite at %ld \n", GetTickCount() ) );
        return cb;
}






/***************************************************************************
 Purpose  :     Copy Input buffer to output, stuffing DLEs and Zeros
                        as specified by fStuffZERO, and cbLineMin. (DLE stuffing
                        is always on).
 Comment  :      This is both debugged and fast. Don't mess around!

;;              Registers are used here as follows
;;
;;      DF = cleared (forward)
;;      AH = previous byte
;;      AL = current byte
;;      CX = byte count of current image line -- initially Filter.cbLineCount
;;      DX = bytes left in input  -- initially [cbIn]
;;      BX = Space left in output -- initially [cbOut]
;;      ES:DI = destination             -- initially [lpbOut]
;;      DS:SI = source                  -- initially [lpbIn]
;;
;;              Since ES & DS are both used, we use the stack frame too
;;              We need to restore the DF flag and the seg regs. can trash
;;              any others.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#define         DLE                             0x10
#define         SUB                             0x1a
#define         EOL                             0x80
#define         EffEff                  0xFF
#define         ELEVEN_ZEROS    0xF07F

UWORD StuffZeroDLE(PThrdGlbl pTG, LPBYTE lpbIn, UWORD cbIn, LPBYTE lpbOut,
                                                                 UWORD cbOutSize, LPUWORD lpcbDone)
{
        UWORD   LineMin;        // copy of Filter.cbLineMin. Need it on stack
        UWORD   cbOutLeft;

#ifdef PORTABLE_CODE
   BYTE CurByte;
   BYTE PrevByte = pTG->Filter.bLastOutByte;
   UWORD CurLineCount = pTG->Filter.cbLineCount;
   LPBYTE SrcEnd = lpbIn + cbIn;
   LPBYTE DstEnd = lpbOut + cbOutSize - 1;   //Subtract 1 in case write 2 bytes at once
   LPBYTE CurrentSrc = lpbIn;
   LPBYTE CurrentDst = lpbOut;
   UWORD NumZeros;
#endif



        (MyDebugPrint(pTG, LOG_ALL, "in StuffZeroDLE: lpbIn=0x%08lx cbIn=%d lpbOut=0x%08lx cbOutSize=%d\r\n",
                lpbIn, cbIn, lpbOut, cbOutSize));

        (MyDebugPrint(pTG, LOG_ALL, "in StuffZeroDLE: lpcbDone=0x%08lx cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x\r\n",
                lpcbDone, pTG->Filter.cbLineMin, pTG->Filter.cbLineCount, pTG->Filter.bLastOutByte));

        // OK. Setup stack frame
        LineMin = pTG->Filter.cbLineMin;

#ifdef PORTABLE_CODE
    while ((CurrentSrc < SrcEnd) && (CurrentDst < DstEnd)) {
       CurByte = *CurrentSrc++;
       if (CurByte == DLE) {
          *CurrentDst++ = CurByte;
          CurLineCount++;
       }
       if ((CurByte == EOL) && ((PrevByte & 0xF0) == 0)) {
          if ((CurLineCount+1) < LineMin) {
             NumZeros = (LineMin - CurLineCount) - 1;
             if (NumZeros <= (DstEnd - CurrentDst)) {       // DstEnd-CurrentDst is 1 less than bytes left, leave 1 byte for end of line, hence <=
                for (;NumZeros > 0;NumZeros--)
                   *CurrentDst++ = 0;
             }
             else {
                CurrentSrc--;       //Unget the end of line for count or bytes written
                break;
             }
          }
          CurLineCount = (WORD)-1;
       }
       *CurrentDst++ = CurByte;
       PrevByte = CurByte;
       CurLineCount++;
    }
#endif



#ifdef PORTABLE_CODE
   pTG->Filter.cbLineCount = CurLineCount;
   pTG->Filter.bLastOutByte = PrevByte;
   *lpcbDone = (UWORD)(cbIn - (SrcEnd - CurrentSrc));
   cbOutLeft = (UWORD)((DstEnd - CurrentDst) + 1);
#endif

        (MyDebugPrint(pTG, LOG_ALL, "ex StuffZeroDLE: *lpcbDone=%d cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x\r\n",
                *lpcbDone, pTG->Filter.cbLineMin, pTG->Filter.cbLineCount, pTG->Filter.bLastOutByte));

   (MyDebugPrint(pTG, LOG_ALL, "ex StuffZeroDLE: cbOutSize=%d cbOutLeft=%d uwRet=%d\r\n",
                cbOutSize, cbOutLeft, (cbOutSize-cbOutLeft)));

        return (cbOutSize - cbOutLeft);
}


// Used to use NOCARRIER_CRLF. However Elliot bug#3619: Ger TE3801 cannot
// receive in Class1 mode -- this
// modem sends us NO CARRIER\n (missing \r), so we look for
// NO CARRIER[\r\n]*..
// CBSZ cbszNOCARRIER_CRLF      = "NO CARRIER\r\n";
extern CBSZ cbszNOCARRIER;
CBSZ cbszOK_CRLF                = "OK\r\n";
#define NCsize          (sizeof("NO CARRIER")-1)
#define OKsize          (sizeof(cbszOK_CRLF)-1)

#define cbPost          pTG->Filter.cbPost
#define rgbPost         pTG->Filter.rgbPost
#define fGotDLEETX      pTG->Filter.fGotDLEETX
#define bPrevIn         pTG->Filter.bPrevIn

// void WINAPI OutputDebugStr(LPSTR);

#ifdef PORTABLE_CODE
#define PortcbSkip   cbSkip
#define PortbPrevIn       bPrevIn
#endif

UWORD FComStripBuf(PThrdGlbl pTG, LPB lpbOut, LPB lpbIn, UWORD cb, BOOL fClass2, LPSWORD lpswEOF)
{
        LPB     lpbOutStart, lpbLim;
        UWORD   cbLeft;
        UWORD   cbSkip;
        UWORD   i;
        LPBYTE CurrentSrc;



        cbLeft = cb;
        lpbOutStart = lpbOut;
        lpbLim = lpbIn + cb;

        if(fGotDLEETX)
                goto MatchPost;

        for( ;lpbIn<lpbLim; )
        {
                if(bPrevIn == DLE)
                {
                        BG_CHK(lpbOut < lpbIn);         // at least 1 behind at this point
                        switch(*lpbIn++)
                        {
                                case DLE:       *lpbOut++ = DLE;
                                                        break;                          // insert single DLE
                                case SUB:       *lpbOut++ = DLE;
                                                        *lpbOut++ = DLE;
                                                        break;                          // insert _two_ DLEs!
                                case EffEff: // treat DLE-0xFF same as DLE-ETX. Intel gives us this
                                case ETX:
                                                        goto gotDLEETX;
                                // default:     break;                          // delete two
                        }
                        bPrevIn = 0;
                }
                else
                {
                        BG_CHK(lpbLim-lpbIn >= 1);


                        for (CurrentSrc = lpbIn;  (CurrentSrc < lpbLim) && (*CurrentSrc != DLE); CurrentSrc++)
                           ;
                        if (CurrentSrc != lpbLim) {
                           PortbPrevIn = DLE;
                        }
                        PortcbSkip = (UWORD)(CurrentSrc - lpbIn);

                        _fmemcpy(lpbOut, lpbIn, cbSkip);
                        lpbOut += cbSkip;
                        lpbIn += cbSkip+1;
                }
        }
        return (UWORD)(lpbOut-lpbOutStart);

gotDLEETX:
        // lpbIn now points to character *after* ETX
        // neither DLE nor ETX have been copied to output

        // return everything upto the last char before DLE
        // and *lpswEOF == TRUE iff the entirety of what follows
        // the DLE-ETX consists of (CR|LF)*("NO CARRIER")(CR|LF)*
        // *or* (CR|LF)*("OK")(CR|LF)*
        // else return error

        if(fClass2)
        {
                *lpswEOF = -1;  // -1==Class2 eof
                goto done;
        }

        fGotDLEETX = TRUE;
        cbPost = 0;

MatchPost:
        cbLeft = min((USHORT)(lpbLim-lpbIn), (USHORT)(POSTBUFSIZE-cbPost));
        _fmemcpy(rgbPost+cbPost, lpbIn, cbLeft);
        cbPost += cbLeft;

        (MyDebugPrint(pTG, LOG_ALL, "GotDLEETX: cbPost=%d cbLeft=%d\r\n", cbPost, cbLeft));
        // // TRACE(("<<%s>>\r\n", (LPSTR)(lpbIn)));
        // D_HexPrint(lpbIn, cbLeft);

        // skip CR LFs. Remember to restart from beginning of the post buffer
        for(i=0; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++)
                ;
        if(i >= cbPost)
                goto done;

        if(rgbPost[i] == 'N')
        {
                if(cbPost-i < NCsize)
                        goto done;
                else if(_fmemcmp(rgbPost+i, cbszNOCARRIER, NCsize)==0)
                {
                        i += NCsize;
                        goto eof;
                }
                else
                        goto error;
        }
        else if(rgbPost[i] == 'O')
        {
                if(cbPost-i < OKsize)
                        goto done;
                else if(_fmemcmp(rgbPost+i, cbszOK_CRLF, OKsize)==0)
                {
                        i += OKsize;
                        goto eof;
                }
                else
                        goto error;
        }
        else
                goto error;

        BG_CHK(FALSE);
eof:
        // skip any trailing CR/LFs
        for( ; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++)
                ;
        if(i == cbPost)
        {
                *lpswEOF = 1;
                goto done;
        }
        // else drop thru to error

error:
        *lpswEOF = -1;
        // goto done;
        fGotDLEETX = 0;         // reset this or we get 'stuck' in this state!

done:
        (MyDebugPrint(pTG, LOG_ALL, "GotDLEETX exit: swEOF=%d uRet=%d\r\n", *lpswEOF, lpbOut-lpbOutStart));
        return (UWORD)(lpbOut-lpbOutStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\identify.c ===
/***************************************************************************
        Name      :     IDENTIFY.C
        Comment   :     Identifying modems

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/


#include "prep.h"


#include "modemint.h"
//#include "fcomint.h"
#include "fdebug.h"

#include "awmodem.h"
#include "adaptive.h"


///RSL
#include "glbproto.h"



#define BIGTEMPSIZE             250

#define faxTlog(m)       DEBUGMSG(ZONE_ID, m)
#define faxT2log(m)      DEBUGMSG(ZONE_ID2, m)
#define FILEID           FILEID_IDENTIFY

#include "inifile.h"

char szModemFaxClasses[] = "ModemFaxClasses";
char szModemSendSpeeds[] = "ModemSendSpeeds";
char szModemRecvSpeeds[] = "ModemRecvSpeeds";
char szModemId[]         = "ModemId";
char szModemIdCmd[]      = "ModemIdCmd";
char szClass0ModemId[]   = "Class0ModemId";
char szClass2ModemId[]   = "Class2ModemId";
char szClass20ModemId[]  = "Class2.0ModemId";

char szResetCommand[]    = "ResetCommand";
char szSetupCommand[]    = "SetupCommand";
char szExitCommand[]     = "ExitCommand";
char szPreDialCommand[]  = "PreDialCommand";
char szPreAnswerCommand[]= "PreAnswerCommand";

// RSL new UNIMODEM INF settings (FAX GENERIC)

char szHardwareFlowControl[]  = "HardwareFlowControl";
char szSerialSpeedInit[]      = "SerialSpeedInit";
char szSerialSpeedConnect[]   = "SerialSpeedConnect";
char szAdaptiveAnswerEnable[] = "AdaptiveAnswerEnable"; 

// new ADAPTIVE INF file (FAX ADAPTIVE)
char      szResponsesKeyName[]  =    "ResponsesKeyName=";
char      szResponsesKeyName2[]  =   "ResponsesKeyName";

char szAdaptiveRecordUnique[] =      "AdaptiveRecordUnique";
char szAdaptiveCodeId[] =            "AdaptiveCodeId";  
char szFaxClass[] =                  "FaxClass";
char szAnswerCommand[] =             "AnswerCommand";
char szModemResponseFaxDetect[] =    "ModemResponseFaxDetect";
char szModemResponseDataDetect[] =   "ModemResponseDataDetect";
char szSerialSpeedFaxDetect[] =      "SerialSpeedFaxDetect";
char szSerialSpeedDataDetect[] =     "SerialSpeedDataDetect";
char szHostCommandFaxDetect[] =      "HostCommandFaxDetect";
char szHostCommandDataDetect[] =     "HostCommandDataDetect";
char szModemResponseFaxConnect[] =   "ModemResponseFaxConnect";
char szModemResponseDataConnect[] =  "ModemResponseDataConnect";

// how was the Modem Key created
char szModemKeyCreationId[] =        "ModemKeyCreationId";


#define NUM_CL0IDCMDS           7
#define NUM_CL2IDCMDS           3
#define NUM_CL20IDCMDS          3

#define LEN_CL0IDCMDS           5
#define LEN_CL2IDCMDS           9
#define LEN_CL20IDCMDS          8


USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG);
BOOL iModemCopyOEMInfo(PThrdGlbl pTG);
void SmashCapsAccordingToSettings(PThrdGlbl pTG);


NPSTR szClass0IdCmds[NUM_CL0IDCMDS] =
{
        "ATI0\r",
        "ATI1\r",
        "ATI2\r",
        "ATI3\r",
        "ATI4\r",
        "ATI5\r",
        "ATI6\r"
};

NPSTR szClass2IdCmds[NUM_CL2IDCMDS] =
{
        "AT+FMFR?\r",
        "AT+FMDL?\r",
        "AT+FREV?\r"
};

NPSTR szClass20IdCmds[NUM_CL20IDCMDS] =
{
        "AT+FMI?\r",
        "AT+FMM?\r",
        "AT+FMR?\r"
};


typedef struct {
        USHORT  uGoClass, uNum, uLen;
        NPSTR   *CmdTable;
        NPSTR   szIniEntry;
} GETIDSTRUCT, near* NPGETIDSTRUCT;

GETIDSTRUCT GetIdTable[3] =
{
        { 0, NUM_CL0IDCMDS, LEN_CL0IDCMDS, szClass0IdCmds, szClass0ModemId },
        { 2, NUM_CL2IDCMDS, LEN_CL2IDCMDS, szClass2IdCmds, szClass2ModemId },
        { GOCLASS2_0, NUM_CL20IDCMDS, LEN_CL20IDCMDS, szClass20IdCmds, szClass20ModemId }
};

#define MAXCMDSIZE              128
#define MAXIDSIZE               128
#define RESPONSEBUFSIZE 256
#define SMALLTEMPSIZE   80
#define TMPSTRINGBUFSIZE (6*MAXCMDSIZE+MAXIDSIZE+RESPONSEBUFSIZE+2*SMALLTEMPSIZE+10)
                                // Enough space for all the lpszs below.




BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG);
void imodem_free_tmp_strings(PThrdGlbl pTG);
void imodem_clear_tmp_settings(PThrdGlbl pTG);

                    
BOOL 
imodem_list_get_str(
    PThrdGlbl pTG,
    ULONG_PTR KeyList[10],
    LPSTR lpszName,
    LPSTR lpszCmdBuf,
    UINT  cbMax,
    BOOL  fCmd);

BOOL imodem_get_str(PThrdGlbl pTG, ULONG_PTR dwKey, LPSTR lpszName, LPSTR lpszCmdBuf, UINT cbMax,
                                        BOOL fCmd);

BOOL SearchInfFile(PThrdGlbl pTG, LPSTR lpstrFile, LPSTR lpstr1, LPSTR lpstr2, LPSTR lpstr3, DWORD_PTR dwLocalKey);
void CheckAwmodemInf(PThrdGlbl pTG);
void ToCaps(LPBYTE lpb);

BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG);

BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG);

UINT iModemGetUserFeedback(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType);

#ifndef USE_REGISTRY
BOOL iModemExpandKey(PThrdGlbl pTG, DWORD dwKey, LPSTR FAR *lplpszKey, LPSTR FAR *lplpszProfileName);
#endif






USHORT EndWithCR( LPSTR sz, USHORT uLen)
{
        if(uLen)
        {
                // Check if the string is terminated with a \r
                if(sz[uLen-1] != '\r')
                {
                        // add a \r
                        sz[uLen++] = '\r';
                        sz[uLen] = 0;
                }
        }
        return uLen;
}



BOOL
RemoveCR (
     LPSTR  sz
     )

{

   DWORD  len;


    if (!sz) {
       return FALSE;
    }

    len = strlen(sz);
    if (len == 0) {
       return FALSE;
    }

    if (sz[len-1] == '\r') {
       sz[len-1] = 0;
    }

    return TRUE;


}



      






USHORT GetIdResp(PThrdGlbl pTG, LPSTR szSend, USHORT uSendLen, LPBYTE lpbRespOut, USHORT cbMaxOut)
{
        USHORT uRespLen;

        (MyDebugPrint(pTG, LOG_ALL, "Want Id for (%s)\r\n", (LPSTR)szSend));

        pTG->fMegaHertzHack = TRUE;
        OfflineDialog2(pTG, (LPSTR)szSend, uSendLen, cbszOK, cbszERROR);
        pTG->fMegaHertzHack=FALSE;

        // sometimes we don't get the OK so try to parse what we got anyway
        (MyDebugPrint(pTG, LOG_ALL, "LastLine = (%s)\r\n ", (LPSTR)(&(pTG->FComModem.bLastReply))));

        uRespLen = min(cbMaxOut, _fstrlen(pTG->FComModem.bLastReply));

        _fmemcpy(lpbRespOut, pTG->FComModem.bLastReply, uRespLen);
        lpbRespOut[uRespLen] = 0; // zero terminate the string

        return uRespLen;
}






USHORT GetIdForClass(PThrdGlbl pTG, NPGETIDSTRUCT npgids, LPBYTE lpbOut, USHORT cbMaxOut,
                        LPBYTE lpbLongestId, USHORT cbMaxLongestId, LPBYTE lpbLongestCmd)
{
        USHORT  i, j, k, uRet, uLen, uLenLong, iLong;
        LPBYTE  lpbLong;

        BG_CHK(lpbOut && cbMaxOut>2);
        cbMaxOut -= 2; // make space for trailing ; and \0
        if(lpbLongestId)
                cbMaxLongestId -= 1; // make space for trailing \0
        uLen=0;

        if(npgids->uGoClass)
        {
                if(!iiModemGoClass(pTG, npgids->uGoClass, 0))
                {
                        ERRMSG(("<<ERROR>> GoClass %d failed\r\n", npgids->uGoClass));
                        goto done;
                }
        }

        for(lpbLong=NULL, uLenLong=0, i=0; i<npgids->uNum; i++)
        {
                uRet = GetIdResp(pTG, npgids->CmdTable[i], npgids->uLen, lpbOut+uLen, (USHORT)(cbMaxOut-uLen));
                // find longest ID among ATI0 thru 3 only!
                if(i<=3 && uLenLong < cbMaxLongestId && uRet > uLenLong)
                {
                        uLenLong = min(uRet, cbMaxLongestId);
                        lpbLong = lpbOut + uLen;
                        iLong = i;
                }
                uLen += uRet;
                lpbOut[uLen++] = ';';
        }
        lpbOut[uLen] = 0;

        if(lpbLongestId && lpbLongestCmd && cbMaxLongestId && lpbLong && uLenLong)
        {
                _fmemcpy(lpbLongestId, lpbLong, uLenLong);
                lpbLongestId[uLenLong] = 0;
                _fmemcpy(lpbLongestCmd, npgids->CmdTable[iLong], npgids->uLen);
                lpbLongestCmd[npgids->uLen] = 0;
                TRACE(("LongestId (%s\r\n)-->(%s)\r\n", (LPSTR)lpbLongestCmd, (LPSTR)lpbLongestId));
        }
        // strip non-prinatbles. *AFTER* extracting the ModemId string!!
        for(j=0, k=0; j<uLen; j++)
        {
                if(lpbOut[j] >= 32 && lpbOut[j] <= 127)
                        lpbOut[k++] = lpbOut[j];
        }
        uLen = k;
        lpbOut[uLen] = 0;
        TRACE(("Class%dId (%s)\r\n", npgids->uGoClass, (LPSTR)lpbOut));

done:
        if(npgids->uGoClass)
                iiModemGoClass(pTG, 0, 0);
        return uLen;
}













void iModemGetWriteIds(PThrdGlbl pTG, BOOL fGotOEMInfo)
{
        // As with iModemFigureOutCmds and iModemGetCaps, we selectively
        // detect ID's taking into account OEM info that's already read in...
        USHORT     uLen1, uLen2, uLen3;
        DWORD_PTR  dwKey=0;
        LPSTR      lpstr1 = 0, lpstr2 = 0, lpstr3 = 0;
        USHORT     uClasses = pTG->TmpSettings.lpMdmCaps->uClasses;

        uLen1 = uLen2 = uLen3 = 0;


        if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                        fREG_CREATE | fREG_READ | fREG_WRITE)))

        {
                ERRMSG(("<<ERROR>> Couldn't get location of modem info.\n\r"));
                BG_CHK(FALSE);
                goto end;

        }

        if (pTG->TmpSettings.dwGot & fGOTPARM_IDCMD)
        {
                int i=0;

                // We have a null ID ...
                if (!pTG->TmpSettings.szIDCmd[0])
                {
                        BG_CHK(!pTG->TmpSettings.szID[0]);
                        goto SaveIDandCMD;
                }

                // We are to detect the ID
                while(i++<2)
                {
                        pTG->TmpSettings.szID[0]=0;
                        pTG->TmpSettings.szResponseBuf[0]=0;
                        GetIdResp(pTG, pTG->TmpSettings.szIDCmd,
                                                (USHORT) _fstrlen(pTG->TmpSettings.szIDCmd),
                                                pTG->TmpSettings.szID, MAXIDSIZE);
                        GetIdResp(pTG, pTG->TmpSettings.szIDCmd,
                                                (USHORT)_fstrlen(pTG->TmpSettings.szIDCmd),
                                                pTG->TmpSettings.szResponseBuf, MAXIDSIZE);
                    if (!_fstrcmp(pTG->TmpSettings.szID, pTG->TmpSettings.szResponseBuf)) break;
                }
                if (i>=3 || !pTG->TmpSettings.szID[0])
                {
                ERRMSG(("<<ERROR>> Can't get matching ID for supplied IDCMD: %s\r\n",
                                        (LPSTR) pTG->TmpSettings.szIDCmd));
                        pTG->TmpSettings.szIDCmd[0]=pTG->TmpSettings.szID[0]=0;
                }
                else
                {
                        ERRMSG((" OEM IDCmd=%s --> %s\r\n",
                                        (LPSTR) pTG->TmpSettings.szIDCmd,
                                        (LPSTR) pTG->TmpSettings.szID));
                }
                pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD | fGOTPARM_ID);
                goto SaveIDandCMD;

        }

// write ModemId first, then ModemIdCmd

        // the lpszOemIDCmd and lpszOemID above).
        pTG->TmpSettings.szID[0]=0;
        lpstr1 = pTG->TmpSettings.szResponseBuf;
        uLen1 = GetIdForClass(pTG, &GetIdTable[0], lpstr1,
                        RESPONSEBUFSIZE, pTG->TmpSettings.szID, MAXIDSIZE,
                        pTG->TmpSettings.szIDCmd);
        lpstr1[uLen1] = 0;
        if (pTG->TmpSettings.szID[0]) pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD|fGOTPARM_ID);

// then the Class0, 2, 2.0 ID strings
        ProfileWriteString(dwKey, GetIdTable[0].szIniEntry, lpstr1, FALSE);

        if(uClasses & FAXCLASS2)
        {
                BG_CHK(pTG->TmpSettings.szResponseBuf[uLen1] == 0);
                lpstr2 = pTG->TmpSettings.szResponseBuf + uLen1 + 1;
                BG_CHK(uLen1 + 1 < RESPONSEBUFSIZE);
                uLen2 = GetIdForClass(pTG, &GetIdTable[1], lpstr2,
                                        (USHORT)(RESPONSEBUFSIZE-uLen1-1), 0, 0, 0);
                lpstr2[uLen2] = 0;
                ProfileWriteString(dwKey, GetIdTable[1].szIniEntry, lpstr2, FALSE);
        }
        if(uClasses & FAXCLASS2_0)
        {
                BG_CHK(pTG->TmpSettings.szResponseBuf[uLen1] == 0);
                BG_CHK(uLen2==0 || pTG->TmpSettings.szResponseBuf[uLen1+uLen2+1] == 0);
                BG_CHK(uLen1 + uLen2 + 2 < RESPONSEBUFSIZE);
                lpstr3 = pTG->TmpSettings.szResponseBuf + uLen1 + uLen2 + 2;
                uLen3 = GetIdForClass(pTG, &GetIdTable[2], lpstr3, (USHORT)((RESPONSEBUFSIZE)-uLen1-uLen2-2), 0, 0, 0);
                lpstr3[uLen3] = 0;
                ProfileWriteString(dwKey, GetIdTable[2].szIniEntry, lpstr3, FALSE);
        }

        ToCaps(lpstr1);
        ToCaps(lpstr2);
        ToCaps(lpstr3);

        TRACE(("Got Ids (%s)\r\n(%s)\r\n(%s)\r\n",
                        ((LPSTR)(lpstr1 ? lpstr1 : "null")),
                        ((LPSTR)(lpstr2 ? lpstr2 : "null")),
                        ((LPSTR)(lpstr3 ? lpstr3 : "null"))));

        // If we've read any commands or caps from the OEM location we
        // skip this...


        if (fGotOEMInfo || ( pTG->ModemKeyCreationId != MODEMKEY_FROM_NOTHING) )
        {
                ERRMSG(("<<WARNING>> Got OEM info: Skipping AWMODEM.INF file search!\r\n"));
        }
        else
        {
                if (!SearchInfFile(pTG, "AWOEM.INF", lpstr1, lpstr2, lpstr3, dwKey))
                                 SearchInfFile(pTG, "AWMODEM.INF", lpstr1, lpstr2, lpstr3, dwKey);
        }

SaveIDandCMD:

        BG_CHK(pTG->TmpSettings.dwGot & fGOTPARM_IDCMD);
        ProfileWriteString(dwKey, szModemId, pTG->TmpSettings.szID, FALSE);
        ProfileWriteString(dwKey, szModemIdCmd, pTG->TmpSettings.szIDCmd, TRUE);

end:
        if (dwKey) ProfileClose(dwKey);
        return;
}

// state: 0=ineol  1=insectionhdr  2=in midline  3=got] 4=got\r\n
// inputs: \r\n==0 space/tab=1 2=[ 3=] 4=pritables 5=others
USHORT uNext[5][6] =
{
  // crlf sp [  ] asc oth
        { 0, 0, 1, 2, 2, 2 },   //in eol
        { 0, 1, 2, 3, 1, 2 },   //in sectionhdr
        { 0, 2, 2, 2, 2, 2 },   //in ordinary line
        { 4, 3, 2, 2, 2, 2 },   //found ]
        { 4, 4, 4, 4, 4, 4 }    //found closing \r\n
};

#define START           0
#define INHEADER1       1
#define INHEADER2       3
#define FOUND           4











void ToCaps(LPBYTE lpb)
{
        // capitalize string
        USHORT i;

        for(i=0; lpb && lpb[i]; i++)
        {
                if(lpb[i] >= 'a' && lpb[i] <= 'z')
                        lpb[i] -= 32;
        }
}



BOOL SearchInfFile(PThrdGlbl pTG, LPSTR lpstrFile, LPSTR lpstr1, LPSTR lpstr2, LPSTR lpstr3, DWORD_PTR dwLocalKey)
{
#if defined(DOSIO) || defined(KFIL)
        char    bTemp[BIGTEMPSIZE];
        char    szHeader[SMALLTEMPSIZE+SMALLTEMPSIZE];
        char    bTemp2[SMALLTEMPSIZE+SMALLTEMPSIZE];
        UINT    uLen, state=0, input=0, uHdrLen;
        HFILE   hfile;
        LPBYTE  lpb, lpbCurr;

        uLen = GetWindowsDirectory(bTemp, BIGTEMPSIZE-15);
        if(!uLen)
        {
                BG_CHK(FALSE);
                return FALSE;
        }
        // if last char is not a \ then append a '\'
        if(bTemp[uLen-1] != '\\')
        {
                bTemp[uLen++] = '\\';
                bTemp[uLen] = 0;                // add new 0 terminator
        }
        _fstrcpy(bTemp+uLen, lpstrFile);
        if((hfile = DosOpen(bTemp, 0)) == HFILE_ERROR)
        {
                ERRMSG(("<<WARNING>> %s: No such file\r\n", (LPSTR)bTemp));
                return FALSE;
        }

        uLen = 0;
        lpbCurr = bTemp;

nextround:
        faxT2log(("Nextround\r\n", state, input));
        state = START;
        uHdrLen = 0;
        for(;;)
        {
                if(!uLen)
                {
                        uLen = DosRead( hfile, bTemp, sizeof(bTemp));
                        if(!uLen || uLen == ((UINT) -1))
                                goto done;
                        lpbCurr = bTemp;
                }

                BG_CHK(state != FOUND);
                switch(*lpbCurr)
                {
                case '\r':
                case '\n':      input = 0; break;
                case ' ':
                case '\t':      input = 1; break;
                case '[':       input = 2; break;
                case ']':       input = 3; break;
                default:        if(*lpbCurr >= 32 && *lpbCurr < 128)
                                                input = 4;
                                        else
                                                input = 5;
                                        break;
                }
                faxT2log(("state=%d, char=%c input=%d, hdrlen=%d ulen=%d\r\n",
                                 state, *lpbCurr, input, uHdrLen, uLen));

                state = uNext[state][input];
                faxT2log(("new state=%d\r\n", state));

                if(state == FOUND)
                {
                        if(uHdrLen > 2)
                                break;
                        else
                                goto nextround;
                }

                if(state == INHEADER1)
                {
                        if(*lpbCurr != '[' && uHdrLen < sizeof(szHeader)-1)
                                szHeader[uHdrLen++] = *lpbCurr;
                }
                else if(state != INHEADER2)
                        uHdrLen=0;

                lpbCurr++;
                uLen--;

                // szHeader[uHdrLen] = 0;
                faxT2log(("%d %s\r\n", uHdrLen, (LPSTR)szHeader));
        }
        faxT2log(("Found[%s]\r\n", (LPSTR)szHeader));
        BG_CHK(uHdrLen > 2);
        // uHdrLen--; // get rid of trailing ]
        szHeader[uHdrLen] = 0;

        // capitalize search string
        ToCaps(szHeader);

        TRACE(("Found[%s]\r\n", (LPSTR)szHeader));

        if(     (lpstr1 ? my_fstrstr(lpstr1, szHeader) : FALSE) ||
                (lpstr2 ? my_fstrstr(lpstr2, szHeader) : FALSE) ||
                (lpstr3 ? my_fstrstr(lpstr3, szHeader) : FALSE) )
        {
                TRACE(("<<WARNING>> Copying INI file section [%s] from %s to %s\r\n",
                                        (LPSTR)szHeader, (LPSTR)lpstrFile, (LPSTR)szIniFile));

                DosClose( hfile);
                // read the whole section as profile string
                if(GetPrivateProfileString(szHeader, NULL, "", bTemp, sizeof(bTemp), lpstrFile) == 0)
                {
                        ERRMSG(("<<ERROR>> Can't read INF file section\r\n"));
                        return FALSE;
                }
                // copy it to our IniFile
                for(lpb=bTemp; *lpb; lpb += _fstrlen(lpb)+1)
                {
                        // lpb is a key in the [szHeader] section of the INF file
                        if(GetPrivateProfileString(szHeader, lpb, "", bTemp2, sizeof(bTemp2), lpstrFile) == 0)
                        {
                                ERRMSG(("<<ERROR>> Can't read INF file entry\r\n"));
                        }
                        else
                        {
                                // copy it to our IniFile
                                ProfileWriteString(dwLocalKey, lpb, bTemp2, FALSE);
                                        (MyDebugPrint(pTG, LOG_ALL, "Wrote %s=%s\r\n", (LPSTR)lpb, (LPSTR)bTemp2));

                        }
                }
                // found what we wanted. Outta here
                return TRUE;
        }

        // couldnt match, try again
        (MyDebugPrint(pTG, LOG_ALL, "No match\r\n"));
        goto nextround;

done:
        (MyDebugPrint(pTG, LOG_ALL, "End of INF file %s\r\n", (LPSTR)lpstrFile));
        // end of inf file--close it
        DosClose(hfile);
#endif  // DOSIO || KFIL
        return FALSE;
}












void CheckAwmodemInf(PThrdGlbl pTG)
{
#if defined(DOSIO) || defined(KFIL)
        USHORT uLen;
        char bTemp[BIGTEMPSIZE];
        HFILE hfile;

        uLen = (USHORT)GetWindowsDirectory(bTemp, sizeof(bTemp)-15);
        if(!uLen)
        {
                BG_CHK(FALSE);
                return;
        }
        // if last char is not a \ then append a '\'
        if(bTemp[uLen-1] != '\\')
        {
                bTemp[uLen++] = '\\';
                bTemp[uLen] = 0;                // add new 0 terminator
        }
        _fstrcpy(bTemp+uLen, "AWMODEM.INF");
        if((hfile = DosOpen(bTemp, 0)) != HFILE_ERROR)
        {
                TRACE(("<<WARNING>> %s exists\r\n", (LPSTR)bTemp));
        }
        else
        {
                if((hfile = DosCreate(bTemp, 0)) == HFILE_ERROR)
                {
                        ERRMSG(("<<ERROR>> Could not create %s\r\n", (LPSTR)bTemp));
                }
                else
                {
                        DosWrite( hfile, (LPSTR)szAwmodemInf, sizeof(szAwmodemInf)-1);
                        DosClose( hfile);
                        TRACE(("<<WARNING>> Created %s\r\n", (LPSTR)bTemp));
                }
        }
        return;
#endif  //DOSIO || KFIL
}














USHORT iModemGetCmdTab(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
                LPCMDTAB lpCmdTab, LPMODEMCAPS lpMdmCaps, LPMODEMEXTCAPS lpMdmExtCaps,
                BOOL fInstall)
{
        USHORT uLen1, uLen2, uRet = INIT_INTERNAL_ERROR;
        USHORT uPassCount = 0;
        USHORT uInstall=0;
        BOOL    fDontPurge=FALSE; //If true, we won't delete section in install.
        int i;

#ifndef METAPORT
        BG_CHK(dwLineIDType == LINEID_COMM_PORTNUM);
#else
        BG_CHK(  dwLineIDType == LINEID_COMM_PORTNUM
                  || dwLineIDType == LINEID_COMM_HANDLE);
#endif

        if (!imodem_alloc_tmp_strings(pTG)) goto done;
        pTG->TmpSettings.lpMdmCaps = lpMdmCaps;
        pTG->TmpSettings.lpMdmExtCaps = lpMdmExtCaps;

        if(fInstall==fMDMINIT_INSTALL) goto DoInstall;

ReadConfig:

        // check for ModemIdCmd, ModemId, ModemFaxClasses,
        //       ResetCommand, SetupCommand, PreDialCommand, PreAnswerCommand,
        //       ExitCommand, FaxSerialSpeed vars
        //       and (if Class1) ModemSendCaps, ModemRecvCaps
        // if all present [some exceptions--see below], then verify that
        //       ModemId is still correct (send ModemIdCmd, get ModemId)
        // if correct then copy all INI values into lpMdmCaps and lpCmdTab
        // else do full install

// get ModemCaps from current settings

        imodem_clear_tmp_settings(pTG);

        if (!iModemGetCurrentModemInfo(pTG))
        {
                goto DoInstall;
        }

        SmashCapsAccordingToSettings(pTG);

        if (! pTG->fCommInitialized) {
           if( ! T30ComInit(pTG, pTG->hComm) ) {
              (MyDebugPrint(pTG, LOG_ALL, "T30ComInit failed \r\n"));
               goto done;
           }

           FComDTR(pTG, TRUE); // Raise DTR in ModemInit
           FComFlush(pTG);

           pTG->fCommInitialized = 1;
        }


        // do modem reset, or ID check won't work (because of echo)
        BG_CHK(pTG->TmpSettings.dwGot&fGOTCMD_Reset);
        if (!pTG->TmpSettings.szReset[0])
        {
                ERRMSG(("<<WARNING>> NULL reset command specified!\r\n"));
        }
        else
        {
                if(iModemReset(pTG, pTG->TmpSettings.szReset) < 0)
                {
                        fDontPurge=TRUE; // we specifically don't purge in this case.
                        goto DoInstall;
                }
    }
// check ID

        // a way around this Id check. If IdCmd has been manually deleted, skip chk
        BG_CHK(pTG->TmpSettings.szIDCmd && pTG->TmpSettings.szID);
        uLen1 = (USHORT)_fstrlen(pTG->TmpSettings.szIDCmd);
        if (fInstall==fMDMINIT_ANSWER || !uLen1) {uRet = 0; goto done;}
        uLen2 = (USHORT)_fstrlen(pTG->TmpSettings.szID);
        BG_CHK(uLen2);

        for(i=0; i<3; i++)
        {
                GetIdResp(pTG, pTG->TmpSettings.szIDCmd, uLen1, pTG->TmpSettings.szResponseBuf,
                                                RESPONSEBUFSIZE);
                if(my_fstrstr(pTG->TmpSettings.szResponseBuf, pTG->TmpSettings.szID))
                {
                        TRACE(("<<WARNING>> Modem IDs (%s): (%s\r\n)-->(%s) confirmed\r\n",
                                (LPSTR)pTG->TmpSettings.szID, (LPSTR)pTG->TmpSettings.szIDCmd,
                                (LPSTR)pTG->TmpSettings.szResponseBuf));
                        uRet = 0;
                        goto done;
                }
        }

        // Failed ID check
        // Fall thru to DoInstall;

DoInstall:
        if(uPassCount > 0)
        {
                TRACE(("<<ERROR>> Install looping!!\r\n"));
                BG_CHK(FALSE);
                uRet =  INIT_INTERNAL_ERROR;
                goto done;
        }
        uPassCount++;

        // +++ currently we always do a "clean" install -- dwGot=0
        // EXCEPT that we use fDontPurge do determine whether we
        // delete the profile section or not.
        fDontPurge=fDontPurge|| (pTG->TmpSettings.uDontPurge!=0);
        imodem_clear_tmp_settings(pTG);
        BG_CHK(!pTG->TmpSettings.dwGot);

        if(uRet = iModemInstall(pTG, dwLineID, dwLineIDType, fDontPurge))
                goto done;      // failed
        else
                goto ReadConfig;        // success

        // on success we want to go back and start over because (a) we want to check
        // that everything is indeed OK and (b) UI etc may have modfied some of the
        // settings so we need to go back and read them in again.

done:
        if (!uRet)
        {
                char *pb = pTG->bModemCmds;
                UINT u;

                // Initialize all command strings in lpCmdTab to static buffer,
                // copying from the corresponding strings in the TmpSettings structure.
                // the latter strings point into
                // the temporarily allocated buffer allocated in
                // imodem_alloc_tmp_strings and will be freed on exit.

                _fmemset(lpCmdTab, 0, sizeof(CMDTAB));

#define ADDSTRING(STRING) \
                BG_CHK(pTG->TmpSettings.STRING); \
                u = _fstrlen(pTG->TmpSettings.STRING)+1; \
                _fmemcpy(pb, pTG->TmpSettings.STRING,u); \
                lpCmdTab->STRING=pb;\
                pb+=u; \
                BG_CHK(pb<=(pTG->bModemCmds+sizeof(pTG->bModemCmds)));

                ADDSTRING(szReset);
                ADDSTRING(szSetup);
                ADDSTRING(szExit);
                ADDSTRING(szPreDial);
                ADDSTRING(szPreAnswer);
        }

        lpCmdTab->dwSerialSpeed = pTG->SerialSpeedInit;
        lpCmdTab->dwFlags = pTG->TmpSettings.dwFlags;
        imodem_free_tmp_strings(pTG);
        return uRet;
}














USHORT iModemInstall(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType, BOOL fDontPurge)
{
        USHORT   uRet = 0;
        BOOL     fGotOEMInfo = FALSE;
        DWORD_PTR hkFr;
        DWORD    localModemKeyCreationId;


        CheckAwmodemInf(pTG);              // check that AWMODEM.INf exist, otherwise create it

        if (!pTG->TmpSettings.dwGot) {

                /////// clear settings in input //////

                // Clear out persistant (registry) info...
                if (!fDontPurge && !ProfileDeleteSection(DEF_BASEKEY,pTG->FComModem.rgchKey))
                {

                ERRMSG(("<<WARNING>> ClearCurrentModemInfo:Can't delete section %s\r\n",
                                        (LPSTR) pTG->FComModem.rgchKey));
                }

                // Since  the above deletes the entire section, we have to write
                // back things that are important to us, which currently
                // is the OEM key...
                {
                        DWORD_PTR dwKey;

                        if (!(dwKey = ProfileOpen(pTG->FComModem.dwProfileID,
                                        pTG->FComModem.rgchKey, fREG_CREATE |fREG_READ|fREG_WRITE))
                            || !ProfileWriteString(dwKey, szOEMKEY,
                                                        pTG->FComModem.rgchOEMKey, FALSE))
                        {
                                ERRMSG(("<<WARNING>> Couldn't write OEM Key after clearing section\r\n"));
                        }
                        // may be save other things here, like modem params???

                        if (dwKey) {ProfileClose(dwKey); dwKey=0;}
                }

                //
                // 1. Check to see if this modem is defined in Adaptive.Inf
                //

                SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, FALSE);

                if (pTG->fAdaptiveRecordFound) {
                   if (! pTG->fAdaptiveRecordUnique) {
                      //
                      // need to talk to a modem to find out its ID.
                      //
                      TalkToModem (pTG, FALSE);

                      if (pTG->fAdaptiveRecordUnique) {
                         SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, TRUE);
                      }
                      else {
                         pTG->fAdaptiveRecordFound = 0;
                         pTG->ModemClass = 0;
                      }
                   }
                }

                //
                // 2. Save either Adaptive.inf or Unimodem.inf [or nothing] to Registry
                //

                if (pTG->fAdaptiveRecordFound) {
                   
                   pTG->ModemKeyCreationId = MODEMKEY_FROM_ADAPTIVE;

                   SaveInf2Registry(pTG);
                }
                else {

                   if ( hkFr = ProfileOpen( OEM_BASEKEY, pTG->lpszUnimodemFaxKey, fREG_READ) ) {
                      pTG->fUnimodemFaxDefined = 1;
                      pTG->ModemKeyCreationId = MODEMKEY_FROM_UNIMODEM;
                      ProfileClose( hkFr);

                      iModemCopyOEMInfo(pTG);

                   }
                   else {
                      pTG->fUnimodemFaxDefined = 0;
                      pTG->ModemKeyCreationId = MODEMKEY_FROM_NOTHING;
                   }

                }


                localModemKeyCreationId = pTG->ModemKeyCreationId;
                pTG->AdaptiveAnswerEnable = 0;
                
                //
                // At this point we have all the info from Adaptive.inf or Unimodem Reg.
                // into Modem Reg.
                // We have nothing in memory.
                //

                if (! pTG->ModemClass) {
                   ReadModemClassFromRegistry(pTG);
                }


                if (! pTG->ModemClass) {
                   TalkToModem(pTG, TRUE);
                   SaveModemClass2Registry(pTG);
                }


                //
                // Get data from Modem Reg. into  memory
                //

                iModemGetCurrentModemInfo(pTG);
                pTG->ModemKeyCreationId = localModemKeyCreationId;

        }

        //
        // We are ready now to initialize the hardware.
        // Can be second init (first one is in TalkToModem
        //

        if(! T30ComInit(pTG, pTG->hComm) )
        {
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Cannot Init COM port\r\n"));
                // error already set to ERR_COMM_FAILED
                uRet = INIT_PORTBUSY;
                goto done;
        }

        FComDTR(pTG, TRUE); // Raise DTR in ModemInit
        FComFlush(pTG);

        pTG->fCommInitialized = 1;





        // we use this to decide if we must read our OEM inf files or not....
        fGotOEMInfo = (pTG->TmpSettings.dwGot & (fGOTCMDS|fGOTCAPS|fGOTPARMS));

ReTry:

        // At this point, we have possibly an incompletely and/or
        // incorrectly filled out set of commands and capabilities.

        // must be first, or modem is in a totally unknown state
        if(uRet = iModemFigureOutCmdsExt(pTG))
                goto done;

        // iModemFigureOut leaves modem is a good (synced up) state
        // this needs to be _after_ lpCmdTab is filled out
        if(!iModemGetCaps(pTG, pTG->TmpSettings.lpMdmCaps,
                                        pTG->TmpSettings.dwSerialSpeed,
                                        pTG->TmpSettings.szReset,
                                        &pTG->TmpSettings.dwGot))
        {
                uRet = INIT_GETCAPS_FAIL;
                goto done;
        }

        // we always save settings here because iModemGetWriteIds below
        // will need to possibly override our settings so far...
        iModemSaveCurrentModemInfo(pTG);

        // must be last since it also does the AWMODEM.INF search
        iModemGetWriteIds(pTG, fGotOEMInfo);

        CleanModemInfStrings(pTG);
        imodem_clear_tmp_settings(pTG);

        // Now we've done all we can. We've got all the settings, written them to
        // the INI file. Call back the UI function here. This will read the
        // current settings from INI file, may modify them and returns OK, Cancel
        // and Detect. On OK & Cancel, just exit. On Detect loop back to start
        // of this function, but this time _skip_ UNIMODEM & do detection ourself
        switch(iModemGetUserFeedback(pTG, dwLineID, dwLineIDType))
        {

        case IDCANCEL:
                uRet = INIT_USERCANCEL;
                break;

        case IDOK:
                uRet = 0;
                break;

        case IDRETRY:
                // We allow the user to keep cmds and detect settings, but
                // currently we throw away all settings and try a fresh detect.
                imodem_clear_tmp_settings(pTG);
                fGotOEMInfo=FALSE;
                goto ReTry;
        }

done:

        return uRet;
}


// This function ptr is passed to the FaxSetup UI. It can only be called
// from inside there. It takes an lpCmdTab & lpMdmCaps and verifies them
// as best it can. Expects modem to be all synced up etc.


















USHORT  TestProc(PThrdGlbl pTG, LPCMDTAB lpCmdTab, LPMODEMCAPS lpMdmCaps, USHORT uClass)
{
        USHORT uLen, uSpeed;

        if(!lpCmdTab->szReset || !_fstrlen(lpCmdTab->szReset))
        {
                ERRMSG(("<<ERROR>> NULL RESET string: %s\r\n", (LPSTR)lpCmdTab->szReset));
                return T30_BADPARAM;
        }

        if(iModemReset(pTG, lpCmdTab->szReset) < 0)
        {
                ERRMSG(("<<ERROR>> Error in RESET string: %s\r\n", (LPSTR)lpCmdTab->szReset));
                return T30_MODEMDEAD;
        }

        if(lpCmdTab->szSetup && (uLen=(USHORT)_fstrlen(lpCmdTab->szSetup)))
        {
                if(OfflineDialog2(pTG, (LPSTR)lpCmdTab->szSetup, uLen, cbszOK, cbszERROR) != 1)
                {
                        ERRMSG(("<<ERROR>> Error in SETUP string: %s\r\n", (LPSTR)lpCmdTab->szSetup));
                        return T30_MODEMERROR;
                }
        }

        uSpeed = (USHORT) lpCmdTab->dwSerialSpeed;
        if( (uSpeed < 4800) ||
                ((uSpeed % 2400) != 0) ||
                ((1152 % (uSpeed/100)) != 0) )
        {
                ERRMSG(("<<ERROR>> Illegal serial speed %ld\r\n", lpCmdTab->dwSerialSpeed));
                return T30_BADPARAM;
        }

        if(!iiModemGoClass(pTG, uClass, lpCmdTab->dwSerialSpeed))
        {
                ERRMSG(("<<ERROR>> Can't go to class %d at speed %ld\r\n", uClass, lpCmdTab->dwSerialSpeed));
                return T30_WRONGTYPE;
        }

        if(lpCmdTab->szPreDial && (uLen=(USHORT)_fstrlen(lpCmdTab->szPreDial)))
        {
                if(OfflineDialog2(pTG, (LPSTR)lpCmdTab->szPreDial, uLen, cbszOK, cbszERROR) != 1)
                {
                        ERRMSG(("<<ERROR>> Error in PREDIAL string: %s\r\n", (LPSTR)lpCmdTab->szPreDial));
                        return T30_MODEMERROR;
                }
        }

        if(lpCmdTab->szPreAnswer && (uLen=(USHORT)_fstrlen(lpCmdTab->szPreAnswer)))
        {
                if(OfflineDialog2(pTG, (LPSTR)lpCmdTab->szPreAnswer, uLen, cbszOK, cbszERROR) != 1)
                {
                        ERRMSG(("<<ERROR>> Error in PREANSWER string: %s\r\n", (LPSTR)lpCmdTab->szPreAnswer));
                        return T30_MODEMERROR;
                }
        }

        if(!iiModemGoClass(pTG, 0, 0))
        {
                ERRMSG(("<<ERROR>> Can't go back to class 0 at speed 2400\r\n"));
                return T30_MODEMERROR;
        }

        // also need to check speeds, but punting on that

        return 0;
}















/***-------------------- FLOW CONTROL ----------------------**********

        Each modem seems to have it's own way of setting
        flow control. Here's a survey

Manuf           which modem?            Flow    Sideeffects
-----           ------------            ----    -----------
Rockwell        RC2324AC                        &K4             &H unused.  \Q unused.
US Robotics Sportster14400              &H2             &K0-3 used, &K4 unused. \cmds unused
                        Courier(HST,V32bis)
PracPeriph      PP14400FXMT/SA          &K4             &H unsued. \cmds unused.
                    PP2400EFXSA
Zoom            9600 V.32 VFX           &K4             &H unused. \Q unused
UDSMotorola Fastalk                             \Q1             &H unused &K unused
HayesOptima Optima24/144                &K4             &H unused \cmds unused
MegaHertz       P2144                    \Q1 \Q4        &H unused &K unused
TwinCom         144/DF                          &K4             &H unused \Q unused
PCLogic         ???                                     ???             ????
????            ???                                     \Q1             &H unused &K unused
ATI                     2400 etc                        &K4             &H unused \cmds unused
MultiTech       MultiModemMT1432MU      &E5             &H unused &K unused \Q unused
                        MultiModemII MT932
                        MultiModemII MT224
Viva            14.4i/Fax and 9624i &K4         &H unused \Q unused &E unused
GVC                     "9600bps Fax Modem" \Q1         &H unused &K unused &E unused
SmartOne        1442F/1442FX            &K4             &H unused \Q unused &E unused
DSI                     ScoutPlus                       *F2             &H &E &K \Q1 unused


        We had &K4 and \Q1 commands being sent (until 7/10/93).
        This is a potential problem for US Robotics, MultiTech
        and DSI modems.

        US Robotics defaults to ALL flow control disabled
        DSI ScoutPlus defaults to CTS/RTS flow control
        MultiTech defaults to CTS/RTS flow control
        MultiTech is Class2-only, so we may not have trouble there

7/10/93
        Added &H2 command to iModemReInit -- doesn't affect anyone else I think
later
        Removed &H2 -- some modems use that as  'help' cmd & display a page
        of help info that they refuse to exit except on pressing N or some such!
        So we think the modem's hung!
later
        Removed *F2 -- Starts a Flassh ROM download on Rockwell!!

****-------------------- FLOW CONTROL -------------------------*******/



/*************************************************************************
        According to "Data and Fax Communications" by Hummel,flow control
        settings are as follows

xon     both
&H2     &H3     -- US Robotics (though this fatally invokes Help on some modems)
&K4     -- Dallas, Hayes, Practical, Prometheus, Rockwell, Sierra, Telebit
                        Twincom, Zoom
\Q1     -- AT&T, Dallas, Microcom, Practical, Prometheus, Sierra
*F2             -- Prometheus (though it fatally invokes Flash ROM download on Rockwell)
#K4             -- Sierra-based fax modems
S68=3   -- Telebit

**************************************************************************/


#define AT              "AT"
#define ampF    "&F"
#define S0_0    "S0=0"
#define E0              "E0"
#define V1              "V1"
#define Q0              "Q0"
#define S7_255  "S7=255"
#define ampD2   "&D2"
#define ampD3   "&D3"
#define bsQ1    "\\Q1"
#define bsJ0    "\\J0"
#define ampK4   "&K4"
#define ampH2   "&H2"
#define ampI2   "&I2"
#define ampE5   "&E5"
#define cr              "\r"
//#define       ampC1   "&C1"







USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG)
{
        USHORT uLen1 = 0, uLen2 = 0;
        BOOL fGotFlo;

        // At this point, we have possibly an incompletely and/or
        // incorrectly filled out set of commands and capabilities.

        // Our job here is to use a combination of detection and
        // pre-filled commands to come up with a working set of
        // commands..

        if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
        {
                if (!(pTG->TmpSettings.szReset)
                   || !*(pTG->TmpSettings.szReset)
                   || iModemReset(pTG, pTG->TmpSettings.szReset) >= 0)
                {
                        goto SkipReset;
                }
                else
                {
                        ERRMSG(("<<WARNING>> BOGUS supplied reset cmd: \"%s\"\r\n",
                                                (LPSTR) pTG->TmpSettings.szReset));
                }
        }

        // Quick test to see if we have a modem at all...
        // +++ REMOVE!
        _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT E0 V1 cr);
        if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) < 0)
        {
                ERRMSG(("<<ERROR>> can't set ATE0V1\r\n"));
                goto modem_dead;
        }

        _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 Q0 cr);
        if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
                goto GotReset;

        // too many variants, too slow, V1Q0 are default anyway
        //_fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 cr);
        //if(iModemReset(pTG->TmpSettings.szSmallTemp1) >= 0)
        //      goto GotReset;

        _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 cr);
        if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
                goto GotReset;

        _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF E0 cr);
        if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
                goto GotReset;

        ERRMSG(("<<ERROR>> can't set AT&FE0\r\n"));

        // Purge comm here, because there may be stuff left in the output
        // buffer that FComClose will try to complete, and if the modem
        // is dead, that  will take a while...
modem_dead:
        FComFlush(pTG);

        return INIT_MODEMDEAD;

GotReset:
        pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
        _fstrcpy(pTG->TmpSettings.szReset, pTG->TmpSettings.szSmallTemp1);

SkipReset:
        // now try setup cmd
        if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
        {
                if (!(pTG->TmpSettings.szSetup)
                   || !*(pTG->TmpSettings.szSetup)
                   || OfflineDialog2(pTG, pTG->TmpSettings.szSetup,
                                                (USHORT)_fstrlen(pTG->TmpSettings.szSetup), cbszOK,
                                                        cbszERROR)==1)
                {
                        goto SkipSetup;
                }
                else
                {
                        ERRMSG(("<<WARNING>> BOGUS supplied setup cmd: \"%s\"\r\n",
                                                (LPSTR) pTG->TmpSettings.szSetup));
                }
        }
        _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT);
        uLen2 = sizeof(AT)-1;

        if(OfflineDialog2(pTG, (LPSTR)(AT S7_255 cr), sizeof(AT S7_255 cr)-1, cbszOK, cbszERROR) == 1)
        {
                _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, S7_255);
                uLen2 += sizeof(S7_255)-1;
        }
        else
                ERRMSG(("<<WARNING>> can't set S7=255\r\n"));

        if(OfflineDialog2(pTG, (LPSTR)(AT ampD3 cr), sizeof(AT ampD3 cr)-1, cbszOK, cbszERROR) == 1)
        {
                _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD3);
                uLen2 += sizeof(ampD3)-1;
        }
        else if(OfflineDialog2(pTG, (LPSTR)(AT ampD2 cr), sizeof(AT ampD2 cr)-1, cbszOK, cbszERROR) == 1)
        {
                _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD2);
                uLen2 += sizeof(ampD2)-1;
        }
        else
                ERRMSG(("<<WARNING>> can't set &D3 or &D2\r\n"));

        fGotFlo=FALSE;
        if(OfflineDialog2(pTG, (LPSTR)(AT ampK4 cr), sizeof(AT ampK4 cr)-1, cbszOK, cbszERROR) == 1)
        {
                _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampK4);
                uLen2 += sizeof(ampK4)-1;
                fGotFlo=TRUE;
        }

        // JosephJ 3/10/95: We try \Q1\J0 even if &K4 passed,
        // because many japanese modems return OK to &K4 but in fact
        // use \J0 for xon xoff flow control
        if(OfflineDialog2(pTG, (LPSTR)(AT bsQ1 cr), sizeof(AT bsQ1 cr)-1, cbszOK, cbszERROR) == 1)
        {
                _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsQ1);
                uLen2 += sizeof(bsQ1)-1;

                if(OfflineDialog2(pTG, (LPSTR)(AT bsJ0 cr), sizeof(AT bsJ0 cr)-1, cbszOK, cbszERROR) == 1)
                {
                        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsJ0);
                        uLen2 += sizeof(bsJ0)-1;
                }
                fGotFlo=TRUE;
        }

        if (!fGotFlo)
        {
                ERRMSG(("<<WARNING>> can't set &K4 or \\Q1, trying &K5\r\n"));
                 if(OfflineDialog2(pTG, (LPSTR)(AT ampE5 cr), sizeof(AT ampE5 cr)-1, cbszOK, cbszERROR) == 1)
                {
                        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampE5);
                        uLen2 += sizeof(ampE5)-1;
                        fGotFlo=TRUE;
                }
        }

        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, cr);
        uLen2 += sizeof(cr)-1;

        _fstrcpy(pTG->TmpSettings.szSetup, pTG->TmpSettings.szSmallTemp1);
        pTG->TmpSettings.dwGot |=fGOTCMD_Setup;

SkipSetup:

        if (!pTG->TmpSettings.dwSerialSpeed)
        {
                        pTG->TmpSettings.dwSerialSpeed = pTG->SerialSpeedInit;
                        pTG->TmpSettings.dwGot |=fGOTPARM_PORTSPEED;
        }

        return 0;
}





void 
TalkToModem (
       PThrdGlbl pTG,
       BOOL      fGetClass
       )

{

   char    Command [400];
   char    Response[1000];
   DWORD   RespLen;
   USHORT  uRet;
   char    *lpBeg;
   char    *lpCur;

#define uMULTILINE_SAVEENTIRE   0x1234

   //
   // This function implements special case modems firmware identification
   // as well as modem class identification.
   //

   if ( (! fGetClass) && (pTG->AdaptiveCodeId != 1) ) {
      return;
   }

   //
   // Initialize modem
   //

   if(! T30ComInit(pTG, pTG->hComm) ) {
      MyDebugPrint(pTG, LOG_ERR,"ERROR: TalkToModem cannot init COM port\r\n");
      return;
   }

   FComDTR(pTG, TRUE); // Raise DTR in ModemInit
   FComFlush(pTG);

   pTG->fCommInitialized = 1;
   
   sprintf (Command, "AT E0 Q0 V1\r" );

   if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    {
       MyDebugPrint(pTG, LOG_ERR, "TalkToModem 1 %s FAILED\n",  Command);
       return;
   }
   
   MyDebugPrint(pTG, LOG_ALL, "TalkToModem 1 %s rets OK\n",  Command);


   if (fGetClass) {

      //
      // Get modem class
      //

      pTG->ModemClass=MODEM_CLASS1;  // default
     
      sprintf (Command, "AT+FCLASS=?\r" );
     
      if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    {
          MyDebugPrint(pTG, LOG_ERR, "TalkToModem 1 %s FAILED\n",  Command);
          return;
      }
     
      MyDebugPrint(pTG, LOG_ALL, "TalkToModem 1 %s returned %s\n",  Command, pTG->FComModem.bLastReply);
     
     
      if (strchr(pTG->FComModem.bLastReply, '1') ) {
         MyDebugPrint(pTG, LOG_ALL, "Default to Class1");
      }
      else if ( lpBeg = strchr (pTG->FComModem.bLastReply, '2') )  {
         lpBeg++;
         if ( *lpBeg != '.' ) {
            MyDebugPrint(pTG, LOG_ALL, "Default to Class2");
            pTG->ModemClass=MODEM_CLASS2;
         }
         else if ( strchr (lpBeg, '2') ) {
             MyDebugPrint(pTG, LOG_ALL, "Default to Class2");
             pTG->ModemClass=MODEM_CLASS2;
         }
         else {
            MyDebugPrint(pTG, LOG_ALL, "Default to Class2.0");
            pTG->ModemClass=MODEM_CLASS2_0;
         }
      }
      else {
         MyDebugPrint(pTG, LOG_ERR, "Could not get valid Class answer. Default to Class1");
      }
   }

   //
   // If needed, get firmware identification.
   //

   switch (pTG->AdaptiveCodeId) {
   
   case 1:
      // Sportster 28800-33600 internal/external


      sprintf (Command, "ATI7\r" );

      FComFlushOutput(pTG);
      FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );




      if ( ( uRet = iiModemDialog( pTG, 0, 0, 5000, uMULTILINE_SAVEENTIRE,1, TRUE,
                               cbszOK,
                               cbszERROR,
                               (CBPSTR)NULL) ) != 1 )  {

          MyDebugPrint(pTG, LOG_ERR, "TalkToModem 2 %s FAILED\n",  Command);
          return;
      }

      MyDebugPrint(pTG, LOG_ALL, "TalkToModem 2 %s rets OK\n",  Command);

      RespLen = min(sizeof(Response) - 1,  strlen(pTG->FComModem.bEntireReply) );
      memcpy(Response, pTG->FComModem.bEntireReply, RespLen);
      Response[RespLen] = 0;

      ToCaps(Response);

      //
      // if "EPROM DATE" is "10/18/95" then the adaptive answer is broken (Hugh Riley, USR 03/25/97).
      // otherwise enable adaptive answer.  
      // If we enabled adaptive answer and firmware is broken then the customer needs to upgrade f/w.
      //

      if ( ! strstr(Response, "10/18/95") ) {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      // 
      // found "10/18/95".  Lets check if this is an EPROM DATE.
      //
      if ( ! (lpBeg = strstr(Response, "EPROM DATE") ) ) {
         return;
      }

      if ( ! (lpCur = strstr(lpBeg, "10/18/95") ) ) {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }


      if ( ! strstr(lpCur, "DSP DATE") ) {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      
      return;

   default:
      return;

   }

   return;
}







BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG)
                // Reads as much as it can from the current profile. Returns TRUE
                // IFF it has read enough for a proper init.
                // On failure, zero's out everything.
                // All info is maintained in global TmpSettings;
{
        USHORT          uLen1=0, uLen2=0;
        ULONG_PTR        dwKey=0;
        ULONG_PTR        dwKeyAdaptiveAnswer=0;
        ULONG_PTR        dwKeyAnswer=0;
        BOOL            fRet=FALSE;
        LPMODEMCAPS     lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
        LPMODEMEXTCAPS  lpMdmExtCaps = pTG->TmpSettings.lpMdmExtCaps;
        UINT            uTmp;
        ULONG_PTR        KeyList[10] = {0};
        char            KeyName[200];
        DWORD           i;
        char            lpTemp[MAXCMDSIZE];
        char            szClass[10];

        imodem_clear_tmp_settings(pTG);

        //
        // get T.30 modem Fax key
        //

        if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) {
                goto end;
        }

        //
        // Lets see what modem Class we will use
        //
        uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
        
        if (uTmp == 1) {
           pTG->ModemClass = MODEM_CLASS1;
        }
        else if (uTmp == 2) {
           pTG->ModemClass = MODEM_CLASS2;
        }
        else if (uTmp == 20) {
           pTG->ModemClass = MODEM_CLASS2_0;
        }

        if (! pTG->ModemClass) {
           MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: MODEM CLASS was not defined.\n");
        }

        switch (pTG->ModemClass) {
        
        case MODEM_CLASS1 :
           sprintf(szClass, "Class1");
           break;

        case MODEM_CLASS2 :
           sprintf(szClass, "Class2");
           break;

        case MODEM_CLASS2_0 :
           sprintf(szClass, "Class2_0");
           break;

        default:
           sprintf(szClass, "Class1");
        }


        //
        // depending on a requested operation, find the appropriate settings 
        //

        if (pTG->Operation == T30_RX) {
           KeyList[0] = dwKey;

           sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
           KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

           sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);
           KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

           if (KeyList[2] == 0) {
               pTG->AdaptiveAnswerEnable = 0;

               sprintf(KeyName, "%s\\%s\\Receive", pTG->FComModem.rgchKey, szClass);
               KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
           }
           else {
               dwKeyAdaptiveAnswer = KeyList[2];
               pTG->AdaptiveAnswerEnable = 1;
           }

           KeyList[3] = 0;
        }
        
        else if (pTG->Operation == T30_TX) {
           KeyList[0] = dwKey;

           sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
           KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

           sprintf(KeyName, "%s\\%s\\Send", pTG->FComModem.rgchKey, szClass);
           KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
           
           KeyList[3] = 0;
        }
        else {
           (MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: INVALID pTG->Operation=%d \n") );
           goto end;
        }



        if (lpMdmCaps->uClasses = (USHORT)ProfileListGetInt(KeyList, szModemFaxClasses, 0))
                        pTG->TmpSettings.dwGot |= fGOTCAP_CLASSES;

        if(lpMdmCaps->uClasses & FAXCLASS1)
        {
                if (lpMdmCaps->uSendSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemSendSpeeds, 0))
                                pTG->TmpSettings.dwGot |= fGOTCAP_SENDSPEEDS;
                if (lpMdmCaps->uRecvSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemRecvSpeeds, 0))
                                pTG->TmpSettings.dwGot |= fGOTCAP_RECVSPEEDS;
        }


        pTG->ModemKeyCreationId = ProfileGetInt(dwKey, szModemKeyCreationId, 0, FALSE);

        //RSL 10/10/96

        pTG->Inst.ProtParams.fEnableV17Send   = ProfileListGetInt(KeyList, szEnableV17Send, 1);
        pTG->Inst.ProtParams.fEnableV17Recv   = ProfileListGetInt(KeyList, szEnableV17Recv, 1);





        uTmp = ProfileListGetInt(KeyList, szHighestSendSpeed, 0);
        if (uTmp) {
            pTG->Inst.ProtParams.HighestSendSpeed = (SHORT)uTmp;
        }

        uTmp = ProfileListGetInt(KeyList, szLowestSendSpeed, 0);
        if (uTmp) {
            pTG->Inst.ProtParams.LowestSendSpeed = (SHORT)uTmp;
        }

        // new settings 

        uTmp = ProfileListGetInt(KeyList, szSerialSpeedInit, 0);
        if (uTmp) {
            pTG->SerialSpeedInit = (UWORD)uTmp;
            pTG->SerialSpeedInitSet = 1;
            pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
        }

        uTmp = ProfileListGetInt(KeyList, szSerialSpeedConnect, 0);
        if (uTmp) {
            pTG->SerialSpeedConnect = (UWORD)uTmp;
            pTG->SerialSpeedConnectSet = 1;
            pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
        }

        uTmp = ProfileListGetInt(KeyList, szHardwareFlowControl, 0);
        if (uTmp) {
            pTG->fEnableHardwareFlowControl = 1;
        }


        (MyDebugPrint(pTG, LOG_ALL, "iModemGetCurrentModemInfo: fEnableV17Send=%d, fEnableV17Recv=%d, HighestSendSpeed=%d, Low=%d EnableAdaptAnswer=%d \n",
                                     pTG->Inst.ProtParams.fEnableV17Send,
                                     pTG->Inst.ProtParams.fEnableV17Recv,
                                     pTG->Inst.ProtParams.HighestSendSpeed,
                                     pTG->Inst.ProtParams.LowestSendSpeed,
                                     pTG->AdaptiveAnswerEnable) );
        
        (MyDebugPrint(pTG, LOG_ALL, "HardwareFlowControl=%d, SerialSpeedInit=%d, SerialSpeedConnect=%d\n",
                                     pTG->fEnableHardwareFlowControl,
                                     pTG->SerialSpeedInit,
                                     pTG->SerialSpeedConnect));



        // get CmdTab. We distinguish been a command being not-specified and null.
        //

        if (imodem_list_get_str(pTG, KeyList, szResetCommand,
                                        pTG->TmpSettings.szReset, MAXCMDSIZE, TRUE))
                pTG->TmpSettings.dwGot |= fGOTCMD_Reset;

        if (imodem_list_get_str(pTG, KeyList, szSetupCommand,
                                        pTG->TmpSettings.szSetup, MAXCMDSIZE, TRUE))
                pTG->TmpSettings.dwGot |= fGOTCMD_Setup;

        if (imodem_list_get_str(pTG, KeyList, szPreDialCommand,
                                        pTG->TmpSettings.szPreDial, MAXCMDSIZE, TRUE))
                pTG->TmpSettings.dwGot |= fGOTCMD_PreDial;

        if (imodem_list_get_str(pTG, KeyList, szPreAnswerCommand,
                                        pTG->TmpSettings.szPreAnswer, MAXCMDSIZE, TRUE))
                pTG->TmpSettings.dwGot |= fGOTCMD_PreAnswer;

        if (imodem_list_get_str(pTG, KeyList, szExitCommand,
                                        pTG->TmpSettings.szExit, MAXCMDSIZE, TRUE))
                pTG->TmpSettings.dwGot |= fGOTCMD_PreExit;


        //
        // Adaptive Answer strings ONLY.
        //

        if (pTG->AdaptiveAnswerEnable) {
           
           pTG->AnswerCommandNum = 0;

           // get Answer commands key
           sprintf(KeyName, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey);

           dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

           if (dwKeyAnswer == 0) {
              MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: AdaptiveAnswer\\AnswerCommand does not exist\n");
              goto lPostAdaptiveAnswer;
           }

           for (i=1; i<=20; i++) {
              sprintf (KeyName, "%d", i);
              if ( ! imodem_get_str(pTG, dwKeyAnswer, KeyName, lpTemp, MAXCMDSIZE, TRUE) ) {
                 break;
              }

              pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->AnswerCommand[pTG->AnswerCommandNum], "%s", lpTemp);

              pTG->AnswerCommandNum++;
           }

           if (pTG->AnswerCommandNum == 0) {
              MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: AdaptiveAnswer\\AnswerCommand Zero values. \n");
              ProfileClose(dwKeyAnswer);
              goto lPostAdaptiveAnswer;
           }


           ProfileClose(dwKeyAnswer);


           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->ModemResponseFaxDetect, "%s", lpTemp);
           }


           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->ModemResponseDataDetect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->ModemResponseDataDetect, "%s", lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->SerialSpeedFaxDetect = (UWORD)atoi (lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->SerialSpeedDataDetect = (UWORD)atoi (lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandFaxDetect, lpTemp, MAXCMDSIZE, TRUE) ) {
              pTG->HostCommandFaxDetect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->HostCommandFaxDetect, "%s", lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandDataDetect, lpTemp, MAXCMDSIZE, TRUE) ) {
              pTG->HostCommandDataDetect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->HostCommandDataDetect, "%s", lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxConnect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->ModemResponseFaxConnect, "%s", lpTemp);
           }

           if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataConnect, lpTemp, MAXCMDSIZE, FALSE) ) {
              pTG->ModemResponseDataConnect = MemAlloc( strlen(lpTemp) + 1);
              sprintf ( pTG->ModemResponseDataConnect, "%s", lpTemp);
           }


        }




lPostAdaptiveAnswer:

        pTG->FixSerialSpeed = (UWORD)ProfileListGetInt(KeyList, szFixSerialSpeed, 0);
        if (pTG->FixSerialSpeed) {
             pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
             pTG->FixSerialSpeedSet = 1;
        }


        //
        // Merge 3 optional different settings for Serial Speed here
        //

        // FixSerialSpeed overrides the others (init/connect)

        if (pTG->FixSerialSpeedSet) {
            pTG->SerialSpeedInit = pTG->FixSerialSpeed;
            pTG->SerialSpeedConnect = pTG->FixSerialSpeed;
            pTG->SerialSpeedInitSet = 1;
            pTG->SerialSpeedConnectSet = 1;
        }

        // if only one of init/connect then the other is same

        if ( pTG->SerialSpeedInitSet && (!pTG->SerialSpeedConnectSet) ) {
           pTG->SerialSpeedConnect = pTG->SerialSpeedInit;
           pTG->SerialSpeedConnectSet = 1;
        }
        else if ( (!pTG->SerialSpeedInitSet) && pTG->SerialSpeedConnectSet ) {
           pTG->SerialSpeedInit = pTG->SerialSpeedConnect;
           pTG->SerialSpeedInitSet = 1;
        }

        // values init/connect are always initialized. 
        // Use (init/connect)Set flags to determine whether there were originally set.
        
        if (! pTG->SerialSpeedInit) {
            pTG->SerialSpeedInit    = 19200;
            pTG->SerialSpeedConnect = 19200;
        }



#ifndef MDDI
        // +++ Expand as necessary:
        if (ProfileListGetInt(KeyList, szCL1_NO_SYNC_IF_CMD, 1))
        {
                pTG->TmpSettings.dwFlags |= fMDMSP_C1_NO_SYNC_IF_CMD;
        }
        if (ProfileListGetInt(KeyList, szANS_GOCLASS_TWICE, 1))
        {
                pTG->TmpSettings.dwFlags |= fMDMSP_ANS_GOCLASS_TWICE; // DEFAULT
        }
#define szMDMSP_C1_FCS  "Cl1FCS" // 0==dunno 1=NO 2=yes-bad
        // specifies whether the modem reports the 2-byteFCS with
        // received HDLC data. (Elliot bugs# 3641, 3668, 3086 report
        // cases of modems sending incorrect FCS bytes).
        // 9/7/95 JosephJ -- changed default from 0 to 2 because Class1 spec
        // says we should NOT rely on the FCS bytes being computed correctly.
        switch(ProfileListGetInt(KeyList, szMDMSP_C1_FCS, 2))
        {
                case 1: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_NO;
                        break;
                case 2: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_YES_BAD;
                        break;
        }
        pTG->TmpSettings.dwGot |= fGOTFLAGS;
#endif //!MDDI


        lpMdmExtCaps->dwDialCaps = ProfileListGetInt(KeyList, szDIALCAPS, 0);

        // Retrieve ID command.
        // a way around this Id check. If IdCmd has been manually deleted, skip chk
        if (imodem_list_get_str(pTG, KeyList, szModemIdCmd,
                                        pTG->TmpSettings.szIDCmd, MAXCMDSIZE, TRUE))
        {
                pTG->TmpSettings.dwGot |= fGOTPARM_IDCMD;
                if (imodem_list_get_str(pTG, KeyList, szModemId,
                                        pTG->TmpSettings.szID, MAXIDSIZE, FALSE))
                        pTG->TmpSettings.dwGot |= fGOTPARM_ID;
        }

        pTG->TmpSettings.uDontPurge= (USHORT)ProfileListGetInt(KeyList, szDONT_PURGE, 0xff);


        //
        // Classes 2 and 2.0
        //

        if (pTG->ModemClass != MODEM_CLASS1) {

            uTmp = ProfileListGetInt(KeyList,szRECV_BOR, 0);
            pTG->CurrentMFRSpec.iReceiveBOR = (USHORT) uTmp;
       
            uTmp = ProfileListGetInt(KeyList, szSEND_BOR, 0);
            pTG->CurrentMFRSpec.iSendBOR = (USHORT) uTmp;
                      
            uTmp = ProfileListGetInt(KeyList, szSW_BOR, 0);
            pTG->CurrentMFRSpec.fSWFBOR = (BOOL) uTmp;
       
            uTmp = ProfileListGetInt(KeyList, szDC2CHAR, 82);
            pTG->CurrentMFRSpec.szDC2[0] = (CHAR) uTmp;
       
            uTmp = ProfileListGetInt(KeyList, szIS_SIERRA, 0);
            pTG->CurrentMFRSpec.bIsSierra = (BOOL) uTmp;
       
            uTmp = ProfileListGetInt(KeyList, szIS_EXAR, 0);
            pTG->CurrentMFRSpec.bIsExar = (BOOL) uTmp;
       
            uTmp = ProfileListGetInt(KeyList, szSKIP_CTRL_Q, 0);
            pTG->CurrentMFRSpec.fSkipCtrlQ = (BOOL) uTmp;
        }

        if (dwKey) ProfileClose(dwKey);

#define fMANDATORY (fGOTCMD_Reset|fGOTCMD_Setup|fGOTCAP_CLASSES)
#define fCLASS1MANDATORY (fMANDATORY | fGOTCAP_SENDSPEEDS | fGOTCAP_RECVSPEEDS)
        fRet = (lpMdmCaps->uClasses & FAXCLASS1)
                  ?     ((pTG->TmpSettings.dwGot & fCLASS1MANDATORY) == fCLASS1MANDATORY)
                  :     ((pTG->TmpSettings.dwGot & fMANDATORY) == fMANDATORY);

end:
        
   for (i=1; i<10; i++) {
      if (KeyList[i] != 0) {
         ProfileClose (KeyList[i]);
      }
   }

   return fRet;


}

















BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG)
{
        DWORD_PTR      dwKey=0;
        LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
        char           KeyName[200];
        DWORD_PTR      dwKeyAdaptiveAnswer=0;
        DWORD_PTR      dwKeyAnswer=0;
        DWORD          i;
        char           szClass[10];


        //
        // BUGBUG: Right now we save all major caps at the root level.
        //

          
        if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                        fREG_CREATE | fREG_READ | fREG_WRITE)))
        {
                ERRMSG(("<<ERROR>> Couldn't get location of modem info.\n\r"));
                goto failure;
        }


        if (! pTG->ModemClass) {
           pTG->ModemClass = MODEM_CLASS1;  
           MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: MODEM CLASS was not defined.\n");
        }

        switch (pTG->ModemClass) {
        
        case MODEM_CLASS1 :
           ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
           sprintf(szClass, "Class1");
           break;

        case MODEM_CLASS2 :
           sprintf(szClass, "Class2");
           ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
           break;

        case MODEM_CLASS2_0 :
           sprintf(szClass, "Class2_0");
           ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
           break;

        default:
           sprintf(szClass, "Class1");
        }

        
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->ModemKeyCreationId );
        ProfileWriteString(dwKey, szModemKeyCreationId,   pTG->TmpSettings.szSmallTemp1, FALSE);
        
        
        ////// Modem Commands
        ProfileWriteString(dwKey, szResetCommand,     pTG->TmpSettings.szReset, TRUE);
        ProfileWriteString(dwKey, szSetupCommand,     pTG->TmpSettings.szSetup, TRUE);
        ProfileWriteString(dwKey, szExitCommand ,     pTG->TmpSettings.szExit, TRUE);
        ProfileWriteString(dwKey, szPreDialCommand  , pTG->TmpSettings.szPreDial, TRUE);
        ProfileWriteString(dwKey, szPreAnswerCommand, pTG->TmpSettings.szPreAnswer, TRUE);


        //
        // Adaptive Answer
        //

        if (pTG->AdaptiveAnswerEnable) {

           // create Class key if it doesn't exist

           sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

           dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAdaptiveAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open Class1.\n\r"));
                goto failure;
           }

           ProfileClose(dwKeyAdaptiveAnswer);

           // create Class1\AdaptiveAnswer key if it doesn't exist

           sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

           dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAdaptiveAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open AdaptiveAnswer.\n\r"));
                goto failure;
           }


           // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

           sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey, szClass);

           dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open AdaptiveAnswer\\AnswerCommand .\n\r"));
                goto failure;
           }

           for (i=0; i<pTG->AnswerCommandNum; i++) {
              sprintf (KeyName, "%d", i+1);
              ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
           }

           ProfileClose(dwKeyAnswer);

           // store the rest of the AdaptiveAnswer values

           if (pTG->ModemResponseFaxDetect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);

           if (pTG->ModemResponseDataDetect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);

           if (pTG->SerialSpeedFaxDetect) {
              sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
              ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
           }

           if (pTG->SerialSpeedDataDetect)   {
              sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
              ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
           }


           if (pTG->HostCommandFaxDetect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);

           if (pTG->HostCommandDataDetect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect, TRUE);


           if (pTG->ModemResponseFaxConnect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);

           if (pTG->ModemResponseDataConnect)
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);


           ProfileClose(dwKeyAdaptiveAnswer);

        }


        if (pTG->fEnableHardwareFlowControl) {
           ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
        }


        //
        // Serial Speed
        //

        if (!pTG->SerialSpeedInitSet) {

             wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->TmpSettings.dwSerialSpeed);
             ProfileWriteString(dwKey, szFixSerialSpeed,   pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        else {
           wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
           ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
        }


#ifndef MDDI
        if (pTG->TmpSettings.dwGot & fGOTFLAGS)
        {
                if (pTG->TmpSettings.dwFlags & fMDMSP_C1_NO_SYNC_IF_CMD)
                {
                        ProfileWriteString(dwKey, szCL1_NO_SYNC_IF_CMD, "1", FALSE);
                }

                if (!(pTG->TmpSettings.dwFlags & fMDMSP_ANS_GOCLASS_TWICE))
                {
                        ProfileWriteString(dwKey, szANS_GOCLASS_TWICE, "0", FALSE);
                }
        }
#endif //!MDDI

        // uDontPurge==1 => save 1
        // otherwise     => save 0
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) (pTG->TmpSettings.uDontPurge==1)?1:0);
        ProfileWriteString(dwKey, szDONT_PURGE, pTG->TmpSettings.szSmallTemp1, FALSE);

        ///////// Modem Caps...
        // write out Classes, then Speeds
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uClasses);
        ProfileWriteString(dwKey, szModemFaxClasses,   pTG->TmpSettings.szSmallTemp1, FALSE);


        //
        // Classes 2 and 2.0 
        // 

        if (pTG->ModemClass != MODEM_CLASS1) {

            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iReceiveBOR);
            ProfileWriteString(dwKey, szRECV_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iSendBOR);
            ProfileWriteString(dwKey, szSEND_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSWFBOR);
            ProfileWriteString(dwKey, szSW_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            ProfileWriteString(dwKey, szDC2CHAR, pTG->CurrentMFRSpec.szDC2, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsSierra);
            ProfileWriteString(dwKey, szIS_SIERRA, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsExar);
            ProfileWriteString(dwKey, szIS_EXAR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSkipCtrlQ);
            ProfileWriteString(dwKey, szSKIP_CTRL_Q, pTG->TmpSettings.szSmallTemp1, FALSE);
    
        }

        if(lpMdmCaps->uClasses & FAXCLASS1)
        {
                wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uSendSpeeds);
                ProfileWriteString(dwKey, szModemSendSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);

                wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uRecvSpeeds);
                ProfileWriteString(dwKey, szModemRecvSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (dwKey)
                ProfileClose(dwKey);
        return TRUE;

failure:
        if (dwKey)
                ProfileClose(dwKey);
        return FALSE;
}





BOOL ReadModemClassFromRegistry  (PThrdGlbl pTG)
{

   UINT            uTmp;
   DWORD_PTR       dwKey;


   if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) {
           return FALSE;
   }

   //
   // Lets see what modem Class we will use
   //
   uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
   
   if (uTmp == 1) {
      pTG->ModemClass = MODEM_CLASS1;
   }
   else if (uTmp == 2) {
      pTG->ModemClass = MODEM_CLASS2;
   }
   else if (uTmp == 20) {
      pTG->ModemClass = MODEM_CLASS2_0;
   }

   if (dwKey) 
      ProfileClose(dwKey);

   return TRUE;


}





BOOL SaveModemClass2Registry  (PThrdGlbl pTG)
{
   DWORD_PTR      dwKey=0;



   if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                   fREG_CREATE | fREG_READ | fREG_WRITE)))
   {
           MyDebugPrint(pTG, LOG_ERR, "<<ERROR>> SaveModemClass2Registry: Couldn't get location of modem info.\n\r");
           goto failure;
   }


   switch (pTG->ModemClass) {
   
   case MODEM_CLASS1 :
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
      break;

   case MODEM_CLASS2 :
      ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
      break;

   case MODEM_CLASS2_0 :
      ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
      break;

   default:
      MyDebugPrint(pTG, LOG_ERR, "<<ERROR>> SaveModemClass2Registry: pTG->ModemClass=%d \r", pTG->ModemClass);
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
   }

   if (dwKey)
           ProfileClose(dwKey);

   return TRUE;


failure:
   return FALSE;


}





BOOL SaveInf2Registry  (PThrdGlbl pTG)
{
        DWORD_PTR      dwKey=0;
        LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
        char           KeyName[200];
        DWORD_PTR      dwKeyAdaptiveAnswer=0;
        DWORD_PTR      dwKeyAnswer=0;
        DWORD          i;
        char           szClass[10];


        if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                        fREG_CREATE | fREG_READ | fREG_WRITE)))
        {
                ERRMSG(("<<ERROR>> Couldn't get location of modem info.\n\r"));
                goto failure;
        }


        if (! pTG->ModemClass) {
           MyDebugPrint(pTG, LOG_ERR, "iModemGetCurrentModemInfo: MODEM CLASS was not defined.\n");
        }

        switch (pTG->ModemClass) {
        
        case MODEM_CLASS1 :
           sprintf(szClass, "Class1");
           ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
           break;

        case MODEM_CLASS2 :
           sprintf(szClass, "Class2");
           ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
           break;

        case MODEM_CLASS2_0 :
           sprintf(szClass, "Class2_0");
           ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
           break;

        default:
           sprintf(szClass, "Class1");
        }

        ////// Modem Commands
        if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
           ProfileWriteString(dwKey, szResetCommand,     pTG->TmpSettings.szReset, TRUE);

        if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
           ProfileWriteString(dwKey, szSetupCommand,     pTG->TmpSettings.szSetup, TRUE);

        if (pTG->TmpSettings.dwGot & fGOTCMD_PreExit)
           ProfileWriteString(dwKey, szExitCommand ,     pTG->TmpSettings.szExit, TRUE);

        if (pTG->TmpSettings.dwGot & fGOTCMD_PreDial)
           ProfileWriteString(dwKey, szPreDialCommand  , pTG->TmpSettings.szPreDial, TRUE);
        
        if (pTG->TmpSettings.dwGot & fGOTCMD_PreAnswer)
           ProfileWriteString(dwKey, szPreAnswerCommand, pTG->TmpSettings.szPreAnswer, TRUE);


        //
        // Adaptive Answer
        //

        if (pTG->AdaptiveAnswerEnable) {

           // create szClass key if it doesn't exist

           sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

           dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAdaptiveAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open szClass.\n\r"));
                goto failure;
           }

           ProfileClose(dwKeyAdaptiveAnswer);

           // create Class\AdaptiveAnswer key if it doesn't exist

           sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

           dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAdaptiveAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open AdaptiveAnswer.\n\r"));
                goto failure;
           }


           // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

           sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey ,szClass);

           dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
           if (dwKeyAnswer == 0) {
                ERRMSG(("<<ERROR>> iModemSaveCurrentModemInfo couldn't open AdaptiveAnswer\\AnswerCommand .\n\r"));
                goto failure;
           }

           for (i=0; i<pTG->AnswerCommandNum; i++) {
              sprintf (KeyName, "%d", i+1);
              ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
              MemFree( pTG->AnswerCommand[i]);
              pTG->AnswerCommand[i] = NULL;
           }
           pTG->AnswerCommandNum = 0;
           ProfileClose(dwKeyAnswer);

           // store the rest of the AdaptiveAnswer values

           if (pTG->ModemResponseFaxDetect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);
              MemFree( pTG->ModemResponseFaxDetect );
              pTG->ModemResponseFaxDetect = NULL;
           }

           if (pTG->ModemResponseDataDetect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);
              MemFree (pTG->ModemResponseDataDetect);
              pTG->ModemResponseDataDetect = NULL;
           }

           if (pTG->SerialSpeedFaxDetect) {
              sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
              ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
           }

           if (pTG->SerialSpeedDataDetect)   {
              sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
              ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
           }


           if (pTG->HostCommandFaxDetect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);
              MemFree( pTG->HostCommandFaxDetect);
              pTG->HostCommandFaxDetect = NULL;
           }

           if (pTG->HostCommandDataDetect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect,TRUE);
              MemFree( pTG->HostCommandDataDetect);
              pTG->HostCommandDataDetect = NULL;
           }


           if (pTG->ModemResponseFaxConnect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);
              MemFree( pTG->ModemResponseFaxConnect);
              pTG->ModemResponseFaxConnect = NULL;
           }

           if (pTG->ModemResponseDataConnect) {
              ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);
              MemFree(pTG->ModemResponseDataConnect);
              pTG->ModemResponseDataConnect = NULL;
           }


           ProfileClose(dwKeyAdaptiveAnswer);

        }


        if (pTG->fEnableHardwareFlowControl) {
           ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
        }


        //
        // Serial Speed
        //

        if (pTG->SerialSpeedInitSet) {
           wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
           ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
        }

        //
        // Classes 2 and 2.0
        //

        if (pTG->ModemClass != MODEM_CLASS1) {

            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iReceiveBOR);
            ProfileWriteString(dwKey, szRECV_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iSendBOR);
            ProfileWriteString(dwKey, szSEND_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSWFBOR);
            ProfileWriteString(dwKey, szSW_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            ProfileWriteString(dwKey, szDC2CHAR, pTG->CurrentMFRSpec.szDC2, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsSierra);
            ProfileWriteString(dwKey, szIS_SIERRA, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsExar);
            ProfileWriteString(dwKey, szIS_EXAR, pTG->TmpSettings.szSmallTemp1, FALSE);
    
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSkipCtrlQ);
            ProfileWriteString(dwKey, szSKIP_CTRL_Q, pTG->TmpSettings.szSmallTemp1, FALSE);
    
        }

        if (dwKey)
                ProfileClose(dwKey);
        return TRUE;



failure:
        if (dwKey)
                ProfileClose(dwKey);
        return FALSE;
}













UINT iModemGetUserFeedback(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType)
{

#ifndef DEBUG
        return IDOK; // 8/27/94 JosephJ. Terrib wants it out!

#else // DEBUG

                LPMODEMCAPS lpMdmCaps = pTG->TmpSettings.lpMdmCaps;

#ifndef WIN32
        return IDOK;
#else


#       define szAA "\n\nAccept settings anyway?"
#       define szEM "<empty>"

        UINT uLen=0;
        LPSTR lpsz = pTG->TmpSettings.szResponseBuf;
        UINT uRet = IDOK;

        // Hack to disable UI.
        // if (GetPrivateProfileInt("Modem", "DisableModemClassDialog", 1, szIniFile))

                goto end;

        iModemGetCurrentModemInfo(pTG);
        // for now print out everything into a large message box.
        uLen = wsprintf(lpsz, "Port: %u\n", (unsigned) dwLineID);
        uLen += wsprintf(lpsz+uLen,
                                        "Classes: %u\n", (unsigned) lpMdmCaps->uClasses);
        uLen += wsprintf(lpsz+uLen,
                                        "Send Speeds: %u\n", (unsigned) lpMdmCaps->uSendSpeeds);
        uLen += wsprintf(lpsz+uLen, "Recv Speeds: %u",
                                        (unsigned) lpMdmCaps->uRecvSpeeds);
        uLen += wsprintf(lpsz+uLen, "\n\nReset Command: %s\n",
                                (LPSTR) ((pTG->TmpSettings.szReset)? pTG->TmpSettings.szReset : szEM));
        uLen += wsprintf(lpsz+uLen, "Setup Command: %s\n",
                                (LPSTR) ((pTG->TmpSettings.szSetup)? pTG->TmpSettings.szSetup : szEM));
        uLen += wsprintf(lpsz+uLen, "Pre-dial Command: %s\n",
                                (LPSTR) ((pTG->TmpSettings.szPreDial)?
                                                                        pTG->TmpSettings.szPreDial : szEM));
        uLen += wsprintf(lpsz+uLen, "Pre-answer Command: %s\n",
                                (LPSTR) ((pTG->TmpSettings.szPreAnswer)?
                                                                        pTG->TmpSettings.szPreAnswer :szEM));
        uLen += wsprintf(lpsz+uLen, "Exit Command: %s\n",
                                (LPSTR) ((pTG->TmpSettings.szExit)? pTG->TmpSettings.szExit : szEM));
        uLen += wsprintf(lpsz+uLen, "Port Speed: %lu\n",
                                (unsigned long) pTG->TmpSettings.dwSerialSpeed);

        uLen += wsprintf(lpsz+uLen, "\nDo you accept these settings?\n");
        BG_CHK(uLen<RESPONSEBUFSIZE);

        if (MessageBox(NULL, pTG->TmpSettings.szResponseBuf, "Fake Fax Setup Dialog",
                                                        MB_TASKMODAL|MB_YESNO)==IDYES)
        {
                LPSTR lpszText = "";
                // UINT uRet1;

                if (MessageBox(NULL,
                                        "Do you want the system to test these settings?",
                                        "Fake Fax Setup Dialog",
                                        MB_TASKMODAL|MB_YESNO)==IDYES)
                {
                        USHORT uClass=0;

                        if      (lpMdmCaps->uClasses & FAXCLASS1) uClass=FAXCLASS1;
                        else if (lpMdmCaps->uClasses & FAXCLASS2) uClass=FAXCLASS2;
                        else if (lpMdmCaps->uClasses & FAXCLASS2_0) uClass=FAXCLASS2_0;

#if 0
                        switch(uRet1=TestProc(pTG, lpCmdTab, lpMdmCaps, uClass))
                        {
                        case T30_BADPARAM:
                                lpszText = "Test failed: bad parameter." szAA;
                                break;
                        case T30_MODEMDEAD:
                                lpszText = "Test failed: modem not responding." szAA;
                                break;
                        case T30_MODEMERROR:
                                lpszText = "Test failed: modem reports error." szAA;
                                break;
                        case T30_WRONGTYPE:
                                lpszText = "Test failed: wrong class specified." szAA;
                                break;
                        case T30_OK:
                                lpszText = "Test passed.";
                                break;
                        default:
                                lpszText = "Internal error.";
                                BG_CHK(FALSE);
                        }

                        if (uRet1 != T30_OK)
                        {
                                if (MessageBox(NULL,
                                                lpszText,
                                                "Fake Fax Setup Dialog",
                                                MB_TASKMODAL|MB_YESNO|MB_ICONSTOP)==IDNO)
                                        {uRet=IDCANCEL;}
                        }
                        else
                        {
                                MessageBox(NULL,
                                                lpszText,
                                                "Fake Fax Setup Dialog",
                                                MB_TASKMODAL|MB_OK);
                        }
#endif
                }
        }
        else
        {
                if (MessageBox(NULL,
                                        "Do you want the system to detect the modem settings?",
                                        "Fake Fax Setup Dialog",
                                        MB_TASKMODAL|MB_YESNO)==IDYES)
                        {uRet = IDRETRY;}
                else
                        {uRet = IDCANCEL;}
        }
end:
        return uRet;
#endif // WIN32

#endif // DEBUG
}













BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG)
{
        WORD w;
        LPSTR lpstr;
        LPVOID lpv;

        BG_CHK(    !pTG->TmpSettings.hglb
                        && !pTG->TmpSettings.szReset
                        && !pTG->TmpSettings.szSetup
                        && !pTG->TmpSettings.szExit
                        && !pTG->TmpSettings.szPreDial
                        && !pTG->TmpSettings.szPreAnswer
                        && !pTG->TmpSettings.szID
                        && !pTG->TmpSettings.szIDCmd
                        && !pTG->TmpSettings.szSmallTemp1
                        && !pTG->TmpSettings.szSmallTemp2
                        && !pTG->TmpSettings.szResponseBuf);

        w = TMPSTRINGBUFSIZE;
        pTG->TmpSettings.hglb  = (ULONG_PTR) MemAlloc(TMPSTRINGBUFSIZE);

        if (!pTG->TmpSettings.hglb) goto failure;

        lpv = (LPVOID) (pTG->TmpSettings.hglb);
        lpstr=(LPSTR)lpv;
        if (!lpstr) {MemFree( (PVOID) pTG->TmpSettings.hglb); pTG->TmpSettings.hglb=0; goto failure;}
        pTG->TmpSettings.lpbBuf = (LPBYTE)lpstr;

        _fmemset(lpstr, 0, TMPSTRINGBUFSIZE);

        pTG->TmpSettings.szReset             = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szSetup             = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szExit                      = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szPreDial           = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szPreAnswer         = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szIDCmd             = lpstr; lpstr+=MAXCMDSIZE;
        pTG->TmpSettings.szID                        = lpstr; lpstr+=MAXIDSIZE;
        pTG->TmpSettings.szResponseBuf       = lpstr; lpstr+=RESPONSEBUFSIZE;
        pTG->TmpSettings.szSmallTemp1        = lpstr; lpstr+=SMALLTEMPSIZE;
        pTG->TmpSettings.szSmallTemp2        = lpstr; lpstr+=SMALLTEMPSIZE;

        pTG->TmpSettings.dwGot=0;

        if ( ((LPSTR)lpv+TMPSTRINGBUFSIZE) < lpstr)
        {
                BG_CHK(FALSE); goto failure;
        }

        return TRUE;

failure:
        ERRMSG(("<<ERROR>> init_tmp_strings: MyAlloc/MyLock failed!\r\n"));
        BG_CHK(FALSE);
        return FALSE;
}












void imodem_free_tmp_strings(PThrdGlbl pTG)
{
        if (pTG->TmpSettings.hglb)
        {
                MemFree( (PVOID) pTG->TmpSettings.hglb);
        }
        _fmemset(&pTG->TmpSettings, 0, sizeof(pTG->TmpSettings));
}















void imodem_clear_tmp_settings(PThrdGlbl pTG)
{
        BG_CHK(pTG->TmpSettings.lpMdmCaps);
        _fmemset(pTG->TmpSettings.lpMdmCaps, 0, sizeof(MODEMCAPS));
        _fmemset(pTG->TmpSettings.lpMdmExtCaps, 0, sizeof(MODEMEXTCAPS));
        pTG->TmpSettings.dwGot=0;
        pTG->TmpSettings.uDontPurge=0;
        pTG->TmpSettings.dwSerialSpeed=0;
        pTG->TmpSettings.dwFlags=0;
        _fmemset(pTG->TmpSettings.lpbBuf, 0, TMPSTRINGBUFSIZE);
}








BOOL 
imodem_list_get_str(
    PThrdGlbl pTG,
    ULONG_PTR  KeyList[10],
    LPSTR     lpszName,
    LPSTR     lpszCmdBuf,
    UINT      cbMax,
    BOOL      fCmd)

{

    int       i;
    int       Num=0;
    BOOL      bRet=0;



   for (i=0; i<10; i++) {
     if (KeyList[i] == 0) {
        Num = i-1;
        break;
     }
   }


   for (i=Num; i>=0; i--)  {
     if ( bRet = imodem_get_str(pTG, KeyList[i], lpszName,  lpszCmdBuf, cbMax,  fCmd) ) {
          return bRet;
     }
   }

   
   return bRet;




}









BOOL imodem_get_str(PThrdGlbl pTG, ULONG_PTR dwKey, LPSTR lpszName, LPSTR lpszCmdBuf, UINT cbMax,
                                        BOOL fCmd)
{
        UINT uLen2;
        char *pc = "bogus";

        BG_CHK(cbMax>1);

        *lpszCmdBuf=0;

        uLen2 = ProfileGetString(dwKey, lpszName,
                                        pc, lpszCmdBuf, cbMax-1);
        if (uLen2)
        {
          if (!_fstrcmp(lpszCmdBuf, pc))
          {
                *lpszCmdBuf=0; return FALSE;
          }
          if (fCmd) EndWithCR(lpszCmdBuf, (USHORT)uLen2);
        }

        return TRUE;
}











BOOL iModemCopyOEMInfo(PThrdGlbl pTG)
{

   return ProfileCopyTree(DEF_BASEKEY, pTG->FComModem.rgchKey, OEM_BASEKEY,
                                           pTG->lpszUnimodemFaxKey);

}



#define MASKOFFV17              0x03
#define V27_2400MASK            0x00
#define V27MASK                 0x02
#define V27_V29MASK             0x03

void SmashCapsAccordingToSettings(PThrdGlbl pTG)
{
        // INI file has already been read.

        // If !fV17Enable then smash the V17 bits of the Capabilities
        if(!pTG->Inst.ProtParams.fEnableV17Send) pTG->FComModem.CurrMdmCaps.uSendSpeeds &= MASKOFFV17;
        if(!pTG->Inst.ProtParams.fEnableV17Recv) pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= MASKOFFV17;

        //
        // commented out RSL. We run at 19200. Nowhere in awmodem.inf have I seen FixSerialSpeed clause.
        //

#if 0
        // Adjust RecvSpeeds Caps according to INI setting
        // of DTE baud rate.

        switch(pTG->Inst.FixSerialSpeed)
        {
        case 0:         break; // do nothing
        case 4800:      pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= V27_2400MASK;  // leaves only 2400
                                break;
        case 7200:      pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= V27MASK;               // leaves V27 48 & 24
                                break;
        case 9600:      pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= V27MASK;
                                break;
        case 14400:     pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= V27_V29MASK;
                                break;
        default:        BG_CHK(FALSE);
        }
#endif

        (MyDebugPrint(pTG, LOG_ALL, "SmashCapsAccordingToSettings: uSendSpeeds=%x uRecvSpeeds=%x \n",
                                     pTG->FComModem.CurrMdmCaps.uSendSpeeds,  pTG->FComModem.CurrMdmCaps.uRecvSpeeds) );


}



int
SearchNewInfFile(
       PThrdGlbl     pTG,
       char         *Key1,
       char         *Key2,
       BOOL          fRead
       )

{

   char      szInfSection[] = "SecondKey=";
   DWORD     lenNewInf;
   int       RetCode = FALSE;
   char      Buffer[400];     // to hold lpToken=lpValue string
   char     *lpCurrent;
   char     *lpStartSection;
   char     *lpTmp;
   char     *lpToken;
   char     *lpValue;


   ToCaps(Key1);

   if (Key2) {
      ToCaps(Key2);
   }

   pTG->AnswerCommandNum = 0;


   if ( ( lenNewInf = strlen(szAdaptiveInf) ) == 0 )  {
      return FALSE;
   }
   

   //
   // Loop thru all segments.
   // Each segment starts with InfPath=
   //

   lpCurrent = szAdaptiveInf;

   do {
      // find InfPath

      lpStartSection = strstr (lpCurrent, szResponsesKeyName);
      if (! lpStartSection) {
         goto exit;
      }

      lpTmp = strchr (lpStartSection, '\r' );
      if (!lpTmp) {
         goto exit;
      }

      // compare Key1

      if ( strlen(Key1) != (lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) {
          lpCurrent = lpTmp;
          continue;
      }

      if ( memcmp (lpStartSection+strlen(szResponsesKeyName),
                   Key1,
                   (ULONG)(lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) != 0 ) {
         lpCurrent = lpTmp;
         continue;
      }

      // find InfSection

      lpCurrent = lpTmp;

      if (Key2) {

           lpStartSection = strstr (lpCurrent, szInfSection);
           if (! lpStartSection) {
              goto exit;
           }
         
           lpTmp = strchr (lpStartSection, '\r' );
           if (!lpTmp) {
              goto exit;
           }

          // compare Key2

          if ( strlen(Key2) != (lpTmp - lpStartSection - strlen(szInfSection) ) ) {
              lpCurrent = lpTmp;
              continue;
          }
       
          if ( memcmp (lpStartSection+strlen(szInfSection),
                       Key2,
                       (ULONG)(lpTmp - lpStartSection - strlen(szInfSection)) ) != 0 ) {
             lpCurrent = lpTmp;
             continue;
          }

      lpCurrent = lpTmp;

      }

      //
      // both keys matched. Go get settings and return
      //
      
      do {

         lpCurrent = strchr (lpCurrent, '\r' );
         if (!lpCurrent) {
            goto exit;
         }

         lpCurrent += 2;


         // find next setting inside the matching section

         lpToken = lpCurrent;

         lpCurrent = strchr (lpCurrent, '=' );
         if (!lpCurrent) {
            goto exit;
         }

         lpTmp = strchr (lpToken, '\r' );
         if (!lpTmp) {
            goto exit;
         }

         if (lpCurrent > lpTmp) {
            // empty string
            lpCurrent = lpTmp;
            continue;
         }


         lpValue = ++lpCurrent;

         lpTmp = strchr (lpValue, '\r' );
         if (!lpTmp) {
            goto exit;
         }

         // we parsed the string. Now get it to the Buffer

         if (lpTmp - lpToken > sizeof (Buffer) ) {
            goto exit;
         }

         memcpy(Buffer, lpToken, (ULONG)(lpTmp - lpToken));

         Buffer[lpValue -lpToken - 1] = 0;
         Buffer[lpTmp - lpToken] = 0;
         
         lpValue = &Buffer[lpValue - lpToken];
         lpToken = Buffer;

         pTG->fAdaptiveRecordFound = 1;


         if ( my_strcmp(lpToken, szAdaptiveAnswerEnable) ) {
            pTG->AdaptiveAnswerEnable = atoi (lpValue);
         }

         else if ( my_strcmp(lpToken, szAdaptiveRecordUnique) ) {
            pTG->fAdaptiveRecordUnique = atoi (lpValue);
         }

         else if ( my_strcmp(lpToken, szAdaptiveCodeId) ) {
            pTG->AdaptiveCodeId = atoi (lpValue);
            if ( ! fRead ) {
               goto exit;
            }
         }

         else if ( my_strcmp(lpToken, szFaxClass) ) {
            ;
         }
         
         else if ( my_strcmp(lpToken, szHardwareFlowControl) ) {
            pTG->fEnableHardwareFlowControl = atoi (lpValue);
         }


         else if ( my_strcmp(lpToken, szSerialSpeedInit) ) {
            pTG->SerialSpeedInit = (USHORT)atoi (lpValue);
            pTG->SerialSpeedInitSet = 1;
         }
    
         
         else if ( my_strcmp(lpToken, szResetCommand) ) {
            sprintf ( pTG->TmpSettings.szReset, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
         }

         
         else if ( my_strcmp(lpToken, szSetupCommand) ) {
            sprintf ( pTG->TmpSettings.szSetup, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Setup;
         }

            
               
         else if ( my_strcmp(lpToken, szAnswerCommand) ) {
            if (pTG->AnswerCommandNum > 20) {
               goto exit;
            }
    
            pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->AnswerCommand[pTG->AnswerCommandNum], "%s", lpValue);
            pTG->AnswerCommandNum++;
         }
    
         else if ( my_strcmp(lpToken, szModemResponseFaxDetect) ) {
            pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->ModemResponseFaxDetect, "%s", lpValue);
         }
    
         else if ( my_strcmp(lpToken, szModemResponseDataDetect) ) {
            pTG->ModemResponseDataDetect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->ModemResponseDataDetect, "%s", lpValue);
         }
    
         else if ( my_strcmp(lpToken, szSerialSpeedFaxDetect) ) {
            pTG->SerialSpeedFaxDetect = (USHORT)atoi (lpValue);
         }
    
         else if ( my_strcmp(lpToken, szSerialSpeedDataDetect) ) {
            pTG->SerialSpeedDataDetect = (USHORT)atoi (lpValue);
         }
    
         
               
         else if ( my_strcmp(lpToken, szHostCommandFaxDetect) ) {
            pTG->HostCommandFaxDetect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->HostCommandFaxDetect, "%s", lpValue);
         }
    
         else if ( my_strcmp(lpToken, szHostCommandDataDetect) ) {
            pTG->HostCommandDataDetect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->HostCommandDataDetect, "%s", lpValue);
         }
    
         else if ( my_strcmp(lpToken, szModemResponseFaxConnect) ) {
            pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->ModemResponseFaxConnect, "%s", lpValue);
         }
    
         else if ( my_strcmp(lpToken, szModemResponseDataConnect) ) {
            pTG->ModemResponseDataConnect = MemAlloc( strlen(lpValue) + 1);
            sprintf ( pTG->ModemResponseDataConnect, "%s", lpValue);
         }
    
         
         else if ( my_strcmp(lpToken, szResponsesKeyName2) ) {
            RetCode = TRUE;
            goto exit;
         }

      } while ( 1 );    // section loop


      
   } while ( 1 );       // file loop



   return (FALSE);


exit:
   return (RetCode);



}


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       )

{
   DWORD    i;

   for (i=0; i<pTG->AnswerCommandNum; i++) {
      if (pTG->AnswerCommand[i]) {
         MemFree( pTG->AnswerCommand[i]);
         pTG->AnswerCommand[i] = NULL;
      }
   }

   pTG->AnswerCommandNum = 0;

   if (pTG->ModemResponseFaxDetect) {
      MemFree( pTG->ModemResponseFaxDetect );
      pTG->ModemResponseFaxDetect = NULL;
   }

   if (pTG->ModemResponseDataDetect) {
      MemFree (pTG->ModemResponseDataDetect);
      pTG->ModemResponseDataDetect = NULL;
   }


   if (pTG->HostCommandFaxDetect) {
      MemFree( pTG->HostCommandFaxDetect);
      pTG->HostCommandFaxDetect = NULL;
   }

   if (pTG->HostCommandDataDetect) {
      MemFree( pTG->HostCommandDataDetect);
      pTG->HostCommandDataDetect = NULL;
   }


   if (pTG->ModemResponseFaxConnect) {
      MemFree( pTG->ModemResponseFaxConnect);
      pTG->ModemResponseFaxConnect = NULL;
   }

   if (pTG->ModemResponseDataConnect) {
      MemFree(pTG->ModemResponseDataConnect);
      pTG->ModemResponseDataConnect = NULL;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\makefile.inc ===
obj\$(TARGET_DIRECTORY)\awmodem.h: awmodem.inf
        bin2c -a awmodem.inf obj\$(TARGET_DIRECTORY)\awmodem.h szAwmodemInf

obj\$(TARGET_DIRECTORY)\adaptive.h: adaptive.inf
        bin2c -a adaptive.inf obj\$(TARGET_DIRECTORY)\adaptive.h szAdaptiveInf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\mdmcmds.h ===
#ifdef DEFINE_MDMCMDS

CBSZ cbszAT                     = "AT\r";
CBSZ cbszHANGUP         = "ATH0\r";
CBSZ cbszANSWER         = "ATA\r";
CBSZ cbszDIAL           = "ATD%c %s\r";
CBSZ cbszDIAL_EXT       = "ATX%cD%c %s%s\r";

CBSZ cbszS8                     = "S8=%d";
CBSZ cbszXn                     = "X%d";
CBSZ cbszLn                     = "L%d";
CBSZ cbszMn                     = "M%d";
CBSZ cbszJustAT         = "AT";

CBSZ cbszOK                     = "OK";
CBSZ cbszCONNECT        = "CONNECT";
CBSZ cbszRING           = "RING";
CBSZ cbszNOCARRIER      = "NO CARRIER";
CBSZ cbszERROR          = "ERROR";
CBSZ cbszNODIALTONE     = "NO DIAL"; // Was NO DIALTONE. Changed to fix
                                                                 // Elliot Bug#2009: USR28 and USR14
                                                                  // modems return NO DIAL TONE instead
                                                                  // of NO DIALTONE.
CBSZ cbszBUSY           = "BUSY";
CBSZ cbszNOANSWER       = "NO ANSWER";
CBSZ cbszFCERROR        = "+FCERROR";


CBSZ cbszGO_CLASS0              = "AT+FCLASS=0\r";
CBSZ cbszGO_CLASS1      = "AT+FCLASS=1\r";
CBSZ cbszGO_CLASS2      = "AT+FCLASS=2\r";
CBSZ cbszGO_CLASS2_0    = "AT+FCLASS=2.0\r";
CBSZ cbszGET_CLASS      = "AT+FCLASS?\r";

CBPSTR rgcbpstrGO_CLASS[] =
{       cbszGO_CLASS0,
        cbszGO_CLASS1,
        cbszGO_CLASS2,
        cbszGO_CLASS2_0
};

USHORT uLenGO_CLASS[] =
{
        sizeof(cbszGO_CLASS0)-1,
        sizeof(cbszGO_CLASS1)-1,
        sizeof(cbszGO_CLASS2)-1,
        sizeof(cbszGO_CLASS2_0)-1,
};

CBSZ cbszQUERY_CLASS    = "AT+FCLASS=?\r";
CBSZ cbszQUERY_FTH              = "AT+FTH=?\r";
CBSZ cbszQUERY_FTM              = "AT+FTM=?\r";
CBSZ cbszQUERY_FRH              = "AT+FRH=?\r";
CBSZ cbszQUERY_FRM              = "AT+FRM=?\r";
CBSZ cbszQUERY_S1               = "ATS1?\r";

#else

extern  CBSZ cbszAT;
extern  CBSZ cbszHANGUP;
extern  CBSZ cbszANSWER;
extern  CBSZ cbszDIAL;
extern  CBSZ cbszDIAL_EXT;

extern  CBSZ cbszS8;
extern  CBSZ cbszXn;
extern  CBSZ cbszLn;
extern  CBSZ cbszMn;
extern  CBSZ cbszJustAT;

extern  CBSZ cbszOK;
extern  CBSZ cbszCONNECT;
extern  CBSZ cbszRING;
extern  CBSZ cbszNOCARRIER;
extern  CBSZ cbszERROR;
extern  CBSZ cbszNODIALTONE;



extern  CBSZ cbszBUSY;
extern  CBSZ cbszNOANSWER;
extern  CBSZ cbszFCERROR;


extern  CBSZ cbszGO_CLASS0;
extern  CBSZ cbszGO_CLASS1;
extern  CBSZ cbszGO_CLASS2;
extern  CBSZ cbszGO_CLASS2_0;
extern  CBSZ cbszGET_CLASS;

extern  CBPSTR rgcbpstrGO_CLASS[];

extern  USHORT uLenGO_CLASS[];

extern  CBSZ cbszQUERY_CLASS;
extern  CBSZ cbszQUERY_FTH;
extern  CBSZ cbszQUERY_FTM;
extern  CBSZ cbszQUERY_FRH;
extern  CBSZ cbszQUERY_FRM;
extern  CBSZ cbszQUERY_S1;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\modemint.h ===
/***************************************************************************
 Name     :     MODEMINT.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 60 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 60+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/

#define MAXPHONESIZE    60
#define DIALBUFSIZE     MAXPHONESIZE + 10
#define MAXPROFILENAMESIZE 128


/**---------------------- #define of other things ---------------------

        FAX_CLASSn      is used in Modem.FaxClass.

        CHECK_PATTERN is used in the Guard elements.
        ECM_FRAMESIZE in T30.C

---------------------- #define of other things ---------------------**/

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

// The following bunch of defines allow us to combine detection
// with pre-read settings (from unimodem, say).

#define fGOTCMD_Reset           (0x1)
#define fGOTCMD_Setup           (0x1<<1)
#define fGOTCMD_PreAnswer       (0x1<<2)
#define fGOTCMD_PreDial         (0x1<<3)
#define fGOTCMD_PreExit         (0x1<<4)

#define fGOTCMDS \
          fGOTCMD_Reset \
        | fGOTCMD_Setup \
        | fGOTCMD_PreAnswer \
        | fGOTCMD_PreDial \
        | fGOTCMD_PreExit

#define fGOTCAP_CLASSES         (0x1<<10)
#define fGOTCAP_SENDSPEEDS      (0x1<<11)
#define fGOTCAP_RECVSPEEDS      (0x1<<12)

#define fGOTCAPS \
          fGOTCAP_CLASSES \
        | fGOTCAP_SENDSPEEDS \
        | fGOTCAP_RECVSPEEDS

#define fGOTPARM_PORTSPEED      (0x1<<20)
#define fGOTPARM_IDCMD          (0x1<<21)
#define fGOTPARM_ID                     (0x1<<22)

#define fGOTPARMS \
          fGOTPARM_PORTSPEED \
        | fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTIDS \
          fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTFLAGS (0x1<<23)


// Following structure has stuff which should ideally go into
// MODEMCAPS, but we can't change that at this state (11/94).

extern BOOL                             fMegaHertzHack;



// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
// Looks like even 330 is too short for some modems..
// 550 is too short for Sharad's PP9600FXMT & things
// can get really messed up if this times out, so use
// a nice large value
#define  iSyncModemDialog(pTG, s, l, w)                                                      \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w, (CBPSTR)(NULL))

// This version for dealing with possible NON-numeric responses as well...
#define  iSyncModemDialog2(pTG, s, l, w1, w2)                                                        \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

// mostly use MultiLine instead because we may get asynchronous
// RING responses at arbitrary times when on-hook
// Non-sync related local stuff. SIngle line, single try
// #define  iLocalModemDialog(s, l, w)  iiModemDialog(s, l, 950, FALSE, 1,      (CBPSTR)w, (CBPSTR)(NULL))

// Use these 3 *only* for GetCaps and ATI etc where we are initing
// (*not* re-initing, which can happen while RING is coming in & so need
// more than 1 try.

// temporarily chnage this to 2 tries & see if it slows things down
// too much.

/****************************

// used to get multi-line responses--single try
#define  iMultiLineModemDialog(s, l, w)                                                 \
                iiModemDialog(s, l, 900, TRUE, 2, (CBPSTR)w, (CBPSTR)(NULL))
// used to get multi-line responses--single try
#define  iMultiLineModemDialog2(s, l, w1, w2)                                                   \
                iiModemDialog(s, l, 900, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
// used for optional settings/commands. Single line, single try
#define  iOptionalModemDialog2(s, l, w1, w2)                                                    \
                iiModemDialog(s, l, 850, FALSE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

// used to get multi-line responses--2 tries. Used when RING noises
// can be coming in, and everywhere else off hook.
#define  i2xMultiLineModemDialog(s, l, w)                                                       \
                iiModemDialog(s, l, 950, TRUE, 2, (CBPSTR)w, (CBPSTR)(NULL))

// used to get multi-line responses
#define  i2xMultiLineModemDialog2(s, l, w1, w2)                                                 \
                iiModemDialog(s, l, 950, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

#define  i2xMultiLineModemDialog2Long(s, l, w1, w2)                                                     \
                iiModemDialog(s, l, 1900, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

************************************/

// These are used for offline things, so we make them all (a) multiline
// (b) long timeout (c) 2 tries and (d) make sure they all look for ERROR
// as a response, to speed things up

#define OfflineDialog2(pTG, s,l,w1,w2)        iiModemDialog(pTG, s, l, 5000, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define OfflineDialog3(pTG, s,l,w1,w2,w3) iiModemDialog(pTG, s, l, 5000, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))

// extern void TwiddleThumbs(ULONG ulTime);
// #define OfflineDialog2(s,l,w1,w2)     (TwiddleThumbs(100), iiModemDialog(s, l, 2000, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL)))


#define GOCLASS2_0      3
extern CBSZ cbszOK, cbszERROR;




/****************** begin prototypes from modem.c *****************/
SWORD iModemSync(PThrdGlbl pTG);
SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd);
UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
BOOL iModemGetCaps(PThrdGlbl pTG, LPMODEMCAPS lpMdmCaps,
                                        DWORD dwSpeed, LPSTR lpszReset, LPDWORD lpdwGot);
void TwiddleThumbs(ULONG ulTime);
BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed);
LPSTR my_fstrstr( LPSTR sz1, LPSTR sz2);
/***************** end of prototypes from modem.c *****************/


/****************** begin prototypes from identify.c *****************/
USHORT iModemGetCmdTab(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
        LPCMDTAB lpCmdTab, LPMODEMCAPS lpMdmCaps,  LPMODEMEXTCAPS lpMdmExtCaps,
        BOOL fInstall);
USHORT iModemInstall(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType, BOOL fDontPurge);
USHORT iModemFigureOutCmds(PThrdGlbl pTG, LPCMDTAB lpCmdTab);
USHORT iModemGetWriteCaps(PThrdGlbl pTG);
/***************** end of prototypes from identify.c *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\modem.c ===
/***************************************************************************
        Name      :     MODEM.C
        Comment   :     Various modem dialog & support functions, specific
                                to COM connected modems. For a modem on the bus
                                everything below & including this file is replaced
                                by the modem driver.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/04/92        arulm   Modif to SUPPORT to provide a replaceable interface
                                                        and to use new FCom functions.
***************************************************************************/

#include "prep.h"

#include "mmsystem.h"
#include "modemint.h"
#include "fcomint.h"
#include "fdebug.h"

#ifndef MDDI
#       include "efaxcb.h"
#endif //MDDI

#define DEFINE_MDMCMDS
#include "mdmcmds.h"

///RSL
#include "glbproto.h"


// 12/18/94 JosephJ: CHECKGOCLASS code issues a +FCLASS? after
//                      each +FCLASS=x to verify that the modem has gone to CLASS x.
//                      We have disabled it because we've not been able to repro
//                      a potential bug of the modem not going to CLASS1 when we expect it -
//                      we currently issue AT+FCLASS=x, wait 500ms, and then issue
//                      an AT to resync, but don't check that the class is currect.
//                      The CHECGOCLASS code has been TESTED on a couple of modems, but
//                      I haven't been able to actually kick in -- i.e., catch the modem
//                      in the wrong mode and retry the +FCLASS=x command, so we've
//                      commented out all the code until we can repro the problem.
// #define CHECKGOCLASS

// no need for this--LPZ is now compulsory, PCMODEMS is optional in this
//    module, and we will use inifiles here whether INIFILE is defd or not
//    (INIFILE is not defined for IFAX so that the other (non-test) modules
//    don't use INI files). In IFAX this module is just for test-purposes.
// #if !defined(INIFILE) || !defined(PCMODEMS) || !defined(LPZ)
// #error "INIFILE and LPZ and PCMODEMS _must_ be defined"
// #endif


#define faxTlog(m)                      DEBUGMSG(ZONE_MD, m)
#define faxT2log(m)                     DEBUGMSG(ZONE_DIA, m)
#define FILEID                          FILEID_MODEM

#ifdef DEBUG
#       define  ST_DIA(x)                       if(ZONE_DIA) { x; }
#       define  ST_MOD(x)                       if(ZONE_MD) { x; }
#else
#       define  ST_DIA(x)                       { }
#       define  ST_MOD(x)                       { }
#endif

#ifdef MON3

// Enhanced comm monitor logging...

#define wEVFLAGS_DIAL   fEVENT_TRACELEVEL_1
#define wEVFLAGS_ANSWER fEVENT_TRACELEVEL_1
#define wEVFLAGS_INIT   fEVENT_TRACELEVEL_1
#define wEVFLAGS_DEINIT fEVENT_TRACELEVEL_1
#define wEVFLAGS_HANGUP fEVENT_TRACELEVEL_1

void    InitMonitorLogging(PThrdGlbl pTG);

#else // !MON3
#define InitMonitorLogging(PThrdGlbl pTG) 0
#endif // !MON3


#       pragma message("Compiling with ADAPTIVE_ANSWER")
USHORT iModemGetAdaptiveResp(PThrdGlbl pTG);
#define uMULTILINE_SAVEENTIRE   0x1234 // +++ HACK passed in as fMultiLine
                                                   //  in iiModemDialog to get it so save
                                                   //  entire buffer in FComModem.bEntireReply.

// Need to have these in descending order so that we'll
// Sync at teh highest common speed with auto-bauding modems!
static UWORD rguwSpeeds[] = {19200, 19200, 9600, 2400, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {19200, 2400, 9600, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {2400, 19200, 9600, 1200, 300, 0};











SWORD HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, CBPSTR cbszCommand, UWORD uwLen)
{
        /* Internal routine to synchronize with the modem's speed.  Tries to
           get a response from the modem by trying the speeds in rglSpeeds
           in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
           a response before trying to reset the speeds.

           Returns the speed it found, 0 if they're in sync upon entry (only
           checked if fTryCurrent!=0), or -1 if it couldn't sync.
        */
        // short i;
        short ilWhich = -1;

        rguwSpeeds[0] = pTG->CurrentSerialSpeed;

        if ( rguwSpeeds[0] == rguwSpeeds[1]) {
            ilWhich++;
        }


        BG_CHK(cbszCommand && uwLen);

        BG_CHK(fTryCurrent);
        // has to be TRUE, or we won't work with autobauding modems

        if (!fTryCurrent)
                if(!FComSetBaudRate(pTG, rguwSpeeds[++ilWhich]))
                        return -1;

        for(;;)
        {
                (MyDebugPrint(pTG, LOG_ALL, "Sync Trying: ilWhich=%d  speed=%d\r\n", ilWhich,
                                 rguwSpeeds[ilWhich]));

                if(iSyncModemDialog(pTG, (LPSTR)cbszCommand, uwLen, cbszOK))
                {
                        (MyDebugPrint(pTG, LOG_ALL, "Succeeded in Syncing at Speed = %d (il=%d)\r\n",
                                         rguwSpeeds[ilWhich], ilWhich));
                    return (ilWhich>=0 ? rguwSpeeds[ilWhich] : 0);
                }

                /* failed.  try next speed. */
                if (rguwSpeeds[++ilWhich]==0)
                {
                        // Tried all speeds. No response
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Cannot Sync with Modem on Command %s\r\n", (LPSTR)cbszCommand));
                        iModemSetError(pTG, MODEMERR_HARDWARE, ERR_MODEM_NORESPONSE, MODEMERRFLAGS_FATAL);
                    return -1;
                }
                if(!FComSetBaudRate(pTG, rguwSpeeds[ilWhich]))
                        return -1;
        }
}






SWORD iModemSync(PThrdGlbl pTG)
{
        // The command used here must be guaranteed to be harmless,
        // side-effect free & non-dstructive. i.e. we can issue it
        // at any point in command mode without chnageing the state
        // of teh modem or disrupting anything.
        // ATZ does not qualify. AT does, I think.....

        return HayesSyncSpeed(pTG, TRUE, cbszAT, sizeof(cbszAT)-1);
}
















SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd)
{
        SWORD swRet;

        if (szCmd == NULL) {
            return -1;
        }

        if((swRet = HayesSyncSpeed(pTG, TRUE, szCmd, (UWORD) _fstrlen(szCmd))) < 0)
                return swRet;
        else
        {
                // ATZ may result in a change in the state/baud rate of the modem
                // (eg. Thought board drops to 2400), therefore we must Sync up
                // again because this function is really a Reset&Sync function.

                // instead of syncing up on AT and then doing ATE0, just
                // sync up on ATE0 directly

                if(iModemSync(pTG) < 0)
                        return -1;

                /////////////////////
                // the above "brilliant" idea messed up Sharad's PP9600FXMT
                // somehow I end up sending it ATATE0 and it answers the phone
                // In other cases, the ATE0 simply has no effect (because the AT&F
                // thing above got confused and teh ATE0 ended up just aborting
                // some previous command) and on ATA I get the ATA echoed,
                // get confused (because multi-line is FALSE) & send ATA again
                // which aborts the whole thing....
                //
                // return HayesSyncSpeed(TRUE, cbszATE0, sizeof(cbszATE0)-1);
                //

                return 0;
        }

}










//////////////////////////////////////////////////////////////////////////////////////////////////////////////
USHORT
T30ModemInit(
    PThrdGlbl pTG,
    HANDLE  hComm,
    DWORD   dwLineID,
    DWORD   dwLineIDType,
    DWORD   dwProfileID,
    LPSTR   lpszKey,
    BOOL    fInstall
    )
{

        USHORT uLen, uRet;

        /*** Inits (or re-inits) the COM port, Syncs up with Modem (at whatever,
                 speed), gets modem capabilities, puts it into CLASS0, syncs again,
                  flushes buffers and returns TRUE on success FALSE on failure
        ***/


        // Save the profile ID and key string.
        pTG->FComModem.dwProfileID = dwProfileID;

        uLen = min(_fstrlen(lpszKey), sizeof(pTG->FComModem.rgchKey)-1);
        _fmemcpy(pTG->FComModem.rgchKey, lpszKey, uLen);
        pTG->FComModem.rgchKey[uLen] = 0;

        if (!uLen)
        {
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Bad param: ProfileID=0x%lx; Key=%s\r\n",
                                        (unsigned long) pTG->FComModem.dwProfileID,
                                        (LPSTR) pTG->FComModem.rgchKey));
                return INIT_INTERNAL_ERROR;
        }

        InitMonitorLogging(pTG);

        //
        // Get the modem info before talking to h/w.
        //

        if(uRet = iModemGetCmdTab(pTG, dwLineID, dwLineIDType,
                        &pTG->FComModem.CurrCmdTab, &pTG->FComModem.CurrMdmCaps,
                        &pTG->FComModem.CurrMdmExtCaps, fInstall))
        {
                        goto error;
        }


        if (dwLineIDType==LINEID_COMM_HANDLE)
        {
                // Let's try to sync up with a simple AT command here...
                // Sometimes the modem could be busy sending RINGS at the wrong
                // speed and it seems to return OK to the reset string but
                // not interpret it?????
                // ALSO: (this is a general problem, in faxt) the modem could be
                // in NUMERIC mode, in which case it will return "0", not "OK"!
                // So we  check for 0 as well...

#define ATV1            "ATV1"
#define AT                  "AT"
#define cr              "\r"
#define  cbszZero "0"


                if (!iSyncModemDialog2(pTG, AT cr,sizeof(AT cr)-1,cbszOK,cbszZero))
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> couldn't sync up to modem on takeover"));
                }
        }

        // use MultiLine because we may get asynchronous RING responses
        // at arbitrary times when on-hook

        if(pTG->FComModem.CurrCmdTab.szSetup && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szSetup)))
        {
                if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szSetup, uLen, cbszOK, cbszERROR) != 1)
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Error in SETUP string: %s\r\n", (LPSTR)pTG->FComModem.CurrCmdTab.szSetup));
                        // SETUP is usually the defaults?? So do nothing if this fails
                        // uRet = INIT_MODEMERROR;
                        // goto error;
                }
        }

        switch (pTG->dwSpeakerMode) {

            case MDMSPKR_OFF:
                pTG->NCUParams.SpeakerControl = 0;
                break;

            case MDMSPKR_DIAL:
                pTG->NCUParams.SpeakerControl = 1;
                break;

            case MDMSPKR_ON:
                pTG->NCUParams.SpeakerControl = 2;
                break;

            default:
                pTG->NCUParams.SpeakerControl = 0;
                break;
        }


        switch (pTG->dwSpeakerVolume) {

            case MDMVOL_LOW:
                pTG->NCUParams.SpeakerVolume = 0;
                break;

            case MDMVOL_MEDIUM:
                pTG->NCUParams.SpeakerVolume = 2;
                break;

            case MDMVOL_HIGH:
                pTG->NCUParams.SpeakerVolume = 3;
                break;

            default:
                pTG->NCUParams.SpeakerVolume = 0;
                break;
        }


        pTG->NCUParams.DialBlind      = 4;  //X4

        // need to do this every time after a Reset/AT&F
        iModemSetNCUParams(pTG, (fInstall==fMDMINIT_ANSWER)?(-1): pTG->NCUParams.DialPauseTime,
                                                pTG->NCUParams.SpeakerControl,
                                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                                pTG->NCUParams.SpeakerRing);
        pTG->fNCUParamsChanged=FALSE;

        InitCommErrCount(pTG);

        // Why is this here??
        FComFlush(pTG);

        pTG->FComStatus.fModemInit = TRUE;
        // pTG->fNCUAbort = 0;
        uRet = INIT_OK;
        goto end;

error:
        FComClose(pTG);
        pTG->FComStatus.fModemInit = FALSE;
        // fall through...
end:
        PUTEVENT(pTG, wEVFLAGS_INIT, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_INIT_END,
                                uRet, 0, NULL);
        return uRet;
}












LPCMDTAB iModemGetCmdTabPtr(PThrdGlbl pTG)
{
        BG_CHK(pTG->FComStatus.fModemInit);
        BG_CHK(pTG->FComModem.CurrCmdTab.szReset);

        return (pTG->FComStatus.fModemInit) ? &pTG->FComModem.CurrCmdTab: NULL;
}










BOOL   iModemSetNCUParams(PThrdGlbl pTG, int comma, int speaker,
                                            int volume, int fBlind, int fRingAloud)
{
#define PARAMSBUFSIZE   60

        char bBuf[PARAMSBUFSIZE];
        USHORT uLen;

        _fstrcpy(bBuf, cbszJustAT);
        uLen = sizeof(cbszJustAT)-1;

        // +++ If we want to split this into dial-tone & busy-tone we
        //         Do it here...
        if ( (fBlind >= 0) && (pTG->ModemKeyCreationId == MODEMKEY_FROM_NOTHING) )
        {

#define SPLIT_BLIND
#ifdef SPLIT_BLIND
#               define fDETECT_DIALTONE 1
#               define fDETECT_BUSYTONE 2
                UINT u=0;
                switch(fBlind)
                {
                case 0:
                        break;
                case fDETECT_DIALTONE:
                        u=2;
                        break;
                case fDETECT_BUSYTONE:
                        u=3;
                        break;
                default:
                        u=4;
                        break;
                }
                uLen += (USHORT)wsprintf(bBuf+uLen, cbszXn, u);
#else // !SPLIT_BLIND
                uLen += (USHORT)wsprintf(bBuf+uLen, cbszXn, (fBlind ? 0 : 4));
#endif
        }

        if(comma >= 0)
        {
                if(comma > 255)
                {
                        BG_CHK(FALSE);
                        comma = 255;
                }
                uLen += (USHORT)wsprintf(bBuf+uLen, cbszS8, comma);
        }
        if(speaker >= 0)
        {
                if(speaker > 2)
                {
                        BG_CHK(FALSE);
                        speaker = 2;
                }
                uLen += (USHORT)wsprintf(bBuf+uLen, cbszMn, speaker);
        }
        if(volume >= 0)
        {
                if(volume > 3)
                {
                        BG_CHK(FALSE);
                        volume = 3;
                }
                uLen += (USHORT)wsprintf(bBuf+uLen, cbszLn, volume);
        }

        // do something with RingAloud

        bBuf[uLen++] = '\r';
        bBuf[uLen] = 0;

        // use MultiLine because we may get asynchronous RING responses
        // at arbitrary times when on-hook
        if(OfflineDialog2(pTG, (LPSTR)bBuf, uLen, cbszOK, cbszERROR) != 1)
        {
                BG_CHK(FALSE);
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Can't Set NCU params\r\n"));
                return FALSE;
        }
        return TRUE;
}




















UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
        UWORD uRet1=0, uRet2=0, uRet3=0;

        // We call GetCapAux twice and if they don't match we
        // call it a 3rd time and arbitrate. Provided it doesn't
        // fail the first time.
        if (!(uRet1=GetCapAux(pTG, cbpstrSend, uwLen))) goto end;
        uRet2=GetCapAux(pTG, cbpstrSend, uwLen);
        if (uRet1!=uRet2)
        {
                        (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> 2nd getcaps return differs 1=%u,2=%u\r\n",
                                                (unsigned) uRet1, (unsigned) uRet2));
                        uRet3=GetCapAux(pTG, cbpstrSend, uwLen);
                        if (uRet1==uRet2 || uRet1==uRet3) {goto end;}
                        else if (uRet2==uRet3)                    {uRet1=uRet2; goto end;}
                        else
                        {
                                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> all 2 getcaps differ! 1=%u,2=%u, 3=%u\r\n",
                                                (unsigned) uRet1, (unsigned) uRet2,
                                                (unsigned) uRet3));
                        }

        }

end: return uRet1;

}


















UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
        NPSTR sz;
        BYTE  speed, high;
        UWORD i, code;
        USHORT  retry;
        USHORT  uRet;

        retry = 0;
restart:
        retry++;
        if(retry > 2)
                return 0;

        (MyDebugPrint(pTG, LOG_ALL, "Want Caps for (%s)\r\n", (LPSTR)cbpstrSend));

        pTG->fMegaHertzHack = TRUE;
        uRet = OfflineDialog2(pTG, (LPSTR)cbpstrSend, uwLen, cbszOK, cbszERROR);
        pTG->fMegaHertzHack=FALSE;

        // sometimes we don't get the OK so try to parse what we got anyway
        (MyDebugPrint(pTG, LOG_ALL, "LastLine = (%s)\r\n ", (LPSTR)(&(pTG->FComModem.bLastReply))));

        if(uRet == 2)
                goto restart;

        if(_fstrlen((LPSTR)pTG->FComModem.bLastReply) == 0)
                goto restart;

        speed = 0;
        high = 0;
        for(i=0, sz=pTG->FComModem.bLastReply, code=0; i<REPLYBUFSIZE && sz[i]; i++)
        {
                if(sz[i] >= '0' &&  sz[i] <= '9')
                {
                        code = code*10 + (sz[i] - '0');
                        continue;
                }
                // reached a non-numeric char
                // if its teh first after a code, need to process the code.

                switch(code)
                {
                case 0:  continue;      // not the first char after a code
                case 3:  break;
                case 24: break;
                case 48: speed |= V27; break;
                case 72:
                case 96: speed |= V29; break;
                case 73:
                case 97:
                case 121:
                case 145: speed |= V33; break;  // long-train codes
                case 74:
                case 98:
                case 122:
                case 146: speed |= V17; break;  // short-train codes

                //case 92:
                //case 93:      break;
                // case 120: // not legal
                // case 144: // not legal
                default:
                                MyDebugPrint(pTG, LOG_ALL, "WARNING: Ignoring unknown Modulation code = %d\r\n", code);
                                // +++ goto restart;
                                code=0;
                                break;
                                // BG_CHK(FALSE);
                                // return 0;
                }
                if(code > high)
                        high=(BYTE)code;

                // reset code counter after processing the baud rate code
                code = 0;
        }

        if(speed == 0)
        {
                // got garbage in response to query
                (MyDebugPrint(pTG, LOG_ALL, "Can't get Caps for (%s\r\n) = 0x%04x  Highest=%d\r\n", (LPSTR)cbpstrSend, speed, high));
                return 0;
        }

        if(speed == 0x0F) speed = V27_V29_V33_V17;

/// RICOH's broken 1st prototype ////////////
///     speed = V27_SLOW;
///     high = 24;
/// RICOH's broken 1st prototype ////////////

        (MyDebugPrint(pTG, LOG_ALL, "Got Caps for (%s\r\n) = 0x%04x  Highest=%d\r\n", (LPSTR)cbpstrSend, speed, high));
        return MAKEWORD(speed, high);   // speed==low byte
}






















BOOL iModemGetCaps(PThrdGlbl pTG, LPMODEMCAPS lpMdmCaps, DWORD dwSpeed, LPSTR lpszReset,
                                        LPDWORD lpdwGot)
{
        /** Modem must be synced up and in normal (non-fax) mode.
                Queries available classes,
                HDLC & Data receive and transmit speeds. Returns
                TRUE if Modem is Class1 or Class2, FALSE if not fax modem
                or other error. Sets the fields in the ET30INST struct **/
        // lpszReset, if nonempty, will be used to reset the modem after
        // the FCLASS=? command see comment about US Robotics Sportster below...

        UWORD   i, uwRet;
        BYTE    speed;
        BOOL    err;
        NPSTR   sz;
        USHORT  retry, uResp;

        if (!*lpdwGot) {_fmemset(lpMdmCaps, 0, sizeof(MODEMCAPS));}

        (MyDebugPrint(pTG, LOG_ALL, "Entering ModemGetCaps\r\n"));

        if (*lpdwGot & fGOTCAP_CLASSES) goto GotClasses;

        for(retry=0; retry<2; retry++)
        {
                pTG->fMegaHertzHack = TRUE;
                uResp = OfflineDialog2(pTG, (LPSTR)cbszQUERY_CLASS, sizeof(cbszQUERY_CLASS)-1, cbszOK, cbszERROR);
                pTG->fMegaHertzHack=FALSE;
                if(uResp != 2)
                        break;
        }

        // sometimes we don't get the OK so try to parse what we got anyway
        (MyDebugPrint(pTG, LOG_ALL, "LastLine = (%s)\r\n", (LPSTR)(&(pTG->FComModem.bLastReply))));


        lpMdmCaps->uClasses = 0;
#ifdef CL0
        lpMdmCaps->uClasses |= FAXCLASS0; // Class0 always available
#endif //CL0

        for(i=0, sz=pTG->FComModem.bLastReply; i<REPLYBUFSIZE && sz[i]; i++)
        {
                UINT uDig=0, uDec=(UINT)-1;

                // This code will accept 1.x as class1, 2 as class2 and 2.x as class2.0
                // Also, it will not detect class 1 in 2.1 or class2 in 1.2 etc.
                // (JDecuir newest class2.0 is labeled class2.1, and he talks
                //  of class 1.0...)
                if(sz[i] >= '0' && sz[i] <= '9')
                {
                        uDig = sz[i]- '0';
                        if (sz[i+1]=='.')
                        {
                                i++;
                        if(sz[i+1] >= '0' && sz[i+1] <= '9')
                                {
                                        uDec = sz[i] - '0';
                                        i++;
                                }
                        }
                }
                if(uDig==1) lpMdmCaps->uClasses |= FAXCLASS1;
                if(uDig==2) {
                        if (uDec==((UINT)-1)) lpMdmCaps->uClasses |= FAXCLASS2;
                        else                              lpMdmCaps->uClasses |= FAXCLASS2_0;
                }

        }
        *lpdwGot |= fGOTCAP_CLASSES;

GotClasses:

        BG_CHK(*lpdwGot & fGOTCAP_CLASSES);
        BG_CHK(lpMdmCaps->uClasses & (FAXCLASS1|FAXCLASS2|FAXCLASS2_0));

        if(lpMdmCaps->uClasses & FAXCLASS2_0)
        {
                // Test Class2.0 ability
#ifndef CL2_0
                (MyDebugPrint(pTG, LOG_ERR,"Class2.0 modem -- IS NOT supported\r\n"));
                lpMdmCaps->uClasses &= (~FAXCLASS2_0);
#else //CL2_0
/****************************************************
                (MyDebugPrint(pTG, LOG_ERR,"Class2.0 modem -- IS NOW supported\r\n"));
                if(!iiModemGoClass(GOCLASS2_0) || !iiModemGoClass(0))
                {
                        (MyDebugPrint(pTG, LOG_ERR,"Failed to change Class\r\n"));
                        lpMdmCaps->uClasses &= (~FAXCLASS2_0);
                }
****************************************************/
#endif //CL2_0
        }

        if(lpMdmCaps->uClasses & FAXCLASS2)
        {
                // Test Class2 ability
#ifndef CL2
                (MyDebugPrint(pTG, LOG_ERR,"Class2 modem -- IS NOT supported\r\n"));
                lpMdmCaps->uClasses &= (~FAXCLASS2);
#else //CL2
         // +++ why is this and class2.0 below commented out?
/****************************************************
                (MyDebugPrint(pTG, LOG_ERR,"Class2 modem -- IS NOW supported\r\n"));
                if(!iiModemGoClass(2) || !iiModemGoClass(0))
                {
                        (MyDebugPrint(pTG, LOG_ERR,"Failed to change Class\r\n"));
                        lpMdmCaps->uClasses &= (~FAXCLASS2);
                }
****************************************************/
#endif //CL2
        }

        if(!lpMdmCaps->uClasses)
        {
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Not a fax modem or unsupported fax class\r\n"));
                iModemSetError(pTG, MODEMERR_HARDWARE, ERR_NOTFAX, MODEMERRFLAGS_FATAL);
                *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
                return FALSE;
        }

        if(!(lpMdmCaps->uClasses & FAXCLASS1)) return TRUE;

///////////////// rest is for Class1 only //////////////////////////

        //////////
        // MERGED from SNOWBALL.RC, but can't really do this in new scheme!!
        // The US Robotics Sportster Swedish resets itself after AT+FCLASS=?
        // So we need to issue a ATE0 here before trying to get caps
        // This is timing independent.
        // if(OfflineDialog2((LPSTR)cbszATE0, sizeof(cbszATE0)-1, cbszOK, cbszERROR) != 1)
        // {
        //      (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Error on ATE0 in GetCaps %s\r\n", (LPSTR)cbszATE0));
        // }
        //////////
        //              +++ why is this done only for Class1?
        // What we do instead is send the Reset command
        if(lpszReset && *lpszReset && iModemReset(pTG, lpszReset) < 0) return FALSE;
        //////////

        if(!iiModemGoClass(pTG, 1, dwSpeed)) goto NotClass1;

        err = FALSE;
/**
        uwRet = GetCap(cbszQUERY_FTH, sizeof(cbszQUERY_FTH)-1);
                        // err = (err || uwRet==0);     // not an err for FTH
                        speed = LOBYTE(uwRet);
                        BG_CHK((speed & ~0x0F)==0);
                        lpMdmCaps->uHDLCSendSpeeds = speed;
**/
        if (!(*lpdwGot & fGOTCAP_SENDSPEEDS))
        {
                uwRet = GetCap(pTG, cbszQUERY_FTM, sizeof(cbszQUERY_FTM)-1);
                                err = (err || uwRet==0);
                                speed = LOBYTE(uwRet);
                                BG_CHK((speed & ~0x0F)==0);
                                lpMdmCaps->uSendSpeeds = speed;
                *lpdwGot |= fGOTCAP_SENDSPEEDS;
        }
/**
        uwRet = GetCap(cbszQUERY_FRH, sizeof(cbszQUERY_FRH)-1);
                        // err = (err || uwRet==0); // not an err for FTH
                        speed = LOBYTE(uwRet);
                        BG_CHK((speed & ~0x0F)==0);
                        lpMdmCaps->uHDLCRecvSpeeds = speed;
**/
        if (!(*lpdwGot & fGOTCAP_RECVSPEEDS))
        {
                uwRet = GetCap(pTG, cbszQUERY_FRM, sizeof(cbszQUERY_FRM)-1);
                                err = (err || uwRet==0);
                                speed = LOBYTE(uwRet);
                                BG_CHK((speed & ~0x0F)==0);
                                lpMdmCaps->uRecvSpeeds = speed;
                *lpdwGot |= fGOTCAP_RECVSPEEDS;
        }

        if(!iiModemGoClass(pTG, 0, dwSpeed))
                err = TRUE;

        if(err)
        {
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Cannot get capabilities\r\n"));
                iModemSetError(pTG, MODEMERR_HARDWARE, ERR_NOCAPS, MODEMERRFLAGS_FATAL);
                goto NotClass1;
        }

        (MyDebugPrint(pTG, LOG_ALL, "Got Caps\r\n"));
        return TRUE;

NotClass1:
        // Reported Class1 but failed AT+FCLASS=1 or one of the Cap queries
        // GVC9624Vbis does this. See bug#1016
        // FIX: Just zap out the Class1 bit. If any other class supported
        // then return TRUE, else FALSE

        lpMdmCaps->uClasses &= (~FAXCLASS1);    // make the Class1 bit==0
        if(lpMdmCaps->uClasses)
                return TRUE;
        else
        {
                *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
                return FALSE;
        }
}















void TwiddleThumbs1( ULONG ulTime)
{
        BEFORESLEEP;

        // doesnt make sense to sleep for less
        // when talking to bad modems
        // BG_CHK(ulTime >= 40);

        MY_TWIDDLETHUMBS(ulTime);

        AFTERSLEEP(ulTime);
}














BOOL   iModemGoClass(PThrdGlbl pTG, USHORT uClass)
{
        return iiModemGoClass(pTG, uClass, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
}


// #ifdef CHECKGOCLASS
// #define GOCLASS_PAUSE 500
// #endif // CHECKGOCLASS


















BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed)
{
        int i;
        USHORT uBaud;
// #ifdef CHECKGOCLASS
//      USHORT uPause=GOCLASS_PAUSE;
// #endif // CHECKGOCLASS


        BG_CHK(!(dwSpeed & 0xFFFF0000L));

        for(i=0; i<3; i++)
        {
                // UDS V.3257 modem needs this time, because if we send it a
                // command too quickly after the previous response, it ignores
                // it or gets garbage
                TwiddleThumbs1(100);
                FComFlush(pTG);
                if(!FComDirectSyncWriteFast(pTG, (LPB)rgcbpstrGO_CLASS[uClass], uLenGO_CLASS[uClass]))
                        goto error;
                // wait 500ms. Give modem enough time to get into Class1 mode
                // otherwise the AT we send may abort the transition
// #ifdef CHECKGOCLASS
//              TwiddleThumbs1(uPause);
//#else // !CHECKGOCLASS
                TwiddleThumbs1(500);
//#endif // !CHECKGOCLASS

                if(dwSpeed)
                {
                        USHORT usSpeed  = (USHORT) dwSpeed;
                        BG_CHK((usSpeed >= 4800) &&
                                 ((usSpeed % 2400) == 0) &&
                                 ((1152 % (usSpeed/100)) == 0));

                        uBaud = usSpeed;
                }
                else if (pTG->SerialSpeedInit) {
                   uBaud = pTG->SerialSpeedInit;

                }
                else {
                   uBaud = 19200;
                }

                // RSL don't do hard-coded 2400 for class0.

                FComSetBaudRate(pTG, uBaud);

                FComFlush(pTG);
                if(iModemSync(pTG) >= 0)
                {
//#ifdef CHECKGOCLASS
//                      // Let's verify the class..
//                      if (!iModemVerifyClass(uClass)) {uPause*=2; continue;}
//#endif CHECKGOCLASS
                        InitCommErrCount(pTG);
                        return TRUE;
                }
        }
error:
        // no point -- and we'll smash our settings
        // iModemReset();
        // error is already set to ERR_NO_RESPONSE inside HayesSync()
        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Cant go to Class %d\r\n", uClass));
        return FALSE;
}















BOOL   iModemClose(PThrdGlbl pTG)
{
        USHORT uLen;
        BOOL fRet=FALSE;

        if(!pTG->FComStatus.fModemInit)
                return TRUE;


        PUTEVENT(pTG, wEVFLAGS_DEINIT, EVENT_ID_MODEM_STATE,
                                EVENT_SubID_MODEM_DEINIT_START, 0, 0, NULL);
        /** Hangs up the phone if it is off hook, closes the COM port
                and returns. If hangup fails then port is also left open. **/

        ////////////////////////////////////////////////////////////
        /// we should close the port anyway ////////////////////////
        /// Or put up a Dialog box or something......///////////////
        ////////////////////////////////////////////////////////////

        if(!iModemHangup(pTG))
                goto end;


        if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) {
            goto lNext;
        }

        if(pTG->FComModem.CurrCmdTab.szExit && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szExit)))
        {
                if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szExit, uLen, cbszOK, cbszERROR) != 1)
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Error in EXIT string: %s\r\n", (LPSTR)pTG->FComModem.CurrCmdTab.szExit));
                }
        }


lNext:
        if(FComClose(pTG))
        {
                pTG->FComStatus.fModemInit = FALSE;
                fRet=TRUE;
        }

end:
        PUTEVENT(pTG, wEVFLAGS_DEINIT, EVENT_ID_MODEM_STATE,
                                EVENT_SubID_MODEM_DEINIT_END, fRet, 0, NULL);
#ifdef MON3
        if (pTG->gMonInfo.fInited)
        {
                MonDump(pTG);
                MonDeInit(pTG);
        }
#endif // MON3
        return fRet;
}

















BOOL   iModemHangup(PThrdGlbl pTG)
{
        BOOL fRet=FALSE;

        if(!pTG->FComStatus.fOffHook) return TRUE;

        // Note: iModemHangup is called by NCULink in ddi.c.
        // Rather than do adaptive-answer-specific code in ddi.c as well,
        // we simply ignore the hangup command in the following case...

// RSL  if (pTG->Comm.fEnableHandoff && pTG->Comm.fExternalHandle && pTG->Comm.fDataCall)
        if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall)
        {
                (MyDebugPrint(pTG, LOG_ALL, "<<WARNING>> iModemHangup: IGNORING Hangup of datamodem call\r\n"));
                        return TRUE;
        }

        PUTEVENT(pTG, wEVFLAGS_HANGUP, EVENT_ID_MODEM_STATE,
                        EVENT_SubID_MODEM_HANGUP_START, 0, 0, NULL);
        // ST_MOD(D_FComPrint(pTG->FComStatus.uComPort-1));
        // FComDTR(FALSE);              // Lower DTR to hangup in ModemHangup
                                                // Need to have &D2 in init string for this.

        // Do this twice. There is a bizarre case where you drop DTR,
        // then go into Dialog, flush, send ATH0, then the modem gives
        // you an OK for the DTR, and you take it as one for the ATH0
        // maybe that's ok....if this gets too slow, skip this.
        HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1);

        if(HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
        {
                FComDTR(pTG, FALSE);         // Lower DTR on stubborn hangups in ModemHangup
                TwiddleThumbs1(1000);    // pause 1 second
                FComDTR(pTG, TRUE);          // raise it again. Some modems return to cmd state
                                                        // only when this is raised again

                if(iModemReset(pTG, pTG->FComModem.CurrCmdTab.szReset) < 0)
                        goto error;
                if(HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
                        goto error;
        }
        pTG->FComStatus.fOffHook = FALSE;

        if(!iiModemGoClass(pTG, 0, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
                goto end;
                // Can also ignore this return value. Just for tidier cleanup

        // Avoid! we'll smash our settings
        // iModemReset();
        fRet=TRUE;
        goto end;

error:
        FComDTR(pTG, TRUE);          // raise it again
        BG_CHK(!fRet);
        // fall through...

end:
        PUTEVENT(pTG, wEVFLAGS_HANGUP, EVENT_ID_MODEM_STATE,
                        EVENT_SubID_MODEM_HANGUP_END, fRet, 0, NULL);
        return fRet;
}





















USHORT   iModemDial(PThrdGlbl pTG, LPSTR lpszDial, USHORT uClass)
{
        ULONG   ulTimeout;
        USHORT  uRet, uLen, uDialStringLen;
        BYTE    bBuf[DIALBUFSIZE];
        CBPSTR  cbpstr;
        char    chMod = pTG->NCUParams.chDialModifier;
        DWORD   dw=0;
        char    KeyName[200];
        HKEY    hKey;
        char    BlindDialString[200];
        char    RegBlindDialString[200];
        long    lRet;
        DWORD   dwSize;
        DWORD   dwType;

        BG_CHK(lpszDial);

        (MyDebugPrint(pTG, LOG_ALL, "Entering ModemDial\r\n"));

        pTG->FComStatus.fOffHook = TRUE;     // Has to be here. Can get an error return
                                                                // below even after connecting
                                                                // and we want to hangup after that!!
        BG_CHK(pTG->Comm.fDataCall==FALSE);
        pTG->Comm.fDataCall=FALSE;

        BG_CHK(uClass==FAXCLASS0 || uClass==FAXCLASS1);

        //
        // check "Modems->Properties->Connection->Wait for dial tone" setting before dialing
        // to correctly set ATX to possibly blind dial
        //
        if (pTG->fBlindDial) {
           
           // create default string
           sprintf(BlindDialString, "ATX3\r");
           
           // need to check Unimodem Settings\Blind_On key. 
           sprintf(KeyName, "%s\\Settings", pTG->lpszUnimodemKey);

           lRet = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           KeyName,
                           0,
                           KEY_READ,
                           &hKey);
       
           if (lRet != ERROR_SUCCESS) {
              MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem Settings key %s\n", KeyName);
           }
           else {
              dwSize = sizeof(RegBlindDialString); 


              lRet = RegQueryValueEx(
                         hKey,
                         "Blind_On",
                         0,
                         &dwType,
                         RegBlindDialString,
                         &dwSize);

              RegCloseKey(hKey);

              if (lRet != ERROR_SUCCESS) {
                  MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem key\\Settings\\Blind_On value \n");
              }
              else if (RegBlindDialString) {
                 sprintf(BlindDialString, "AT%s\r", RegBlindDialString);
              }
           }
        }


        // Let's update the modem settings here, if required.
        if (pTG->fNCUParamsChanged)
        {
                if (!iModemSetNCUParams(pTG, pTG->NCUParams.DialPauseTime,
                                                                pTG->NCUParams.SpeakerControl,
                                                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                                                pTG->NCUParams.SpeakerRing))
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> iModemSetNCUParams FAILED\r\n"));
                }
                pTG->fNCUParamsChanged=FALSE;
        }

        if(uClass==FAXCLASS1)
        {
                if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
                {
                        uRet = CONNECT_ERROR;
                        goto error;
                }
        }

        //
        // blind dial set here if requested by user
        //
        if (pTG->fBlindDial && BlindDialString) {
           uLen = (USHORT)strlen(BlindDialString);

           if(OfflineDialog2(pTG, BlindDialString, uLen, cbszOK, cbszERROR) != 1)
           {
                   (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Error in BLIND DIAL string: %s\r\n", BlindDialString));
           }
        }



        if(pTG->FComModem.CurrCmdTab.szPreDial && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreDial)))
        {
                if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial, uLen, cbszOK, cbszERROR) != 1)
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Error in PREDIAL string: %s\r\n", (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial));
                }
        }

        cbpstr = cbszDIAL;

        // If the dial string already has a T or P prefix, we use that
        // instead.
        {
                char c=0;
                while((c=*lpszDial) && c==' ') *lpszDial++;
                if (c=='t'|| c=='T' || c=='p'|| c=='P')
                {
                        chMod = c;
                        lpszDial++;
                        while((c=*lpszDial) && c==' ') *lpszDial++;
                }

        }

        BG_CHK(chMod=='P' || chMod=='T' || chMod=='p' || chMod=='t');

        uLen = (USHORT)wsprintf(bBuf, cbpstr, chMod, (LPSTR)lpszDial);

        // Need to set an approriate timeout here. A minimum of 15secs is too short
        // (experiment calling machines within a PABX), plus one has to give extra
        // time for machines that pick up after 2 or 4 rings and also for long distance
        // calls. I take a minumum of 30secs and add 3secs for each digits over 7
        // (unless it's pulse dial in which case I add 8secs/digit).
        // (I'm assuming that a long-distance call will take a minimum of 8 digits
        // anywhere in ths world!). Fax machines I've tested wait about 30secs
        // independent of everything.

        uDialStringLen = (USHORT)_fstrlen(lpszDial);

#define DIAL_TIMEOUT    60000L

        ulTimeout=0;
        if(uDialStringLen > 7)
                ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000)
                                         * (uDialStringLen - 7);

        if(pTG->NCUParams.AnswerTimeout != -1 &&
                (((ULONG)pTG->NCUParams.AnswerTimeout * 1000L) > ulTimeout))
        {
                        ulTimeout = 1000L * (ULONG)pTG->NCUParams.AnswerTimeout;
                        if (ulTimeout<20000L) ulTimeout=20000L;
        } else
                ulTimeout += DIAL_TIMEOUT;

        if(pTG->fNCUAbort)
        {
                (MyDebugPrint(pTG, LOG_ERR,"NCUDial--aborting\r\n"));
                pTG->fNCUAbort = 0;
                uRet = CONNECT_ERROR;
                goto error;
        }
#ifndef MDDI
        ICommStatus(pTG, T30STATS_DIALING, 0, 0, 0);
#endif //MDDI
        pTG->FComStatus.fInDial = TRUE;
        // look for MultiLine, just in case we get echo or garbage.
        // Nothing lost, since on failure of this we can't do anything

        // uRet = iiModemDialog((LPB)bBuf, uLen, ulTimeout, TRUE, 1, TRUE,
        //                                       cbszCONNECT, cbszBUSY, cbszNOANSWER,
        //                                       cbszNODIALTONE, cbszERROR, (CBPSTR)NULL);
        // Send seperately & use iiModemDialog only for the response

        // all this just to send the ATDT
                FComFlushOutput(pTG);
                TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
                FComFlushInput(pTG);
                FComDirectAsyncWrite(pTG, bBuf, uLen);
        // now try to get a response
        dw = GetTickCount();
        uRet = iiModemDialog(pTG, 0, 0, ulTimeout, TRUE, 1, TRUE,
                                                 cbszCONNECT, cbszBUSY, cbszNOANSWER,
                                                 cbszNODIALTONE, cbszERROR, cbszNOCARRIER, (CBPSTR)NULL);

        pTG->FComStatus.fInDial = FALSE;
        (MyDebugPrint(pTG, LOG_ALL, "ModemDial -- got %d response from Dialog\r\n", uRet));


#if !((CONNECT_TIMEOUT==0) && (CONNECT_OK==1) && (CONNECT_BUSY==2) && (CONNECT_NOANSWER == 3) && (CONNECT_NODIALTONE==4) && (CONNECT_ERROR==5))
#error CONNECT defines not correct ERROR, OK, BUSY, NOANSWER, NODIALTONE == CONNECT_ERROR, CONNECT_OK, CONNECT_BUSY, CONNECT_NOANSWER, CONNECT_NODIALTONE
#else
#pragma message("verified CONNECT defines")
#endif


        switch(uRet)
        {
        case CONNECT_TIMEOUT:
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_NO_ANSWER);

            (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Dial: Got timeout\r\n"));
            break;


        case CONNECT_OK:
            MyDebugPrint(pTG, LOG_ALL, "Dial: Got CONNECT\r\n");
            break;


        case CONNECT_BUSY:
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_BUSY);

            (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Dial: Got BUSY\r\n"));
            break;


        case CONNECT_NOANSWER:
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_NO_ANSWER);

            (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Dial: Got NOANSWER\r\n"));
            break;


        case CONNECT_NODIALTONE:
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_NO_DIAL_TONE);

            (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Dial: Got NODIALTONE\r\n"));
            break;


        case CONNECT_ERROR:
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_NO_ANSWER);

            (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Dial: Got ERROR\r\n"));
            break;


        case 6: {

#define TIME_DELTA(prev, now)\
        (((prev)<=(now)) ?((now)-(prev)) : (now) + (0xffffffffL-(prev)))

                        DWORD dwNow=GetTickCount();
                        DWORD dwDelta = TIME_DELTA(dw, dwNow);
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Dial: Got NO CARRIER after %lums\r\n",
                                        (unsigned long) dwDelta));
                        if (dwDelta < 5000L)
                        {
                                (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Dial: Pretending it's BUSY\r\n"));

                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_BUSY);

                                uRet = CONNECT_BUSY;
                        }
                        else
                        {
                                (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Dial: Pretending it's TIMEOUT\r\n"));

                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);

                                uRet = CONNECT_TIMEOUT;
                        }
                }
                break;

        default:
             BG_CHK(FALSE);

        }

        if(uRet == CONNECT_OK)
        {
                goto done;
        }
        else
        {
                if(uRet == CONNECT_TIMEOUT)     {

                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_NO_ANSWER);

                    uRet = CONNECT_NOANSWER;
                        // call it a no answer
                }

                goto error;
        }

        // no fallthru here
        BG_CHK(FALSE);

error:
        if(!iModemHangup(pTG))
        {
                // BG_CHK(FALSE);
                // at this point in teh production version we
                // need to call some OS reboot function!!
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Can't Hangup after DIALFAIL\r\n"));
                uRet = CONNECT_ERROR;
        }
        // fall through
#ifndef MDDI
        ICommFailureCode(pTG, T30FAILS_NCUDIAL_ERROR + uRet);
#endif //MDDI
done:
        PUTEVENT(pTG, wEVFLAGS_DIAL, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_DIAL_END,
                                uRet, 0, NULL);
        return uRet;
}




// fImmediate==FALSE -- wait for NCUParams.NumRings else answer right away
USHORT   iModemAnswer(PThrdGlbl pTG, BOOL fImmediate, USHORT uClass)
{
        CBPSTR  cbpstr;
        USHORT  uLen, uRet;
        char    Command[400];
        int     i;


        (MyDebugPrint(pTG, LOG_ALL, "Entering ModemAnswer\r\n"));

        pTG->FComStatus.fOffHook=TRUE;       // Has to be here. Can mess up after answering
                                                                // but before CONNECT and we want to hangup
                                                                // after that!!
        BG_CHK(pTG->Comm.fDataCall==FALSE);
        pTG->Comm.fDataCall=FALSE;

/**** Not looking for RING should speed things up *********************
        (MyDebugPrint(pTG, "Looking for RING\r\n"));
        // However with an external modem this can cause problems
        // because we may go into a 14second wait for answer, with phone
        // off hook. Better to read S1 here. If 0 return error. If non-zero
        // loop until reaches X or timeout (in case other guy hangs up before
        // X rings).

        // Don't resync here. We'll flush the RING from the buffer!!
        // if EfaxCheckForRing() fails, the callers will resync
        // through FaxSync()

#define RING_TIMEOUT 15000                              // Random Timeout
// Need to wait reasonably long, so that we don't give up too easily

        if(!iModemResp1(RING_TIMEOUT, cbszRING))
                {uRet=CONNECT_NORING_ERROR; goto done;}

**********************************************************************/



        BG_CHK(uClass==FAXCLASS0 || uClass==FAXCLASS1);

        if (pTG->fNCUParamsChanged)
        {
                if (!iModemSetNCUParams(pTG,  pTG->NCUParams.DialPauseTime,
                                                                pTG->NCUParams.SpeakerControl,
                                                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                                                pTG->NCUParams.SpeakerRing))
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> iModemSetNCUParams FAILED\r\n"));
                }
                pTG->fNCUParamsChanged=FALSE;
        }


        //
        // below is Adaptive Answer handling. 
        // It is separate because all the commands are defined via INF
        //

        if (pTG->AdaptiveAnswerEnable) {

           for (i=0; i< (int) pTG->AnswerCommandNum; i++) {
              sprintf (Command, "%s",  pTG->AnswerCommand[i] );

              if (i == (int) pTG->AnswerCommandNum - 1) {
                 // last command-answer
                 FComFlushOutput(pTG);
                 TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
                 FComFlushInput(pTG);
                 FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );

                 pTG->FComStatus.fInAnswer = TRUE;
                 
                 break;

              }


              if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    {
                  MyDebugPrint(pTG, LOG_ERR, "Answer %d=%s FAILED\n", i, Command);
              }
              else {
                  MyDebugPrint(pTG, LOG_ALL, "Answer %d=%s rets OK\n", i, Command);
              }
           }

           uRet=iModemGetAdaptiveResp(pTG);
           pTG->FComStatus.fInAnswer=FALSE;
           if (uRet==CONNECT_OK) 
               goto done;
           else          
               goto error;
        }

        //
        // assuming FAX call since can't determine that anyway...
        //
        else if(uClass==FAXCLASS1)
        {
                // 5/95 JosephJ:Elliot Bug#3421 -- we issue the AT+FCLASS=1 command
                //      twice so that if one gets zapped by a RING the other will
                //          be OK.
                if (pTG->FComModem.CurrCmdTab.dwFlags&fMDMSP_ANS_GOCLASS_TWICE)
                        iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
                if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
                {
                        uRet = CONNECT_ERROR;
                        goto error;
                }
        }

        if(pTG->FComModem.CurrCmdTab.szPreAnswer && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreAnswer)))
        {
                if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer, uLen, cbszOK, cbszERROR) != 1)
                {
                        (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Error on PREANSWER string: %s\r\n", (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer));
                }
        }



#define ANSWER_TIMEOUT 40000                            // Random Timeout
// Need to wait reasonably long, so that we don't give up too easily

        cbpstr = cbszANSWER;
        uLen = sizeof(cbszANSWER)-1;

        if(pTG->fNCUAbort)
        {
                (MyDebugPrint(pTG, LOG_ERR,"NCUAnswer--aborting\r\n"));
                pTG->fNCUAbort = 0;
                uRet = CONNECT_ERROR;
                goto error;
        }

#ifndef MDDI
        ICommStatus(pTG, T30STATR_ANSWERING, 0, 0, 0);
#endif //MDDI
        pTG->FComStatus.fInAnswer = TRUE;

        // if(!iModemDialog((LPSTR)cbpstr, uLen, ANSWER_TIMEOUT, cbszCONNECT))
        // look for MultiLine, just in case we get echo or garbage.
        // Nothing lost, since on failure of this we can't do anything

        // if(!iiModemDialog((LPB)cbpstr, uLen, ANSWER_TIMEOUT, TRUE, 1, TRUE,
        //                                       cbszCONNECT, (CBPSTR)NULL))
        // Send seperately & use iiModemDialog only for the response

        // all this just to send the ATA


                FComFlushOutput(pTG);
                TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
                FComFlushInput(pTG);
                FComDirectAsyncWrite(pTG, cbpstr, uLen);


        // now try to get a response
        
        if(!iiModemDialog(pTG, 0, 0, ANSWER_TIMEOUT, TRUE, 1, TRUE, cbszCONNECT, (CBPSTR)NULL))
        {
                pTG->FComStatus.fInAnswer = FALSE;
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get CONNECT after RING\r\n"));

                // try to hangup and sync with modem. This should work
                // even if phone is not really off hook
                uRet = CONNECT_ERROR;
                goto error;
        }
        else
        {
                pTG->FComStatus.fInAnswer = FALSE;
                uRet = CONNECT_OK;
                goto done;
        }

        // no fallthru here
        BG_CHK(FALSE);

error:

        if (pTG->Comm.fEnableHandoff && uRet==CONNECT_WRONGMODE_DATAMODEM)
        {
                // We won't hangup.
                ICommFailureCode(pTG, T30FAILR_NCUANSWER_ERROR); // ++ Change
                // We deliberately leave pTG->FComStatus.fOffHook to TRUE, because
                // it is off hook.
                goto done;


        }

        if(!iModemHangup(pTG))
        {
                // BG_CHK(FALSE);
                // at this point in teh production version we need to
                // call some OS reboot function!!
                // In WFW this can occur if an external modem has been
                // powered down. so just drop thru & return ERROR
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Can't Hangup after ANSWERFAIL\r\n"));
                uRet = CONNECT_ERROR;
        }
#ifndef MDDI
        ICommFailureCode(pTG, T30FAILR_NCUANSWER_ERROR);
#endif //MDDI
        // fall through

done:
        PUTEVENT(pTG, wEVFLAGS_DIAL, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_ANSWER_END,
                                uRet, 0, NULL);
        return uRet;

}












LPSTR my_fstrstr( LPSTR sz1, LPSTR sz2)
{
        int i, len1, len2;

        if ( (sz1 == NULL) || (sz2 == NULL) ) {
            return NULL;
        }

        len1 = _fstrlen(sz1);
        len2 = _fstrlen(sz2);

        for(i=0; i<=(len1-len2); i++)
        {
                if(_fmemcmp(sz1+i, sz2, len2) == 0)
                        return sz1+i;
        }
        return NULL;
}






int my_strcmp(LPSTR sz1, LPSTR sz2)
{

   if ( (sz1 == NULL) || (sz2 == NULL) ) {
       return FALSE;
   }

   if ( strcmp(sz1, sz2) == 0 ) {
      return TRUE;
   }

   return FALSE;

}









BOOL fHasNumerals(PThrdGlbl pTG, LPSTR sz)
{
        int i;

        if (sz == NULL) {
            return FALSE;
        }

        for(i=0; sz[i]; i++)
        {
                if(sz[i] >= '0' && sz[i] <= '9')
                        return TRUE;
        }
        return FALSE;
}
















UWORD    far iiModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                                          BOOL fMultiLine, UWORD uwRepeatCount, BOOL fPause,
                                          CBPSTR cbpstrWant1, CBPSTR cbpstrWant2, ...)
{
        /** Takes a command string, and it's lengt writes it out to the modem
            and tries to get one of the allowed responses. It writes the command
                out, waits ulTimeOut millisecs for a response. If it gets one of the
                expected responses it returns immediately.

                If it gets an unexpected/illegal response it tries (without any
                waiting) for subsequent lines to the same response.     When all the
                lines (if > 1) of the response lines are exhausted, if none is among the
                expected responses, it writes the command again and tries again,
                until ulTimeout has expired. Note that if no response is received,
                the command will be written just once.

                The whole above thing will be repeated upto uwRepeatCount times
                if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

                It returns when (a) one of the specified responses is received or
                (b) uwRepeatCount tries have failed (each having returned an
                illegal response or having returned no response in ulTimeout
                millsecs) or (c) the command write failed, in which
                case it returns immediately.

                It flushes the modem inque before each Command Write.

                Returns 0 on failure and the 1 based index of the successful
                response on     success.

                This can be used in the following way:-

                for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
                value, of the order of the transmission time of the longest
                possible (erroneous or correct) line of response plus the size
                of the command. eg. at 1200baud we have about 120cps = about
                10ms/char. Therefore a timeout of about 500ms is more than
                adequate, except for really long command lines.

                for Local Sync dialogs, used to sync up with the modem which may
                be in an unsure state, use the same timeout, but also a repeat
                count of 2 or 3.

                for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
                after the flags have been received, and which may incur a delay
                before a response (ATDT is teh same. CONNECT is issued after a
                long delay & anything the DTE sends will abort the process).
                For these cases the caller should supply a long timeout and
                probably a repeatcount of 1, so that the
                routine will timeout after one try but go on issuing teh command
                as long as an error repsonse is received.

                For +FRH etc, the long timeout should be T1 or T2 in teh case of
                CommandRecv and ResponseRecv respectively.

        **/


        BYTE bReply[REPLYBUFSIZE];
        UWORD   i, j, uwRet, uwWantCount;
        SWORD   swNumRead;
        CBPSTR  rgcbszWant[10];
        va_list ap;
        LPTO    lpto, lptoRead, lpto0;
        BOOL    fGotFirstLine, fFirstSend;
        ULONG   ulLeft;
        UINT    uPos=0;

        pTG->FComModem.bEntireReply[0]=0;

        // ensure that we'll abort in FComm only on fresh calls to NCUAbort
        // protecting ourselves against this var being randomly left set.
        // Note we check this variable _just_ before calling ModemDialog
        // in NCUDial and NCUAnswer & assuming atomicity between then and here
        // we'll never miss an abort in a Dial/Answer

        BG_CHK(uwRepeatCount>0);
        // extract the (variable length) list of acceptable responses.
        // each is a CBSZ, code based 2 byte ptr

        // first response always present
        rgcbszWant[1] = cbpstrWant1;

        if((rgcbszWant[2] = cbpstrWant2) != NULL)
        {
                // if more than one response
                va_start(ap, cbpstrWant2);
                for(j=3; j<10; j++)
                {
                        if((rgcbszWant[j] = va_arg(ap, CBPSTR)) == NULL)
                                break;
                }
                uwWantCount = j-1;
                va_end(ap);
        }
        else
                uwWantCount = 1;

        BG_CHK(uwWantCount>0);


        if(szSend)
        {
                (MyDebugPrint(pTG, LOG_ALL, "Dialog: Send (%s\r\n) len=%d WantCount=%d time=%ld rep=%d\r\n", (LPSTR)szSend,
                        uwLen, uwWantCount, ulTimeout, uwRepeatCount));
        }
        else
        {
                (MyDebugPrint(pTG, LOG_ALL, "Response: WantCount=%d time=%ld rep=%d\r\n",
                        uwWantCount, ulTimeout, uwRepeatCount));
        }
        for(j=1; j<=uwWantCount; j++)
                (MyDebugPrint(pTG, LOG_ALL, "Want %s\r\n", (LPSTR)(rgcbszWant[j])));


        lpto = &(pTG->FComModem.toDialog);
        lpto0 = &(pTG->FComModem.toZero);
        pTG->FComStatus.fInDialog = TRUE;

        // Try the dialog upto uwRepeatCount times
        for(uwRet=0, i=0; i<uwRepeatCount; i++)
        {
#define DIALOGRETRYMIN  600

                startTimeOut(pTG, lpto, ulTimeout);
                fFirstSend = TRUE;
                do
                {
                        if(szSend)
                        {
                                if(!fFirstSend)
                                {
                                        ulLeft = leftTimeOut(pTG, lpto);
                                        if(ulLeft <= DIALOGRETRYMIN)
                                        {
                                                (MyDebugPrint(pTG, LOG_ALL, "ulLeft=%ul too low\r\n", ulLeft));
                                                break;
                                        }
                                        else
                                        {
                                                (MyDebugPrint(pTG, LOG_ALL, "ulLeft=%ul OK\r\n", ulLeft));
                                        }
                                }
                                fFirstSend = 0;

                                // If a command is supplied, write it out, flushing input
                                // first to get rid of spurious input.

                        /*** SyncWrite calls Drain here which we should not need **
                         *** as we are immediately waiting for a response *********
                         **********************************************************
                                if(!FComDirectSyncWrite(szSend, uwLen))
                         **********************************************************/

                                if(fPause)
                                        TwiddleThumbs1(40);      // 100 is too long

                                // FComFlushInput();
                                FComFlush(pTG);            // Need to flush output too? Maybe...
                                // there's nowhere else to flush/loosen up teh output

                                // The flush has to be as late in the game as possible,
                                // because if teh previous command got confused & accepted
                                // a response to an earlier command or something, then
                                // it's response may still be in transit (this happened
                                // on Sharad's PP9600FXMT), so the later we do this the
                                // better. So we send the entire command w/o teh \r,
                                // wait for it to drain, then Flush again (input only
                                // this time) then send the CR

        ///////// Potential Major source of failures ////////
        // DirectSyncWrite calls Drain which calls DllSleep if everything
        // is not drained, so we could end up waiting for 1 time slice
        // which is at least 50ms and looks like it can be much higher on
        // some machines. This was screwing up our AT+FTM=96 is some cases
        // FIX: Enter Crit section here exit after this is done
        //////////////////////////////////////////////////////

                        FComCritical(pTG, TRUE);     // make sure to exit on all paths out of here

                                BG_CHK(szSend[uwLen-1] == '\r');
                                if(!FComDirectSyncWriteFast(pTG, szSend, (UWORD)(uwLen-1)))
                                {

                                FComCritical(pTG, FALSE);

                                        // Need to check that we are sending only ASCII or pre-stuffed data here
                                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Modem Dialog Sync Write timed Out\r\n"));
                                        uwRet = 0;
                                        goto error;
                                        // If Write fails, fail & return immediately.
                                        // SetMyError() will already have been called.
                                }
                                // output has drained. Now flush input
                                FComFlushInput(pTG);
                                // and then send the CR
                                if(!FComDirectAsyncWrite(pTG, "\r", 1))
                                {

                                FComCritical(pTG, FALSE);

                                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Modem Dialog Write timed Out on CR\r\n"));
                                        uwRet = 0;
                                        goto error;
                                }

                        FComCritical(pTG, FALSE);

                        }

                        // Try to get a response until timeout or bogus response
                        pTG->FComModem.bLastReply[0] = 0;
                        fGotFirstLine=FALSE;

#define SECONDLINE_TIMEOUT      500

                        for(lptoRead=lpto;;startTimeOut(pTG, lpto0, SECONDLINE_TIMEOUT), lptoRead=lpto0)
                        {
                                // get a CR-LF terminated line
                                // for the first line use macro timeout, for multi-line
                                // responses use 0 timeout.
                        retry:
                                bReply[0] = 0;
                                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);

                                if(swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                                        goto retry;             // blank line -- throw away & get another

                                // Fix Bug#1226. Elsa Microlink returns this garbage line in
                                // response to AT+FCLASS=?, followed by the real reply. Since
                                // we only look at the first line, we see only this garbage line
                                // and we never see the real reply (0, 1, 2, 2.0)
                                if(swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                                        goto retry;

                                // Fix Elliot bug#3619 -- German modem TE3801 sends us
                                // \r\r\nOK\r\n -- so we treat \r\r\n as blank line.
                                if(swNumRead==3 && bReply[0]=='\r' && bReply[1]=='\r' && bReply[2]=='\n')
                                        goto retry;


                                if(swNumRead == 0)      // timeout
                                {
                                        if(fGotFirstLine)
                                        {
                                                // for MegaHertz, which returns no OK after
                                                // capabilities queries
                                                if(pTG->fMegaHertzHack)
                                                {
                                                        if(fHasNumerals(pTG, pTG->FComModem.bLastReply))
                                                        {
                                                                uwRet = 1;
                                                                goto end;
                                                        }
                                                }
                                                break;
                                        }
                                        else
                                                goto timeout;
                                }
                                if(swNumRead < 0)       // error-but lets see what we got anyway
                                        swNumRead = (-swNumRead);

                                fGotFirstLine=TRUE;

                                //
                                // +++ HACK:
                                // We add everything upto the first NULL of each
                                // line of reply to bEntireReply, for the specific
                                // case of fMultiLine==uMULTILINE_SAVEENTIRE
                                // This is so we save things like:
                                // \r\nDATA\r\n\r\nCONNECT 12000\r\n
                                //
                                if(pTG->Comm.fEnableHandoff && fMultiLine==uMULTILINE_SAVEENTIRE
                                        && uPos<sizeof(pTG->FComModem.bEntireReply))
                                {
                                        UINT cb;
                                        bReply[REPLYBUFSIZE-1]=0;
                                        cb = _fstrlen(bReply);
                                        if ((cb+1)> (sizeof(pTG->FComModem.bEntireReply)-uPos))
                                        {
                                                (MyDebugPrint(pTG, LOG_ALL, "<<WARNING>> bEntireReply: out of space\r\n"));
                                                BG_CHK(FALSE);
                                                cb=sizeof(pTG->FComModem.bEntireReply)-uPos;
                                                if (cb) cb--;
                                        }
                                        _fmemcpy((LPB)pTG->FComModem.bEntireReply+uPos, (LPB)bReply, cb);
                                        uPos+=cb;
                                        pTG->FComModem.bEntireReply[uPos]=0;
                                }

                                for(bReply[REPLYBUFSIZE-1]=0, j=1; j<=uwWantCount; j++)
                                {
                                        if(my_fstrstr(bReply, rgcbszWant[j]) != NULL)
                                        {
                                                uwRet = j;
                                                goto end;
                                        }
                                }
                                if(!fMultiLine)
                                        break;
                                // Got something unknown
                                // Retry command and response until timeout

                                // We reach here it IFF we got a non blank reply, but it wasn't what
                                // we wanted. Squirrel teh first line away somewhere so that we can
                                // retrieve is later. We use this hack to get multi-line informational
                                // responses to things like +FTH=? Very important to ensure that
                                // blank-line replies don't get recorded here. (They may override
                                // the preceding line that we need!).

                                if( (pTG->FComModem.bLastReply[0] == 0) ||
                                    ( ! _fstrcmp(pTG->FComModem.bLastReply, cbszRING) ) ) {
                                            // copy only if _first_ response line
                                        _fmemcpy((LPB)pTG->FComModem.bLastReply, (LPB)bReply, REPLYBUFSIZE);
                                }
                                // copies whole of bReply which includes zero-termination put
                                // there by FComFilterReadLine
                                (MyDebugPrint(pTG, LOG_ALL, "ModemDialog: Saved line (%s)\r\n", (LPSTR)(&(pTG->FComModem.bLastReply))));
                        }
                        // we come here only on unknown reply.
                        BG_CHK(swNumRead > 0 || fGotFirstLine);
                }
                while(checkTimeOut(pTG, lpto));

                if(fGotFirstLine)
                        continue;

                (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Weird!! got timeout in iiModemDialog loop\r\n"));
        timeout:
                // Need to send anychar to abort the previous command.
                // use random 120ms timeout -- too short. upped to 250
#       define ABORT_TIMEOUT    250
                BG_CHK(swNumRead == 0);
                // send \rAT\r
                // no need for pause--we just timed out!!
                // TwiddleThumbs1(40);

                FComFlush(pTG); // flush first--don't wnat some old garbage result
                FComDirectSyncWriteFast(pTG, "\rAT", 3);
                FComFlushInput(pTG); // flush input again
                FComDirectAsyncWrite(pTG, "\r", 1);
                startTimeOut(pTG, lpto0, ABORT_TIMEOUT);
                do
                {
                        // don't abort inside ReadLine for this (abort dialog)
                        if(pTG->fNCUAbort >= 2) pTG->fNCUAbort = 1;
                        swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
                }
                while(swNumRead==2 && bReply[0]=='\r'&& bReply[1]=='\n');
                // While we get a blank line. Get another.

                //
                // BugBug (andrewr): if FComFilterReadLine fails, then bReply 
                // is not initialed and we can have bogus data in our debug 
                // statement below.  Safest way to initialize this is to 
                // initialize the data if this call fails since we don't
                // necessarily know all the side effects of changing this in 
                // the calling function or calling it above.
                //
                if (swNumRead == 0) {
                    bReply[0] = 0;
                }

                if(bReply[0] && my_fstrstr(bReply, cbszOK)==NULL)
                        (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> Anykey abort reply not OK. Got <<%s>>\r\n", (LPSTR)bReply));


                // Need Flush here, because \rAT\r will often get us
                // a cr-lf-OK-cr-lf-cr-lfOK-cr-lf response. If we send
                // just a \r, sometimes we may get nothing

                // FComFlushInput();
                FComFlush(pTG);

                if(pTG->fNCUAbort)
                {
                        (MyDebugPrint(pTG, LOG_ERR,"ModemDialog--aborting\r\n"));
                        pTG->fNCUAbort = 0;
                        break;  // drop out of loop to error
                }
        }

error:
        BG_CHK(uwRet == 0);
        (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> ModemDialog: (%s\r\n) --> (%d)(%s, etc) Failed\r\n", (LPSTR)(szSend?szSend:"null"), uwWantCount, (LPSTR)rgcbszWant[1]));
        iModemSetError(pTG, MODEMERR_HARDWARE, ERR_COMMAND_FAILED, MODEMERRFLAGS_TRANSIENT);
        pTG->FComStatus.fInDialog = 0;
        return 0;

end:
        BG_CHK(uwRet != 0);
        (MyDebugPrint(pTG, LOG_ALL, "ModemDialog: GOT IT %d (%s)\r\n", uwRet, (LPSTR)(rgcbszWant[uwRet])));
        pTG->FComStatus.fInDialog = 0;
        return uwRet;
}


#ifdef MON3
void    InitMonitorLogging(PThrdGlbl pTG)
{
        DWORD_PTR dwKey;

        pTG->Comm.fEnableHandoff=1;
        if (pTG->Comm.fEnableHandoff)
        {
                (MyDebugPrint(pTG, LOG_ALL, "<<WARNING>> ADAPTIVE ANSWER ENABLED\r\n"));
        }

        if ( 0 )  // RSL !fBeenHere
        {
                dwKey = ProfileOpen(DEF_BASEKEY, szGENERAL, fREG_READ);
                if (dwKey)
                {
                        MONOPTIONS mo;
#ifdef DEBUG
#       define DEFMONVAL 1
#else   //!DEBUG
#       define DEFMONVAL 0
#endif  //!DEBUG

                        BOOL fDoMonitor =(BOOL)(ProfileGetInt(dwKey, szMONITORCOMM, DEFMONVAL, NULL));



                        _fmemset(&mo, 0, sizeof(mo));
                        if (fDoMonitor)
                        {
                                UINT uPrefDataBufSizeKB=0;
                                UINT uMaxExistingSizeKB=0;
                                uPrefDataBufSizeKB=ProfileGetInt(dwKey, szMONITORBUFSIZEKB, (0x1<<6), NULL);
#define szMONITOREXISTINGFILESIZE "MonitorMaxOldSizeKB"
#define szMONITORDIR                      "MonitorDir"
                                uMaxExistingSizeKB=
                                                        ProfileGetInt(dwKey, szMONITOREXISTINGFILESIZE, 64, NULL);
                                mo.dwMRBufSize = ((DWORD)uPrefDataBufSizeKB)<<(10-2);
                                mo.dwDataBufSize = ((DWORD)uPrefDataBufSizeKB)<<10;
                                mo.dwMaxExistingSize = ((DWORD)uMaxExistingSizeKB)<<10;
                                ProfileGetString(dwKey, szMONITORDIR, "c:\\",
                                                                        mo.rgchDir, sizeof(mo.rgchDir)-1);
                        }
                        ProfileClose(dwKey); dwKey=0;

                        if (fDoMonitor)
                        {
                                INT i = _fstrlen(mo.rgchDir);
                                BG_CHK((i+1)<sizeof(mo.rgchDir));
                                if (i && mo.rgchDir[i-1]!='\\')
                                        {mo.rgchDir[i]='\\';mo.rgchDir[i+1]=0;}
                                MonInit(pTG, &mo);
                                (MyDebugPrint(pTG, LOG_ALL, "MONITOR OPTIONS: dwMR=%lu; dwDB=%lu; dwMES=%lu; szDir=\"%s\":%s\r\n",
                                                        (unsigned long) mo.dwMRBufSize,
                                                        (unsigned long) mo.dwDataBufSize,
                                                        (unsigned long) mo.dwMaxExistingSize,
                                                        (LPSTR) mo.rgchDir,
                                                        (LPSTR) ((pTG->gMonInfo.fInited)? "ON" : "OFF")));
                        }
                }
        }
}
#endif // MON3
















USHORT iModemGetAdaptiveResp(PThrdGlbl pTG)
{
        USHORT                uRet=CONNECT_ERROR;
        BOOL                  fGotOK=FALSE;
        BOOL                  fGotData=FALSE;
        BOOL                  fGotFax=FALSE;
        LONG                  lRet;
        char                  Command[400];


        pTG->Comm.fDataCall = FALSE;



// RSL was 60 000
#define AA_ANSWER_TIMEOUT       40000

        //
        // handle Adaptive Answer
        // should get FAX/DATA response
        //
        switch( iiModemDialog( pTG, 0, 0, AA_ANSWER_TIMEOUT, uMULTILINE_SAVEENTIRE,1, TRUE,
                               pTG->ModemResponseFaxDetect,
                               pTG->ModemResponseDataDetect,
                               cbszCONNECT,
                               cbszOK,
                               (CBPSTR)NULL)) {

             case 1:
                  fGotFax = 1;
                  (MyDebugPrint(pTG, LOG_ALL,"AdaptiveAnswer: got FAX response\n"));
                  break;

             case 2:
                 fGotData = 1;
                 (MyDebugPrint(pTG, LOG_ALL,"AdaptiveAnswer: got DATA response\n"));
                 break;

             case 3:
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get CONNECT before FAX/DATA\r\n"));
                 pTG->Comm.fDataCall = FALSE;
                 uRet = CONNECT_ERROR;
                 goto end;

             case 4:
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get OK before FAX/DATA\r\n"));
                 pTG->Comm.fDataCall = FALSE;
                 uRet = CONNECT_ERROR;
                 goto end;

             default:
             case 0:   
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get default before FAX/DATA\r\n"));
                pTG->Comm.fDataCall = FALSE;
                uRet = CONNECT_ERROR;
                goto end;
        }

        // here we may have to change the serial speed and send some cmds (such as ATO-go online)

        if (fGotFax) {
           if (pTG->SerialSpeedFaxDetect) {
              FComSetBaudRate(pTG, pTG->SerialSpeedFaxDetect);
           }

           if (pTG->HostCommandFaxDetect)  {
              sprintf (Command, "%s",  pTG->HostCommandFaxDetect );
   
              FComFlushOutput(pTG);
              FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
           }

        }
        else if (fGotData) {
           if (pTG->SerialSpeedDataDetect) {
              FComSetBaudRate(pTG, pTG->SerialSpeedDataDetect);
           }

           if (pTG->HostCommandDataDetect)    {
              sprintf (Command, "%s",  pTG->HostCommandDataDetect );
   
              FComFlushOutput(pTG);
              FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
           }
        }
        else {
           (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: LOGICAL PGM ERROR\r\n"));
           pTG->Comm.fDataCall = FALSE;
           uRet = CONNECT_ERROR;
           goto end;
        }


        // wait for connect now.

        switch( iiModemDialog( pTG, 0, 0, AA_ANSWER_TIMEOUT, uMULTILINE_SAVEENTIRE,1, TRUE,
                               (fGotFax) ? pTG->ModemResponseFaxConnect : pTG->ModemResponseDataConnect,
                               cbszCONNECT,
                               cbszOK,
                               (CBPSTR)NULL)) {

             case 1:
                  if (fGotFax) {
                     uRet=CONNECT_OK;
                     goto end;
                  }
                  else {
                     goto lDetectDataCall;
                  }

             case 2:
                if (fGotFax) {
                   uRet=CONNECT_OK;
                   goto end;
                }
                else {
                   goto lDetectDataCall;
                }

             case 3:
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get OK after FAX/DATA\r\n"));
                 pTG->Comm.fDataCall = FALSE;
                 uRet = CONNECT_ERROR;
                 goto end;

             default:
             case 0:
                (MyDebugPrint(pTG, LOG_ERR,"<<ERROR>> AnswerPhone: Can't get default after FAX/DATA\r\n"));
                pTG->Comm.fDataCall = FALSE;
                uRet = CONNECT_ERROR;
                goto end;
        }



lDetectDataCall:
        // Now we've got to fake out modem and fcom into thinking that
        // the phone is off hook when in fact it isn't.
        pTG->Comm.fDataCall = TRUE;
        uRet = CONNECT_WRONGMODE_DATAMODEM;


        //
        // New TAPI: Have to switch out of passtrough before handing off the call
        //


        MyDebugPrint(pTG, LOG_ALL, "AdaptiveAnswer: lineSetCallParams called at %ld \n", GetTickCount() );

        if (!itapi_async_setup(pTG)) {
            MyDebugPrint(pTG, LOG_ERR,  "ERROR: AdaptiveAnswer: itapi_async_setup failed \n");


            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
        }

        lRet = lineSetCallParams(pTG->CallHandle,
                                 LINEBEARERMODE_VOICE,
                                 0,
                                 0xffffffff,
                                 NULL);

        if (lRet < 0) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: AdaptiveAnswer: lineSetCallParams failed \n");

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);

            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
        }
        else {
             MyDebugPrint(pTG, LOG_ALL, "AdaptiveAnswer: lineSetCallParams returns ID %ld\n", (long) lRet);
        }


        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: AdaptiveAnswer: itapi_async_wait failed \n");
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);

            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
        }



        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NOT_FAX_CALL);



end:
        return uRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\timeouts.c ===
/***************************************************************************
        Name      :     TIMEOUTS.C
        Comment   :     Various support functions

        Revision Log

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        001 12/18/91    arulm   Commenting it for the first time. This is the
                                                        "stable" DOS version from which the Windows code
                                                        will be derived. This file should not change
                                                        for Windows
***************************************************************************/

#include "prep.h"

#include "fcomint.h"
#include "fdebug.h"

///RSL
#include "glbproto.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_TO, m)
#define         faxT2log(m)             DEBUGMSG(ZONE_TIMEOUT, m)
#define         FILEID                  FILEID_TIMEOUTS

/***************************************************************************
        Name      :     Timers Class
        Purpose   :     Provide for Timeouts
                                        TO                 -- Timeout struct
                                        startTimeout -- creates a new timeout
***************************************************************************/








void   startTimeOut(PThrdGlbl pTG, LPTO lpto, ULONG ulTimeout)
{

        /////////////  ulTimeout <<= 1;         // give us a little more time during debugging

        BG_CHK(lpto);

        lpto->ulStart = GetTickCount();
        lpto->ulTimeout = ulTimeout;
        lpto->ulEnd = lpto->ulStart + ulTimeout;        // will wrap around as system
                                                                                                // time nears 4Gig ms

        (MyDebugPrint(pTG, LOG_ALL, "StartTO: 0x%08lx --> to=0x%08lx start=0x%08lx end=0x%08lx\r\n",
                        lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd));

        return;
}






BOOL   checkTimeOut(PThrdGlbl pTG, LPTO lpto)
{
        // if it returns FALSE, caller must return FALSE immediately
        // (after cleaning up, as appropriate).

        // SWORD swRet;
        ULONG ulTime;

        BG_CHK(lpto);

        ulTime = GetTickCount();

        //// if(fVerbose3)
        ////    (MyDebugPrint(pTG, "CheckTO: 0x%08lx --> to=0x%08lx start=0x%08lx  end=0x%08lx CURR=0x%08lx\r\n",
        ////            lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));

        if(lpto->ulTimeout == 0)
        {
                goto out;
        }
        else if(lpto->ulEnd >= lpto->ulStart)
        {
                if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
                        return TRUE;
                else
                        goto out;
        }
        else    // ulEnd wrapped around!!
        {
                ERRMSG(("<<ERROR>> CheckTO WRAPPED!!: 0x%04x --> to=0x%08lx start=0x%08lx  end=0x%08lx time=0x%08lx\r\n",
                        lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));

                if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
                        return TRUE;
                else
                        goto out;
        }

out:
        faxT2log(("CheckTO--TIMEOUT!: 0x%04x --> to=0x%08lx start=0x%08lx  end=0x%08lx CURR=0x%08lx\r\n",
                        lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));
        return FALSE;
}










// this will return garbage values if
ULONG   leftTimeOut(PThrdGlbl pTG, LPTO lpto)
{
        ULONG ulTime;

        BG_CHK(lpto);
        ulTime = GetTickCount();

        if(lpto->ulTimeout == 0)
                return 0;
        else if(lpto->ulEnd >= lpto->ulStart)
        {
                if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
                        return (lpto->ulEnd - ulTime);
                else
                        return 0;
        }
        else
        {
                if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
                        return (lpto->ulEnd - ulTime);  // in unsigned arithmetic this
                                                                                        // works correctly even if End<Time
                else
                        return 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\ncuparms.c ===
/***************************************************************************
 Name     :     NCUPARMS.C
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#include "prep.h"

#include "modemint.h"
#include "fcomint.h"
#include "fdebug.h"


///RSL
#include "glbproto.h"


#define faxTlog(m)                      DEBUGMSG(ZONE_MD, m)
#define FILEID                          FILEID_NCUPARMS



void iNCUParamsReset(PThrdGlbl pTG)
{
        _fmemset(&(pTG->NCUParams), 0, sizeof(NCUPARAMS));

        pTG->NCUParams.uSize = sizeof(pTG->NCUParams);

        // These are used to set S regs etc.
        // -1 means leave modem at default
        pTG->NCUParams.DialtoneTimeout = -1;
        pTG->NCUParams.DialPauseTime   = pTG->NCUParams.FlashTime         = -1;
        pTG->NCUParams.DialBlind     = -1;
        pTG->NCUParams.SpeakerVolume   = pTG->NCUParams.SpeakerControl= -1;
        pTG->NCUParams.SpeakerRing     = -1;

        // should be used in answer
        pTG->NCUParams.RingsBeforeAnswer = 0;
        // should be used in Dial
        pTG->NCUParams.AnswerTimeout = 60;
        // used in Dial
        pTG->NCUParams.chDialModifier  = 'T';
        pTG->fNCUParamsChanged =FALSE; // to indicate the we need to reset params
}





void FComInitGlobals(PThrdGlbl pTG)
{
        _fmemset(&pTG->FComStatus, 0, sizeof(FCOM_STATUS));
        _fmemset(&pTG->FComModem, 0, sizeof(FCOM_MODEM));
        pTG->fNCUAbort = 0;
        _fmemset(&pTG->Comm, 0, sizeof(pTG->Comm));
        // +++ fComInit = 0;
}












BOOL   NCUSetParams(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams)
{
        BG_CHK(lpNCUParams);
        // BG_CHK(DDI.fLineInUse == 1);
        // (MyDebugPrint(pTG, "In NCUSetParams fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        // BG_CHK(FComStatus.fModemInit);

        // Copy params into our local NCUparams struct
        pTG->NCUParams = *lpNCUParams;

/*** all will be set on next ReInit. Since all have to *****************
         do with dial that's soon enough ***********************************
        return
        iModemSetNCUParams( pTG->NCUParams.DialPauseTime, pTG->NCUParams.SpeakerControl,
                                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                                pTG->NCUParams.SpeakerRing);
************************************************************************/

        // ignoring DialtoneTimeout and AnswerTimeout because we have
        //              problems with S7 and answering correctly (no answer vs voice etc)
        // also Pulse/Tone I think is being used correctly in Dial (C2 & C1)

        pTG->fNCUParamsChanged =TRUE; // to indicate the we need to reset params
                                                         // next time we call/answer...
// To-do
        // Use RingsBeforeAnswer in Class2Answer and Modem answer
        // and we have to set RingAloud--how?

        return TRUE;
}













BOOL   ModemGetCaps(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpMdmCaps)
{
        BG_CHK(lpMdmCaps);
        // BG_CHK(DDI.fModemOpen == 1);
        // (MyDebugPrint(pTG, "In ModemGetCaps fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        BG_CHK(pTG->FComStatus.fModemInit);

        *lpMdmCaps = pTG->FComModem.CurrMdmCaps;
        return TRUE;
}













void   NCUAbort(PThrdGlbl pTG, USHORT uLine, BOOL fEnable)
{
        // BG_CHK(DDI.fLineInUse == 1);
        // (MyDebugPrint(pTG, "In NCUAbort fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        BG_CHK(pTG->FComStatus.fModemInit || !fEnable);

        if(!fEnable)
                pTG->fNCUAbort = 0;
        else if(pTG->FComStatus.fInAnswer || pTG->FComStatus.fInDial)
                pTG->fNCUAbort = 2;
        else
                pTG->fNCUAbort = 1;
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\aw16bit.h ===
/* 
 * Scraps taken directly from the msvc.200 include files to
 * define types that are needed in our source that are not
 * defined by the 16bit compiler
 */


#ifndef _16BIT_TYPES_
#define _16BIT_TYPES_
#ifndef WIN32

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#define STATIC  static
#define CONST   const
#define CHAR    char
#define UCHAR   BYTE
#define INT     int
#define HKEY    HANDLE
#define HFILE   int

typedef short    SHORT;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef CHAR    *PCHAR;
typedef VOID    *PVOID;

typedef unsigned int _far * LPUINT;
typedef UCHAR *PUCHAR;
typedef LPSTR LPTSTR;
typedef const LPTSTR LPCTSTR;




#ifndef WIN32
//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

//
// System time is represented with the following structure:
//

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
#endif /* !WIN32 */


#define CopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))

#endif /* WIN32 */
#endif /* _16BIT_TYPES_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awcapapi.h ===
/* Copyright Microsoft Corp 1994 */
/* awCapInf.h
 *
 * definitions for Capabilites Interface for modems
 *
 *
 */

#ifndef awCapInf_h_include
#define awCapInf_h_include

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

// The convinence of defining bit masks
#define AWCAP_SETBIT(x) 1<<x

// enum enumCapabilities
enum enumCapabilities {
                    // Standard Capabilities
    eCapStd_MessageVer,
    eCapStd_fBinaryData,
    eCapStd_fInboundRouting,
    eCapStd_SecurityVer,
    eCapStd_CompressVer,
    eCapStd_OperatingSysVer,
    eCapStd_PreambleVer,
    eCapStd_InteractiveVer,
    eCapStd_DataSpeed,
    eCapStd_DataLink,
            // Image Capabilites
    eCapImg_PagePixWid,
    eCapImg_RBAver,
    eCapImg_CoverAttachVer,
    eCapImg_AddressBookAttachVer,
    eCapImg_GDIMetaVer,
    eCapImg_HighResolutions,
    eCapImg_OtherEncoding,
    eCapImg_PageSizesSupported,
    eCapImg_OtherPageSizesSupported,
            // Polling Capability Group
    eCapPol_fLowSpeedPoll,
    eCapPol_fHighSpeedPoll,
    eCapPol_fPollByNameAvail,
    eCapPol_fPollByRecipAvail,
    eCapPol_fPollByFileName,
    eCapPol_fAppCapAvail,
    eCapPol_fNoShortTurn,
    eCapPol_MsgRelayVer,
    eCapPol_ExtCapsCRC,
    //  General Information Group
    eCapInfo_MachineId,
						// FAX Capablities
	eCapFax_fPublicPoll,
    eCapFax_AwRes,
    eCapFax_Encoding,
    eCapFax_PageWidth,
    eCapFax_PageLength

};

//  enum enumCapStd_eMessageVer
enum enumCapStd_eMessageVer {
    eMessageVer_NoLinearizeMsg  = 0,
    eMessageVer_LinearizeVer1   = 1,
    eMessageVer_MaxValue        = 7     // Largest Value in enum
};

//  enum enumCapStd_eSecurityVer
enum enumCapStd_eSecurityVer {
    eSecurityVer_NoSecurity     = 0,
    eSecurityVer_SecurityV1     = 1,
    eSecurityVer_MaxValue       = 7 // Largest Value in enum
};
//  enum enumCapStd_eCompressVer
enum enumCapStd_eCompressVer {
    eCompressVer_NoCompession   = 0,
    eCompressVer_CompressV1     = 1,
    eCompressVer_MaxValue       = 3 // Largest Value in enum
};
//  enum enumCapStd_eOperatingSysVer
enum enumCapStd_eOperatingSysVer {
    eOperatingSysVer_EFAX       = 0,
    eOperatingSysVer_IFAX       = 1,
    eOperatingSysVer_IPRINT     = 2,
    eOperatingSysVer_IPHONE     = 3,
    eOperatingSysVer_MaxValue   = 7 // Largest Value in enum
};
//  enum enumCapStd_eInteractiveVer
enum enumCapStd_eInteractiveVer {
    eInteractiveVer_NotSupported        = 0,
    eInteractiveVer_InteractiveV1       = 1,
    eInteractiveVer_MaxValue            = 7 // Largest Value in enum
};

//  enum enumCapStd_eDataSpeed
enum enumCapStd_eDataSpeed {
    eDataSpeed_NoDataModem      = 0,
    eDataSpeed_V_22bis          = 1,        // 2400
    eDataSpeed_V_32             = 2,            // 9600
    eDataSpeed_V_32bis          = 3,        // 14400
    eDataSpeed_V_32ter          = 4,        // 19200
    eDataSpeed_Reserved0        = 5,        //
    eDataSpeed_V_fast           = 6,        //
    eDataSpeed_Reserved1        = 7,        //
    eDataSpeed_MaxValue         = 7     // Largest Value in enum
};

//  enum enumCapStd_eDataLink
enum enumCapStd_eDataLink {
    eDataLink_NoDataLink    = 0,
    eDataLink_MNP           = 1,        // V.42 Annex A
    eDataLink_V_42          = 2,        // V.42 LAPM & MNP
    eDataLink_V_42bis       = 3,        // V.42bis compression
    eDataLink_MaxValue      = 3     // Largest Value in enum
};


// enum enumCapImg_eCoverAttachVer
enum enumCapImg_eCoverAttachVer {
    eCoverAttachVer_NoSupported = 0,
    eCoverAttachVer_Version1    = 1,
    eCoverAttachVer_MaxValue    = 3     // Largest Value in enum
};

//  enum enumCapImg_eGDIMetaVer
enum enumCapImg_eGDIMetaVer {
    eGDIMetaVer_NotSupported    = 0,
    eGDIMetaVer_MaxValue        = 3     // Largest Value in enum
};

//  enum enumCapImg_eHighResolutions
enum enumCapImg_eHighResolutions {
    eHighResolutions_NotSupported      = 0,
    eHighResolutions_MaxValue          = 0   // Largest Value in num
};


//  enum enumCapImg_eOtherEncoding
enum enumCapImg_eOtherEncoding {
    eOtherEncoding_NotSupported     = 0,
    eOtherEncoding_MaxValue         = 0         // Largest Value in enum
};

enum enumCapFax_eAwres {
 	eAwres_UNKNOWN 		 	=	 0,
 	eAwres_CUSTOM           =	 AWCAP_SETBIT(0),
 	eAwres_mm080_038        =	 AWCAP_SETBIT(1),
 	eAwres_mm080_077        =	 AWCAP_SETBIT(2),
 	eAwres_mm080_154        =	 AWCAP_SETBIT(3),
 	eAwres_mm160_154        =	 AWCAP_SETBIT(4),
 	eAwres_200_100          =	 AWCAP_SETBIT(5),
 	eAwres_200_200          =	 AWCAP_SETBIT(6),
 	eAwres_200_400          =	 AWCAP_SETBIT(7),
 	eAwres_300_300          =	 AWCAP_SETBIT(8),
 	eAwres_400_400          =	 AWCAP_SETBIT(9),
 	eAwres_600_600          =	 AWCAP_SETBIT(10),
    eAwres_MaxValue         =    AWCAP_SETBIT(10)    // Largest Value in enum
};

//  enum enumCapFax_eEncoding 		
enum enumCapFax_eEncoding {			// Bit Values
    eEncoding_NotSupported     = 0,	
    eEncoding_MH               = AWCAP_SETBIT(0),
    eEncoding_MR               = AWCAP_SETBIT(1),
    eEncoding_MMR              = AWCAP_SETBIT(2),
    eEncoding_MaxValue         = AWCAP_SETBIT(2)         // Largest Value in enum
};
//  enum enumCapFax_ePageWidth 		
enum enumCapFax_ePageWidth 	{			// Bit Values
    ePageWidth_A4 			 	= 0,
	ePageWidth_B4 				= AWCAP_SETBIT(0), 
	ePageWidth_A3  				= AWCAP_SETBIT(1),
	ePageWidth_A5 				= AWCAP_SETBIT(2),  /* 1216 pixels */
	ePageWidth_A6  				= AWCAP_SETBIT(3), 	/* 864 pixels  */
	ePageWidth_A5_1728 			= AWCAP_SETBIT(4),  /* 1216 pixels */
	ePageWidth_A6_1728 			= AWCAP_SETBIT(5) 	/* 864 pixels  */
 };
//  enum enumCapFax_ePageLength 		
enum enumCapFax_ePageLength 	{			// Bit Values
    ePageLength_A4 			 	= 0,
	ePageLength_B4 				= 1, 
	ePageLength_Unlimited		= 2,
	ePageLength_MaxValue		= 2
 };

#define CAP_DEFAULT_MESSAGE_VER         eMessageVer_NoLinearizeMsg
#define CAP_DEFAULT_SECURITY_VER        eSecurityVer_NoSecurity
#define CAP_DEFAULT_COMPRESS_VER        eCompressVer_NoCompession
#define CAP_DEFAULT_OS_VER              eOperatingSysVer_EFAX
#define CAP_DEFAULT_INTERACTIVE_VER     eInteractiveVer_NotSupported
#define CAP_DEFAULT_DATA_SPEED          eDataSpeed_NoDataModem
#define CAP_DEFAULT_DATA_LINK           eDataLink_NoDataLink
#define CAP_DEFAULT_COVER_ATTACH_VER    eCoverAttachVer_NoSupported
#define CAP_DEFAULT_GDI_META_VER        eGDIMetaVer_NotSupported
#define CAP_DEFAULT_HIGH_RESOLUTIONS    eHighResolutions_NotSupported
#define CAP_DEFAULT_OTHER_ENCODING      eOtherEncoding_NotSupported
#define CAP_DEFAULT_FPUBLICPOL			efPublicPoll_NotSupported
#define CAP_DEFAULT_RES				    eAwres_mm080_038
#define CAP_DEFAULT_ENCODING    		eEncoding_MH
#define CAP_DEFAULT_PAGEWIDTH 		    ePageWidth_A4
#define CAP_DEFAULT_PAGELENGTH    		ePageLength_A4
   
#define CAP_DEFAULT_RAMBO_VER           0       // no enum for these yet...
#define CAP_DEFAULT_MSG_RELAY_VER       0
#define CAP_DEFAULT_POLL_EXT_CAPS_CRC   0
#define CAP_DEFAULT_PAGE_SIZES          0


/* UpdateCapabilitiesEntry()
 *Parameters:
 *  lpPhoneNumber   Pointer to Normalized phone number with country and
 *                  city code added to local number. For example
 *                  1-206-936-8502.
 *  cbRawFrames     Number of bytes contained pointed to by lpRawFrames.
 *  lpRawFrames     Pointer to buffer containing raw bytes by At Work Modem
 *                  Transport for Capabilities exchange.
 *Returns:
 *      0   = Success entry previously existed
 *      1   = Success entry was created
 *      1   = Failure lpPhoneNumber contained invalid characters
 */
extern int EXPORT_DLL WINAPI UpdateCapabilitiesEntry(
    PSZ                 lpPhoneNumber,
    DWORD               cbRawFrames,
    PUCHAR              lpRawFrames);

/* GetCapabilitiesEntry()
 *Parameters:
 *  lpPhoneNumber   Pointer to Normalized phone number with country and city
 *                  code added to local number. For example 1-206-936-8502.
 *  cbRawFrames     Number of bytes contained pointed to by lpRawFrames.
 *  cbRawFramesRtn  Number of bytes returned in lpRawFrames.
 *  lpRawFrames     Pointer to buffer containing raw bytes by At Work Modem
 *                  Transport for Capabilities exchange.
 *Returns:
 *  ERROR_SUCCESS       Success entry found and returned.
 *  ERROR_BAD_ARGUMENTS Failure lpPhoneNumber contained invalid characters
 *                      or lpRawFrames is NULL
 *  ERROR_MORE_DATA     Failure cbRawFrames to small, actual number of bytes
 *                      available in cbRawFramesRtn.
 */
extern int EXPORT_DLL WINAPI GetCapabilitiesEntry(
    PSZ             lpPhoneNumber,
    LPDWORD         lpcbRawFrames,
    PUCHAR          lpRawFrames,
    PBOOL           pfRtnDefault
);

/*  DeleteCapabilitiesEntry()
 *Parameters:
 *  lpPhoneNumber   Pointer to Normalized phone number with country and city
 *                  code added to local number. For example 1-206-936-8502.
 *Returns:
 *  0   = Success entry found and deleted.
 *  1   = Failure lpPhoneNumber contained invalid characters
 *  2   = Failure lpPhoneNumber was not found.
 */

extern int EXPORT_DLL WINAPI DeleteCapabilitiesEntry(
    PSZ                 lpPhoneNumber
);

/* EnumCapabilitiesOpen
 *
 *  Open a session for enumeration of the Capabilities database
 *Parameters:
 *  lphDataBase     LP to handle for subsuquenct calls to the Enum
 *                  API's
 *Returns:
 *  ERROR_SUCCESS -- Call succeded otherwise an error occured
 *                   and the database handle is not valid
 *  error otherwise
 */
int EXPORT_DLL WINAPI  EnumCapabilitiesOpen(
    LPDWORD         lphDataBase
);

/* EnumCapabilitiesClose
 *
 *  Close a session for enumeratin of the Capabilities database
 *Parameters:
 *  hDataBase   handle from call to EnumCapabilitiesOpen
 *Returns:
 *  ERROR_SUCCESS -- always returns
 */
int WINAPI  EnumCapabilitiesClose(
    DWORD           hDataBase
);

/*  EnumCapabablitesEntry()
 *  Used to return a list of phone numbers known by the capabilities
 *  interface.  The caller passes a buffer to store a list of zero
 *  terminated ASCII strings.  If the buffer is too small the buffer
 *  is filled up to cbPhoneNumberList and lpcbPhoneNumberList is
 *  returned with the number of bytes required to retrieve the compete
 *  list.  So the ideal calling sequence is to call the function twice
 *  , once with cbPhoneNumberList with a value of zero and
 *  lpcbPhoneNumberList is returned with the size of the correct buffer.
 *  A second call is then made with the proper buffer sized and
 *  cbPhoneNumberList  correctly set. However, the size of the buffer
 *  necessary may change from the first call to second because of
 *  parallel activity, so padding the buffer after the first call as
 *  well as a timely calling sequence will minimize the possibility of
 *  a failure.
 *
 *Parameters:
 *  hDataBase       handle from call to EnumCapabilitiesOpen
 *  lpPhoneNumber   Pointer to buffer where list of zero terminated phone
 *                  numbers is stored.
 *  lpcbPhoneNumber Size of the buffer that lpPhoneNumberList points to.
 *  lpLastWrite     Pointer to FILETIME structure to store last Write Time
 *
 *Returns:
 *  ErrorSuccess
 *  Error otherwise
 */
extern int EXPORT_DLL  WINAPI  EnumCapabilitiesEntry(
    DWORD           hDataBase,
    PSZ             lpPhoneNumber,
    LPLONG          lpcbPhoneNumber,
    PFILETIME       lpLastWrite
);


/* GetCapabilitiesValue()
 * Returns the integer value of the capability extracted from the
 * lpRawFrames.
 *
 * Parameters:
 *  eCapabilities   Enumeration value of enumCapabilities.  One capability
 *                  that caller is attempting to discover.
 *  lpValue         pointer to where parsed capabilities is returned. Only
 *                  valid if function returns success.
 *  lpcbValue       On Call size of lpValue, on return # bytes returned.
 *  lpRawFrames     Pointer to buffer containing raw bytes by At Work Modem
 *                  Transport for Capabilities exchange.
 *  cbRawFrames     Size of lpRawFrames data.
 *Returns:
 *  ERROR_SUCCESS   = Capability found and value returned in lpValue.
 *  != ERROR_SUCCESS= Failure eCapabilities was not found in the raw frames.
 */
int EXPORT_DLL WINAPI GetCapabilitiesValue(
    enum    enumCapabilities    eCapabilities,
    PVOID               lpValue,
    PDWORD              lpcbValue,
    PVOID               lpRawFrames,
    DWORD               cbRawFrames
);


#ifdef __cplusplus
} // extern "C"
#endif

#endif  // awCapInf_h_include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awcover.h ===
/* Returns TRUE for success, FALSE for failure */

/* Fills in lphsfile on success with handle to file containing 200 x 200 HRAW
   cover page, with paper size 1728 x 2100 */

typedef BOOL (WINAPI *CREATECOVPAGEPROC)(LPSOSSESSION, LPMESSAGESOS, LPhSecureFile);
BOOL WINAPI CreateCovPage(LPSOSSESSION lpSession, LPMESSAGESOS lpMsg,
			  LPhSecureFile lphSFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\arasock.h ===
/*
 * this is the arasock header
 */

#ifndef _ARASOCK_
#define _ARASOCK_


#include <windows.h>
#include <socket.h>

#define	PSI_SUCCESS				0
#define AS_PROTFAMILY_NOT_FOUND	(WSABASEERR+94)
#define AS_PF_OUT_OF_RANGE		(WSABASEERR+95)

#define	AS_MAX_TASK				10
#define AS_MAX_SOCK_PER_TASK	5
#define AS_MAX_SOCKET			AS_MAX_TASK*AS_MAX_SOCK_PER_TASK

#define AS_STATE_INUSE			0x01	// socket has been reserved, but not bound
#define AS_STATE_AVAILABLE		0x00	// the socket is bound to an address

 typedef struct PROTPARAMtag
 {  
  	WORD	wTypes;			// the protocol styles supported, SOCK_DGRAM, SOCK_STREAM, etc
	DWORD	dwFamilies;		// the families we support.  usually ours + PF_UNSPEC
 	#ifndef SHIP_BUILD
 	WORD	wMaxDataSize;	// Maximum data size supported by this transport
 	#endif
 } PROTPARAM, *PPROTPARAM, FAR *LPPROTPARAM;

/////////  PSI CALLBACKS to Arador Sockets ////////////////////
		int CALLBACK  ASclosedProc(SOCKET sock, WORD wResult); 
typedef int (CALLBACK *LPFN_CLOSED)(SOCKET sock, WORD wResult);
	
//////// PSI entry point Prototypes ///////////
		int WINAPI  PSIinit(LPPROTPARAM lpProtParam, LPFN_CLOSED lpfnLink);
typedef	int (WINAPI *LPFN_PSIINIT)(LPPROTPARAM lpProtParam, LPFN_CLOSED lpfnLink);
 		int WINAPI PSIdeinit(void);
typedef int (WINAPI *LPFN_PSIDEINIT)(void);
		int WINAPI PSIopen(SOCKET sock, int nStyle, int nMac, LPFN_CLOSED lpfnClosed);
typedef int (WINAPI *LPFN_PSIOPEN)(SOCKET sock, int nStyle, int nMac, LPFN_CLOSED lpfnClosed);
		int WINAPI PSIclose(SOCKET sock);
typedef	int (WINAPI *LPFN_PSICLOSE)(SOCKET sock);
		int WINAPI PSIbindAddress(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
typedef	int (WINAPI *LPFN_PSIBINDADDRESS)(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
		int WINAPI PSIconnect(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
typedef	int (WINAPI *LPFN_PSICONNECT)(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
		int WINAPI PSIassociate(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
typedef	int (WINAPI *LPFN_PSIASSOCIATE)(SOCKET sock, LPSOCKADDR lpSockAddr, WORD wAddrLen);
		int WINAPI PSIlisten(SOCKET sock, int nBacklog);
typedef	int (WINAPI *LPFN_PSILISTEN)(SOCKET sock, int nBacklog);
		int WINAPI PSIaccept(SOCKET sock, SOCKET sockNew);
typedef	int (WINAPI *LPFN_PSIACCEPT)(SOCKET sock, SOCKET sockNew);
		int WINAPI PSIsendConnection(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags);
typedef	int (WINAPI *LPFN_PSISENDCONNECTION)(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags);
		int WINAPI PSIrecvConnection(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags);
typedef	int (WINAPI *LPFN_PSIRECVCONNECTION)(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags);
		int WINAPI PSIsendConnectionless(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags, LPSOCKADDR lpSockAddr, WORD wAddrLen);
typedef	int (WINAPI *LPFN_PSISENDCONNECTIONLESS)(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags, LPSOCKADDR lpSockAddr, WORD wAddrLen);
		int WINAPI PSIrecvConnectionless(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags, LPSOCKADDR lpSockAddr, LPWORD lpwAddrLen);
typedef	int (WINAPI *LPFN_PSIRECVCONNECTIONLESS)(SOCKET sock, LPBYTE lpbData, LPWORD lpwDataLen, WORD wFlags, LPSOCKADDR lpSockAddr, LPWORD lpwAddrLen);
		int WINAPI PSIgetRemoteName(SOCKET sock, LPSOCKADDR lpSockAddr, LPWORD pwAddrLen);
typedef	int (WINAPI *LPFN_PSIGETREMOTENAME)(SOCKET sock, LPSOCKADDR lpSockAddr, LPWORD pwAddrLen);
		int WINAPI PSIgetLocalName(SOCKET sock, LPSOCKADDR lpSockAddr, LPWORD pwAddrLen);
typedef	int (WINAPI *LPFN_PSIGETLOCALNAME)(SOCKET sock, LPSOCKADDR lpSockAddr, LPWORD pwAddrLen);
		int WINAPI PSIregEvent(SOCKET sock, HWND hWnd, WORD wMsg, DWORD dwEvent);
typedef	int (WINAPI *LPFN_PSIREGEVENT)(SOCKET sock, HWND hWnd, WORD wMsg, DWORD dwEvent);
		int WINAPI PSIsetOption(SOCKET sock, WORD wOptName, LPBYTE lpOptVal, WORD wOptLen);
typedef	int (WINAPI *LPFN_PSISETOPTION)(SOCKET sock, WORD wOptName, LPBYTE lpOptVal, WORD wOptLen);
		int WINAPI PSIgetOption(SOCKET sock, WORD wOptName, LPBYTE lpOptVal, LPWORD lpwOptLen);
typedef	int (WINAPI *LPFN_PSIGETOPTION)(SOCKET sock, WORD wOptName, LPBYTE lpOptVal, LPWORD lpwOptLen);
		int WINAPI PSIStartAdvertisement(SOCKET sock, WORD wServerType, LPSTR lpServerName );
typedef	int (WINAPI *LPFN_PSISTARTADVT)( SOCKET sock, WORD wServerType, LPSTR lpServerName );
		int WINAPI PSIStopAdvertisement(SOCKET sock, WORD wServerType );
typedef	int (WINAPI *LPFN_PSISTOPADVT)( SOCKET sock, WORD wServerType);
typedef	void (WINAPI *LPFN_PSIFINDSERVERCLOSE)( AWHANDLE hTransaction );
	void WINAPI PSIFindServerClose( AWHANDLE hTransaction );
struct hostent FAR * WINAPI PSIFindFirstServer( WORD wServerType, LPSTR lpServerName, 
					LPAWHANDLE lphTransaction );
typedef	struct hostent FAR *(WINAPI *LPFN_PSIFINDFIRSTSERVER)( WORD wServerType, 
							LPSTR lpServerName, LPAWHANDLE lphTransaction );
struct hostent FAR * WINAPI PSIFindNextServer
	( WORD wServerType,LPSTR lpServerName, AWHANDLE hTransaction );
typedef	struct hostent FAR *(WINAPI *LPFN_PSIFINDNEXTSERVER)
	( WORD wServerType, LPSTR lpServerName, AWHANDLE hTransaction );
	int WINAPI PSIGetHostByName(LPSTR lpServerName, LPSOCKADDR lpAddr, WORD wBufLen );
typedef	int (WINAPI *LPFN_PSIGETHOSTBYNAME)( LPSTR ServerName, LPSOCKADDR lpAddr, WORD wBufLen );

int WINAPI  PSIGetLastSocketError ( SOCKET  sockParm );
typedef	int (WINAPI *LPFN_PSIGETLASTSOCKETERROR)( SOCKET sockParm);

typedef struct PROTFAMILYtag
 {   
 	BOOL						fInUse;
 	char						lpszProtocol[20];
 	PROTPARAM					ProtParam;
 	HINSTANCE					hinstDll;
 	LPFN_PSIOPEN				PSIopen;
 	LPFN_PSICLOSE				PSIclose;
 	LPFN_PSIBINDADDRESS			PSIbindAddress;
 	LPFN_PSICONNECT				PSIconnect;
 	LPFN_PSIASSOCIATE			PSIassociate;
 	LPFN_PSILISTEN				PSIlisten;
 	LPFN_PSIACCEPT				PSIaccept;
 	LPFN_PSISENDCONNECTION		PSIsendConnection;
 	LPFN_PSIRECVCONNECTION		PSIrecvConnection;
 	LPFN_PSISENDCONNECTIONLESS	PSIsendConnectionless;
 	LPFN_PSIRECVCONNECTIONLESS	PSIrecvConnectionless;
 	LPFN_PSIGETREMOTENAME		PSIgetRemoteName;
 	LPFN_PSIGETLOCALNAME		PSIgetLocalName;
 	LPFN_PSIREGEVENT			PSIregEvent;
 	LPFN_PSISETOPTION			PSIsetOption;
 	LPFN_PSIGETOPTION			PSIgetOption;
 	LPFN_PSISTARTADVT			PSIStartAdvertisement;
 	LPFN_PSISTOPADVT			PSIStopAdvertisement;
	LPFN_PSIFINDFIRSTSERVER		PSIFindFirstServer;
	LPFN_PSIFINDNEXTSERVER		PSIFindNextServer;
	LPFN_PSIFINDSERVERCLOSE		PSIFindServerClose;
	LPFN_PSIGETHOSTBYNAME		PSIGetHostByName;
 } PROTFAMILY, *PPROTFAMILY;
 

 typedef struct AWSOCKHANDLEtag
 {
 	AWHANDLE hProtAwHandle;		// handle returned by the transport
 	WORD wCurrentFamily;
 	HGLOBAL hMem;				// Handle returned by GlobalAlloc
 	BYTE	ServerName[48];		// To store server Name
 	WORD 	wServerType;		// Cache ServerType
 }AWSOCKHANDLE;

 typedef AWSOCKHANDLE FAR *LPAWSOCKHANDLE;
 typedef struct PERTASKtag
 {  
 	BOOL		fInUse;
 	HTASK		hTaskId;
 	WORD		wReferenceCount;	
	WORD		wUsedSockets;
	WORD		wLastError;
	struct hostent hent;
#ifdef ATWORK
	struct sockaddr	sa_list[8];
	char FAR * addrlist[16];	// Assume that we will never support more than 8 transports at the
							// same time
#endif	
 } PERTASK, *PPERTASK;
	
 typedef struct SOCKETtag
 {  
 	WORD		wState;		// OR'd list of AS_STATES
 	WORD		wType;
 	WORD		wMac;
 	int			nProtFamily;		// we need this array index twice because we do funky poniter stuff
 	PPROTFAMILY	pProtFamily;
 	PPERTASK	pPerTask;
 } SOCK, *PSOCK;
 
int ASinstallProtocolStack(WORD wProtFamily, LPSTR lpszProtocol, LPSTR lpszDllName);
int ASinstallProtocolStacks();
int ASremoveProtocolStack(WORD wProtFamily);
#ifdef IFAX
void ASRemoveProtocolStacks();
#endif
int CALLBACK ASclosedProc(SOCKET sock, WORD wResult); 
#ifdef ATWORK
LPVOID myGlobalAlloc( UINT flags, DWORD dwMemSize , HGLOBAL FAR *lpHandle );
HGLOBAL myGlobalFree( HGLOBAL hMem,  LPVOID lpMem );
#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awdebug.h ===
/***********************************************************************
 *
 * At Work Fax: Debug Trace Stuff
 *
 *
 * Copyright 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *
 ***********************************************************************/

#ifndef awDebug_h_include
#define awDebug_h_include


#ifdef __cplusplus
extern "C" {
#endif


#ifdef DEBUG

// prototypes
void _DebugCheckHeap(void);
VOID FAR CDECL DebugPrintf(LPSTR lpszFmt, ...);
VOID FAR CDECL DebugErrorPrintf(LPSTR lpszFmt, ...);

// macros
#define AwTraceEntry( f ) 		DebugPrintf("ENTER->"#f"\n")
#define AwDebugTrace( x )       DebugPrintf x
#define AwDebugError( x )       DebugErrorPrintf x
// MAPI Debug traces
#define AwDebugTraceSc(f,sc) \
    DebugErrorPrintf(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc))
#define AwDebugTraceResult(f,hr)   \
    DebugErrorPrintf(#f " returns 0x%08lX %s\n", GetScode(hr), \
    SzDecodeScode(GetScode(hr)))
#define AwDebugTraceArg(f,s)   \
  DebugPrintf(#f ": bad parameter: " s "\n")
#define AwDebugTraceLine() \
  (DebugPrintf("File %s, Line %i    \n",__FILE__,__LINE__))
#define AwDebugCheckHeap()  _DebugCheckHeap()

#else

#define AwTraceEntry( f )
#define AwDebugTrace(x)
#define AwDebugError(x)
#define AwDebugTraceResult(f,hr)
#define AwDebugTraceSc(f,sc)
#define AwDebugTraceLine()
#define AwDebugTraceArg(x,y)
#define AwDebugCheckHeap()

#endif

/***********************************************************************
 *
 * Memory tracking functions and defines
 *
 ***********************************************************************/

// memory tracking macros
#define FREE_ALL_LEAKS		0x00000001
#define DUMP_LEAKED_MEMORY	0x00000002

#ifdef MEM_TRACKING

#define INIT_MEMORY_TRACKING	InitMemoryTracking
#define STOP_MEMORY_TRACKING	UnInitMemoryTracking
#define REGISTER_ALLOC			RegisterMemoryAlloc
#define REGISTER_FREE			UnRegisterMemoryAlloc

#else

#define INIT_MEMORY_TRACKING
#define STOP_MEMORY_TRACKING
#define REGISTER_ALLOC
#define REGISTER_FREE

#endif	// MEM_TRACKING

// memory tracking functions prototypes
BOOL InitMemoryTracking(LPTSTR lpszProcessName);
BOOL UnInitMemoryTracking(ULONG);
BOOL RegisterMemoryAlloc(LPVOID lpMem, ULONG cBytes);
BOOL UnRegisterMemoryAlloc(LPVOID lpMem);

#ifdef __cplusplus
} // extern "C"
#endif

#endif  // awDebug_h_include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awcpesup.h ===
/*
 *  AWCPESUP . H
 *
 *      Microsoft AtWork Fax for Windows
 *      Copyright (C) 1993-1994, Microsoft Corporation
 *
 *      Information in this document is subject to change without notice and does
 *      not represent a commitment on the part of Microsoft Corporation.
 */

/*
 * Constants
 */
 
 
// Recipient properties
#define CPE_RECIPIENT_NAME              (0x80000001)
#define CPE_RECIPIENT_TITLE             (0x80000002)
#define CPE_RECIPIENT_DEPARTMENT        (0x80000003)
#define CPE_RECIPIENT_OFFICE_LOCATION   (0x80000004)
#define CPE_RECIPIENT_COMPANY           (0x80000005)
#define CPE_RECIPIENT_STREET_ADDRESS	(0x80000006)
#define CPE_RECIPIENT_POST_OFFICE_BOX   (0x80000007)
#define CPE_RECIPIENT_LOCALITY			(0x80000008)
#define CPE_RECIPIENT_STATE_OR_PROVINCE	(0x80000009)
#define CPE_RECIPIENT_POSTAL_CODE		(0x80000010)
#define CPE_RECIPIENT_COUNTRY			(0x80000011)
#define CPE_RECIPIENT_HOME_PHONE        (0x80000012)         
#define CPE_RECIPIENT_WORK_PHONE        (0x80000013)         
#define CPE_RECIPIENT_FAX_PHONE         (0x80000014)         

// Sender properties
#define CPE_SENDER_NAME                 (0x08000001)
#define CPE_SENDER_TITLE                (0x08000002)
#define CPE_SENDER_DEPARTMENT           (0x08000003)
#define CPE_SENDER_OFFICE_LOCATION      (0x08000004)
#define CPE_SENDER_COMPANY              (0x08000005)
#define CPE_SENDER_ADDRESS              (0x08000006)
#define CPE_SENDER_HOME_PHONE           (0x08000007)
#define CPE_SENDER_WORK_PHONE           (0x08000008)
#define CPE_SENDER_FAX_PHONE            (0x08000009)
#define CPE_RECIPIENT_TO_LIST           (0x0800000A)
#define CPE_RECIPIENT_CC_LIST           (0x0800000B)

// Message related properties                   
#define CPE_MESSAGE_SUBJECT             (0x00800001)
#define CPE_MESSAGE_SUBMISSION_TIME     (0x00800002)
#define CPE_MESSAGE_BILLING_CODE        (0x00800003)

// Miscellanous message properties
#define CPE_MISC_ATTACHMENT_NAME_LIST   (0x00800004)// ; delimeted list of attachment names
#define CPE_MISC_USER_DEFINED           (0x00800005)// lpvBuf contains LPSPropValue

// Count type properties
#define CPE_COUNT_RECIPIENTS            (0x00800006)// Total count of recipients
#define CPE_COUNT_ATTACHMENTS           (0x00800007)// Total number of attachments
#define CPE_COUNT_PAGES                 (0x00800008)// total number of pages

// Derived property so CPE can get at PR_BODY data
// using the tempfile copy of PR_BODY
#define CPE_MESSAGE_BODY_FILENAME		(0x00800009)// Temp filename for PR_BODY text

// Configuration properties
#define CPE_CONFIG_CPE_TEMPLATE         (0x00080004)
#define CPE_CONFIG_PRINT_DEVICE         (0x00080005)// The device to print to

// Finish modes
#define CPE_FINISH_PAGE                 (0x00008001) //This is used when the 
												  //CPE finishes a page with out an error
#define CPE_FINISH_ERROR                (0x00008002) // This is used when the 
													  //CPE encounters an error.
													  //This causes the process to end and
													  //no further processing should take place
													  
// Finish return values
#define CPE_NEXT_PAGE                   (0x00000001) 
#define CPE_DONE                        (0x80000001)
#define CPE_ERROR                       (0x80000002)                                                     


//Version info
#define AWCPESUPPORT_VERSION 			(0x00010000)

/*
 * CPESupport Interface
 */
typedef ULONG FAR *LPULONG;

#undef INTERFACE
#define INTERFACE IAWCPESupport

DECLARE_INTERFACE_(IAWCPESupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
	
	// *** ICPESupport methods *** 
	STDMETHOD(GetVersion) (THIS_ LPULONG lpulVer) PURE;
	/* This function is used for version checking, 
	   it is currently not implemented */
	
	STDMETHOD(GetProp) (THIS_ ULONG ulProp, LPULONG lpulBufSize, LPVOID lpvBuf) PURE;
	/* This function is used to retrieve properties for the Cover Page.
		ulProp is one of the property constants above.
		lpulBufSize is a pointer to the size of the buffer pointed to by lpvBuf.
		lpvBuf is a buffer where the property value is returned.  If this value is NULL,
		the size needed to hold the property is returned in lpulBufSize.
	*/
	
	STDMETHOD(SetProp) (THIS_ ULONG ulProp, LPVOID lpvBuf) PURE;
	/* This function is used to set properties On the message.
		ulProp is one of the property constants above.
		lpvBuf is the buffer where the property value is.  
	*/
		
	STDMETHOD(GetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
	/* This function is used to retrieve the count of certain attributes, such
	   as thee number of recipients.
	   ulCntProp is one of the Count properties listed above.
	   lpulCount is where the count value is returned.
	*/

	STDMETHOD(SetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
	/* This function is used to set the count of certain attributes, such
	   as the number of recipients.
	   ulCntProp is one of the Count properties listed above.
	   lpulCount is the count value.
	*/

	STDMETHOD(Finish) (THIS_ ULONG ulMode) PURE;
	/* This function get called when the CPE finishes a page or encounters an error.
	   The CPE passes one of the finish codes from above to the function to signal 
	   which case is finishing, either the page or the CPE encountered an error.
	   ulMode is one of the pre defined modes.
	   
	   The function can return three modes other than normal errors:
			CPE_NEXT_PAGE   Finish returns this to signal the CPE to start printing
							the next page.
							
			CPE_DONE                Finish returns this to signal the CPE that all of the 
							Cover pages ahve been printed.
							
			CPE_ERROR               Finish returns this to signal that an error ocurred in
							the transport subsystem.  The CPE should exit with out UI
							and without calling finish again.
							
	*/
};
typedef IAWCPESupport FAR * LPAWCPESUPPORT;

// Service Entry definition
extern "C" {
typedef LONG (WINAPI *AWCPESUPPORTPROC)(DWORD dwSesID, LPAWCPESUPPORT FAR* lppCPESup);
}
typedef AWCPESUPPORTPROC FAR* LPAWCPESUPPORTPROC;



/*
 * GUIDs
 */
DEFINE_GUID(IID_IAWCPESupport, 0xd1ac6c20,0x91d4,0x101b,0xae,0xcc,0x00,0x00,0x0b,0x69,0x1f,0x18);

/*
 * Registry key locations
 */

// THESE MUST BE IDENTICAL TO THE ONES IN FAXCOVER.H!!!!!!!	$BUGBUG this needs to be removed before release

// This is the root level key where the CPE specific sub keys are stored
#define CPE_SUPPORT_ROOT_KEY 	("Software\\Microsoft\\At Work Fax\\Transport Service Provider")

// This is the location where the CPE puts the command line to used when calling it to print
// cover pages at send time.  The format is total at the CPE's discretion.  The transport will
// look for the string "SESS_ID" and replace it with the current session id.  The session ID is
// a DWORD. 
#define CPE_COMMAND_LINE_KEY ("Cover Page Editor")

// This key contains the DLL name that the CPE loads to get the Support Object
#define CPE_SUPPORT_DLL_KEY ("CPE Support DLL")

//This is the key that holds the name of the function in the Support DLL that is the actual "Service Entry"
#define CPE_SUPPORT_FUNCTION_NAME_KEY ("CPE Support Function Name")

// END IDENTICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awdenc.h ===
// Copyright (c) Microsoft Corp. 1995
/*==============================================================================
Interfaces to encode AWD image streams.

19-Jul-95    RajeevD    Created
==============================================================================*/

#ifndef _AWDENC_
#define _AWDENC_

#include <windows.h>
#include <buffers.h>

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
IMAGE INTERFACE OVERVIEW

This interface is used to create an image file suitable for embedding in an AWD
file.  First, an IMAGEINFO structure is be initialized and passed to ImageCreate.
Next, ImageSetBand can be called multiple times to append bitmap data to the
current page or start a new page.  Finally, ImageClose must be called at the end
of the last page.
==============================================================================*/

/*==============================================================================
The IMAGEINFO structure must be initialized before passing it to ImageCreate.
The dwTypeIn field may be set to HRAW_DATA if passing Windows bitmaps, where
the high (sign) bit of each byte is leftmost in the image, or LRAW_DATA for fax
bitmaps, where it is rightmost.  The dwTypeOut field must be set to RAMBO_DATA.
These constants are defined in buffers.h.
==============================================================================*/
typedef struct
{
	DWORD  dwTypeIn;       // HRAW_DATA or LRAW_DATA
	DWORD  dwTypeOut;      // must be RAMBO_DATA
	WORD   xRes;           // horizontal resolution [dpi]
	WORD   yRes;           // vertical resolution [dpi]
}
	IMAGEINFO, FAR *LPIMAGEINFO;

/*==============================================================================
ImageCreate creates an image file with the specified name, returning a context
pointer to be passed to ImageSetBand and ImageClose.
==============================================================================*/
LPVOID                         // returns context (NULL on failure)
WINAPI
ImageCreate
(
  LPTSTR      lpszImagePath,   // image file name
  LPIMAGEINFO lpImageInfo      // image parameters
);

/*==============================================================================
ImageSetBand will encode a BITMAP with the following restrictions:

	bmType        must be 0
	bmWidth       pixel width, must be same for all bands and a multiple of 32
	bmHeight      pixel height, must be same for all bands except last on page
	bmWidthBytes  must be bmWidth / 8
	bmPlanes      must be 1
	bmBitsPixel   must be 1
	bmBits        must point to less than 64K of data

All bitmaps must have the same height, except the last one on a page, which may
be less.  To start a new page, ImageSetBand is called with bmHeight set to 0.
A new page should not be started before the first page or after the last page.
==============================================================================*/
BOOL                           // returns TRUE on success
WINAPI
ImageSetBand
(
  LPVOID   lpImage,            // context returned from ImageCreate
  LPBITMAP lpbmBand            // bitmap data to be added
); 

/*==============================================================================
ImageClose is called at the end of the last page.  If ImageClose fails, the 
incomplete image file must be deleted.  If ImageSetBand fails, ImageClose must
be called before deleting the image file.
==============================================================================*/
BOOL                           // returns TRUE on success
WINAPI
ImageClose
(
	LPVOID   lpImage             // context returned from ImageCreate
);

/*==============================================================================
AWD INTERFACE OVERVIEW

This interface is used to create an AWD file and embed image files within it.

The current implementation relies on static variables; therefore Win32 clients
should not use it from more than one thread and Win16 clients should not yield
(PeekMessage etc.) between AWDCreate and AWDClose.
==============================================================================*/


/*==============================================================================
AWDCreate creates a file with the specified name, returning a context pointer to
be passed to AWDAddImage and AWDClose.
==============================================================================*/
LPVOID                         // returns context (NULL on failure)
WINAPI
AWDCreate
(
	LPTSTR lpszAWDPath,          // AWD file name
	LPVOID lpReserved            // must be NULL
);

/*==============================================================================
AWDAddImage may be called multiple times to embed images within the AWD file.
It is the responsibility of the client to delete the image file if no longer
needed.
==============================================================================*/
BOOL                           // returns TRUE on success
WINAPI
AWDAddImage
(
	LPVOID lpAWD,                // context returned from AWDCreate
	LPTSTR lpszImagePath         // image file to embed in AWD file
);

/*==============================================================================
AWDClose is called after no more image are to be added to the AWD file.  If
AWDClose fails, the incomplete AWD file should be deleted.  If AWDAddImage fails,
AWDClose must be called before deleting the incomplete AWD file.
==============================================================================*/
BOOL
WINAPI
AWDClose
(
	LPVOID lpAWD
);

#ifdef __cplusplus
} // extern "C" 
#endif

#endif // _AWDENC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awfaxcfg.h ===
/***************************************************************************

    Name      : FaxCfg.c

    Comment   : Fax Configuration Interface (for profile wizard, property sheet
    			and per-msg options)

    Functions :

    Created   : 02/26/94

    Author    : BruceK

    Contribs  :	Yoram (1/3/95):	added permsg common stuff
				Yoram (3/24/95): added profile wizard interface

***************************************************************************/

#define szAWFcfgDLL     "awfxcg32.dll"      // At Work Fax Configuration DLL name
#define szAWFxAbDLL     "awfxab32.dll"      // At Work Fax Address Book DLL name

/*
 *    Wrapped IMAPIProp Interface declaration.
 */

#undef    INTERFACE
#define INTERFACE    struct _WMPROP

#undef  MAPIMETHOD_
#define    MAPIMETHOD_(type, method)    MAPIMETHOD_DECLARE(type, method, WMPROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define    MAPIMETHOD_(type, method)    MAPIMETHOD_TYPEDEF(type, method, WMPROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)    STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WMPROP_)
{
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
};

// typedef for a standard Release function
// typedef ULONG (STDMETHODCALLTYPE *LPFNRELEASE)(LPWMPROP);
typedef MAPIMETHOD_(ULONG,LPFNRELEASE) (THIS);


typedef struct _WMPROP 
{
    WMPROP_Vtbl *        lpVtbl;

    /* Need to be the same as other objects */
    
    LONG                lcInit;

    /* MAPI memory routines */
    
    LPALLOCATEBUFFER    lpAllocBuff;
    LPALLOCATEMORE		lpAllocMore;
    LPFREEBUFFER        lpFreeBuff;

    HINSTANCE			hInst;
    LPMALLOC            lpMalloc;
    ULONG				ulType;
    ULONG				cbOptionData;
    LPBYTE				lpbOptionData;
    LPMAPIPROP			lpMAPIProp;

	/*
	 *	 Various table used for displaying dialogs
	 */
	LPTABLEDATA			lpDetailsTable;
	LPTABLEDATA			lpDDLBXTableCoverPages;

	/*
	 *	Used for faxcfg-XP communication
	 */

	LPFNRELEASE			lpfnFaxcfgRelease;
	HINSTANCE			hlibPerMsg;

} WMPROP, FAR *LPWMPROP;

// MAWF configuration property sheet typedef and function pointer
typedef BOOL (*LPFNMAWFSETTINGSDIALOG)(HINSTANCE, HWND, DWORD, WORD);

// the per-msg options entry points
typedef BOOL (*LPFNPERMSGOPTIONS)(	LPMAPIPROP,HINSTANCE,LPMALLOC,ULONG,ULONG,LPBYTE,
 									LPMAPISUP, LPWMPROP FAR *,LPFNRELEASE);
typedef HRESULT (*LPFNGETPROFILEMSGPROPS)(LPMAPISUP, LPMAPIUID, ULONG *, LPSPropValue *);

// the MAPI profile wizard interface between awfxcg32 and awfaxp32
typedef struct WIZINFO
{
	LPMAPIPROP  lpMapiProp;		// object into which we store the properties
	HINSTANCE   hInst;			// The instance of the provider DLL
	LPMAPISUP	lpMAPISup;		// a MAPI support object
} WIZINFO, *LPWIZINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awfile.h ===
#ifndef __AWFILE_H__
#define __AWFILE_H__

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif


#ifndef IFAX11
#define AWFS_BLACKBOX 1     // turn on the blackbox option
#endif


#define AWFS_SEEK_BEG 0
#define AWFS_SEEK_CUR 1
#define AWFS_SEEK_END 2

#define AWFS_BADREAD            ((WORD)0xffff)
#define AWFS_BADWRITE           ((WORD)0xffff)
#define AWFS_BADSEEK            ((DWORD)0xffffffff)


#define AWFS_ROOT_DIR           "c:\\awfiles"

#ifdef AWFS_BLACKBOX

#define AWFS_READ  0            /* Read mode */
#define AWFS_WRITE 1            /* Write mode */
#define AWFS_BACKDOORWRITE 254  /* Internal use only */

#ifndef __AWFILE2_H__
/* None of the first 4 bytes of this structure can never legally be 0, so you
   can use this fact to mark an hSecureFile as unused. */
typedef struct hSecureFile
{
    BYTE data[12];
}
    hSecureFile, FAR *LPhSecureFile;

typedef struct hOpenSecureFile
{
    BYTE data[10];
}
    hOpenSecureFile, FAR *LPhOpenSecureFile;
#endif

#else   /* ------ IFAX11: NOT BLACKBOX ANY MORE ------ */

#define AWFS_TEMP_PATTERN   "c:\\awfiles\\T*.*"
#define AWFS_ALL_PATTERN    "c:\\awfiles\\*.*"
#define AWFS_REF_COUNT      "c:\\awfiles\\refcount.awf"

#define AWSF ((DWORD)'A'+((DWORD)'W'<<8)+((DWORD)'S'<<16)+((DWORD)'F'<<24))
#define AWFS_MAX_PATH       42  // C:\8.3\8.3\8.3  ==>  6 + 3 * 12 = 42
#define AWFS_BAD_ENCODER    0

/* ------- wFileInfo, used in SecCreateFile() ---------- */

#define AWFS_MASK_JOBINFO   ((WORD) 0x0FF0)
#define AWFS_GENERIC        ((WORD) 0x0000)
#define AWFS_RECVTOPC       ((WORD) 0x0010)
#define AWFS_SCANTOPC       ((WORD) 0x0020)
#define AWFS_SENDFROMPC     ((WORD) 0x0030)
#define AWFS_PRINTFROMPC    ((WORD) 0x0040)
#define AWFS_SCANTOTWAIN    ((WORD) 0x0050)
#define AWFS_RECV           ((WORD) 0x0060)	// don't care where awfile is
#define AWFS_SEND           ((WORD) 0x0070)	// don't care where awfile is
#define AWFS_SCAN           ((WORD) 0x0080)	// don't care where awfile is
#define AWFS_PRINT          ((WORD) 0x0090)	// don't care where awfile is

#define AWFS_MASK_SCRATCH   ((WORD) 0x0003)
#define AWFS_PERSISTENT     ((WORD) 0x0000)
#define AWFS_SCRATCH        ((WORD) 0x0001)

#define AWFS_MASK_DRIVE     ((WORD) 0x7000)
#define AWFS_DONTCARE       ((WORD) 0x0000)
#define AWFS_REMOTE         ((WORD) 0x1000)
#define AWFS_LOCAL          ((WORD) 0x2000)
#define AWFS_PREFERLOCAL    ((WORD) 0x3000)
#define AWFS_PREFERREMOTE   ((WORD) 0x4000)

#define AWFS_USER_ATTACH    (AWFS_GENERIC|AWFS_PERSISTENT)  // user attachment

/* -------- mode, used in SecOpenFile() --------- */

#define AWFS_MASK_ACCESSMODE    ((WORD) 0x000F)
#define AWFS_READ               ((WORD) 0)
#define AWFS_WRITE              ((WORD) 1)
// #define AWFS_BACKDOORWRITE      ((WORD) 2)   /* Internal use only */
// now it is only a hack
#define AWFS_BACKDOORWRITE 254  /* Internal use only */ // a hack for awsec.dll

#define AWFS_MASK_PREFETCH      ((WORD) 0x00F0)
// we can specify the max num of active buffers when prefetch will be turned off
#define AWFS_DEFAULT_PREFETCH   ((WORD) 0x0030) // three buffers can be prefetched at most

#define AWFS_MASK_BUFSIZE       ((WORD) 0xFF00)	// in units of 256 Bytes
#define AWFS_DEFAULT_BUFSIZE    ((WORD) 0x1000)	// 4 KB is default
#define AWFS_MAX_BUFSIZE        ((WORD) 0x4000) // 16 KB is max, please

#define AWFS_NORM_READ          (AWFS_READ|AWFS_DEFAULT_PREFETCH|AWFS_DEFAULT_BUFSIZE)
#define AWFS_NORM_WRITE         (AWFS_WRITE|AWFS_DEFAULT_BUFSIZE)

/* -------- data structures ------------- */

typedef struct tag_hSecureFile
{   // simplify naming and provide job information
    // must be 12 bytes for backward compatibility
    DWORD   dwEncoder;  // encoding file name, non-zero
    WORD    wFileInfo;  // file info passed in while calling SecCreateFile()
    WORD    wRemote;    // 0 for local file; non-zero for remote file
    char    szExt[4];	// customized extension if szExt[0] != '\0'
}
    hSecureFile, FAR *LPhSecureFile;

typedef struct tag_OpenHandle
{
    // the following from hSecureFile
    hSecureFile hsf;

    // the following are from original hOpenSecureFile
    WORD    wHdrSize;   // Size of header, 0 means closed file handle
    DWORD   dwHandle;	// Open file handle (4 bytes)
    WORD    wMode;      // READ or WRITE or READ_WRITE, used in _lopen()
    ULONG   ulOffset;   // Current physical position in the file

    // the following are for remote awfile client
    LPVOID  lpRfsOpen;  // for remote file system information

    // hands off, internal use only
    struct tag_OpenHandle FAR * next;
    struct tag_OpenHandle FAR * alloc_next;
}
    OPENHANDLE, FAR * LPOPENHANDLE;

typedef struct tag_hOpenSecureFile
{   // maintain more information associated with handle
    // must be 10 bytes for backward compatibility
    LPOPENHANDLE    lpOpenHandle;   // pointer to the internal info of file handle
    BYTE            unused[6];      // to keep the same size for backward compatibility
}
    hOpenSecureFile, FAR *LPhOpenSecureFile;

typedef struct tag_hSecureHeader
{   // drop encryption
    // previously, 266 bytes, 256 bytes of them are for security key.
    DWORD   magic;      // Should be AWSF
    WORD    size;       // Size of header
    hSecureFile hsf;
}
    hSecureHeader, FAR *LPhSecureHeader;

// for hhsos.dll
typedef struct tag_FILELINK
{
    DWORD           dwHash;     // awfile.dll does not care
    hSecureFile     hFile;
    WORD            wRefCount;
    struct tag_FILELINK FAR * lpNext;
}
    FILELINK, FAR * LPFILELINK;

// for remote awfile
typedef struct tag_FILECOUNT
{
    hSecureFile hsf;
    WORD        wRefCount;
}
    FILECOUNT, FAR * LPFILECOUNT;

#endif // end of IFAX11


// No secure file handles will have the first 4 bytes as 0

#define IsValidSecureFile(hsec) (*((LPDWORD)&(hsec)) != 0)


#ifdef IFAX11
/* Last error maintenance */
void WINAPI SecSetLastError ( DWORD dwErr );
DWORD WINAPI SecGetLastError ( void );


/* Construct the path name of this awfile. cb is the size of the buffer
   to hold the path name. The size of the buffer is recommended to be
   AWFS_MAX_PATH.
   Return NO_ERROR if this operation is successful.
   Return ERROR_NOT_SUFFICIENT_MEMORY if the buffer is too small.
   Return ERROR_INVALID_PARAMETER if either pointer is null. */
WORD WINAPI SecGetPath ( hSecureFile FAR * lphsf, LPSTR lpszPath, UINT cb );
WORD WINAPI SetGetRootDir ( LPSTR lpszPath, UINT cb );


/* Construct the encoder of the given awfile file name (not path name). */
DWORD WINAPI SecExtractEncoderFromFileName ( LPSTR lpszFileName );
#endif



/* Creates a new file in the secur file system, and fills in hsec to point to
   the new file.  Space for hsec must be allocated by the caller.  Returns 0
   for success, non-zero on failure.  The file is not open when the function
   returns. If temp is non-zero, file will be erased when machine is next
   rebooted as part of cleanup. */
#ifdef AWFS_BLACKBOX
WORD WINAPI SecCreateFile(hSecureFile FAR *hsec, WORD temp);
#else
WORD WINAPI SecCreateFile(hSecureFile FAR *hsec, WORD wFileInfo);
WORD WINAPI SecCreateFileEx (hSecureFile FAR * lphsec, WORD wFileInfo, LPSTR lpszExt );
#endif

/* Deletes a file from the secure file system.  Returns 0 for success, non-zero
   for failure.  Doesn't actually remove file until reference count is 0 */
WORD WINAPI SecDeleteFile(hSecureFile FAR *hsec);

/* Increments reference count on a secure file, such that it will take one more
   delete call to remove the file than before.  Returns 0 for success, non-zero
   for failure. */
WORD WINAPI SecIncFileRefCount(hSecureFile FAR *hsec);
#ifdef IFAX11
WORD WINAPI SecAdjustRefCount ( hSecureFile FAR * lphsf, short sAdjust );
#endif

/* Opens a secure file for reading or writing.  Mode must be AWFS_READ or
   AWFS_WRITE.  Returns 0 for success, non-zero on failure.  Fills in hopense
   with a secure file handle on success.  Space for hopensec must be allocated
   by the caller.  Opening the file for write should happen only once.  Once
   the file has been closed from writing, it should never be opened for writing
   again.  A file can be opened for reading multiple times.  The file should
   be created with SecCreateFile before it is opened for writing. */
WORD WINAPI SecOpenFile(hSecureFile FAR *hsec,
			    hOpenSecureFile FAR *hopensec, WORD mode);

/* Closes a secure file which has been opened by SecOpenFile.  Returns 0 for
   success, non-zero for failure. */
WORD WINAPI SecCloseFile(hOpenSecureFile FAR *hopensec);

/* Flushes a secure file which has been opened by SecOpenFile.  Returns 0 for
   success, non-zero for failure. */
WORD WINAPI SecFlushFile(hOpenSecureFile FAR *hopensec);

/* Flushes all reference counts to disk.  Returns 0 for success, non-zero for
   failure. */
WORD WINAPI SecFlushCache(void);

/* Reads from a secure file.  This will read up to bufsize bytes from the file
   into buf.  Buf should, therefore, be at least bufsize bytes big.  The
   hopensec should be obtained from calling SecOpenFile with mode equal to
   AWFS_READ.  The number of bytes read is returned, with 0 meaning end of
   file, and AWFS_BADREAD meaning a read error occurred. */
WORD WINAPI SecReadFile(hOpenSecureFile FAR *hopensec, LPVOID buf,
			    WORD bufsize);

/* Writes to a secure file.  hopensec should be obtained from SecOpenFile with
   the mode set to AWFS_WRITE.  bufsize bytes are written from buf.  The number
   of bytes written is returned on success.  AWFS_BADWRITE is returned on
   failure.  The buffer passed in will be returned intact, but will be modified
   along the way, so it cannot be a shared copy of a buffer */
WORD WINAPI SecWriteFile(hOpenSecureFile FAR *hopensec, LPVOID buf,
			     WORD bufsize);

/* Seeks to position pos in hOpenSecFile for either writing or reading.  Type
   can be AWFS_SEEK_BEG for seeking to pos bytes from the start of the file,
   AWFS_SEEK_CUR for seeking to pos bytes from the current position, and
   AWFS_SEEK_END for pos bytes from the end of the file.  SecSeekFile returns
   the new position in bytes from the beginning of the file, or AWFS_BADSEEK.*/
DWORD WINAPI SecSeekFile(hOpenSecureFile FAR *hopensec, long pos,
			     WORD type);

/* Private MAPI API's */

typedef WORD CALLBACK RefCallback(hSecureFile FAR *lphSecFile);
void WINAPI SecReinitRefCount(RefCallback *lpfnRefCB);

BOOL WINAPI RegisterSecFile(hSecureFile FAR *lphSecFile); // unexported
BOOL WINAPI UnRegisterSecFile(hSecureFile FAR *lphSecFile); // unexported

#ifdef IFAX11
void WINAPI SecResetRefCount ( LPFILELINK lpFileLink );
#endif


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __AWFILE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awlzrd.h ===
// Copyright (c) Microsoft Corp. 1994-95
/*==============================================================================
Simple interface to file (de)compression.

DATE				NAME			COMMENTS
07-Nov-94   RajeevD   Created.
==============================================================================*/
#ifndef _AWLZRD_
#define _AWLZRD_

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
ConvertFile
(
	LPSTR lpszIn,     // input filename, OLE stream, or IFAX file key
	LPSTR lpszOut,    // output filename, must be created by caller
	UINT  cbHeader,   // header size to be copied w/o compression
	UINT  nCompress,  // conversion type {AW_COMPRESS, AW_DECOMPRESS}
	UINT  vCompress   // compress level, must be 1
);

// conversion types
#define AW_COMPRESS   0
#define AW_DECOMPRESS 1

BOOL
WINAPI
LZDecode
(
	LPVOID   lpContext, 
	LPBUFFER lpbufPrev, // previous output buffer    
	LPBUFFER lpbufCurr, // current output buffer
	LPBUFFER lpbufLZ    // LZ input buffer
);

BOOL
WINAPI
LZEncode
(
	LPVOID   lpContext,
	LPBUFFER lpbufPrev, // previous input buffer    
	LPBUFFER lpbufCurr, // current input buffer
	LPBUFFER lpbufLZ    // LZ output buffer
);

#ifdef __cplusplus
} // extern "C" 
#endif

#endif // _AWLZRD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awhelp.h ===
/**********************************************************************\
* awhelp.h
*
* At Work(TM) Help System Include File  
*
* Copyright (C) 1994. Microsoft Corporation.  All rights reserved. 
*
\**********************************************************************/

/*********************** Version ******************************/

#define AWHELP_VERSION	0x00010000	// At Work Help Version 1.00

/************************ Types *******************************/

typedef struct awsubjectinfo 
{
	DWORD  dwID;
	DWORD  dwAttributes;
	DWORD  dwTitle;
	DWORD  dwMessage;
	DWORD  dwBitmap;
	DWORD  dwIcon;
	DWORD  dwInfo;
	DWORD  dwRes1;
	DWORD  dwRes2;
} HELPSUBJECTINFO,FAR *LPHELPSUBJECTINFO;

/*** Attributes when Adding Folders: ***/

#define AWHELPF_HIDDEN		0x80000000
#define AWHELPF_INACTIVE	0x40000000
#define AWHELPF_LARGEMSGS	0x20000000

/****************** General Error Messages **********************/

#define AWHELP_NOERROR		0
#define AWHELP_ERROR		1
#define AWHELP_INVALIDPARAM	2
#define AWHELP_INVALIDFOLDER	3
#define AWHELP_INVALIDTOPIC	4
#define AWHELP_INUSE		5
#define AWHELP_OUTOFMEMORY	6

/********************* Public Routines **************************/

/***** Enabling / Disabling Help *****/

VOID FAR PASCAL Enable(void);
VOID FAR PASCAL Disable(void);


/***** Displaying Help *****/

DWORD FAR PASCAL _loadds AtWorkHelpDisplay(HWND hWnd, DWORD dwSubjectID, DWORD dwData);


/***** Customizing Help ****/

DWORD FAR PASCAL _loadds AtWorkHelpAddSubject(DWORD		dwAction,
					      LPHELPSUBJECTINFO lpFolder,
				              LPHELPSUBJECTINFO lpTopic);
#ifdef PHOENIX
/***** Querying Status of Help ****/
BOOL FAR PASCAL _loadds AtWorkIsHelpActiveWindow();
#endif /* PHOENIX */

/** Flags for dwAction parameter: **/

#define AWHELP_GETVERSION		0
#define AWHELP_MODIFYATTR		1
#define AWHELP_REGINFOFOLDER		2
#define AWHELP_UNREGINFOFOLDER		3
#define AWHELP_DISMISS			4

/* (eof) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awkkc.h ===
/*****************************************************************************/
/*                               A W K K C . H                               */
/*                      Copyright (C) 1994 Mictosoft.                        */
/*                                                                           */
/*                    This header file is used IFAX IME                      */
/*****************************************************************************/

#define IR_OPENCANDIDATE       0x190 //
#define IR_CHANGECANDIDATE     0x191 //
#define IR_CLOSECANDIDATE      0x192 //

#define IME_CAND_READ          1     //
#define IME_SETACTIVECANDIDATE 0x60  // wParam = Cadidate string index.(1+)

#define INPUT_MODE_WINDOW      100   // IFAX IME private function
#define KOHO_LIST_WINDOW       101   // IFAX IME private function
#define CANDIDATE_STRING       102   // IFAX IME private function

typedef struct _tagCANDIDATELIST {
    DWORD   dwSize;             // Size of this data structure.
    DWORD   dwStyle;            // Style of candidate strings.
    DWORD   dwNumCandStr;               // Number of candidate strings.
    DWORD   dwSelectedCand;     // Index of a candidate string now selected.
    DWORD   dwPreferNumPerPage; // NOT USE!
    DWORD   dwCandStrOffset[];  // Candidate string offset.
//  CHAR    chCandidateStr[];   // Candidate string.This must be ASCIIZ string.
} CANDIDATELIST, FAR *LPCANDIDATELIST;


/* ----------------------------------------------------------------------------
   wParam of SKM_IMESETOPEN message that is sent to ScreenKbdWndProc
   ------------------------------------------------------------------------- */
#define  KANA_CLOSE_IME     0
#define  KANA_OPEN_IME      1
#define  KANA_GYO_INDEX     2
#define  KANA_SEND_BS       3
#define  KANA_CONV_TBL      4
#define  KANA_OLD_TBL       5
#define  KANA_LB_HWND       6
#define  KANA_CNAGE_CONV    7

#define  FLUSH_UNDET        1
#define  FLUSH_UNDET_L      1L

#define NUM_GYO_INDEX       10
#define KANA_CLOSE_KAKUTEI  11
#define  KANA_CLOSE_CONV    12
#define  KANA_SEND_CLEAR    13
#define  KANA_SET_LB        14
#define  KANA_SEND_VK       15
#define  KANA_MOVE_CONV     16
#define  GET_KANA_GYO_INDEX 17
#define  GET_NUM_GYO_INDEX  18
#define  SET_KBD_OPENIME    19
#define  GET_KBD_OPENIME    20
#define  SET_KANA_SHIFT     21
#define  GET_KANA_SHIFT     22
#define  KANA_CLEAR_CONV    23
#define  KANA_SET_INIT      24

/* ----------------------------------------------------------------------------
   { left, top, right, bottom } for KANA Keypads
   ------------------------------------------------------------------------- */
#define ltrb_abc2            252,67,281,92
#define ltrb_number2         281,67,311,92
#define ltrb_kigou2           65,67, 94,92
#define ltrb_sh_kana2          6,67, 36,92
#define ltrb_w_kakute        210,67,249,92
#define ltrb_sh_hira2         36,67, 65,92
#define ltrb_1_1        6, 7, 32,32
#define ltrb_1_2       37, 7, 63,32
#define ltrb_1_3       68, 7, 94,32
#define ltrb_1_4       99, 7,125,32
#define ltrb_1_5      130, 7,156,32
#define ltrb_1_6      161, 7,187,32
#define ltrb_1_7      192, 7,218,32
#define ltrb_1_8      223, 7,249,32
#define ltrb_1_9      254, 7,280,32
#define ltrb_1_10     285, 7,311,32
#define ltrb_2_1        6,37, 32,62
#define ltrb_2_2       37,37, 63,62
#define ltrb_2_3       68,37, 94,62
#define ltrb_2_4       99,37,125,62
#define ltrb_2_5      130,37,156,62
#define ltrb_2_6      161,37,187,62
#define ltrb_2_7      192,37,218,62
#define ltrb_2_8      223,37,249,62
#define ltrb_2_9      254,37,280,62
#define ltrb_2_10     285,37,311,62


#define ltrb_kakute2  208,4,249,29
#define ltrb_henkan2  153,4,203,29
#define ltrb_zenkou2  99, 4,148,29
#define ltrb_katakana2 20,200,35,230
#define ltrb_hiragana2 40,200,55,230
#define ltrb_han_kana2 60,200,75,230
#define ltrb_bunsetsu2 80,200,95,230
/**** Bellow xxx1 is old define . this is a save ****/
/**** xxx2 is new define  *******************/

#define ltrb_abc3            252,4,281,29
#define ltrb_number3         281,4,311,29
#define ltrb_kigou3           65,4, 94,29
#define ltrb_sh_kana3          6,4, 36,29
#define ltrb_sh_hira3         36,4, 65,29
#define       ltrb_NumZen_1 79+25, 2,  119+25,  27
#define       ltrb_NumZen_2 125+25, 2,  165+25,  27
#define       ltrb_NumZen_3 171+25, 2,  211+25,  27
#define       ltrb_NumZen_4 79+25, 32, 119+25,  57
#define       ltrb_NumZen_5 125+25, 32, 165+25,  57
#define       ltrb_NumZen_6 171+25, 32, 211+25,  57
#define       ltrb_NumZen_7 79+25, 62, 119+25,  87
#define       ltrb_NumZen_8 125+25, 62, 165+25,  87
#define       ltrb_NumZen_9 171+25, 62, 211+25,  87
#define       ltrb_NumZen_0 125+25, 92, 165+25, 117
#define       ltrb_NumZen_ast 79+25, 92, 119+25, 117
#define       ltrb_NumZen_shp 171+25, 92, 211+25, 117
#define       ltrb_NumZen_prl 37, 2, 63,  27
#define       ltrb_NumZen_prr 69,  2, 95,  27
#define       ltrb_NumZen_unv 6,  2, 32,  27
#define       ltrb_NumZen_atm 6, 32, 32,  57
#define       ltrb_NumZen_plus 252, 32-30, 281,  57-30
#define       ltrb_NumZen_min 37+249-3, 32-30, 3+63+249-3,  57-30
#define       ltrb_NumZen_paus 37, 32, 95,  57
#define       ltrb_NumZen_henk 6, 92-30, 63+32, 117-30
#define       ltrb_NumZen_kaku 252, 62, 252+41, 87
#define       ltrb_NumZen_zen  252, 32, 281,  57
/* ----------------------------------------------------------------------------
   key code to recognize ( if it's same as other VK key, change followings )
   --------------------------------------------------------------------------*/
#define vENT_key     0x454e                 // for KAKUTE key : "en"
#define vSP_key      0x5350                 // for HENKAN key : "sp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awg3file.h ===
#ifndef _AWG3FILE_
#define _AWG3FILE_

/********************************************************************

    @doc    EXTERNAL SRVRDLL LINEARIZER

    @type   VOID | AWG3 File Format |
            
            An AWG3 file can be used to describe any
            multi page image encoded using a CCITT G3 standard like
            MH, MR, or MMR.

            The file format is a special case of the Microsoft Fax Linearized
			format. It consists of a LINHEADER structure, followed by
			an extended linearized header, followed by the image data.
			The image data is specified as one or more headers, each followed
            by a page of encoded image data. Each header starts a
            new page. The file is terminated with a header containing
            a special end-of-file signature marker.

			Linearizer helper function CreateSimpleHeader  should be used to
			write the LINHEADER and extended linearized header when creating
			an AWG3 file.

			Linearizer helper function DiscardLinHeader  should be used to
			skip past the LINHEADER and extended linearized header when
			reading the AWG3 file.

            The page header format is defined by the structure <t AWG3HEADER>.
            The data for each page consists of one or more frames.
			A frame consists of  a DWORD indicating the length of data in
			the frame followed by that many bytes of data. The last
			frame of each page must be of zero length and indicates
			the end of the page data.
			The data consists of raw MH, MR, or MMR, encoded so that the
			least significant bit of each byte should be sent first over
			the wire.

    @xref   <t AWG3HEADER>

********************************************************************/

/********
    @doc    EXTERNAL SRVRDLL LINEARIZER

    @types  AWG3HEADER | Describes the Header Structure for an AWG3 File.

    @field  WORD    | wSig  | Must be SIG_G3 for the page headers, and
            SIG_ENDFILE for the end of file header.

    @field  WORD    | wHeaderSize | Must be set to the size of the header
            structure. Used for version control.

    @field  WORD    | wTotalHeaders | If non-zero, this indicates the total
            number of and headers (including the end-of-file header)
			in this file. This need only be set in the first header.
			If zero, the total number of headers is not specified directly and
			can be obtained by traversing the headers in the file (until
			the end-of-file header).

    @field  WORD    | wHeaderNum | Gives the ordinal number for this 
            header. Must be set for all headers. Numbering starts at 1.

    @field  DWORD   | lDataOffset   | Gives the offset from the beginning
            of the current header to the start of the first frame
			of the data for this page. 
            Must always be set. 

    @field  DWORD   | lNextHeaderOffset | Gives the offset from the start of the
            current header to where the header for the next page can be found. If this
            is set to 0, the next header starts at the end of the
            last frame (which will be a null frame) for this page. 

    @field  DWORD | AwRes | One of the standard resolution defines 
            specified in <t STD_RESOLUTIONS>.

    @field  DWORD | Encoding | One of the G3 Fax types from the
            standard types defined in <t STD_DATA_TYPES>. Basically one
            of MH_DATA, MR_DATA, or MMR_DATA.

    @field  DWORD | PageWidth | One of the standard page widths as defined in
            <t STD_PAGE_WIDTHS>.

    @field  DWORD | PageLength | One of the standard page lengths as defined in
            <t STD_PAGE_LENGTHS>.

    @xref   <t AWG3 File Format>
********/    

#define	SIG_G3		0x3347
#define SIG_ENDFILE 0x4067

#ifndef WIN16		// remove WIN16 irritation
#pragma pack(push)
#endif

#pragma pack(1)
typedef struct {
	WORD	wSig;		  	// always set to one of the above SIG_ #defines
	WORD	wHeaderSize;  	// always set
  WORD    wTotalHeaders;	// can be 0
	WORD	wHeaderNum;		// starts from 1
    // 8 bytes

								// all offsets from start of _this_header_
	DWORD	lDataOffset;		// always set. points to the first frame-size DWORD
	DWORD	lNextHeaderOffset;	// may be NULL--then next header follows end of data 
    // 16 bytes

	DWORD   AwRes;			// as per AWRES_ defines below. DIFFERENT from Snowball
	DWORD   Encoding;		// as per _DATA defines below. Same as Snowball
	DWORD   PageWidth;		// as per WIDTH_ defines below. Same as Snowball
	DWORD   PageLength;		// as per LENGTH_ defines below. Same as SNowball
    // 32 bytes

	BYTE	Reserved1[32];	// pad out to 64 bytes for future expansion
} AWG3HEADER, far* LPAWG3HEADER;

#ifdef WIN16		// remove WIN16 irritation
#pragma pack()
#else
#pragma pack(pop)
#endif



// Standard Bit Valued MetaData values
#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L


// Standard Resolutions
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_75_75             0x00000800L
#define AWRES_100_100           0x00001000L

/********
    @doc    EXTERNAL  DATATYPES  SRVRDLL

    @type   WORD | STD_PAGE_LENGTHS | Standard Page Lengths

    @emem   LENGTH_A4 | Std A4 paper length, Value: 0
    @emem   LENGTH_B4 | Std B4 paper length, Value: 1
    @emem   LENGTH_UNLIMITED | Unknown length, Value: 2

    @comm   These lengths are compatible with those defined
            by the CCITT for G3 machines. They are used
            in fax format headers, and in structures dealing
            with fax machine capabilities.
********/   

// Length defines
#define LENGTH_A4			0	
#define LENGTH_B4			1	
#define LENGTH_UNLIMITED	2


/********
    @doc    EXTERNAL  DATATYPES  SRVRDLL

    @type   WORD | STD_PAGE_WIDTHS | Standard Page Widths

    @emem   WIDTH_A4 |1728 pixels, Value: 0
    @emem   WIDTH_B4 |2048 pixels, Value: 1
    @emem   WIDTH_A3 |2432 pixels, Value: 2
    @emem   WIDTH_A5 |1216 pixels, Value: 16
    @emem   WIDTH_A6 |864 pixels, Value: 32

    @comm   These widths are compatible with those defined
            by the CCITT for G3 machines. They are used
            in fax format headers, and in structures dealing
            with fax machine capabilities.
********/   

//Width defines
#define WIDTH_A4	0	/* 1728 pixels */
#define WIDTH_B4	1	/* 2048 pixels */
#define WIDTH_A3	2	/* 2432 pixels */
#define WIDTH_MAX	WIDTH_A3

#define WIDTH_A5		16 	/* 1216 pixels */
#define WIDTH_A6		32	/* 864 pixels  */
#define WIDTH_A5_1728	64 	/* 1216 pixels */
#define WIDTH_A6_1728	128	/* 864 pixels  */

#endif // _AWG3FILE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awnetfax.h ===
//--------------------------------------------------------------------------
//
// Module Name:  AWNETFAX.H
//
// Brief Description:  This module contains declarations for the At Work
//                     Fax Net Fax.
//
// Author:  Kent Settle (kentse)
// Created: 13-Sep-1994
//
// Copyright (c) 1994 Microsoft Corporation
//
//--------------------------------------------------------------------------
#ifndef _AWNETFAX_H_
#define _AWNETFAX_H_

#ifndef LPTSTR
#ifdef UNICODE
typedef LPWSTR PTSTR, LPTSTR;
#else
typedef LPSTR PTSTR, LPTSTR;
#endif
#endif

typedef struct _SERVERCHEAPTIME {
    SYSTEMTIME      stStart;
    SYSTEMTIME      stEnd;
} SERVERCHEAPTIME, FAR *LPSERVERCHEAPTIME;


//--------------------------------------------------------------------------
// BOOL NetInitServer(LPTSTR lpstrTransportDir, LPTSTR lpstrSharedDir,
//                    LPTSTR lpstrPhoneNumber, LPTSTR lpstrModemName,
//                    LPMODEMCAPS lpModemCaps, LPTSTR lpstrDefRecipAddr,
//                    LPTSTR lpstrDefRecipName)
//
// This function is called to initialize the server machine.
//
// Parameters
//   lpstrTransportDir  Pointer to string specifying the directory where our
//                      MAPI transport will be placing it's files.
//
//   lpstrSharedDir     Pointer to string specifying the directory which
//                      has been shared.  This is the directory into which
//                      all the server status files will be placed.  This is
//                      also the directory into which the client will be
//                      looking.
//
//   lpstrPhoneNumber   Pointer to string specifying modem's phone number.
//
//   lpstrModemName     Pointer to string specifying modem's name.
//
//   lpModemCaps        Pointer to MODEMCAPS structure.
//
//   lpstrDefRecipAddr  Pointer to string specifying default recipient addr.
//
//   lpstrDefRecipName  Pointer to string specifying default recipeint name.
//
// Returns
//   This function returns TRUE for success, FALSE otherwise.
//
// History:
//   14-Jul-1994    -by-    Kent Settle     (kentse)
// Cleaned up.
//--------------------------------------------------------------------------

extern BOOL NetInitServer(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPMODEMCAPS,
                          LPTSTR, LPTSTR, SERVERCHEAPTIME *);

//--------------------------------------------------------------------------
// BOOL NetDeinitServer(VOID)
//
// This function is called to deinitialize the server machine.
//
// Parameters
//   None.
//
// Returns
//   This function returns TRUE for success, FALSE otherwise.
//
// History:
//   14-Jul-1994    -by-    Kent Settle     (kentse)
// Cleaned up.
//--------------------------------------------------------------------------

extern BOOL NetDeinitServer(VOID);

#endif // _AWNETFAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awnsfapi.h ===
/***************************************************************************
 Name     :     AWNSFAPI.H
 Comment  :     Definitions of the AtWork AWBC (Basicaps) structure which is the
            decrypted/decooded/reformatted form of the At Work NSF and NSC
            Also the decrypted form of the At Work NSS
            Also defines the APIs for encoding/decoding AtWork NSF/NSC/NSS

     Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Created
***************************************************************************/

#ifndef _AWNSFAPI_H
#define _AWNSFAPI_H


/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#ifdef PORTABLE    /** -DPORTABLE on machines with flat 32-bit model **/
#ifdef STDCALL
#   define WINAPI       __stdcall
#   define EXPORTAWBC   __stdcall
#else
#       define WINAPI
#       define EXPORTAWBC
#endif
#       define FAR
#       define NEAR
#       define PASCAL
#   define CALLBACK
#       define __export
#       define _export
#       define max(a, b)        (((a) > (b)) ? (a) : (b))
        typedef short    BOOL;
#elif defined(WIN32) /** WIN32 **/
#       define __export  __declspec( dllexport )
#       define _export  __declspec( dllexport )
#       define EXPORTAWBC        WINAPI
#else /** 16bit Windows */
#       define FAR       _far
#       define NEAR              _near
#       define PASCAL    _pascal
#       define WINAPI    _far _pascal
#   define CALLBACK  _far _pascal
#       define EXPORTAWBC       _export WINAPI
        typedef int      BOOL;
#endif /** Portable, WIN32 or WIN16 **/

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;
typedef unsigned short  USHORT;
typedef BYTE FAR*               LPBYTE;
typedef WORD FAR*               LPWORD;


#include <fr.h>

#pragma pack(2)    /** ensure packing is portable, i.e. 2 or more **/





typedef enum {
        BC_NONE = 0,
    SEND_CAPS,      /** Used to derive an NSF to send **/
    RECV_CAPS,      /** Derived from a received NSF   **/
    SEND_PARAMS,    /** Used to derive an NSS to send **/
    RECV_PARAMS,    /** Derived from a received NSS   **/
    SEND_POLLREQ,   /** Used to derive a NSC to send  **/
    RECV_POLLREQ,    /** Derived from a receive NSC    **/

        SEND_ACK,
        RECV_ACK,
        SEND_DISCONNECT,
        RECV_DISCONNECT

} BCTYPE;

#define BCTYPE_FIRST    RECV_CAPS
#define BCTYPE_LAST     RECV_POLLREQ





#define MAXTOTALIDLEN           61
#define MAXNSCPOLLREQ           5

#ifndef NOCHALL
#       define POLL_CHALLENGE_LEN       10
#       define POLL_PASSWORD_LEN        20
#endif

#define MAXNSFFRAMESIZE         256     /* MAW NSx frames must be 255 bytes or less */
#define MAXFIRSTNSFSIZE         38  /* The first transmitted MAW NSx frame must
                                                                        be 38 bytes or less */
#define MAXNEXTNSFSIZE          70  /* subsequent transmitted MAW NSx frame must
                                                                        be 72 bytes or less */
#define MAXNSFFRAMES            (MAXNSCPOLLREQ+5)


typedef struct
{
        WORD PollType;          /* one of the POLLTYPE_ defines below */
        WORD fReturnControl;    /* T or F */
        WORD PassType;
        WORD wNameLen;
        BYTE bName[MAXTOTALIDLEN+3];    /* align on even boundary */

#ifdef NOCHALL
        WORD wPassLen;
        BYTE bPass[MAXTOTALIDLEN+3];    /* align on even boundary */
#else
        WORD wChallRespLen;
        BYTE bChallResp[max(POLL_PASSWORD_LEN, POLL_CHALLENGE_LEN)+2];
#endif
}
AWBCPOLLREQ, FAR* LPAWBCPOLLREQ;

typedef struct
{
  BCTYPE bctype;    /* must always be set. One of the enum values above    */
  WORD   wAWBCSize; /* size of this (fixed size) AWBC struct, must be set  */
  WORD   wAWBCVer;  /* if using this header file, set it to VER_AWFXPROT100*/
  WORD   wAWBCSig;  /* Clients must set to SIG_AWFXPROT in struct passed in
                        to the NSF encoding/decoding routines. In Structs
                        returned from these routines this will be 0         */

  BYTE  vMsgProtocol;  /* 00==Doesn't accept linearized msgs. vMSG_SNOW==
                           Current (WFW) version of linearizer. For NSS, ver
                           of linearized msg, if any, following the NSS-DCS */
  BYTE  fInwardRouting;/* 00==no inward routing                            */
  BYTE  fBinaryData;   /* accept binary files inside linearized msgs       */
  BYTE  vMsgCompress;  /* 00==none                                              */
  BYTE  fDontCache;    /* 1=NSF/DIS caps of this machine should _not_ be cached (see long note above)*/

  BYTE  DataLink;      /* Data-link protocols. 000==none                   */
  BYTE  DataSpeed;     /* Data modem modulations/speeds. 00000==none       */
  BYTE  vShortFlags;   /* 00==not supported                                */

  BYTE  OperatingSys;  /* OS_WIN16==16bit Windows(Win3.1, WFW etc)         */
                       /* OS_ARADOR==AtWork based OSs (IFAX etc)           */
                       /* OS_WIN32== WIN32 OSs (NT, WIN95)                      */
  BYTE  vSecurity;     /* 00==none vSECURE_SNOW==snowball security         */
  BYTE  vInteractive;  /* 00==No interactive protocol support              */

  BYTE  TextEncoding;  /* Text code. TEXTCODE_ASCII==ascii    */
  BYTE  TextIdLen;     /* Text ID length                                        */
  BYTE  Reserved1;         /* Pad to even boundary before array */

  BYTE  bTextId[MAXTOTALIDLEN+3];   /* zero-terminated                     */
  BYTE  bMachineId[MAXTOTALIDLEN+3];/* machine ID                          */

  BYTE  MachineIdLen;               /* length of machine id                */

  BYTE  vRamboVer;     /* Rambo: 00==not supported                         */
  BYTE  vAddrAttach;   /* 00==cannot accept address bk attachmnts          */
  BYTE  fAnyWidth;     /* page pixel widths don't have to be exactly T.4   */
  BYTE  HiEncoding;    /* one or more of the HENCODE_ #defines below       */
  BYTE  HiResolution;  /* one or more of the HRES_ #defines below          */
  BYTE  CutSheetSizes; /* one or more of the PSIZE_ #defines below         */
  BYTE  fOddCutSheet;  /* Cut-sheet sizes other than ones listed below     */
  BYTE  vMetaFile;     /* 00==metafiles not accepted                       */
  BYTE  vCoverAttach;  /* 00==no digital cover page renderer               */

  BYTE  fLowSpeedPoll;  /* SEP/PWD/NSC poll reqs accepted                  */
  BYTE  fHighSpeedPoll; /* PhaseC pollreqs accepted                        */
                        /* if both the above 00, poll reqs not accepted    */
  BYTE  fFilePolling;   /* Supports polling for arbitrary files            */
  BYTE  fPollByRecipAvail; /* Poll-by-Recipient msgs available             */
  BYTE  fPollByNameAvail;  /* Poll-by-MessageName msgs available           */

  BYTE  fExtCapsAvail;  /* Extended capabiities available                  */
  BYTE  fNoShortTurn;   /* NOT OK recving NSC-DTC immediately after EOM-MCF*/
  BYTE  vMsgRelay;      /* Msg relay ver. 0==no support                    */

  WORD  ExtCapsCRC;     /* CRC of machine's extended capabilities          */

  struct {
    BYTE    vMsgProtocol;  /* non-zero: linearized msg follows           */
                           /* vMSG_SNOW current linearized format        */
    BYTE    vInteractive;  /* non-zero: Interactive prot being invoked   */
  }
  NSS;

  WORD wNumPollReq;                                     /* number of poll reqs */
  AWBCPOLLREQ rgPollReq[MAXNSCPOLLREQ]; /* array of AWBCPOLLREQ structures */
}
AWBC, FAR* LPAWBC, NEAR* NPAWBC;


/** Appropriate values for some of the above fields **/

#define vMSG_SNOW       1       /* Snowball Linearizer version */
#define vMSG_IFAX100    2       /* IFAX linearizer version */
#define vSECURE_SNOW    1       /* vSecurity for Snowball (v1.00 of MAW)         */
#define OS_WIN16        0       /* OperatingSys for Win3.0, 3.1, WFW3.1, 3.11*/
#define OS_ARADOR       1       /* OperatingSys for Arador-based systems         */
#define OS_WIN32                2       /* OperatingsSys for WIN32 (NT, WIN95)       */
#define TEXTCODE_ASCII  0       /* TextEncoding for 7-bit ASCII                          */


#define SIG_AWFXPROT    0xYYYY
#define VER_AWFXPROT100 0x100



extern BOOL WINAPI IsAtWorkNSx(LPBYTE lpb, WORD wSize);



extern WORD _export WINAPI AWBCtoNSx(IFR ifr, LPAWBC lpawbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);



extern WORD _export WINAPI NSxtoAWBC(IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                                        LPAWBC lpawbcOut, WORD wAWBCSize);


extern void _export WINAPI MaskAWBC(LPAWBC lpawbc, WORD wSize);



#define AWERROR_OK                0
#define AWERROR_BCTYPE            1
#define AWERROR_SIG               2
#define AWERROR_NOSPACE           3
#define AWERROR_NOTAWFRAME        4
#define AWERROR_NULLFRAME         5
#define AWERROR_VERSION           6
#define AWERROR_INVALIDBC         7

#pragma pack()

#endif /** _AWNSFAPI_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awnsfcor.h ===
/***************************************************************************
 Name     :	AWNSFCOR.H
 Comment  :	NSF related definitions that _must_ be kept the same.
			EVERYTHING in this file affects what is sent across the
			wire. For full compatibility with all versions of Microsoft
			At Work NSFs, _nothing_ in here should be changed.

			The NSF protocol can be extended by adding new groups
			and by appending fields at the end of existing groups.

			Interfaces, structures and constants that only affect one
			machine (i.e. not what is on the wire) should not be in
			this file


	Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 12/31/93 arulm Created this. Verified in matches Snowball.rc
***************************************************************************/

#ifndef _AWNSFCOR_H
#define _AWNSFCOR_H

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


/** Microsoft At Work NSF signature **/

#define SIG_USA            0xB5		/** defiend by CCITT 		**/
#define SIG_ATWORK1        0x00		/** 00--first (low) byte	**/
#define SIG_ATWORK2        0x76		/** 76--second (high) byte	**/


#define MAXNSCPOLLREQ			5

#ifndef NOCHALL
#	define POLL_CHALLENGE_LEN	10
#endif 


/** NSF Group Numbers. Cant have duplicates. Max 5 bits. **/

#define GROUPNUM_FIRST		1
#define GROUPNUM_STD		1
#define GROUPNUM_POLLCAPS	2
#define GROUPNUM_POLLREQ	3
#define GROUPNUM_IMAGE 		4
#define GROUPNUM_TEXTID		5
#define GROUPNUM_MACHINEID	6
#define GROUPNUM_NSS		7
#define GROUPNUM_LAST		7



#ifndef PORTABLE /* Microsoft C only */

#pragma pack(1)    /** MUST ensure packed structures here **/

// Note that all these structures have a fixed size (as defined here)
// in memory, but a variable size when encoded in the NSF on the wire
// During transmission, only the smallest non-zero prefix of each 
// capability group is sent. For example if the STD group is
// zero from the 7th byte onward, only 6 bytes are sent.
//
// Similarly strings that are variable length on the wire are fixed 
// length in the in-memory structures, for ease of manipulation

typedef struct
{
	WORD	GroupLength	:6;
	WORD	GroupNum	:5;
	WORD	Reserved	:5;
}
BCHDR, near* NPBCHDR, far* LPBCHDR;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCSTD | Standard Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCSTD).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_STD.

	@field BITFIELD | vMsgProtocol | Linearizer version. Set to 0 if linearized
			messages are not accepted. Set to vMSG_SNOW if using
			Snowball/WFW3.11 linearizer/delinearizer. Set to vMSG_IFAX if
			using IFAX release 1.00 linearizer/delinearizer.

	@field BITFIELD | fBinaryData | Set to 1 if binary files are accepted
			inside linearized messages. Otherwise set to 0. (Currently
			must set to 1 if vMsgProtocol is non-zero).

	@field BITFIELD | fInwardRouting | Currently set to 0
	@field BITFIELD | vSecurity		 | Set to vSECURE_SNOW if using Snowball/WFW3.11
			version of linearized message security

	@field BITFIELD | vMsgCompress	 | Currently set to 0
	@field BITFIELD | fDontCache	 | If this is set, the DIS & NSF capabilities
		   should not be cached, because they are not constant. This will
		   be set, for example, in machines that are part of a "hunt group"
		   i.e. a poll of fax possibly heterogenous machines connected to
		   multiple lines on a single inward-dial number. When a call comes
		   in any random available machine is assigned the call. If the
		   machines are heterogenous, then callers that cache capabilities
		   will run into trouble on subsequent calls to the same number.
		   The same might be the case for numbers shared by a (say) PC with a
		   modem running the At Work protocol and a ordinary G3 fax. When the
		   PC is powered up & running, At Work features are available. When the
		   PC is shutdown the G3 fax acts as a "backup". Etc..

	@field BITFIELD | OperatingSys	 | Set to OS_WIN16 if based on 16bit Windows
			(Win3.1 or earlier, WFW3.1, WFW3.11 etc).  OS_WIN32 if based on
			WIN32 API (NT and WIN95). OS_ARADOR if based on the AT Work
			device OSs. Values for non-Microsoft OSs TBD.
			Please contact Microsoft if you need this.

	@field BITFIELD | vShortFlags	 | Currently set to 0	
	@field BITFIELD | vInteractive	 | Currently set to 0
	@field BITFIELD | DataSpeed		 | Currently set to 0
	@field BITFIELD | DataLink		 | Currently set to 0

	@xref <t BC> 
********/

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_STD
	WORD	vMsgProtocol	:3;	// 00==Doesnt accept linearized msgs
								// vMSG_SNOW==Current (WFW) version of linearizer
	WORD	fBinaryData		:1;	// accept binary files inside linearized msgs
	WORD	fInwardRouting	:1;	// 00==no inward routing
//2bytes
	BYTE	vSecurity		:3;	// 00==none vSECURE_SNOW==snowball security
	BYTE	vMsgCompress	:2;	// 00==none
	BYTE	fDontCache		:1;	// 1=DIS/NSF caps should not be cached!!
	BYTE	Reserved		:2;
//3bytes
	BYTE	OperatingSys	:3;	// OS_WIN16==16bit Windows(Win3.1, WFW etc)
								// OS_ARADOR==AtWork based OSs (IFAX etc)
								// OS_WIN32== WIN32 OSs (NT, WIN95)
	BYTE	vShortFlags		:2;	// 00==not supported
	BYTE	vInteractive	:3;	// 00==No interactive protocol support
//4bytes
	BYTE	DataSpeed		:5;	//Data modem modulations/speeds. 00000==none
	BYTE	DataLink 		:3;	//Data-link protocols. 000==none
//5bytes
}
BCSTD, near* NPBCSTD, far* LPBCSTD;

typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// must be GROUPNUM_TEXTID
	WORD	TextEncoding:5;	// Text code. TEXTCODE_ASCII==ascii
//2bytes
	BYTE	bTextId[MAXTOTALIDLEN+2];	// zero-terminated
}
BCTEXTID, near* NPBCTEXTID, far* LPBCTEXTID;


typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// must be GROUPNUM_MACHINEID
	WORD	Reserved	:5;	
//2bytes
	BYTE	bMachineId[MAXTOTALIDLEN+2];	// machine ID
}
BCMACHINEID, near* NPBCMACHINEID, far* LPBCMACHINEID;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCIMAGE | Image Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCIMAGE).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_IMAGE.

	@field BITFIELD | fAnyWidth	| Currently set to 0.
	@field BITFIELD | vRamboVer	| At Work Resource-based rendering technology
			(a.k.a. Rambo) version number. Set to 0 if Rambo format is not
			supported. Set to vRAMBO_VER1 if using IFAX release 1.00 Rambo
			rasterizer.

	@field BITFIELD | vCoverAttach | Currently set to 0.
	@field BITFIELD | vAddrAttach  | Currently set to 0.
	@field BITFIELD | vMetaFile	   | Currently set to 0.
	@field BITFIELD | HiResolution | Currently set to 0.
	@field BITFIELD | HiEncoding   | Currently set to 0.	 
	@field BITFIELD | CutSheetSizes| Currently set to 0.
	@field BITFIELD | fOddCutSheet | Currently set to 0.

	@xref <t BC> 
********/

typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// group number--must be GROUPNUM_IMAGE
	WORD	fAnyWidth	:1;	// page pixel widths dont have to be exactly T.4
	WORD	vRamboVer	:4;	// Rambo: 00==not supported
//2bytes

	BYTE	vCoverAttach:3;	// 00==no digital cover page renderer
	BYTE	vAddrAttach	:2;	// 00==cannot accept address bk attachmnts
	BYTE	vMetaFile	:2;	// 00==metafiles not accepted
	BYTE	Reserved1	:1;
//3bytes

	BYTE	HiResolution :4; // one or more of the HRES_ #defines below
	BYTE	HiEncoding	 :4; // one or more of the HENCODE_ #defines below
//4bytes

	BYTE	CutSheetSizes;	// one or more of the PSIZE_ #defines below
//5bytes

	BYTE	fOddCutSheet:1;	// Cut-sheet sizes other than ones listed below
							// are available. (To get list req. ext caps)
	BYTE	Reserved2	:7;
//6bytes
}
BCIMAGE, far* LPBCIMAGE, near* NPBCIMAGE;

/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCPOLLCAPS | Polling Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCPOLLCAPS).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_POLLCAPS.

	@field BITFIELD | fLowSpeedPoll	 | Set to 1 if NSC poll requests are accepted,
			and there are poll-stored messages/files available for polling.

	@field BITFIELD | fHighSpeedPoll | Set to 1 if Phase-C poll requests are
			accepted, and there are poll-stored messages/files available
			for polling.

	@field BITFIELD | fPollByNameAvail  | Set to 1 if polling for documents by
			title and optional password is supported and there are some
			such poll-stored documents available.

	@field BITFIELD | fPollByRecipAvail	| Set to 1 if polling for contents of
			a registered user's Message folder is supported and active.

	@field BITFIELD | fFilePolling 	| Set to 1 if polling for arbitrary disk
			files by path name is supported.

	@field BITFIELD | fExtCapsAvail	| Set to 1 if extended capabalities are
			supported and there are some registered extended capabilities
			available for polling. If this is non-zero, the ExtCapsCRC field
			must also be set.

	@field BITFIELD | fNoShortTurn	| Set to 1 if polling is supported, but the
			poller is required to wait for the T2 (6 sec) timeout followed
			by NSF-DIS before sending NSC-DTC. If this is 0, Pollers are
			free to send an NSC-DTC immediately after EOM-MCF.

	@field BITFIELD | vMsgRelay	 | Currently set to 0.

	@field WORD | ExtCapsCRC | Set iff fExtCapsAvail is 1. This is a
			CCITT-CRC16 of the registered extended capabailities on the
			the machine.

	@xref <t BC> 
********/
					  
typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_POLLCAPS
	WORD	fLowSpeedPoll	:1;	// SEP/PWD/NSC poll reqs accepted
	WORD	fHighSpeedPoll	:1;	// PhaseC pollreqs accepted
								// if both the above 00, poll reqs not accepted
	WORD	fPollByNameAvail :1;// Poll-by-MessageName msgs available
	WORD	fPollByRecipAvail:1;// Poll-by-Recipient msgs available
	WORD	fFilePolling 	 :1;// Supports polling for arbitrary files
//2bytes

	BYTE	fExtCapsAvail	:1;	// Extended capabiities available
	BYTE	fNoShortTurn	:1;	// NOT OK recving NSC-DTC immediately after EOM-MCF
	BYTE	vMsgRelay		:3;	// Msg relay ver. 0==no support
	BYTE	Reserved		:3;
//3bytes

	WORD	ExtCapsCRC;			// CRC of machines extended capabilities
//5bytes
}
BCPOLLCAPS, far *LPBCPOLLCAPS, near* NPBCPOLLCAPS;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCPOLLREQ | Poll Request stucture

	@field BITFIELD | GroupLength | Must be set to sizeof(BCPOLLREQ).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_POLLREQ.

	@field BITFIELD | fReturnControl | 1=return control when done 0=hangup when done
	@field BITFIELD | PollType		 | Poll type. See <t POLLTYPE> for details.
	@field BYTE		| b[]			 | Variable length name and (optionally) password.
			The exact contents and layout depends on the POLLTYPE as follows

		@flag POLLTYPE_NAMED_DOC | b[] contains a Poll Document Name. If there
			is no password, the Document Name is not null-terminated. If there
			is a password, the document name is null-terminated and followed
			by the "Poll Challenge Response" generated using the algorithm
			below.

		@flag POLLTYPE_BYRECIPNAME | b[] contains a Recipient Mailbox Address.
			If there is no password, the Mailbox Address is not null-terminated.
			If there is a password, the mailbox address is null-terminated and
			followed by the "Poll Challenge Response".

		@flag POLLTYPE_BYPATHNAME | b[] contains a file pathname. If there
			is no password, the pathname is not null-terminated. If there
			is a password, the pathname is null-terminated and followed
			by the "Poll Challenge Response".

		@flag POLLTYPE_EXTCAPS | If no password is supplied b[] is 0 length,
			otherwise b[0] is 0, and is followed by the "Poll Challenge
			Response".

		@flag POLLTYPE_DONE | b[0] is the poll error code. A code of 0 means
				success. If b[] is zero length, that is equivalent to success.

		@flag POLLTYPE_WAIT   | b[] must be 0 length
		@flag POLLTYPE_PHASEC | b[] must be 0 length

	@comm

	At Work Fax uses a Challenge-Response protocol for password
	verification during polling. The scheme used is as follows.

	On the POLLER'S side, bytes 3 to 3 + POLL_CHALLENGE_LEN of the actual
	encrypted bytes of the FIF of the last MS NSF received prior to polling is
	used as a challenge string. (This corresponds to the first
	POLL_CHALLENGE_LEN bytes of the FIF after skipping the USA & MS codes).
	If the received NSFs FIF had fewer than 3+POLL_CHALLENGE_LEN bytes then
	as many bytes as were received are used. These bytes are the "Challenge".
	
	This challenge string is encrypted using the actual Poll-Password as the
	key. The enctypted result is the "Challenge Response". This is what is
	actually sent on the wire. The actual poll password is not sent.
	
	On the POLLEE'S side password verification is done as follows. The
	relevant bytes of the last NSF sent are always saved as teh "Challenge".
	On receiving a poll-req, the requested poll document name is used to look
	up the expected password. Encrypt the saved "Challenge" the expected
	password to get the "Expected Challenge Response". Compare the "Expected
	Challenge Response" with the actual received "Challenge Response". Allow
	the poll request to proceed only if they are identical (and identical is
	length).
	
	Note: The Challenge, and the challenge-response may both contain embedded
	nuls. However the Poll Document-Name cannot contain embedded nuls.

	@xref <t BC> 
********/

#pragma warning (disable: 4200)

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_POLLREQ
	WORD	fReturnControl	:1;	// 1=return control when done 0=hangup when done
	WORD	PollType		:4;	// one of the POLLTYPE_ defines below
//2bytes
	BYTE	b[];		// var length name and (optionally) password
}
BCPOLLREQ, far *LPBCPOLLREQ, near* NPBCPOLLREQ;

#pragma warning (default: 4200)


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCNSS | BC NSS struct

	@field BITFIELD | GroupLength | Must be set to sizeof(BCNSS).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_NSS.

	@field BITFIELD | vMsgProtocol | Version of linearizer used to
			encode the version of the message that immediately follows.

	@field BITFIELD | vInteractive | Command to switch to the Microsoft
			At Work Interactive Protocol. Version of that protocol to use.

	@xref <t BC> 
********/			  

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_NSS
	WORD	vMsgProtocol	:3;	// non-zero: linearized msg follows
								// vMSG_SNOW current linearized format
	WORD	Reserved1		:2;
// 2 bytes
	BYTE	vInteractive	:3;	// non-zero: Interactive prot being invoked
	BYTE	Reserved2		:5;
// 3 bytes
} 
BCNSS, far *LPBCNSS, near* NPBCNSS;

#pragma pack()    /** MUST ensure packed structures here **/

#endif /* !PORTABLE */



#define vMSG_SNOW       1	/* Snowball Linearizer version */
#define vMSG_IFAX100	2	/* IFAX linearizer version */
#define vSECURE_SNOW    1	/* vSecurity for Snowball (v1.00 of MAW)	 */
#define vRAMBO_VER1		1	/* Rambo ver on IFS66 */
#define OS_WIN16        0	/* OperatingSys for Win3.0, 3.1, WFW3.1, 3.11*/
#define OS_ARADOR       1	/* OperatingSys for Arador-based systems 	 */
#define	OS_WIN32		2	/* OperatingsSys for WIN32 (NT, WIN95)       */	
#define TEXTCODE_ASCII  0	/* TextEncoding for 7-bit ASCII				 */
#define vADDRBK_VER1    1   /* Address book attachments ver 1.00         */

/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI

    @type   VOID | POLLTYPE | PollType values

    @emem	POLLTYPE_WAIT		| Poll request being processed--wait 
	@emem	POLLTYPE_PHASEC		| Poll request was already sent in PhaseC 
	@emem	POLLTYPE_EXTCAPS	| Extended capabilities poll request
	@emem	POLLTYPE_NAMED_DOC	| Named document poll request
	@emem	POLLTYPE_BYRECIPNAME| Poll-by-Recip Mailbox Address
	@emem	POLLTYPE_BYPATHNAME	| Poll-by-File Pathname
	@emem	POLLTYPE_DONE		| poll request done or failed. Control being returned
********/

#define POLLTYPE_WAIT			0	
#define POLLTYPE_PHASEC			1	
#define POLLTYPE_EXTCAPS		2	
#define POLLTYPE_NAMED_DOC		3	
#define POLLTYPE_BYRECIPNAME	4	
#define POLLTYPE_BYPATHNAME		5	
#define POLLTYPE_DONE			8	
#define POLLTYPE_LAST				/* last valie POLLTYPE_ value */


#ifdef PORTABLE		/** ANSI C version **/

#define GroupLength(lp)		  ((((LPBYTE)(lp))[0]) & 0x3F)
#define GroupNum(lp)		  ((((((LPBYTE)(lp))[0]) >> 6) & 0x03) | (((((LPBYTE)(lp))[1]) & 0x07) << 2))
#define SetGroupLength(lp, n) ((((LPBYTE)(lp))[0]) = (((((LPBYTE)(lp))[0]) & 0xC0) | ((n) & 0x3F)))
#define SetupTextIdHdr(lp, l, n, t)										\
    (((LPBYTE)(lp))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));   \
    (((LPBYTE)(lp))[1]) = ((((n) & 0x1C) >> 2) | (((t) & 0x1F) << 3));

#else 				/** Microsoft C version **/

#define GroupLength(lp)		  (((LPBCHDR)(lp))->GroupLength)
#define GroupNum(lp)		  (((LPBCHDR)(lp))->GroupNum)
#define SetGroupLength(lp, n) (((LPBCHDR)(lp))->GroupLength = (n))
#define SetupTextIdHdr(lp, l, n, t)				\
	(((LPBCTEXTID)(lp))->GroupNum = (n)); 		\
	(((LPBCTEXTID)(lp))->GroupLength = (l));	\
	(((LPBCTEXTID)(lp))->TextEncoding = (t));

#endif /* PORTABLE */


#define AWRES_ALLT30 (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_mm080_154 | AWRES_mm160_154 | AWRES_200_200 | AWRES_300_300 | AWRES_400_400)


/********
    @doc    EXTERNAL OEMNSF DATATYPES

    @type   VOID | FAX_PAGE_WIDTHS | Fax Page Width values

    @emem	WIDTH_A4 | A4 width, 1728 pixels at 8 lines/mm horizontal resolution.
	@emem	WIDTH_B4 | B4 width, 2048 pixels at 8 lines/mm horizontal resolution.
	@emem	WIDTH_A3 | A3 width, 2432 pixels at 8 lines/mm horizontal resolution.

	@comm
	
	Widths in pixels must be exactly correct for MH/MR/MMR decoding to work.
	The width above are for NORMAL, FINE, 200dpi and SUPER resolutions.
	At 400dpi or SUPER_SUPER exactly twice as many pixels must be supplied
	and at 300dpi exactly 1.5 times.

	@flag Number of Pixels/Bytes per line at each page width and resolution |

		.			A4				B4				A3

		200		1728/216		2048/256		2432/304

		300		2592/324		3072/384		3648/456

		400		3456/432		4096/512		4864/608

	@xref <t BCFAX>

********/

#define WIDTH_A4	0	
#define WIDTH_B4	1	
#define WIDTH_A3	2	
#define WIDTH_MAX	WIDTH_A3

#define WIDTH_A5		16 	/* 1216 pixels */
#define WIDTH_A6		32	/* 864 pixels  */
#define WIDTH_A5_1728	64 	/* 1216 pixels */
#define WIDTH_A6_1728	128	/* 864 pixels  */



/********
    @doc    EXTERNAL OEMNSF DATATYPES

    @type   VOID | FAX_PAGE_LENGTHS | Fax Page Width values

    @emem	LENGTH_A4		| A4 length.
	@emem	LENGTH_B4		| B4 length.
	@emem	LENGTH_UNLIMITED| Unknown/Unlimited length.

	@xref <t BCFAX> 
********/

#define LENGTH_A4			0	
#define LENGTH_B4			1	
#define LENGTH_UNLIMITED	2


#endif /* _AWNSFCOR_H */

/****************************************************************************

 Note, line is kept open during poll requests as follows:-

(1) Successful poll request

 Caller   Callee        Notes
 ....
 <SendPhaseC>
 EOM
          MCF      previous operation is now done
 NSC/DTC           TurnReason=TURN_POLL (may be accompanied by SEP etc)
                    (should contain all NSF caps etc)
          NSC/DTC  TurnReason=TURN_WAIT (response is not yet ready)
                    (minimal NSC, only beginning of POLLREQ grp, no other grps)
 NSC/DTC           TurnReason=TURN_POLL (dont resend SEP etc)
                    (minimal NSC, only beginning of POLLREQ grp, no other grps)
          NSC/DTC  TurnReason=TURN_WAIT 
 NSC/DTC           TurnReason=TURN_POLL 
          NSS/DCS        
 <TCF, CFR, Phase C etc>
          EOM 
 MCF
          NSC/DTC  TurnReason=TURN_DONE (req done. Return control if req)
                    (if control is not requested back, send DCN here)
 .....


(2) Unsuccessful poll request

 Caller   Callee     Notes
 ....
 <SendPhaseC>
 EOM 
          MCF       previous operation is now done
 NSC/DTC            TurnReason=TURN_POLL (may be accompanied by SEP etc)
                     (should contain all NSF caps etc)
          NSC/DTC   TurnReason=TURN_WAIT (response is not yet ready)
                     (minimal NSC, only beginning of POLLREQ grp, no other grps)
 NSC/DTC            TurnReason=TURN_POLL (dont resend SEP etc)
                     (minimal NSC, only beginning of POLLREQ grp, no other grps)
          NSC/DTC   TurnReason=TURN_WAIT (response is not yet ready)
 NSC/DTC            TurnReason=TURN_POLL (dont resend SEP etc)
          NSC/DTC   TurnReason=TURN_FAIL (response is not available)
 DCN                 (or continue with other operations)
                         
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awnsfint.h ===
/***************************************************************************
 Name     :     AWNSFINT.H
 Comment  :     INTERNAL-ONLY Definitions of BC and NSF related structs

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Modifying aftering adding encryption
***************************************************************************/


#ifndef _AWNSFINT_H
#define _AWNSFINT_H

#include <awnsfcor.h>
#include <fr.h>

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#pragma pack(2)         /* ensure portable packing (i.e. 2 or more) */

/* these sizes should remain constant across all platforms */

#define GRPSIZE_STD                     5
#define GRPSIZE_IMAGE           6
#define GRPSIZE_POLLCAPS        5
#define GRPSIZE_NSS                     3
#define GRPSIZE_FAX                     12

#define BCEXTRA_TEXTID  64      /** space for one 60-byte Text ID **/
#define BCEXTRA_POLL    128     /** space for reasonable poll requests **/
#define BCEXTRA_HUGE    640     /** space for everything, probably.... **/

#define MAXNSCPOLLREQ                   5

#ifndef NOCHALL
#       define POLL_CHALLENGE_LEN       10
#endif



#ifdef PORTABLE         /* ANSI C */

typedef struct { BYTE b[GRPSIZE_STD];           } BCSTD;
typedef struct { BYTE b[GRPSIZE_IMAGE];         } BCIMAGE;
typedef struct { BYTE b[GRPSIZE_POLLCAPS];      } BCPOLLCAPS;
typedef struct { BYTE b[GRPSIZE_NSS];           } BCNSS;
typedef struct { BYTE b[GRPSIZE_FAX];           } BCFAX;

typedef struct
{
        BCTYPE  bctype;
        WORD    wBCSize;
        WORD    wBCVer;
        WORD    wBCSig;
        WORD    wTotalSize; /** total size of header + associated var len strings **/

        BCSTD           Std;
        BCIMAGE         Image;
        BCPOLLCAPS      PollCaps;
        BCNSS           NSS;
        BCFAX           Fax;

        WORD    wTextEncoding;  /** char set code see above  **/
        WORD    wTextIdLen;             /** length of text id **/
        WORD    wszTextId;              /** offset from start of struct to zero-term szTextId **/
        WORD    wMachineIdLen;  /** size of Machine Id (not zero-terminated) **/
        WORD    wrgbMachineId;  /** offset from start of struct to zero-term szNumId **/
        /* WORD wszNumId; */    /** offset from start of struct to zero-term szNumId **/

        WORD    wszRecipSubAddr;  /* offset from start of struct to zero-term SUB frame */
        WORD    wRecipSubAddrLen; /* length of SUB frame */

        WORD    wNumPollReq;    /** number of SEPPWDOFF structs i.e. size of following array **/
        WORD    rgwPollReq[MAXNSCPOLLREQ];      /** array of offsets to POLLREQ structures **/

#ifndef NOCHALL
        WORD    wChallengeLen;  /** length of challenge string **/
        WORD    wChallenge;             /** offset to challenge string **/
#endif

        BYTE    b[BCEXTRA_HUGE];
        DWORD   Guard;
}
BCwithHUGE, FAR* LPBC, NEAR* NPBC;

#define BC_SIZE (sizeof(BCwithHUGE)-BCEXTRA_HUGE-sizeof(DWORD))


#else /* Microsoft C only */



/********
    @doc   EXTERNAL DATATYPES OEMNSF

        @types BCFAX | Fax Capabilities Group

        @field BOOL      | fPublicPoll | Blind/Public poll availability/request
        @field DWORD | AwRes       | Resolution Capabilities or Mode. See <t STD_RESOLUTIONS> for values.
        @field WORD  | Encoding    | Encoding Capabilities or Mode. See <t STD_DATA_TYPES>
        @field WORD  | PageWidth   | Page Width Capabilities or Mode. See <t FAX_PAGE_WIDTHS>
        @field WORD  | PageLength  | Page Length Capabilities or Mode. See <t FAX_PAGE_LENGTHS>
********/

typedef struct
{
        ///////// This structure is not transmitted /////////

        WORD    fPublicPoll;
//2bytes

        DWORD   AwRes;          /* One or more of the AWRES_ #defines           */
        WORD    Encoding;       /* One or more of MH_DATA/MR_DATA/MMR_DATA      */
        WORD    PageWidth;      /* One of the WIDTH_ #defines (these are not bitflags!) */
        WORD    PageLength;     /* One of the LENGTH_ #defines (these are not bitflags!) */
//12 bytes
}
BCFAX, far* LPBCFAX, near* NPBCFAX;


/********
    @doc    EXTERNAL DATATYPES OEMNSF

        @types  BC | Basic Capabilities structure corresponding
                                 to sent or received NSF, NSS or NSC frames.

        @field BCTYPE | bctype | Type of BC structure. Must always be set. See <t BCTYPE> for values.
        @field WORD   | wBCSize| Size of this (fixed size) AWBC struct. Must always be set.
        @field WORD   | wBCVer | Version. Currently set it to VER_AWFXPROT100.
        @field WORD   | wBCSig | Set to VER_AWFXPROT100.

        @field BCSTD      | Std      | Standard Capability group. See <t BCSTD> for details.
        @field BCIMAGE    |     Image    | Image Capability group. See <t BCIMAGE> for details.
        @field BCPOLLCAPS |     PollCaps | PollCaps Capability group. See <t BCPOLLCAPS> for details.
        @field BCNSS      | NSS          | NSS Capability group. See <t BCNSS> for details.
        @field BCFAX      | Fax          | Fax Capability group. See <t BCFAX> for details.

        @field WORD     | wTextEncoding | Character-Set code used in TextId
        @field WORD     | wTextIdLen    | Length of TextId in bytes
        @field WORD     | wszTextId             | Offset from start of struct to zero-term szTextId
        @field WORD     | wMachineIdLen | Length of MachineId in bytes (not zero-terminated)
        @field WORD     | wrgbMachineId | Offset from start of struct to MachineId.

        @field WORD     | wszRecipSubAddr  | Offset from start of struct to zero-term SubAddress.
        @field WORD     | wRecipSubAddrLen | Length of SubAddress.
                                |
        @field WORD     | wNumPollReq  | Number of valid PollReqs in the following array. Cannot exceed MAXNSCPOLLREQ.
        @field WORD     | rgwPollReq[] | Array of offsets (from start of struct) to POLLREQ structures.
                                |
        @field WORD     | wChallengeLen | Length of the Password-Challenge string
        @field WORD     | wChallenge    | Offset (from start of struct) to Challenge string

        @xref   <t BCTYPE>
********/


typedef struct
{
        BCTYPE  bctype;  // must always be set. One of the enum values above
        WORD    wBCSize; // size of this (fixed size) BC struct, must be set
        WORD    wBCVer; // if using this header file, set it to VER_AWFXPROT100
        WORD    wBCSig; // if using this header file, set it to VER_AWFXPROT100
        WORD    wTotalSize; // total size of header + associated var len strings

        BCSTD                   Std;
        BCIMAGE                 Image;
        BCPOLLCAPS              PollCaps;
        BCNSS                   NSS;
        BCFAX                   Fax;            // for internal use _only_

        WORD    wTextEncoding;  // char set code
        WORD    wTextIdLen;             // length of text id
        WORD    wszTextId;              // offset from start of struct to zero-term szTextId
        WORD    wMachineIdLen;  // size of Machine Id (not zero-terminated)
        WORD    wrgbMachineId;  // offset from start of struct to zero-term szNumId
        // WORD wszNumId;               // offset from start of struct to zero-term szNumId

        WORD    wszRecipSubAddr;        // offset from start of struct to zero-term SUB frame
        WORD    wRecipSubAddrLen;       // length of SUB frame

        WORD    wNumPollReq;            // size of following array
        WORD    rgwPollReq[MAXNSCPOLLREQ];      // array of offsets to POLLREQ structures

#ifndef NOCHALL
        WORD    wChallengeLen;  // length of challenge string
        WORD    wChallenge;             // offset to challenge string
#endif //!NOCHALL
}
BC, far* LPBC, near* NPBC;

#define BC_SIZE sizeof(BC)

//#ifndef __cplusplus

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_TEXTID];
        DWORD   Guard;
}
BCwithTEXT;

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_POLL];
        DWORD   Guard;
}
BCwithPOLL;

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_HUGE];
        DWORD   Guard;
}
BCwithHUGE;

//#endif //!__cplusplus


/**------------------- ACK struct ----------------**/

typedef struct
{
        BCTYPE  bctype;  // must always be set. One of SEND_ACK or SEND_DISCONNECT
        WORD    wACKSize; // size of this (fixed size) ACK struct, must be set
        WORD    wACKVer; // if using this header file, set it to VER_AWFXPROT100
        WORD    wACKSig; // if using this header file, set it to VER_AWFXPROT100

        BOOL    fAck;
}
ACK, far* LPACK;


#endif /** PORTABLE **/



#define AppendToBCLen(lpbc, uMax, lpb, uLen, wOff, wLen)                \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo = ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                          \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wOff = (lpbc)->wTotalSize;                                            \
          (lpbc)->wLen = uCopy;                                                                         \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}


#define AppendToBCOff(lpbc, uMax, lpb, uLen, wOff)                              \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo = ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                          \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wOff = (lpbc)->wTotalSize;                                            \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}

#define AppendToBC(lpbc, uMax, lpb, uLen)                                               \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo =  ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                         \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}


#define InitBC(lpbc, uSize, t)                                                          \
{                                                                                                                       \
        _fmemset((lpbc), 0, (uSize));                                                   \
        (lpbc)->bctype  = (t);                                                                  \
        (lpbc)->wBCSize = sizeof(BC);                                                   \
        (lpbc)->wBCVer  = VER_AWFXPROT100;                                              \
        (lpbc)->wBCSig  = VER_AWFXPROT100;                                              \
        (lpbc)->wTotalSize = sizeof(BC);                                                \
}


#define GetTextId(lpbc, lpbOut, uMax)                                                                           \
        BG_CHK((lpbOut) && (lpbc) && (uMax));                                                                   \
        ((LPBYTE)(lpbOut))[0] = 0;                                                                                              \
        if( (lpbc)->wTextIdLen && (lpbc)->wszTextId &&                                                  \
                (lpbc)->wszTextId < (lpbc)->wTotalSize &&                                                       \
                (lpbc)->wszTextId+(lpbc)->wTextIdLen <= (lpbc)->wTotalSize)                     \
        {                                                                                                                                               \
                USHORT uLen;                                                                                                            \
                uLen = min(((uMax)-1), (lpbc)->wTextIdLen);                                                     \
                _fmemcpy((lpbOut), (((LPBYTE)(lpbc)) + (lpbc)->wszTextId), uLen);       \
                ((LPBYTE)(lpbOut))[uLen] = 0;                                                                           \
        }

#define PutTextId(lpbc, uMax, lpbIn, uLen, enc)                                                          \
        if(uLen) { AppendToBCLen(lpbc, uMax, lpbIn, uLen, wszTextId, wTextIdLen);\
                (lpbc)->wTextEncoding = (enc); }

#define HasTextId(lpbc)         ((lpbc)->wTextIdLen && (lpbc)->wszTextId)



#define PutRecipSubAddr(lpbc, uMax, lpbIn, uLen)                                                         \
        if(uLen) { AppendToBCLen(lpbc, uMax, lpbIn, uLen, wszRecipSubAddr, wRecipSubAddrLen); }

#define GetRecipSubAddr(lpbc, lpbOut, uMax)                                                                             \
        BG_CHK((lpbOut) && (lpbc) && (uMax));                                                                   \
        ((LPBYTE)(lpbOut))[0] = 0;                                                                                              \
        if( (lpbc)->wRecipSubAddrLen && (lpbc)->wszRecipSubAddr &&                                                      \
                (lpbc)->wszRecipSubAddr < (lpbc)->wTotalSize &&                                                 \
                (lpbc)->wszRecipSubAddr+(lpbc)->wRecipSubAddrLen <= (lpbc)->wTotalSize)                 \
        {                                                                                                                                               \
                USHORT uLen;                                                                                                            \
                uLen = min(((uMax)-1), (lpbc)->wRecipSubAddrLen);                                                       \
                _fmemcpy((lpbOut), (((LPBYTE)(lpbc)) + (lpbc)->wszRecipSubAddr), uLen); \
                ((LPBYTE)(lpbOut))[uLen] = 0;                                                                           \
        }

#define HasRecipSubAddr(lpbc)   ((lpbc)->wRecipSubAddrLen && (lpbc)->wszRecipSubAddr)


/* returns FALSE (and doesnt caopy anything) if destination is too small */
#define CopyBC(lpbcOut, wMaxOut, lpbcIn)                \
        ( (wMaxOut < lpbcIn->wTotalSize) ? FALSE :      \
                        (_fmemcpy(lpbcOut, lpbcIn, lpbcIn->wTotalSize), TRUE) )

/** not for general use **/
/** #define DeleteTextId(lpbc)  ((lpbc)->wszTextId=(lpbc)->wTextIdLen=(lpbc)->wTextEncoding=0) **/




#define OffToNP(npbc, off) (((npbc)->off) ? (((NPBYTE)(npbc)) + ((npbc)->off)) : NULL)
#define OffToLP(lpbc, off) (((lpbc)->off) ? (((LPBYTE)(lpbc)) + ((lpbc)->off)) : NULL)

#define OFF_CHK(lpbc, off)      BG_CHK((lpbc)->off >= sizeof(BC) && (lpbc)->off <= (lpbc)->wTotalSize)


#if defined(IFBGPROC) || defined(IFFGPROC)
#       define EXPORTBC         _export WINAPI
#else
#       define EXPORTBC
#endif


/***************************************************************************
    @doc    INTERNAL

        @api    WORD | NSxtoBC | Called to parse received Microsoft At Work NSx
                                        frames and fill in a BC structure.

        @parm   IFR | ifr | This must be set to ifrNSF for parsing Capabilities
                        (NSF/DIS) and to ifrNSS for parsing Mode/Parameters (NSS/DCS)

        @parm   LPFR[] | rglpfr | [in] Pointer to array of LPFR pointers which
                        point to FR structures that contain the received frame(s).

        @parm   WORD | wNumFrame | [in] Number of received frames i.e. length of
                        the above array of pointers

        @parm   LPBC | lpbcOut | [out] Pointer to output BC struct

        @parm   WORD | wBCSize | [in] size of the above AWBC struct.

        @rdesc  Returns AWERROR_OK on success, otherwise one of the other
                        AWERROR_ values.

        @xref   <t IFR> <t FR> <t BC>
***************************************************************************/



/***************************************************************************
    @doc    INTERNAL

        @api    WORD | BCtoNSx | Called to create Microsoft At Work NSx frames
                                                         from a BC struct

        @parm   IFR | ifr | This must be set to ifrNSF for creating Capabilities
                        (NSF/DIS) and to ifrNSS for creating Mode/Parameters (NSS/DCS)

        @parm   LPBC | lpbcIn | [in] Pointer to input BC struct.

        @parm   LPBYTE | lpbOut | [out] Pointer to space where the NSx frames
                        will be created. On successful return this will point to an array
                        of *lpwNumFrame pointers to FR structures, (i.e. on return the
                        start of this buffer contains an LPFR[] array that is *lpwNumFrame
                        items long). The pointers point to the actual (variable-length)
                        FR stuctures which are placed in the buffer following this
                        array of pointers.

        @parm   WORD | wMaxOut | [in] Length of the above buffer. It is
                        reccomended that this be at least 256 bytes long

        @parm   LPWORD | lpwNumFrame | [out] Number of NSx frames created. Also
                        length of the LPFR[] array created in the supplied buffer.

        @rdesc  Returns AWERROR_OK on success, otherwise one of the other
                        AWERROR_ values.

        @xref   <t IFR> <t FR> <t BC>
***************************************************************************/




#if defined(IFBGPROC) || defined(IFFGPROC)

// internal APIs only!

/***************************************************************************
    @doc    INTERNAL

        @api    WORD    | DIStoBCFAX | Parses a DIS into a BCFAX
        @parm   LPBYTE  | lpbDIS         | [in] Pointer to DIS (FIF part only)
        @parm   WORD    | wLenDIS        | [in] length of DIS
        @parm   LPBCFAX | lpbcfax        | [out] Pointer to BCFAX struct to be filled in
        @parm   WORD    | wLenBCFAX      | [in] length of BCFAX struct

        @rdesc  Returns length of BCFAX filled in on success. 0 on failure

        @comm   **NOTE**: Be sure to call this function _after_ calling NSxtoBC,
                        because NSxtoBC zeros out the entire BC struct, _including_ the
                        BCFAX part, so if the order were reversed, the data parsed from
                        the DIS would be lost.

        @xref   <t IFR> <t BCFAX>
***************************************************************************/

WORD EXPORTBC DIStoBCFAX(IFR ifr, LPBYTE lpbDIS, WORD wLenDIS, LPBCFAX lpbcfax, WORD wLenBCFAX);

/***************************************************************************
    @doc    INTERNAL

        @api    WORD    | BCFAXtoDIS | Creates a DIS from a BCFAX
        @parm   LPBCFAX | lpbcfax        | [in] Pointer to BCFAX struct
        @parm   WORD    | wLenBCFAX      | [in] length of BCFAX struct
        @parm   LPBYTE  | lpbDIS         | [out] Pointer to space for DIS (FIF part only).
                                                                        Note: This API does _not_ create an FR struct!!
        @parm   WORD    | wLenDIS        | [in] length of buffer provided for DIS

        @rdesc  Returns length of DIS created on success. 0 on failure
        @xref   <t IFR> <t BCFAX>
***************************************************************************/

WORD EXPORTBC BCFAXtoDIS(IFR ifr, LPBCFAX lpbcfax, WORD wLenBCFAX, LPBYTE lpbDIS, WORD wLenDIS);

#endif /* IFBGPROC || IFFGPROC */

#pragma pack()

#endif /** _AWNSFINT_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awsecx.h ===
#ifndef __AWSECX_H__
#define __AWSECX_H__

#ifdef __cplusplus
extern "C" {
#endif


#define MINKEYBUFSIZE    1024  // dictated by comments in awsec.h

#define SECTYPE_NONE     0
#define SECTYPE_KEY      1
#define SECTYPE_PASSWORD 2

#define CB_QUERYREPLACE    0
#define CB_INFORMDUPLICATE 1
typedef BOOL (CALLBACK QUERYREPLACEKEYCB)(HWND hWndParent, LPTSTR pKeyOwner,
 UINT context) ;

typedef WORD (CALLBACK *RESOLVEGETKEYCB)(LPMAPISESSION pSession,
 LPARAM lParamfpx, WORD context, LPBYTE pKey,
 LPWORD pcbKey);

typedef struct {
    LPBYTE    pKey ;
    WORD      cbKey;
    LPTSTR    pName;
    LPENTRYID pEntryID;
    LONG      cbEntryID;
} SECKEYREC, *LPSECKEYREC ;

BOOL GetPABStrings(LPMAPISESSION pSession, LPTSTR *ppFName, LPTSTR *ppEAddress);
BOOL GetLoginName(LPMAPISESSION pSession, LPTSTR *ppLoginName);
BOOL GetLoginNameXP (LPTSTR lpszFriendly, LPTSTR lpszEmail, LPTSTR *ppLoginName);
WORD GetCurrentUserAddress(LPMAPISESSION pSession, LPTSTR *ppAddress,
 LPWORD pNChars);

BOOL SetNoneSecurityProps(LPMAPIPROP pMsg, LPTSTR pPwdEncrypt, BOOL bDigSig,
 DWORD dwhSecurity);
BOOL SetKeySecurityProps(LPMAPIPROP pMsg, LPTSTR pPwdEncrypt, BOOL bDigSig,
 DWORD dwhSecurity);
BOOL SetPwdSecurityProps(LPMAPIPROP pMsg, LPTSTR pPwdEncrypt, LPTSTR pPassword,
 BOOL bDigSig, DWORD dwhSecurity);

BOOL GetSecurityProps(LPMAPIPROP pMsg, LPTSTR pPwdDecrypt, LPWORD pSecType,
 LPBOOL pDigSig, LPTSTR *ppSecPwd, LPTSTR *ppSimplePwd);

BOOL SetResolveGetKeyCB(DWORD hSec, RESOLVEGETKEYCB fpxResolve, LPARAM lParamfpx);
BOOL SetMapiSession(DWORD hSec, LPMAPISESSION pSession);
BOOL SetAddressBook(DWORD hSec, LPADRBOOK lpAB);

WORD ImportPrivateKeysEx(LPSTR userid, LPSOSSESSION lpSess,
 ReadCB FAR *readCB, DWORD readHand, LPSTR password);

WORD AddPublicKeysEx(LPSOSSESSION lpSess, LPSECKEYREC pKeys, int iNumKeys,
 LPMAPISESSION pSession, QUERYREPLACEKEYCB fpxCB, HWND hWndParent);

WORD DelPublicKeysEx(LPSOSSESSION lpSess, LPSECKEYREC pKeys, int iNumKeys,
 LPMAPISESSION pSession);

WORD GetPublicKeyEx(LPSOSSESSION lpSess, LPTSTR pOwner, BYTE FAR *key,
 LPWORD pcbKey);

WORD GetUsersPublicKeyEx(LPSOSSESSION lpSess, BYTE FAR *key, LPWORD pcbKey);

// Convenient utilities.
BOOL GetFaxABEntryID(LPADRBOOK pAB, LPENTRYID *ppEntryID, LPULONG pcbEntryID);

BOOL MakeTargetName(LPTSTR pFName, LPTSTR pEAddress, LPTSTR *ppTargetName);

BOOL AddKeyEntryToPAB(LPADRBOOK pAB, LPABCONT pPAB,
  LPTSTR pFName, LPTSTR pEAddress, LPBYTE pKey, WORD cbKey,
  LPSPropValue *ppRetEntryID);

// Additional return codes.
#define SEC_INVSECHANDLE    20    // security handle has become invalid.
#define SEC_LOSTKEYS        21    // this operation has caused loss of keys.
#define SEC_REGFAILURE      22    // registry failure keeps operation from succeeding.
#define SEC_BUFTOOSMALL     23    // supplied buffer was to small to hold return.
#define SEC_NOMATCHINGOWNER 24    // Could not find key owner matching the target.
#define SEC_DUPLICATEOWNERS 25    // More could not resolve key ownership.
#define SEC_MAPIERROR       26    // Unexpected mapi error returned.

// Programmer error:
#define SEC_NOMAPISESSION   50    // Mapi Session not set, opperation requires one

#define SEC_FAILURE        100


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __AWSECX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awsec.h ===
/* NO_MAPI - defined for lhutil to get some apis that
 *            do not use mapi -scousens
 */

#ifndef __AWSEC_H__
#define __AWSEC_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __FAXOPT_H__

/* **** Special return values for functions below **** */

#define KEY_ADD	1
#define KEY_DEL	2
#define KEY_LOC 3
#define KEY_FND 4

/* The following are return codes from functions which say they return SIG_* as
   return values */

#define SIG_SUCCESS     0   /* Operation succeeded */
#define SIG_BADINFILE   1   /* Bad input file */
#define SIG_BADOUTFILE  2   /* Bad output file */
#define SIG_FORGED      3   /* Signature does not match keyset */
#define SIG_AUTHENTIC   4   /* Signature matches keyset */
#define SIG_NOTVERIFIED 5   /* No key found, so can not verify signature */
#define SIG_BADPASS     6   /* Bad password or incorrect session handle */
#define SIG_NOMEM       7   /* Out of memory error */
#define SIG_ABORT       8   /* Callback caused abort */
#define SIG_BUSY        9   /* Concurrent job already running */

/* The following are return codes from functions which say they return SEC_* as
   return values */

#define SEC_SUCCESS         0   /* Operation succeeded          */
#define SEC_BADFILE         1   /* File cannot be opened        */
#define SEC_KEYTOOSMALL     2   /* Keybuffer too small          */
#define SEC_NOMATCH         3   /* No key of requested type found for
				   specified keyholder          */
#define SEC_FILECORRUPT     4   /* File integrity check failed  */
#define SEC_NOMEMORY        5   /* Aborted due to low memory conditions */
#define SEC_BADPTR          6   /* An invalid pointer was passed in */
#define SEC_USERABORT       7   /* User aborted operation       */
#define SEC_BADPASS         8   /* Invalid password             */
#define SEC_ABORT           9   /* Callback caused abort        */
#define SEC_BUSY           10   /* Concurrent job already running */
#define SEC_WRONGKEY       11   /* Wrong key used in decryption */
#define SEC_NEWERVERSION   12	/* File generated by newer version of software,
				   and we cannot decrypt it */
#define SEC_NODISKSPACE	   13	/* Cannot allocate neccessary disk space for
				   main or temporary file */
#define SEC_ALREADYLOGGED  14	/* User is already logged in, so certain
				   account changes cannot be made */
#define SEC_UNDERPRIV	   15	/* User does not have sufficient priviledge */
#define SEC_INITFAIL	   16   /* Can't init the security system */
#define SEC_ALREADYTHERE   17   /* Key already exists on add or rename */

#endif

/* **** Callback parameter definitions for functions below **** */

/* return values: 0 = success, 1 = End of Job, 2 = failure */
/* A function of type ReadCB allocates a buffer (of arbitrary size), and then
   fills it from handle hf (passed in when the callback was set up) */
typedef WORD CALLBACK ReadCB(DWORD hf, LPBUFFER FAR *buf);

/* return values: 0 = success, 2 = failure */
/* A function of type WriteCB writes the buffer passed in (arbitrary size) out
   to handle hf, and then frees the buffer */
typedef WORD CALLBACK WriteCB(DWORD hf, LPBUFFER buf);

/* return values: 0 = continue, 1 = abort */
/* A function of type SigCB is called with information about a signature on a
   file.  Each time it is called, it is passed the handle it gave when the
   callback was set up (hf), a username (username), and a result (result).
   The result can be SIG_FORGED (key found, but signature does not match key),
   SIG_AUTHENTIC (key found, and signature matches key), or SIG_NOTVERIFIED
   (key not found, and therefore cannot be authenticated) */
typedef WORD CALLBACK SigCB(DWORD hf, LPSTR username, WORD result);

/* return 0 for continue, 1 for abort.  */
/* A function of type listcallback is called with information about a key.  For
   each key, a pointer to the key is returned (key), along with its size
   (keysize), and the userid for whom the key is for.  Also, a handle is passed
   back which was passed in when the callback was set up originally */
typedef WORD (CALLBACK *listcallback)(BYTE FAR *key, WORD keysize, LPSTR userid,
				   DWORD handle);

/* **** Special Purpose API's **** */

/* To be called by UISHELL whenever the machine phone number has changed */
void WINAPI SecNewPhoneNumber(void);

#ifndef __AWGLOBAL_H__

/* **** Linearize/Delinarize API's **** */

/* Calls to encrypt and decrypt messages - for the linearizer only */

#ifndef NO_MAPI
/* Initializes key encryption.  Takes userid and mapi session handle of user
   to encrypt for.  Also takes userid of destination user.  Returns instance,
   which should be used on calls to EncryptData, as well as fills in buf with
   header information.  EncryptInit should be called with buf NULL first, and
   it will return the minimum needed size for the buffer.  Buf should then be
   allocated to be at least this size.  Returns value of type SEC_* if buf is
   not NULL. */
WORD WINAPI EncryptInit(LPSTR userid, LPSOSSESSION lpSess, LPSTR destuser,
			LPDWORD instance, LPBUFFER buf);

/* Takes current lpSess and inst from an EncryptInit call.  Fills in a pointer
   (buf) and a length (len) of an IFMemAlloc'ed block of memory.  This
   memory can be cached and restored via EncryptRestore for delayed encryption
   where the user can log out.  The header from EncryptInit should be stored,
   along with the Mapi session handle and the buffer returned.  Returns value
   of type SEC_* */
WORD WINAPI EncryptSave(LPSOSSESSION lpSess, DWORD inst, LPBYTE FAR *buf,
			LPWORD len);

/* Takes a pointer to a buffer and the buffer's length, as returned from
   EncryptSave, along with a (now possibly expired/invalid) lpSess.  Returns
   an inst suitable for passing to EncryptData.  Returns value of type SEC_* */
WORD WINAPI EncryptRestore(LPDWORD inst, LPSOSSESSION lpSess, LPBYTE buf,
			   WORD len);

/* Encrypts data using key encryption.  Takes a mapi session handle of user to
   encrypt for, as well as instance (inst) returned by EncryptInit.  Converts
   buf in place from plaintext to encrypted text.  After the final packet, a
   buffer of metatype END_OF_JOB should be passed in. Returns value of type
   SEC_* */
WORD WINAPI EncryptData(LPSOSSESSION lpSess, DWORD inst, LPBUFFER buf);

/* Initializes key decryption.  Takes userid and mapi session handle of user
   to decrypt for.  Also takes userid of source user.  Returns instance,
   which should be used on calls to DecryptData.  Takes a buffer which should
   be at least 8K (from message to decrypt), or the whole message if it is less
   than 8K, and returns a smaller buffer (of size >= 0, since header is
   stripped off).  Note that the buffer is the same, but the valid data area
   will be smaller.  Returns value of type SEC_* */
WORD WINAPI DecryptInit(LPSTR userid, LPSOSSESSION lpSess, LPSTR srcuser,
			LPDWORD instance, LPBUFFER buf);

/* Decrypts data using key encryption.  Takes a mapi session handle of user to
   decrypt for, as well as instance (inst) returned by DecryptInit.  Converts
   buf in place from encrypted to plaintext.  After the final packet, a
   buffer of metatype END_OF_JOB should be passed in. Returns value of type
   SEC_*. */
WORD WINAPI DecryptData(LPSOSSESSION lpSess, DWORD inst, LPBUFFER buf);
#endif /* NO_MAPI */

/* Initializes password encryption.  Takes pwd as the password to encrypt with.
   Returns instance, which should be used on calls to SimpleEncryptData, as
   well as fills in buf with header information.  SimpleEncryptInit should be
   called with buf NULL first, and it will return the minimum needed size for
   the buffer.  Buf should then be allocated to be at least this size.  Returns
   value of type SEC_* if buf is not NULL. */
WORD WINAPI SimpleEncryptInit(LPSTR pwd, LPDWORD instance, LPBUFFER buf);

/* Takes inst from a SimpleEncryptInit call.  Fills in a pointer (buf) and a
   length (len) of an IFMemAlloc'ed block of memory.  This memory can be
   cached and restored via SimpleEncryptRestore for delayed encryption where
   the user can log out.  The header from EncryptInit should be stored, along
   with the returned buffer.  Returns value of type SEC_* */
WORD WINAPI SimpleEncryptSave(DWORD inst, LPBYTE FAR *buf, LPWORD len);

/* Takes a pointer to a buffer and the buffer's length, as returned from
   SimpleEncryptSave, along with a (now possibly expired/invalid) lpSess.
   Returns an inst suitable for passing to SimpleEncryptData.  Returns value
   of type SEC_* */
WORD WINAPI SimpleEncryptRestore(LPDWORD inst, LPBYTE buf, WORD len);

/* Encrypts data using password encryption.  Takes an instance (inst) returned
   by EncryptInit.  Converts buf in place from plaintext to encrypted text.
   After the final packet, a buffer of metatype END_OF_JOB should be passed
   in.  Returns a value of type SEC_*. */
WORD WINAPI SimpleEncryptData(DWORD inst, LPBUFFER buf);

/* Initializes password decryption.  Takes password to use for decryption.
   Returns instance, which should be used on calls to SimpleDecryptData.  Takes
   a buffer which should be used on calls to DecryptData.  Takes a buffer which
   should be at least 8K (from message to decrypt), or the whole message if it
   is less than 8K, and returns a smaller buffer (of size >= 0, since header is
   stripped off).  Note that the buffer is the same, but the valid data area
   will be smaller.  Returns value of type SEC_* */
WORD WINAPI SimpleDecryptInit(LPSTR pwd, LPDWORD instance, LPBUFFER buf);

/* Decrypts data using password decryption.  Takes an instance (inst) returned
   by SimpleDecryptInit.  Converts buf in place from encrypted to plaintext.
   After the final packet, a buffer of metatype END_OF_JOB should be passed in.
   Returns value of type SEC_*. */
WORD WINAPI SimpleDecryptData(DWORD inst, LPBUFFER buf);

/* Call to start hashing bft header.  Returns 0 for failure, or non-zero
   context for passing to SendBFTHash and DoneBFTHash */
DWORD WINAPI StartBFTHash(void);

/* Pass in context from StartBFTHash, and buffer with length */
void WINAPI SendBFTHash(DWORD Context, LPBYTE buf, WORD len);

/* Pass in context after done calling SendBFTHash.  If salt points to 3 bytes
   which are 0, a salt is generated and returned, else the salt is used.
   Key must be 5 bytes, from which the actual key is derived.  Res must be 16
   bytes long to receive hashed encrypted result. */
void WINAPI DoneBFTHash(DWORD Context, LPBYTE salt, LPBYTE res);

/* **** Signature API's **** */

#ifndef NO_MAPI
/* Takes a read and write callback, and handles to pass them.  If the file is
   already signed (YOU MUST CHECK THE EXTENSION), you must pass the size of the
   header (from SignFileHeaderSize) in the HeaderSize field.  This value will
   currently always be changed to 0 upon return.  The new header will be
   written out to the callback.  To make the signed file, you prepend the data
   written to the callback to the original file, unless it was already signed,
   in which case you prepend it to the file inside the signed file (based on
   SignFileHeaderSize).  Also takes a session handle for the user who is
   signing the file, along with the username.  Returns SIG_*. */
WORD WINAPI SignFile(ReadCB *readCB, DWORD readHand, WriteCB *writeCB,
		     DWORD writeHand, LPSTR userid, LPSOSSESSION lpSess,
		     LPSTR filename, LPWORD HeaderSize);

/* Extracts file from signed file.  Takes a read and write callback and handles
   for them.  Reads the file from the read callback, and writes it out to the
   write callback.  Returns SIG_*. */
WORD WINAPI UnSignFile(ReadCB *readCB, DWORD readHand, WriteCB *writeCB,
		       DWORD writeHand);

/* Obtains the headersize and filename of a signed file.  Sets headersize to be
   the size of the header of signed file, and fills filename with 8.3 filename
   from a signed file obtained by reading from the callback.  Returns 0 for
   success, 1 for failure, 2 for not a signed file. */
WORD WINAPI SignFileHeaderSize(ReadCB *readCB, DWORD readHand,
			       LPWORD headersize, LPSTR filename);

/* Calls signature callback for each signature in the file obtained by the
   read callback.  Reads file from the read callback (SEE NOTE), and then calls the
   sig callback once for each signature (or until the callback signals to stop
   through its return value.  If filename is non-null, also returns the 8.3
   filename in the buffer pointed to by filename.  Returns SIG_*. */

/* NOTE: Unlike the usual semantics, the read callback should not simply return 1
   to indicate EOF.  Instead, it should allocate an empty buffer and return 0, then
   return 1 on the next call. -RajeevD */
WORD WINAPI GetSignatures(LPSTR userid, LPSOSSESSION lpSess, ReadCB *readCB,
			  DWORD readHand, SigCB *sigCB, DWORD sigHand,
			  LPSTR filename);

/* **** Public key API's **** */

/* Lists all public keys in an exported file, given that the read callback
   returns data from the unsigned portion of a signed key file, or from an
   unsigned key file.  Calls the read callback to read the file, and then
   calls the listcallback to enumerate the keys, passing it the listhandle with
   each key.  Returns SEC_*. */
WORD WINAPI ListKeysInFile(ReadCB FAR *readCB, DWORD readHand,
			       listcallback lcb, DWORD listhandle);

/* Lists all keys in user database for having mapi session lpSess for user
   userid.  Calls the listcallback to enumerate the keys, also passing the
   listhandle with each key.  Passing in a NULL for lpSess returns keys in the
   global key list (userid is ignored).  Returns SEC_*. */
WORD WINAPI ListKeys(LPSTR userid, LPSOSSESSION lpSess, listcallback lcb,
			 DWORD listhandle);

/* Creates a file header for an unsigned key file of numkeys public keys.
   Writes the header appropriate for a keyfile of numkeys keys out to the
   write callback, passing it writeHand as well.  Should be called in order
   to create a key file, before using AddPubKeyToFile to actually add the
   keys.  Returns SEC_*. */
WORD WINAPI CreatePubKeyFile(WriteCB FAR *writeCB, DWORD writeHand,
				 WORD numkeys);

/* Appends a key to keyfile created with KeyFileHeader.  Must be called exactly
   the number of times specified by the numkeys parameter to CreatePubKeyFile.
   Takes a key and a keysize, as well as the userid of the user corresponding
   to the key.  Calls the writecallback to write to append to a file that key.
   After all keys are written to the file, it can be closed and is now a valid
   public key file.  This file can be signed to create a signed key file.
   Returns SEC_*. */
WORD WINAPI AddPubKeyToFile(WriteCB FAR *writeCB, DWORD writeHand,
				BYTE FAR *key, WORD keysize, LPSTR userid);

/* Retrieves public key from a unsigned key file.  Returns key and size of key
   for user corresponding to userid, if it can be found.  Reads through read
   callback.  Key must point to at least 1024 bytes of memory.  If file is
   signed, callback should return bytes starting from offset in file after
   signed header size (from SignFileHeaderSize).  Returns SEC_*. */
WORD WINAPI GetPubKeyFromFile(ReadCB *readCB, DWORD readHand,
				  BYTE FAR *key, WORD FAR *keysize,
				  LPSTR userid);

/* Adds key for targetuserid into registry of userid with session handle
    lpSess.  Key should point to a key of size keysize, for user specified by
    userid.  Returns SEC_*. */
WORD WINAPI AddPubKey(LPSTR userid, LPSOSSESSION lpSess, BYTE FAR *key,
			  WORD keysize, LPSTR targetuserid);

/* Adds key for targetuserid into global key list.  lpSess must be the session
   handle for superuser userid.  Key should point to a key of size keysize,
   for user specified by targetuserid.  Returns SEC_*. */
WORD WINAPI AddGlobalPubKey(LPSTR userid, LPSOSSESSION lpSess,
				BYTE FAR *key, WORD keysize,
				LPSTR targetuserid);

/* Retrieves key for searchuserid from registry of userid with session handle
   lpSess.  Key must point to at least 1024 bytes of memory.  Actual size is
   returned in keysize.  If lpSess is NULL, reads from the global key list
   (userid is ignored).  Returns SEC_*. */
WORD WINAPI GetPubKey(LPSTR userid, LPSOSSESSION lpSess, BYTE FAR *key,
			  WORD FAR *keysize, LPSTR searchuserid);

/* Deletes key of targetuserid from registry of userid with session handle
   lpSess.  Returns SEC_*. */
WORD WINAPI DelPubKey(LPSTR userid, LPSOSSESSION lpSess,
			  LPSTR targetuserid);

/* Deletes key of targetuseri from global key list.  Userid must be a superuser
   with session handle lpSess.  Returns SEC_*. */
WORD WINAPI DelGlobalPubKey(LPSTR userid, LPSOSSESSION lpSess,
				LPSTR targetuserid);

/* Returns 1 if a public key exists for 'name' in key registry belonging to
   user 'userid' with session handle 'lpSess', or 0 otherwise.  If NULL is
   passed in for lpSess, checks the global key list (and userid is ignored). */
BOOL WINAPI ExistsPubKey(LPSTR userid, LPSOSSESSION lpSess, LPSTR name);

/* Returns 1 if a public key can be found using fuzzy matching as used in
   decrypt and encrypt for 'name' in key registry belonging to user 'userid'
   with session handle 'lpSess', or 0 otherwise.  If NULL is passed in for
   lpSess, checks the global key list (and userid is ignored). */
BOOL WINAPI ExistsFuzzyPubKey(LPSTR userid, LPSOSSESSION lpSess, LPSTR name);

/* Creates new key set (public and private) for userid logged in with 'lpSess'.
   Returns SEC_*. */
WORD WINAPI MakeNewKeySet(LPSTR userid, LPSOSSESSION lpSess);

/* For use when a user forgets his password.  Takes lpSess of userid who is a
   superuser, and the username of the user who has forgotten his password
   (targetuser).  Sets their password to be newuserpwd, and gives them a new
   set of keys.  targetuser should not be logged in.  Returns SEC_*.  */
WORD WINAPI ReinitKeyAndPassword(LPSTR userid, LPSOSSESSION lpSess,
				     LPSTR targetuser, LPSTR newuserpwd);

/* For use when a user wants to change his password.  Takes lpSess of userid
   who wants to change his password, along with old and new password.  Returns
   SEC_*. */
WORD WINAPI ChangePassword(LPSTR userid, LPSOSSESSION lpSess, LPSTR oldpass,
			   LPSTR newpass);

/* Exports private key set (password encrypted) through callbacks.  Writes out
   encrypted (with login password) file through write callback, which contains
   the user's private and public keys.  This file can be read back with
   ImportPrivateKeys.  Returns SEC_*. */
WORD WINAPI ExportPrivateKeys(LPSTR userid, LPSOSSESSION lpSess,
				  WriteCB FAR *writeCB, DWORD writeHand);

/* Attemps to import private and public key for userid with session lpSess,
   using password passed in to decrypt, reading file through read callback.
   Returns SEC_*. */
WORD WINAPI ImportPrivateKeys(LPSTR userid, LPSOSSESSION lpSess,
				  ReadCB FAR *readCB, DWORD readHand,
				  LPSTR password);

/* Removes keyset for a user */
WORD WINAPI DeleteKeySet(LPSTR userid, LPSOSSESSION lpSess);

/* Returns 1 if a user has a key set, else returns 0 */
WORD WINAPI HasPrivateKey(LPSTR userid, LPSOSSESSION lpSess);


/* Places 154 bytes into screendata array for displaying key passed in.
   screendata should be displayed as 14 groups of 11 characters.  Only
   alphanumerical characters will be returned in screendata.  It is not
   null-terminated, or delimited in any way - just 154 characters. Returns 0
   on success, or 1 if the key is invalid. */
WORD WINAPI GetDisplayableKey(BYTE FAR *key, BYTE FAR *screendata);

/* Converts keyinput into key for userid.  Keyinput is 154 bytes (only valid
   characters are 2..9, A..H, J..N, P..Z).  Returns 0 for success, or group
   which is invalid if the key is not valid (ie: 1 for 1st 11 characters,
   etc...).  If 15 is returned, there is an error, but the box number cannot
   be determined (should never happen, barring a malicious user trying to make
   it happen).  If 0 is returned, fills in key and keysize.  Key must point to
   at least 1024 bytes of memory. */
WORD WINAPI BuildKey(BYTE FAR *keyinput, BYTE FAR *key,WORD FAR *keysize);

/* **** Generic API's **** */

/* Returns a random DWORD */
DWORD WINAPI RandDWord(void);

/* **** Mapi API's **** */

HRESULTSOS WINAPI ValidateUserLogin(LPSTR lpszname, LPSTR lpszPassword,
				     DWORD FAR *lpdwSecurityHandle);

HRESULTSOS WINAPI UnvalidateUserLogin(LPSOSSESSION lpSess);

HRESULTSOS WINAPI CreateSecureUser(LPSTR lpszName, LPSTR lpszPassword);

HRESULTSOS WINAPI DeleteSecureUser(LPSTR lpszName);

#endif /* NO_MAPI */

#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __AWSEC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awpddl32.h ===
//--------------------------------------------------------------------------
//
// Module Name:  AWPDDL32.H
//
// Brief Description:  This module contains declarations for the back end
//                     interfaces for the At Work Fax Printer Device Layer.
//
// Author:  Kent Settle (kentse)
// Created: 23-Mar-1994
//
// Copyright (c) 1994 Microsoft Corporation
//
//--------------------------------------------------------------------------
#ifndef _AWPDDL32_H_
#define _AWPDDL32_H_

#ifndef LPTSTR
#ifdef UNICODE
typedef LPWSTR PTSTR, LPTSTR;
#else
typedef LPSTR PTSTR, LPTSTR;
#endif
#endif

#ifdef UNICODE
#define JOBSUMMARYDATA_NAME L"Microsoft_At_Work_Job_Summary_Data_Shared_Memory"
#else
#define JOBSUMMARYDATA_NAME "Microsoft_At_Work_Job_Summary_Data_Shared_Memory"
#endif

#define ID_JOBSUMMARYDATA   0x44534A44      // "DJSD"

typedef struct _JOBSUMMARYDATA     /* jsd */
{
    DWORD           dwID;       // "DJSD" = Device Job Summary Data.
    DWORD           dwNumPages; // number of pages contained in print job.
    DWORD           dwError;    // error code, if any.
    DWORD           dwEndID;    // "DJSD" = end of JOBSUMMARYDATA signature.
} JOBSUMMARYDATA;
typedef JOBSUMMARYDATA FAR *PJOBSUMMARYDATA;

extern BOOL AtWkFax_SetupPublish(
  DWORD xRes,
  DWORD yRes,
  DWORD PaperSize,
  DWORD PaperWidth,
  DWORD PaperLength,
  DWORD Orientation,
  DWORD Halftone,
  LPTSTR  pstrFileName,
  LPTSTR  pstrJobEvent,
  LPTSTR  pstrIDEvent,
  LPTSTR  pstrErrorEvent);

#if defined _NT_SUR_ || defined _CAIRO_
extern BOOL AtWkFax_EndPage(DWORD);
extern BOOL AtWkFax_StartDoc(DWORD, LPBYTE, DWORD, DWORD, LPTSTR);
extern BOOL AtWkFax_StartPage(DWORD);
extern BOOL AtWkFax_EndDoc(DWORD, LPBYTE, DWORD);
extern BOOL AtWkFax_WriteData(DWORD, LPBYTE, DWORD);
extern BOOL AtWkFax_Close(DWORD);
extern BOOL AtWkFax_Abort(DWORD);
extern BOOL AtWkFax_ExtDeviceMode(DEVMODE FAR *, LPTSTR);
extern BOOL AtWkFax_DeviceCapabilities(LPDEVMODE, LPTSTR);
extern DWORD AtWkFax_Open(LPDEVMODE, LPTSTR);
extern BOOL AtWkFax_Reset(DWORD, LPDEVMODE);
#else
extern BOOL FAR PASCAL AtWkFax_EndPage(DWORD);
extern BOOL FAR PASCAL AtWkFax_StartDoc(DWORD, LPBYTE, DWORD, DWORD, LPTSTR);
extern BOOL FAR PASCAL AtWkFax_StartPage(DWORD);
extern BOOL FAR PASCAL AtWkFax_EndDoc(DWORD, LPBYTE, DWORD);
extern BOOL FAR PASCAL AtWkFax_WriteData(DWORD, LPBYTE, DWORD);
extern BOOL FAR PASCAL AtWkFax_Close(DWORD);
extern BOOL FAR PASCAL AtWkFax_Abort(DWORD);
extern BOOL FAR PASCAL AtWkFax_ExtDeviceMode(DEVMODE FAR *, LPTSTR);
extern BOOL FAR PASCAL AtWkFax_DeviceCapabilities(LPDEVMODE, LPTSTR);
extern DWORD FAR PASCAL AtWkFax_Open(LPDEVMODE, LPTSTR);
extern BOOL FAR PASCAL AtWkFax_Reset(DWORD, LPDEVMODE);

#endif // !_NT_SUR_ || _CAIRO_
#endif // _AWPDDL32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awview.h ===
// Copyright (c) Microsoft Corp. 1993-95
/*==============================================================================
Interfaces to decode AWD image streams.

17-Oct-93    RajeevD    Created.
==============================================================================*/
#ifndef _VIEWREND_
#define _VIEWREND_

#include <windows.h>
#include <buffers.h>
	
#ifdef __cplusplus
extern "C" {
#endif

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC

/*==============================================================================
VIEWER INTERFACE OVERVIEW

This interface is used to decode AWD image streams.  First, ViewerOpen is called,
filling a VIEWINFO structure.  ViewerSetPage seeks to a page.  ViewerGetBand may
be called multiple times to fetch bitmaps for the next band of the page.  Finally,
ViewerClose is called to terminate the session.
==============================================================================*/

/*==============================================================================
For AWD files created by Win95 RTM, yMax will be an upper bound, possibly 72
scan lines more than the exact value.  For AWD files created with awdenc32.dll
or the SDK release of awrbae32.dll, the yMax reported will be the exact value.
==============================================================================*/
#pragma pack (push)
#pragma pack(1)
typedef struct
{
	WORD cPage;  // number of pages
	WORD xRes;   // horizontal resolution [dpi]
	WORD yRes;   // vertical resolution [dpi]
	WORD yMax;   // maximum page height [pixels]
}
	VIEWINFO, FAR* LPVIEWINFO;
#pragma pack(pop)
	
/*==============================================================================
ViewerOpen is passed a pointer to the image stream.  The caller may request 
HRAW_DATA for Windows bitmaps, where the high bit (sign) of each byte is 
leftmost in the image, or LRAW_DATA for fax bitmaps, where it is rightmost.
These constants are defined in buffers.h.

Upon return, the lpwBandSize parameter will contain the size of the band to
be allocated to receive bitmaps fetched with ViewerGetBand.  The VIEWINFO
structure will also be filled.
==============================================================================*/
LPVOID                    // returns context (NULL on failure)
WINAPI
ViewerOpen
(
	LPVOID     lpImage,     // OLE2 IStream*
	DWORD      nType,       // data type: HRAW_DATA or LRAW_DATA
	LPWORD     lpwReserved, // reserved, pass NULL
	LPWORD     lpwBandSize, // output pointer to output band size
	LPVIEWINFO lpViewInfo   // output pointer to VIEWINFO struct
);

/*==============================================================================
ViewerSetPage seeks to the current page.  The first page has index 0.
==============================================================================*/
BOOL                   // returns TRUE for success
WINAPI      
ViewerSetPage
(
	LPVOID lpContext,    // context returned from ViewerOpen
	UINT   iPage         // page index (first page is 0)
);

/*==============================================================================
ViewerGetBand may be called to fetch successive bands of a page.  Upon call,
bmBits must point to an output buffer of size determined by ViewerOpen.
Upon return, the remaining fields will be filled as follows...

	bmType        must be 0
	bmWidth       pixel width, will be same for all bands and a multiple of 32
	bmHeight      pixel height, will be same for all bands except last on page
	bmWidthBytes  will be bmWidth / 8
	bmPlanes      will be 1
	bmBitsPixel   will be 1

If there are no more bands on the page, bmHeight will be 0 and ViewerSetPage
must be called before calling ViewerGetBand again.
==============================================================================*/
BOOL                   // returns TRUE for success
WINAPI
ViewerGetBand
(
	LPVOID   lpContext,  // context returned from ViewerOpen
	LPBITMAP lpbmBand    // bitmap and bmBits to be filled
);

/*==============================================================================
ViewerClose must be called to release the context returned by ViewerOpen.
==============================================================================*/
BOOL WINAPI ViewerClose
(
	LPVOID lpContext     // context returned from ViewerOpen
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _VIEWREND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awrt.h ===
#ifndef _INC_IFAXOS
#ifndef _INC_RUNTIME
#define _INC_IFAXOS        //could be dropped once other include files stop including ifaxos.h
#define _INC_RUNTIME

#ifdef __cplusplus   //make sure everything has a "C" interface
extern "C" {
#endif

#ifndef WINDRV
#   ifdef WIN32
#       define _INC_OLE
#   endif
#   include <windows.h>
#  ifdef   WIN32
#      include <windowsx.h>
#  endif
#endif

/*
 * If using 16bit compiler, need to define some types that
 *  are now defined for the 32bit compiler
 */
#if defined (DOS16) | defined (WIN16)
#include <aw16bit.h>
#if defined (DOS16)
#include <string.h>
#define lstrlen(a) _fstrlen(a)
#endif
#endif

/*
 * Cross platform File I/O
 *   DOS16 used by lhutil
 */
#if defined (DOS16)
#include <io.h>
#define IOSEEK  _lseek
#define IOREAD  _read
#define IOWRITE _write
#define HFILE   int

#else /* WIN32 | WIN16 */
#define IOSEEK  _llseek
#define IOREAD  _lread
#define IOWRITE _lwrite
#endif /* DOS16 */


typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;


#define CARRAIGE_RETURN 0x0D
#define LINEFEED 0x0A
#define BACKSPACE 0x08
#define CNULL   0x00

#ifndef WIN32
#ifndef MAKEWORD
#  define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif
#  define EXPORT_DLL
#  define IMPORT_DLL
#else
#  ifndef HTASK
#     define HTASK HANDLE
#  endif
#  define __export __declspec( dllexport )
#  define _export  __declspec( dllexport )
#  define IMPORT_DLL __declspec( dllimport )
#  define EXPORT_DLL __declspec( dllexport )
#endif

// --------------- RESOURCE management -------------------------------

// Always define this for now ...
#ifndef SHIP_BUILD
// #if defined(VALIDATE) || defined(DEBUGAPI) || defined(DEBUG)

/********
    @doc    EXTERNAL    RESOURCE IFAXOS

    @type   VOID |  RESOURCE_ALLOC_FLAGS | Lists the resource management options
            for OS resource accounting.

    @emem   RES_ALLOC_TASK  |  This flag indicates that the resource in question
            is being allocated on behalf of the current process. The resource
            should not be directly passed on to any other process context. It
            should be freed by this process before termination - else the kernel
            will free it when the process dies (if running in debug).
            Ownership automatically gets transferred between tasks when standard
            IPC methods like pipes are used to transfer resources like Buffers.

    @emem   RES_ALLOC_NONE  | This flag is used to allocate resources which should
            not be accounted to any system module. The calling party essentially
            undertakes full responsibility for freeing this object. This is mainly
            to be used for resource allocated on behalf of messages in the store
            since their ownership is transferred to the current process which has
            the message open.

    @emem   HINSTANCE_DLL   | If the allocated resource is to be assigned to the
            calling DLL, the hinstance of the DLL should be passed in as the value
            of the ResourceFlags Word. These resources will be freed (in the debug
            version) when the DLL terminates. They will not be assigned to any
            particular process context.

    @xref   <f IFBufAlloc> <f IFMemAlloc> <f CreateMutex> <f CreateEvent>
            <f IFPipeCreate> <f IFProcSetResFlags>
********/

#define RES_ALLOC_TASK  0x0000
#define RES_ALLOC_NONE  0x0001
#define RES_ALLOC_INTERNAL  0x0002
#define RES_ALLOC_CRITSEC  0x0003

#if defined(WFW) || defined(WIN32)

#define IFProcSetResFlags(wResFlags)  (0)

#else

extern EXPORT_DLL VOID WINAPI IFProcSetResFlags(WORD wResFlags);

#endif

#else

#define IFProcSetResFlags(p1) (0)

#endif

// Functions -----------
#ifndef WIN32
HTASK   WINAPI GetWindowTask(HWND hwnd);
#ifndef SHIP_BUILD
DWORD   WINAPI IFProcProfile(HTASK hTask, BOOL fStart);
#else
#define IFProcProfile(HTASK,FSTART) (0)
#endif
#else
// Remove calls to Profile ..
#define IFProcProfile(x,y)    (DWORD)(0)
#endif


#ifdef DEBUG

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   RETAILMSG    |   Prints a message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           RETAILMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf>
********/
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   WARNINGMSG    |   Prints a warning message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           WARNINGMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           WARNING: 0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf> <f ERRORMSG>
********/
#define WARNINGMSG(printf_exp)   \
   (IFDbgPrintf("WARNING:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGMSG    |   Prints a trace message on the debug
           console depending on enable flags set by the user.

   @parm   <lt>c_expression<gt>    |   cond    |   Boolean condition which is
           evaluated to decide whether or not to print the message.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @rdesc  TRUE if the message is printed, and FALSE if it is not.

   @comm   The condition should consist of a boolean expression testing whether
           the relevant zones are on or off.  Each module has a current zone
           mask which identifies which of the possible 32 zones is currently on.
           The top 16 bits of these are reserved for use for system defined
           zones - like ZONE_FUNC_ENTRY which is defined as

           #define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)

            Modules should take care to see
           that they print out trace messages which are meaningful and conform
           to some pattern - remember that other people than you have to see
           and make sense of your messages. The general format I have been
           following is :

           <lt>Task ID<gt> :
           <lt>ModuleName<gt>:<lt>SubModule<gt>:<lt>Function<gt>:<lt>msg<gt>

           The task ID is useful to sort out the output of multiple tasks
           running in the system.  The example call above yields this kind of
           output.

           The various predefined system zones are:
               ZONE_FUNC_ENTRY : To be used for all function entry and exit
                   messages. By convention, the parameters should be printed
                   on entry, and the return value should be printed on exit.
                   Any values printed in hexadecimal should be preceded by a 0x
               ZONE_INT_FUNC : To be used for any other traces at interesting
                   points within a function.

           All trace messages are disabled in a non debug build.

   @ex     Example Definition & Use |

           #define ZONE_CUSTOM (0x00000001&dpCurSettings.ulZoneMask)

           DEBUGMSG (ZONE_FUNC_ENTRY && ZONE_CUSTOM,
                       ("0x%04X:IFK:Buffers:GenericFunction:Entry\r\n",
                       GetCurrentTask()));

           This will print a trace message only if the user has turned the
           function entry zone and the custom zone on.

   @xref   <f IFDbgPrintf>
********/
#define BG_CHK(exp)    \
   ((exp)?1:(              \
       IFDbgPrintf ("DEBUGCHK failed in file %s at line %d \r\n",  \
                 (LPSTR) __FILE__ , __LINE__ ), 1  \
            ))

#ifndef DEBUGCHK_UNSAFE_IN_WFWBG


#define DBGCHK(module,exp) \
   ((exp)?1:(          \
       IFDbgPrintf ("%s: DEBUGCHK failed in file %s at line %d \r\n", \
                 (LPSTR) module, (LPSTR) __FILE__ , __LINE__ ),    \
       IFDbgCheck() \
            ))

#define DEBUGCHK(exp) DBGCHK(dpCurSettings.lpszName, exp)

#endif


#if 0
#define DEBUGMSG(cond,printf_exp)   \
   ((cond)?(IFDbgPrintf printf_exp),1:0)
#endif

#define DEBUGMSG(cond,printf_exp)   \
   (IFDbgPrintf printf_exp)



   /********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   ERRORMSG    |   Prints an error message on the debug
           console.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display Error messages.

   @ex     Example Definition & Use |

           ERRORMSG (("0x%04X:JOB Failed !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           ERROR: Job Process: 0x2346: JOB Failed !!

   @xref   <f IFDbgPrintf>
********/
#define ERRORMSG(printf_exp)   \
   (IFDbgPrintf("ERROR:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)

// Standard Debug zones
#define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)
#define ZONE_INT_FUNC   (0x00020000&dpCurSettings.ulZoneMask)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGSTMT   |   Evaluates the expression in debug mode.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be evaluated.

   @rdesc  Returns the value returned by the expression.

   @comm   This macro is provided for convenience and code readability purposes
           to replace a construct of the form

               #ifdef DEBUG
               exp;
               #endif

           It evaluates to zero in a non debug build.

********/

#define DEBUGSTMT(exp) exp


#else         //Not Debug
// These are to macro out all debug stuff in retail/ship builds
#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)
#define DEBUGMSG(cond,expr)  (0)
#define DBGCHK(module,exp) (0)
#define DEBUGCHK(exp) (0)
#define BG_CHK(exp) (0)
#define DEBUGSTMT(exp) (0)

#endif


//----------------------------- MESSAGING -------------------------

// Message type definitions  - below 0x0400 is reserved by windows,
// between 0x0400 and 0x0800 is reserved by the IFAX OS

#define IF_START        WM_USER+0x0300
#define IF_USER         IF_START+0x0400


#include <errormod.h>

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULES  | Identifiers for all the standard system modules.

    @emem   MODID_NONE          | Use this if you are not setting the module ID. DONT USE ZERO !!
    @emem   MODID_WIN32         | Set for modules returning standard Win32 system error codes
    @emem   MODID_BOSS          | ID = 1    Error in BOSS
    @emem   MODID_WINMODULE     | ID = 2    All windows modules including UER/GDI/KERNEL
    @emem   MODID_IFKERNEL      | ID = 3
    @emem   MODID_IFFILESYS     | ID = 4
    @emem   MODID_MSGSTORE      | ID = 5
    @emem   MODID_LINEARIZER    | ID = 6
    @emem   MODID_SECURITY      | ID = 7
    @emem   MODID_IFPRINT       | ID = 8    High level Printer Driver
    @emem   MODID_IFSCAN        | ID = 9    High level Scanner Driver
    @emem   MODID_IFSIPX        | ID = 10   SPX/IPX Stack
    @emem   MODID_REND_SERVER   | ID = 11   Rendering Server
    @emem   MODID_FORMAT_RES    | ID = 12   Format Resolution
    @emem   MODID_IFFILE        | ID = 13   IFFiles
    @emem   MODID_TEXTRENDERER  | ID = 14   Ascii Renderer
    @emem   MODID_DIGCOVPAGE    | ID = 15   Digital Coverpage
    @emem   MODID_AWBRANDER     | ID = 16   Fax Brander
    @emem   MODID_MSGSVR        | ID = 17   Message Server
    @emem   MODID_MSGHNDLR      | ID = 18  Per-Connection message handler
    @emem   MODID_MODEMDRV      | ID = 19  Modem driver
    @emem   MODID_PSIFAX       | ID = 20   PSI Fax protocol
    @emem   MODID_AWT30            | ID = 21
    @emem   MODID_PSIFAXBG     | ID = 22
    @emem   MODID_AWNSF            | ID = 23
    @emem   MODID_FAXCODEC      | ID = 24
    @emem   MODID_MSGPUMP       | ID = 25
    @emem   MODID_AWREPORT      | ID = 26
    @emem   MODID_MSGSVRD               | ID = 27


    @emem   MODID_CUSTOM        | ID = 160  Beyond this are custom/installable modules

    @xref   <f IFErrAssemble> <f IFErrGetModule>
********/
// System Module IDs
#define MODID_WIN32         0
#define MODID_BOSS          1
#define MODID_WINMODULE     2
#define MODID_IFKERNEL      3
#define MODID_IFFILESYS     4
#define MODID_MSGSTORE      5
#define MODID_LINEARIZER    6
#define MODID_SECURITY      7
#define MODID_IFPRINT       8
#define MODID_IFSCAN        9
#define MODID_IFSIPX        10
#define MODID_REND_SERVER   11
#define MODID_FORMAT_RES    12
#define MODID_IFFILE        13
#define MODID_TEXTRENDERER  14
#define MODID_DIGCOVPAGE    15
#define MODID_AWBRANDER     16
#define MODID_MSGSVR        17
#define MODID_MSGHNDLR      18
#define MODID_MODEMDRV     19
#define MODID_PSIFAX       20
#define MODID_AWT30            21
#define MODID_PSIFAXBG     22
#define MODID_AWNSF            23
#define MODID_FAXCODEC      24
#define MODID_MSGPUMP       25
#define MODID_AWREPORT      26
#define MODID_MSGSVRD           27

#define MAXMODID              26

#define MODID_NONE          159

// Special module ID's
#define MODID_CUSTOM        160


/********
    @doc    EXTERNAL    ERROR   IFAXOS

    @api    DWORD    | IFErrAssemble   | Forms an IFAX Error dword out of its components.

    @parm   BYTE    | bProcessID    | Identifies the process in whose context the error
            occured. Must be one of the predefined system process ID's - see <t SYSTEM_PROCESSES>
            for the list. This field does not need to be filled in until an error is
            propagated across a process boundary. If not being set to a valid PROCID, this
            should be initilialized to one of the following values:
            @flag  PROCID_WIN32 | if <p bModuleID> is set to MODID_WIN32.
            @flag  PROCID_NONE | for all other cases.

    @parm   BYTE    | bModuleID | Identifies the module reporting the error. MUST be
            one of the predefined system module ID's - see <t SYSTEM_MODULES> for the
            list.

    @parm   WORD    | wApiCode  | Identifies the API code for the error in the module indicated
            by <p bModuleID>. All Api codes should be defined in the file errormod.h. Api codes should
            be defined so that the low 6 bits are zero. This allows both the <p wApiCode> and the
            <p wErrorCode> to be logical OR'ed together and stored as a single word.

    @parm   WORD    | wErrorCode    | Identifies the error code. The format
            of this is module dependent. For uniformity however, it is highly
            encouraged that all IFAX modules use a standard format for this error word.
            This standard format reserves the first 6 bits for an error code,
            and the high 10 bits for an API identifier.

            If the IFAX format is being used, the <p wApiCode>
            parameter should be used to pass in the high 10 bits, and the <p wErrorCode> (This
            parameter!) should be used to pass in the 6 bit error code. Values upto ERR_FUNCTION_START
            are reserved for standard system errors - see <t SYSTEM_ERROR_VALUES> for the list.
            Error values should be positive and less than 64.

            Other modules like the filesystem conform completely to the Win32 Error space. These
            should set <p wErrorCode> to standard Win32 errors (use all 16 bits) and leave
            the <p wApiCode> as API_WIN32.

            Still others need to use all 16 bits in a custom manner - like the Printer Drivers.
            These *must* set the <p bModuleID> correctly so that the error can be interpreted
            appropriately. Standard processes like the UI have to understand these error codes,
            so only inbuilt system modules which they have knowledge about can use custom codes.
            These should set the wApiCode to API_NONE.

    @rdesc  Returns the DWORD representation for this error. This allows this to be directly
            passed in as input to <f SetLastError>.

    @ex     Example usage |

            SetLastError(IFErrAssemble(PROCID_NONE,MODID_IFKERNEL,API_IFK_POSTMESSAGE,ERR_INVALID_PARAM));

    @xref   <f IFErrGetModule> <f IFErrGetProcess> <f GetIFErrorErrcode> <f SetLastError>
            <f GetIFErrorApicode> <t SYSTEM_MODULES> <t SYSTEM_PROCESSES> <t SYSTEM_ERROR_VALUES>
            <f GetLastError> <f IFNVRamSetError> <f GetIFErrorCustomErrcode>
********/

#define IFErrAssemble(process,module,call,error) \
    MAKELONG((WORD)call|(WORD)error, MAKEWORD((BYTE)module, (BYTE)process))
#define GetIFErrorErrcode(errvar)   (LOWORD((DWORD)errvar) & 0x003F)
#define GetIFErrorCustomErrcode(errvar) LOWORD((DWORD)errvar)

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_PROCESSES  | Identifiers for all the standard system processes.

    @emem   PROCID_WIN32        | Used to initialize for Win32 modules.
    @emem   PROCID_NONE         | Used when process context does not need to be set.
    @emem   PROCID_MSGSCHED     | ID = 0x21
    @emem   PROCID_JOBPROCESS   | ID = 0x22
    @emem   PROCID_UI           | ID = 0x23
    @emem   PROCID_PRINTER      | ID = 0x24
    @emem   PROCID_SCANNER      | ID = 0x25
    @emem   PROCID_MSGSVR       | ID = 0x26
    @emem   PROCID_GRRENDER     | ID = 0x27
    @emem   PROCID_MSGHNDLR     | ID = 0x28
    @emem   PROCID_PARADEV              | ID = 0x29
    @emem   PROCID_UIBGPROC     | ID = 0x30

    @comm   All Process ID's need to have the 6th bit set to be compatible with the
            standard Win32 error definitions.

    @xref   <f IFErrAssemble> <f IFErrGetProcess>
********/
// System Process IDs
#define PROCID_WIN32           0x00
#define PROCID_NONE            0x20
#define PROCID_MSGSCHED        0x21
#define PROCID_JOBPROCESS      0x22
#define PROCID_UI              0x23
#define PROCID_PRINTER         0x24
#define PROCID_SCANNER         0x25
#define PROCID_MSGSVR          0x26
#define PROCID_GRRENDER        0x27
#define PROCID_MSGHNDLR        0x28
#define PROCID_PARADEV         0x29
#define PROCID_UIBGPROC            0x30

// Strings used in debug version for friendly display
#define MAXPROCID  11
#define SYSPROCESSSTRINGS       \
    {"None", "Msg Scheduler", "Job Process", "UI Process", "Printer", "Scanner", \
     "Msg Transport", "GR Renderer", "Msg Handler", "Para Dev", "UIBGProc"  }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

   @type   VOID | SYSTEM_ERROR_VALUES | This defines all the standard
           system error values.

   @emem   ERR_NOT_ENOUGH_MEM | Value = 0x0001 : Indicates an out of memory
           condition.

   @emem   ERR_INVALID_PARAM | Value = 0x0002 : Indicates that any one of
           the parameters passed to the function was invalid.

   @emem   ERR_FUNCTION_START | Value = 0x0010 : Any error value above this
           had been custom defined by the called function. If you need
           a custom error value, you can define it starting from this
           value.

   @xref   <f IFErrAssemble>
********/

// System Error values
#define ERR_NOT_ENOUGH_MEM  0x0001
#define ERR_INVALID_PARAM   0x0002
#define ERR_FUNCTION_START  0x0010

// Strings used in debug version for friendly display
#define SYSERRORSTRINGS \
    {"None", "Out Of Memory", "Invalid Param", "Unused", "Unused", "Unused",  \
    "Unused", "Unused", "Unused", "Unused", "Unused", "Unused", \
    "Unused", "Unused", "Unused", "Unused" }


#include <buffers.h>

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc> <f IFBufAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc> <f IFBufAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

//
#define RAW_DATA_SIZE       -3      // 8Kb

// Special size for modem ECM frame
#define BYTE_265_SIZE       -4      // 265 bytes
#define BYTE_265_ACTUALSIZE 265

// Number of sizes
#define MAX_POOL_INDEX  -4          // For parameter validation

// Not available yet!
#define BAND_BUFFER_SIZE    30720      // 64Kb

// Flag to force global alloc. Uses a windows flag which is ignored/defunct in
// the 3.1 kernel (and the boss kernel)
#define IFMEM_USEGLOBALALLOC GMEM_NOT_BANKED


typedef struct _DBGPARAM {
   CHAR    lpszName[32];           // name of module
   HWND    hwnd;                   // Primary window Handle if task, NULL otherwise
   CHAR    rglpszZones[16][32];    // names of zones for first 16 bits
   ULONG   ulZoneMask;             // Zone Mask
}   DBGPARAM, FAR *LPDBGPARAM;


// Functions
extern LPBUFFER  IFBufAlloc (LONG lBufSize);
extern BOOL  IFBufFree (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufSplit (LPBUFFER lpbf, LPBYTE lpb);

extern VOID FAR IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

extern LPVOID  IFMemAlloc (UINT fuAlloc, LONG lAllocSize,
                                  LPWORD lpwActualSize);
extern BOOL  IFMemFree (LPVOID lpvMem);



/***********************************************************************
 *
 * Standard Memory Allocation Routines
 *    for easy crossplatform development
 *    with resource tracking code.
 * Routines are in MEMORY.C
 *
 ***********************************************************************/
#ifndef NOSTD_MEM_RTNS
PVOID WINAPI AWMemAlloc(UINT cb);
PVOID WINAPI AWMemReAlloc(PVOID pv, UINT cb);
PVOID WINAPI AWMemFree(PVOID pv);
#endif /* NOSTD_MEM_RTNS */

/***********************************************************************
 *
 * Registry functions prototypes
 *
 ***********************************************************************/
// registry functions prototypes
UINT AwGetInitializerInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey, INT dwDefault,
  LPCTSTR lpszFile);
DWORD AwGetInitializerString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszDefault, LPTSTR lpszReturnBuffer, DWORD cchReturnBuffer,
  LPCTSTR lpszFile);
BOOL AwWriteInitializerString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile);
BOOL AwWriteInitializerInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  DWORD i, LPCTSTR lpszFile);

// Encourage people to use the correct variable
extern DBGPARAM dpCurSettings;

#ifdef __cplusplus
} // extern "C" {
#endif

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\awrc32.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by awfax32.rc
//
#define MAWF_MESSAGE                    100
#define MAWF_DELIVERY                   101
#define MAWF_DEVICE                     102
#define MAWF_SENDER                     103
#define MAWF_SETTIME                    104
#define MAWF_PERMESSAGE					105
#define MAWF_PRINTED_MESSAGE			106
#define MAWF_DELIVERY_CHEAP				107
#define MAWF_SELECTDRIVE				108
#define MAWF_SECURITY					109
#define MAWF_DEVICE_ADD					110
// #define MAWF_WIZARD						111
#define MAWF_TOLL_LIST                  112
#define MAWF_W_NOT_IMPLEMENTED          102
#define MAWF_W_MUST_SELECT_ITEM         104
#define MAWF_W_RESBAD                   105
#define MAWF_W_TAPI_REINIT              113
#define MAWF_W_NO_MODEM                 114
#define MAWF_W_TAPI_LINE_CLOSE          115
#define MAWF_W_TAPI_LOC_NOT_FOUND       116
#define MAWF_W_MUST_BE_NUMBER           117
#define MAWF_W_PROFILE_CORRUPTED        202
#define MAWF_W_NO_REQUIRED_PROPS        203
#define MAWF_W_CP_FILEEXISTS            204
#define MAWF_W_CP_FILE_IN_WIN           205
#define MAWF_W_CPE_STILL_RUNS           206
#define MAWF_W_SENDER_NAME              207
#define MAWF_W_SENDER_NUMBER            208
#define MAWF_W_FAX_DEVICE               209
#define MAWF_W_NO_SHARE_FOLDER          210
#define MAWF_W_MUST_SENDER_NAME         211
#define MAWF_W_MUST_FAX_NUMBER          212
#define MAWF_W_NO_FAX_DEVICE            213
#define MAWF_W_LMI_DLL_LOAD_FAIL        214
#define MAWF_W_CFG_DLL_LOAD_FAIL        215
#define MAWF_W_LMI_ADD_FAILED           216
#define MAWF_W_CANT_REMOVE_LOCAL_MODEM  217
#define MAWF_W_LMI_REMOVE_FAILED        218
#define MAWF_W_SHARE_NAME_TRUNC         220
#define MAWF_W_NO_SHARE_USERS           221
#define MAWF_W_OLD_VERSION				222
#define MAWF_W_CREATE_PROFILE			223
#define MAWF_E_GENERIC                  500
#define MAWF_E_MAPI_DLL_LOAD_FAIL       501
#define MAWF_E_MAPI_LOGON_FAIL          502
#define MAWF_E_MAPI_LOGOFF_FAIL         503
#define MAWF_E_NO_MEM                   504
#define MAWF_E_WRONG_WINDOWS_VERSION    507
#define MAWF_E_MAWF_DLL_LOAD_FAIL       509
#define MAWF_E_FILE_NOT_FOUND           511
#define MAWF_E_UNKNOWN                  512
#define MAWF_E_TAPI_CONFIG_DLG          514
#define MAWF_E_TAPI_LOC_CORRUPT         515
#define MAWF_E_TAPI_CANT_INIT           516
#define MAWF_E_MORE_THAN_ONE_INSTANCE   601
#define MAWF_E_CP_FILECOPY              602
#define MAWF_E_INVALID_SHARE_NAME       603
#define MAWF_E_BAD_SHARE_FOLDER         604
#define MAWF_E_CANT_SHARE               605
#define MAWF_E_DUP_SHARE                606
#define IDH_NO_CONTEXT                  998
#define IDH_COMM_GROUPBOX               999
#define IDS_MAWF_NAME                   1000
#define IDS_AWF_NAME                    1001
#define IDS_FAX_NAME                    1002
#define IDS_INFORMATION_MESSAGE         1003
#define IDS_WARNING_MESSAGE             1004
#define IDS_CRITICAL_MESSAGE            1005
#define IDS_HELP_FILE_NAME              1006
#define IDS_CPE_FILE_NAME               1008
#define IDS_TAPI_LINE_NAME              1010
#define IDS_TAPI_ADDRESS_NAME           1011
#define IDS_TAPI_CC_UNKNOWN             1012
#define IDS_NONE                        1014
#define IDS_DEFAULT_COUNTRY_ID          1015
#define IDS_DEV_NAMES            		1016
#define IDS_QA_NAMES		           	1017
#define IDS_PMBLD_NAMES					1018
#define IDS_APP_NAME                    1050
#define IDS_CFG_INI_FILE_NAME           1051
#define IDS_MODULE_NAME                 1052
#define IDS_NO_MODEM                    1053
#define IDS_ACTIVE_FAX_LABEL            1054
#define IDS_LOCATION_LABEL              1055
#define IDS_TOLL_DLG_OVH_TEXT			1056
#define IDS_TOLL_DLG_CUR_LB_LABEL		1057
#define IDS_TOLL_DLG_XXXX				1058
#define M_SEND_WHEN_START               1120
#define IDS_SEND_WHEN_HOUR              1121
#define IDS_SEND_WHEN_MINUTE            1122
#define M_SEND_WHEN_END                 1123
#define M_PAPER_SIZE_START              1130
#define IDS_PAPER_US_LETTER             1131
#define IDS_PAPER_US_LEGAL              1132
#define IDS_PAPER_A4                    1133
#define IDS_PAPER_B4                    1134
#define M_PAPER_SIZE_END                1135
#define	IDS_DEFAULT_PAPER_SIZE_METRIC	1138
#define	IDS_DEFAULT_PAPER_SIZE_US		1139
#define M_IMAGE_QUALITY_START           1140
#define IDS_QUALITY_BEST                1141
#define IDS_QUALITY_STANDARD            1142
#define IDS_QUALITY_FINE                1143
#define IDS_300DPI                      1144
#define M_IMAGE_QUALITY_END             1145
#define M_CHEAP_BEGIN_START             1150
#define IDS_CHEAP_BEGIN_HOUR            1151
#define IDS_CHEAP_BEGIN_MINUTE          1152
#define M_CHEAP_BEGIN_END               1153
#define M_CHEAP_END_START               1160
#define IDS_CHEAP_END_HOUR              1161
#define IDS_CHEAP_END_MINUTE            1162
#define M_CHEAP_END_END                 1163
#define M_NUM_OF_RINGS_START            1180
#define IDS_NUM_OF_RINGS_2              1181
#define IDS_NUM_OF_RINGS_3              1182
#define IDS_NUM_OF_RINGS_4              1183
#define IDS_NUM_OF_RINGS_5              1184
#define IDS_NUM_OF_RINGS_6              1185
#define IDS_NUM_OF_RINGS_7              1186
#define IDS_NUM_OF_RINGS_8              1187
#define IDS_NUM_OF_RINGS_9              1188
#define IDS_NUM_OF_RINGS_10             1189
#define M_NUM_OF_RINGS_END              1190
#define M_FAX_DEVICES_START             1192
#define IDS_PC_FAX                      1193
#define IDS_FAX_SERVER                  1194
#define M_FAX_DEVICES_END               1195
#define IDS_IFAX_MACHINE                1196
#define M_COVER_PAGE_START              1200
#define IDS_MSC_CPFILEEXT               1201
#define IDS_MSC_COMDLGPAT               1202
#define IDS_MSC_COMDLGTITLE             1203
#define IDS_DEFAULT_COVER_PAGE          1204
#define M_COVER_PAGE_END                1205
#define M_SHARE_DIR_START               1210
#define IDS_SHARE_COMDLGTITLE           1211
#define IDS_SHARE_COMDLGPAT             1212
#define IDS_SHARE_PATH                  1213
#define IDS_SHARE_COMMENT               1214
#define IDS_DEFAULT_SHARE_NAME			1215
#define M_SHARE_DIR_END                 1216
#define IDS_HELP_FILENAME				1220
#define IDS_CPE_FILENAME				1221
#define IDS_DEFAULT_RETRIES				1230
#define IDS_MAX_RETRIES					1231
#define IDS_DEFAULT_TIME_BET_RETRIES	1232
#define IDI_FAXCFG_ICON                 1301
#define IDI_DIALING_ICON                1302
#define IDI_USER_ICON                   1303
#define IDI_MODEM_ICON                  1304
#define IDI_MESSAGE_ICON                1305
#define CONTROLS_START                  2000
#define IDC_SEND_AS_GROUPBOX            2000
#define IDC_SEND_BEST_AVAIL             2001
#define IDC_SEND_AS_EMAIL               2002
#define IDC_SEND_AS_FAX                 2003
#define IDC_SEND_ASAP                   2004
#define IDC_SEND_AT_CHEAP               2005
#define IDC_SEND_AT_TIME                2006
#define IDC_SET_CHEAP_TIME              2007
#define IDC_SEND_WHEN_HOUR              2008
#define IDC_TIME_SEP                    2009
#define IDC_SEND_WHEN_MINUTE            2010
#define IDC_SEND_WHEN_AMPM              2011
#define IDC_TIME_ARROW                  2012
#define IDC_BILLING_CODE_LABEL          2015
#define IDC_BILLING_CODE                2016
#define IDC_MORE_OPTIONS                2017
#define IDC_TIME_BORDER                 2018
#define IDC_PRINTED_FORMAT_OPTIONS      2019
#define IDC_DELIVERY                    2021
#define IDC_SECURITY                    2022
#define IDC_GENERAL                     2023
#define IDC_CP_INCLUDE                  2030
#define IDC_CP_BEGIN_MSG_ON             2031
#define IDC_CP_OPEN                     2032
#define IDC_CP_LIST                     2033
#define IDC_CP_NEW                      2034
#define IDC_CP_BROWSE                   2035
#define IDC_CP_SET_DEFAULT              2036
#define IDC_SET_TIME                    2037
#define IDC_COVER_PAGE_GROUPBOX         2038
#define IDC_SEND_WHEN_GROUPBOX          2039
#define IDC_OVH_TEXT                    2040
#define IDC_IPMDOC						2041
#define IDC_MODEM_SETTINGS              2101
#define IDC_MODEM_ADD                   2102
#define IDC_MODEM_REMOVE                2103
#define IDC_AVAIL_FAX_DEVICES           2104
#define IDC_AVAIL_FAX_DEVICES_LIST      2105
#define IDC_MODEM_SET_ACTIVE            2106
#define IDC_MODEM_SHARE_GROUPBOX        2110
#define IDC_MODEM_SHARE_CHECKBOX        2111
#define IDC_SHARE_REQUIRE_PASSWD        2112
#define IDC_WORK_OFFLINE                2113
#define IDC_SHARE_NAME                  2114
#define IDC_SHARE_NAME_LABEL            2115
#define IDC_SHARE_PASSWD                2116
#define IDC_FAXMODEM_GROUPBOX           2117
#define IDC_SHARE_PROPERTIES            2118
#define IDC_AVAIL_FAX_DEVICES_LABEL     2119
#define IDC_SHARE_TEXT                  2120
#define IDC_MODEM_OVH_TEXT              2121
#define IDC_SHARE_PATHNAME              2122
#define MAWFRecipient                   2200
#define IDC_RECIP_DISPLAY_NAME_LABEL    2201
#define IDC_RECIP_DISPLAY_NAME          2202
#define IDC_RECIP_FAX_NUMBER_GROUPBOX   2203
#define IDC_RECIP_COUNTRY_CODE_LABEL    2204
#define IDC_RECIP_COUNTRY_CODE          2205
#define IDC_RECIP_FAX_NUMBER_LABEL      2206
#define IDC_RECIP_FAX_NUMBER_AREA_CODE  2207
#define IDC_RECIP_FAX_NUMBER_LABEL2     2208
#define IDC_RECIP_FAX_NUMBER            2209
#define IDC_RECIP_MAILBOX_LABEL         2210
#define IDC_RECIP_MAILBOX               2211
#define IDC_RECIP                       2212
#define IDC_RECIP_DIAL_HELPER           2213
#define IDC_RECIP_DIAL_LONG_DISTANCE    2214
#define IDC_PAPER_SIZE_LABEL            2301
#define IDC_PAPER_SIZE                  2302
#define IDC_PAPER_PORTRAIT              2303
#define IDC_PAPER_LANDSCAPE             2304
#define IDC_IMAGE_QUALITY_LABEL         2305
#define IDC_IMAGE_QUALITY               2306
#define IDC_ORIENTATION_LABEL           2307
#define IDC_MUST_RENDER_ATTACH          2308
#define IDC_RETRIES_GROUPBOX            2401
#define IDC_NUMBER_OF_RETRIES_LABEL     2403
#define IDC_NUMBER_OF_RETRIES           2404
#define IDC_TIME_BET_RETRIES_LABEL1     2405
#define IDC_TIME_BET_RETRIES            2406
#define IDC_TIME_BET_RETRIES_LABEL2     2407
#define IDC_DEVELOPERS_NAMES            2408
#define IDC_DEVELOPERS_BUTTON           2409
#define IDC_DIALING_INFO_LABEL          2410
#define IDC_DIALING_INFO                2411
#define IDC_EDIT_TOLL_LIST_LABEL        2413
#define IDC_DIALING_GROUPBOX            2414
#define IDC_EDIT_TOLL_LIST              2415
#define IDC_RD_NOENCRYPT                2501
#define IDC_RD_KEYENCRYPT               2502
#define IDC_RD_PWDENCRYPT               2503
#define IDC_CK_DIGSIG                   2504
#define IDC_TXT_KEYENCRYPT              2505
#define IDC_TXT_DIGSIG                  2506
#define IDC_GRP_ENCRYPTMETHOD           2507
#define IDC_TOLL_LIST_ADD               2601
#define IDC_TOLL_LIST_REMOVE            2602
#define IDC_TOLL_LIST_ALL_LB            2603
#define IDC_TOLL_LIST_CURRENT_LB        2604
#define IDC_TOLL_LIST_ADD_ALL			2605
#define IDC_TOLL_LIST_REMOVE_ALL		2606
#define IDC_TOLL_LIST_ALL_LB_LABEL      2607
#define IDC_TOLL_LIST_CURRENT_LB_LABEL  2608
#define IDC_RECIP_FAX_PRIMARY           2901
#define IDC_RECIP_FAX_ALTERNATE         2902
#define IDC_USE_ALTERNATE               2903
#define IDC_RECIP_MACHINE_TYPE          2905
#define IDC_SENDER_NAME_LABEL           3101
#define IDC_SENDER_NAME                 3102
#define IDC_SENDER_ADDR_GROUPBOX        3105
#define IDC_SENDER_MAILBOX_LABEL        3106
#define IDC_SENDER_MAILBOX              3107
#define IDC_SENDER_COUNTRY_CODE_LABEL   3108
#define IDC_SENDER_COUNTRY_CODE         3109
#define IDC_SENDER_FAX_NUMBER_LABEL     3110
#define IDC_SENDER_FAX_NUMBER_AREA_CODE 3111
#define IDC_SENDER_FAX_NUMBER_LABEL2    3112
#define IDC_SENDER_FAX_NUMBER           3113
#define IDC_SENDER_COMPANY_LABEL        3115
#define IDC_SENDER_COMPANY              3116
#define IDC_SENDER_ADDRESS_LABEL        3117
#define IDC_SENDER_ADDRESS              3118
#define IDC_SENDER_TITLE_LABEL          3119
#define IDC_SENDER_TITLE                3120
#define IDC_SENDER_DEPT_LABEL           3121
#define IDC_SENDER_DEPT                 3122
#define IDC_SENDER_OFFICE_LOC_LABEL     3123
#define IDC_SENDER_OFFICE_LOC           3124
#define IDC_SENDER_OFFICE_TL_LABEL      3125
#define IDC_SENDER_OFFICE_TL            3126
#define IDC_SENDER_HOME_TL_LABEL        3127
#define IDC_SENDER_HOME_TL              3128
#define IDC_SENDER_OVH_TEXT             3129
#define IDC_SENDER_FAX_NUMBER_LABEL1    3130
#define IDC_START_CHEAP_RATES_LABEL     3301
#define IDC_CHEAP_BEGIN_TBORDER         3302
#define IDC_CHEAP_BEGIN_HOUR            3303
#define IDC_TIME_SEP1                   3304
#define IDC_CHEAP_BEGIN_MINUTE          3305
#define IDC_CHEAP_BEGIN_AMPM            3306
#define IDC_CHEAP_BEGIN_TARROW          3307
#define IDC_END_CHEAP_RATES_LABEL       3308
#define IDC_CHEAP_END_TBORDER           3309
#define IDC_CHEAP_END_HOUR              3310
#define IDC_TIME_SEP2                   3311
#define IDC_CHEAP_END_MINUTE            3312
#define IDC_CHEAP_END_AMPM              3313
#define IDC_CHEAP_END_TARROW            3314
#define IDC_WIZARD_INFO_TEXT            3401
#define IDC_WIZARD_DONE_TEXT            3402
#define IDC_WIZARD_CLICK_NEXT           3403
#define IDC_ANSWER_OVH_TEXT             3410
#define IDC_ANSWER_MODE_AUTO            3411
#define IDC_ANSWER_MODE_NO              3412
#define IDC_NUMBER_OF_RINGS             3414
#define IDC_ANSWER_YES_TEXT1            3415
#define IDC_ANSWER_NO_TEXT	            3416
#define IDC_ANSWER_YES_TEXT2            3417
#define IDC_ANSWER_YES_TEXT3            3418
#define IDC_DEVTYPE_OVH_TEXT			3419
#define IDC_DEVTYPE_LOCAL				3420
#define IDC_DEVTYPE_OTHER				3421
#define IDC_DEVTYPE_LOCAL_TEXT			3422
#define IDC_DEVTYPE_OTHER_TEXT			3423
#define IDC_DRIVE_LIST                  3501
#define IDC_DRIVE_LIST_LABEL            3502
#define IDC_ADD_FAX_LIST                3601
#define IDC_ADD_FAX_LIST_LABEL          3602
#define IDC_HAVE_DISK                   3603
#define IDC_DISPLAY_NAME                3605
#define CONTROLS_END                    3606
#define M_SAVE_NAMES_START              4000
#define IDS_SN_PRODUCT_NAME             4000
#define IDS_SN_SEND_AS                  4001
#define IDS_SN_BILLING_CODE             4002
#define IDS_SN_INCLUDE_COVER_PAGE       4003
#define IDS_SN_BGN_MSG_ON_COVER         4004
#define IDS_SN_CHEAP_TIME_BEGIN_HOUR    4005
#define IDS_SN_CHEAP_TIME_BEGIN_MINUTE  4006
#define IDS_SN_CHEAP_TIME_END_HOUR      4007
#define IDS_SN_CHEAP_TIME_END_MINUTE    4008
#define IDS_SN_NUMBER_RETRIES           4009
#define IDS_SN_MINUTES_BETWEEN_RETRIES  4010
#define IDS_SN_PRINT_ORIENTATION        4011
#define IDS_SN_PAPER_SIZE               4012
#define IDS_SN_IMAGE_QUALITY            4013
#define IDS_SN_SEND_WHEN_TYPE           4014
#define IDS_SN_NOT_EARLIER_HOUR         4015
#define IDS_SN_NOT_EARLIER_MINUTE       4016
#define IDS_SN_PROFILE_VERSION          4017
#define IDS_SN_PREV_BILLING_CODES       4018
#define IDS_SN_DEFAULT_COVER_PAGE       4019
#define IDS_SN_BILLING_CODE_DWORD       4020
#define IDS_SN_LOG_ENABLE               4021
#define IDS_SN_LOG_NUM_OF_CALLS         4022
#define IDS_SN_DISPLAY_PROGRESS         4023
#define IDS_SN_EMBED_LINKED_OBJECTS     4024
#define IDS_SN_TAPI_LOC_ID              4025
#define IDS_SN_SENDER_NAME              4026
#define IDS_SN_SENDER_EMAIL_ADDR        4027
#define IDS_SN_SPEAKER_MODE             4028
#define IDS_SN_ANSWER_MODE              4029
#define IDS_SN_ANSWER_NUM_RINGS         4030
#define IDS_SN_SENDER_STATION_ID        4031
#define IDS_SN_ACTIVE_FAX_MODEM         4032
#define IDS_SN_ENABLE_RECIPIENT_OPTIONS 4033
#define IDS_SN_MUST_RENDER_ATTACH       4034
#define IDS_SN_CALLING_CARD             4035
#define IDS_SN_ACTIVE_MODEM_TYPE        4036
#define IDS_SN_WORK_OFFLINE             4037
#define IDS_SN_SHARE_DEVICE             4038
#define IDS_SN_SHARE_NAME               4039
#define IDS_SN_SENDER_COMPANY           4040
#define IDS_SN_SENDER_TITLE             4041
#define IDS_SN_SENDER_ADDRESS           4042
#define IDS_SN_SENDER_DEPT              4043
#define IDS_SN_SENDER_OFFICE_LOC        4044
#define IDS_SN_SENDER_HOME_TL           4045
#define IDS_SN_SENDER_OFFICE_TL         4046
#define IDS_SN_SENDER_COUNTRY_ID        4047
#define IDS_SN_NETFAX_DEVICES           4048
#define IDS_SN_SHARE_PATHNAME           4049
#define M_SAVE_NAMES_END                4050
#define IDH_OVR_MESSAGE                 5001
#define IDH_OVR_DIALING                 5002
#define IDH_OVR_MODEM                   5003
#define IDH_OVR_SENDER                  5004
#define IDC_STATIC                      -1
#define IDC_STATIC_CONTROL              0xffff

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         3660
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\bmscaler.h ===
// Copyright (c) Microsoft Corp. 1993-94
/*==============================================================================
This include file defines the API for the bitmap scaler and padder.

06-Oct-93    RajeevD    Created.
==============================================================================*/
#ifndef _BMSCALER_
#define _BMSCALER_

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
ScalerGetRatios() returns a pointer to a capabilities structure, which points to
the array of scaling ratios available.  Each ratio is a pair of UINTs where the
first and second value correspond to input and output respectively.  For example,
{2,1} is reduction to 50% and {2,3} is enlargement to 150%.

The three classes of ratios are isotropic, vertical, and horizontal, listed in
that order.  The number of ratios in each class is given by the capabilities
structure.  Within each class, ratios are ordered monotonically from greatest
enlargement to greatest reduction.  
==============================================================================*/
typedef struct
{
	UINT FAR* lpRatios;  // array of scaling ratios
	WORD cIsotropic;     // number of isotropic ratios
	WORD cVertical;      // number of vertical ratios
	WORD cHorizontal;    // number of horizontal ratios
	WORD iPadder;        // index of padding (1:1) ratio
}
	SCALE_RATIOS, FAR *LPSCALE_RATIOS;

LPSCALE_RATIOS WINAPI ScalerGetRatios (void);

/*==============================================================================
The SCALE structure specifies the scaling operation to be performed.
The comments enclosed with square brackets apply to vertical scaling.
==============================================================================*/
typedef struct
#ifdef __cplusplus
FAR SCALE
#endif
{
	DWORD nTypeIn;     // input encoding: HRAW_DATA [or LRAW_DATA]
	DWORD nTypeOut;    // output encoding: must be same as input
	UINT  iRatio;      // scaling ratio index from ScalerRatios()
	UINT  cbLineIn;    // input line width in bytes (must be 4x)
	UINT  cbPadLeft;   // output left padding width in bytes [0]
	UINT  cbPadRight;  // output right padding width in bytes [0]
	BOOL  fPadOnes;    // output background color (0 or 1)
}
	SCALE, FAR *LPSCALE;

#define SCALE_PAD_ZEROS FALSE
#define SCALE_PAD_ONES  TRUE

/*==============================================================================
ScalerTranslate() calculates the output line width for a given input line width 
and scaling ratio.  This function is useful in determining, for example, the 
amount of padding required to preserve DWORD alignment.
==============================================================================*/
UINT                   // output width, exclusive of padding
WINAPI
ScalerTranslate
(
	LPSCALE lpParam      // initialization parameters
);

/*==============================================================================
ScalerInit() initializes the scaler.  When queried with a NULL context pointer, 
it indicates how much memory must be allocated by the caller.  When passed a 
pointer to that memory, it initializes the context.
==============================================================================*/
UINT                   // size of context in bytes
WINAPI
ScalerInit
(
	LPVOID lpContext,    // context pointer (NULL on query)
	LPSCALE lpParam      // initialization parameters
);

/*==============================================================================
ScalerExec() executes the scaling specified in ScalerInit().

In the input buffer, lpbBegData is advanced and wLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.

In the output buffer, wLengthData is incremented as data is appended.  A whole 
number of scan lines is produced

To flush any output data at the end of a page, pass a NULL input buffer.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
#define OUTPUT_FULL TRUE
#define INPUT_EMPTY FALSE

BOOL                   // output buffer full?
WINAPI
ScalerExec
(
	LPVOID lpContext,    // context pointer
	LPBUFFER lpbufIn,    // input buffer (NULL at end of page)
	LPBUFFER lpbufOut    // output buffer
);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // _BMSCALER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\bgt30.h ===
/***************************************************************************
 Name     :	BGT30.C
 Comment  :	Implements the IFAX Comm API

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


/****************************************************
	// wParam==Comport
#	define IF_T30_INIT		(IF_USER + 0x301)

	// wParam==TRUE/FALSE	lParam==hProt
#	define IF_T30_ANSWER	(IF_USER + 0x302)

	// wParam==aPhone		lParam==hProt
#	define IF_T30_CALL		(IF_USER + 0x303)

	// wParam==On/off
#	define IF_T30_LISTEN	(IF_USER + 0x304)

	// wParam, lParam unused
	// #	define IF_T30_ABORT	(IF_USER + 0x305)
	// #define IF_T30_DATA		(IF_USER + 0x306)
******************************************************/

#ifdef TSK
#	define BGT30EXPORT	__export WINAPI
#	define BGT30WINAPI	WINAPI
#else
#	define BGT30EXPORT	
#	define BGT30WINAPI	
#endif
	
		void BGT30EXPORT T30Init(USHORT uComPort, USHORT uModemClass);
typedef void (BGT30WINAPI  *LPFN_T30INIT)(USHORT uComPort, USHORT uModemClass);
		void BGT30EXPORT T30DeInit(void);
typedef	void (BGT30WINAPI  *LPFN_T30DEINIT)(void);
		USHORT BGT30EXPORT T30Answer(BOOL fImmediate, USHORT uLine, USHORT uModem);
typedef USHORT (BGT30WINAPI  *LPFN_T30ANSWER)(BOOL fImmediate, USHORT uLine, USHORT uModem);
		UWORD BGT30EXPORT T30Call(ATOM aPhone, USHORT uLine, USHORT uModem);
typedef	UWORD (BGT30WINAPI  *LPFN_T30CALL)(ATOM aPhone, USHORT uLine, USHORT uModem);
		USHORT BGT30EXPORT T30Listen(USHORT uLevel, USHORT uLine);
typedef	USHORT (BGT30WINAPI  *LPFN_T30LISTEN)(USHORT uLevel, USHORT uLine);

#ifdef TSK
void BGT30EXPORT SetT30Callbacks(HWND, LPFN_T30INIT, LPFN_T30DEINIT,
						   LPFN_T30CALL, LPFN_T30ANSWER, LPFN_T30LISTEN);
#endif

#ifdef THREAD
void BGT30EXPORT T30WaitUntilBGExit(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\buffers.h ===
/*==============================================================================
This file includes the BUFFER typedef and standard meta-data values.

23-Feb-93    RajeevD    Moved from ifaxos.h
17-Jul-93    KGallo     Added STORED_BUF_DATA metadata type for buffers containing 
                        the stored info for another buffer.
28-Sep-93    ArulM      Added RES_ ENCODE_ WIDTH_ and LENGTH_ typedefs
==============================================================================*/
#ifndef _INC_BUFFERS
#define _INC_BUFFERS

//----------------------------- BUFFERS -------------------------
/****
	@doc    EXTERNAL        IFAXOS    DATATYPES

	@types  BUFFER  |   The Buffer structure defines the buffer header
			structures which processes manipulate.

	@field  WORD	|   fReadOnly   | Specifies whether the buffer
			is readonly or not. It is the applications responsibility to
			check this flag and not violate it. <f IFBufMakeWritable> should
			be used if a process needs to write on a buffer which is
			marked readonly. This field should not be modified by the
			process itself.

	@field  LPBYTE  |   lpbBegBuf   | A far ptr pointing to the physical
			start of the buffer. This ptr has meaning only in the calling
			process's address space and should not be stored for any
			reason. It should not be modified either.

	@field  WORD    |   wLengthBuf  | Physical length of the buffer. Should
			not be modified by the process. Should be used in conjunction
			with <e BUFFER.lpbBegBuf> to know the physical boundaries of the buffer.

	@field  DWORD    |   dwMetaData   | Indicates the kind of data stored in
			the buffer. See <t STD_DATA_TYPES> for all the possible values
	    of this field.

	@field  LPBYTE  |   lpbBegData  | Far ptr to the start of valid data in the
			buffer. The process is responsible for maintaining the integrity
			of this as it consumes or produces data in the buffer. The ptr should
			not be passed to any other process as it will not be valid. At buffer
			allocation time this field is initialized to point to the physical
			beginning of the buffer.

	@field  LPBYTE  |   lpbCurPtr   | One of the fields of a union containing
	    lpbfNext and dwTemp as its other members.
	    A general purpose far ptr which can be
			used to mark an interesting place in the buffer. Should be used as
			a temporary variable while processing the buffer. Should not be directly
	    passed to any other process. Initialized
			to point to the beginning of the buffer at allocation time.
	    Remember that this is a UNION !!

	@field  LPBUFFER  |   lpbfNext | One of the fields of a union containing
	    lpbCurPtr and dwTemp as its other members. This should be used
	    when a module wants to internally link a list of buffers together.
	    Remember that this is a UNION !!

	@field  DWORD |   dwTemp | One of the fields of a union containing
	    lpbfNext and lpbCurPtr as its other members. This should be used when
	    the module wants to store some random information in the header.
	    Remember that this is a UNION !!

	@field  WORD    |   wLengthData | Gives the length of valid contiguous data
			present in the buffer starting at <e BUFFER.lpbBegData>. The process is
			responsible for maintaining the integrity of this. Initialized to
			zero at allocation time.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname _BUFFER

	@xref   <f IFBufAlloc>
****/

typedef struct _BUFFER
{       
	// Private portion
	struct _BUFFERDATA  FAR *lpbdBufData;
	struct _BUFFER FAR *lpbfNextBuf;
    WORD    wResFlags;

	// Read Only portion
	WORD	fReadOnly;      // Is the buffer readonly ??
	LPBYTE  lpbBegBuf;      // Physical start of buffer
	WORD    wLengthBuf;     // Length of buffer

	// Read write public portion
	WORD    wLengthData;    // length of valid data
	DWORD   dwMetaData;      // Used to store metadata information
	LPBYTE  lpbBegData;     // Ptr to start of data
	union
	{
		struct _BUFFER FAR*     lpbfNext;       // for linking buffers
		LPBYTE  lpbCurPtr;      // for local current position use
		DWORD   dwTemp;    // for general use
	};

#ifdef VALIDATE
	// Dont touch this !!
	WORD    sentinel;       // debug sentinel
#endif

// C++ Extensions
#ifdef __cplusplus

	LPBYTE EndBuf  (void) FAR {return lpbBegBuf  + wLengthBuf; }
	LPBYTE EndData (void) FAR {return lpbBegData + wLengthData;}
	void   Reset   (void) FAR {lpbBegData = lpbBegBuf; wLengthData = 0;}
  
#endif // __cplusplus

} BUFFER, FAR *LPBUFFER , FAR * FAR * LPLPBUFFER ;

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_DATA_TYPES | Standard data types used for
	    specifying the format of data in the system.

    @emem   MH_DATA     | Modified Huffman (T.4 1-dimensional).
    @emem   MR_DATA     | Modified READ (T.4 2-dimensional).
    @emem   MMR_DATA| Modified Modified READ (T.6).
    @emem   LRAW_DATA | Raw bitmap data, Least Significant Bit to the left.
    @emem   HRAW_DATA | Raw Bitmap data, Most Significant Bit to the left.
    @emem   DCX_DATA | Industry standard DCX specification (collection of PCX pages).
    @emem   ENCRYPTED_DATA | Data encrypted - original format unspecified.
    @emem   SIGNED_DATA | Data along with a digital signature. 
    @emem   BINFILE_DATA | Arbitrary binary data.
    @emem   STORED_BUF_DATA | Contains a BUFFER header & data.
    @emem   DCP_TEMPLATE_DATA | Digital Cover Page template data.
    @emem   DCP_DATA | Digital Cover Page processed template data.
    @emem   SPOOL_DATA | Spool data type - same as MMR for now.
    @emem   PRINTMODE_DATA | Printer Mode structure.
    @emem   ASCII_DATA | Ascii text.
    @emem   OLE_DATA   | Ole object.
    @emem   OLE_PICTURE | Ole Rendering Data.
    @emem   END_OF_PAGE | End of page marker.
    @emem   END_OF_JOB  | End of job marker.
    @emem   CUSTOM_METADATA_TYPE  | Beyond this value custom data types can be
	    defined.

    @comm   This should be used to specify data type of any data stream in the
	    system - from BUFFERS to Linearized Messages.  All data types which 
	    need to be used in bit fields (i.e. the Format Resolution) must have
	    a value which is a power of 2.  Other data types which do not need to used
	    in a bit field context may be assigned the other values.
********/

#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L
#define LRAW_DATA         0x00000008L
#define HRAW_DATA         0x00000010L
#define DCX_DATA          0x00000020L
#define ENCRYPTED_DATA    0x00000040L
#define BINFILE_DATA      0x00000080L
#define DCP_TEMPLATE_DATA 0x00000100L
#define ASCII_DATA        0x00000200L
#define RAMBO_DATA        0x00000400L
#define LINEARIZED_DATA   0x00000800L
#define DCP_DATA          0x00001000L
#define PCL_DATA          0x00002000L
#define ADDR_BOOK_DATA    0x00004000L
#define OLE_BIT_DATA      0x00008000L    // So we can use fmtres on OLE_DATA
#define OLE_BIT_PICTURE   0x00010000L    // So we can use fntres on OLE_BIT_PICTURE

// Make spool data be MMR
#define SPOOL_DATA        MMR_DATA

// Standard Non-Bit Valued MetaData values
#define NULL_DATA         0x00000000L
#define SIGNED_DATA       0x00000003L
#define STORED_BUF_DATA   0x00000005L
#define PRINTMODE_DATA    0x00000006L
#define OLE_DATA          0x0000001EL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define OLE_PICTURE       0x0000001FL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define END_OF_PAGE       0x00000021L
#define END_OF_JOB        0x00000022L
#define PARADEV_DATA      0x00000031L    // parallel device data
#define PARADEV_EOF       0x00000032L    // parallel device end of file


#define ISVIEWATT(e)  (((e) == MMR_DATA) || ((e) == RAMBO_DATA))
#define ISOLEATT(e)   (((e) == OLE_DATA) || ((e) == OLE_PICTURE))
#define ISPAGEDATT(e) (((e)==MMR_DATA) || ((e)==MR_DATA) || \
                        ((e)==MH_DATA)|| ((e)==LRAW_DATA)|| ((e)==HRAW_DATA))


// Allow for 24 standard bit valued MetaData values
#define CUSTOM_METADATA_TYPE  0x00800001L

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_RESOLUTIONS | Standard Page Resolutions

    @emem   AWRES_UNUSED      | Resolution is unused or irrelevant
    @emem   AWRES_UNKNOWN     | Resolution is unknown
    @emem   AWRES_CUSTOM      | Custom resolution
    @emem   AWRES_mm080_038   | 8 lines/mm x 3.85 lines/mm
    @emem   AWRES_mm080_077   | 8 lines/mm x 7.7 lines/mm
    @emem   AWRES_mm080_154   | 8 lines/mm x 15.4 lines/mm
    @emem   AWRES_mm160_154   | 16 lines/mm x 15.4 lines/mm
    @emem   AWRES_200_100     | 200 dpi x 100 dpi
    @emem   AWRES_200_200     | 200 dpi x 200 dpi
    @emem   AWRES_200_400     | 200 dpi x 400 dpi
    @emem   AWRES_300_300     | 300 dpi x 300 dpi
    @emem   AWRES_400_400     | 400 dpi x 400 dpi
********/   

#define AWRES_UNUSED            0xFFFFFFFFL
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_600_300           0x00000800L

// Keep old names for a while
#define AWRES_NORMAL            AWRES_mm080_038
#define AWRES_FINE              AWRES_mm080_077
#define AWRES_SUPER             AWRES_mm080_154
#define AWRES_SUPER_SUPER       AWRES_mm160_154
#define AWRES_SUPER_FINE        AWRES_SUPER_SUPER

/********
    @doc    EXTERNAL    IFAXOS  DATATYPES  SRVRDLL

    @type   DWORD |  STD_PAGE_LENLIMITS | Standard Page Length Limits

    @emem   AWLENLIMIT_UNUSED    | Page Length Limit unused
    @emem   AWLENLIMIT_STD       | Page Length Limit defined by Standard Paper Size
    @emem   AWLENLIMIT_UNLIMITED | unlimited page length
********/

#define AWLENLIMIT_UNUSED    0xFFFFFFFFL
#define AWLENLIMIT_STD       0x00000001L
#define AWLENLIMIT_UNLIMITED 0x00000002L


/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL 

    @typee  STD_PAGE_SIZES | Standard Page Sizes

    @emem   AWPAPER_UNUSED         |  Paper size is unused
    @emem   AWPAPER_UNKNOWN         |  Unknown size
    @emem   AWPAPER_CUSTOM          |  Custom Paper size
    @emem   AWPAPER_A3_PORTRAIT     |  A3 Portrait
    @emem   AWPAPER_A3_LANDSCAPE    | A3 landscape
    @emem	AWPAPER_B4_PORTRAIT     | B4 portrait
	@emem	AWPAPER_B4_LANDSCAPE    | B4 landscape
	@emem	AWPAPER_A4_PORTRAIT     | A4 portrait
	@emem	AWPAPER_A4_LANDSCAPE    | A4 landscape
	@emem	AWPAPER_B5_PORTRAIT     | B5 portrait
	@emem	AWPAPER_B5_LANDSCAPE    | B5 landscape
	@emem	AWPAPER_A5_PORTRAIT     | A5 portrait
	@emem	AWPAPER_A5_LANDSCAPE    | A5 landscape
	@emem	AWPAPER_A6_PORTRAIT     | A6 portrait
	@emem	AWPAPER_A6_LANDSCAPE    | A6 landscape
	@emem	AWPAPER_LETTER_PORTRAIT | Letter portrait
	@emem	AWPAPER_LETTER_LANDSCAPE | Letter landscape
	@emem	AWPAPER_LEGAL_PORTRAIT   | Legal portrait
	@emem	AWPAPER_LEGAL_LANDSCAPE  | Legal landscape
	@emem	AWPAPER_WIN31_DEFAULT   | ????


	@comm   Page width in pixels must be exactly correct for MH/MR/MMR
			decoding and to interoperate with Group-3 fax machines.
			The table in the example below gives the bits/bytes required at each width
			and resolution combination

    @ex     Table for Page Width vs Resolution  |

                         A4        B4        A3        A5        A6
    200dpi / 8li/mm   1728/216  2048/256  2432/304  1216/152   864/108
    300               2592/324  3072/384  3648/456  1824/228  1296/162
    400dpi / 16li/mm  3456/432  4096/512  4864/608  2432/304  1728/216

********/

#define         AWPAPER_UNUSED                  0xFFFFFFFFL
#define         AWPAPER_UNKNOWN                 0x00000000L
#define         AWPAPER_CUSTOM                  0x00000001L
#define         AWPAPER_A3_PORTRAIT             0x00000002L
#define         AWPAPER_A3_LANDSCAPE            0x00000004L
#define         AWPAPER_B4_PORTRAIT             0x00000008L
#define         AWPAPER_B4_LANDSCAPE            0x00000010L
#define         AWPAPER_A4_PORTRAIT             0x00000020L
#define         AWPAPER_A4_LANDSCAPE            0x00000040L
#define         AWPAPER_B5_PORTRAIT             0x00000080L
#define         AWPAPER_B5_LANDSCAPE            0x00000100L
#define         AWPAPER_A5_PORTRAIT             0x00000200L
#define         AWPAPER_A5_LANDSCAPE            0x00000400L
#define         AWPAPER_A6_PORTRAIT             0x00000800L
#define         AWPAPER_A6_LANDSCAPE            0x00001000L
#define         AWPAPER_LETTER_PORTRAIT         0x00002000L
#define         AWPAPER_LETTER_LANDSCAPE        0x00004000L
#define         AWPAPER_LEGAL_PORTRAIT          0x00008000L
#define         AWPAPER_LEGAL_LANDSCAPE         0x00010000L
#define         AWPAPER_WIN31_DEFAULT           0x00020000L





#endif // _INC_BUFFERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\comdevi.h ===
/***************************************************************************
 Name     :     COMDEVI.H
 Comment  :     Controls Comm interface used by Fax Modem Driver. There are
                        4 choices.
                        (a) If UCOM is defined, it uses the WIN16 Comm API as exported
                                by USER.EXE (though eventually it gets to COMM.DRV)
                        (b) If UCOM is not defined and VC is defined, it uses the
                                COMM.DRV-like interface exported by DLLSCHED.DLL (which
                                merely serves as a front for VCOMM.386)
                        (c) If neither UCOM nor VC are defined, it uses Win3.1 COMM.DRV
                                export directly.
                        (d) If WIN32 is defined (neither UCOM or VC should be defined at
                                the same time), it uses the WIN32 Comm API

 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



#pragma optimize("e", off)              // "e" is buggy

// must be 8K or less, dues to DEADCOMMTIMEOUT. See fcom.c!!
// maybe not...

// #define      COM_INBUFSIZE           16384
// #define      COM_OUTBUFSIZE          16384
#define COM_INBUFSIZE           4096
#define COM_OUTBUFSIZE          4096
// #define COM_INBUFSIZE                256
// #define COM_OUTBUFSIZE               256
// #define COM_INBUFSIZE                1024
// #define COM_OUTBUFSIZE               1024

#define BETWEENCALL_THRESH 50

#ifdef DEBUG
#       define CALLTHRESH_CONST         50
#       define CALLTHRESH_PERBYTE       1
#       define BEFORECALL               static DWORD t1, t2; t1=GetTickCount();
#   define INTERCALL(sz)
/*
#   define INTERCALL(sz)                if((t1-t2) > BETWEENCALL_THRESH)\
                 ERRMSG(("!!!Inter API %s delay %ld!!!\r\n", (LPSTR)(sz), (t1-t2)));
*/
#       define AFTERCALL(sz,n)  \
                t2=GetTickCount();\
                if((t2-t1) > (CALLTHRESH_CONST+((DWORD)n)*CALLTHRESH_PERBYTE))                  \
                        ERRMSG(("!!!API %s took %ld!!!\r\n", (LPSTR)(sz), (t2-t1)));
#else
#       define BEFORECALL
#       define AFTERCALL
#   define INTERCALL
#endif




#if INVALID_HANDLE_VALUE >= 0           // must be <= 0
#error INVALID_HANDLE_VALUE is >=0. This won't work....
#endif
#define My2ndOpenComm(sz, ph)                                                                                           \
        { BEFORECALL;                                                                                                                   \
          if((*((LPHANDLE)(ph)) = CreateFile((LPCTSTR)(sz), GENERIC_READ|GENERIC_WRITE, \
                        0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) != INVALID_HANDLE_VALUE)           \
          {                                                                                                                                             \
                if(!SetupComm(*((LPHANDLE)(ph)), COM_INBUFSIZE, COM_OUTBUFSIZE))        \
                {                                                                                                                                       \
                        CloseHandle(*((LPHANDLE)(ph)));                                                                 \
                        *((LPHANDLE)(ph)) = INVALID_HANDLE_VALUE;                                               \
                }                                                                                                                                       \
          }                                                                                                                                             \
          AFTERCALL("Open", 0);                                                                                                 \
        }                                                                                                                                               \


#define My2ndCloseComm(h, pn)   { BEFORECALL; *(pn) = (!CloseHandle((HANDLE)h)); AFTERCALL("Close",0); }
#define MySetCommState(h,pdcb)  (!SetCommState((HANDLE)(h), (pdcb)))
#define MyGetCommState(h,pdcb)  (!GetCommState((HANDLE)(h), (pdcb)))

#define OVL_CLEAR(lpovl) \
                                 { \
                                        if (lpovl) \
                                        { \
                                                (lpovl)->Internal = (lpovl)->InternalHigh=\
                                                (lpovl)->Offset = (lpovl)->OffsetHigh=0; \
                                                if ((lpovl)->hEvent) ResetEvent((lpovl)->hEvent); \
                                        } \
                                 }


#define MySetCommMask(h,mask)   (!SetCommMask((HANDLE)(h), (mask)))
#define MyFlushComm(h,q)                (!PurgeComm((HANDLE)h, ((q)==0 ? PURGE_TXCLEAR : PURGE_RXCLEAR)))
#define MySetXON(h)                             (!EscapeCommFunction((HANDLE)(h), SETXON))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\dcxcodec.h ===
// Copyright (C) Microsoft Corp. 1994
/*==============================================================================
The prototypes in this header file define an API for the Dcx Codec DLL.

DATE				NAME			COMMENTS
13-Jan-94   RajeevD   Parallel to faxcodec.h
==============================================================================*/
#ifndef _INC_DCXCODEC
#define _INC_DCXCODEC

#include <faxcodec.h>

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
DcxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // returns size of context (0 on failure)
WINAPI DcxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

/*==============================================================================
DcxCodecConvert() executes the conversion specified in DcxCodecInit().

In the input buffer, lpbBegData is advanced and uLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.

In the output buffer, uLengthData is incremented as data is appended.  If the
output type is HRAW_DATA, an integral number of scan lines are produced.

To flush any output data at the end of apage, pass a NULL input buffer.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // returns status
WINAPI DcxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);


#ifdef __cplusplus
} // extern "C" {
#endif

#pragma pack (push)
#pragma pack(1)

// DCX file header
typedef struct
{
	DWORD   dwSignature;    // always set to DCX_SIG
	DWORD   dwOffset[1024]; // array of page offsets
}
	DCX_HDR;

#define DCX_SIG 987654321L

// PCX file header
typedef struct
{
	BYTE    bSig;          // signature: always  0Ah
	BYTE    bVer;          // version: at least 2 
	BYTE    bEnc;          // encoding: always 1
	BYTE    bBPP;          // color depth [bpp]
	short   xMin;          // x minimum, inclusive
	short   yMin;          // y minimum, inclusive
	short   xMax;          // x maximum, inclusive
	short   yMax;          // y maximum, inclusive
	WORD    xRes;          // x resolution [dpi]
	WORD    yRes;          // y resolution [dpi]
	BYTE    bPalette[48];  // color palette
	BYTE    bReserved;
	BYTE    bPlanes;       // number of color planes
	WORD    wHoriz; 
  WORD    wPalInfo;      // palette info: always 1
	char    bFill[58];
}
	PCX_HDR;
#pragma pack(pop)

#endif // _INC_DCXCODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\cas.h ===
/***************************************************************************
 Name     :	CAS.C
 Comment  :	

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#ifdef CAS

// Copy of the DCX and PCX header from dcx.h in \wfw\efaxpump

#define MAX_DCX_PAGES       1023 

typedef struct DCXHDR_s
{
    DWORD   id;                     // 4 byte integer =987654321
    DWORD   Offset[MAX_DCX_PAGES+1];// array of 4 byte integers showing page offsets

}   DCXHDR;

typedef struct PCXHDR_s
{
	char    id;             // always = 0Ah
	char    version;        // value of 2 is suggested, higher allowed
	char    encode_method;  // always = 1
	char    bitsperpixel;   // =1 for fax mode transfer
	short   xtopleft;
	short   ytopleft;
	short   width;
	short   height;
	short   hDPI; 
	short   vDPI; 
	char    pal[48];
	char    reserv;
	char    colorplanes;    // must be 1 for fax mode
	short   horiz;
    	short   nPaletteInfo;   // palette info. must be 1
	char    filler[58];
}   PCXHDR;


/***------------------ Interface to CAS.C ------------------***/

		BOOL __export WINAPI CASModemFind(void);
typedef BOOL (WINAPI  *LPFN_CASMODEMFIND)(void);
	// returns TRUE if CAS is installed, FALSE if not

		VOID __export WINAPI CASInit(void);
typedef BOOL (WINAPI  *LPFN_CASINIT)(void);
	// init stuff, if any

		VOID __export WINAPI CASDeInit(void);
typedef VOID (WINAPI  *LPFN_CASDEINIT)(void);
	// if you want to down any shutdown-cleanup
	// (e.g. if there are pending receives, does CAS 
	// save them for you across a reboot?)

		BOOL __export WINAPI CASSendFile(ATOM aPhone, ATOM aFileMG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX);
typedef BOOL (WINAPI  *LPFN_CASSENDFILE)(ATOM aPhone, ATOM aFileMG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX);
	// Send. Returns immediately with TRUE unless
	// some internal DEBUGCHK-like error or multiple
	// sends. Handles only one at a time & saves CAS handle
	// internally

		WORD __export WINAPI CASCheckSent(void);
typedef WORD (WINAPI  *LPFN_CASCHECKSENT)(void);
	// Checks if pending send (only one at any time), was sent. 
	// Returns 0 if still pending, non-zero if done, with success/error. 
	// The return value should be in LOBYTE=result HIBYTE=extended-error 
	// form. See FILET30.H, line 29-38 for valid values/combinations.

		USHORT __export WINAPI CASGetNumReceived(void);
typedef USHORT (WINAPI  *LPFN_CASGETNUMRECEIVED)(void);
	// Get *number* of pending receives	(successful or failure) only. 
	// Don't actually dequeue any.

		DWORD __export WINAPI CASGetNextRecv(LPSTR szPath, LPSTR szFile);
typedef DWORD (WINAPI  *LPFN_CASGETNEXTRECV)(LPSTR szPath, LPSTR szFile);
	// gives the spool dir (recvd file in all forms _must_ be put 
	// there for pump to get it) and a suggested filename (8.3 format) 
	// which has been checked to be "safe" to create in that directory. 
	// File name/extension can be changed as neccesary.
	// Return value must be a DWORD with the return filename atom
	// in LOWORD and result/extendederr in HIWORD (i.e result
	// is LOBYTE(HIWORD()) and exterr is HIBYTE(HIWORD()).
	// See lines 54--66 of FILET30.H for valid return values

		VOID __export WINAPI CASAbort(void);
typedef VOID (WINAPI  *LPFN_CASABORT)(void);
	// Abort current Send/Recv if possible.
	// Return when abort is **complete**. Can stub it out currently

		BOOL __export WINAPI CASSetAutoAnswer(BOOL fOn, USHORT uNumRings);
typedef BOOL (WINAPI  *LPFN_CASSETAUTOANSWER)(BOOL fOn, USHORT uNumRings);
	// fOn==TRUE--answer On, FALSE--answer Off
	// uNumRings == after X rings. (0 or more)


		BOOL __export WINAPI CASSetBC(LPBC lpbc, BCTYPE bctype);
typedef	BOOL (WINAPI  *LPFN_CASSETBC)(LPBC lpbc, BCTYPE bctype);

// Finally, we should also see if we can implement any of Mike 
// Ginsberg's INI settings on a CAS board. 

#endif // CAS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\class2.h ===
#define         IDSIZE                  20
#define         MFR_SIZE                80
#define         RESPONSE_BUF_SIZE       300

typedef enum {  
  PCB_SEND_CAPS,
  PCB_SEND_PARAMS,
  PCB_RECV_PARAMS
}  PCBTYPE;


typedef struct {
        USHORT  uPCBSize;               // must set this
        BOOL    fEFAX;                  // accepts EFAX linearized file format

        BYTE    Resolution;             // one or more of the RES_ #defines below
        BYTE    Encoding;               // one or more of the ENCODE_ #defines below
        BYTE    PageWidth;                      // one of the WIDTH_ #defines below
        BYTE    PageLength;                     // one of the LENGTH_ #defines below
        BYTE    MinScan;                // one of the MINSCAN_ #defines below
                                                        // used only in RecvCaps
        PCBTYPE pcbtype;
        // BOOL fG3image;                       
        BOOL    fG3Poll;                // has G3 file available for polling
        BOOL    fNewT30;                // handles PWD/SEP/SUB
        CHAR    szID[IDSIZE+2]; // Must use '0' to '9' or ' '(space) only

        BOOL    fBinary;                // accepts binary files inside linearized EFAX messages
        BOOL    fRambo;                 // accepts Rambo inside linearized EFAX messages
        BOOL    fExtCapsSupport;// supports extended caps
        BOOL    fExtCapsAvail;  // has extended caps available for polling
                                                        // add more as they become clear

        BYTE    Baud;
} PCB, far* LPPCB, near* NPPCB;


//  Array to hold parsed class2 command strings.
#define MAX_CLASS2_COMMANDS     10
#define MAX_PARAM_LENGTH        50

typedef struct cl2_command {
    USHORT    comm_count;
    BYTE    command[MAX_CLASS2_COMMANDS];
    BYTE    parameters[MAX_CLASS2_COMMANDS][MAX_PARAM_LENGTH];
} CL2_COMM_ARRAY;


// structure for modem specific hacks
typedef struct {
        // Fields for manufacturer, model, and revision number
        CHAR    szATI[MFR_SIZE];
        CHAR    szMFR[MFR_SIZE];
        CHAR    szMDL[MFR_SIZE];
        CHAR    szREV[MFR_SIZE];
        //Fields for specific actions to take
        //BOR values to use
        USHORT    iReceiveBOR;
        USHORT    iSendBOR;
        //Value to enable data to be recieved after FDR
        CHAR    szDC2[2];
        BOOL    bIsSierra;
        BOOL    bIsExar;
        BOOL    fSkipCtrlQ;     // DONT wait for CtrlQ after FDT
        BOOL    fSWFBOR;        // Implement AT+FBOR=1 in software (i.e., bitreverse)
                                                // Only invoked on send(recv) if iSendBOR(iRecvBOR)
                                                // is 1 (in which it will send AT+FBOR=0).
} MFRSPEC, far *LPMFRSPEC;



/**-------------------- from MODEM.H -----------------------------**/

typedef char  C2SZ;
typedef char  *C2PSTR;




/**-------------------- from COMMODEM.H -----------------------------**/

#define MAXPHONESIZE    60
#define DIALBUFSIZE     MAXPHONESIZE + 10






/**-------------------- modelled after MODEMINT.H -----------------------------**/
// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
                // Looks like even 330 is too short for some modems..

#define Class2SyncModemDialog(pTG, s, l, w)                                  \
    Class2iModemDialog(pTG, (s), (l), 550, TRUE, 2, (C2PSTR)(w), (C2PSTR)(NULL))



// has to be >1 try & multi-line because we can have RING noises
// coming in at anytime while on-hook
/**
#define  Class2LocalModemDialog(s, l, w)                        \
        Class2iModemDialog((s), (l), 1500, TRUE, 2, (C2PSTR)(w), (C2PSTR)(NULL))
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\defs1.h ===
//
// DEFS.H      Common macros for the Local Fax Project.
//
// History:
//     2/27/94 JosephJ Created.
//
#define MAX_PATHNAME_SIZE 128

#if defined(DEBUG)

#  define DEBUG_CODE // debug-related functionality (the "Test" menu)
#  define USE_IPC    // Enable IPC communication.	
#  define ENABLE_LOGGING
#  define ASSERT(cond)\
    if(!(cond)){LOG_ERR((_ERR, "**** ASSERTION FAILURE *** %s:%d",\
     (LPSTR)__FILE__, (int)__LINE__));}

#else // DEBUG

#  define ASSERT(cond)\
   LOGSTMT({if (!(cond)) {LOG_ERR((_ERR, "Assert Fail %s:%d",\
     (LPSTR)__FILE__, (int)__LINE__));}})

#endif // !DEBUG

#ifdef WIN32
#define MYFAR
#else
#define MYFAR  __far
#endif

// Logging related.

#ifdef ENABLE_LOGGING
//#    define COMPNAME "xxx"
//#    define SUBCOMPNAME "yyy"
//#    define FUNCNAME "zzz"
#  define _WRN     "<<WRN>>", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _ERR     "<<ERR>>", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _MSG     "Message", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _ENTRY   "  Enter", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _EXITS   "   Exit", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _EXITF   "Exit(FAIL)", COMPNAME, SUBCOMPNAME, FUNCNAME
#  define _TS   NULL, NULL, NULL, NULL
#  define LOGSTMT(expr) expr
// +++ following are old style, should be replaced by LOG(..) macro below
#  define LOG_MSG(args) log_log args
#  define ODS(str) OutputDebugString(str)
#  define LOG_ENTRY(str) log_log(_ENTRY, "%s", str)
#  define LOG_EXIT_SUCCESS(str) log_log(_EXITS, "%s", str)
#  define LOG_EXIT_FAILURE(str) log_log(_EXITF, "%s", str)
#  define LOG_ERR(args)    log_log args
#  define LOG_WRN(args)    log_log args

#  define LOG(args)    log_log args

#define MYCDECL __cdecl

#define MYLPSTR char MYFAR *

#ifndef _DEF_FILE_
   void MYFAR MYCDECL  log_log(
               MYLPSTR lpszComp,
               MYLPSTR lpszSubComp,
               MYLPSTR lpszFunc,
               MYLPSTR lpszType,
               MYLPSTR lpszFmt,
               ...
           );
#endif // _DEF_FILE_

#else  // !ENABLE_LOGGING

#  define LOGSTMT(expr)
#  define LOG_MSG(args)
#  define ODS(str)
#  define LOG_ENTRY(str)
#  define LOG_EXIT_SUCCESS(str)
#  define LOG_EXIT_FAILURE(str)
#  define LOG_ERR(args)
#  define LOG_WRN(args)

#  define LOG(args)

#endif  // !ENABLE_LOGGING

#  define POLLREQ	// Poll request

#ifndef _DEF_FILE_
typedef unsigned int MYFAR * LPUINT;
#endif // _DEF_FILE_

#ifdef WIN32

#define TAPI


#define MYWEP  \
        int _export CALLBACK WEP(int type)

#define MYLIBMAIN \
        int _export CALLBACK WEP(int type); \
        BOOL _export WINAPI LibMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpv)

#define MYLIBSTARTUP(_szName) \
		LOG_MSG((_MSG, "LibMain called reason=%lu.P=0x%lx.T=0x%lx\r\n",\
					(unsigned long) dwReason,\
				(unsigned long) GetCurrentProcessId(),\
				(unsigned long) GetCurrentThreadId()\
				));\
        if(dwReason==DLL_THREAD_ATTACH || dwReason==DLL_THREAD_DETACH) \
                return TRUE; \
        if(dwReason==DLL_PROCESS_DETACH) \
                return WEP(0);\
		if(dwReason==DLL_PROCESS_ATTACH && (_szName))						\
		{																	\
			HMODULE hM = GetModuleHandle(_szName);							\
			if (hM) DisableThreadLibraryCalls(hM);							\
		}

#define MYLIBSHUTDOWN

#define	ADAPTIVE_ANSWER

#else  // !WIN32

#define MYWEP  \
   int __export WINAPI WEP (int nParam)

#define MYLIBMAIN \
   int __export WINAPI WEP (int nParam);\
        BOOL _export WINAPI LibMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpv)

#define MYLIBSTARTUP() \
    if (wHeapSize > 0) UnlockData(0);

#endif  // !WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\debug.h ===
/*
 -  DEBUG.H
 -
 *      Debug-related definitions
 *
 *		Yoram Yaacovi, 11/93
 *		Taken from MAPI 1.0 sources
 *
 */

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It 
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define SzDecodeScode(_sc)	SzDecodeScodeFn(_sc)
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#define SzDecodeScode(_sc)	(0)
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#if defined (DEBUG)
#define	DEBUG_TRACE	DebugTraceFn
#define	EXTENDED_DEBUG_TRACE ExtendedDebugTraceFn
#else
#define DEBUG_TRACE
#define EXTENDED_DEBUG_TRACE
#endif

// Prototypes for debug functions in debug.c
#if !defined (__MAPIDBG_H_)
void			DebugTrap(void);
int __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int __cdecl		DebugTraceFn(char *pszFormat, ...);
int __cdecl		ExtendedDebugTraceFn(char *pszFormat, ...);
char * __cdecl	SzDecodeScodeFn(SCODE sc);
#endif
BOOL ExtendedDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\dosio.h ===
#ifdef KFIL		// use win kernel file handling

#define DosInit() 				(TRUE)
#define DosDeInit()
#define DosOpen(f, m)			_lopen(f, m)
#define DosClose(h)				_lclose(h)
#define DosCreate(f, m)			_lcreat(f, m)
#define DosSeek(h, off, pos)	((DWORD)_llseek(h, off, pos))
#define DosRead(h, lpb, cb)		_lread(h, lpb, cb)	
#define DosWrite(h, lpb, cb)	_lwrite(h, lpb, cb)
#define DosCommit(h)		

#endif // KFIL

#ifdef DOSIO

#define	MAKEWORD(l,h)	((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))

BOOL WINAPI DosInit(void);
void WINAPI DosDeInit(void);
DWORD WINAPI DosCall (WORD DosAX, WORD DosBX, WORD DosCX, DWORD DosDSDX);

#define DosDelete(sz)		((WORD)DosCall(0x4100, 0, 0, (DWORD)((LPSTR)(sz))))
#define DosCreate(sz,a)		((WORD)DosCall(0x3C00, 0, a, (DWORD)((LPSTR)(sz))))
#define DosClose(h)			((WORD)DosCall(0x3E00, h, 0, 0))
#define DosCommit(h)		((WORD)DosCall(0x6800, h, 0, 0))
#define DosOpen(sz, m)		((WORD)DosCall(MAKEWORD(m, 0x3D), 0, 0, (DWORD)((LPSTR)(sz))))
#define DosRead(h, lpb, cb)	((WORD)DosCall(0x3F00, h, cb, (DWORD)((LPBYTE)(lpb))))
#define DosWrite(h,lpb,cb)	((WORD)DosCall(0x4000, h, cb, (DWORD)((LPBYTE)(lpb))))
#define DosSeek(h,off,p)	DosCall(MAKEWORD(p,0x42), h, HIWORD((DWORD)(off)), MAKELONG(LOWORD((DWORD)(off)), 0))

// #ifdef VPMTD_FINDFIRST
//	// these two return -1 on failure and unknown (probably 0x4E00 etc) on success
//	// the structure containing the found data is in the DTA (part of PSP)
// #	define DosFindFirst(sz, a)	((WORD)DosCall(0x4E00, 0, a, (DWORD)((LPSTR)(sz))))
// #	define DosFindNext()		((WORD)DosCall(0x4F00, 0, 0, 0))
// #endif //VPMTD_FINDFIRST

#endif //DOSIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\efaxcb.h ===
/***************************************************************************
 Name     :     EFAXCB.H
 Comment  :

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "protparm.h"

#ifdef TSK
#       define TSKEXPORT        _export WINAPI
#else
#       define TSKEXPORT
#endif

/****************** begin prototypes from icomfile.c *****************/
void   ICommGotAnswer(PThrdGlbl pTG);
void   ICommSetSendMode(PThrdGlbl pTG, BOOL fECM, LONG sBufSize, USHORT uDataSize, BOOL fPad);
void   ICommSetRecvMode(PThrdGlbl pTG, BOOL fECM);
BOOL   ICommRecvCaps(PThrdGlbl pTG, LPBC lpBC);
BOOL   ICommRecvParams(PThrdGlbl pTG, LPBC lpBC);
BOOL   ICommRecvPollReq(PThrdGlbl pTG, LPBC lpBC);
USHORT   ICommNextSend(PThrdGlbl pTG);
BOOL   ICommSendPageAck(PThrdGlbl pTG, BOOL fAck);
void   ICommFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail);
SWORD   ICommGetSendBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, SLONG slOffset);
BOOL   ICommPutRecvBuf(PThrdGlbl pTG, LPBUFFER lpbf, SLONG slOffset);
USHORT   ICommGetRecvPageAck(PThrdGlbl pTG, BOOL fSleep);
LPBC   ICommGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep);
void   ICommGotDisconnect(PThrdGlbl pTG);

#ifdef RICOHAI
        LPBYTE   ICommGetOEMCaps(LPWORD);
        void   ICommSetOEMCaps(LPBYTE lpb, WORD wLen);
#endif

#ifdef STATUS
        void   ICommStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3);
#else
#       define  ICommStatus(pTG, stat, uN1, uN2, uN3)
#endif

#ifdef FILET30
        void TSKEXPORT  NotifyRing(PThrdGlbl pTG, BOOL fStart);        // TRUE==start FALSE==stop
        void TSKEXPORT  EndOfCall(PThrdGlbl pTG, UWORD uErr);
        ULONG TSKEXPORT StartAnswer(PThrdGlbl pTG, BOOL fBG, BOOL fImmediate);

        void    ICommRawCaps(PThrdGlbl pTG, LPBYTE lpbCSI, LPBYTE lpbDIS, USHORT cbDIS,
                        LPFR FAR * rglpfrNSF, USHORT wNumFrames);

#       define ICommRecvBufIsEmpty(pTG)    (TRUE)

#else

        void   NotifyHandset(PThrdGlbl pTG, USHORT uOld, USHORT uNew);
        void       NotifyRing(PThrdGlbl pTG, BOOL fStart);
        void       EndOfCall(PThrdGlbl pTG, UWORD uErr);
        ULONG   StartAnswer(PThrdGlbl pTG, BOOL fBG, BOOL fImmediate);
        BOOL   ICommRecvBufIsEmpty(PThrdGlbl pTG);

#endif //FILET30
/***************** end of prototypes from icomfile.c *****************/


// flags for PutRecvBuf
#define RECV_STARTBLOCK         -1
#define RECV_STARTPAGE          -2
#define RECV_ENDPAGE            -3
#define RECV_ENDDOC                     -4
#define RECV_SEQ                        -5
#define RECV_SEQBAD                     -6
#define RECV_FLUSH                      -7

// flags for GetSendBuf
#define SEND_STARTBLOCK         -1
#define SEND_STARTPAGE          -2
#define SEND_QUERYENDPAGE       -3
#define SEND_SEQ                        -4

#define SEND_ERROR                      -1
#define SEND_EOF                        1
#define SEND_OK                         0


#ifdef PSI
        void   D_PSIFAXCheckMask(PThrdGlbl pTG, LPBYTE);
#else
#       define  D_PSIFAXCheckMask(pTG, arg)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\defs.h ===
/***************************************************************************
 Name     :	DEFS.H
 Comment  :	

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#pragma warning(disable:4001)   /** nonstd extensions **/
#pragma warning(error:4002)		// too many actual params for macro
#pragma warning(error:4003)     // too few actual params for macro
#pragma warning(error:4005)     // macro redefined
#pragma warning(error:4020)     // too many actual params for function
#pragma warning(error:4021)     // too few actual params for function


#pragma warning(disable:4050)	// different code attributes on fn ptr
#pragma warning(disable:4057)   // indirection to slightly different types
#pragma warning(disable:4101)   // unreferenced local variable
//// ignoring this warning resulted in bug when 'case' keyword was omitted!!//
// #pragma warning(disable:4102)   // unreferenced label
#pragma warning(disable:4135)   // conv between integral types
#pragma warning(disable:4200)   // nonstd ext: zero sized array in struct
#pragma warning(disable:4201)   // nonstd ext: nameless struct/union
#pragma warning(disable:4206)	// nonstd ext: trans unit is empty (whole file ifdefd out)
#pragma warning(disable:4209)	// nonstd ext: benign typedef redefinition
#pragma warning(disable:4214)   // nonstd ext: non-int bitfield
#pragma warning(disable:4704)   // inline asm precludes global optimization
#pragma warning(disable:4705)   // statement has no effect
#pragma warning(disable:4706)   // Assignment within conditional expression
#pragma warning(disable:4791)   // Loss of debugging info


#define UECM	// REQD!! DON'T DELETE EVER!! (This is incorrect-->use ECM for NON-EFAX G3 machines. (Ortho))
				// This directly controls the ECM bit in the DIS
#define SMM     // Static mem (for temp) (Reqd for WFW. Currently reqd for all)
				// uses 2k in fcom\filter.c 350 in class1\framing.c 500 in t30\t30.c--use it always
#define PDUMP	// Protocol dump. Uses 500bytes extra. Ortho to all else


#if defined(WFW) || defined(WFWBG)
#   pragma  message ("Compiling for WFW")
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)
#endif //DEBUG
#	define FASTLOG	// recv file list/log is FASTER (REQD--old one doesn't work)
#	define VS		// Vertical Scaling in Send. (Ortho)
#	define NOPRE	// no pre-emption. Reqd for WFW. Useless for IF (Ortho)
#   define DYNL    	// Dynamic loading of DLLs. (WFW and !MDRV)
#   define VC       // uses VCOMM Comm driver thru DLLSCHED (WFW)
#   define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#   define CAS      // CAS support (Ortho)
#   define CL2      // Class2 support (Ortho)
#   define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
#   define CHK      // check recvd data using old or new FAXCODEC (req !REC)
#	define FILET30	// all file io & filet30 api
#	define FAXWATCH	// write out a FAXWATCH.LOG
#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#	define NEGOT	// do negotiation
#	define DOSIO	// use DOSIO calls thru DLLSCHED
#	define DISCARDFIX	// Declare discardable & fix in LibMain
//#	define  SEC         // recode send data to MR/MMR with new FAXCODEC. Doesn't work yet
//#	define  REC         // recode recv data with new FAXCODEC (!CHK and RECODE_TO). Doesn't work yet
//#	define  RECODE_TO	MH_DATA         // for old Pumps
//#	define  RECODE_TO	MMR_DATA        // for compactness
#endif //WFW || WFWBG


#if defined(IFAX) && !defined(WINPAD)
#  pragma message ("Compiling for IFAX")
#ifdef DEBUG
//#	define MON	// monitor bytes (Ortho)	// can't use it without KFIL or DOSIO
#endif //DEBUG
// #  define IFP


//  Receive spool options to control anti-RNR
#define RXSPOOLFIFO	// initiate receive spool FIFO if printer cannot keep up
#define END_PSIFAX_WHENFLUSHING		// early cleanup of PSIFAX when receive is
									// complete and FIFO is being flushed

#  define CHKDATA  // check recvd data in MSGSVR
#  define RECOVER // save recvd data in MSGSVR for later recovery
#  define RECOVER2 // continue recving after jobproc has croaked
#  define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#  define OEMNSF	// support fro OEMNSF DLLs
#  define RICOHAI 	// support fro Ricoh AI protocol (requires OEMNSF also)
#  define PSI	// PSI version--reqd to compile anything in PSIFAX dir
#  define TSK	// BGT30 is a Process. No DLLSCHED. REQD for some vague stuff in FCOM
#  define IFK	// Use IFKERNEL services (Alloc/Free etc)
#  define BOSS	// Make WEP FIXED etc...
//#define COMMCRIT	// put CritSection() around access to COMM.DRV
//#define CL2	// Use CL2 or 2.0 driver, not T30+ET30PROT+Class1/OEM driver
//#  define PCR	// PageCrit. Reqd for safe recv with Class1. (need !MDDI). BREAKS! with OEM modem drivers

//	The Cactus is a MDDI based on our Class1 driver. So we need PCR!
#if defined(CACTUS)
#	define PCR
#	pragma message("Enabling PCR for CACTUS")
#endif // CACTUS

#  define MDDI	// exact ModemDDI (rev 0.90) (need MDRV && !DYNL). REQD if using OEM driver. REQD to diable if using Class1 driver.
#  define MDRV	// monolith drv. REQD for OEM driver (need !WFW & !DYNL). Incompatible with CL2. Optional for Class1.
#  define STATUS  // support for sending STATUS msgs. Optional.
#  define NVLOG	// log errors to NVRAM
// these two must be OFF for IFAX, ON for Winpad
// (if left on in IFAX UI & Transport use different option struct sizes)
//# define INIFILE // read INI file settings. Optional. (advisable for Cl1 & Cl2)
//# define PCMODEMS// read AT cmd INI file settings. Reqd for Class1 & CL2. (i.e. if not OEM driver or !MDDI) (need INIFILE also).
#endif  //IFAX && !WINPAD



#if defined(WINPAD)
#  pragma message ("Compiling for WINPAD")
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)	// can't use it without KFIL or DOSIO
#endif //DEBUG
#  define TSK	// BGT30 is a Process. No DLLSCHED. REQD for some vague stuff in FCOM
//#  define MDDI	// exact ModemDDI (rev 0.90) (need MDRV && !DYNL). REQD if using OEM driver. REQD to diable if using Class1 driver.
//#  define MDRV	// monolith drv. REQD for OEM driver (need !WFW & !DYNL). Incompatible with CL2. Optional for Class1.
#  define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#  define CL2      // Class2 support (Ortho)
//#  define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
//#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#  	define PSI	// PSI version--reqd to compile anything in PSIFAX dir
#  	define IFK	// Use IFKERNEL services (Alloc/Free etc)
#	define KFIL // use kernel file APIs
#	define COMMCRIT	// put CritSection() around access to COMM.DRV
#endif  //WINPAD



#if defined(WIN32)
#   pragma  message ("Compiling for WIN32")
#define AWG3	// Use AWG3 instead of MG3
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)
// Can't monitor bytes in WIN 32 -- why not?
#endif //DEBUG
#	define POLLREQ	// send poll req. (ortho)
#	define FASTLOG	// recv file list/log is FASTER (REQD--old one doesn't work)
#	define VS		// Vertical Scaling in Send. (Ortho)
//#	define NOPRE	// no pre-emption. Reqd for WFW. Useless for all others?
//#	define TSK		// BGT30 is a Process. No DLLSCHED. doesn't work in WIN32
#	define THREAD	// BGT30 becomes a WIN32 thread inside EFAXRUN
#   define DYNL    	// Dynamic loading of DLLs. (WFW and !MDRV)
//#   define VC       // uses VCOMM Comm driver thru DLLSCHED (WFW)
#   define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#   define CAS      // CAS support (Ortho)
#   define CL2      // Class2 support (Ortho)
#   define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
#   define CHK      // check recvd data using old or new FAXCODEC (req !REC)
#	define FILET30	// all file io & filet30 api
#	define FAXWATCH	// write out a FAXWATCH.LOG
#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#	define NEGOT	// do negotiation
#	define KFIL	// use Kernel File Calls
#	define  SEC     // recode send MMR data to MR/MH with AWCODC32. Works now.
//#	define  REC         // recode recv data with new FAXCODEC (req NFC and !CHK and RECODE_TO). Doesn't work yet
//#	define  RECODE_TO	MH_DATA         // for old Pumps
//#	define  RECODE_TO	MMR_DATA        // for compactness
#	define IFDbgPrintf MyIFDbgPrintf	// +++ Redirect dbg msgs to efaxrun for now..
#	define METAPORT		// FCom can deal with port handles as well as port number.
#	define UNIMEXT		// Unimodem MCX aware
#	define TAPI			// TAPI aware
#	define COMPRESS		// Linearized messages are RejeevD-compressed.
#	define ADAPTIVE_ANSWER	// Ataptive-answer handoff to another TAPI app..
#	define USECAPI		// Capabilities saved via registry, not via
						// Post-message, textcaps, etc.
#	define MON3			// Extended COMM monitoring features (retail AND debug)
#	ifndef DEBUG
#	define SHIP_BUILD
#	endif // !DEBUG
#	ifdef DEBUG
#		define NSF_TEST_HOOKS	// hooks for testing NSF compatibility.
#	endif // DEBUG
# define PORTABLE_CODE
#endif // WIN32






//////// JUNE Demo IFAX /////////////////////////////////////////
//	#if defined(IFFGPROC) || defined(IFBGPROC)
//	#       pragma  message ("Compiling for IFAX")
//	#       define  MDRV    // monolithic driver. reqd for IF (!WFW & !DYNL)
//	#       define  TSK             // it's a Process--Can use win msging. No DLLSCHED
//	#       define  IFK             // Use IFKERNEL services (Alloc/Free etc)
//	#       define  KFIL    // Use Win Kernel FILEIO services
//	//#		define  PCR             // Page Critical. Reqd for safe recv. (!MDDI)
//	#       define  MDDI    // exact ModemDDI (rev 0.90)    (MDRV && T3TO && !DYNL)
//	#       define  T3TO    // use local timeouts (not from fcom) in T30 (MDDI)
//	#		define JUNE             // june 6th demo
//	#       define  FASTLOG 		// take this out along with JUNE
//	// #	ifdef DEBUG
//	// #       	define  MON             // monitor bytes (Ortho)
//	// #	endif //DEBUG
//	#endif  //IFFGPROC
/////////////////////////////////////////////////////////////////////						
// +++ josephj Ifaxos was changed so that DEBUGCHK calls DBGCHK,
//		which is not so harmful
//#ifdef DEBUG
//	// not safe to call in BG (snowball==>GPF, IFAX==>timing problems)
//#	define DEBUGCHK_UNSAFE_IN_WFWBG
//#	define DEBUGCHK		UNSAFE_IN_WFWBG
//#endif //DEBUG

#if (defined(CHK) && defined(REC))
#       error REC and CHK combination invalid
#endif
#if defined(MDDI) && !defined(MDRV)
#       error MDDI requires MDRV
#endif
#if defined(DYNL) && defined(MDRV)
#       error DYNL requires !MDRV
#endif
#if !defined(MDRV) && !defined(LPZ)
#       error !MDRV requires LPZ
#endif
#if !defined(LPZ)
#       error New modem-init scheme requires LPZ in _all_ builds
#endif

#if !defined(FILET30) && (defined(FASTLOG) || defined(FAXWATCH))
#       error NOFILE--cant have FASTLOG or FAXWATCH
#endif

#ifdef WIN32
#	ifdef IFK
#		error "IFK option illegal under WIN32"
#	endif
//#	ifndef TSK
//#		error "must use TSK in WIN32. Dllsched option NYI"
//#	endif
#	ifdef NOPRE
#		error NOPRE not supported in WIN32 (cant lockup machine)
#	endif
#	ifdef MDDI
#		error MDDI not supported in WIN32 (need FComCritical())
#	endif
#endif

#ifdef TMR
#	error "TMR option no longer supported"
#endif



	
#ifdef DISCARDFIX
#	define	CODEFIXED	DISCARDABLE
#	define	DATAFIXED	FIXED
#else //DISCARDFIX
#	define	CODEFIXED	FIXED
#	define	DATAFIXED	FIXED
#endif // DISCARDFIX


#ifdef COMMENTS_NEED_TO_BE_REMOVED

/////////////////////////////////////// Tasking/Sleep/Timing options ///////
//
// There are 4 options available
// (1) Tasking/Sleeping thru DLLSCHED: #defs reqd are !TSK !TMR and !IFK
// (2) Tasking/Sleeping thru an IFKERNEL BGproc: #defs reqd TSK IFK and !TMR
// (3) Tasking thru WIN32: #defs reqd WIN32 TSK !IFK !TMR
// (4) Use WM_TIMERs to sleep: #defs reqd TSK TMR  -- NOT SUPPORTED anymore
//
/////////////////////////////////////// Tasking/Sleep/Timing options ///////


//######## GENERAL ##############################
//
// anything labelled (Ortho) is orthogonal to everything else and can be
//      added or removed independently. All others have conditions marked
//      or described below.
//
//
// WFW--requires VC and SMM and !IFK and !KFIL. Can use DYNL or not.
//              If DYNL used then LPZ is reqd & MDRV excluded
// IFF--requires MDRV and TSK and IFK and !DYNL. Can use TMR and/or NTF
//              but currently thats broken. Requires KFIL if any file calls are
//              made.
//
//
// TMR--use Timers & messaging (requires TSK)
// NTF--use WM_NOTIFY msgs also (requires TSK and TMR)
// DYNL & split drivers don't work with IF.
// DYNL and MDRV are mutually exclusive (though both can be absent)
//
//
// Modem Strings. Can use -D LPZ(far) CBZ(code-based) or nothing (near)
// for CBSZ ptrs, but the latter 2 work only with FCOM & CLASS1
// as one piece (i.e. with MDRV defined).
// For WFW--MUST be LPZ. For IF--can be nothing or LPZ. near is better
// CBZ doesn't work yet
//
//######## Debug ##############################
//
// MON-- monitor bytes to port, can be set orthogonal to DEBUG
// DEFS= $(DEFS) -DNOVCOM       ## don't use VCOMM (use with dummy DDRV)
//
//######## WFW specific ##############################
//
// WFW--assumes disk available for r/w during ECM
// only reasonable combos are (T30PROC and not WFW) and (not T30PROC and WFW)
// STATICM--never dynamically allocs. Must be set for WFW
// UCOM--call comm driver thru USER (not directly). Must *not* be set
//              for WFW. Probably don't use for IFF or IFB
//
//######## OBSOLETE BUT USABLE ##############################
//
// SLOW--double all timeouts,
// TO_REALLY_VERBOSE--trace every TO check
//
//######## TOTALLY OBSOLETE -- DO NOT USE ###############
//
// T3TO -- T30 timeouts are local (NPTOs) instead of from FCOM (now foled into MDDI)
//
//######## NOT TESTED IN A WHILE -- DO NOT USE ###############
//
// NCR--don't preempt during negotiation
// DYNMON -- monitor bufs are dynamically alloced. Must be off for WFW
// OLDECM -- old (non-seeking/non-buffered) ver of ECM
//
//######## BROKEN -- DO NOT USE ##############################
//
// Hack for RC224ATF
// DEFS= $(DEFS) -DS7H          ## don't turn this ON. It's broken & not reqd
//
//######## NOT YET IMPLEM ##########################
//
// RECVOEMNSF--not yet implem. Only for IFAX
// PRI--not yet implem, may never be
// USECRP--not tested, may never be
// MMR_AVAIL -- runtime rendering not yet implem. will be soon
//
//##################################################

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\entryid.h ===
/***************************************************************************

    Name      : entryid.h

    Comment   : Entry ID values for Microsoft At Work FAX

    Functions : none

    Created   : 03/01/94

    Author    : Bruce J Kelley

    Contribs  :

    Comments  :

***************************************************************************/

// Provider UUID's
//
// Use uuidgen.exe to generate new UUID's.
//
// At Work Fax Transport:
// 65BA6B50-1756-101B-BA6B-00001B15D43F
#define AWFAXPUID {0x65,0xBA,0x6B,0x50,0x17,0x56,0x10,0x1B,0xBA,0x6B,0x00,0x00,0x1B,0x15,0xD4,0x3F}
// At Work Fax Transport: for the Message Options profile section
// ED3DF040-FD96-1069-BDF0-00AA004A82CB
#define AWFAXPMSGUID {0xED,0x3D,0xF0,0x40,0xFD,0x96,0x10,0x69,0xBD,0xF0,0x00,0xAA,0x00,0x4A,0x82,0xCB}
// Microsoft Fax Address Book Provider MAPIUID
#define MUIDABMAWF {0x66,0x47,0x10,0xc0,0xfc,0xc4,0x10,0x1a,0x87,0x10,0x08,0x00,0x2b,0x2d,0xc5,0xb7}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\devlapi.h ===
//--------------------------------------------------------------------------
//
// Module Name:  DEVLAYER.H
//
// Brief Description:  This module contains declarations for the back end
//                     interfaces for the At Work Fax Printer Device Layer.
//
// Author:  Rajeev Dujari
//
// Copyright (c) 1994 Microsoft Corporation
//
//--------------------------------------------------------------------------
#ifndef _DEVLAYER_
#define _DEVLAYER_

#include <windows.h>
#ifndef WIN32
#include <print.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Function Prototypes
DWORD WINAPI AtWkFax_Open
	(LPDEVMODE lpdv, LPTSTR lpszPort);
BOOL  WINAPI AtWkFax_StartDoc
	(DWORD dwContext, LPBYTE lpszHeader, DWORD cbHeader, DWORD hDC, LPTSTR lpszTitle);
BOOL WINAPI  AtWkFax_SetCopyCount
  (DWORD dwContext, UINT iCopies);
BOOL  WINAPI AtWkFax_StartPage
	(DWORD dwContext);
BOOL  WINAPI AtWkFax_WriteData
	(DWORD dwContext, LPBYTE lpszData, DWORD cbData);
BOOL  WINAPI AtWkFax_EndPage
	(DWORD dwContext);
BOOL  WINAPI AtWkFax_EndDoc
	(DWORD dwContext, LPBYTE lpszHeader, DWORD cbHeader);
BOOL  WINAPI AtWkFax_Abort
	(DWORD dwContext);
BOOL  WINAPI  AtWkFax_Close
	(DWORD dwContext);
BOOL  WINAPI AtWkFax_ExtDeviceMode
	(LPDEVMODE lpdv, LPTSTR lpszPort);
BOOL  WINAPI  AtWkFax_ResetDevice
	(DWORD dwContext, LPDEVMODE lpdv);
BOOL WINAPI AtWkFax_GetResolutions
        (LPTSTR lpszPrinterName,LPTSTR lpszPortName, LPDWORD lpdwResolutions) ;
BOOL WINAPI AtWkFax_GetPaperSizes
        (LPTSTR lpszPrinterName,LPTSTR lpszPortName, LPDWORD lpdwPaperSizes) ;

// Function Pointers
typedef DWORD (WINAPI *AWF_OPEN)
	(LPDEVMODE lpdv, LPTSTR lpszPort);
typedef BOOL  (WINAPI *AWF_STARTDOC)
	(DWORD dwContext, LPBYTE lpszHeader, DWORD cbHeader, DWORD hDC, LPTSTR lpszTitle);\
typedef BOOL  (WINAPI *AWF_SETCOPYCOUNT)
  (DWORD dwContext, UINT iCopies);	
typedef BOOL  (WINAPI *AWF_STARTPAGE)
	(DWORD dwContext);
typedef BOOL  (WINAPI *AWF_WRITEDATA)
	(DWORD dwContext, LPBYTE lpszData, DWORD cbData);
typedef BOOL  (WINAPI *AWF_ENDPAGE)
	(DWORD dwContext);
typedef BOOL  (WINAPI *AWF_ENDDOC)
	(DWORD dwContext, LPBYTE lpszHeader, DWORD cbHeader);
typedef BOOL  (WINAPI *AWF_CLOSE)
	(DWORD dwContext);
typedef BOOL  (WINAPI *AWF_ABORT)
  (DWORD dwContext);
typedef BOOL  (WINAPI *AWF_EXTDEVICEMODE)
	(LPDEVMODE lpdv, LPTSTR lpszPort);
typedef BOOL  (WINAPI *AWF_RESETDEVICE)
    (DWORD dwOld, DWORD dwNew);
typedef BOOL  (WINAPI *AWF_GETRESOLUTIONS)
    (LPTSTR lpszPrinterName,LPTSTR lpszPortName, LPDWORD lpdwResolutions) ;
typedef BOOL  (WINAPI *AWF_GETPAPERSIZES)
    (LPTSTR lpszPrinterName,LPTSTR lpszPortName, LPDWORD lpdwPaperSizes) ;

// Exported Names
#define AWS_OPEN                MAKEINTRESOURCE(10) //"AtWkFax_Open"
#define AWS_STARTDOC            MAKEINTRESOURCE(11) //"AtWkFax_StartDoc"
#define AWS_SETCOPYCOUNT        MAKEINTRESOURCE(12) //"AtWkFax_SetCopyCount"
#define AWS_STARTPAGE           MAKEINTRESOURCE(13) //"AtWkFax_StartPage"
#define AWS_WRITEDATA           MAKEINTRESOURCE(14) //"AtWkFax_WriteData"
#define AWS_ENDPAGE             MAKEINTRESOURCE(15) //"AtWkFax_EndPage"
#define AWS_ENDDOC              MAKEINTRESOURCE(16) //"AtWkFax_EndDoc"
#define AWS_CLOSE               MAKEINTRESOURCE(17) //"AtWkFax_Close"
#define AWS_ABORT               MAKEINTRESOURCE(18) //"AtWkFax_Abort"
#define AWS_EXTDEVICEMODE       MAKEINTRESOURCE(19) //"AtWkFax_ExtDeviceMode"
#define AWS_RESETDEVICE         MAKEINTRESOURCE(20) //"AtWkFax_ResetDevice"
#define AWS_GETRESOLUTIONS      MAKEINTRESOURCE(30) //"AtWkFax_GetResolutions"
#define AWS_GETPAPERSIZES       MAKEINTRESOURCE(31) //"AtWkFax_GetPaperSizes"

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _DEVLAYER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\f2lf.h ===
//
//	F2LF.H		Macros to change FileT30 calls to LFileT30 calls
//			Include it before including <filet30.h>
//			
//
//	History:
//		3/6/94	JosephJ	Created.
//
#define	FileT30Send		LFileT30Send
#define	FileT30Listen		LFileT30Listen
#define	FileT30Abort		LFileT30Abort
#define	FileT30Answer		LFileT30Answer
#define	FileT30ReportRecv	LFileT30ReportRecv
#define	FileT30Status		LFileT30Status
#define	FileT30Init			LFileT30Init
#define	FileT30DeInit		LFileT30DeInit
#define	FileT30AckRecv		LFileT30AckRecv
#define	FileT30ModemClasses	LFileT30ModemClasses
#define	FileT30ReadIniFile	LFileT30ReadIniFile
#define	FileT30SetStatusWindow	LFileT30SetStatusWindow
#ifdef POLLREQ
#define	FileT30PollReq		LFileT30PollReq
#endif

#if 0
USHORT __export WINAPI LFileT30Init(DWORD dwLineID,
			 USHORT usLineIDType, USHORT uClass,
			 LPSTR szSpoolDir,
			 LPSTR szId,
			 LPSTR szDefRecipAddress,
			 LPSTR szDefRecipName,
			 USHORT uAutoAnswer,
			 HWND hwndListen);
#endif

// Also the New config api...
USHORT __export WINAPI LFileT30Configure(
     DWORD dwLineID, USHORT usLineIDType,
     LPNCUPARAMS lpParams,
     BOOL fInstall
     );

// And this dude....
DWORD __export WINAPI LFileT30ReportSend(
		BOOL fGetIt,
		LPDWORD  lpdwSend, LPDWORD lpdwDur, LPDWORD lpdwFmt
		);
	// Returns 0 if nothing to report. Else returns NETFAX recip error code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\et30type.h ===
/**************************************************************************
	Name      :	ET30TYPE.H
	Comment   :	Types used in several et30 modules

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

	Revision Log
	Num   Date      Name     Description
	--- -------- ---------- -----------------------------------------------
***************************************************************************/


#include <fr.h>

/****

typedef		BYTE far*		LPB;
typedef		LPB	 far*		LPLPB;
typedef		WORD far*		LPWORD;
typedef		void far*		LPVOID;
typedef		signed short	SWORD;
typedef		signed long		SLONG;

typedef		LPBUFFER far*	LPLPBUFFER;

****/




/**** ERR values returned by GetLastError() ***
// used in T30
#define ERR_T1_TIMEOUT_SEND		41
#define ERR_T1_TIMEOUT_RECV		42
#define ERR_3TCFS_NOREPLY		43
#define ERR_3TCFS_DISDTC		44
#define ERR_TCF_BADREPLY		45 
#define ERR_3POSTPAGES_NOREPLY	46
#define ERR_T2_TIMEOUT			47

****/




typedef enum {
	actionNULL=0,
	actionFALSE,		actionTRUE,			actionERROR,
	actionHANGUP,		actionDCN,			// actionCONTINUE,
	// actionSUCCESS,

	actionGONODE_T,		actionGONODE_R1,	actionGONODE_R2,
	actionGONODE_A,		actionGONODE_D,		actionGONODE_E,
	actionGONODE_F,

	actionGONODE_I,		actionGONODE_II,	actionGONODE_III,
	actionGONODE_IV,	actionGONODE_V,		actionGONODE_VII,
	actionGONODE_RECVCMD,
	actionGONODE_ECMRETRANSMIT,
	actionGONODE_RECVPHASEC,
	actionGONODE_RECVECMRETRANSMIT,

	actionSEND_DIS,		actionSEND_DTC,		actionSEND_DCS,
	actionSENDMPS,		actionSENDEOM,		actionSENDEOP,
	actionSENDMCF,		actionSENDRTP,		actionSENDRTN,
	actionSENDFTT,		actionSENDCFR,		actionSENDEOR_EOP,
	actionGETTCF,		actionSKIPTCF,
	actionSENDDCSTCF,	actionDCN_SUCCESS,	actionNODEF_SUCCESS,
	actionHANGUP_SUCCESS
#ifdef PRI
	,actionGONODE_RECVPRIQ,					actionGOVOICE,
	actionSENDPIP,							actionSENDPIN
#endif
#ifdef IFP
	,actionGONODE_IFP_SEND,	actionGONODE_IFP_RECV
#endif
} ET30ACTION;


typedef enum {
	eventNULL = 0,
	eventGOTFRAMES, 	eventNODE_A, 		eventSENDDCS,
	eventGOTFTT, 		eventGOTCFR,		eventSTARTSEND,
	eventPOSTPAGE,
	eventGOTPOSTPAGERESP, 					eventGOT_ECM_PPS_RESP,

	eventSENDDIS, 		eventSENDDTC,		eventRECVCMD,
	eventGOTTCF,		eventSTARTRECV,		eventRECVPOSTPAGECMD,

	eventECM_POSTPAGE, 	event4THPPR,		eventNODE_T,
	eventNODE_R,

#ifdef PRI
	eventGOTPINPIP, eventVOICELINE, eventQUERYLOCALINT
#endif

} ET30EVENT;




/** ifr indexes. These numbers must match the ones in hdlc.c.
 ** They must be consecutive, and start from 1
 **/

#define 	ifrNULL		0
#define 	ifrDIS		1
#define 	ifrCSI		2
#define 	ifrNSF		3
#define		ifrDTC		4
#define		ifrCIG		5
#define		ifrNSC		6
#define		ifrDCS		7
#define		ifrTSI		8
#define		ifrNSS		9
#define		ifrCFR		10
#define		ifrFTT		11
#define		ifrMPS		12
#define		ifrEOM		13
#define		ifrEOP		14
#define		ifrPWD		15
#define		ifrSEP		16
#define		ifrSUB		17
#define		ifrMCF		18
#define		ifrRTP		19
#define		ifrRTN		20
#define		ifrPIP		21
#define		ifrPIN		22
#define		ifrDCN		23
#define		ifrCRP		24 

#define		ifrPRI_MPS		25
#define		ifrPRI_EOM		26
#define		ifrPRI_EOP		27

#define		ifrPRI_FIRST	ifrPRI_MPS
#define		ifrPRI_LAST		ifrPRI_EOP

	/********* ECM stuff starts here. T.30 section A.4 ******/

#define		ifrCTC		28
#define		ifrCTR		29
#define		ifrRR		30
#define		ifrPPR		31
#define		ifrRNR		32
#define		ifrERR		33

#define		ifrPPS_NULL		34
#define		ifrPPS_MPS		35
#define		ifrPPS_EOM		36
#define		ifrPPS_EOP		37
#define		ifrPPS_PRI_MPS	38
#define		ifrPPS_PRI_EOM	39
#define		ifrPPS_PRI_EOP	40

#define 	ifrPPS_FIRST		ifrPPS_NULL
#define 	ifrPPS_LAST			ifrPPS_PRI_EOP
#define		ifrPPS_PRI_FIRST	ifrPPS_PRI_MPS
#define		ifrPPS_PRI_LAST		ifrPPS_PRI_EOP

#define		ifrEOR_NULL		41
#define		ifrEOR_MPS		42
#define		ifrEOR_EOM		43
#define		ifrEOR_EOP		44
#define		ifrEOR_PRI_MPS	45
#define		ifrEOR_PRI_EOM	46
#define		ifrEOR_PRI_EOP	47

#define 	ifrEOR_FIRST		ifrEOR_NULL
#define 	ifrEOR_LAST			ifrEOR_PRI_EOP
#define		ifrEOR_PRI_FIRST	ifrEOR_PRI_MPS
#define		ifrEOR_PRI_LAST		ifrEOR_PRI_EOP

#define		ifrECM_FIRST	ifrCTC
#define		ifrECM_LAST		ifrEOR_PRI_EOP

#define 	ifrMAX		48		// Max legal values (not incl this one)
#define		ifrBAD		49
#define		ifrTIMEOUT	50
// #define		ifrERROR	51




/**** Global buffer mgmnt ****/


#define MAXFRAMESIZE	132

// #define ECM_FRAME_SIZE	256
// #define ECM_EXTRA		9	// 4 for prefix, 2 for suffix, 3 for slack in recv


#ifdef IFK
	// use same for 64 bytes frames also
#	define MY_ECMBUF_SIZE			BYTE_265_SIZE
#	define MY_ECMBUF_ACTUALSIZE		BYTE_265_ACTUALSIZE
#	define MY_BIGBUF_SIZE			BYTE_265_SIZE
#	define MY_BIGBUF_ACTUALSIZE		BYTE_265_ACTUALSIZE
#else //IFK
	// use same for 64 bytes frames also
#	define MY_ECMBUF_SIZE			(256 + 9)	
#	define MY_ECMBUF_ACTUALSIZE		(256 + 9)
#	define MY_BIGBUF_SIZE			(MY_ECMBUF_SIZE * 4)
#	define MY_BIGBUF_ACTUALSIZE		(MY_ECMBUF_SIZE * 4)
#endif //IFK


#ifndef MDDI

// too long
// #define PAGE_PREAMBLE    1700
// too long
// #define PAGE_PREAMBLE    400
// MUST BE LESS THAN 375 (TCF length at 2400bps)
// too short for slow 386/20 with Twincom at 9600
// #define PAGE_PREAMBLE   100

// too long
// #define PAGE_POSTAMBLE  500
// #define PAGE_POSTAMBLE  250

// Can all teh above. WE're going to make it a factor of the TCF len
// #define	PAGE_PREAMBLE_DIV	3	// 500ms preamble at all speeds
// let's be nice & safe & use 750ms (see bug#1196)
#define	PAGE_PREAMBLE_DIV	2	// 750ms preamble at all speeds

// Postamble is not that important so use a smaller time
#define	PAGE_POSTAMBLE_DIV	3	// 500ms preamble at all speeds
// #define	PAGE_POSTAMBLE_DIV	2	// 750ms preamble at all speeds

#else //MDDI

#define	PAGE_PREAMBLE_DIV	0	// no preamble
#define	PAGE_POSTAMBLE_DIV	0	// no preamble

#endif //MDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\errormod.h ===
#ifndef _ERRORMOD_H
#define _ERRORMOD_H


// IFKERNEL API's
#define API_IFK_ALLOCBUF	         0x0040
#define API_IFK_FREEBUF	            0x0080
#define API_IFK_MAKEBUFWRITABLE	   0x00c0
#define API_IFK_SHAREBUF	         0x0100
#define API_IFK_SPLITBUF	         0x0140

#define API_IFK_IFGLOBALALLOC       0x1000
#define API_IFK_IFGLOBALFREE        0x1040

#define API_IFK_CREATEIFPIPE	      0x2000
#define API_IFK_DELETEIFPIPE	      0x2040
#define API_IFK_OPENIFPIPE	         0x2080
#define API_IFK_CLOSEIFPIPE	      0x20c0
#define API_IFK_REQREADFROMIFPIPE	0x2100
#define API_IFK_REQWRITETOIFPIPE	   0x2140

#define API_IFK_NEWMEMUNIT	         0x3040

#define API_IFK_POSTMESSAGE	      0x4000
#define API_IFK_GETMESSAGE		      0x4040
#define API_IFK_PEEKMESSAGE	      0x4080
#define API_IFK_BROADCASTMESSAGE	   0x40c0

#define API_IFK_CREATEPROCESS       0x5000
#define API_IFK_TERMINATEAPP            0x5040
#define API_IFK_GETIFPROCWINDOW         0x5080
#define API_IFK_SETIFPROCPRIORITY       0x50C0
#define API_IFK_GETIFPROCPRIORITY       0x5100

#define API_IFK_CREATEMUTEX	            0x6000
#define API_IFK_RELEASEMUTEX	        0x6040
#define API_IFK_CREATEEVENT	            0x6080
#define API_IFK_SETEVENT		        0x60c0   
#define API_IFK_WAITFORSINGLEOBJECT	    0x6100
#define API_IFK_FREESYNCOBJECT	        0x6140
#define API_IFK_GETSETEVENTPARAM        0x6180

#define API_IFK_IFSETTIMER             0x7000


//IFSCAN APIs (High level scanner driver: error codes in prnscn.h)
#define	API_OPENSCANNER				0x0040
#define	API_CLOSESCANNER			0x0080
#define	API_STARTSCANJOB			0x00c0
#define	API_ENDSCANJOB				0x0100
#define	API_CONTINUESCANJOB			0x0200
#define	API_ABORTSCANJOB			0x0300
#define	API_GETSCANNERSTATUS		0x0400
#define API_GETSCANNERPAPERINFO	  	0x0500
#define	API_GETSCANIMAGEINFO		0x0600
#define	API_GETSCANNERCAPS			0x0700
#define	API_GETSCANNERCUSTOMCAPS	0x0800
#define	API_COMPLETESCANPAGE		0x0900
#define	API_GETSCANDEVICEINFO		0x0a00
#define	API_SELECTSCANDEVICE		0x0b00
#define	API_SCANDEVICEMODE			0x0c00
#define	API_INITIFSCAN				0x0d00
#define	API_SCANDIAGNOSTICJOB		0x0e00
#define	API_GETDEVINFOFROMID		0x0f00
#define	API_GETDEVINFOFROMSTR		0x1000
#define	API_GETDEVDEFAULTMODE		0x1100
#define API_SCANNERPREFEED			0x1200
#define API_STARTCOPYJOB			0x1300
#define API_ENDCOPYJOB				0x1400

//IFPRINT (high level printer drivers api: error codes in prnscn.h)
#define	API_SELECTPRINTDEVICE		0x0a00
#define	API_GETPRINTDEVICEINFO		0x0900
#define	API_PRINTDEVICEMODE			0x0b00
#define	API_PRINTDIAGNOSTICJOB		0x0c00
#define API_CHECKPRINTERSTATUS		0x0d00

//Awreport(the report engine)
#define	API_AWREPORTMESSAGE			0x0a00


//Remote Access APIs (Remote Access Apis)
//IPX
#define	API_PSINIT				0x0040
#define	API_INITIATEBIND		0x0080

//MAC
#define	API_MACINIT				0x0040


//Renderer APIs

#define	API_RENDEROPEN				0x0040
#define	API_RENDEREXECUTE			0x0080
#define	API_RENDERCLOSE				0x00c0


//  Message pump events disguised as APIs

                                       // APICODE BITS | ERRCODE BITS
#define API_JOBMESSAGE        0x0040   // 0000 0000 01 | 00 0000
#define API_JOBCOMPLETE       0x0080   // 0000 0000 10 | 00 0000
#define API_JOBERRCOMPLETE    0x00C0   // 0000 0000 11 | 00 0000

#define API_MPJOBCANCEL       0x0100   
#define API_MPREJECTMSG       0x0140   
#define API_MPANSWER          0x0180   
#define API_MPTRANSPORT       0x01C0   
#define API_MPPOLLRETRIEVE    0x0200   
#define API_MPDEST            0x0240   




// WINDOWS MODULE API's 
#define WERR_OK  0x0
#define WERR_GETVERSION 0x40
#define WERR_GETFREESPACE 0x80
#define WERR_GETCURRENTPDB 0xC0
#define WERR_GETWINDOWSDIRECTORY 0x100
#define WERR_GETSYSTEMDIRECTORY 0x140
#define WERR_GETFREESYSTEMRESOURCES 0x180
#define WERR_GETWINFLAGS 0x1C0
#define WERR_GETDOSENVIRONMENT 0x200
#define WERR_GETCURRENTTIME 0x240
#define WERR_GETTICKCOUNT 0x280
#define WERR_GETTIMERRESOLUTION 0x2C0
#define WERR_LOGERROR 0x300
#define WERR_LOGPARAMERROR 0x340
#define WERR_GETWINDEBUGINFO 0x380
#define WERR_SETWINDEBUGINFO 0x3C0
#define WERR_FATALEXIT 0x400
#define WERR_FATALAPPEXIT 0x440
#define WERR_EXITWINDOWS 0x480
#define WERR_EXITWINDOWSEXEC 0x4C0
#define WERR_DEBUGBREAK 0x500
#define WERR_OUTPUTDEBUGSTRING 0x540
#define WERR_SETERRORMODE 0x580
#define WERR_ISBADREADPTR 0x5C0
#define WERR_ISBADWRITEPTR 0x600
#define WERR_ISBADHUGEREADPTR 0x640
#define WERR_ISBADHUGEWRITEPTR 0x680
#define WERR_ISBADCODEPTR 0x6C0
#define WERR_ISBADSTRINGPTR 0x700
#define WERR_PROFINSCHK 0x740
#define WERR_PROFSETUP 0x780
#define WERR_PROFSAMPRATE 0x7C0
#define WERR_PROFSTART 0x800
#define WERR_PROFSTOP 0x840
#define WERR_PROFCLEAR 0x880
#define WERR_PROFFLUSH 0x8C0
#define WERR_PROFFINISH 0x900
#define WERR_CATCH 0x940
#define WERR_THROW 0x980
#define WERR_SWITCHSTACKBACK 0x9C0
#define WERR_SWITCHSTACKTO 0xA00
#define WERR_LOADMODULE 0xA40
#define WERR_FREEMODULE 0xA80
#define WERR_LOADLIBRARY 0xAC0
#define WERR_FREELIBRARY 0xB00
#define WERR_WINEXEC 0xB40
#define WERR_GETMODULEHANDLE 0xB80
#define WERR_GETMODULEUSAGE 0xBC0
#define WERR_GETMODULEFILENAME 0xC00
#define WERR_GETPROCADDRESS 0xC40
#define WERR_GETINSTANCEDATA 0xC80
#define WERR_GETCODEHANDLE 0xCC0
#define WERR_GETCODEINFO 0xD00
#define WERR_MAKEPROCINSTANCE 0xD40
#define WERR_FREEPROCINSTANCE 0xD80
#define WERR_SETSWAPAREASIZE 0xDC0
#define WERR_SWAPRECORDING 0xE00
#define WERR_VALIDATECODESEGMENTS 0xE40
#define WERR_GETNUMTASKS 0xE80
#define WERR_ISTASK 0xEC0
#define WERR_GETCURRENTTASK 0xF00
#define WERR_YIELD 0xF40
#define WERR_DIRECTEDYIELD 0xF80
#define WERR_GLOBALALLOC 0xFC0
#define WERR_GLOBALREALLOC 0x1000
#define WERR_GLOBALFREE 0x1040
#define WERR_GLOBALDOSALLOC 0x1080
#define WERR_GLOBALDOSFREE 0x10C0
#define WERR_GLOBALLOCK 0x1100
//#define WERR_GLOBALLOCK 0x1140
#define WERR_GLOBALUNLOCK 0x1180
#define WERR_GLOBALSIZE 0x11C0
#define WERR_GLOBALHANDLE 0x1200
#define WERR_GLOBALFLAGS 0x1240
#define WERR_GLOBALWIRE 0x1280
//#define WERR_GLOBALWIRE 0x12C0
#define WERR_GLOBALUNWIRE 0x1300
#define WERR_GLOBALPAGELOCK 0x1340
#define WERR_GLOBALPAGEUNLOCK 0x1380
#define WERR_GLOBALFIX 0x13C0
#define WERR_GLOBALUNFIX 0x1400
#define WERR_GLOBALLRUNEWEST 0x1440
#define WERR_GLOBALLRUOLDEST 0x1480
#define WERR_GLOBALCOMPACT 0x14C0
#define WERR_GLOBALNOTIFY 0x1500
#define WERR_LOCKSEGMENT 0x1540
#define WERR_UNLOCKSEGMENT 0x1580
#define WERR_ALLOCSELECTOR 0x15C0
#define WERR_FREESELECTOR 0x1600
#define WERR_ALLOCDSTOCSALIAS 0x1640
#define WERR_PRESTOCHANGOSELECTOR 0x1680
#define WERR_GETSELECTORBASE 0x16C0
#define WERR_SETSELECTORBASE 0x1700
#define WERR_GETSELECTORLIMIT 0x1740
#define WERR_SETSELECTORLIMIT 0x1780
#define WERR_LIMITEMSPAGES 0x17C0
#define WERR_VALIDATEFREESPACES 0x1800
#define WERR_LOCALALLOC 0x1840
#define WERR_LOCALREALLOC 0x1880
#define WERR_LOCALFREE 0x18C0
#define WERR_LOCALLOCK 0x1900
//#define WERR_LOCALLOCK 0x1940
#define WERR_LOCALUNLOCK 0x1980
#define WERR_LOCALSIZE 0x19C0
#define WERR_LOCALHANDLE 0x1A00
//#define WERR_LOCALHANDLE 0x1A40
#define WERR_LOCALFLAGS 0x1A80
#define WERR_LOCALINIT 0x1AC0
#define WERR_LOCALCOMPACT 0x1B00
#define WERR_LOCALSHRINK 0x1B40
#define WERR_OPENFILE 0x1B80
#define WERR__LOPEN 0x1BC0
#define WERR__LCREAT 0x1C00
#define WERR__LCLOSE 0x1C40
#define WERR__LLSEEK 0x1C80
#define WERR__LREAD 0x1CC0
#define WERR__LWRITE 0x1D00
#define WERR__HREAD 0x1D40
#define WERR__HWRITE 0x1D80
#define WERR_GETTEMPFILENAME 0x1DC0
#define WERR_GETTEMPDRIVE 0x1E00
#define WERR_GETDRIVETYPE 0x1E40
#define WERR_SETHANDLECOUNT 0x1E80
#define WERR_WNETADDCONNECTION 0x1EC0
#define WERR_WNETGETCONNECTION 0x1F00
#define WERR_WNETCANCELCONNECTION 0x1F40
#define WERR_FINDRESOURCE 0x1F80
#define WERR_LOADRESOURCE 0x1FC0
#define WERR_FREERESOURCE 0x2000
#define WERR_LOCKRESOURCE 0x2040
//#define WERR_LOCKRESOURCE 0x2080
#define WERR_SIZEOFRESOURCE 0x20C0
#define WERR_ACCESSRESOURCE 0x2100
#define WERR_ALLOCRESOURCE 0x2140
#define WERR_SETRESOURCEHANDLER 0x2180
#define WERR_INITATOMTABLE 0x21C0
#define WERR_ADDATOM 0x2200
#define WERR_DELETEATOM 0x2240
#define WERR_FINDATOM 0x2280
#define WERR_GETATOMNAME 0x22C0
#define WERR_GLOBALADDATOM 0x2300
#define WERR_GLOBALDELETEATOM 0x2340
#define WERR_GLOBALFINDATOM 0x2380
#define WERR_GLOBALGETATOMNAME 0x23C0
#define WERR_GETATOMHANDLE 0x2400
#define WERR_GETPROFILEINT 0x2440
#define WERR_GETPROFILESTRING 0x2480
#define WERR_WRITEPROFILESTRING 0x24C0
#define WERR_GETPRIVATEPROFILEINT 0x2500
#define WERR_GETPRIVATEPROFILESTRING 0x2540
#define WERR_WRITEPRIVATEPROFILESTRING 0x2580
#define WERR_ANSITOOEM 0x25C0
#define WERR_OEMTOANSI 0x2600
#define WERR_ANSITOOEMBUFF 0x2640
#define WERR_OEMTOANSIBUFF 0x2680
#define WERR_ANSINEXT 0x26C0
#define WERR_ANSIPREV 0x2700
#define WERR_ANSIUPPER 0x2740
#define WERR_ANSILOWER 0x2780
#define WERR_ANSIUPPERBUFF 0x27C0
#define WERR_ANSILOWERBUFF 0x2800
#define WERR_ISCHARALPHA 0x2840
#define WERR_ISCHARALPHANUMERIC 0x2880
#define WERR_ISCHARUPPER 0x28C0
#define WERR_ISCHARLOWER 0x2900
#define WERR_LSTRCMP 0x2940
#define WERR_LSTRCMPI 0x2980
#define WERR_LSTRCPY 0x29C0
#define WERR_LSTRCAT 0x2A00
#define WERR_LSTRLEN 0x2A40
#define WERR_LSTRCPYN 0x2A80
#define WERR_HMEMCPY 0x2AC0
#define WERR_ISDBCSLEADBYTE 0x2B00
#define WERR_LOADSTRING 0x2B40
#define WERR_OEMKEYSCAN 0x2B80
#define WERR_VKKEYSCAN 0x2BC0
#define WERR_GETKEYBOARDTYPE 0x2C00
#define WERR_MAPVIRTUALKEY 0x2C40
#define WERR_GETKBCODEPAGE 0x2C80
#define WERR_GETKEYNAMETEXT 0x2CC0
#define WERR_TOASCII 0x2D00
#define WERR_CREATEDC 0x2D40
#define WERR_CREATEIC 0x2D80
#define WERR_CREATECOMPATIBLEDC 0x2DC0
#define WERR_DELETEDC 0x2E00
#define WERR_GETDCORG 0x2E40
#define WERR_SAVEDC 0x2E80
#define WERR_RESTOREDC 0x2EC0
#define WERR_SETENVIRONMENT 0x2F00
#define WERR_GETENVIRONMENT 0x2F40
#define WERR_MULDIV 0x2F80
#define WERR_SETBOUNDSRECT 0x2FC0
#define WERR_GETBOUNDSRECT 0x3000
#define WERR_GETDEVICECAPS 0x3040
#define WERR_SETMAPMODE 0x3080
#define WERR_GETMAPMODE 0x30C0
#define WERR_SETWINDOWORG 0x3100
#define WERR_GETWINDOWORG 0x3140
#define WERR_SETWINDOWEXT 0x3180
#define WERR_GETWINDOWEXT 0x31C0
#define WERR_OFFSETWINDOWORG 0x3200
#define WERR_SCALEWINDOWEXT 0x3240
#define WERR_SETVIEWPORTORG 0x3280
#define WERR_GETVIEWPORTORG 0x32C0
#define WERR_SETVIEWPORTEXT 0x3300
#define WERR_GETVIEWPORTEXT 0x3340
#define WERR_OFFSETVIEWPORTORG 0x3380
#define WERR_SCALEVIEWPORTEXT 0x33C0
#define WERR_SETWINDOWORGEX 0x3400
#define WERR_GETWINDOWORGEX 0x3440
#define WERR_SETWINDOWEXTEX 0x3480
#define WERR_GETWINDOWEXTEX 0x34C0
#define WERR_OFFSETWINDOWORGEX 0x3500
#define WERR_SCALEWINDOWEXTEX 0x3540
#define WERR_SETVIEWPORTEXTEX 0x3580
#define WERR_GETVIEWPORTEXTEX 0x35C0
#define WERR_SETVIEWPORTORGEX 0x3600
#define WERR_GETVIEWPORTORGEX 0x3640
#define WERR_OFFSETVIEWPORTORGEX 0x3680
#define WERR_SCALEVIEWPORTEXTEX 0x36C0
#define WERR_DPTOLP 0x3700
#define WERR_LPTODP 0x3740
#define WERR_GETNEARESTCOLOR 0x3780
#define WERR_GETSYSCOLOR 0x37C0
#define WERR_SETSYSCOLORS 0x3800
#define WERR_GETSTOCKOBJECT 0x3840
#define WERR_ISGDIOBJECT 0x3880
#define WERR_DELETEOBJECT 0x38C0
#define WERR_SELECTOBJECT 0x3900
#define WERR_GETOBJECT 0x3940
#define WERR_UNREALIZEOBJECT 0x3980
#define WERR_ENUMOBJECTS 0x39C0
//#define WERR_ENUMOBJECTS 0x3A00
#define WERR_CREATEPEN 0x3A40
#define WERR_CREATEPENINDIRECT 0x3A80
#define WERR_CREATESOLIDBRUSH 0x3AC0
#define WERR_CREATEHATCHBRUSH 0x3B00
#define WERR_CREATEPATTERNBRUSH 0x3B40
#define WERR_CREATEDIBPATTERNBRUSH 0x3B80
#define WERR_CREATEBRUSHINDIRECT 0x3BC0
#define WERR_SETBRUSHORG 0x3C00
#define WERR_GETBRUSHORG 0x3C40
#define WERR_GETBRUSHORGEX 0x3C80
#define WERR_CREATERECTRGN 0x3CC0
#define WERR_CREATERECTRGNINDIRECT 0x3D00
#define WERR_CREATEELLIPTICRGNINDIRECT 0x3D40
#define WERR_CREATEELLIPTICRGN 0x3D80
#define WERR_CREATEPOLYGONRGN 0x3DC0
#define WERR_CREATEPOLYPOLYGONRGN 0x3E00
#define WERR_CREATEROUNDRECTRGN 0x3E40
#define WERR_SETRECTRGN 0x3E80
#define WERR_COMBINERGN 0x3EC0
#define WERR_EQUALRGN 0x3F00
#define WERR_OFFSETRGN 0x3F40
#define WERR_GETRGNBOX 0x3F80
#define WERR_RECTINREGION 0x3FC0
#define WERR_PTINREGION 0x4000
#define WERR_CREATEPALETTE 0x4040
#define WERR_SELECTPALETTE 0x4080
#define WERR_REALIZEPALETTE 0x40C0
#define WERR_UPDATECOLORS 0x4100
#define WERR_ANIMATEPALETTE 0x4140
#define WERR_SETPALETTEENTRIES 0x4180
#define WERR_GETPALETTEENTRIES 0x41C0
#define WERR_GETNEARESTPALETTEINDEX 0x4200
#define WERR_RESIZEPALETTE 0x4240
#define WERR_GETSYSTEMPALETTEENTRIES 0x4280
#define WERR_GETSYSTEMPALETTEUSE 0x42C0
#define WERR_SETSYSTEMPALETTEUSE 0x4300
#define WERR_SELECTCLIPRGN 0x4340
#define WERR_GETCLIPBOX 0x4380
#define WERR_INTERSECTCLIPRECT 0x43C0
#define WERR_OFFSETCLIPRGN 0x4400
#define WERR_EXCLUDECLIPRECT 0x4440
#define WERR_PTVISIBLE 0x4480
#define WERR_RECTVISIBLE 0x44C0
#define WERR_MOVETO 0x4500
#define WERR_GETCURRENTPOSITION 0x4540
#define WERR_MOVETOEX 0x4580
#define WERR_GETCURRENTPOSITIONEX 0x45C0
#define WERR_LINETO 0x4600
#define WERR_POLYLINE 0x4640
#define WERR_LINEDDA 0x4680
#define WERR_RECTANGLE 0x46C0
#define WERR_ROUNDRECT 0x4700
#define WERR_ELLIPSE 0x4740
#define WERR_ARC 0x4780
#define WERR_CHORD 0x47C0
#define WERR_PIE 0x4800
#define WERR_POLYGON 0x4840
#define WERR_POLYPOLYGON 0x4880
#define WERR_SETPOLYFILLMODE 0x48C0
#define WERR_GETPOLYFILLMODE 0x4900
#define WERR_FLOODFILL 0x4940
#define WERR_EXTFLOODFILL 0x4980
#define WERR_FILLRGN 0x49C0
#define WERR_FRAMERGN 0x4A00
#define WERR_INVERTRGN 0x4A40
#define WERR_PAINTRGN 0x4A80
#define WERR_FILLRECT 0x4AC0
#define WERR_FRAMERECT 0x4B00
#define WERR_INVERTRECT 0x4B40
#define WERR_DRAWFOCUSRECT 0x4B80
#define WERR_TEXTOUT 0x4BC0
#define WERR_TABBEDTEXTOUT 0x4C00
#define WERR_EXTTEXTOUT 0x4C40
#define WERR_GETTEXTEXTENT 0x4C80
#define WERR_GETTABBEDTEXTEXTENT 0x4CC0
#define WERR_GETTEXTEXTENTPOINT 0x4D00
#define WERR_DRAWTEXT 0x4D40
#define WERR_GRAYSTRING 0x4D80
#define WERR_GETCHARWIDTH 0x4DC0
#define WERR_SETTEXTCOLOR 0x4E00
#define WERR_GETTEXTCOLOR 0x4E40
#define WERR_SETBKCOLOR 0x4E80
#define WERR_GETBKCOLOR 0x4EC0
#define WERR_SETBKMODE 0x4F00
#define WERR_GETBKMODE 0x4F40
#define WERR_SETTEXTALIGN 0x4F80
#define WERR_GETTEXTALIGN 0x4FC0
#define WERR_SETTEXTCHARACTEREXTRA 0x5000
#define WERR_GETTEXTCHARACTEREXTRA 0x5040
#define WERR_SETTEXTJUSTIFICATION 0x5080
#define WERR_CREATEFONT 0x50C0
#define WERR_CREATEFONTINDIRECT 0x5100
#define WERR_SETMAPPERFLAGS 0x5140
#define WERR_ADDFONTRESOURCE 0x5180
#define WERR_REMOVEFONTRESOURCE 0x51C0
#define WERR_GETTEXTFACE 0x5200
#define WERR_GETASPECTRATIOFILTER 0x5240
#define WERR_GETASPECTRATIOFILTEREX 0x5280
#define WERR_GETTEXTMETRICS 0x52C0
#define WERR_GETOUTLINETEXTMETRICS 0x5300
#define WERR_ENUMFONTFAMILIES 0x5340
#define WERR_ENUMFONTS 0x5380
//#define WERR_ENUMFONTS 0x53C0
//#define WERR_ENUMFONTFAMILIES 0x5400
#define WERR_GETFONTDATA 0x5440
#define WERR_CREATESCALABLEFONTRESOURCE 0x5480
#define WERR_GETGLYPHOUTLINE 0x54C0
#define WERR_GETCHARABCWIDTHS 0x5500
#define WERR_GETKERNINGPAIRS 0x5540
#define WERR_GETRASTERIZERCAPS 0x5580
#define WERR_CREATEBITMAP 0x55C0
#define WERR_CREATEBITMAPINDIRECT 0x5600
#define WERR_CREATECOMPATIBLEBITMAP 0x5640
#define WERR_CREATEDISCARDABLEBITMAP 0x5680
#define WERR_CREATEDIBITMAP 0x56C0
#define WERR_LOADBITMAP 0x5700
#define WERR_BITBLT 0x5740
#define WERR_PATBLT 0x5780
#define WERR_STRETCHBLT 0x57C0
#define WERR_STRETCHDIBITS 0x5800
#define WERR_SETPIXEL 0x5840
#define WERR_GETPIXEL 0x5880
#define WERR_SETSTRETCHBLTMODE 0x58C0
#define WERR_GETSTRETCHBLTMODE 0x5900
#define WERR_SETBITMAPDIMENSION 0x5940
#define WERR_GETBITMAPDIMENSION 0x5980
#define WERR_SETBITMAPDIMENSIONEX 0x59C0
#define WERR_GETBITMAPDIMENSIONEX 0x5A00
#define WERR_SETROP2 0x5A40
#define WERR_GETROP2 0x5A80
#define WERR_SETBITMAPBITS 0x5AC0
#define WERR_GETBITMAPBITS 0x5B00
#define WERR_SETDIBITS 0x5B40
#define WERR_GETDIBITS 0x5B80
#define WERR_SETDIBITSTODEVICE 0x5BC0
#define WERR_CREATEMETAFILE 0x5C00
#define WERR_CLOSEMETAFILE 0x5C40
#define WERR_GETMETAFILE 0x5C80
#define WERR_DELETEMETAFILE 0x5CC0
#define WERR_COPYMETAFILE 0x5D00
#define WERR_PLAYMETAFILE 0x5D40
#define WERR_GETMETAFILEBITS 0x5D80
#define WERR_SETMETAFILEBITS 0x5DC0
#define WERR_SETMETAFILEBITSBETTER 0x5E00
#define WERR_PLAYMETAFILERECORD 0x5E40
#define WERR_ENUMMETAFILE 0x5E80
#define WERR_STARTDOC 0x5EC0
#define WERR_STARTPAGE 0x5F00
#define WERR_ENDPAGE 0x5F40
#define WERR_ENDDOC 0x5F80
#define WERR_ABORTDOC 0x5FC0
#define WERR_SETABORTPROC 0x6000
#define WERR_SPOOLFILE 0x6040
#define WERR_QUERYABORT 0x6080
#define WERR_ESCAPE 0x60C0
#define WERR_GETSYSTEMMETRICS 0x6100
#define WERR_GETDOUBLECLICKTIME 0x6140
#define WERR_SETDOUBLECLICKTIME 0x6180
#define WERR_SYSTEMPARAMETERSINFO 0x61C0
#define WERR_SETRECT 0x6200
#define WERR_SETRECTEMPTY 0x6240
#define WERR_COPYRECT 0x6280
#define WERR_ISRECTEMPTY 0x62C0
#define WERR_EQUALRECT 0x6300
#define WERR_INTERSECTRECT 0x6340
#define WERR_UNIONRECT 0x6380
#define WERR_SUBTRACTRECT 0x63C0
#define WERR_OFFSETRECT 0x6400
#define WERR_INFLATERECT 0x6440
#define WERR_PTINRECT 0x6480
#define WERR_REGISTERWINDOWMESSAGE 0x64C0
#define WERR_GETMESSAGE 0x6500
#define WERR_PEEKMESSAGE 0x6540
#define WERR_WAITMESSAGE 0x6580
#define WERR_GETMESSAGEPOS 0x65C0
#define WERR_GETMESSAGETIME 0x6600
#define WERR_GETMESSAGEEXTRAINFO 0x6640
#define WERR_TRANSLATEMESSAGE 0x6680
#define WERR_DISPATCHMESSAGE 0x66C0
#define WERR_SETMESSAGEQUEUE 0x6700
#define WERR_GETINPUTSTATE 0x6740
#define WERR_GETQUEUESTATUS 0x6780
#define WERR_POSTMESSAGE 0x67C0
#define WERR_SENDMESSAGE 0x6800
#define WERR_POSTAPPMESSAGE 0x6840
#define WERR_REPLYMESSAGE 0x6880
#define WERR_INSENDMESSAGE 0x68C0
#define WERR_CALLMSGFILTER 0x6900
#define WERR_POSTQUITMESSAGE 0x6940
#define WERR_REGISTERCLASS 0x6980
#define WERR_UNREGISTERCLASS 0x69C0
#define WERR_GETCLASSINFO 0x6A00
#define WERR_GETCLASSNAME 0x6A40
#define WERR_GETCLASSWORD 0x6A80
#define WERR_SETCLASSWORD 0x6AC0
#define WERR_GETCLASSLONG 0x6B00
#define WERR_SETCLASSLONG 0x6B40
#define WERR_ISWINDOW 0x6B80
#define WERR_CREATEWINDOWEX 0x6BC0
#define WERR_CREATEWINDOW 0x6C00
#define WERR_DESTROYWINDOW 0x6C40
#define WERR_GETWINDOWTASK 0x6C80
#define WERR_ISCHILD 0x6CC0
#define WERR_GETPARENT 0x6D00
#define WERR_SETPARENT 0x6D40
#define WERR_ISWINDOWVISIBLE 0x6D80
#define WERR_SHOWWINDOW 0x6DC0
#define WERR_ENABLEWINDOW 0x6E00
#define WERR_ISWINDOWENABLED 0x6E40
#define WERR_SETWINDOWTEXT 0x6E80
#define WERR_GETWINDOWTEXT 0x6EC0
#define WERR_GETWINDOWTEXTLENGTH 0x6F00
#define WERR_GETWINDOWWORD 0x6F40
#define WERR_SETWINDOWWORD 0x6F80
#define WERR_GETWINDOWLONG 0x6FC0
#define WERR_SETWINDOWLONG 0x7000
#define WERR_GETCLIENTRECT 0x7040
#define WERR_GETWINDOWRECT 0x7080
#define WERR_GETWINDOWPLACEMENT 0x70C0
#define WERR_SETWINDOWPLACEMENT 0x7100
#define WERR_SETWINDOWPOS 0x7140
#define WERR_BEGINDEFERWINDOWPOS 0x7180
#define WERR_DEFERWINDOWPOS 0x71C0
#define WERR_ENDDEFERWINDOWPOS 0x7200
#define WERR_MOVEWINDOW 0x7240
#define WERR_BRINGWINDOWTOTOP 0x7280
#define WERR_DEFWINDOWPROC 0x72C0
#define WERR_CALLWINDOWPROC 0x7300
//#define WERR_CALLWINDOWPROC 0x7340
#define WERR_ADJUSTWINDOWRECT 0x7380
#define WERR_ADJUSTWINDOWRECTEX 0x73C0
#define WERR_FLASHWINDOW 0x7400
#define WERR_SHOWOWNEDPOPUPS 0x7440
#define WERR_OPENICON 0x7480
#define WERR_CLOSEWINDOW 0x74C0
#define WERR_ANYPOPUP 0x7500
#define WERR_ISICONIC 0x7540
#define WERR_ISZOOMED 0x7580
#define WERR_CLIENTTOSCREEN 0x75C0
#define WERR_SCREENTOCLIENT 0x7600
#define WERR_MAPWINDOWPOINTS 0x7640
#define WERR_WINDOWFROMPOINT 0x7680
#define WERR_CHILDWINDOWFROMPOINT 0x76C0
#define WERR_GETDESKTOPWINDOW 0x7700
#define WERR_FINDWINDOW 0x7740
#define WERR_ENUMWINDOWS 0x7780
#define WERR_ENUMCHILDWINDOWS 0x77C0
#define WERR_ENUMTASKWINDOWS 0x7800
#define WERR_GETTOPWINDOW 0x7840
#define WERR_GETWINDOW 0x7880
#define WERR_GETNEXTWINDOW 0x78C0
#define WERR_SETPROP 0x7900
#define WERR_GETPROP 0x7940
#define WERR_REMOVEPROP 0x7980
#define WERR_ENUMPROPS 0x79C0
#define WERR_GETDC 0x7A00
#define WERR_RELEASEDC 0x7A40
#define WERR_GETWINDOWDC 0x7A80
#define WERR_GETDCEX 0x7AC0
#define WERR_BEGINPAINT 0x7B00
#define WERR_ENDPAINT 0x7B40
#define WERR_UPDATEWINDOW 0x7B80
#define WERR_EXCLUDEUPDATERGN 0x7BC0
#define WERR_LOCKWINDOWUPDATE 0x7C00
#define WERR_GETUPDATERECT 0x7C40
#define WERR_GETUPDATERGN 0x7C80
#define WERR_INVALIDATERECT 0x7CC0
#define WERR_VALIDATERECT 0x7D00
#define WERR_INVALIDATERGN 0x7D40
#define WERR_VALIDATERGN 0x7D80
#define WERR_REDRAWWINDOW 0x7DC0
#define WERR_SCROLLWINDOW 0x7E00
#define WERR_SCROLLDC 0x7E40
#define WERR_SCROLLWINDOWEX 0x7E80
#define WERR_SETACTIVEWINDOW 0x7EC0
#define WERR_GETACTIVEWINDOW 0x7F00
#define WERR_GETLASTACTIVEPOPUP 0x7F40
#define WERR_SETFOCUS 0x7F80
#define WERR_GETFOCUS 0x7FC0
#define WERR_GETKEYSTATE 0x8000
#define WERR_GETASYNCKEYSTATE 0x8040
#define WERR_GETKEYBOARDSTATE 0x8080
#define WERR_SETKEYBOARDSTATE 0x80C0
#define WERR_SETCAPTURE 0x8100
#define WERR_RELEASECAPTURE 0x8140
#define WERR_GETCAPTURE 0x8180
#define WERR_SWAPMOUSEBUTTON 0x81C0
#define WERR_GETSYSMODALWINDOW 0x8200
#define WERR_SETSYSMODALWINDOW 0x8240
#define WERR_SETTIMER 0x8280
#define WERR_KILLTIMER 0x82C0
#define WERR_LOADACCELERATORS 0x8300
#define WERR_TRANSLATEACCELERATOR 0x8340
#define WERR_ISMENU 0x8380
#define WERR_CREATEMENU 0x83C0
#define WERR_CREATEPOPUPMENU 0x8400
#define WERR_LOADMENU 0x8440
#define WERR_LOADMENUINDIRECT 0x8480
#define WERR_DESTROYMENU 0x84C0
#define WERR_GETMENU 0x8500
#define WERR_SETMENU 0x8540
#define WERR_GETSYSTEMMENU 0x8580
#define WERR_DRAWMENUBAR 0x85C0
#define WERR_HILITEMENUITEM 0x8600
#define WERR_INSERTMENU 0x8640
#define WERR_APPENDMENU 0x8680
#define WERR_MODIFYMENU 0x86C0
#define WERR_REMOVEMENU 0x8700
#define WERR_DELETEMENU 0x8740
#define WERR_CHANGEMENU 0x8780
#define WERR_ENABLEMENUITEM 0x87C0
#define WERR_CHECKMENUITEM 0x8800
#define WERR_GETSUBMENU 0x8840
#define WERR_GETMENUITEMCOUNT 0x8880
#define WERR_GETMENUITEMID 0x88C0
#define WERR_GETMENUSTRING 0x8900
#define WERR_GETMENUSTATE 0x8940
#define WERR_SETMENUITEMBITMAPS 0x8980
#define WERR_GETMENUCHECKMARKDIMENSIONS 0x89C0
#define WERR_TRACKPOPUPMENU 0x8A00
#define WERR_SETSCROLLPOS 0x8A40
#define WERR_GETSCROLLPOS 0x8A80
#define WERR_SETSCROLLRANGE 0x8AC0
#define WERR_GETSCROLLRANGE 0x8B00
#define WERR_SHOWSCROLLBAR 0x8B40
#define WERR_ENABLESCROLLBAR 0x8B80
#define WERR_OPENCLIPBOARD 0x8BC0
#define WERR_CLOSECLIPBOARD 0x8C00
#define WERR_EMPTYCLIPBOARD 0x8C40
#define WERR_GETOPENCLIPBOARDWINDOW 0x8C80
#define WERR_GETCLIPBOARDOWNER 0x8CC0
#define WERR_SETCLIPBOARDVIEWER 0x8D00
#define WERR_GETCLIPBOARDVIEWER 0x8D40
#define WERR_SETCLIPBOARDDATA 0x8D80
#define WERR_GETCLIPBOARDDATA 0x8DC0
#define WERR_ISCLIPBOARDFORMATAVAILABLE 0x8E00
#define WERR_GETPRIORITYCLIPBOARDFORMAT 0x8E40
#define WERR_REGISTERCLIPBOARDFORMAT 0x8E80
#define WERR_COUNTCLIPBOARDFORMATS 0x8EC0
#define WERR_ENUMCLIPBOARDFORMATS 0x8F00
#define WERR_GETCLIPBOARDFORMATNAME 0x8F40
#define WERR_CHANGECLIPBOARDCHAIN 0x8F80
#define WERR_LOADCURSOR 0x8FC0
#define WERR_CREATECURSOR 0x9000
#define WERR_DESTROYCURSOR 0x9040
#define WERR_COPYCURSOR 0x9080
#define WERR_SHOWCURSOR 0x90C0
#define WERR_SETCURSORPOS 0x9100
#define WERR_GETCURSORPOS 0x9140
#define WERR_SETCURSOR 0x9180
#define WERR_GETCURSOR 0x91C0
#define WERR_CLIPCURSOR 0x9200
#define WERR_GETCLIPCURSOR 0x9240
#define WERR_LOADICON 0x9280
#define WERR_CREATEICON 0x92C0
#define WERR_DESTROYICON 0x9300
#define WERR_COPYICON 0x9340
#define WERR_DRAWICON 0x9380
#define WERR_MESSAGEBOX 0x93C0
#define WERR_MESSAGEBEEP 0x9400
#define WERR_CREATECARET 0x9440
#define WERR_DESTROYCARET 0x9480
#define WERR_SETCARETPOS 0x94C0
#define WERR_GETCARETPOS 0x9500
#define WERR_HIDECARET 0x9540
#define WERR_SHOWCARET 0x9580
#define WERR_GETCARETBLINKTIME 0x95C0
#define WERR_SETCARETBLINKTIME 0x9600
#define WERR_DEFFRAMEPROC 0x9640
#define WERR_DEFMDICHILDPROC 0x9680
#define WERR_TRANSLATEMDISYSACCEL 0x96C0
#define WERR_ARRANGEICONICWINDOWS 0x9700
#define WERR_ISDIALOGMESSAGE 0x9740
#define WERR_DEFDLGPROC 0x9780
#define WERR_CREATEDIALOG 0x97C0
#define WERR_CREATEDIALOGINDIRECT 0x9800
#define WERR_CREATEDIALOGPARAM 0x9840
#define WERR_CREATEDIALOGINDIRECTPARAM 0x9880
#define WERR_DIALOGBOX 0x98C0
#define WERR_DIALOGBOXINDIRECT 0x9900
#define WERR_DIALOGBOXPARAM 0x9940
#define WERR_DIALOGBOXINDIRECTPARAM 0x9980
#define WERR_ENDDIALOG 0x99C0
#define WERR_GETDLGCTRLID 0x9A00
#define WERR_GETDLGITEM 0x9A40
#define WERR_SENDDLGITEMMESSAGE 0x9A80
#define WERR_SETDLGITEMINT 0x9AC0
#define WERR_GETDLGITEMINT 0x9B00
#define WERR_SETDLGITEMTEXT 0x9B40
#define WERR_GETDLGITEMTEXT 0x9B80
#define WERR_CHECKDLGBUTTON 0x9BC0
#define WERR_CHECKRADIOBUTTON 0x9C00
#define WERR_ISDLGBUTTONCHECKED 0x9C40
#define WERR_GETNEXTDLGGROUPITEM 0x9C80
#define WERR_GETNEXTDLGTABITEM 0x9CC0
#define WERR_MAPDIALOGRECT 0x9D00
#define WERR_GETDIALOGBASEUNITS 0x9D40
#define WERR_DLGDIRLIST 0x9D80
#define WERR_DLGDIRSELECT 0x9DC0
#define WERR_DLGDIRLISTCOMBOBOX 0x9E00
#define WERR_DLGDIRSELECTCOMBOBOX 0x9E40
#define WERR_DLGDIRSELECTEX 0x9E80
#define WERR_DLGDIRSELECTCOMBOBOXEX 0x9EC0
#define WERR_SETWINDOWSHOOK 0x9F00
#define WERR_DEFHOOKPROC 0x9F40
//#define WERR_SETWINDOWSHOOK 0x9F80
//#define WERR_DEFHOOKPROC 0x9FC0
#define WERR_UNHOOKWINDOWSHOOK 0xA000
#define WERR_SETWINDOWSHOOKEX 0xA040
#define WERR_UNHOOKWINDOWSHOOKEX 0xA080
#define WERR_CALLNEXTHOOKEX 0xA0C0
#define WERR_ENABLEHARDWAREINPUT 0xA100
#define WERR_QUERYSENDMESSAGE 0xA140
#define WERR_LOCKINPUT 0xA180
#define WERR_GETSYSTEMDEBUGSTATE 0xA1C0
#define WERR_WINHELP 0xA200
#define WERR_OPENSOUND 0xA240
#define WERR_CLOSESOUND 0xA280
#define WERR_STARTSOUND 0xA2C0
#define WERR_STOPSOUND 0xA300
#define WERR_SETVOICEQUEUESIZE 0xA340
#define WERR_SETVOICENOTE 0xA380
#define WERR_SETVOICEACCENT 0xA3C0
#define WERR_SETVOICEENVELOPE 0xA400
#define WERR_SETVOICESOUND 0xA440
#define WERR_SETVOICETHRESHOLD 0xA480
#define WERR_GETTHRESHOLDEVENT 0xA4C0
#define WERR_GETTHRESHOLDSTATUS 0xA500
#define WERR_SETSOUNDNOISE 0xA540
#define WERR_WAITSOUNDSTATE 0xA580
#define WERR_SYNCALLVOICES 0xA5C0
#define WERR_COUNTVOICENOTES 0xA600
#define WERR_BUILDCOMMDCB 0xA640
#define WERR_OPENCOMM 0xA680
#define WERR_CLOSECOMM 0xA6C0
#define WERR_READCOMM 0xA700
#define WERR_WRITECOMM 0xA740
#define WERR_UNGETCOMMCHAR 0xA780
#define WERR_FLUSHCOMM 0xA7C0
#define WERR_TRANSMITCOMMCHAR 0xA800
#define WERR_SETCOMMSTATE 0xA840
#define WERR_GETCOMMSTATE 0xA880
#define WERR_GETCOMMERROR 0xA8C0
#define WERR_SETCOMMBREAK 0xA900
#define WERR_CLEARCOMMBREAK 0xA940
#define WERR_SETCOMMEVENTMASK 0xA980
#define WERR_GETCOMMEVENTMASK 0xA9C0
#define WERR_ESCAPECOMMFUNCTION 0xAA00
#define WERR_ENABLECOMMNOTIFICATION 0xAA40
#define WERR_WVSPRINTF 0xAA80
#define WERR_DEFDRIVERPROC 0xAAC0
#define WERR_OPENDRIVER 0xAB00
#define WERR_CLOSEDRIVER 0xAB40
#define WERR_SENDDRIVERMESSAGE 0xAB80
#define WERR_GETDRIVERMODULEHANDLE 0xABC0
#define WERR_GETNEXTDRIVER 0xAC00
#define WERR_GETDRIVERINFO 0xAC40

#endif // _ERRORMOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxhelp.h ===
/* Faxview topic ids */
#define HelpContents              1 /*not used*/
#define ViewingAFax               2
#define SavingAFax                3
#define CopyingAFax               4
#define PrintingAFax              5
#define ScaleRotateAFax           6
#define QuitingFaxView            7
#define SelectingPart             8 /*not used*/
#define EnhancingAFax             9

/* MSFax topic ids */
#define contents                 10
#define troubleshooting          11 /*not used*/
#define queueforfaxmodemon       12
#define changelogodb             13
#define microsoftatworkfaxdb     14
#define faxmodemsdb              15
#define addfaxmodemsdb           16
#define faxmodemsetupdb          17
#define faxmodemspeakercontroldb 18
#define modemdialingoptionsdb    19
#define advanceddialingprefixesdb 20
#define sharelocalfaxmodemdb     21
#define connectnetworkfaxdb      22
#define configuringthefaxmodem   23
#define sharingafaxmodem         24
#define stopsharingafaxmodem     25  /*not used*/
#define addressingafax           26  /*not used*/
#define sendingafaxfrommicrosoftmail 27
#define sendingafaxfromanapplication 28
#define attachingadocumenttoafax 29
#define usingtheadvanceddialingfeature 30
#define usingthepersonaladdressbook 31
#define settingfaxoptions        32
#define specifyingtheactivefaxmodem 33
#define receivingfaxes           34
#define managingoutgoingfaxes    35
#define usingsecurity            36
#define faxsecuritydb            37
#define publickeysdb             38
#define privatekeymanagementdb   39
#define enterpublickeydb         40
#define faxsecuritylogindb       41
#define copykeydb                42
#define faxmessagesecurityoptionsdb 43
#define faxoptionsdb             44
#define transmissionoptionsdb    45
#define newuserdb                46
#define queuedb                  48
#define faxsigdb                 49
#define faxsigsavedb             50
#define pubkeyseldb		 51
#define newfaxsecuritypassworddb	52
#define changefaxsecuritypassworddb	53
#define sec_pub_imp_file	54
#define sec_priv_imp_file	55
#define pass_encr_pass		56
#define faxmodedb		57
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxcodec.h ===
// Copyright (c) Microsoft Corp. 1992-94
/*==============================================================================
The prototypes in this header file define an API for the Fax Codec DLL.

DATE				NAME			COMMENTS
25-Nov-92		RajeevD   Created.
13-Apr-93		RajeevD		Changed to Bring Your Own Memory (BYOM :=) API.
01-Nov-93   RajeevD   Defined structure for initialization parameters.
21-Jan-94   RajeevD   Split FaxCodecRevBuf into BitReverseBuf and InvertBuf.
19-Jul-94   RajeevD   Added nTypeOut=NULL_DATA and FaxCodecCount.
==============================================================================*/
#ifndef _FAXCODEC_
#define _FAXCODEC_

#include <windows.h>
#include <buffers.h>

/*==============================================================================
The FC_PARAM structure specifies the conversion to be initialized.
This matrix indicates the valid combinations of nTypeIn and nTypeOut.

                             nTypeOut
                             
                 MH     MR     MMR    LRAW    NULL
                 
        MH               *      *       *      *

        MR       *              *       *      *
nTypeIn
        MMR      *       *              *

        LRAW     *       *      * 
        
==============================================================================*/
#ifdef WIN32
#pragma pack (push)
#pragma pack(1)
#endif

typedef struct
#ifdef __cplusplus
  FAR FC_PARAM
#endif
{
	DWORD nTypeIn;      // input data type:  {MH|MR|MMR|LRAW}_DATA
	DWORD nTypeOut;     // output type type: {MH|MR|MMR|LRAW|NULL}_DATA
	UINT  cbLine;       // scan line byte width (must be multiple of 4)
	UINT  nKFactor;     // K factor (significant for nTypeOut==MR_DATA)
}
	FC_PARAM, FAR *LPFC_PARAM;

#ifdef WIN32
#pragma pack(pop)
#endif

#ifdef __cplusplus
extern "C" {
#endif
/*==============================================================================
FaxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // size of context (0 on failure)
WINAPI FaxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

typedef UINT (WINAPI *LPFN_FAXCODECINIT)
	(LPVOID, LPFC_PARAM);

// Return codes for FaxCodecConvert
typedef UINT FC_STATUS;
#define FC_INPUT_EMPTY 0
#define FC_OUTPUT_FULL 1
#define FC_DECODE_ERR  4 // only for nTypeIn==MMR_DATA

/*==============================================================================
FaxCodecConvert() executes the conversion specified in FaxCodecInit().

In the input buffer, lpbBegData is advanced and wLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.  If the input type is LRAW_DATA, wLengthData must be a
multiple of 4.

In the output buffer, wLengthData is incremented as data is appended.  If the
output type is LRAW_DATA, an whole number of scan lines are produced.

To flush any output data at the end of a page, pass a NULL input buffer or a
zero length buffer with dwMetaData set to END_OF_PAGE.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // status
WINAPI FaxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);

typedef UINT (WINAPI *LPFN_FAXCODECCONVERT)
	(LPVOID, LPBUFFER, LPBUFFER);

/*==============================================================================
The FC_COUNT structure accumulates various counters during FaxCodecConvert.
==============================================================================*/
typedef struct
{
	DWORD cTotalGood;    // total good scan lines
	DWORD cTotalBad;     // total bad scan lines
	DWORD cMaxRunBad;    // maximum consecutive bad
}
	FC_COUNT, FAR *LPFC_COUNT;

/*==============================================================================
FaxCodecCount() reports and resets the internal counters.
==============================================================================*/
void WINAPI FaxCodecCount
(
	LPVOID     lpContext,
	LPFC_COUNT lpCount
);

typedef void (WINAPI *LPFN_FAXCODECCOUNT)
	(LPVOID, LPFC_COUNT);

/*==============================================================================
BitReverseBuf() performs a bit reversal of buffer data.  The dwMetaData field is
toggled between LRAW_DATA and HRAW_DATA.  As with all scan lines, the length 
of data (wLengthData) must be a 32-bit multiple.  For best performance the start
of the data (lpbBegData) should be 32-bit aligned and the data predominantly 0.
==============================================================================*/
void WINAPI BitReverseBuf (LPBUFFER lpbuf);

/*==============================================================================
InvertBuf() inverts buffer data.  As with all scan lines, the length of data 
(wLengthData) must be a 32-bit multiple.  For best performance, the start of 
data (lpbBegData) should be 32-bit aligned.
==============================================================================*/
void WINAPI InvertBuf (LPBUFFER lpbuf);

/*==============================================================================
FaxCodecChange() produces a change vector for an LRAW scan line.
==============================================================================*/
typedef short FAR* LPSHORT;

// Slack Parameters.
#define RAWBUF_SLACK 2
#define CHANGE_SLACK 12
#define OUTBUF_SLACK 16

extern void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,  // LRAW scan line
	UINT    cbLine,   // scan line width
  LPSHORT lpsChange // change vector
);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // _FAXCODEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxipc.h ===
/***********************************************************************
 *
 * At Work Fax: FAX Inter Process Communication
 *
 *
 * Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *
 ***********************************************************************/


// Message queue structure: This lives in shared memory
typedef struct _IPC_MSG {
    UINT        uMessageId;     // Message Identifier
    WPARAM      wParam;         // wParam message specific data
    LPARAM      lParam;         // lParam message specific data
} IPC_MSG, *LPIPC_MSG;

// Message queue header: This lives at the top of shared memory
typedef struct _IPC_QUEUE {
    DWORD       cEntries;       // Count of entries in queue
    DWORD       cMaxEntries;    // Maximum number of entries to fit in queue
    IPC_MSG     Messages[];     // Queue of entries
} IPC_QUEUE, *LPIPC_QUEUE;

// IPC structure: This lives in local memory of each process
typedef struct _FAX_IPC {
    HANDLE      hevNew;         // Event handle to be triggered on new data
    HANDLE      hmtxAccess;     // Mutex handle to control access to IPC queue
    HANDLE      hMapFile;       // Mapped File handle
    LPIPC_QUEUE lpQueue;        // Pointer to queue of IPC messages
} FAX_IPC, *LPFAX_IPC;


#define ERROR_APPLICATION_DEFINED   0x20000000
#define FAXIPC_ERROR_QUEUE_FULL     (ERROR_APPLICATION_DEFINED | 1)


//
// Function Templates
//
LPFAX_IPC IPCOpen(PUCHAR lpName);
BOOL IPCPost(LPFAX_IPC lpIPC, UINT uMessageId, WPARAM wParam, LPARAM lParam);
BOOL IPCGetMessage(LPFAX_IPC lpIPC, PUINT lpuMessageId, WPARAM * lpwParam,
  LPARAM * lplParam, UINT uMsgFilterMin, UINT uMsgFilterMax, DWORD dwTimeout);
BOOL IPCWait(LPFAX_IPC lpIPC, PUINT lpuMessageId, WPARAM * lpwParam,
  LPARAM * lplParam, DWORD dwTimeout);
BOOL IPCTest(LPFAX_IPC lpIPC);
BOOL IPCClear(LPFAX_IPC lpIPC);
BOOL IPCClose(LPFAX_IPC lpIPC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxcover.h ===
/***************************************************************************

    Name      :     faxcover.h

    Comment   :     Fax Cover Page declarations

    Functions :     (see Prototypes just below)

    Created   :     03/18/94

    Author    :     Bruce J Kelley

    Contribs  :         Andrew Waters  8/11/94 Added MAPI prop structures and
				header information

***************************************************************************/

//#define COVER_PAGE_EDITOR               "awcpe.exe"
#define CPE_TEMP_FILE_NAME              "~awcpet."
#define CPE_EXTENSION                   "cpd"
#define NEWLINE                         "\n"

// This is the exported name of the support entry point
#define CPE_SUPPORT_FUNCTION_NAME       "CPESupportProc"

// Typedefs for the memory mapped file

//This is the list of properties in the order they are stored in the file
enum
{
	// Recipient properties
	cperRECIPIENT_SIZE=0,
	cperRECIPIENT_NAME,
	cperRECIPIENT_TITLE,
	cperRECIPIENT_DEPARTMENT,
	cperRECIPIENT_OFFICE_LOCATION,
	cperRECIPIENT_COMPANY,
	cperRECIPIENT_STREET_ADDRESS,
	cperRECIPIENT_POST_OFFICE_BOX,
	cperRECIPIENT_LOCALITY,
	cperRECIPIENT_STATE,
	cperRECIPIENT_POSTAL_CODE,
	cperRECIPIENT_COUNTRY,
	cperRECIPIENT_HOME_PHONE,
	cperRECIPIENT_WORK_PHONE,
	cperRECIPIENT_FAX_PHONE,
	cperLAST
} cper;

enum
{
	// Sender properties
	cpesdSENDER_SIZE=0,
	cpesdSENDER_NAME,
	cpesdSENDER_FAX_PHONE,
	cpesdSENDER_COMPANY,
	cpesdSENDER_TITLE,
	cpesdSENDER_ADDRESS,
	cpesdSENDER_DEPARTMENT,
	cpesdSENDER_HOME_PHONE,
	cpesdSENDER_WORK_PHONE,
	cpesdSENDER_OFFICE_LOCATION,

	// List properties that don't change
	cpesdRECIPIENT_TO_LIST,
	cpesdRECIPIENT_CC_LIST,
	
	// Message related properties
	cpesdMESSAGE_SUBJECT,
	cpesdMESSAGE_SUBMISSION_TIME,
	cpesdMESSAGE_BILLING_CODE,

	// Configuration properties
	cpesdCONFIG_CPE_TEMPLATE,
	cpesdCONFIG_PRINT_DEVICE,
	
	// Miscellanous message properties
	cpesdMISC_ATTACHMENT_NAME_LIST,
	cpesdMISC_USER_DEFINED,
	
	// Count properties
	cpesdCOUNT_ATTACHMENTS,
	cpesdCOUNT_RECIPIENTS,
	cpesdCOUNT_PAGES,

	// Derived property so CPE can get at PR_BODY data
	// using the tempfile copy of PR_BODY
	cpesdMESSAGE_BODY_FILENAME,

	// Internal Data that isn't in the public interface
	cpesdERROR_EVENT,
	cpesdFINISH_EVENT,
	cpesdNEXT_EVENT,
	cpesdRECIP_ATOM,
	cpesdLAST
} cpesd;

typedef struct EntryTAG
{
	DWORD dwOffset; //Offset of this entry in the file
	DWORD dwSize;   //Size of entry in body.  If it is a string this includes the NULL.
} ENTRY;

typedef struct CPESD_HeaderTAG
{
	ENTRY rgEntries[cpesdLAST];     // This is always first in the file
} CPESD_HEADER, FAR *LPCPESD_HEADER;

typedef struct CPER_HeaderTAG
{
	ENTRY rgEntries[cperLAST];
} CPER_HEADER, FAR *LPCPER_HEADER;


enum
{
	// Static data not associated with a user.
	sdmprPR_DISPLAY_TO=0,
	sdmprPR_DISPLAY_CC,
	sdmprPR_SUBJECT,
	sdmprPR_CLIENT_SUBMIT_TIME,
	sdmprPR_FAX_BILLING_CODE,
	sdmprPR_FAX_CP_NAME,
	sdmpr_LAST
} sdmpr;

extern const struct _SPropTagArray_StaticDataMessage_PropTagArray;

enum
{
	// Sender Properties
	sdpprPR_SENDER_NAME=0,
	sdpprPR_SENDER_EMAIL_ADDR,
	sdpprPR_COMPANY_NAME,
	sdpprPR_TITLE,
	sdpprPR_POSTAL_ADDRESS,
	sdpprPR_DEPARTMENT_NAME,
	sdpprPR_HOME_TELEPHONE_NUMBER,
	sdpprPR_OFFICE_TELEPHONE_NUMBER,
	sdpprPR_OFFICE_LOCATION,
	sdppr_LAST
} sdppr;

extern const struct _SPropTagArray_StaticDataProfile_PropTagArray;
// Recipient Property array.  This is the array that will be upated between
// each cover page that is printed
enum
{
	rprPR_DISPLAY_NAME=0,
	rprPR_TITLE,
	rprPR_DEPARTMENT_NAME,
	rprPR_OFFICE_LOCATION,
	rprPR_COMPANY_NAME,
	rprPR_RECIPIENT_STREET_ADDRESS,
	rprPR_RECIPIENT_POST_OFFICE_BOX,
	rprPR_RECIPIENT_LOCALITY,
	rprPR_RECIPIENT_STATE,
	rprPR_RECIPIENT_POSTAL_CODE,
	rprPR_RECIPIENT_COUNTRY,
	rprPR_HOME_TELEPHONE_NUMBER,
	rprPR_OFFICE_TELEPHONE_NUMBER,
	rprPR_EMAIL_ADDRESS,  //This is considered the fax number
	rprPR_MAILBOX,
	rprPR_FAX_CP_NAME,
	rpr_LAST
} rpr;

extern const struct _SPropTagArray_Recipient_PropTagArray;

/* Data that is not in the above structures is :

	COUNT_RECIPIENTS - This is in the faxjob.uNumRecipients
	COUNT_ATTACHMENTS - This is in faxjob.uNumAttachments
	COUNT_PAGES - This is in format.wNumPages   I need to increment this once to
				  add in the cover page.
	MISC_ATTACHMENT_NAME_LIST - This would require gettting an attachment table
	
*/

/*
	Event structure used for determination of which event signaled
*/
typedef enum _CPE_PRINT_EVENTS{
	CPE_ERROR_EVENT = 0,
	CPE_PRINT_JOB_EVENT,
	CPE_PRINT_ERROR_EVENT,
	CPE_PRINT_ID_EVENT,
	CPE_TIMEOUT= WAIT_TIMEOUT,
	CPE_FAILED = WAIT_FAILED
} CPE_PRINT_EVENTS, *PCPE_PRINT_EVENTS;

#define C_CPE_EVENTS 4  //This is the number of events that will be waited on

// Return value from
typedef enum _WAIT_CP_RETURN {
    WCP_DONE_OK,
    WCP_DONE_FAILURE,
    WCP_TIMEOUT
} WAIT_CP_RETURN, * LPWAIT_CP_RETURN;

// THESE MUST BE IDENTICAL TO THE ONES IN AWCPESUP.H!!!!!!!

// This is the root level key where the CPE specific sub keys are stored
#define CPE_SUPPORT_ROOT_KEY 	("Software\\Microsoft\\At Work Fax\\Transport Service Provider")

// This is the location where the CPE puts the command line to used when calling it to print
// cover pages at send time.  The format is total at the CPE's discretion.  The transport will
// look for the string "SESS_ID" and replace it with the current session id.  The session ID is
// a DWORD.
#define CPE_COMMAND_LINE_KEY ("Cover Page Editor")

// This key contains the DLL name that the CPE loads to get the Support Object
#define CPE_SUPPORT_DLL_KEY ("CPE Support DLL")

//This is the key that holds the name of the function in the Support DLL that is the actual "Service Entry"
#define CPE_SUPPORT_FUNCTION_NAME_KEY ("CPE Support Function Name")

// END IDENTICAL

// Function prototypes

// This is in cover.c.  It is used to init the CPE transport interface
BOOL InitCPEInterface(HINSTANCE);

/*
	CreateCPStaticDataMapping
	
	Variable comments
  	   pszBodyFile = File containing message body text from PR_BODY.
	   atSDFile is an atom representing the name of the file mapping
	   hSDFile is the handle to the file mapping
	   hCPErrEvt is set by the support object on error from the CPE
	   hCPNxtEvt is set by the transport to cause the CPE to print the next page
	   hCPFinEvt is set by the transport to notify the CPE that the job is done
*/
BOOL  CreateCPStaticDataMapping(NPFAXJOB ppFaxJob,
								WORD wNumPages,
  								LPTSTR pszBodyFile,
								LPATOM atSDFile,
								LPHANDLE hSDFile,
								LPATOM atCPErrEvt,
								LPHANDLE hCPErrEvt,
								LPATOM atCPNxtEvt,
								LPHANDLE hCPNxtEvt,
								LPATOM atCPFinEvt,
								LPHANDLE hCPFinEvt);

BOOL DestroyCPStaticDataMapping(LPATOM atSDFile,
								LPHANDLE hSDFile,
								LPATOM atCPErrEvt,
								LPHANDLE hCPErrEvt,
								LPATOM atCPNxtEvt,
								LPHANDLE hCPNxtEvt,
								LPATOM atCPFinEvt,
								LPHANDLE hCPFinEvt);

/***************************************************************************

    Name      : RenderRecipCoverPage

    Purpose   : This function renders a cover page for a single recipient

    Parameters:
	 	pFaxJob is a pointer to the current job structure.
		pFormat is a pointer to the current format structure.
		pRecip is a pointer to the current recipient.
		atSDFile is the atom for the static data mapping.
		pfCPEExec is a bool used to trak the cover page editor.
		
    Returns   : TRUE on succuss, FALSE on failure

***************************************************************************/
BOOL RenderRecipCoverPage(NPFAXJOB pFaxJob,
						   NPFORMAT pFormat,
						   NPEFAX_RECIPIENT pRecip,
						   ATOM atSDFile,
						   PBOOL pfCPEExec,
 						   HANDLE hCPErrEvt,
 						   HANDLE hCPNxtEvt,
                          LPDELFILENODE * lppDeleteFiles);

/*
	CreateCPRecipientMapping
	
	variable comments
		hrpCur is a handle to the current recipient
		atRDFile is the atom to the memmap name
		hRMFile is a handle to the open memap file
*/
BOOL CreateCPRecipientMapping(NPFAXJOB pFaxJob,
								NPEFAX_RECIPIENT hrpCur,
								LPATOM patRDFile,
								LPHANDLE phRMFile);
						
BOOL DestroyCPRecipientMapping(LPATOM patRDFile,
								LPHANDLE phRMFile);

/*
	SetupCPRenderRecip
	
	variable comments
		npft is a pointer to the format structure for the job
		hrpCur is the handle to the current recipient
		prp is a pointer to the current renderer properties
		phDevMem is a handle to the shared devlayer memory [out]
		phDevlayer is a handle to the devlayer [out]
		pjd is a pointer to jobdata [out]
*/
BOOL SetupCPRenderRecip(NPFORMAT npft,
						NPEFAX_RECIPIENT hrpCur,
						LPRENDER_PRINT prp,
						LPHANDLE phDevMem,
						LPHANDLE phDevlayer,
						PJOBSUMMARYDATA *pjd);
				
BOOL DestroyCPRenderRecip(NPFORMAT npft,
							NPEFAX_RECIPIENT hrpCur,
							LPRENDER_PRINT prp,
							LPHANDLE phDevMem,
							LPHANDLE phDevlayer,
							PJOBSUMMARYDATA *pjd);

/*
	CreateCPECommandLine
	
	variable comments
		atSDFile is the atom for the static data mapping
		atRDFile is the atom for the recipient data mapping
		ppszCPECmdLn is where the command line is returned
*/
BOOL CreateCPECommandLine(ATOM atSDFile,
							ATOM atRDFile,
							LPTSTR *ppszCPECmdLn);

/*
	WaitCPEvents
	
	variable comments
		lpvYieldParm is a parameter for MapiYield
		prp is a handle to the current renderer properties
		hCPErrEvt is a handle to CPError event
*/
WAIT_CP_RETURN WaitCPEvents(LPVOID lpvYieldParm,
							LPRENDER_PRINT prp,
							HANDLE hCPErrEvt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxopt.h ===
/* Copyright Microsoft Corp 1993
 *
 *      faxopt.c
 *
 * Include file for faxopt.dll
 *
 *
 *      Created:        1/10/93
 *      Author:         mikegins
 */

#ifndef __FAXOPT_H__
#define __FAXOPT_H__ 1

#ifndef __FAXSEC_H__

#define SEC_SUCCESS         0   /* Operation succeeded          */
#define SEC_BADFILE         1   /* File cannot be opened        */
#define SEC_KEYTOOSMALL     2   /* Keybuffer too small          */
#define SEC_NOMATCH         3   /* No key of requested type found for
                  specified keyholder, or too many matches
                  were found (ie: joe@+123 and mart@+123 both
                  match @+123 with equal weight */
#define SEC_FILECORRUPT     4   /* File integrity check failed  */
#define SEC_NOMEMORY        5   /* Aborted due to low memory conditions */
#define SEC_BADPTR          6   /* An invalid pointer was passed in */
#define SEC_USERABORT       7   /* User aborted operation       */
#define SEC_BADPASS         8   /* Invalid password             */
#define SEC_ABORT           9   /* Callback caused abort        */
#define SEC_BUSY           10   /* Concurrent job already running */
#define SEC_WRONGKEY       11   /* Wrong key used in decryption */
#define SEC_NEWERVERSION   12  /* File generated by newer version of software,
                  and we cannot decrypt it */
   

#define SIG_SUCCESS     0   /* Operation succeeded */
#define SIG_BADINFILE   1   /* Bad input file */
#define SIG_BADOUTFILE  2   /* Bad output file */
#define SIG_FORGED      3   /* Signature does not match keyset */
#define SIG_AUTHENTIC   4   /* Signature matches keyset */
#define SIG_NOTVERIFIED 5   /* No key found, so can not verify signature */
#define SIG_BADPASS     6   /* Bad password or incorrect session handle */
#define SIG_NOMEM       7   /* Out of memory error */
#define SIG_ABORT       8   /* Callback caused abort */
#define SIG_BUSY        9   /* Concurrent job already running */

#endif

#define FAXOPTBASEATT   0x6000
#define iATTlogostr     (FAXOPTBASEATT+ 0)
#define iATTlogo1       (FAXOPTBASEATT+ 1)
#define iATTlogo2       (FAXOPTBASEATT+ 2)
#define iATTlogo3       (FAXOPTBASEATT+ 3)
#define iATTlogo4       (FAXOPTBASEATT+ 4)
#define iATTlogo5       (FAXOPTBASEATT+ 5)
#define iATTinccover    (FAXOPTBASEATT+ 6)
#define iATTtranshour   (FAXOPTBASEATT+ 7)
#define iATTtransquart  (FAXOPTBASEATT+ 8)
#define iATTdelivform   (FAXOPTBASEATT+ 9)
#define iATTimagequal   (FAXOPTBASEATT+10)
#define iATTprintorient (FAXOPTBASEATT+11)
#define iATTcheapbeghr  (FAXOPTBASEATT+13)
#define iATTcheapendhr  (FAXOPTBASEATT+14)
#define iATTcheapbegq   (FAXOPTBASEATT+15)
#define iATTcheapendq   (FAXOPTBASEATT+16)
#define iATTnumret      (FAXOPTBASEATT+17)
#define iATTminbetret   (FAXOPTBASEATT+18)
#define iATTpapersize   (FAXOPTBASEATT+19)
#define iATTtransprio   (FAXOPTBASEATT+20)
#define iATTencrypt     (FAXOPTBASEATT+21)
#define iATTsign        (FAXOPTBASEATT+22)
#define iATTIncludeBody (FAXOPTBASEATT+23)
#define iATTSimplePwd   (FAXOPTBASEATT+24)

#define SelectUser Func20
WORD FAR PASCAL SelectUser(LPSTR userid, DWORD userinst, LPSTR olduser,
              LPSTR selecteduser);
#define GetSimplePwd Func21
WORD FAR PASCAL GetSimplePwd(LPSTR pwd);
#define ImportKeysDlg Func22
WORD FAR PASCAL ImportKeysDlg(LPSTR filename, HWND hDlg);

/* 0 = success, 1 = End of Job, 2 = failure */
typedef WORD FAR PASCAL ReadCB(DWORD hf, LPBUFFER FAR *buf);
typedef WORD FAR PASCAL WriteCB(DWORD hf, LPBUFFER buf);
typedef void FAR PASCAL LogCB(LPSTR userid, DWORD userinst);

/* 0 = continue, 1 = abort */
typedef WORD FAR PASCAL SigCB(DWORD hf, LPSTR username, WORD result);

#if FALSE
#define MailStarting Func00
void FAR PASCAL MailStarting(LogCB *LoginCB, LogCB *LogoutCB, LPSTR userid);
#define MailShutdown Func01
void FAR PASCAL MailShutdown(void);
#define EncryptInit Func02
WORD FAR PASCAL EncryptInit(LPSTR userid, DWORD userinst, LPSTR destuser,
               WORD FAR *instance, LPBUFFER buf);
#define EncryptData Func03
WORD FAR PASCAL EncryptData(DWORD userinst, WORD inst, LPBUFFER buf);
#define DecryptInit Func04
WORD FAR PASCAL DecryptInit(LPSTR userid, DWORD userinst, LPSTR srcuser,
               WORD FAR *instance, LPBUFFER buf);
#define DecryptData Func05
WORD FAR PASCAL DecryptData(DWORD userinst, WORD inst, LPBUFFER buf);
#define SimpleEncryptInit Func06
WORD FAR PASCAL SimpleEncryptInit(LPSTR pwd, WORD FAR *instance, LPBUFFER buf);
#define SimpleEncryptData Func07
WORD FAR PASCAL SimpleEncryptData(WORD inst, LPBUFFER buf);
#define SimpleDecryptInit Func08
WORD FAR PASCAL SimpleDecryptInit(LPSTR pwd, WORD FAR *instance, LPBUFFER buf);
#define SimpleDecryptData Func09
WORD FAR PASCAL SimpleDecryptData(WORD inst, LPBUFFER buf);
#ifndef DELRINA
#define SignFile Func10
#endif
WORD FAR PASCAL SignFile(ReadCB *readCB, DWORD readHand, WriteCB *writeCB,
            DWORD writeHand, LPSTR userid, DWORD userinst,
            LPSTR filename, WORD FAR *HeaderSize);
#define UnSignFile Func11
WORD FAR PASCAL UnSignFile(ReadCB FAR *readCB, DWORD readHand,
              WriteCB FAR *writeCB,DWORD writeHand);
#ifndef DELRINA
#define ExistsPubKey Func12
#endif
BOOL FAR PASCAL ExistsPubKey(LPSTR name);
#define IsUserLoggedIn Func13
WORD FAR PASCAL IsUserLoggedIn(void);
#define SignFileHeaderSize Func14
WORD FAR PASCAL SignFileHeaderSize(ReadCB FAR *readCB, DWORD readHand,
                  WORD FAR *headersize, LPSTR filename);
#define GetSignatures Func15
WORD FAR PASCAL GetSignatures(ReadCB FAR *readCB, DWORD readHand,
                 SigCB FAR *sigCB, DWORD sigHand, LPSTR filename);

/* Call to start hashing bft header.  Returns 0 for failure, or non-zero
   context for passing to SendBFTHash and DoneBFTHash */
#define StartBFTHash Func23
WORD FAR PASCAL StartBFTHash(void);

/* Pass in context from StartBFTHash, and buffer with length */
#define SendBFTHash Func24
void FAR PASCAL SendBFTHash(WORD Context, BYTE FAR *buf, WORD len);

/* Pass in context after done calling SendBFTHash.  If salt points to 3 bytes
   which are 0, a salt is generated and returned, else the salt is used.
   Key must be 5 bytes, from which the actual key is derived.  Res must be 16
   bytes long to receive hashed encrypted result. */

#define DoneBFTHash Func25
void FAR PASCAL DoneBFTHash(WORD Context, BYTE FAR *salt, BYTE FAR *key,
               BYTE FAR *res);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxsrc.inc ===
!if !$(FREEBUILD)				
C_DEFINES = $(C_DEFINES) -DDEBUG		
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\faxpwd.h ===
/*
 * File Name: FAXPWD.H
 *
 * Copyright (c)1994 Microsoft Corporation, All Rights Reserved
 *
 * Author:	 Ken Horn (a-kenh)
 * Created:  03-Aug-94
 *
 *
 */

#ifndef _FAXPWD_H_
#define _FAXPWD_H_

#ifdef __cplusplus
extern "C" {
#endif

// takes a TCHAR[MAPWD] to hold longest allowed password
#define MAXPWD             128
#define MAXLOGINPWD     MAXPWD
#define MAXSIMPLEPWD    MAXPWD
#define MINPWDLEN            4   // string length of shortest valid password.

BOOL __declspec(dllexport) WINAPI pwdReplaceAccount(HWND hwndParent,
 FARPROC fpxLogin,  FARPROC fpxLogout, FARPROC fpxHasKeys, FARPROC fpxReinit,
 LPDWORD phSec);

BOOL __declspec(dllexport) WINAPI pwdChangeKeyPassword(HWND hwndParent,
 FARPROC fpxLogin,  FARPROC fpxLogout, FARPROC fpxChangePwd, FARPROC fpxReinit,
 LPDWORD phSec);

DWORD __declspec(dllexport) WINAPI pwdValidateUserLogin(HWND hwndParent,
 FARPROC fpxLogin,  FARPROC fpxLogout, FARPROC fpxHasKeys, FARPROC fpxReinit);

BOOL __declspec(dllexport) WINAPI pwdGetSimplePassword(HWND hwndParent,
 LPTSTR pPassword, WORD cbPassword);

BOOL __declspec(dllexport) WINAPI pwdConfirmSimplePassword(HWND hwndParent,
 LPTSTR pPassword, WORD cbPassword);

BOOL __declspec(dllexport) WINAPI pwdConfirmLoginPassword(HWND hwndParent,
  LPTSTR pPassword, WORD cbPassword, LPBOOL pbCacheit);

void __declspec(dllexport) WINAPI pwdDeleteCachedPassword();

BOOL __declspec(dllexport) WINAPI pwdSetCachePassword(LPTSTR pPassword);


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FAXPWD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\fr.h ===
#ifndef _FR_H
#define _FR_H

#pragma pack(1)    /** ensure packed structures **/

/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI SRVRDLL

    @type   BYTE | IFR | .
				
	@flag Frame identifier values used in the FR struct and various APIs |

			ifrDIS 	= DIS frame

			ifrCSI 	= CSI frame

			ifrNSF	= NSF frame

			ifrDTC	= DTC frame

			ifrCIG	= CIG frame

			ifrNSC	= NSC frame

    		ifrDCS	= DCS frame

    		ifrTSI 	= TSI frame

    		ifrNSS	= NSS frame

    @xref   <t FR>
********/

#define 	ifrNULL		0
#define 	ifrDIS		1
#define 	ifrCSI		2
#define 	ifrNSF		3
#define		ifrDTC		4
#define		ifrCIG		5
#define		ifrNSC		6
#define		ifrDCS		7
#define		ifrTSI		8
#define		ifrNSS		9

typedef BYTE 		IFR;
typedef IFR FAR*	LPIFR;


/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI SRVRDLL

	@types  FR | Structure containing received or sent frames

	@field  IFR		| ifr	| Frame identifier
	@field  BYTE	| cb	| Length of the FIF part of the frame
	@field  BYTE[]	| fif	| Variable length FIF part

	@tagname _FR
	@xref   <t IFR>
********/


typedef struct 
{
	IFR		ifr;
	BYTE	cb;

} FRBASE;

#if defined(PORTABLE) || defined(__cplusplus)	/* strictly ANSI C */

typedef struct 
{
	IFR		ifr;
	BYTE	cb;
	BYTE	fif[1];		/* start of var length array */
}
FR, FAR* LPFR, NEAR* NPFR;

#else 				/* Microsoft C */

typedef struct 
{
	FRBASE;			/* anonymous */
	BYTE	fif[1];	/* variable length fif field */
	    
} FR, FAR* LPFR, NEAR* NPFR;

#endif

typedef LPFR FAR* LPLPFR;
typedef LPLPFR FAR* LPLPLPFR;


/********
    @doc    EXTERNAL OEMNSF DATATYPES

	@types  LLPARAMS | Structure containing low-level T.30 capabilities or
						parameters.

	@field  BYTE 	| Baud    | Baud Rate Capability or Mode.
	
		@flag Baud Rate Mode Codes |

			V27_2400	= 0

			V27_4800	= 2

			V29_7200	= 3

			V29_9600	= 1

			V33_12000	= 6

			V33_14400	= 4

			V17_7200	= 11

			V17_9600	= 9

			V17_12000	= 10

			V17_14400	= 8

		@flag V27_SLOW | Baud Rate Capability: V.27 at 2400bps only.
		@flag V27_ONLY | Baud Rate Capability: V.27 only, at 2400bps and 4800bps.
		@flag V29_ONLY | Baud Rate Capability: V.29 only, at 7200bps and 9600bps.
		@flag V27_V29  | Baud Rate Capability: V.27 and V.29 at the above speeds.
		@flag V27_V29_V33 | Baud Rate Capability: V.27 and V.29 at the above speeds plus
							V.33 at 12000bps and 14400bps.
		@flag V27_V29_V33_V17 | Baud Rate Capability: V.27, V.29, V.33 at the above
							speeds plus V.17 at 12000bps and 14400bps.

	@field  BYTE	| MinScan | Minimum Scan-line time Requirement or Mode.

		@flag Minscan Mode Codes |

			MINSCAN_40	= 4

			MINSCAN_20	= 0

			MINSCAN_10	= 2

			MINSCAN_5	= 1

			MINSCAN_0	= 7

		@flag MINSCAN_0_0_0    | MinScan Reqmnt: 0ms at all vertical resolutions
		@flag MINSCAN_5_5_5    | MinScan Reqmnt: 5ms at all vertical resolutions
		@flag MINSCAN_10_10_10 | MinScan Reqmnt: 10ms at all vertical resolutions
		@flag MINSCAN_20_20_20 | MinScan Reqmnt: 20ms at all vertical resolutions
		@flag MINSCAN_40_40_40 | MinScan Reqmnt: 40ms at all vertical resolutions
		@flag MINSCAN_40_20_20 | MinScan Reqmnt: 40ms at 100dpi, 20ms at all other resolutions
		@flag MINSCAN_20_10_10 | MinScan Reqmnt: 20ms at 100dpi, 10ms at all other resolutions
		@flag MINSCAN_10_5_5   | MinScan Reqmnt: 10ms at 100dpi, 5ms at all other resolutions
		@flag MINSCAN_40_40_20 | MinScan Reqmnt: 40ms at 100dpi and 200dpi, 20ms at 400dpi
		@flag MINSCAN_20_20_10 | MinScan Reqmnt: 20ms at 100dpi and 200dpi, 10ms at 400dpi
		@flag MINSCAN_10_10_5  | MinScan Reqmnt: 10ms at 100dpi and 200dpi, 5ms at 400dpi
		@flag MINSCAN_40_20_10 | MinScan Reqmnt: 40ms at 100dpi, 20ms at 200dpi, 10ms at 400dpi
		@flag MINSCAN_20_10_5  | MinScan Reqmnt: 20ms at 100dpi, 10ms at 200dpi, 5ms at 400dpi

	@field  BYTE	| fECM	  | ECM Capability or Mode (boolean).
	@field  BYTE	| fECM64  | Small-Frame (64 byte frame) ECM Capability or Mode (boolean).

	@tagname _LLPARAMS
	@xref   <f OEM_NSxToBC>, <f OEM_CreateFrame>
********/


typedef struct
{

    BYTE    Baud;
    BYTE    MinScan;

    BYTE    fECM;
    BYTE    fECM64;
/**
    BYTE    fNonEfaxBFT     :1;
    BYTE    fNonEfaxSUB     :1;
    BYTE    fNonEfaxSEP     :1;
    BYTE    fNonEfaxPWD     :1;
    BYTE    fNonEfaxCharMode:1;
    BYTE    fNonEfaxDTM     :1;
    BYTE    fNonEfaxBTM     :1;
    BYTE    fNonEfaxEDI     :1;
**/
}
LLPARAMS, FAR* LPLLPARAMS, NEAR* NPLLPARAMS;

/** Baud rate capability codes **/
#define V27_SLOW			0
#define V27_ONLY			2
#define V29_ONLY			1
#define V33_ONLY			4
#define V17_ONLY			8
#define V27_V29				3
#define V27_V29_V33			7
#define V27_V29_V33_V17		11
#define V_ALL				15


/** Baud rate mode codes **/
#define V27_2400     0  
#define V29_9600     1 
#define V27_4800     2 
#define V29_7200     3 
#define V33_14400    4 
#define V33_12000    6 
#define V17_14400    8
#define V17_9600     9
#define V17_12000    10
#define V17_7200     11


/** Minscan capability codes **/
#define MINSCAN_0_0_0		7
#define MINSCAN_5_5_5		1
#define MINSCAN_10_10_10	2
#define MINSCAN_20_20_20	0
#define MINSCAN_40_40_40	4
#define MINSCAN_40_20_20	5
#define MINSCAN_20_10_10	3
#define MINSCAN_10_5_5		6
#define MINSCAN_10_10_5	   	10
#define MINSCAN_20_20_10   	8
#define MINSCAN_40_40_20   	12
#define MINSCAN_40_20_10   	13
#define MINSCAN_20_10_5	   	11


typedef enum
{
	WHICHDCS_FIRST = 0,
	WHICHDCS_NOREPLY = 1,
	WHICHDCS_FTT = 2,
	WHICHDCS_DIS = 3
}
WHICHDCS;



#pragma pack()    

#endif /* _FR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\fcomapi.h ===
/***************************************************************************
        Name      :     FCOMAPI.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.
        Functions :     (see Prototypes just below)
        Revision Log

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "timeouts.h"

#define FILTER_DLEONLY  1
#define FILTER_DLEZERO  0



// following currently defined in FileT30.h
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)










/***************************************************************************
                                        Common Modem Operations
***************************************************************************/

#ifdef CBZ
        typedef char __based(__segname("_CODE")) CBSZ[];
        typedef char __based(__segname("_CODE")) *CBPSTR;
#else
#       ifdef LPZ
                typedef char far CBSZ[];
                typedef char far *CBPSTR;
#       else
                typedef char near CBSZ[];
                typedef char near *CBPSTR;
#       endif
#endif

// iModemInit takes following SPECIAL values for fInstall:
#define fMDMINIT_NORMAL 0       // Normal Init -- includes ID Check.
#define fMDMINIT_INSTALL 1      // Full install
#define fMDMINIT_ANSWER 10      // Quick init before answering -- Skips ID check.

// +++ Old code sometimes calls with fINSTALL=TRUE
#if     (fMDMINIT_INSTALL!=TRUE) || (fMDMINIT_ANSWER==TRUE) || (fMDMINIT_NORMAL!=0) || !fMDMINIT_ANSWER
#       error "fMDMINIT_* ERROR"
#endif

// iModemInit returns these
#define INIT_OK                         0
#define INIT_INTERNAL_ERROR     13
#define INIT_MODEMERROR         15
#define INIT_PORTBUSY           16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\genawd.h ===
/*
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

        name:   Elliot Viewer - Chicago Viewer Utility
        						Cloned from the IFAX Message Viewing Utility

        file:   genawd.h

    comments:   Header for AWD file creation functions for C folks
            
        
		
----------------------------------------------------------------------------
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
*/

/*
	Unicode spasms
 */
//#ifndef WIN32
#ifndef TCHAR
typedef char TCHAR;
#endif
 
#ifndef _T
#define _T(x)	x
#endif

#ifndef LPTSTR
typedef TCHAR FAR *LPTSTR;
#endif

#ifndef LPTCH
typedef TCHAR FAR *LPTCH;
#endif
//#endif   
   
   
/*  
	Error return codes
 */
#define GENAWD_OK				0  	// No worries
#define GENAWD_CANTCREATE 		1	// Can't create AWD doc file
#define GENAWD_NODOCUMENTS  	2	// DocnameList is NULL
#define GENAWD_CANTCREATE0 	 	4	// Can't create Documents storage
#define GENAWD_CANTCREATE1 	 	5	// Can't create Persistent Information storage
#define GENAWD_CANTCREATE2 	 	6	// Can't create Page Information storage
#define GENAWD_CANTCREATE3 	 	7	// Can't create Document Information storage
#define GENAWD_CANTCREATE4 	 	8	// Can't create Global Information storage
#define GENAWD_CANTCREATE5 	 	9	// Can't create Annotation storage
#define GENAWD_CANTCREATE6 	   10	// Can't create Object storage
#define GENAWD_CANTOPENSTREAM  11  	// Can't open a stream
#define GENAWD_CANTWRITESTREAM 12  	// Can't write a stream
#define GENAWD_CANTOPENDOSFILE 13  	// Can't open a DOS file
#define GENAWD_NOMEMORY        14  	// Out of memory
#define GENAWD_CANTOPENMSG	   15	// Can't open AWD doc/message file
#define GENAWD_CANTMAKEOBJECT  16   // Can't create embedded object                                
#define GENAWD_CANTINITOLE	   17   // Can't initialize OLE2 innards
#define GENAWD_CANTMAKETEMPSTG 18   // Can't create temp IStorage for object
#define GENAWD_CANTREADDOSFILE 19   // Can't read dos file
#define GENAWD_CANTCREATE7 	   20	// Can't create DisplayOrder stream




#ifdef __cplusplus
extern "C" {
#endif

short far
	InitAwdFile( LPTSTR lpszAwdName );
	
	
short far
	AddDocFile( LPTSTR lpszDocName );
	
	
short far
	CloseAwdFile( void );		
    
    
/*
	istgObj is cast to an IStorage* internally and used for the
	object's IStorage if it is non-NULL. I did it this way so a 
	C caller won't have to #include all of the compound file 
	garbage if it doesn't want to. If istgObj is NULL then 
	a temporary IStorage is created for the object.
 */
short far
	MakeEmbeddedObject( LPTSTR lpszAwdName, 
						LPVOID FAR *istgObj,	// IStorage*, can be NULL.
						LPVOID FAR *ppvObj );

	
#ifdef __cplusplus	
	}             
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\filet30.h ===
/***************************************************************************
 Name     :
 Comment  :

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
  ???     arulm created
 3/17/94  josephj Modified to handle AWG3 format, tapi and other device ids.
                  Specifically, changed prototypes for FileT30Init,
                  and FileT30ModemClasses, and added #defines for LINEID_*
***************************************************************************/
#ifndef _FILET30_
#define _FILET30_

#include <ifaxos.h>
#include <t30fail.h>

#ifdef __cplusplus
extern "C" {
#endif

//      Types of LineId's
#define LINEID_NONE             (0x0)
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)
#define LINEID_NETFAX_DEVICE    (0x10)


USHORT  FileT30Init(
                                DWORD dwLineID, USHORT usLineIDType,
                                DWORD dwProfileID, LPSTR lpszSection,
                                USHORT uClass,
                                // LPSTR szSpoolDir, LPSTR szId,
                                // LPSTR szDefRecipAddress, LPSTR szDefRecipName,

                                USHORT uAutoAnswer, HWND hwndListen
                         );

        // dwLineID, usLineIDType:
        //   If usLineIDType==LINEID_COMM_PORTNUM:
        //      dwLineID = COMM port# -- 1 to 4 for COM ports, 0 for CAS
        //   If usLineIDType==LINEID_COMM_HANDLE:
        //      dwLineID = Handle to open comm port.
        //   If usLineIDType==LINEID_TAPI_DEVICEID:
        //      dwLineID = TAPI DeviceID
        //   If usLineIDType==LINEID_TAPI_PERMANENT_DEVICEID:
        //      dwLineID = TAPI Permanent DeviceID.
        //
        // uClass: exactly one of the FAXCLASS??? #defines from below
        //
        //  dwProfileID and lpszSection point to the registry/inifile that
        //      contain configuration information for the particular line.
        //
        //      WIN16: dwProfileID is ignored (should be 0), and we look in efaxpump.ini
        //                 lpszSection should point to the section where per-line
        //                 configuration information is stored. The following entries
        //                 are mandatory:
        //                 - SpoolDir --> path to spool directory for recvd files
        //                       acquires modem etc. Returns one of values below
        //                 - LocalId:   ID to be used in DIS/CIG
        //                 - DefRecipAddr: Recip address to be used for
        //                       incoming G3 faxes
        //                 - DefRecipName:    Recip name to be used for incoming G3 faxes.
        // WIN32: dwProfileID should point to a system registry key handle (such as
        //                              HKEY_CURRENT_USER)
        //                lpszSection should be a key relative to the above handle that
        //                points to a location where configuration information for this
        //                line is to be stored. The mandatory entries are those mentioned
        //                above for WIN16 -- they are all null-terminated strings.

        // uAutoAnswer, hwndListen: same as for FileT30Listen below..
        //
        // Returns OK, NOMODEM (port number is wrong) or PORTBUSY
        // (somebody else is using the port) or WRONGTYPE (wrong modem type)
        // BETTERTYPE (chosen type is supported, but a "better" type is also
        // supported). In the last 2 cases suberr is 1,2, or 3 giving the
        // correct/better type and Init is *successful*. In the BETTERTYPE
        // case, the chosen type is used, *not* the "better" type.
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem


USHORT  FileT30Listen(USHORT uLevel, HWND hwndResult);
        // uLevel: 0==off 1==notif posted if hwndResult is non-NULL 2==auto
        // returns one of values below
        // Usually OK or PORTBUSY
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem

        // In manual answer mode (Mode 1), once a RING is detected,
        // it _must_ be cleared before anything else can be done.
        // It can be cleared by a call to FileT30Answer(T/F)

void  FileT30Send(ATOM aPhone, ATOM aCapsPhone, ATOM aFileAWG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX, HWND hwndResult);
        // return value via IF_FILET30_DONE message below.
        // Result values can be
        //      BUSY or PORTBUSY
        //      CALLDONE+SENTALL                                -- all Aok
        //      CALLFAIL+SENTSOME or SENTNONE   -- actually called & failed
        //      BADPARAM                                                -- bad file name, phone number too long
        //      BUG                                                             -- some debugchk failed
        //  DIALFAIL+NCUDIAL_xxx                        -- failure during dial
        //  DIALFAIL+NCUANSWER_xxx                      -- failure during answer
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        //      That's it
        // aCapsPhone, is nonzero, is to be used to as  the key for saving
        // capabilities entries (it  will be in canonical form, typically).
        // All the caller is responsible for freeing all atoms, on receiving
        // FILET30_DONE message, which is guaranteed to be sent.

ULONG  FileT30Answer(BOOL fAccept, BOOL fImmediate, HWND hwndResult);
        // fAccept is FALSE to reject a call
        // if fAccept and fImmediate are TRUE call is answered even
        //              if no RING detected if transport is IDLE
        // if fAccept==TRUE and fImmediate==FALSE call is answered
        //              iff it is ringing. We also wait for the configured
        //              number of Rings rather than answer immediately.

        // failure return value (loword==err hiword==FailureCode)
        // Result values can be
        // BUSY or PORTBUSY
        // FILE_ERROR
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        // Nothing else


void  FileT30Abort();
        // Synchronous abort of current send/recv. Busy-waits until done.
        // Transport returns to IDLE state. If aim is to shut down all
        // activity, then call FileT30Listen(0,0) first, then FileT30Abort()
        // and then FileT30Deinit(TRUE)

DWORD  FileT30ReportRecv(LPDWORD lpdwPollContext, BOOL fGetIt);
        // returns file names of received faxes one by one.
        // *lpdwPollContext, if non-null, will be set to 0 if this is a normal
        // receive or the supplied context dword if this is a response to a poll
        // request (see FileT30PollRequest).
        //
        // returns 0 if no more received faxes
        // LOWORD is global atom for file name
        // HIWORD is final result (i.e. lowbyte=one of the values below,
        //                                                              hibyte=Failure Code // T30FAIL_xxx values)
        //
        // The only return values returned are:-
        // ANSWERFAIL (ext err is NCUANSWER_ERROR or NCUANSWER_NORING)
        //              (former likely on voice calls, latter on manual answers)
        // CALLFAIL, CALLDONE, ABORT or FILE_ERROR (ext err == 0)
        // file atom can be present anyway from any of these. If
        // result value is not CALLDONE then this is only a partially
        // received transmission.


BOOL  FileT30AckRecv(ATOM aRecv);
        // acknowledges successful receipt. The Recv log is deleted
        // aRecv must be non-NULL and a valid recv file name
        // returns FALSE on errors

        // ***NOTE*** Until AckRecv is called multiple calls to ReportRecv
        //                        will return the same value


USHORT  FileT30Status(void);
        // returns one of
#       define  T30STATE_IDLE           0
#       define  T30STATE_SENDING        1
#       define  T30STATE_RECEIVING      2
#       define  T30STATE_ABORTING       3       // stuck inside abort loop
                                                                // this is a bad error...!!


void  FileT30SetStatusWindow(HWND hwndStatus);
        // all subsequent status messages get posted to this
        // window. If hwndStatus==0, recv status is not posted

BOOL  FileT30ReadIniFile(void);
        // forces transport to re-read INI file
        // returns FALSE if busy


USHORT  FileT30DeInit(BOOL fForce);
        // Frees modem etc.
        // returns T30_OK if ok
        // Returns T30_BUSY if call in progress
        // If call not in progress, but recv files left,
        // returns T30_RECVLEFT. If fForce is TRUE then
        // it saves recv file list to disk and returns
        // and T30_OK. Reloads recv list next time


DWORD  FileT30ModemClasses(
        DWORD dwLineID, USHORT usLineIDType,
        DWORD dwProfileID, LPSTR lpszSection
        );
        // dwLineID, usLineIDType: same as in FileT30Init.
        // dwProfileID, lpszSection: same as in FileT30Init.
        //----------MUST BE CALLED ONLY WHEN TRANSPORT IS **NOT** INITED--------//
        // returns ((DWORD)(-1)) on error (e.g. if called when transport is inited)
        // return 0 if no modem detected (e.g. CAS is supported but no CAS detected
        //                                                              or can't get ComPort or can't talk to modem)
        // LOWORD(return value)==uClasses is one or more of the below
        // CAS is checked IFF uPort is 0

#ifdef WIN32
BOOL  FileT30UpdateHandle(HANDLE hComm);
        // Once the transport has been inited with an external handle,
        // and answer mode is off, and no activity is ongoing, this api
        // can be called to to specify a new comm handle. If hComm ==
        // NULL, this will disable further sends or attempts to change answer
        // mode to on until a subsequent FileT30UpdateHandle call is made with a
        // valid hComm. The comm port and modem will be in an unknown state
        // when this is made, so the transport should properly setup the
        // port and reset the modem to a known state the next time it want's
        // to talk to the modem.
#endif

#       define          FAXCLASS0               0x01
#       define          FAXCLASS1               0x02
#       define          FAXCLASS2               0x04
#       define          FAXCLASS2_0             0x08    // Class4==0x10
#       define          FAXCLASSMOUSE   0x40    // used if mouse found
#       define          FAXCLASSCAS             0x80

void  FileT30PollReq(ATOM aPhone, ATOM aCapsPhone, USHORT PollType,
                   ATOM aDocName, ATOM aPassWord, DWORD dwPollContext, HWND hwndResult);

        // Poll type is one of the POLLTYPE_ values below
#define POLLTYPE_G3                      0 // G3(blind) poll req: DocName/Pass=null
#define POLLTYPE_EXTCAPS         2 // ext-caps poll request: DocName/Pass=null
#define POLLTYPE_NAMED_DOC       3 // named-doc poll req: DocName=reqd. Pwd=optional
#define POLLTYPE_BYRECIPNAME 4 // poll-by-recip-name: DocName=recip email-name. Pwd=reqd
#define POLLTYPE_BYPATHNAME      5 // poll-by-filename: DocName=file-path. Pwd=reqd

        // dwPollContext is a dword of context which will associated with all
        // receives associated with this poll request. See FileT30ReportReceives.

        // return value via IF_FILET30_DONE message below.
        // Poll Response shows up as a regular recvd message
        // Result values can be
        //      BUSY or PORTBUSY
        //      CALLDONE                                -- all Aok
        //      CALLFAIL                                -- actually called & failed
        //      BADPARAM                                -- bad file name, phone number too long
        //      BUG                                             -- some debugchk failed
        //  DIALFAIL+NCUDIAL_xxx        -- failure during dial
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        // aCapsPhone -- see FileT30Send.

// also returns
        // T30_NOSUPPORT  -- returns this if this API is called with a Class2
        //              or CAS modem (polling not supported), or a non-G3 pollreq is
        //              sent to a non-AWFAX entity (this error returned after calling)




/**------------------ Messages returned *from* t30.exe --------------------**/

#define IF_FILET30_STATUS       (IF_USER + 0x702)
        // wParam==aPhone (used as handle)
        // LOBYTE(LOWORD(lParam))==one of T30STATUS_ defines below
        // HIBYTE(LOWORD(lParam))==N1 (as defined below)
        // LOBYTE(HIWORD(lParam))==N2 (as defined below)
        // HIBYTE(HIWORD(lParam))==N3 (as defined below)
        // +++ WARNING: these constants are duplicated in psifxapi.h

  typedef enum
  {
        T30STAT_INITING,        // all N==0
  // sender
        T30STATS_DIALING,       // all N==0
        T30STATS_TRAIN,         // N1==BaudRateCode N2==how many times N3==0
                                                // Baud rate remains same for the page that follows
        T30STATS_SEND,          // N1==Page number N2==%age done N3==0
        T30STATS_CONFIRM,       // N1==Page number N2==0 N3==0
        T30STATS_REJECT,        // N1==Page number N2==0 N3==0
        T30STATS_RESEND_ECM,// N1==Page number N2==0 N3==Block number
        T30STATS_SUCCESS,       // all N==0
        T30STATS_FAIL,          // all N==0
  // recvr
        T30STATR_ANSWERING,     // all N==0
        T30STATR_TRAIN,         // N1==0 N2==how many times(NYI) N3==0
                                                // Baud rate remains same for the page that follows
        T30STATR_RECV,          // N1==Page number
                                                // MAKEWORD(N2,N3)==KBytes recvd in this page
        T30STATR_CONFIRM,       // N1==Page number **rest NYI** N2==Num bad lines N3==0
        T30STATR_REJECT,        // N1==Page number **rest NYI** N2==Num bad lines N3==0
        T30STATR_RERECV_ECM,// **all Ns NYI**  N1==Page number N2==BlockNum N3==how many times
        T30STATR_SUCCESS,       // all N==0
        T30STATR_FAIL,          // all N==0
  // both
        T30STAT_ERROR,          // all N==0
  // autoanswer
        T30STAT_NOANSWER,               // all N==0
        T30STAT_MANUALANSWER,   // all N==0
        T30STAT_AUTOANSWER,             // all N==0

        T30STATS_SEND_DATA,             // N1==Page number N2=KB sent in curr page N3==MsgNum or AttachNum
        T30STATR_RECV_DATA,             // N1==Page number N2=KB recvd in curr page N3==MsgNum or AttachNum
        T30STATS_CONFIRM_ECM    // Sent in ADDITION to T30STATS_CONFIRM
                                                // N1==Page number.
                                                // MAKEWORD(N2,N3)==K Bytes confirmed.
  }
  T30STATUS;

        // Baud rate codes
        /* V27_2400     0  (display as V.27 2400bps) */
        /* V29_9600     1 */
        /* V27_4800     2 */
        /* V29_7200     3 */
        /* V33_14400    4 */
        /* V33_12000    6 */
        /* V17_14400    8 */
        /* V17_9600     9 */
        /* V17_12000    10 */
        /* V17_7200     11 */


// Not used any more
// #define      IF_FILET30_RING         (IF_USER + 0x704)
        // wParam, lParam not used
        // sent iff listen level is set to 1
        // This is sent in manual answer mode. You *must* call FileT30Answer
        // with TRUE or FALSE after this, otherwise no further calls will
        // be answered or notified.

#define IF_FILET30_DESTTYPERES          (IF_USER + 0x705)
        // wParam==aPhone. LOBYTE(LOWORD(lParam))=one of the DEST_ defines below
        //                      HIBYTE(LOWORD(lParam))=Res--one or more of the RES_ defines
        //                      LOBYTE(HIWORD(lParam))=Enc--one or more of the ENCODE_ defines
        //                      HIBYTE(HIWORD(lParam))=vSecurity--security version number
        //                                                                      00==none 01==snowball
        // (see protapi.h for format)

        // Destination types
#       define DEST_UNKNOWN     0
#       define DEST_G3                  1
#       define DEST_IFAX                2
#       define DEST_EFAX                3
#       define NUM_DESTTYPE     4


#define IF_FILET30_TEXTCAPS     (IF_USER + 0x706)
        // wParam==aPhone. lParam==long pointer to ASCIIZ rep. of recvd NSF/CSI/DIS
        // length of the textcaps will never exceed
        #define TEXTCAPSSIZE    300

#define IF_FILET30_START        (IF_USER + 0x702)
#define IF_FILET30_END          (IF_USER + 0x706)

#define IF_FILET30_DONE         (IF_USER + 0x703)
        // sent after a Send is done
        // wParam==aPhone (used as handle)
        // LOBYTE(LOWORD(lParam))==result value
        // HIBYTE(LOWORD(lParam))==ext err
        // LOBYTE(HIWORD(lParam))==FailureCode  // one of the T30FAIL_xxx defines
        // never returns OK. Only CALLDONE, DIALFAIL, BUSY, PORTBUSY, BADPARAM, BADFILE
        // **new** and FILE_ERROR (only on disk-errors on manual answer; on same
        // errors in auto-answer, it just doesn't answer). Currently this happens
        // if (a) spool dir is so full it can't find a unique file name or
        // (b) it can't create a spool file for the received fax.

/**----- result values --------**/
#define T30_OK                          0
#define T30_CALLDONE            1
#define T30_CALLFAIL            2
#define T30_BUSY                        3
#define T30_DIALFAIL            4
#define T30_ANSWERFAIL          5
#define T30_BADPARAM            6
#define T30_WRONGTYPE           7
#define T30_BETTERTYPE          8
#define T30_NOMODEM                     9
#define T30_MISSING_DLLS        10
#define T30_FILE_ERROR          11
#define T30_RECVLEFT            12
#define T30_INTERNAL_ERROR      13
#define T30_ABORT                       14
#define T30_MODEMERROR          15
#define T30_PORTBUSY            16
#define T30_MODEMDEAD           17
#define T30_GETCAPS_FAIL        18
#define T30_NOSUPPORT           19
/**----- ICommEnd values **/


/**----- If err=T30_DIALFAIL, exterr is one of -----**/
#       define          NCUDIAL_ERROR                   0
// #define              NCUDIAL_OK                              1
#       define          NCUDIAL_BUSY                    2
#       define          NCUDIAL_NOANSWER                3
#       define          NCUDIAL_NODIALTONE              4
#       define          NCUDIAL_MODEMERROR              5


/**----- If err=T30_ANSWERFAIL, exterr is one of -----**/
#       define          NCUANSWER_ERROR                 0
// #define              NCUANSWER_OK                    1
#       define          NCUANSWER_NORING                8
#       define          NCUANSWER_MODEMERROR    5
#       define          NCUANSWER_DATAMODEM     10

/**----- If err=T30_MODEMBUSY, exterr is one of -----**/
        // 0==we are using it 1==someone else is using the modem/com port

/**-- On Send: if err=T30_CALLDONE or T30_CALLFAIL, exterr is one of --**/
#       define          T30_SENTALL             1
#       define          T30_SENTNONE    2
#       define          T30_SENTSOME    3

/***
        if err=T30_CALLDONE and exterr=T30_SENTALL
                a call is considered completed successfully
        if err=T30_CALLFAIL and exterr=T30_SENTALL                      ***REPORT A BUG***
                something weird has heppened,
                but all pages _may_ have reached.
                to be safe call it an error
        if err=T30_CALLDONE and exterr!=T30_SENTALL                     ***REPORT A BUG***
                something _really_ weird has happened,
                most probably all pages did not reach OK.
                To be safe call it an error
        if err=T30_CALLFAIL and exterr!=T30_SENTALL
                A definite error
**/

/**-- On Send and Recv: if err=T30_CALLDONE or T30_CALLFAIL, FailureCode is one of
          the failure codes described in T30FAIL.H
**/



/************************************************************************
*************************************************************************
*************************************************************************
*************************************************************************
*************************************************************************/



/**-- disk file format (MG3, EFX, IFX and CFX files)
          File consists on N pages, each with a header of
          the following structure, followed by data.

          However, all parameters in the headers on non-first
          pages are ignored, except the size field, i.e. you can't
          mix MG3/IFX/EFX in a single file, and all pages better
          use the same res/width/length/encoding.

          Sigs are:- "G3", "EB", "EI" (EFAX binary, image) and "EF"
                                 (File/ASCII)
--**/

#define SIG_G3          0x3347
#define SIG_EB          0x4245
#define SIG_EI          0x4945
#define SIG_FA          0x4146

typedef struct {
        WORD    wSig;                   // must always be set and must be the same for all headers in a file.
        WORD    wHeaderSize;    // size of this header in bytes. Must always be set
        WORD    wTotalHeaders;  // significant *only* in *first* page header. Can be zero otherwise.
        WORD    wHeaderNum;             // from 1 to wNumPages. Must always be set.
        DWORD   lDataOffset;// offset to this page's data from start of file. Must always be set.
        DWORD   lDataSize;      // num bytes of data following. Must always be set.

// 16 bytes
        DWORD   lNextHeaderOffset;      // offset to next header, from start of file. Must always be set.

        // the next 5 are significant *only* in *first* page header. Can be zero otherwise.
        BYTE    Resolution;             // one or more of the RES_ #defines below
        BYTE    Encoding;               // one or more of the ENCODE_ #defines below
        BYTE    PageWidth;                      // one of the WIDTH_ #defines below
        BYTE    PageLength;                     // one of the LENGTH_ #defines below
        WORD    wMinBytesPerLine;       // set to 0 if no guarantees
                                                                // this may not be used
        WORD    Text;                   // Text Encoding, can use TEXT_ASCII from below
        BYTE    RecvStatus;             // Received OK/not OK (0=unknown/unused 1=OK 2=error)
        BYTE    SendStatus;             // Sent OK/not OK (0=unknown/unused 1=OK 2=error)
        WORD    vSecurity;              // Pad to 32 bytes

// 32 bytes
#define MAXFHBIDLEN     20
        BYTE    szID[MAXFHBIDLEN+1];            // caller id (used in send _and_ recv). Null terminated.
        BYTE    Reserved2[11];  // Pad to 32 bytes

// 64 bytes

        BYTE    szFileTitle[13];// Null-term 8.3 user-visible file name,
        BYTE    szFileName[13]; // Null-term 8.3 file name, assumed to be in _same_
                                                        // directory as the spool file containing this struct
        BYTE    Reserved3[6];   // Pad to 32 bytes

// 96 bytes

        BYTE    Reserved4[160]; // pad out to 256 bytes for future expansion

// 256 bytes

} FHB, far* LPFHB;

#define vSECURE_SNOW    1

/**---------------------------------------------------------------------

MG3
        A G3 file consists of one or more such headers each followed by
        Group-3 fax data, in compressed form. Each header starts a new
        page. The number of pages, res, encoding, width & len of each
        page is set in the first header.

EFX
IFX
        An EB file consists of one or more such headers each followed by
        Linearized data. Each header starts a new Message. The number of
        messages in a file is determined by the 'wTotalPages' field of
        the first header. An EI file differs only in that the contents
        of the linearized message are claimed to be purely imageable.

CFX
        An FA file consists of one or more such headers. Each header
        either represents ASCII note-text or a file attachment.
        If the Text field of the header is set to TEXT_ASCII,
        then the header is followed by lPageDataSize bytes of ASCII
        data, and the szFileName field is not used.

        Otherwise the Text field must be 0 and the szFileName
        field must be meaningful, and must contain the user-visible
        filename of an attachment. The file must be in the same
        directory, and the filename is in zero-terminated 8.3 format.
        Resolution, Width, Length, wMinBytesPerLine unused. The
        And the lPageDatSize field of this structure must be zero.


NOTES:-
        In all cases, wSig, wHeaderSize, lPageDataSize, lPagePadSize
        must be set correctly (0 when applicable).
        Each FHB in the file corresponds to a logical "page", so
        wPageNum must always be set accordingly (first page is 1) and
        in the FIRST FHB in a file wTotalPages must be set to the total
        number of FHB structures in the file. In all other FHBs in the file
        it must be 0.

        Resolution, Encoding, Width, Length and wMinBytesPerLine
        are not always used. In all cases, all unused fields, reserved and
        pad fields must be set to 00.

--------------------------------------------------------------------**/


//--------------------- Transport API's ---------------

BOOL FAR PASCAL ProcessAnswerModeReturn(USHORT uRetVal);
    // Return TRUE if the answer mode shoudl be retried
    // FALSE if not. Displays an error message box if
    // necessary.

//--------------------- PROFILE ACCESS API's ---------------
//
//      Following APIs provide access the fax-related information
//      stored in the the registry/ini-file.
//
//      These API's should be used, rather than GetPrivateProfileString, etc...
//  On WIN32, these API's use the registry.
//

#ifdef WIN32
#define USE_REGISTRY
#endif

#ifdef USE_REGISTRY
#       define  DEF_BASEKEY 1
#       define  OEM_BASEKEY 2
#else
#       define  DEF_BASEKEY 0
#       define  OEM_BASEKEY 0
#endif

#define szINIFILE                       "EFAXPUMP.INI"

#define szDIALTONETIMEOUT       "DialToneWait"
#define szANSWERTIMEOUT         "HangupDelay"
#define szDIALPAUSETIME         "CommaDelay"
#define szPULSEDIAL                     "PULSEDIAL"
#define szDIALBLIND                     "BlindDial"
#define szSPEAKERCONTROL        "SpeakerMode"
#define szSPEAKERVOLUME         "Volume"
#define szSPEAKERRING           "RingAloud"
#define szRINGSBEFOREANSWER     "NumRings"
#define szHIGHESTSENDSPEED      "HighestSendSpeed"
#define szLOWESTSENDSPEED       "LowestSendSpeed"
#define szENABLEV17SEND         "EnableV17Send"
#define szENABLEV17RECV         "EnableV17Recv"



#define szDISABLEECM            "DisableECM"
#define szDISABLEG3ECM          "DisableG3ECM"
#define sz64BYTEECM                     "SmallFrameECM"
#define szDISABLE_MR_SEND       "DisableMRSend"
#define szDISABLE_MR_RECV       "DisableMRRecv"
#define szCOPYQUALITYCHECKLEVEL "CopyQualityCheckLevel"

#define szOEMKEY                        "OEMKey"
#define szFAX                           "Fax"

#ifdef PCMODEMS
#define szFIXMODEMCLASS         "FixModemClass"
#define szFIXSERIALSPEED        "FixSerialSpeed"
#define szCL1_NO_SYNC_IF_CMD "Cl1DontSync"
#define szANSWERMODE            "AnswerMode"
#define szANS_GOCLASS_TWICE "AnsGoClassTwice"
#endif //PCMODEMS


#define szDEFRECIPNAME          "DefRecipName"
#define szDEFRECIPADDR          "DefRecipAddr"
#define szSPOOLDIR                      "SpoolDir"
#define szLOCALID                       "LocalID"

#define szGENERAL                       "General"
#define szRUNTIME                       "RunTime"
#define szACTIVEDEVICEID    "ActiveDeviceID"
#define szACTIVEDEVICEIDTYPE "ActiveDeviceIDType"
#define szACTIVEDEVICESECTION "ActiveDeviceSection"

// Following use to specify model-specific behavour of CLASS2 Modems.
// Used only in the class2 driver.
#define         szRECV_BOR              "Cl2RecvBOR"
#define         szSEND_BOR              "Cl2SendBOR"
#define         szDC2CHAR               "Cl2DC2Char"    // decimal ascii code.
#define         szIS_SIERRA             "Cl2IsSr"               //Sierra
#define         szIS_EXAR               "Cl2IsEx"               //Exar
#define         szSKIP_CTRL_Q   "Cl2SkipCtrlQ"  // Don't wait for ^Q to send
#define         szSW_BOR                "Cl2SWBOR"              // Implement +FBOR in software.

// Following to control disabling compression capabalities
// 0 => Enabled !0 => Disabled
#define         szDISABLE_CMPRS_SEND    "DisableCmprsSend"
#define         szDISABLE_CMPRS_RECV    "DisableCmprsRecv"

// Cotrols whether we delete the modem section on installing modem...
#define         szDONT_PURGE "DontPurge"
#define szDIALCAPS                      "DialCaps"
        // One of the LINEDEVCAPSFLAGS_* below.

// RAW Capabilities for the machine dialled last - a MACHINECAPS structure
// which consists of (see srvrdll documentation):
// DIS -- single FR structure.
// NSFs -- Multipe FR structures, terminated by an FR structure with 0
// type and size.
#define szRemoteMachineCaps             "RemoteMACHINECAPS"


// Following constants from TAPI.H
// Indicate which special dial chars the modem supports: '!' '@' 'W' resp.
#define LINEDEVCAPFLAGS_DIALBILLING  0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET        0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE 0x00000100

#ifdef NSF_TEST_HOOKS

// These are used only for nsf compatibility testing...

// Key where test NSx frames are stored
#define szNSFTEST "Runtime\\NSFTest"

// Under the above key, the values are as follows:
// If any of the following are defined, we will transmit
// the corresponding frames instead of the internally-generated ones:
//              Name                    Type    Description
//          SentNSFFrameCount   string  count of nsf frames
//              SentNSFFrames           binary  one or more FR structures
//              SentNSSFrameCount       string
//              SentNSSFrames           binary
//
//      After each call, the received frames will be written under the same
//      key (NSFTest):
//              RecvdNSFFrameCount  string  count of nsf frames
//              RecvdNSFFrames      binary  one or more FR structures
//              RecvdNSSFrameCount  string
//              RecvdNSSFrames          binary
//              RecvdNSCFrameCount      string
//              RecvdNSCFrames          binary

#endif // NSF_TEST_HOOKS

//===========   PROFILE ENTRIES: ENHANCED COMM MONITORING =============

#define szMONITORCOMM "MonitorComm"
                        // If 1, comm monitoring is enabled. On by default
                        //      for debug, off by default for retail.
                        // Used by awfxio32.dll

#define szMONITORBUFSIZEKB "MonitorBufSizeKB"
                        // Size of comm monitor buffer in KB. If not specified,
                        // internal default is used.
                        // Used by awfxio32.dll

//========== PROFILE ENTRIES: ADAPTIVE ANSWER =============

#define szADAPTIVEANSWER "AdaptiveAnswer"
                        // If 1, adaptive answer is enabled -- i.e., the ability
                        // to answer either a data or fax call.
                        // Used by awfxio32.dll and awfxex32.exe

//========== PROFILE ENTRIES: TAPI =============

#define szHIGHEST_PRIO_APP "HighestPrioApp"
                        // String value giving module name of app to be placed as
                        // highest priority to answer datamodem calls.
                        // Used by awfxex32.exe

//      Flags passed into ProfileOpen
enum {
fREG_READ               = 0x1,
fREG_WRITE              = 0x1<<1,
fREG_CREATE     = 0x1<<2,
fREG_VOLATILE   = 0x1<<3
};

//--------------------- END PROFILE ACCESS API's ---------------

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FILET30_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\global.h ===
//
// thread sync. timeouts
//

#define RX_WAIT_ACK_TERMINATE_TIMEOUT   60000
#define RX_ACK_THRD_TIMEOUT             3000

#define TX_WAIT_ACK_TERMINATE_TIMEOUT   60000

//
// TIFF encoder/decoder defs.
//

#define  LINE_LENGTH   1728

#define  FAX_SUCCESS   0
#define  FAX_FAILURE   1

#define  RET_FAIL     0
#define  RET_SUCCESS  1
#define  RET_TIMEOUT  2
#define  RET_CANCELED 3

#define  LOG_ALL      256
#define  LOG_ERR      1
#define  LOG_NOTHING  0

#define  T30_RX       1
#define  T30_TX       2



typedef struct {
    DWORD           tiffCompression;
    BOOL            HiRes;
    char            lpszLineID[16];  // to be used for a temp. TIFF page data file
}  TX_THRD_PARAMS;

#define   DECODE_BUFFER_SIZE    44000

#define   MODEMKEY_FROM_UNIMODEM   1
#define   MODEMKEY_FROM_ADAPTIVE   2
#define   MODEMKEY_FROM_NOTHING    3



//identify.c

typedef struct {

   DWORD_PTR hglb;                 // Tmp globall alloc "handle" for strings.
                                                        // type HGLOBAL for non-ifax and LPVOID
                                                        // for IFAX
   LPBYTE lpbBuf;
   LPSTR  szReset;                      // MAXCMDSIZE
   LPBYTE szSetup;                      // MAXCMDSIZE
   LPBYTE szExit;                       // MAXCMDSIZE
   LPBYTE szPreDial;            // MAXCMDSIZE
   LPBYTE szPreAnswer;          // MAXCMDSIZE
   LPBYTE szIDCmd;                      // MAXCMDSIZE
   LPBYTE szID;                         // MAXIDSIZE
   LPBYTE szResponseBuf;        // RESPONSEBUFSIZE
   LPBYTE szSmallTemp1;         // SMALLTEMPSIZE
   LPBYTE szSmallTemp2;         // SMALLTEMPSIZE

   LPMODEMCAPS lpMdmCaps;
   LPMODEMEXTCAPS lpMdmExtCaps;
   DWORD dwSerialSpeed;
   DWORD dwFlags;               // dwFlags, as defined in the CMDTAB structure.
   DWORD dwGot;
   USHORT uDontPurge;           // Profile entry says shouldn't delete the profile.
                                                        // NOTE: We will ignore this and not delete the
                                                        // profile if we don't get a response from the
                                                        // modem, to avoid unnecessarily deleting the
                                                        // profile simply because the modem is not
                                                        // responding/off/disconnected.
                                                        //
                                                        // 0 = purge
                                                        // 1 = don't purge
                                                        // anything else = uninitialized.

} S_TmpSettings;


typedef struct tagThreadGlobal {
        //  t30.c
    int                     RecoveryIndex;
    ET30PARAMS              Params;      // protocol\t30.h
    ET30T30                 T30;         // same
    ET30ECM                 ECM;         // same
    ET30ECHOPROTECT         EchoProtect; // same
        // protapi.c
    PROT                    ProtInst;    // protocol\protocol.h
    PROTPARAMS              ProtParams;  // headers\protparm.h
        // ddi.c
    MODEMPARAMS             ModemParams; // headers\modemddi.h
    CLASS1_MODEM            Class1Modem; // class1\class1.h
    CLASS1_STATUS           Class1Status;// same
        // ifddi.c
    CLASS1_DDI              DDI;         // same
        // 4. fcom.c
    FCOM_COMM               Comm;        // comm\fcomint.h
    BOOL                    fNCUAbort;// same,  0=None 2=abort FCOM 1=abort higher level only
        // identify.c
    S_TmpSettings           TmpSettings; // here
        // ncuparams.c
    NCUPARAMS               NCUParams;   // headers\ncuparm.h
    BOOL                    fNCUParamsChanged; //comm\modemint.h, to indicate the we need to reset params on next dial/answer...
        // modem.c
    FCOM_MODEM              FComModem;   // same
    FCOM_STATUS             FComStatus;  // same

    INSTDATA                Inst;        // fxrn\efaxrun.h

    HLINE                   LineHandle;
    HCALL                   CallHandle;
    DWORD                   DeviceId;
    HANDLE                  FaxHandle;
    HANDLE                  hComm;
        // memory management
    USHORT  uCount;
    USHORT  uUsed;
    BUFFER  bfStaticBuf[STATICBUFCOUNT];
    BYTE    bStaticBufData[STATICBUFSIZE];
        // additional mostly from gTAPI
    int                     fGotConnect;
    HANDLE                  hevAsync;
    int                     fWaitingForEvent;
    DWORD                   dwSignalledRID;
    DWORD                   dwSignalledParam2;
    DWORD_PTR               dwSignalledParam3;
    DWORD                   dwPermanentLineID;
    char                    lpszPermanentLineID[16];
    char                    lpszUnimodemFaxKey[200];
    char                    lpszUnimodemKey[200];
    TIFF_INFO               TiffInfo;
    LPBYTE                  TiffData;
    int                     TiffPageSizeAlloc;
    int                     TiffOffset;
    int                     fTiffOpenOrCreated;
    char                    lpszDialDestFax[sizeof(LINETRANSLATEOUTPUT)+64];
    DWORD                   StatusId;
    DWORD                   StringId;
    DWORD                   PageCount;
    LPTSTR                  CSI;
    LPTSTR                  CallerId;
    LPTSTR                  RoutingInfo;
    int                     fDeallocateCall;
    int                     CurrentCommSpeed;
    HANDLE                  CtrlEvent;
    COMM_CACHE              CommCache;
    BOOL                    fMegaHertzHack;
    MONINFO                 gMonInfo;
    FCOM_FILTER             Filter;

#ifdef SMM
#define MAXFILTERBUFSIZE 2048
    BYTE                    bStaticFilterBuf[MAXFILTERBUFSIZE];
#endif

#define CMDTABSIZE 100
    BYTE                    bModemCmds[CMDTABSIZE];    // store modem cmds read from INI/registry here

#define SMALLTEMPSIZE   80
    char                    szSmallTemp1[SMALLTEMPSIZE];
    char                    szSmallTemp2[SMALLTEMPSIZE];

    COMMODEM_FRAMING        Framing;

#ifdef SMM
#define FRAMEBUFINITIALSIZE     ((USHORT)(((4 + 256 + 2) * 1.2) + 10)) // extra for flags
    BYTE                    bStaticFramingBuf[FRAMEBUFINITIALSIZE];
#endif


    BYTE                    bRem[MAXNSFFRAMESIZE];
    BYTE                    bOut[MAXNSFFRAMESIZE];

    PROTDUMP                fsDump;

#ifndef NOCHALL
    BYTE                    bSavedChallenge[POLL_CHALLENGE_LEN];
    USHORT                  uSavedChallengeLen;
#endif

#define TOTALRECVDFRAMESPACE    500
#ifdef SMM
    BYTE                    bStaticRecvdFrameSpace[TOTALRECVDFRAMESPACE];
#endif

    DWORD                   lEarliestDialTime;

    RFS                     rfsSend;

    WORD                    PrevcbInQue;
    WORD                    PrevcbOutQue;
    BOOL                    PrevfXoffHold;
    BOOL                    PrevfXoffSent;


    LPWSTR                  lpwFileName;

    HANDLE                  CompletionPortHandle;
    ULONG_PTR                CompletionKey;

// helper thread interface
    BOOL                    fTiffThreadRunning;


    TX_THRD_PARAMS          TiffConvertThreadParams;
    BOOL                    fTiffThreadCreated;
    HANDLE                  hThread;

    HANDLE                  ThrdSignal;
    HANDLE                  FirstPageReadyTxSignal;

    DWORD                   CurrentOut;
    DWORD                   FirstOut;
    DWORD                   LastOut;
    DWORD                   CurrentIn;

    BOOL                    ThrdRuns;

    BOOL                    ReqTerminate;
    BOOL                    AckTerminate;
    BOOL                    ReqStartNewPage;
    BOOL                    AckStartNewPage;
    BOOL                    ThreadFatalError;

    char                    InFileName[_MAX_FNAME];
    HANDLE                  InFileHandle;
    BOOL                    InFileHandleNeedsBeClosed;
    BOOL                    fTxPageDone;
    BOOL                    fTiffPageDone;
    BOOL                    fTiffDocumentDone;

// helper RX interface


    BOOL                    fPageIsBad;
    BOOL                    fLastReadBlock;

    HANDLE                  ThrdDoneSignal;
    HANDLE                  ThrdAckTerminateSignal;

    DWORD                   ThrdDoneRetCode;

    DWORD                   BytesIn;
    DWORD                   BytesInNotFlushed;
    DWORD                   BytesOut;
    DWORD                   BytesOutWillBe;

    char                    OutFileName[_MAX_FNAME];
    HANDLE                  OutFileHandle;
    BOOL                    SrcHiRes;

// error reporting
    BOOL                    fFatalErrorWasSignaled;

// abort sync.

    HANDLE                  AbortReqEvent;
    HANDLE                  AbortAckEvent;
    BOOL                    fUnblockIO;        // pending I/O should be aborted ONCE only
    BOOL                    fOkToResetAbortReqEvent;
    BOOL                    fAbortReqEventWasReset;

    BOOL                    fAbortRequested;

// CSID, TSID local/remote

    char                    LocalID[MAXTOTALIDLEN + 2];
    LPWSTR                  RemoteID;
    BOOL                    fRemoteIdAvail;

// Adaptive Answer
    BOOL                    AdaptiveAnswerEnable;

// Unimodem setup
    DWORD                   dwSpeakerVolume;
    DWORD                   dwSpeakerMode;
    BOOL                    fBlindDial;

// INF settings
    BOOL                    fEnableHardwareFlowControl;

    UWORD                   SerialSpeedInit;
    BOOL                    SerialSpeedInitSet;
    UWORD                   SerialSpeedConnect;
    BOOL                    SerialSpeedConnectSet; 
    UWORD                   FixSerialSpeed;
    BOOL                    FixSerialSpeedSet;

    BOOL                    fCommInitialized;

// derived from INF
    UWORD                   CurrentSerialSpeed;

// Unimodem key info
    char                    ResponsesKeyName[300];

// new ADAPTIVE.INF

    DWORD                   FaxClass;
    
    char                   *ResetCommand;
    char                   *SetupCommand;
    
    DWORD                   AnswerCommandNum;
    char                   *AnswerCommand[20];
    char                   *ModemResponseFaxDetect;
    char                   *ModemResponseDataDetect;
    UWORD                   SerialSpeedFaxDetect;
    UWORD                   SerialSpeedDataDetect;
    char                   *HostCommandFaxDetect;
    char                   *HostCommandDataDetect;
    char                   *ModemResponseFaxConnect;
    char                   *ModemResponseDataConnect;

    BOOL                    Operation;

// Flags to indicate the source of INF info

    BOOL                    fAdaptiveRecordFound;
    BOOL                    fAdaptiveRecordUnique;
    BOOL                    fUnimodemFaxDefined;
    DWORD                   AdaptiveCodeId;
    DWORD                   ModemKeyCreationId;


// Class2 

    DWORD                   ModemClass;
    
    USHORT    cbResponseSize;
    BYTE    lpbResponseBuf[RESPONSE_BUF_SIZE];
    CL2_COMM_ARRAY  class2_commands;
    

    BOOL        fRecvPageOK; // flag set when Class2GetRecvPageAck is called
    NCUPARAMS   NCUParams2;
    LPCMDTAB        lpCmdTab;
    PROTPARAMS      ProtParams2;
    BYTE        bLastReply2[REPLYBUFSIZE+1];
    BYTE        bFoundReply[REPLYBUFSIZE+1];
    
    MFRSPEC                 CurrentMFRSpec;
    BYTE                    Class2bDLEETX[3];
    
    BYTE                    lpbResponseBuf2[RESPONSE_BUF_SIZE];
    
    BCwithTEXT      bcSendCaps; // Used to generate DIS
    BCwithTEXT      bcSendParams; // Used to generate DCS
    PCB DISPcb; // has default DIS values for this modem.
    
    BOOL        fAbort; // flag set when Class2Abort is called
    
    TO    toAnswer;
    TO    toRecv;
    TO    toDialog;
    TO    toZero;

#define C2SZMAXLEN 50

    C2SZ cbszFDT[C2SZMAXLEN];                    
    C2SZ cbszINITIAL_FDT[C2SZMAXLEN];            
    C2SZ cbszFDR[C2SZMAXLEN];                    
    C2SZ cbszFPTS[C2SZMAXLEN];                   
    C2SZ cbszFCR[C2SZMAXLEN];                    
    C2SZ cbszFNR[C2SZMAXLEN];                    
    C2SZ cbszFCQ[C2SZMAXLEN];                    
    C2SZ cbszFLO[C2SZMAXLEN];                    

    C2SZ cbszFBUG[C2SZMAXLEN];                   
    C2SZ cbszSET_FBOR[C2SZMAXLEN];               

    // DCC - set High Res, Huffman, no ECM/BFT, default all others.
    C2SZ cbszFDCC_ALL[C2SZMAXLEN];               
    C2SZ cbszFDCC_RECV_ALL[C2SZMAXLEN];          
    C2SZ cbszFDIS_RECV_ALL[C2SZMAXLEN];          
    C2SZ cbszFDCC_RES[C2SZMAXLEN];               
    C2SZ cbszFDCC_BAUD[C2SZMAXLEN];              
    C2SZ cbszFDIS_BAUD[C2SZMAXLEN];              
    C2SZ cbszFDIS_IS[C2SZMAXLEN];                
    C2SZ cbszFDIS_NOQ_IS[C2SZMAXLEN];            
    C2SZ cbszFDCC_IS[C2SZMAXLEN];                
    C2SZ cbszFDIS_STRING[C2SZMAXLEN];            
    C2SZ cbszFDIS[C2SZMAXLEN];                   
    C2SZ cbszZERO[C2SZMAXLEN];                   
    C2SZ cbszONE[C2SZMAXLEN];                    
    C2SZ cbszQUERY_S1[C2SZMAXLEN];               
    C2SZ cbszRING[C2SZMAXLEN];                   
    
    
    C2SZ cbszCLASS2_ATI[C2SZMAXLEN];             
    C2SZ cbszCLASS2_FMFR[C2SZMAXLEN];           
    C2SZ cbszCLASS2_FMDL[C2SZMAXLEN];           
    C2SZ cbszCLASS2_FREV[C2SZMAXLEN];

    C2SZ cbszFDT_CONNECT[C2SZMAXLEN];            
    C2SZ cbszFDT_CNTL_Q[C2SZMAXLEN];             
    C2SZ cbszFCON[C2SZMAXLEN];                   
    C2SZ cbszGO_CLASS2[C2SZMAXLEN];              
    C2SZ cbszFLID[C2SZMAXLEN];                   
    C2SZ cbszENDPAGE[C2SZMAXLEN];                
    C2SZ cbszENDMESSAGE[C2SZMAXLEN];             
    C2SZ cbszCLASS2_QUERY_CLASS[C2SZMAXLEN];     
    C2SZ cbszCLASS2_GO_CLASS0[C2SZMAXLEN];       
    C2SZ cbszCLASS2_ATTEN[C2SZMAXLEN];           
    C2SZ cbszATA[C2SZMAXLEN];                    
    // Bug1982: Racal modem, doesnt accept ATA. So we send it a PreAnswer
    // command of ATS0=1, i.r. turning ON autoanswer. And we ignore the
    // ERROR response it gives to the subsequent ATAs. It then answers
    // 'automatically' and gives us all the right responses. On hangup
    // however we need to send an ATS0=0 to turn auto-answer off. The
    // ExitCommand is not sent at all in Class2 and in Class1 it is only
    // sent on releasing the modem, not between calls. So just send an S0=0
    // after the ATH0. If the modem doesnt like it we ignore the response
    // anyway
    C2SZ cbszCLASS2_HANGUP[C2SZMAXLEN];   
    C2SZ cbszCLASS2_CALLDONE[C2SZMAXLEN]; 
    C2SZ cbszCLASS2_ABORT[C2SZMAXLEN];    
    C2SZ cbszCLASS2_DIAL[C2SZMAXLEN];     
    C2SZ cbszCLASS2_NODIALTONE[C2SZMAXLEN];
    C2SZ cbszCLASS2_BUSY[C2SZMAXLEN];     
    C2SZ cbszCLASS2_NOANSWER[C2SZMAXLEN]; 
    C2SZ cbszCLASS2_OK[C2SZMAXLEN];       
    C2SZ cbszCLASS2_FHNG[C2SZMAXLEN];    
    C2SZ cbszCLASS2_ERROR[C2SZMAXLEN];    
    C2SZ cbszCLASS2_RESET[C2SZMAXLEN];
    C2SZ cbszCLASS2_ATE0[C2SZMAXLEN];

    BYTE    Resolution;             
    BYTE    Encoding;               


// Dbg
    DWORD                   CommLogOffset;
    DWORD                   dbg1;
    DWORD                   dbg2;
    DWORD                   dbg3;
    DWORD                   dbg4;
    DWORD                   dbg5;


}   ThrdGlbl, *PThrdGlbl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\glbproto.h ===
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\AWNSFINT.H


WORD EXPORTBC NSxtoBC(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                LPBC lpbcOut, WORD wBCSize);

WORD EXPORTBC BCtoNSx(PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from protocol\timeouts.h

#ifdef MDDI             // timeouts


/****************** begin prototypes from timeouts.c *****************/
void TstartTimeOut(PThrdGlbl pTG, TO * npto, ULONG ulTimeOut);
BOOL TcheckTimeOut(PThrdGlbl pTG, TO * npto);
/****************** end prototypes from timeouts.c *****************/

#else //MDDI

#define TstartTimeOut(pTG, lpto, ulTime)             startTimeOut(pTG, lpto, ulTime)
#define TcheckTimeOut(pTG, lpto)                     checkTimeOut(pTG, lpto)

#endif //MDDI



//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\timeouts.h

/****************** begin prototypes from timeouts.c *****************/
extern void    startTimeOut( PThrdGlbl pTG, TO *lpto, ULONG ulTimeOut);
extern BOOL    checkTimeOut( PThrdGlbl pTG, TO *lpto);
extern ULONG  leftTimeOut( PThrdGlbl pTG, TO *lpto);
/****************** begin prototypes from timeouts.c *****************/





//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\protapi.h



#define ProtGetSendMod(pTG)                  ((USHORT)ProtExtFunction(pTG, GET_SEND_MOD))
#define ProtGetRecvMod(pTG)                  ((USHORT)ProtExtFunction(pTG, GET_RECV_MOD))
#define ProtGetRetransmitMask(pTG)   ((LPBYTE)ProtExtFunction(pTG, GET_PPR_FIF))
#define ProtGetECMFrameSize(pTG)     ((USHORT)ProtExtFunction(pTG, GET_ECM_FRAMESIZE))
#define ProtGetRecvECMFrameSize(pTG) ((USHORT)ProtExtFunction(pTG, GET_RECV_ECM_FRAMESIZE))
#define ProtReceivingECM(pTG)                ((BOOL)ProtExtFunction(pTG, RECEIVING_ECM))
#define ProtGetWhatNext(pTG)                 ((LPWHATNEXTPROC)ProtExtFunction(pTG, GET_WHATNEXT))
#define ProtGetPPS(pTG)                      ((ULONG)ProtExtFunction(pTG, GET_PPS))

// have to use this in SendPhaseC
#define ProtGetMinBytesPerLine(pTG)         ((USHORT)ProtExtFunction(pTG, GET_MINBYTESPERLINE))
#define ProtGetRecvECMFrameCount(pTG)       ((USHORT)ProtExtFunction(pTG, GET_RECVECMFRAMECOUNT))
#define ProtResetRecvECMFrameCount(pTG) ((USHORT)ProtExtFunction(pTG, RESET_RECVECMFRAMECOUNT))
#define ProtResetRecvPageAck(pTG)           ((USHORT)ProtExtFunction(pTG, RESET_RECVPAGEACK))

#define ProtGetSendEncoding(pTG)            ((USHORT)ProtExtFunction(pTG, GET_SEND_ENCODING))
#define ProtGetRecvEncoding(pTG)            ((USHORT)ProtExtFunction(pTG, GET_RECV_ENCODING))



/****************** begin prototypes from protapi.c *****************/
BOOL    ProtGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep);
DWORD_PTR ProtExtFunction(PThrdGlbl pTG, USHORT uFunction);

                BOOL WINAPI ET30ProtSetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uRecvSpeeds, USHORT uSendSpeeds);
typedef BOOL (WINAPI *LPFN_ET30PROTSETPROTPARAMS)(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uRecvSpeeds, USHORT uSendSpeeds);
                BOOL WINAPI ET30ProtClose(PThrdGlbl pTG);
typedef BOOL (WINAPI *LPFN_ET30PROTCLOSE)(PThrdGlbl pTG);
                BOOL WINAPI iET30ProtSetBC(PThrdGlbl pTG, LPBC lpBC, BCTYPE bctype);
typedef BOOL (WINAPI *LPFN_IET30PROTSETBC)(PThrdGlbl pTG, LPBC lpBC, BCTYPE bctype);
                void WINAPI ET30ProtRecvPageAck(PThrdGlbl pTG, BOOL fAck);
typedef void (WINAPI *LPFN_ET30PROTRECVPAGEACK)(PThrdGlbl pTG, BOOL fAck);
                void WINAPI ET30ProtAbort(PThrdGlbl pTG, BOOL fEnable);
typedef void (WINAPI *LPFN_ET30PROTABORT)(PThrdGlbl pTG, BOOL fEnable);
                BOOL WINAPI ET30ProtOpen(PThrdGlbl pTG, BOOL fCaller);
typedef BOOL (WINAPI *LPFN_ET30PROTOPEN)(PThrdGlbl pTG, BOOL fCaller);

#ifdef OEMNSF
        // Ricoh IFS66 only
        void   LoadOEMNSFDll(PThrdGlbl pTG, HINSTANCE hinstModem);
        void   UnloadOEMNSFDll(PThrdGlbl pTG, BOOL fNormal);
#endif

#ifdef RICOHAI
        BOOL RicohAIInit(PThrdGlbl pTG);
        void RicohAIEnd(PThrdGlbl pTG);
        void RicohAIInitRecv(PThrdGlbl pTG);
#endif

/***************** end of prototypes from protapi.c *****************/


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\comapi.h

#define FComFilterAsyncWrite(pTG, lpb,cb,fl) (FComFilterWrite(pTG, lpb, cb, fl) == cb)
// #define FComFilterSyncWrite(lpb,cb)  ((FComFilterWrite(lpb, cb)==cb) && FComDrain(TRUE,TRUE))
#define FComDirectAsyncWrite(pTG, lpb,cb) (FComDirectWrite(pTG, lpb, cb) == cb)
#define FComDirectSyncWriteFast(pTG, lpb,cb)  ((FComDirectWrite(pTG, lpb, cb)==cb) && FComDrain(pTG, FALSE,TRUE))

#define FComFlush(pTG)                     { FComFlushQueue(pTG, 0); FComFlushQueue(pTG, 1); }
#define FComFlushInput(pTG)        { FComFlushQueue(pTG, 1); }
#define FComFlushOutput(pTG)       { FComFlushQueue(pTG, 0); }


extern BOOL    FComInit(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType);

extern BOOL    FComClose(PThrdGlbl pTG);
extern BOOL    FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate);
extern void    FComFlushQueue(PThrdGlbl pTG, int queue);
extern BOOL    FComXon(PThrdGlbl pTG, BOOL fEnable);
extern BOOL    FComDTR(PThrdGlbl pTG, BOOL fEnable);
extern UWORD   FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb);
extern UWORD   FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags);
extern BOOL    FComDrain(PThrdGlbl pTG, BOOL fLongTimeout, BOOL fDrainComm);
extern UWORD   FComFilterReadBuf(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lpto, BOOL fClass2, LPSWORD lpswEOF);
// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout
extern SWORD    FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead);

extern void    FComInFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterClose(PThrdGlbl pTG);

extern void    FComAbort(PThrdGlbl pTG, BOOL f);
extern void    FComCritical(PThrdGlbl pTG, BOOL);
extern void    FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin);

#if !defined(WFW) && !defined(WFWBG)
        extern BOOL   FComCheckRing(PThrdGlbl pTG);
        typedef BOOL (WINAPI *LPFN_FCOMCHECKRING)(PThrdGlbl pTG);
#endif
#ifndef MDRV
        BOOL FComGetOneChar(PThrdGlbl pTG, UWORD ch);
#endif //!MDRV


extern void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fStart);

/****************** begin DEBUG prototypes *****************/
extern void  far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid);
extern void  far D_HexPrint(LPB b1, UWORD incnt);

extern  void far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs);
typedef void (far  *LPFN_D_GOTERROR)(PThrdGlbl pTG, int nCid, int err, COMSTAT far* lpcs);

#ifdef WFWBG
        extern void  far FComSetBG(PThrdGlbl pTG, BOOL);
        typedef void (far  *LPFN_FCOMSETBG)(PThrdGlbl pTG, BOOL);
#endif
/***************** end of prototypes *****************/



/****************** begin prototypes from modem.c *****************/
extern USHORT  iModemInit(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
                                                                                        DWORD dwProfileID,
                                                                                        LPSTR lpszKey,
                                                                                        BOOL fInstall);
typedef USHORT (WINAPI  *LPFN_IMODEMINIT)(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
                                                                                        DWORD dwProfileID,
                                                                                        LPSTR lpszKey,
                                                                                        BOOL fInstall);
extern BOOL  iModemClose(PThrdGlbl pTG);
typedef BOOL (WINAPI  *LPFN_IMODEMCLOSE)(PThrdGlbl pTG);

extern BOOL     iModemSetNCUParams(PThrdGlbl pTG, int comma, int speaker, int volume, int fBlind, int fRingAloud);
extern BOOL     iModemHangup(PThrdGlbl pTG);
extern USHORT   iModemDial(PThrdGlbl pTG, LPSTR lpszDial, USHORT uClass);
extern USHORT   iModemAnswer(PThrdGlbl pTG, BOOL fImmediate, USHORT uClass);
extern LPCMDTAB   iModemGetCmdTabPtr(PThrdGlbl pTG);

// 6 fixed args, then variable number of CBPSTRs, but there
// must be at leat 2. One real one and one NULL terminator
extern UWORD  far iiModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                                        BOOL fMultiLine, UWORD uwRepeatCount, BOOL fPause,
                                        CBPSTR w1, CBPSTR w2, ...);
/***************** end of prototypes from modem.c *****************/






//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\filet30.h


ULONG_PTR   ProfileOpen(DWORD dwProfileID, LPSTR lpszSection, DWORD dwFlags);
                //                      dwProfileID should be one of DEF_BASEKEY or OEM_BASEKEY.
                //                      lpszSection should be (for example) "COM2" or "TAPI02345a04"
                //                      If dwProfileID == DEF_BASEKEY, the value is set to be a
                //                      sub key of:
                //                              HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\At Work Fax\
                //                              Local Modems\<lpszSection>.
                //                      Else if it is DEF_OEMKEY, it is assumed to be a fully-
                //                      qualified Key name, like "SOFTWARE\MICROSOFT.."
                //
                //                      Currently both are based of HKEY_LOCAL_MACHINE.
                //
                //      When you're finished with this key, call ProfileClose.
                //
                //  dwFlags is a combination of one of the fREG keys above..
                //
                //  WIN32 ONLY: if lpszSection is NULL, it will open the base key,
                //              and return its handle, which can be used in the Reg* functions.


// Following are emulations of Get/WritePrivateProfileInt/String...

BOOL   
ProfileWriteString(
    ULONG_PTR dwKey,
    LPSTR lpszValueName,
    LPSTR lpszBuf,
    BOOL  fRemoveCR 
    );


DWORD   ProfileGetString(ULONG_PTR dwKey, LPSTR lpszValueName, LPSTR lpszDefault, LPSTR lpszBuf , DWORD dwcbMax);
UINT   ProfileGetInt(ULONG_PTR dwKey, LPSTR szValueName, UINT uDefault, BOOL *fExist);


UINT   
ProfileListGetInt(
    ULONG_PTR  KeyList[10],
    LPSTR     lpszValueName,
    UINT      uDefault
);


// Following read/write binary data (type REG_BINARY). Available
// on Win32 only....

// Returns size of data read
DWORD   ProfileGetData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf , DWORD dwcbMax);
// Returns true on success. Deletes Value if lpbBuf is NULL.
BOOL    ProfileWriteData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf , DWORD dwcb);

void   ProfileClose(ULONG_PTR dwKey);
BOOL   ProfileDeleteSection(DWORD dwProfileID, LPSTR lpszSection);

BOOL   
ProfileCopySection(
      DWORD   dwProfileIDTo,
      LPSTR   lpszSectionTo,  
      DWORD   dwProfileIDFr,
      LPSTR   lpszSectionFr,
      BOOL    fCreateAlways
);

BOOL   ProfileCopyTree(DWORD dwProfileIDTo,
                        LPSTR lpszSectionTo, DWORD dwProfileIDFrom, LPSTR lpszSectionFrom);







//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



// from headers\modemddi.h


/****************** begin prototypes from ddi.c *****************/
                USHORT  NCUModemInit(PThrdGlbl pTG, DWORD lInitParam);
                void  NCUModemDeInit(PThrdGlbl pTG);
#ifdef UNUSED
                void  NCUGetConfig(PThrdGlbl pTG, LPNCUCONFIG lpNCUConfig);
#endif // UNUSED
                USHORT  NCUCheckRing(PThrdGlbl pTG, USHORT uLine);
                USHORT  NCUCheckHandset(PThrdGlbl pTG, USHORT uHandset);
                BOOL  NCUSetParams(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams);
typedef BOOL (WINAPI  *LPFN_NCUSETPARAMS)(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams);
                HLINE  NCUGetLine(PThrdGlbl pTG, USHORT uLine);
                BOOL   NCUReleaseLine(PThrdGlbl pTG, HLINE hLine);
                USHORT   NCULink(PThrdGlbl pTG, HLINE hLine, HMODEM hModem, USHORT uHandset, USHORT uFlags);
                USHORT   NCUDial(PThrdGlbl pTG, HLINE hLine, LPSTR szPhoneNum);
                USHORT   NCUTxDigit(PThrdGlbl pTG, HLINE hLine, char chDigit);
                void   NCUAbort(PThrdGlbl pTG, USHORT uLine, BOOL fEnable);
typedef void (WINAPI   *LPFN_NCUABORT)(PThrdGlbl pTG, USHORT uLine, BOOL fEnable);
                HMODEM  ModemOpen(PThrdGlbl pTG, USHORT uModemType, USHORT uModem);
                BOOL    ModemClose(PThrdGlbl pTG, HMODEM hModem);
                BOOL    ModemGetCaps(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpModemCaps);
typedef BOOL (WINAPI    *LPFN_MODEMGETCAPS)(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpModemCaps);
                BOOL  ModemSync(PThrdGlbl pTG, HMODEM hModem, ULONG     ulTimeout);

#ifndef MDDI
                // 4/12/95 JosephJ. +++ Hack to prevent ModemSync from issuing AT
                // on sending DCN.
                BOOL  ModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG   ulTimeout, DWORD dwFlags);
                        // dwFlags -- one of...
#                       define fMDMSYNC_DCN 0x1L
#endif // !MDDI

                BOOL  ModemFlush(PThrdGlbl pTG, HMODEM);
                USHORT  ModemConnectTx(PThrdGlbl pTG, HMODEM, ULONG ulTimeout, WORD wFlags);
                USHORT  ModemConnectRx(PThrdGlbl pTG, HMODEM, WORD wFlags);
                BOOL  ModemSendMode(PThrdGlbl pTG, HMODEM, USHORT uMod, BOOL fHDLC, USHORT ifrHint);
#ifdef UNUSED
                BOOL  ModemSendTCF(PThrdGlbl pTG, HMODEM, USHORT uMod, ULONG ulDuration);
#endif // UNUSED
                BOOL  ModemSendMem(PThrdGlbl pTG, HMODEM, LPBYTE lpb, USHORT uCount, USHORT uParams);
                BOOL  ModemSendSilence(PThrdGlbl pTG, HMODEM, USHORT uMillisecs, ULONG ulTimeout);
                BOOL  ModemRecvSilence(PThrdGlbl pTG, HMODEM, USHORT uMillisecs, ULONG ulTimeout);
                USHORT  ModemRecvMode(PThrdGlbl pTG, HMODEM, USHORT uMod, BOOL fHDLC, ULONG ulTimeout, USHORT ifrHint);
                USHORT  ModemRecvMem(PThrdGlbl pTG, HMODEM, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
                BOOL  ModemSetParams(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParms);
typedef BOOL (WINAPI  *LPFN_MODEMSETPARAMS)(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParms);
                void  ModemEndRecv(PThrdGlbl pTG, HMODEM);
                BOOL  NCUModemUpdateConfig(PThrdGlbl pTG);
/***************** end of prototypes from ddi.c *****************/

// Modem Diagnostics API
DWORD  NCUModemDiagnostic(PThrdGlbl pTG, HLINE, HMODEM, WORD inparam);


//////////////// This is used for Modem Diagnostics //////////////

// Start a Modem diagnostic session
WORD WINAPI MdmStartDiagnostic(PThrdGlbl pTG);
// return a handle or 0 on failure (modem busy)

// Execute a modem diagnostic & return result
DWORD WINAPI MdmExecDiagnostic(PThrdGlbl pTG, WORD hndle, WORD inparam);
// calls Low-level modem driver disgnostic function
// NCUModemDiagnostic(HLINE, HMODEM, WORD inparam)
// and returned the DWORD result

// Start a Modem transport diagnostic session
WORD WINAPI MdmEndDiagnostic(PThrdGlbl pTG, WORD hndle);




//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//fxrn

void SetFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail);
void SetStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3);

LPBUFFER  MyAllocBuf(PThrdGlbl pTG, LONG sSize);
BOOL  MyFreeBuf(PThrdGlbl pTG, LPBUFFER);
void MyAllocInit(PThrdGlbl pTG);


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//negot.c

BOOL NegotiateCaps(PThrdGlbl pTG);




//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// my own stuff


typedef VOID (T30LINECALLBACK)(
    HLINE               hLine,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );


VOID
T30LineCallBackFunction(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );




VOID FaxDevInit(PThrdGlbl pTG, HLINE   hLine,HCALL   hCall);
BOOL    T30ComInit( PThrdGlbl pTG, HANDLE hComm);
PVOID T30AllocThreadGlobalData(VOID);
BOOL T30Cl1Rx (PThrdGlbl  pTG);
BOOL T30Cl1Tx (PThrdGlbl  pTG,LPSTR      szPhone);

HANDLE T30GetCommHandle(HLINE   hLine, HCALL   hCall);



USHORT
T30ModemInit(PThrdGlbl pTG,HANDLE  hComm,DWORD   dwLineID,DWORD   dwLineIDType,
             DWORD   dwProfileID, LPSTR   lpszKey, BOOL    fInstall);


BOOL itapi_async_setup(PThrdGlbl pTG);
BOOL itapi_async_wait(PThrdGlbl pTG,DWORD dwRequestID,PDWORD lpdwParam2,PDWORD_PTR lpdwParam3,DWORD dwTimeout);
BOOL itapi_async_signal(PThrdGlbl pTG, DWORD dwRequestID, DWORD dwParam2, DWORD_PTR dwParam3);


VOID
MyDebugPrint(
    PThrdGlbl  pTG,
    int        DbgLevel,
    LPSTR      Format,
    ...
    );


LPLINECALLPARAMS itapi_create_linecallparams(void);

void
GetCommErrorNT(
    PThrdGlbl       pTG,
    HANDLE          h,
    int*            pn,
    LPCOMSTAT       pstat);


int
ReadFileNT(
    PThrdGlbl       pTG,
    HANDLE          h,
    LPVOID          lpBuffer,
    DWORD           BytesToRead,
    LPDWORD         BytesHadRead,
    LPOVERLAPPED    lpOverlapped,
    DWORD           TimeOut,
    HANDLE          SecondEvent
    );


void
ClearCommCache(
    PThrdGlbl   pTG
    );

int  FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead);


BOOL MonInit(PThrdGlbl pTG, LPMONOPTIONS lpmo);
                // dwPrefNumMRs - preferred number of MONREC structures in circ. buf
                // dwPrefBufSize - preferred size of byte circular buf
                // -- May globally alloc data of the appropriate size.
                // -- May use internal static data


void MonDeInit(PThrdGlbl pTG);
                // Inverse of MonInit.

BOOL MonPutComm(PThrdGlbl pTG, WORD wFlags, LPBYTE lpb, WORD wcb);
                // Adds comm info to monitor record.

BOOL MonPutEvent(PThrdGlbl pTG, WORD wFlags, WORD wID, WORD wSubID,
                                        DWORD dwData0, DWORD dwData1, LPSTR lpszTxtMsg);
                // Adds event info to monitor record.

void MonDump(PThrdGlbl pTG);
                // Dumps the .mon (byte buffer) and .mrc (MONREC buffer) to the
                // file constructed using lpszStubName, if non NULL.
                // EG: if lpszStubName == "d:\logs\awfax", the files
                // Created would be of the form "d:\logs\awfaxN.mon" and
                // "d:\logs\awfaxN.mrc", where N is a number starting with 0 and
                // incremented each time MonDump is called (it wraps around at 16
                // currently). N is reset to zero each time MonInit is called.
                // If lpszStubName is NULL, a default of "c:\fax" is used instead.

UWORD FComStripBuf(PThrdGlbl pTG, LPB lpbOut, LPB lpbIn, UWORD cb, BOOL fClass2, LPSWORD lpswEOF);

void InitCapsBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);

BOOL
SignalStatusChange(
    PThrdGlbl   pTG,
    DWORD       StatusId
    );

////////////////////////////////////////////////////////////////////
// Ansi prototypes
////////////////////////////////////////////////////////////////////

VOID  CALLBACK
T30LineCallBackFunctionA(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );

BOOL WINAPI
FaxDevInitializeA(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );


BOOL WINAPI
FaxDevStartJobA(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR       CompletionKey
    );

BOOL WINAPI
FaxDevEndJobA(
    HANDLE          FaxHandle
    );


BOOL WINAPI
FaxDevSendA(
    IN  HANDLE               FaxHandle,
    IN  PFAX_SEND_A          FaxSend,
    IN  PFAX_SEND_CALLBACK   FaxSendCallback
    );

BOOL WINAPI
FaxDevReceiveA(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE_A      FaxReceive
    );

BOOL WINAPI
FaxDevReportStatusA(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperationA(
    HANDLE              FaxHandle
    );






HANDLE
TiffCreateW(
    LPWSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    );




HANDLE
TiffOpenW(
    LPWSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly
    );



// fast tiff


DWORD
TiffConvertThreadSafe(
    PThrdGlbl   pTG
    );

DWORD
TiffConvertThread(
    PThrdGlbl   pTG
    );


DWORD
PageAckThreadSafe(
    PThrdGlbl   pTG
    );

DWORD
PageAckThread(
    PThrdGlbl   pTG
    );


VOID
SignalHelperError(
    PThrdGlbl   pTG
    );



BOOL
DecodeMHFaxPageAsync(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName
    );


BOOL
DecodeMRFaxPageAsync(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName,
    BOOL                HiRes
    );


DWORD
ComputeCheckSum(
    LPDWORD     BaseAddr,
    DWORD       NumDwords
    );

BOOL
SignalRecoveryStatusChange(
    T30_RECOVERY_GLOB   *Recovery
    );


VOID
SimulateError(
    DWORD   ErrorType
    );


int
SearchNewInfFile(
       PThrdGlbl     pTG,
       char         *Key1,
       char         *Key2,
       BOOL          fRead
       );


int 
my_strcmp(
       LPSTR sz1,
       LPSTR sz2
       );


void 
TalkToModem (
       PThrdGlbl pTG,
       BOOL      fGetClass
       );


BOOL
SaveInf2Registry (
       PThrdGlbl pTG
       );

BOOL
SaveModemClass2Registry  (
       PThrdGlbl pTG
       );


BOOL
ReadModemClassFromRegistry  (
       PThrdGlbl pTG
       );


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       );



BOOL
RemoveCR (
     LPSTR  sz
     );



/***  BEGIN PROTOTYPES FROM CLASS2.c ***/

BOOL
T30Cl2Rx(
   PThrdGlbl pTG
);


BOOL 
T30Cl2Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL  Class2Send(PThrdGlbl pTG);
BOOL  Class2Receive(PThrdGlbl pTG);
USHORT Class2Dial(PThrdGlbl pTG, LPSTR lpszDial);
USHORT Class2Answer(PThrdGlbl pTG, BOOL fImmediate);
SWORD Class2ModemSync(PThrdGlbl pTG);
UWORD   Class2iModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                  BOOL fMultiLine, UWORD uwRepeatCount, ...);
BOOL Class2ModemHangup(PThrdGlbl pTG);
BOOL Class2ModemAbort(PThrdGlbl pTG);
SWORD Class2HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, C2PSTR cbszCommand, UWORD uwLen);
USHORT Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout,
                        USHORT far* lpcbRecv);
BOOL  Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount);
BOOL Class2ModemDrain(PThrdGlbl pTG);
void Class2TwiddleThumbs(ULONG ulTime);
LPSTR Class2_fstrstr( LPSTR sz1, LPSTR sz2);
USHORT Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution);
BOOL Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb);
USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout);
USHORT Class2EndPageResponseAction(PThrdGlbl pTG);
BOOL Class2GetModemMaker(PThrdGlbl pTG);
void Class2SetMFRSpecific(PThrdGlbl pTG, LPSTR lpszSection);
BOOL    Class2Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
void    Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);
void    Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb);
void Class2SetDIS_DCSParams(PThrdGlbl pTG, BCTYPE bctype, LPUWORD Encoding, LPUWORD Resolution,
        LPUWORD PageWidth, LPUWORD PageLength, LPSTR szID);

void    Class2BCHack(PThrdGlbl pTG);
BOOL Class2GetBC(PThrdGlbl pTG, BCTYPE bctype);
void Class2GetRecvPageAck(PThrdGlbl pTG);
void Class2ReadProfile(PThrdGlbl pTG, LPSTR lpszSection);
void    cl2_flip_bytes( LPB lpb, DWORD dw);


BOOL   iModemGoClass(PThrdGlbl pTG, USHORT uClass);

void Class2Abort(PThrdGlbl pTG, BOOL fEnable);
BOOL  Class2NCUSet(PThrdGlbl pTG, LPNCUPARAMS NCUParams2);

void
Class2Init(
     PThrdGlbl pTG
);


BOOL
Class2SetProtParams(
     PThrdGlbl pTG,
     LPPROTPARAMS lp
);

/***    BEGIN PROTOTYPES FROM CLASS2_0.c ***/

BOOL
T30Cl20Rx (
    PThrdGlbl pTG
);


BOOL
T30Cl20Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL  Class20Send(PThrdGlbl pTG);
BOOL  Class20Receive(PThrdGlbl pTG);

void
Class20Init(
     PThrdGlbl pTG
);

BOOL Class20GetModemMaker(PThrdGlbl pTG);
           
BOOL    Class20Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\fmtres.h ===
/********************************************\
 * 
 *  File   : fmtres.h
 *  Author : Kevin Gallo
 *  Created: 9/27/93
 *
 *  Copyright (c) Microsoft Corp. 1993-1994
 *
 *  Overview:
 *
 *  Revision History:
 \********************************************/

#ifndef _FMTRES_H
#define _FMTRES_H

// System includes

#include "ifaxos.h"
#include "rendserv.h"
#ifdef IFAX
#include "awnsfapi.h"
#include "awnsfint.h"
#include "printer.h"
#include "scanner.h"
#include "sosutil.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Format Resolution Initializers
//

EXPORT_DLL BOOL WINAPI FRInitResolvers() ;
EXPORT_DLL BOOL WINAPI FRFreeResolvers() ;

// =================================================================
//
// Format Resolution Error Codes
//
// *******
// These are returned in GetLastError only.  See below for the function return values.
// *******
//
// Format IFErrAssemble(PROCID_NONE,MODID_FMTRES,0,error code)
//
// The error code is a 16 bit value specific to the format resolution
//
// Bits 0 - 3 indicate the error type (4)
// Bits 4 - 8 indicate the extended error type (specific to each error) (4)
// Bits 10 - 15 are specific data or errors to each extended error (8)
//
// =================================================================

#define FRMAKE_ERR(err) (err)

// All system errors are possible return values as well

#define FRERR_NONE              FRMAKE_ERR(0)     // No error
#define FRERR_UNRESOLVED        FRMAKE_ERR(1)     // Unresolved - incompatible type
#define FRERR_FR_FAIL           FRMAKE_ERR(2)     // The desired fmtres function failed (invalid params/other/etc..)
#define FRERR_DEV_FAIL          FRMAKE_ERR(3)     // Device failed.
#define FRERR_SOS_CORRUPT       FRMAKE_ERR(4)     // Message store was corrupt
#define FRERR_FS_FAIL           FRMAKE_ERR(5)     // File System failure
#define FRERR_SYSTEM_FAIL       FRMAKE_ERR(6)     // System failure (out of memory/load lib/etc...)

// =================================================================
// EXTENDED ERRORS:
//
// The extended error code is different for every error and must be determined based on the type of error
//
// =================================================================
 
#define FRMAKE_EXTERR(exterr) ((exterr) << 4)

// Used for all errors

#define FREXTERR_NONE           FRMAKE_EXTERR(0)     // No extended error code

// Extended errors for FRERR_UNRESOLVED

// We need a NO_PROP since the INCOMP_PROP can only store 32 values and there are 32 possible bits

#define FREXTERR_INCOMP_PROP    FRMAKE_EXTERR(1)	// At least one attachment had incompatible properties
							// - Data contains prop index (high 3 bits) and src value index (low 5)
#define FREXTERR_NO_PROP        FRMAKE_EXTERR(2)	// At least one attachment had a property with no values
							// - Data contains prop index (high 3 bits) and src value index (low 5)
#define FREXTERR_INCOMP_PROT    FRMAKE_EXTERR(3)	// The protocol was incompatible
							// - Data contains protocol vers (3 bits) of src (high) and tgt (low)
// Data contains reason for encryption failure
// 0 - Means machine does not support encryption at all
// 1 - Means at least one attachment could not be snet encrypted (basically lin images to snowball)

#define FREXTERR_NO_ENCRYPT     FRMAKE_EXTERR(4)	// Could not resolve because the target did not support encryption
#define FREXTERR_NEED_RNDRS     FRMAKE_EXTERR(5)	// Renderers were needed but cannot be used with this job type

// Extended errors for FRERR_SOS_CORRUPT

#define FREXTERR_OPEN_FAIL      FRMAKE_EXTERR(1)     // Could not open an attachment or message
#define FREXTERR_GETPROP_FAIL   FRMAKE_EXTERR(2)     // There was a property missing
#define FREXTERR_BAD_VALUE      FRMAKE_EXTERR(3)     // Property had an invalid value
#define FREXTERR_SAVE_FAIL      FRMAKE_EXTERR(4)     // Could not save changes
#define FREXTERR_SETPROP_FAIL   FRMAKE_EXTERR(5)     // Could not set a property value

#define FREXTERR_BAD_MSG        FRMAKE_EXTERR(6)     // The message was not properly formed

// Extended errors for FRERR_DEV_FAIL and
// Extended errors for FRERR_SYSTEM_FAIL

#define FREXTERR_NOT_ENOUGH_MEM FRMAKE_EXTERR(1)     // Out of memory
#define FREXTERR_LOAD_LIBRARY   FRMAKE_EXTERR(2)     // Load Library failed
#define FREXTERR_GETPROCADDRESS FRMAKE_EXTERR(3)     // Get Proc Address failed

// Extended errors for FRERR_FR_FAIL

#define FREXTERR_INVALID_PARAM  FRMAKE_EXTERR(1)     // Invalid Parameter
#define FREXTERR_INVALID_STEP   FRMAKE_EXTERR(2)     // Invalid step (e.g. open called before init)

// =================================================================
// ERROR DATA
//
// The error data is different for every error/extended error pair
//
// =================================================================
 
#define FRMAKE_ERRDATA(exterr) ((exterr) << 8)
#define FRGET_ERRDATA(exterr)  (((WORD)(exterr)) >> 8)

//
// These are the property indexes for FREXTERR_INCOMP_PROP extended error
//

#define FR_PROP_UNKNOWN     (0)
#define FR_PROP_ENCODING    (1)
#define FR_PROP_RESOLUTION  (2)
#define FR_PROP_PAGESIZE    (3)
#define FR_PROP_BRAND       (4)
#define FR_PROP_LENLIMIT    (5)

#define FRFormCustomError(err,exterr,data) ((WORD) (((err) | (exterr)) | FRMAKE_ERRDATA(data)))
#define FRFormIFError(err,exterr,data) \
           (IFErrAssemble(PROCID_NONE,MODID_FORMAT_RES,0,FRFormCustomError((err),(exterr),(data))))

#define FRGetError(err)         (((WORD)(err)) & 0x000f)
#define FRGetExtError(err)      (((WORD)(err)) & 0x00f0)
#define FRGetErrorCode(err)     (((WORD)(err)) & 0x00ff)
#define FRGetErrorData(err)     FRGET_ERRDATA(err)

#define FRSetErrorData(dwerr,data) (((dwerr) & 0xffff00ff) | FRMAKE_ERRDATA(data))

#ifdef IFAX

// 
// Format resolution flags
//
// These flags are passed in to the Resolve and CanResolve calls to indicate the target device
//

typedef enum {
    FRES_NORMAL = 0,       // Use the default destination
    FRES_SPOOL  = 1,       // Spool to file
    FRES_VIEW   = 2,       // Use viewer output format
    FRES_PRINT  = 3,       // Send to printer
    FRES_XMIT   = 4,       // Send to transport
    FRES_PRINTALL  = 5,    // Send to printer (all attachments)
    FRES_LOCAL_SEND = 6,   // Send to local user
} FRDEST ;

// Function return Codes
//
// These are the codes returned from format resolution Resolve and CanResolve
//
// If the return value is anything but FR_RESOLVED then GetLastError will contain the extended error information
//  - values for GetLastError are above
//

#define FR_UNRESOLVED   0x0000
#define FR_RESOLVED     0x0001
#define FR_COMPATIBLE   0x0002
#define FR_UPDATE       0x0004
#define FR_NON_RT       0x0008   // Non real-time (too slow or uses foreground resources)
#define FR_SOS_ERR      0x4000
#define FR_SYSTEM_ERR   0x8000

#define CHK_FR_ERR(n) ((n & (FR_SOS_ERR | FR_SYSTEM_ERR)) != 0)

//
// Some typedefs
//

typedef BC REMCAPS ;
typedef LPBC LPREMCAPS ;

//
// Context based calls 
//    These are used for better division of work.  Some can be done beforehand.
//

typedef LPVOID LPFORMATRES ;

LPFORMATRES WINAPI FRAlloc() ;
void WINAPI FRFree(LPFORMATRES lpfr) ;

BOOL WINAPI FRInit(LPFORMATRES lpfr,HSOSCLIENT hsc,LPSOSMSG lpSrcMsg,LPSOSMSG lpTgtMsg) ;
void WINAPI FRDeInit(LPFORMATRES lpfr) ;

BOOL WINAPI FROpen(LPFORMATRES lpfr,
		   FRDEST Dest,
		   lpRSProcessPipeInfo_t lpProcInfo,
		   LPREMCAPS lpRemCaps) ;

void WINAPI FRClose(LPFORMATRES lpfr) ;

BOOL WINAPI FRResolve(LPFORMATRES lpfr) ;

BOOL WINAPI FRCanResolve(LPFORMATRES lpfr) ;

//
// These will perform the operation completely
//

UINT WINAPI FRResolveMsg (HSOSCLIENT hsc,
			  LPSOSMSG lpSrcMsg,
			  LPSOSMSG lpTgtMsg,
			  FRDEST Dest,
			  lpRSProcessPipeInfo_t lpProcInfo) ;

UINT WINAPI FRCanResolveMsg (HSOSCLIENT hsc,
			     LPSOSMSG lpSrcMsg,
			     LPSOSMSG lpTgtMsg,
			     FRDEST Dest,
			     lpRSProcessPipeInfo_t lpProcInfo) ;

UINT WINAPI FRCompareRemCaps (HSOSCLIENT hsc,
			      LPSOSMSG lpSrcMsg,
			      LPSOSMSG lpTgtMsg,
			      LPREMCAPS lpRemCaps) ;

UINT WINAPI FRResolveRemote (HSOSCLIENT hsc,
			     LPSOSMSG lpSrcMsg,
			     LPSOSMSG lpTgtMsg,
			     FRDEST Dest,
			     lpRSProcessPipeInfo_t lpProcInfo,
			     LPREMCAPS lpRemCaps) ;

#endif

// The target message needs to allocated and open

EXPORT_DLL BOOL WINAPI FRResolveEncoding (lpEncoding_t lpSrcEnc,
					  lpEncoding_t lpTgtEnc,
					  lpTopology FAR * lplpTop) ;

#ifdef WIN32

EXPORT_DLL BOOL WINAPI FRAddNode (lpTopology FAR * lpTop, LPSTR lpszName, LPSTR RenderProc, LPVOID lpParam , UINT cbParam) ;

EXPORT_DLL BOOL WINAPI FRAddTopNode (lpTopology FAR * lpTop, lpTopNode lpNode) ;

#endif

EXPORT_DLL void WINAPI FRFreeTopology (lpTopology lpTop) ;

//
// Page size and resolution APIs
//

/***********************************************************************

@doc	PRINTER	EXTERNAL	

@types	PAPERFORMAT|Structure to hold the Paper Format Information.

@field	USHORT|usPaperType|The Size of the Paper.
@field	USHORT|usPaperWidth|The width of the Paper in mm.
@field	USHORT|usPaperHeight|The height of the Paper in mm.
@field	USHORT|usXImage|The number of pixels in x direction that will be
		created in an image for this page size at the resolution specified by
		the field usResInHorz by the printer driver.
@field	USHORT|usYImage|The number of scanlines that will be renderd for this
		page size at the resolution specified in usResInVert by the printer
		driver.
@field	USHORT|usResInHorz|The resolution in dpi (rounded to the closest
		hundredth) in the x direction.
@field	USHORT|usResInVert|The resolution in dpi (rounded to the closest
		hundredth) in the y direction.
@field	USHORT|usResInVert|The resolution in dpi (rounded to the closest
		hundredth) in the y direction.
@field	USHORT|usAspectXY|The AspectXY for a given resolution.  The is equal
		to the square root of the sum of squares of the resolution(in dpi)
		in x and y directions.
*************************************************************************/

typedef struct _PAPERFORMAT{
    USHORT  usPaperType;                // the equivalent windows paper size
    USHORT  usPaperWidth;               //in mm
    USHORT  usPaperHeight;              //in mm
    USHORT  usXImage;                   //in pixels
    USHORT  usYImage;                   //in pixels
    USHORT  usResInHorz;                //the resolution in dpi in x dir
    USHORT  usResInVert;                //the resolution in dpi in y dir
    USHORT  usAspectXY;                 //for the gdi info
} PAPERFORMAT, * PPAPERFORMAT;

typedef PAPERFORMAT FAR * LPPAPERFORMAT;
typedef PAPERFORMAT NEAR * NPPAPERFORMAT;

EXPORT_DLL USHORT WINAPI GetStdBytesPerLine(ULONG ulResolution,ULONG ulPaperSize);
EXPORT_DLL DWORD  WINAPI GetStdPixelsPerLine(ULONG ulResolution,ULONG ulPaperSize);
EXPORT_DLL DWORD  WINAPI GetStdLinesPerPage(ULONG ulResolution,ULONG ulPaperSize);
EXPORT_DLL USHORT WINAPI GetXResolution(ULONG ulResolution);
EXPORT_DLL USHORT WINAPI GetYResolution(ULONG ulResolution);
EXPORT_DLL BOOL   WINAPI GetPaperFormatInfo(LPPAPERFORMAT lpPf,ULONG ulAwPaperSize,USHORT usXRes,USHORT usYRes);

EXPORT_DLL WORD WINAPI AWPaperToFaxWidth(ULONG ulPaperSize);
EXPORT_DLL ULONG WINAPI FaxWidthToAWPaper(WORD Width);
EXPORT_DLL WORD WINAPI AWPaperToFaxLength(ULONG ulPaperSize);

#ifdef IFAX

// Given an encoding and an association returns either the same encoding or a new one

BOOL WINAPI FRGetAssocEncoding (lpEncoding_t lpEnc,LPSTR lpExt) ;

// This will return the paper sizes supported with the given input paper and zoom options
// This will return at ulPaperSize if ulZoomOption is 0

ULONG  WINAPI GetZoomCaps(ULONG ulPaperSize,ULONG ulZoomOption) ;

// This will give the zoom value to use to get ZoomPaperSize from OrigPaperSize
// Returns 0 if not possible

ULONG  WINAPI GetZoomValue(ULONG ulOrigPaperSize,ULONG ulZoomPaperSize) ;

//
// Debug functions - stubbed out in retail
//

// Returns TRUE if the fmtres version is debug, FALSE if retail (basically whether this does anything)
// The parameters are bit arrays, not enumerated values
// -1 will disable a filter

BOOL WINAPI FRSetDestCapFilter(DWORD dwEnc,DWORD dwRes,DWORD dwPageSize,DWORD dwLenLimit) ;
BOOL WINAPI FRGetDestCapFilter(LPDWORD dwEnc,LPDWORD dwRes,LPDWORD dwPageSize,LPDWORD dwLenLimit) ;

#endif

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FMTRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lft3lpc.h ===
#ifndef LFT3LPC_H
#define LFT3LPC_H
//
//	LFT3LPC.H	Marshalling of Local FileT30 API arguments
//
//	History:
//		3/7/94	JosephJ	Created.
//
typedef unsigned long DWORD;

// Function IDs
enum {
	eID_FILET30FIRST = 0x1000,
	eID_FILET30INIT = eID_FILET30FIRST,
	eID_FILET30LISTEN,
	eID_FILET30SEND,
	eID_FILET30ANSWER,
	eID_FILET30ABORT,
	eID_FILET30REPORTRECV,
	eID_FILET30ACKRECV,
	eID_FILET30STATUS,
	eID_FILET30SETSTATUSWINDOW,
	eID_FILET30REREADINIFILE,
	eID_FILET30DEINIT,
	eID_FILET30MODEMCLASSES,
	eID_FILET30REPORTSEND,
	eID_FILET30POLLREQ,
	eID_FILET30_INTERNAL_EVENT,
	eID_FILET30_CALLBACK_PERIODIC,
	eID_FILET30_CALLBACK_CALLDONE,
	eID_FILET30LAST = eID_FILET30_CALLBACK_CALLDONE
};

// Marshalled data.
typedef struct {

    DWORD  dwID;			// The eID_* above
    DWORD  dw1,dw2,dw3,dw4,dw5,dw6,dw7;	// Function specific (see below)
    DWORD  dwRet;			// Return value, if any.

} LFT30_MARSHALLED_DATA;

// Marshalling info...

// FileT30Init
	// dwID=eID_FILET30INIT
	//
	// dw1=dwLineID
	// dw2=usLineIDType
	// dw3=dwProfileID (but we enforce this to be 0).
	// dw4=ATOM(lpszSection) (but we enforce this to be 0).
	// dw5=uClass
	// NO! dw3=uClass
	// NO! dw4=MAKELONG(ATOM(lpszSpoolDir), ATOM(lpszID))
	//		  (deleted by caller on return)
	// NO!dw5=MAKELONG(ATOM(lpszDefRecipAddress),
	// 	        ATOM(lpszDefRecipName))   (deleted by caller on return)
	// dw6=uAutoAnswer
	// dw7=hwndListen
	//
	// dwRet=ret

// FileT30Listen
	// dwID=eID_FILET30LISTEN
	//
	// dw1=uLevel
	// dw2=hwndResult
	// dw3..7=0
	//
	// dwRet=ret

// FileT30Send
	// dwID=eID_FILET30SEND
	//
	// dw1=aPhone
	// dw2=aFileMG3
	// dw3=aFileIFX
	// dw4=aFileEFX
	// dw5=aFileDCX
	// dw6=hwndResult
	// dw7=0
	//
	// dwRet=0

// FileT30Answer
	// dwID=eID_FILET30ANSWER
	//
	// dw1=fAccept
	// dw2=fImmediate
	// dw3=hwndResult
	// dw4=hCALL (TAPI) -- must be zero for remote calls.
	// dw5..7=0
	//
	// dwRet=ret

// FileT30Abort
	// dwID=eID_FILET30ABORT
	//
	// dw1..7=0
	//
	// dwRet=0

// FileT30ReportRecv
	// dwID=eID_FILET30REPORTRECV
	//
	// dw1=fGetIt
	// dw2  (OUT) dwPollContext
	// dw3..7=0
	//
	// dwRet=ret

// FileT30AckRecv
	// dwID=eID_FILET30ACKRECV
	//
	// dw1=aRecv
	// dw2..7=0
	//
	// dwRet=ret

// FileT30Status
	// dwID=eID_FILET30STATUS
	//
	// dw1..7=0
	//
	// dwRet=ret

// FileT30SetStatusWindow
	// dwID=eID_FILET30SETSTATUSWINDOW
	//
	// dw1=hwndStatus
	// dw2..7=0
	//
	// dwRet=0

// FileT30ReadIniFile
	// dwID=eID_FILET30REREADINIFILE
	//
	// dw1..7=0
	//
	// dwRet=0

// FileT30DeInit
	// dwID=eID_FILET30DEINIT
	//
	// dw1=fForce
	// dw2..7=0
	//
	// dwRet=ret

// FileT30ModemClasses
	// dwID=eID_FILET30MODEMCLASSES
	//
	// dw1=dwLineID
	// dw2=dwLineIDType
	// dw3=dwProfileID
	// dw4=GlobalAddAtom(lpszKey) (deleted by caller on return).
	// dw5..7=0
	//
	// dwRet=ret

// FileT30ReportSend
	// dwID = eID_FILET30REPORTSEND
	//
	// dw1 = (DWORD) fGetIt
	// dw2 = (DWORD) dwSend (OUT) -- in milliseconds (not used, really).
	// dw3 = (DWORD) dwDur  (OUT) -- duration in milliseconds.
	// dw4 = (DWORD) dwFmt  (OUT) -- FORMATTYPE units (srvrdll.h).
	//
	// dwRet=ret

// FileT30PollReq
	// dwID = eID_FILET30POLLREQ
	//
	// dw1 = (DWORD) aPhone
	// dw2 = (DWORD) PollType
	// dw3 = (DWORD) aDocName
	// dw4 = (DWORD) aPassword
	// dw5 = (DWORD) dwPollContext
	// dw6 = (DWORD) hwndResult
	//
	// dwRet= 0

// This is the name of the semaphore which is used simply to
// Detect/register if/that the awfxex app has been loaded.
#define szAWFXEX_SEMAPHORE_NAME "awlfx.B1E90.SM"

#endif // LFT3LPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\inifile.h ===
#ifndef INIFILE_H
#define INIFILE_H

// Defines data so can be included only once in each DLL!!

char szIniFile[]		= szINIFILE;

char szDialtoneTimeout[]= szDIALTONETIMEOUT;
char szAnswerTimeout[]	= szANSWERTIMEOUT;
char szDialPauseTime[]	= szDIALPAUSETIME;
char szPulseDial[]		= szPULSEDIAL;
char szDialBlind[]		= szDIALBLIND;
char szSpeakerControl[]	= szSPEAKERCONTROL;
char szSpeakerVolume[]	= szSPEAKERVOLUME;
char szSpeakerRing[]	= szSPEAKERRING;
char szRingsBeforeAnswer[]	= szRINGSBEFOREANSWER;
char szHighestSendSpeed[]	= szHIGHESTSENDSPEED;
char szLowestSendSpeed[]	= szLOWESTSENDSPEED;
char szEnableV17Send[]		= szENABLEV17SEND;
char szEnableV17Recv[]		= szENABLEV17RECV;
char szDisableECM[]			= szDISABLEECM;
char sz64ByteECM[]			= sz64BYTEECM;
char szCopyQualityCheckLevel[]	= szCOPYQUALITYCHECKLEVEL;

#ifdef PCMODEMS
char szFixModemClass[] 		= szFIXMODEMCLASS;
char szFixSerialSpeed[]     = szFIXSERIALSPEED;
#endif //PCMODEMS


char szDefRecipName[]		= szDEFRECIPNAME;
char szDefRecipAddr[]		= szDEFRECIPADDR;
char szSpoolDir[]			= szSPOOLDIR;
char szLocalID[]			= szLOCALID;
char szOEMKey[]				= szOEMKEY;

#endif INIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\ifaxos.h ===
#ifndef _INC_IFAXOS
#define _INC_IFAXOS

#ifdef __cplusplus
extern "C" {
#endif

// add SHIP_BUILD from Win95fax retail builds
#ifndef DEBUG
#ifdef WIN32
#define SHIP_BUILD
#endif
#endif

// -------------------------- Include Files ------------------------------------

#ifdef IFBGPROC
// Remove appropriate parts of windows.h
// #define NOKERNEL
#ifndef WANTGDI
#define NOGDI
#endif
// #define  NOUSER
#define NOSOUND
// #define  NOCOMM
// #define  NODRIVERS
// #define  NOMINMAX
// #define  NOLOGERROR
// #define  NOPROFILER
// #define  NOMEMMGR
// #define  NOLFILEIO
// #define  NOOPENFILE
// #define  NORESOURCE
// #define  NOATOM
// #define  NOLANGUAGE
// #define  NOLSTRING
// #define  NODBCS
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#ifndef WANTGDI
#define NOGDIOBJ
#define NOBITMAP
#endif
#define NODRAWTEXT
#define NOTEXTMETRIC
#define NOSCALABLEFONT
#define NORASTEROPS
#define NOMETAFILE
#define NOSYSMETRICS
#define NOSYSTEMPARAMSINFO
// #define NOMSG
#define NOWINSTYLES
#define NOWINOFFSETS
// #define  NOSHOWWINDOW
#define NODEFERWINDOWPOS
#define NOVIRTUALKEYCODES
#define NOKEYSTATES
#define NOWH
#define NOMENUS
#define NOSCROLL
#define NOCLIPBOARD
#define NOICONS
#define NOMB
#define NOSYSCOMMANDS
#define NOMDI
#define NOCTLMGR
#define NOWINMESSAGES
#define NOHELP
#endif

// put strict type checking on ... and get rid of multiple define warnings
#ifndef STRICT
#define STRICT
#endif

#ifndef WINDRV
#   ifdef WIN32
#       define _INC_OLE
#   endif
#   include <windows.h>
#  ifdef   WIN32
#      include <windowsx.h>
#  endif
#endif

#ifdef WIN32
#define DECLSPEC_IMPORT __declspec(dllimport)
#endif

#ifndef WIN32
// Define WINBASE to avoid mapi including some duplicate definitions
#define _WINBASE_
#endif

//-------------------------- General Defines ---------------------

#ifndef WIN32
#define STATIC  static
#define CONST   const
#define CHAR    char
#define UCHAR   BYTE
#define INT     int

typedef short    SHORT;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef CHAR    *PCHAR;
typedef VOID    *PVOID;
#endif

typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;

#define CARRAIGE_RETURN 0x0D
#define LINEFEED 0x0A
#define BACKSPACE 0x08
#define CNULL   0x00

#ifndef WIN32
#ifndef MAKEWORD
#  define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif
#  define EXPORT_DLL
#  define IMPORT_DLL
#else
#  ifndef HTASK
#     define HTASK HANDLE
#  endif
#  define __export __declspec( dllexport )
#  define _export  __declspec( dllexport )
#  define IMPORT_DLL __declspec( dllimport )
#  define EXPORT_DLL __declspec( dllexport )
#endif

// --------------- RESOURCE management -------------------------------

// Always define this for now ...
#ifndef SHIP_BUILD
// #if defined(VALIDATE) || defined(DEBUGAPI) || defined(DEBUG)

/********
    @doc    EXTERNAL    RESOURCE IFAXOS

    @type   VOID |  RESOURCE_ALLOC_FLAGS | Lists the resource management options
            for OS resource accounting.

    @emem   RES_ALLOC_TASK  |  This flag indicates that the resource in question
            is being allocated on behalf of the current process. The resource
            should not be directly passed on to any other process context. It
            should be freed by this process before termination - else the kernel
            will free it when the process dies (if running in debug).
            Ownership automatically gets transferred between tasks when standard
            IPC methods like pipes are used to transfer resources like Buffers.

    @emem   RES_ALLOC_NONE  | This flag is used to allocate resources which should
            not be accounted to any system module. The calling party essentially
            undertakes full responsibility for freeing this object. This is mainly
            to be used for resource allocated on behalf of messages in the store
            since their ownership is transferred to the current process which has
            the message open.

    @emem   HINSTANCE_DLL   | If the allocated resource is to be assigned to the
            calling DLL, the hinstance of the DLL should be passed in as the value
            of the ResourceFlags Word. These resources will be freed (in the debug
            version) when the DLL terminates. They will not be assigned to any
            particular process context.

    @xref   <f IFBufAlloc> <f IFMemAlloc> <f CreateMutex> <f CreateEvent>
            <f IFPipeCreate> <f IFProcSetResFlags>
********/

#define RES_ALLOC_TASK  0x0000
#define RES_ALLOC_NONE  0x0001
#define RES_ALLOC_INTERNAL  0x0002
#define RES_ALLOC_CRITSEC  0x0003

#if defined(WFW) || defined(WIN32)

#define IFProcSetResFlags(wResFlags)  (0)

#else

extern EXPORT_DLL VOID WINAPI IFProcSetResFlags(WORD wResFlags);

#endif

#else

#define IFProcSetResFlags(p1) (0)

#endif

// --------------- ERROR Handling ------------------------------------

#include <errormod.h>

/********
    @doc    EXTERNAL    ERROR   IFAXOS

    @api    DWORD    | IFErrAssemble   | Forms an IFAX Error dword out of its components.

    @parm   BYTE    | bProcessID    | Identifies the process in whose context the error
            occured. Must be one of the predefined system process ID's - see <t SYSTEM_PROCESSES>
            for the list. This field does not need to be filled in until an error is
            propagated across a process boundary. If not being set to a valid PROCID, this
            should be initilialized to one of the following values:
            @flag  PROCID_WIN32 | if <p bModuleID> is set to MODID_WIN32.
            @flag  PROCID_NONE | for all other cases.

    @parm   BYTE    | bModuleID | Identifies the module reporting the error. MUST be
            one of the predefined system module ID's - see <t SYSTEM_MODULES> for the
            list.

    @parm   WORD    | wApiCode  | Identifies the API code for the error in the module indicated
            by <p bModuleID>. All Api codes should be defined in the file errormod.h. Api codes should
            be defined so that the low 6 bits are zero. This allows both the <p wApiCode> and the
            <p wErrorCode> to be logical OR'ed together and stored as a single word.

    @parm   WORD    | wErrorCode    | Identifies the error code. The format
            of this is module dependent. For uniformity however, it is highly
            encouraged that all IFAX modules use a standard format for this error word.
            This standard format reserves the first 6 bits for an error code,
            and the high 10 bits for an API identifier.

            If the IFAX format is being used, the <p wApiCode>
            parameter should be used to pass in the high 10 bits, and the <p wErrorCode> (This
            parameter!) should be used to pass in the 6 bit error code. Values upto ERR_FUNCTION_START
            are reserved for standard system errors - see <t SYSTEM_ERROR_VALUES> for the list.
            Error values should be positive and less than 64.

            Other modules like the filesystem conform completely to the Win32 Error space. These
            should set <p wErrorCode> to standard Win32 errors (use all 16 bits) and leave
            the <p wApiCode> as API_WIN32.

            Still others need to use all 16 bits in a custom manner - like the Printer Drivers.
            These *must* set the <p bModuleID> correctly so that the error can be interpreted
            appropriately. Standard processes like the UI have to understand these error codes,
            so only inbuilt system modules which they have knowledge about can use custom codes.
            These should set the wApiCode to API_NONE.

    @rdesc  Returns the DWORD representation for this error. This allows this to be directly
            passed in as input to <f SetLastError>.

    @ex     Example usage |

            SetLastError(IFErrAssemble(PROCID_NONE,MODID_IFKERNEL,API_IFK_POSTMESSAGE,ERR_INVALID_PARAM));

    @xref   <f IFErrGetModule> <f IFErrGetProcess> <f GetIFErrorErrcode> <f SetLastError>
            <f GetIFErrorApicode> <t SYSTEM_MODULES> <t SYSTEM_PROCESSES> <t SYSTEM_ERROR_VALUES>
            <f GetLastError> <f IFNVRamSetError> <f GetIFErrorCustomErrcode>
********/

#define IFErrAssemble(process,module,call,error) \
    MAKELONG((WORD)call|(WORD)error, MAKEWORD((BYTE)module, (BYTE)process))

/*********
    @doc    EXTERNAL ERROR  IFAXOS

    @api    BYTE    | IFErrGetModule  | Retrieves the module ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the module ID. This will be from the list specified in <t SYSTEM_MODULES>.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrSetModule>

    @api    BYTE    | IFErrGetProcess  | Retrieves the process ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the process ID. This will be from the list specified in <t SYSTEM_PROCESSES>.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrSetProcess>

    @api    WORD    | GetIFErrorErrcode  | Retrieves the error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. If less than ERR_FUNCTION_START, this is from the list
            in <t SYSTEM_ERROR_VALUES>.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorCustomErrcode  | Retrieves a custom 16 bit error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. This might be a Win32 error code if the module ID was
            MODID_WIN32, or a custom error code.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorApicode  | Retrieves the API code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the API code. API codes for all the system modules are documented in
            the file errormod.h

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES>

    @api    DWORD    | IFErrSetModule  | Sets the module ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. It's value is not changed by the call.

    @parm   BYTE    | bModule   | The module ID to be set from the list in <t SYSTEM_MODULES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrGetModule>

    @api    DWORD    | IFErrSetProcess  | Sets the Process ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. Its value is not changed by the call.

    @parm   BYTE    | bProcess   | The Process ID to be set from the list in <t SYSTEM_PROCESSES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrGetProcess>

********/
#define IFErrSetModule(errvar,module)  \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD((BYTE)module, HIBYTE(HIWORD((DWORD)errvar))))
#define IFErrSetProcess(errvar,process)    \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD(LOBYTE(HIWORD((DWORD)errvar)), (BYTE)process))
#define IFErrGetModule(errvar)    LOBYTE(HIWORD((DWORD)errvar))
#define IFErrGetProcess(errvar)   HIBYTE(HIWORD((DWORD)errvar))
#define GetIFErrorErrcode(errvar)   (LOWORD((DWORD)errvar) & 0x003F)
#define GetIFErrorApicode(errvar)   (LOWORD((DWORD)errvar) & 0xFFC0)
#define GetIFErrorCustomErrcode(errvar) LOWORD((DWORD)errvar)

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULES  | Identifiers for all the standard system modules.

    @emem   MODID_NONE          | Use this if you are not setting the module ID. DONT USE ZERO !!
    @emem   MODID_WIN32         | Set for modules returning standard Win32 system error codes
    @emem   MODID_BOSS          | ID = 1    Error in BOSS
    @emem   MODID_WINMODULE     | ID = 2    All windows modules including UER/GDI/KERNEL
    @emem   MODID_IFKERNEL      | ID = 3
    @emem   MODID_IFFILESYS     | ID = 4
    @emem   MODID_MSGSTORE      | ID = 5
    @emem   MODID_LINEARIZER    | ID = 6
    @emem   MODID_SECURITY      | ID = 7
    @emem   MODID_IFPRINT       | ID = 8    High level Printer Driver
    @emem   MODID_IFSCAN        | ID = 9    High level Scanner Driver
    @emem   MODID_IFSIPX        | ID = 10   SPX/IPX Stack
    @emem   MODID_REND_SERVER   | ID = 11   Rendering Server
    @emem   MODID_FORMAT_RES    | ID = 12   Format Resolution
    @emem   MODID_IFFILE        | ID = 13   IFFiles
    @emem   MODID_TEXTRENDERER  | ID = 14   Ascii Renderer
    @emem   MODID_DIGCOVPAGE    | ID = 15   Digital Coverpage
    @emem   MODID_AWBRANDER     | ID = 16   Fax Brander
    @emem   MODID_MSGSVR        | ID = 17   Message Server
    @emem   MODID_MSGHNDLR      | ID = 18  Per-Connection message handler
    @emem   MODID_MODEMDRV      | ID = 19  Modem driver
    @emem   MODID_PSIFAX       | ID = 20   PSI Fax protocol
    @emem   MODID_AWT30            | ID = 21
    @emem   MODID_PSIFAXBG     | ID = 22
    @emem   MODID_AWNSF            | ID = 23
    @emem   MODID_FAXCODEC      | ID = 24
    @emem   MODID_MSGPUMP       | ID = 25
    @emem   MODID_AWREPORT      | ID = 26
    @emem   MODID_MSGSVRD               | ID = 27


    @emem   MODID_CUSTOM        | ID = 160  Beyond this are custom/installable modules

    @xref   <f IFErrAssemble> <f IFErrGetModule>
********/
// System Module IDs
#define MODID_WIN32         0
#define MODID_BOSS          1
#define MODID_WINMODULE     2
#define MODID_IFKERNEL      3
#define MODID_IFFILESYS     4
#define MODID_MSGSTORE      5
#define MODID_LINEARIZER    6
#define MODID_SECURITY      7
#define MODID_IFPRINT       8
#define MODID_IFSCAN        9
#define MODID_IFSIPX        10
#define MODID_REND_SERVER   11
#define MODID_FORMAT_RES    12
#define MODID_IFFILE        13
#define MODID_TEXTRENDERER  14
#define MODID_DIGCOVPAGE    15
#define MODID_AWBRANDER     16
#define MODID_MSGSVR        17
#define MODID_MSGHNDLR      18
#define MODID_MODEMDRV     19
#define MODID_PSIFAX       20
#define MODID_AWT30            21
#define MODID_PSIFAXBG     22
#define MODID_AWNSF            23
#define MODID_FAXCODEC      24
#define MODID_MSGPUMP       25
#define MODID_AWREPORT      26
#define MODID_MSGSVRD           27

#define MAXMODID              26

#define MODID_NONE          159

// Special module ID's
#define MODID_CUSTOM        160

// Strings used in debug version for friendly display
#define SYSMODULESTRINGS   \
    { "Win32", "Boss", "Windows", "IFKernel", "FileSystem", "Msg Store", "Linearizer",    \
      "Security", "HLPrintDriver", "HLScanDriver", "IPX/SPX", "RendServer", \
      "Format Res", "IFFile", "AsciiRenderer","DigCovPage","AWBrander", \
      "Msg Server", "Msg Handler", "Modem Driver", "PSIFAX", "AWT30",  \
     "PSIFAXBG", "AWNSF", "Fax Codec", "Msg Pump" , "Awreport" \
    }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_PROCESSES  | Identifiers for all the standard system processes.

    @emem   PROCID_WIN32        | Used to initialize for Win32 modules.
    @emem   PROCID_NONE         | Used when process context does not need to be set.
    @emem   PROCID_MSGSCHED     | ID = 0x21
    @emem   PROCID_JOBPROCESS   | ID = 0x22
    @emem   PROCID_UI           | ID = 0x23
    @emem   PROCID_PRINTER      | ID = 0x24
    @emem   PROCID_SCANNER      | ID = 0x25
    @emem   PROCID_MSGSVR       | ID = 0x26
    @emem   PROCID_GRRENDER     | ID = 0x27
    @emem   PROCID_MSGHNDLR     | ID = 0x28
    @emem   PROCID_PARADEV              | ID = 0x29
    @emem   PROCID_UIBGPROC     | ID = 0x30

    @comm   All Process ID's need to have the 6th bit set to be compatible with the
            standard Win32 error definitions.

    @xref   <f IFErrAssemble> <f IFErrGetProcess>
********/
// System Process IDs
#define PROCID_WIN32           0x00
#define PROCID_NONE            0x20
#define PROCID_MSGSCHED        0x21
#define PROCID_JOBPROCESS      0x22
#define PROCID_UI              0x23
#define PROCID_PRINTER         0x24
#define PROCID_SCANNER         0x25
#define PROCID_MSGSVR          0x26
#define PROCID_GRRENDER        0x27
#define PROCID_MSGHNDLR        0x28
#define PROCID_PARADEV         0x29
#define PROCID_UIBGPROC            0x30

// Strings used in debug version for friendly display
#define MAXPROCID  11
#define SYSPROCESSSTRINGS       \
    {"None", "Msg Scheduler", "Job Process", "UI Process", "Printer", "Scanner", \
     "Msg Transport", "GR Renderer", "Msg Handler", "Para Dev", "UIBGProc"  }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

   @type   VOID | SYSTEM_ERROR_VALUES | This defines all the standard
           system error values.

   @emem   ERR_NOT_ENOUGH_MEM | Value = 0x0001 : Indicates an out of memory
           condition.

   @emem   ERR_INVALID_PARAM | Value = 0x0002 : Indicates that any one of
           the parameters passed to the function was invalid.

   @emem   ERR_FUNCTION_START | Value = 0x0010 : Any error value above this
           had been custom defined by the called function. If you need
           a custom error value, you can define it starting from this
           value.

   @xref   <f IFErrAssemble>
********/

// System Error values
#define ERR_NOT_ENOUGH_MEM  0x0001
#define ERR_INVALID_PARAM   0x0002
#define ERR_FUNCTION_START  0x0010

// Strings used in debug version for friendly display
#define SYSERRORSTRINGS \
    {"None", "Out Of Memory", "Invalid Param", "Unused", "Unused", "Unused",  \
    "Unused", "Unused", "Unused", "Unused", "Unused", "Unused", \
    "Unused", "Unused", "Unused", "Unused" }

// Functions

#if !defined(SHIP_BUILD) && !defined(WIN32)
VOID WINAPI RestoreLastError (DWORD dwErrVal);
#else
#define RestoreLastError(dw) SetLastError(dw)
#endif

#ifndef WIN32
VOID WINAPI SetLastError (DWORD dwErrVal);
DWORD WINAPI GetLastError (VOID);
#endif


//----------------------------- MESSAGING -------------------------

// Message type definitions  - below 0x0400 is reserved by windows,
// between 0x0400 and 0x0800 is reserved by the IFAX OS

#define IF_START        WM_USER+0x0300

#define IF_TASK_START   IF_START+0x0001
#define IF_TASK_END     IF_START+0x0020
#define IF_DEBUG_START  IF_START+0x0021
#define IF_DEBUG_END    IF_START+0x0040
#define IF_PIPES_START  IF_START+0x0041
#define IF_PIPES_END    IF_START+0x0060
#define IF_TIMER_START  IF_START+0x0081
#define IF_TIMER_END    IF_START+0x0090
#define IF_USER         IF_START+0x0400
//messages for printer and scanner
#define IF_SCANNER_START IF_START+0x0200
#define IF_SCANNER_END   IF_START+0x0220
//messages for the graphics renderer
#define    IF_GRRENDER_START   IF_START+0x0221
#define    IF_GRRENDER_END     IF_START+0x0230
//messages for the faxcodec renderer
#define    IF_FAXREND_START    IF_START+0x0231
#define    IF_FAXREND_END      IF_START+0x0235
//messages for the message pump
#define IF_MSGPUMP_START (IF_START+0x0250)
#define IF_MSGPUMP_END   (IF_START+0x029F)
//messages for devices
#define IF_DEVICE_START (IF_START+0x02B0)
#define IF_DEVICE_END   (IF_START+0x02CF)
// Message for UI Init
#define IF_UI_START        (IF_START+0x2F0)
#define IF_UI_END      (IF_START+0x300)
// Status
#define IF_STATUS_START    (IF_START+0x301)
#define IF_STATUS_END   (IF_START+0x310)
// Config
#define IF_CONFIG_START    (IF_START+0x311)
#define IF_CONFIG_END   (IF_START+0x320)
// Modem
#define IF_MODEM_START (IF_START+0x321)
#define IF_MODEM_END   (IF_START+0x325)
// PSIBG
#define IF_PSIBG_START (IF_START+0x330)
#define IF_PSIBG_END   (IF_START+0x339)
// PSIFAX
#define IF_PSIFAX_START    (IF_START+0x340)
#define IF_PSIFAX_END      (IF_START+0x349)
// MSGSVR
#define IF_MSGSVR_START  (IF_START+0x350)
#define IF_MSGSVR_END    (IF_START+0x369)
// OEM
#define IF_OEM_START    (IF_START+0x370)
#define IF_OEM_END      (IF_START+0x379)
// SOS
#define IF_SOS_START    (IF_START+0x380)
#define IF_SOS_END      (IF_START+0x38F)
// uiutil
#define IF_UU_START     (IF_START+0x390)
#define IF_UU_END       (IF_START+0x39F)
// parallel device
#define IF_PD_START     (IF_START+0x3A0)
#define IF_PD_END       (IF_START+0x3BF)
// RPC layer
#define IF_RPC_START     (IF_START+0x3C0)
#define IF_RPC_END       (IF_START+0x3CF)
//UIBGProc
#define IF_UIBGPROC_START (IF_START+0x3D0)
#define IF_UIBGPROC_END   (IF_START+0x3DF)
// services
#define IF_SERVICE_START  (IF_START+0x3E0)
#define IF_SERVICE_END    (IF_START+0x3EF)


/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_INIT_STATUS |   This message should be posted by all devices
           after initialization is complete to indicate success/failure.
           Typically, the device process will send an IF_INIT_STATUS
          message for every device it initializes and one for its own
          initilization. This message should be posted to the UISHELL
          process. Use <f IFProcGetInfo> to obtain the appropriate window handle.

   @parm   WPARAM  | wParam    | 16 bit device error.
   @parm   LPARAM  | lParam    | Is formed as MAKELPARAM(MAKEWORD
       (ucInitStatus,ucMinorDevId),MAKEWORD(ucMajorDevId,ucProcId))
   @flag   INIT_NO_ERROR   |   There was no error.
   @flag   INIT_FATAL_ERROR|   There was a fatal error. System should reboot.
   @flag   INIT_WARNING_ERROR  | There were some errors, but the system doesnt need
           to reboot.

   @parm   LPARAM  | lParam    | Contains a standard IFAX Error code. See
           <f IFErrAssemble> for details.

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/
#define INIT_NO_ERROR      0x00
#define INIT_FATAL_ERROR   0x01
#define INIT_WARNING_ERROR 0x02

#define IF_INIT_STATUS     IF_UI_START
/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS
   @msg    IF_DEVREINIT |   This message will be posted by the uishell to
           device process that handle user errors if the initialization
           fails due to user errors.

   @parm   WPARAM  | wParam    | MAKEWORD(ucMinorDevId,ucMajorDevId)

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/

#define    IF_DEVREINIT    IF_UI_START+1

// Functions --------
BOOL WINAPI BroadcastMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI BroadcastMessageEx (UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dispatch message for BG Procs
/********
   @doc    EXTERNAL    MESSAGE     MACROS  IFAXOS

   @api    VOID    |   DispatchMessage | Dispatches a message to your
           windows procedure.

   @parm   LPMSG   | lpMsg |   Ptr to a message struct which is to be
           dispatched. This parameter *must* be &msg for all IFAX
           background processes - i.e you must have a declared variable
           called "msg" into which you have previsouly retrieved the
           message using <f GetMessage>.

   @comm   This function dispatches a message to your windows procedure.
           For foreground processes this works exactly the way the standard
           Windows DispatchMessage works. For background processes
           (which dont have any explicit windows) the message is sent to
           a procedure called BGWindowProc. You *must* have a callback
           defined as this - see BGWindowProc for details.

   @cb     LRESULT  BGCALLBACK |   BGWindowProc    | This is the window procedure
           for all IFAX background processes. The functions *must* be called
           by this exact name. This callback is not relevant for foreground
           processes.

   @parm   HWND    | hwnd  | contains the handle of the window to which the
           message is being dispatched. For Background processes this will always
           be the same as that returned from <f IFProcGetInfo>.

   @parm   UINT    | message | the message id

   @parm   WPARAM  | wParam | the first parameter associated with the message

   @parm   LPARAM  | lParam    | The second parameter associated with the message

   @rdesc  The return value depends on the message being processed.

   @comm   A protoype for this is already declared in ifaxos.h. You should
           process all your messages inside this window procedure. Your
           main application loop should thus look like

           while (GetMessage(&msg,NULL,0,0))
           {
               DispatchMessage(&msg);
           }
           return;

           You should *not* export this procedure in your .def file.

   @xref   <f GetMessage>
********/

#ifdef IFBGPROC
#define DispatchMessage(pmsg)   BGWindowProc((pmsg)->hwnd,(pmsg)->message,(pmsg)->wParam,(pmsg)->lParam)
#define BGCALLBACK PASCAL
LRESULT BGCALLBACK BGWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

//----------------------------- TASK MANAGEMENT--------------------
/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   ENTER_INT_CRIT_SECTION  | Macro to enter
           an interrupt critical section.

   @comm   This is an inline assembly macro which turns interrupts
           off. Needless to say, this must be used with extreme
           caution. There must be a matching call to
           <f EXIT_INT_CRIT_SECTION>. Nested pairs of calls
           to these are permitted as long as they are not within the
          same invocation of the function. The function relies on
          being able to save the previous state of the flags in a
          unique local variable called __wIntFlags.
           This might affect some optimization options in your
           function due to being inline assembly. You might want to
           declare a local function which calls this macro internally.
           This way you can get global optimzations in the calling
           functions.

   @xref   <f EXIT_INT_CRIT_SECTION>  <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/


// Macros --------
#define ENTER_INT_CRIT_SECTION  \
   {   \
   _asm pushf  \
   _asm cli    \
   _asm pop __wIntFlags    \
   }

/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   EXIT_INT_CRIT_SECTION   | Macro to exit
           an interrupt critical section.

   @comm   This is an inline assembly macro which sets the interrupt
           flag state back to its state before the last call to
           <f ENTER_INT_CRIT_SECTION>. This function relies    on the
          appropriate flags to have been saved in a local variable
          with the name __wIntFlags.

   @xref   <f ENTER_INT_CRIT_SECTION> <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/

// defined this way so that it works with windows enhanced mode
// refer guide to programming pg 14-15
#define EXIT_INT_CRIT_SECTION   \
   {   \
   _asm mov ax, __wIntFlags    \
   _asm test ah,2      \
   _asm jz $+3     \
   _asm sti            \
   _asm NOP            \
   }

/********
    @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | PRIORITY DEFINES  | System defined priority levels
    @emem   PROC_PRIORITY_CRITICALRT | This should be used very sparingly
            for tasks which have very critical real time constraints (less
            than 200ms). These processes should typically be very low bandwidth
            since they can easily starve other processes.
    @emem   PROC_PRIORITY_HIGHRT | Tasks with latency requirements of less than
            a second. Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_MEDRT | Tasks with latency requirements of 1-3 secs.
            Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_LOWRT | Tasks with latencies of 3-30secs. Should not
            be high bandwidth.
    @emem   PROC_PRIORITY_DEFAULT | The default priority tasks start out at. These
            processes have none or very low real time requirements. They should
            in general not have high bandwidth.
    @emem   PROC_PRIORITY_NONRT_USERVISIBLE | Non real time tasks which have visibility
            at the user level. Can be high bandwidth. An example on a fax machine is
            a copy job.
    @emem   PROC_PRIORITY_NONRT_USERHIDDEN | Non real time tasks which have very little
            visibility at the user level. Examples on a fax machine are local jobs
            not involving devices. Can be high bandwidth.
    @comm   Processes should be VERY careful in setting their priorities. The way the
            current scheduling works it is very easy to cause starvation of low
            priority processes. In particular, processes which are "high bandwidth" - ie
            those which can consume huge amounts of CPU time if given, should be very
            careful - and should in general be at a priority level lower than the default.
            Processes higher than the default should have some sontrols on how much cpu
            time they can use up. On the fax machine, such controls are mostly in the form
            of device througputs - like the phone line.
    @xref   <f IFProcSetPriority> <f IFProcGetPriority>
********/
#define PROC_PRIORITY_MIN               31
#define PROC_PRIORITY_MAX               1
#define PROC_PRIORITY_CRITICALRT        3
#define PROC_PRIORITY_HIGHRT            6
#define PROC_PRIORITY_MEDRT             9
#define PROC_PRIORITY_LOWRT             12
#define PROC_PRIORITY_DEFAULT           15
#define PROC_PRIORITY_NONRT_USERVISIBLE   18
#define PROC_PRIORITY_NONRT_USERHIDDEN    21

#define UAE_BOX                 0
#define NO_UAE_BOX              1

///// Specific priorities used by standard processes       ////
//
// We want the following relations to hold
//      PSIFAXBG > everything else, cause it's low-latency, low-bandwidth
//      ModemJob related (med bandwidth) > all other high/med bandwith jobs
//  DeviceJob related (high bandwidth, NO latency reqs) < all other jobs except Spool jobs
//  SpoolJobs (high bandwidth NO latency reqs, not user-visible) < everything
//  MSCHED is as high as ModemJob prio when it is on critical path, otherwise
//              it stays at default. Higher than Dev & Spool jobs, lower than all else
//  COMMSRV (pretty low latency reqs, high bandwidth) is slightly higher than
//              default (Higher than MSCHED & Dev/Spool jobs, lower than modem jobs)
//  RPCHNDLR (pretty lax latency reqs, high bandwidth) dynamic
//              Same prio as MSCHED while working, same as COMMSRV during accept
//  MSGSVR & RPCSRV (lowish latency reqs, very low bandwidth) roundrobin
//              with ModemJob, higher than all else
//  REPORT bg proc slightly lower than default.

// PSIFAXBG prio is highest
#define PRIO_PSIFAXBG_ACTIVE    PROC_PRIORITY_CRITICALRT
#define PRIO_PSIFAXBG_IDLE      PROC_PRIORITY_DEFAULT
// ModemJob is 2nd highest
#define PRIO_MODEMJOB           PROC_PRIORITY_MEDRT
// Spooljob is LOWEST, Device jobs are second lowest
#define PRIO_SPOOLJOB           PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_DEVICEJOB          PROC_PRIORITY_NONRT_USERVISIBLE
// PSINET jobs are same prio as SPOOL jobs
#define PRIO_PSINETJOB          PRIO_SPOOLJOB
// MSCHED's prio when it is NOT on a MODEMJOB critical path
#define PRIO_MSCHED             PROC_PRIORITY_DEFAULT
// COMMSRV is between MODEMJOB & MSCHED
#define PRIO_COMMSRV            PROC_PRIORITY_LOWRT
// RPCHNDLR is same as MSCHED while working
#define PRIO_RPCHNDLR_ACCEPT    PROC_PRIORITY_LOWRT
#define PRIO_RPCHNDLR_WORKING   PROC_PRIORITY_DEFAULT
// RPCSRV is same as MODEMJOB. It should NOT consume much CPU at this level!
#define PRIO_RPCSRV             PROC_PRIORITY_MEDRT
// MSGSVR is same as MODEMJOB, except when processing recovery msgs
#define PRIO_MSGSVR_WAITMSG     PROC_PRIORITY_MEDRT
#define PRIO_MSGSVR_RECOVERY    PROC_PRIORITY_NONRT_USERVISIBLE
// Report process is real low prio when doing background info assimilation
// slightly higher when doing work on user request.
#define PRIO_UIBGPROC                   PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_UIBGPROC_USERREQUEST PROC_PRIORITY_NONRT_USERVISIBLE

/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_QUIT |   This is the message which forces <f GetMessage>
           to return FALSE causing the process to exit its main message
           processing loop and terminate. Typically a process should
           post itself this message in response to a <m IF_EXIT> message.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_EXIT>

   @msg    IF_EXIT | This message is sent to a process to request it
           to terminate. An application should clean up any resources
           it has allocated and then post itself a <m IF_QUIT> message
           directly.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_QUIT>
********/

// Messages
#define IF_QUIT     IF_TASK_START
#define IF_EXIT     IF_TASK_START+1

// Functions -----------
#ifndef WIN32
HTASK   WINAPI GetWindowTask(HWND hwnd);
#ifndef SHIP_BUILD
DWORD   WINAPI IFProcProfile(HTASK hTask, BOOL fStart);
#else
#define IFProcProfile(HTASK,FSTART) (0)
#endif
#else
// Remove calls to Profile ..
#define IFProcProfile(x,y)    (DWORD)(0)
#endif

HTASK WINAPI IFProcCreate (LPSTR lpszAppName, UINT fuCmdShow);
VOID WINAPI IFProcTerminate (HTASK hTask, WORD wFlags);
VOID WINAPI IFProcEnterCritSec(VOID);
VOID WINAPI IFProcExitCritSec(VOID);
BOOL WINAPI IFProcChangeToFG(VOID);
BOOL WINAPI IFProcChangeToBG(VOID);
HWND    WINAPI IFProcGetInfo (HTASK FAR *lphTask, LPSTR lpszModule, HINSTANCE FAR *lphInst);
BOOL    WINAPI IFProcRegisterWindow (HWND hwnd);
WORD    WINAPI IFProcGetPriority (HTASK hTask);
BOOL    WINAPI IFProcSetPriority (HTASK hTask, WORD wPriority);

#ifndef NOBUFFERS
//----------------------------- BUFFERS -------------------------

// Moved BUFFER typedef and standard meta-data values to buffers.h! -RajeevD
#include <buffers.h>

#ifdef VALIDATE
#define BUF_SENTINELPOS 30
#endif

// Error values
#define ERR_DATA_SMALL      ERR_FUNCTION_START

// Functions
extern LPBUFFER  IFBufAlloc (LONG lBufSize);
extern BOOL      IFBufFree (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufMakeWritable (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufShare (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufSplit (LPBUFFER lpbf, LPBYTE lpb);


//----------------------------- PIPES ----------------------------

#ifndef WIN32

// types
typedef  struct _PIPE NEAR *HPIPE;

// Parameter
#define IFPIPE_READ_MODE    0x0001
#define IFPIPE_WRITE_MODE   0x0002
#define REQREAD_REMOVE_DATA 0x0003
#define REQREAD_NOREMOVE_DATA   0x0004

// Error values
#define ERR_TOO_MANY_OPENS          ERR_FUNCTION_START
#define ERR_TOO_MANY_PENDING_WRITES ERR_FUNCTION_START+1
#define ERR_PIPE_STILL_OPEN         ERR_FUNCTION_START+2

/********
   @doc    EXTERNAL    MESSAGES    IFPIPES IFAXOS

   @msg    IF_PIPE_DATA_WRITTEN | This message is sent to notify a process
           that a previous write request using <f IFPipeReqWrite> has
           been successfully concluded. On reciept of this message the
           process can issue another write request on the same pipe.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <f IFPipeReqWrite>

   @msg    IF_PIPE_DATA_ARRIVED | This message is sent to a process which
           previsouly issued a read request to a pipe, intimating it that
           the buffer it requested is now available.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | Contains a far ptr to a <t BUFFER> structure
           which has the requested data. On receipt of this message the process
           can issue another read request on the same pipe.

   @rdesc  none

   @xref   <f IFPipeReqRead>
********/

// Messages
#define IF_PIPE_DATA_WRITTEN    IF_PIPES_START
#define IF_PIPE_DATA_ARRIVED    IF_PIPES_START+1

// Functions
HPIPE WINAPI IFPipeCreate (WORD wSize);
BOOL WINAPI IFPipeDelete (HPIPE hpipe);
BOOL WINAPI IFPipeOpen (HPIPE hPipe, HWND hwnd, WORD wMode, WPARAM wContext);
BOOL WINAPI IFPipeClose (HPIPE hPipe, WORD wMode);
BOOL WINAPI IFPipeReqRead (HPIPE hPipe, WORD fwRemove);
BOOL WINAPI IFPipeReqWrite (HPIPE hPipe, LPBUFFER lpbf);
BOOL WINAPI IFPipeGetInfo (HPIPE hPipe, LPWORD lpwSize, LPWORD lpwcBufs);

#else // !WIN32

DECLARE_HANDLE32(HPIPE);

#endif // !WIN32

#endif // NOBUFFERS

//----------------------------- DEBUG SERVICES -------------------------

// Debug typedefs. These dont do any harm to anyone. Define them if there is
// anyone who might need them.

#if defined(DEBUG) || defined(IFKINTERNAL)

/********
   @doc    EXTERNAL    DATATYPES   DEBUG   IFAXOS

   @types  DBGPARAM    |   Structure containing the debug
           settings for any module in the system.

   @field  CHAR[32]    |   lpszName    | Specifies the name of the module.
           This is how your module will appear in the IFAX controller. Must
           be less than 32 characters long, and NULL terminated.

   @field  HWND    |   hwnd    | Specifies the primary window handle associated with
           this module IF the module is a process. For DLL's this value should
           always be NULL. Background processes should set it to their own ID using
           <f IFProcGetInfo> and <f GetCurrentTask> at initialization time.
           Foreground processes should set it to the window handle of their client
           window.

   @field  CHAR[16][32]    | rglpszZones   |   Stores a list of 16 strings
           which describe the zones associated with the lower 16 bits of
           zone mask. The module must decide and define its own zones for these
           bits - any bits not used should be left as "Not Used". These strings
           will be displayed by the IFAX controller to assist users in choosing
           the zones to be set for your module. Each string should not be more
           than 32 characters long, and should be NULL terminated.

   @field  ULONG   |   ulZoneMask  |   This is the mask which stores the
           current zone settings for the module. The IFAX controller will
           set this field according to what the user specifies. This field
           should be initialized to something which makes sense for your module
           - as that will be the default till the user changes it.

   @comm   This structure should be passed to <f IFDbgSetParams> at
           intialization time to enable the user to control the trace options.

           **VERY IMPORTANT NOTE** This structure MUST be declared with a
           variable  name of dpCurSettings to allow the system zones to
           function correctly.

   @tagname _DBGPARAM

   @xref   <f IFDbgSetParams>

********/

typedef struct _DBGPARAM {
   CHAR    lpszName[32];           // name of module
   HWND    hwnd;                   // Primary window Handle if task, NULL otherwise
   CHAR    rglpszZones[16][32];    // names of zones for first 16 bits
   ULONG   ulZoneMask;             // Zone Mask
}   DBGPARAM, FAR *LPDBGPARAM;

// Debug functions
BOOL WINAPI IFDbgOut (LPSTR lpszStatus);
WORD WINAPI IFDbgIn (LPSTR lpszPrompt, LPSTR lpszReply, WORD wBufSize);
extern EXPORT_DLL VOID WINAPI IFDbgSetParams (LPDBGPARAM lpdpParam, BOOL fEntry);
extern VOID FAR  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

// Encourage people to use the correct variable
extern DBGPARAM dpCurSettings;


// Special UI communication stuff

// Functions
DWORD WINAPI DebugUIMessage (UINT wMsg, WPARAM wParam, DWORD lParam);

// Messages to the UI proc
#define IF_DISP_STRING  IF_DEBUG_START
#define IF_INP_REQUEST  IF_DEBUG_START+1
#define IF_NEW_SETTING  IF_DEBUG_START+2
#define IF_DEL_SETTING  IF_DEBUG_START+3
#define IF_NEW_TASK     IF_DEBUG_START+4
#define IF_DEL_TASK     IF_DEBUG_START+5
#define IF_FILELOG_POLL IF_DEBUG_START+6

// Messages from the UI proc
#define REGISTER_UI_TASK    1
#define SET_LOG_MODE       2
#define DEBUG_OUT_DONE      3
#define DEBUG_IN_DONE       4
#define DEREGISTER_UI_TASK  5


#endif

// Debug Macros. These should be defined only if the module is being compiled
// in debug

#ifdef DEBUG

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGMSG    |   Prints a trace message on the debug
           console depending on enable flags set by the user.

   @parm   <lt>c_expression<gt>    |   cond    |   Boolean condition which is
           evaluated to decide whether or not to print the message.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @rdesc  TRUE if the message is printed, and FALSE if it is not.

   @comm   The condition should consist of a boolean expression testing whether
           the relevant zones are on or off.  Each module has a current zone
           mask which identifies which of the possible 32 zones is currently on.
           The top 16 bits of these are reserved for use for system defined
           zones - like ZONE_FUNC_ENTRY which is defined as

           #define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)

            Modules should take care to see
           that they print out trace messages which are meaningful and conform
           to some pattern - remember that other people than you have to see
           and make sense of your messages. The general format I have been
           following is :

           <lt>Task ID<gt> :
           <lt>ModuleName<gt>:<lt>SubModule<gt>:<lt>Function<gt>:<lt>msg<gt>

           The task ID is useful to sort out the output of multiple tasks
           running in the system.  The example call above yields this kind of
           output.

           The various predefined system zones are:
               ZONE_FUNC_ENTRY : To be used for all function entry and exit
                   messages. By convention, the parameters should be printed
                   on entry, and the return value should be printed on exit.
                   Any values printed in hexadecimal should be preceded by a 0x
               ZONE_INT_FUNC : To be used for any other traces at interesting
                   points within a function.

           All trace messages are disabled in a non debug build.

   @ex     Example Definition & Use |

           #define ZONE_CUSTOM (0x00000001&dpCurSettings.ulZoneMask)

           DEBUGMSG (ZONE_FUNC_ENTRY && ZONE_CUSTOM,
                       ("0x%04X:IFK:Buffers:GenericFunction:Entry\r\n",
                       GetCurrentTask()));

           This will print a trace message only if the user has turned the
           function entry zone and the custom zone on.

   @xref   <f IFDbgPrintf>
********/

#if 0
#define DEBUGMSG(cond,printf_exp)   \
   ((cond)?(IFDbgPrintf printf_exp),1:0)
#endif


#define DEBUGMSG(cond, printf_exp)   \
   (IFDbgPrintf printf_exp)



// Standard Debug zones
#define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)
#define ZONE_INT_FUNC   (0x00020000&dpCurSettings.ulZoneMask)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   ERRORMSG    |   Prints an error message on the debug
           console.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display Error messages.

   @ex     Example Definition & Use |

           ERRORMSG (("0x%04X:JOB Failed !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           ERROR: Job Process: 0x2346: JOB Failed !!

   @xref   <f IFDbgPrintf>
********/
#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define ERRORMSG(printf_exp)   \
   (IFDbgPrintf("ERROR:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   RETAILMSG    |   Prints a message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           RETAILMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf>
********/
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   WARNINGMSG    |   Prints a warning message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           WARNINGMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           WARNING: 0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf> <f ERRORMSG>
********/
#ifndef WIN32
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define WARNINGMSG(printf_exp)   \
   (IFDbgPrintf("WARNING:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif


/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGCHK    |   Macro implementing an assert.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be checked.

   @rdesc  Returns TRUE if the expression was non zero, and FALSE if not.

   @comm   This is a macro which implements functionality similar to the assert
           statement in C.  The expression argument is evaluated, and no action
           is taken if it evaluates to true. If false, a debug message is
           printed out  giving the  File name and line number where the check
           failed, along with the module name which was registered
           in the <t DBGPARAM> structure. Because of this, you *must* register
           your debug settings using <f IFDbgSetParams> before you can use the
           DEBUGCHK macro.  After this the function <f IFDbgCheck> is called
           to generate an assert.

           This statement disappears when the DEBUG option is turned off.

    @xref   <f IFDbgCheck>
********/

#define BG_CHK(exp)    \
   ((exp)?1:(              \
       IFDbgPrintf ("DEBUGCHK failed in file %s at line %d \r\n",  \
                 (LPSTR) __FILE__ , __LINE__ ), 1  \
            ))

#ifndef DEBUGCHK_UNSAFE_IN_WFWBG


#define DBGCHK(module,exp) \
   ((exp)?1:(          \
       IFDbgPrintf ("%s: DEBUGCHK failed in file %s at line %d \r\n", \
                 (LPSTR) module, (LPSTR) __FILE__ , __LINE__ ),    \
       IFDbgCheck() \
            ))

#define DEBUGCHK(exp) DBGCHK(dpCurSettings.lpszName, exp)

#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGSTMT   |   Evaluates the expression in debug mode.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be evaluated.

   @rdesc  Returns the value returned by the expression.

   @comm   This macro is provided for convenience and code readability purposes
           to replace a construct of the form

               #ifdef DEBUG
               exp;
               #endif

           It evaluates to zero in a non debug build.

********/

#define DEBUGSTMT(exp) exp

#else // NOT DEBUG

// Let debugmsg's through currently
#ifndef SHIP_BUILD
//#ifndef FOOBAR

// Non DEBUG MODE
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)
#else  //Win32 -- NO MESSAGES OF ANY SORT IN NON-DEBUG WIN32

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif


#else

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif

// These are to macro out all debug stuff in retail/ship builds
#define DEBUGMSG(cond,expr)  (0)
#define DBGCHK(module,exp) (0)
#define DEBUGCHK(exp) (0)
#define BG_CHK(exp) (0)
#define DEBUGSTMT(exp) (0)

// Macros for direct function calls made ..
#ifndef IFKINTERNAL
#define IFDbgOut(lpszStatus) (0)
#define IFDbgIn(lpszPrompt,lpszReply,wBufSize) (0)
#define IFDbgSetParams(lpdpParam,fEntry) (0)
#define DebugUIMessage(wMsg,wParam,lParam) (0)
#endif

#endif

/********
   @doc    EXTERNAL    IFAXOS    MACROS

   @api    BOOL    |   UIEVENT |   Prints a status string in the UI

   @parm   LPSTR | string |  String to be printed.

   @comm   This macro is provided in both the retail & debug builds to
            allow some limited set of status strings to be printed in
            the UI. You must format a string yourself - you can
            use wsprintf() to create a complex one if desired. The
            maximum string length allowed is 64 bytes.
********/
#define IF_SYS_EVENT     IF_UI_START+1
// UI Event messages
#define UIEVENT(string)   \
{       \
    CHAR    szUIShell[] = "UISHELL";  \
    DEBUGCHK(lstrlen(string) < 64); \
    PostMessage (IFProcGetInfo(NULL, szUIShell, NULL), IF_SYS_EVENT,   \
                 NULL, MAKELPARAM(GlobalAddAtom(string),0));    \
}

// --------------- Synchronization services --------------------------------------
// Dont provide any for win32.
#ifndef WIN32

typedef  struct _SYNC NEAR *HSYNC;

// Error returns
#define ERR_MUTEX_NOT_FREE  ERR_FUNCTION_START
#define ERR_EVENT_NOT_FREE  ERR_FUNCTION_START+1
#define ERR_TOO_MANY_EVENTWAITS ERR_FUNCTION_START+2

// generic functions
DWORD WINAPI WaitForSingleObject (HSYNC hsc, DWORD dwTime);

// Mutex functions
HSYNC WINAPI CreateMutex (LPVOID lpvAttribs, BOOL fInitial,LPSTR lpszName);
BOOL WINAPI ReleaseMutex (HSYNC hsc);

// Event Functions
HSYNC   WINAPI  CreateEvent (LPVOID lpvAttribs, BOOL bManualReset,
                            BOOL bInitialState, LPSTR lpszName);

BOOL    WINAPI  SetEvent (HSYNC hsc);
BOOL    WINAPI  ResetEvent (HSYNC hsc);
BOOL WINAPI FreeSyncObject (HSYNC hsc);
BOOL WINAPI  GetSetEventParam (HSYNC hsc, BOOL fSetParam, LPDWORD lpdwParam);

#else // !WIN32

DECLARE_HANDLE32(HSYNC);

#endif // !WIN32

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULE_NAMES  | Strings to be passed to IFProcGetInfo to get handles to standard IFAX modules

    @emem   MODNAME_UISHELL  | UI Shell
    @emem   MODNAME_MSCHED   | Message Scheduler
    @emem   MODNAME_MSGSVR   | Message Server a.k.a. Message Transport

    @xref   <f IFProcGetInfo>
********/

// IFAX Module names
#define MODNAME_UISHELL        "UISHELL"
#define MODNAME_MSCHED     "MSCHED"
#define MODNAME_MSGSVR     "MSGSVR"


// --------------- Timer Services -----------------------------------------

#ifndef WIN32

/********
   @doc    EXTERNAL    IFAXOS    MESSAGES    TIMER

   @msg    IF_TIMER | This message is sent to notify a process
           of the expiration of a timer set using <f IFTimerSet>.

   @parm   WPARAM  | wParam    | Contains the timer id set int he
           <f IFTimerSet> call.

   @parm   LPARAM  | lParam    | Contains the lParam passed into
           the IFTimerSet call.

   @rdesc  none

   @xref   <f IFTimerSet>
********/

// messages
#define IF_TIMER    IF_TIMER_START

// flags
#define TIME_ONESHOT    0
#define TIME_PERIODIC   1

// functions
VOID WINAPI IFProcSleep (WORD wSleepPeriod);
WORD WINAPI IFTimerSet (HWND hwnd, WORD idTimer, WORD wTimeout,
                         TIMERPROC tmprc, WORD wFlags, LPARAM lContext);
BOOL WINAPI    IFTimerKill (HWND hwnd, UINT idTimer);

#endif

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc> <f IFBufAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

//
#define RAW_DATA_SIZE       -3      // 8Kb

// Special size for modem ECM frame
#define BYTE_265_SIZE       -4      // 265 bytes
#define BYTE_265_ACTUALSIZE 265

// Number of sizes
#define MAX_POOL_INDEX  -4          // For parameter validation

// Not available yet!
#define BAND_BUFFER_SIZE    30720      // 64Kb

// Flag to force global alloc. Uses a windows flag which is ignored/defunct in
// the 3.1 kernel (and the boss kernel)
#define IFMEM_USEGLOBALALLOC GMEM_NOT_BANKED

// Functions
extern LPVOID IFMemAlloc (UINT fuAlloc, LONG lAllocSize,
                                  LPWORD lpwActualSize);
extern BOOL   IFMemFree (LPVOID lpvMem);


/********
    @doc    EXTERNAL   IFAXOS

    @api    HIPCMEM | IFMemGetIPCHandle | Returns an opaque 32 bit handle
            which is portable across process contexts.

    @parm   LPVOID  | lpvMem    | A ptr to global memory allocated using
            <f IFMemAlloc>.

    @rdesc  Opaque 32 bit none zero handle if succesfull. 0 if the memory
            ptr passed in is invalid.

    @comm   This function should be used by any DLL or process before trying
            to pass this memory to another process context. Only handles
            returned by this API should cross context boundaries, and the
            receiving context should call <f IFMemMapIPCHandle> to get back
            a valid memory ptr in its new context.

            This applies even for DLL's which might allocate a piece of
            global memory and access it in different process contexts. They
            should use these functions to map them so that they are portable.

            For Win16/IFAX implementations, this is essentially a NOP.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>

    @type   DWORD | HIPCMEM | Opaque 32 bit handle to global memory block.

    @xref   <f IFMemMapIPCHandle> <f IFMemGetIPCHandle>
*********/
typedef DWORD HIPCMEM;
#define IFMemGetIPCHandle(par1) ((HIPCMEM)par1)

/********
    @doc    EXTERNAL   IFAXOS

    @api    DWORD | IFMemMapIPCHandle | Maps a piece of memory into the
            current tasks address space.

    @parm   HIPCMEM | hMemHandle    | A memory handle returned from a call
            to <f IFMemGetIPCHandle> previously.

    @rdesc  Valid ptr to memory in the context of the calling process if
            succesful. NULL if it fails.

    @comm   See comments in <f IFMemMapIPCHandle>.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>
*********/
#define IFMemMapIPCHandle(par1) ((LPVOID)par1)


// --------------- Time API's ----------------------------------------------

/********
    @doc    EXTERNAL IFAXOS SRVRDLL

    @types  SYSTEMTIME  | Structure describing the time in terms of roman
            calendar.

    @field  WORD    | wYear | The year
    @field  WORD    | wMonth | The month from 1-12
    @field  WORD    | wDayOfWeek | Day of week with Sunday = 0
    @field  WORD    | wDay | The day of the month, from 1-31
    @field  WORD    | wHour | The hour from 0-23
    @field  WORD    | wMinute | Minutes from 0-59
    @field  WORD    | wSecond | Seconds from 0-50
    @field  WORD    | wMilliseconds | Milliseconds from 0-99

    @comm   This is the format used for dislaying time to the user etc.

    @xref   <f SystemTimeToFileTime> <t FILETIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32

typedef struct _SYSTEMTIME {
   WORD wYear;
   WORD wMonth;
   WORD wDayOfWeek;
   WORD wDay;
   WORD wHour;
   WORD wMinute;
   WORD wSecond;
   WORD wMilliseconds;
} SYSTEMTIME, FAR *LPSYSTEMTIME;

#endif

/********
    @doc    EXTERNAL  IFAXOS

    @types  FILETIME    | Structure used to store time internally and for
            mathematical operations.

    @field  DWORD   | dwLowDateTime | Low 32 bits of the time.

    @field  DWORD   | dwHighDateTime | High 32 bits of the time.

    @comm   Absolute time in IFAX is represented by a 64-bit large integer accurate
            to 100ns resolution.  The smallest time resolution used by this package
            is One millisecond.  The basis for this time is the start of 1601 which
            was chosen because it is the start of a new quadricentury.  Some facts
            to note are:

            o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

            o At 100ns resolution a large integer (i.e., 63 bits) is good for
            about 29,247 years, or around 10,682,247 days.

            o At 1 second resolution 31 bits is good for about 68 years

            o At 1 second resolution 32 bits is good for about 136 years

            o 100ns Time (ignoring time less than a millisecond) can be expressed
            as two values, Days and Milliseconds.  Where Days is the number of
            whole days and Milliseconds is the number of milliseconds for the
            partial day.  Both of these values are ULONG.

    @xref   <f SystemTimeToFileTime> <t SYSTEMTIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32
// If sos property.h has been included this will cause a redefinition
#ifndef PROPERTY_H

#ifndef _FILETIME_
#define _FILETIME_

typedef struct _FILETIME {
   DWORD dwLowDateTime;
   DWORD dwHighDateTime;
} FILETIME, FAR *LPFILETIME;

#endif // _FILETIME_

#endif // Property_H

BOOL WINAPI FileTimeToSystemTime(LPFILETIME lpTime,LPSYSTEMTIME lpTimeFields);

BOOL WINAPI SystemTimeToFileTime(LPSYSTEMTIME lpTimeFields,LPFILETIME lpTime);

BOOL WINAPI FileTimeToLocalFileTime(LPFILETIME lpft, LPFILETIME lpftLocal);

BOOL WINAPI LocalFileTimeToFileTime(LPFILETIME lpftLocal, LPFILETIME lpft);

BOOL WINAPI SetLocalTime(LPSYSTEMTIME lpstLocal);

VOID WINAPI GetLocalTime(LPSYSTEMTIME lpstLocal);
#endif // Win32

// --------------- NVRAM  API's ----------------------------------------------

typedef struct ERRORLOGPOINTER {
    WORD wNextEntryPtr ;
    WORD wNumEntries ;
} ERRORLOGPOINTER , FAR * LPERRORLOGPOINTER ;

#define MAX_ERRORLOG_ENTRIES       30
#define MAX_OEMERRBUF_SIZE         16

/********
    @doc    EXTERNAL  IFAXOS

    @types  ERRORLOGENTRY    | Used to store Log Entries.

    @field  DWORD   | dwErrorCode | This is the IFAX error code
           corresponding to the error being retrieved. See <f IFErrAssemble>
           for details of the format of this dword.

    @field  DWORD   | dwTimeStamp | The time at which this error was
           logged into NVRam. The various fields are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from COUNTER_YEAR_OFFSET (add COUNTER_YEAR_OFFSET to get actual year)

    @field CHAR    | oemErrBuf  | The buffer in which the application
           specific custom data/extended error corresponding to this
           error is retrieved.

    @comm   Used as a parameter to IFNvramGetError. This will typically be
           used for diagnostic functions.

    @xref   <f IFNvramGetError>
********/

#define COUNTER_YEAR_OFFSET  (1970)

typedef struct tagERRORLOGENTRY {
   DWORD dwErrorCode;
   DWORD dwTimeStamp;
   char oemErrBuf[MAX_OEMERRBUF_SIZE];
} ERRORLOGENTRY, FAR *LPERRORLOGENTRY;

typedef DWORD ERRORLOGSENTINEL , FAR * LPERRORLOGSENTINEL ;

// Set to the current version number (12.19)
#define SENTINEL_SET              0x00000C13UL

#define MAX_COUNTERS 30
#define OEM_NVRAM_COUNTER_START 12

// Special system counter which indicates the # of times the machine has rebooted
// It is a 4 byte counter with a timestamp
// If this value is 1 then this is the first time the machine has ever been rebooted.
// - This value cannot be set by any user application!

#define BOOT_COUNTER           0

// specific counter numbers assigned for various logical counters

#define TXCALL_COUNTER         1
#define RXCALL_COUNTER         2

// ************************************************************