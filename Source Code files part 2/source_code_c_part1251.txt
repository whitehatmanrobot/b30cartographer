>(&rProductId), m_uiMaxFeatureLength);

//	 -- HIDPI.H
//	 HIDP_GetData(Report Type, Data, Lenght, Preparse Data, Report, ReportLength);

	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}


/***********************************************************************************
**
**	HRESULT CForceFeatures::GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus)
**
**	@mfunc	Get the JoyChannel Status from msgame's MSGAME_FEATURE_GETSTATUS
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetStatus
(
	JOYCHANNELSTATUS_REPORT& rJoyChannelStatus	// @parm Reference to JOYCHANNELSTATUS_REPORT to be filled by driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rJoyChannelStatus.bReportId = MSGAME_FEATURE_GETSTATUS;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rJoyChannelStatus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
		DWORD err = GetLastError();
		return HRESULT_FROM_WIN32(err);
//	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulAckNak)
**
**	@mfunc	Returns an AckNak by using msgame's GetAckNak Featue
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetAckNak
(
	ULONG_REPORT& rulAckNak	// @parm REFERENCE to ULONG_REPORT to be filled by driver with AckNak
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulAckNak.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulAckNak), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulNakAck)
**
**	@mfunc	Returns an AckNak by using msgame's MSGAME_FEATURE_NAKACK
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetNakAck(
	ULONG_REPORT& rulNakAck	// @parm REFERENCE to ULONG_REPORT to be filled by driver with NakAck
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulNakAck.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulNakAck), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
/***********************************************************************************
**
**	HRESULT CForceFeatures::GetSync(ULONG_REPORT& rulGameport)
**
**	@mfunc	Get Sync information from MSGAME's MSGAME_FEATURE_GETSYNC
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetSync
(
	ULONG_REPORT& rulGameport	// @parm REFERENCE to ULONG_REPORT to be filled by driver with Gameport
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulGameport.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulGameport), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::DoReset()
**
**	@mfunc	Does Reset via MSGAME's MSGAME_FEATURE_DORESET
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::DoReset()
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	ULONG_REPORT ulBogus;
	ulBogus.bReportId = MSGAME_FEATURE_DORESET;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&ulBogus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffd_swff.hpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header to define FFD (Swforce) Force Feedback Driver API
    
    FUNCTIONS:		


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	22-Jan-96       MEA     original
	1.1		21-Mar-97		MEA		from SWForce
			12-Mar-99		waltw	Removed dead code (mostly FFD_xxx functions)
										These functions no longer exported in .def
		        
****************************************************************************/
#ifndef FFD_SWFF_SEEN
#define FFD_SWFF_SEEN
#include "DX_Map.hpp"
#include "hau_midi.hpp"

#define	TWOPI	(3.14159265358979323846 * 2)
#define	PI		(3.14159265358979323846)
#define	PI2		(1.57079632679489661923)
#define	PI4		(0.78539816339744830966)
#define RADIAN 	(57.29577951)

#define xDegrees2Radians(rAngle) 		((rAngle) * PI / 180.0)
#define xRadians2Degrees(rAngle) 		((rAngle) * 180.0 / PI)

//
// --- Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')


#define MAX_UD_PARAM_FORCE_DATA_COUNT	1000
#define MAX_PL_PARAM_NUM_EFFECTS		50


//---------------------------------------------------------------------------
// Function prototype declarations
//---------------------------------------------------------------------------
#ifdef _cplusplus
extern "C" {
#endif

HRESULT CreateEffectFromFile(
		IN LPCTSTR pszFileName,
		IN ULONG ulAction,
		IN OUT PDNHANDLE pDnloadID,
		IN DWORD dwFlags);

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwFileSize,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags);

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult);

HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lForceValue,
	IN ULONG ulAxisMask,
	IN OUT PSHORT pX,
	IN OUT PSHORT pY);

HRESULT WINAPI FFD_GetDiagCounters(
	IN OUT PDIAG_COUNTER pDiagCounter);

HRESULT WINAPI FFD_SetDeviceState(ULONG);

HRESULT WINAPI FFD_PutRawForce(
	IN PFORCE pForce);

HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction);

HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE EffectID);

HRESULT WINAPI FFD_PlaybackEffect(
	IN DNHANDLE hEffectID,  
	IN ULONG ulMode);

HRESULT WINAPI FFD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

HRESULT FFD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex,
	IN OUT PLONG pForceValue);

#ifdef _cplusplus
}
#endif


#endif // of ifndef FFD_SWFF_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\hau_midi.cpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for Jolt Midi device command Protocol
    
    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			02-Apr-96	MEA   	Original
				19-Sep-96	MEA		Removed ES1.0 specific code
				05-Dec-96	MEA		Removed ALLACK debug switch
	1.1			17-Mar-97	MEA		DX-FF mode
				14-Apr-97	MEA		Added support for RTC spring
				16-Mar-99	waltw	Add checks for NULL g_pJoltMidi

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "midi_obj.hpp"
#include "dx_map.hpp"
#include "sw_objec.hpp"
#include "ffd_swff.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/

/****************************************************************************

   Declaration of variables

****************************************************************************/
//
// Globals specific to hau_midi
//
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// *** ---------------------------------------------------------------------***
// Function:   	CMD_Init
// Purpose:    	Inits JOLT for MIDI channel
// Parameters: 
//			   	none
//
// Returns:    	SUCCESS - if successful, else
//				a device Error code
//
// Algorithm:
//
// Comments:
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_Init(void)
{
	HRESULT hRet;
	BYTE bChannel = DEFAULT_MIDI_CHANNEL;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	g_pJoltMidi->SetMidiChannel(bChannel);	// Force this channel
	hRet = CMD_MIDI_Assign(bChannel);
	return(hRet);
}

//
// --- EFFECT_CMDs
//
/****************************************************************************

    FUNCTION:   CMD_Force_Out

	PARAMETERS:	IN LONG	lForceData	- Actual force 
				IN ULONG ulAxisMask - Axis Mask

	RETURNS:	SUCCESS or FAILURE

   	COMMENTS:	Sends force vector to MIDI channel

  Byte 0	= EFFECT_CMD + Channel #
									D7 D6  D5  D4  D3  D2  D1  D0
									-- --  --  --  --  --  --  --
  Byte 1	= Low byte of Force		 0 v4  v3  v2  v1  v0  d   d
  Byte 2	= High byte of Force	 0 v11 v10 v9  v8  v7  v6  v5 
	where: d  d
	       -  -
		   0  0	reserved
		   0  1	PUT_FORCE_X
		   1  0	PUT_FORCE_Y
		   1  1	PUT_FORCE_XY

****************************************************************************/
HRESULT CMD_Force_Out(LONG lForceData, ULONG ulAxisMask)
{
	HRESULT hRet;
	BYTE cData1;
	BYTE cData2;
	BYTE cAxis;		

 	BYTE cStatus = EFFECT_CMD;
	switch(ulAxisMask)	
	{
		case X_AXIS:
			cAxis = PUT_FORCE_X;
			break;
		case Y_AXIS:
			cAxis = PUT_FORCE_Y;
			break;
		case (X_AXIS | Y_AXIS):
			cAxis = PUT_FORCE_XY;
			break;
		default:
			return (SFERR_INVALID_PARAM);				
			break;
	}
	cData1 = ((int) lForceData << 2) & 0x7c;
	cData1 = cData1 | cAxis;
	cData2 = ((int) lForceData >> 5) & 0x7f;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, cData1, cData2);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR, 
					DRIVER_ERROR_MIDI_OUTPUT));
	// Note: PutForce used to not expect an ACK/NACK, only used to slow down
	// transmission to Jolt and prevent any lockups
	//Sleep(SHORT_MSG_TIMEOUT);
	//ACKNACK AckNack = {sizeof(ACKNACK)};
	//hRet = g_pJoltMidi->GetAckNackData(g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay, &AckNack);
#if 0
	static DWORD dwMod = 0;
	dwMod++;
	if(dwMod%g_pJoltMidi->DelayParamsPtrOf()->dwForceOutMod == 0)
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay);
#endif
	DWORD dwIn;
	int nDelayCount = g_pJoltMidi->DelayParamsPtrOf()->dwForceOutDelay;
	for(int i=0; i<nDelayCount; i++)
		g_pDriverCommunicator->GetStatusGateData(dwIn);
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_DestroyEffect
// Purpose:    	Destroys the Effect from Device
// Parameters: 
//				IN DNHANDLE DnloadID		- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//	The Device's Effect ID and memory is returned to free pool.
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= DESTROY_EFFECT		0   0   0   1   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(NULL != pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	// Send the command

	HRESULT hRet = pMidiEffect->DestroyEffect();

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	// Wait for ACK.  Note: WinMM has callback Event notification
	// while Backdoor and serial does not.
	if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
	{	
		hRet = g_pJoltMidi->GetAckNackData(ACKNACK_EFFECT_STATUS_TIMEOUT, &AckNack, REGBITS_DESTROYEFFECT);
	}
	else
		hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_DESTROYEFFECT);

	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));

	// Delete the Effect
	delete pMidiEffect;
    return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	CMD_PlayEffectSuperimpose
// Purpose:    	Plays the Effect in Device
// Parameters: 
//				IN DNHANDLE DnloadID	- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:	This is PLAY_SUPERIMPOSE mode
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//										D7  D6  D5  D4  D3  D2  D1  D0
//										--  --  --  --  --  --  --  --
//  Byte 1	= PLAY_EFFECT_SUPERIMPOSE	0   0   1   0   0   0   0   0
//  Byte 2	= EffectID (7 bits)			0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_PlayEffectSuperimpose( 
	IN DNHANDLE DnloadID) 
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

#if 0
	// Hack to fix firmware bug #1138 which causes an infinite duration
	// effect not to be felt on re-start once the effect has been stopped.
	// The hack is to "change" the duration from infinite to infinite
	ULONG ulDuration = pMidiEffect->DurationOf();
	if(ulDuration == 0)
	{
		// see if it is a PL or an atomic effect
		ULONG ulSubType = pMidiEffect->SubTypeOf();
		BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);
		if(!bProcessList)
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, 0);
	}
#endif

	// Update the playback mode for this Effect
	pMidiEffect->SetPlayMode(PLAY_SUPERIMPOSE);

	assert((BYTE) DnloadID < MAX_EFFECT_IDS);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,PLAY_EFFECT_SUPERIMPOSE,(BYTE)DnloadID);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_PLAYEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_PlayEffectSolo
// Purpose:    	Plays the Effect in Device as PLAY_SOLO
// Parameters: 
//				IN DNHANDLE EffectID	- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:	This is PLAY_SOLO mode
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= PLAY_EFFECT_SOLO	 	0   0   0   0   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_PlayEffectSolo( 
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

#if 0
	// Hack to fix firmware bug #1138 which causes an infinite duration
	// effect not to be felt on re-start once the effect has been stopped.
	// The hack is to "change" the duration from infinite to infinite
	ULONG ulDuration = pMidiEffect->DurationOf();
	if(ulDuration == 0)
	{
		// see if it is a PL or an atomic effect
		ULONG ulSubType = pMidiEffect->SubTypeOf();
		BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);
		if(!bProcessList)
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, 0);
	}
#endif

	// Update the playback mode for this Effect
	pMidiEffect->SetPlayMode(PLAY_SOLO);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,PLAY_EFFECT_SOLO, (BYTE) DnloadID);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_PLAYEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_StopEffect
// Purpose:    	Stops the Effect in Device
// Parameters: 
//				IN DNHANDLE EffectID		- an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= STOP_EFFECT		 	0   0   1   1   0   0   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_StopEffect( 
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, STOP_EFFECT, (BYTE) DnloadID);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	ACKNACK AckNack = {sizeof(ACKNACK)};
	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_STOPEFFECT);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetIndex
// Purpose:    	Sets the autoincrementing Index for MODIFY_CMD
// Parameters: 
//				IN int nIndex			- Index value 0 - 15
//				IN DNHANDLE DnloadID	- Effect ID in stick
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= SET_INDEX+index	 	0   1   i   i   i   i   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Check for valid Effect
	if (SYSTEM_EFFECT_ID != DnloadID)
	{
		CMidiEffect *pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiEffect);
		if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);
	}

	assert((nIndex <= MAX_INDEX) && (nIndex >= 0));
	if ((nIndex < 0) || (nIndex > MAX_INDEX)) return (SFERR_INVALID_PARAM);
	
	BYTE cByte1;
	cByte1 = SET_INDEX | (BYTE) (nIndex << 2);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD, cByte1, (BYTE) DnloadID);

	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: SetIndex used to not require ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_SETINDEX);
	// :
	if (SUCCESS != hRet)
		return (SFERR_DRIVER_ERROR);
	
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParam
// Purpose:    	Modifies an Effect parameter
// Parameters: 
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= MODIFY_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Low 7 bits data	 	0   v   v   v   v   v   v   v
//  Byte 2	= High 7 bits data		0   v   v   v   v   v   v   v
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParam( 
	IN WORD wNewParam)
{
	HRESULT hRet;
	BYTE cByte1, cByte2;
	cByte1 = wNewParam & 0x7f;
	cByte2 = (BYTE) ((wNewParam >> 7) & 0x7f);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(MODIFY_CMD, cByte1, cByte2);
	
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: ModifyParam used to not require an ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_MODIFYPARAM);
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParamByIndex
// Purpose:    	Modifies an Effect parameter, given an Index
// Parameters: 
//				IN	int nIndex			- Index 0 to 15
//				IN DNHANDLE DnloadID	- Download ID
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//	Assumes DnloadID is already valid
//	Calls SetIndex followed by ModifyParam
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParamByIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID, 
	IN WORD wNewParam)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	if ((nIndex < 0) || (nIndex > MAX_INDEX))
		return (SFERR_INVALID_PARAM);

	int i;
	for (i=0; i<MAX_RETRY_COUNT; i++)
	{
		hRet = CMD_SetIndex(nIndex,DnloadID);
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwSetIndexDelay);
		if (SUCCESS == hRet) break;
#ifdef _DEBUG
		OutputDebugString("CMD_SetIndex Failed. Retrying again\n");
#endif
	}
	if (SUCCESS != hRet)
		return (hRet);
	else
	{
		for (i=0; i<MAX_RETRY_COUNT; i++)
		{
			hRet = CMD_ModifyParam(wNewParam);
			Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwModifyParamDelay);
			if (SUCCESS == hRet) break;
#ifdef _DEBUG
			OutputDebugString("CMD_SetIndex Failed. Retrying again\n");
#endif
		}
	}
	return (hRet);
}

//
// --- SYSTEM_CMDs
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetDeviceState
// Purpose:    	Sets the FF device State
// Parameters: 
//			   	ULONG ulMode 
//
// Returns:    	SUCCESS - if successful, else
//				Device error code
//
// Algorithm:
// Comments:   	
//	ulMode:
//	  DEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
//	  DEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
//	  DEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
//	  DEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
//	  DEV_PAUSE		5L		// All Effects are "Paused"
//	  DEV_STOP_ALL	6L		// Stops all Effects. 
//
//  Byte 0	= SYSTEM_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Set Device Type	 	0   0   0   0   0   0   0   1
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetDeviceState(
	IN ULONG ulMode)
{
	HRESULT hRet = SUCCESS;
	assert(g_pJoltMidi);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	BYTE	bChannel = g_pJoltMidi->MidiChannelOf();
	MIDIINFO *pMidiOutInfo = g_pJoltMidi->MidiOutInfoOf();
	switch (ulMode)
	{
		case DEV_RESET:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_SHUTDOWN, 0);
			break;

		case DEV_FORCE_ON:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_FORCE_ON, 0);
			break;

		case DEV_FORCE_OFF:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_FORCE_OFF, 0);
			break;

		case DEV_CONTINUE:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_CONTINUE, 0);
			break;

		case DEV_PAUSE:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_PAUSE, 0);
			break;

		case DEV_STOP_ALL:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_STOP_ALL, 0);
			break;

		case SWDEV_KILL_MIDI:
			hRet = g_pJoltMidi->MidiSendShortMsg(SYSTEM_CMD, SWDEV_KILL_MIDI, 0);
			break;

		default:
			return SFERR_INVALID_PARAM;
	}
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Wait for ACK or NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
	if (DEV_RESET == ulMode)
	{	// Wait for Jolt to complete the cycle
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay);
		hRet = g_pJoltMidi->GetAckNackData(ACKNACK_TIMEOUT, &AckNack, REGBITS_SETDEVICESTATE);
	}
	else
	{
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);
		hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_SETDEVICESTATE);
	}

	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));

	// Special case Shutdown
	if (DEV_RESET == ulMode)
	{
		// Delete all Effects except built-in RTC Spring and FRICTION cancel.
		g_pJoltMidi->DeleteDownloadedEffects();	
	}
	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwPostSetDeviceStateDelay);
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_GetEffectStatus
// Purpose:    	Returns Status of Effect ID
// Parameters: 
//			   	DNHANDLE DnloadID		- Effect ID
//				PBYTE	 pStatusCode	- Status Code
//
// Returns:    	SUCCESS - if successful, else
//				a device Error code
//				*pStatusCode set to		- SWDEV_STS_EFFECT_STOPPED
//										  SWDEV_STS_EFFECT_RUNNING
//
// Algorithm:
//
// Comments:   	
//  Byte 0	= STATUS_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Effect ID			 	0   0   0   0   0   1   0   0
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_GetEffectStatus(DNHANDLE DnloadID, PBYTE pStatusCode)
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(STATUS_CMD, (BYTE) DnloadID, 0);
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay);// enough for about 3 bytes of data being sent at 330us/byte	

	DWORD dwIn;
	hRet = g_pDriverCommunicator->GetStatusGateData(dwIn);
	if (SUCCESS != hRet) return (hRet);

	if ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & RUNNING_MASK_200))
	{
		*pStatusCode = SWDEV_STS_EFFECT_RUNNING;
	}
	else
	{
		*pStatusCode = SWDEV_STS_EFFECT_STOPPED;
	}
	return (hRet);
}

//
// --- System Exclusive Commands
//
// System Exclusive Command:MIDI_ASSIGN
// 
// *** ---------------------------------------------------------------------***
// Function:   	CMD_MIDI_Assign
// Purpose:    	Inits JOLT MIDI channel
// Parameters:	BYTE bMidiChannel	- Channel to assign 
//
// Returns:    	SUCCESS or Error code
//				
//
// Algorithm:
//
// Comments:   	SYS_EX type command
//   
//	Body							D7  D6  D5  D4  D3  D2  D1  D0
//  ------							--  --  --  --  --  --  --  --
//  Byte 0	= MIDI_ASSIGN			0   0   0   1   0   0   0   0
//  Byte 1	= channel#(0-15) e.g. 5	0   0   0   0   0   1   0   1
//  Byte 2	= not used, set to 0    0   0   0   0   0   0   0   0
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_MIDI_Assign(
	IN BYTE bMidiChannel)
{
	HRESULT hRet;
	PMIDI_ASSIGN_SYS_EX lpData;
	CMidiAssign *pMidiAssign;

	assert((bMidiChannel > 0) && (bMidiChannel < MAX_MIDI_CHANNEL));

	pMidiAssign = new CMidiAssign;
	assert(pMidiAssign);
	if (!pMidiAssign) return (SFERR_DRIVER_ERROR);
	pMidiAssign->SetMidiAssignChannel(bMidiChannel);
	lpData = (PMIDI_ASSIGN_SYS_EX) pMidiAssign->GenerateSysExPacket();
	assert(lpData);
	if(!lpData) return (SFERR_DRIVER_ERROR);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Prepare the buffer for SysEx output
	g_pJoltMidi->MidiAssignBuffer((LPSTR) lpData, 
					(DWORD) sizeof(MIDI_ASSIGN_SYS_EX), TRUE);

	// Send the message and Wait for the ACK
	hRet = g_pJoltMidi->MidiSendLongMsg();
	if (SUCCESS == hRet)
	{
		ACKNACK AckNack = {sizeof(ACKNACK)};
		// Wait for ACK.  Note: WinMM has callback Event notification
		// while Backdoor and serial does not.
		if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
		{	
			hRet = g_pJoltMidi->GetAckNackData(ACKNACK_TIMEOUT, &AckNack, REGBITS_DEVICEINIT);
		}
		else
			hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, REGBITS_DEVICEINIT);

		// :
		if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
		if (ACK != AckNack.dwAckNack)
			hRet = g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode);
 	}
	else
		hRet = SFERR_DRIVER_ERROR;

	// Release the Midi buffers and delete the MIDI sys_ex object
	g_pJoltMidi->MidiAssignBuffer((LPSTR) lpData, 0, FALSE);
	delete pMidiAssign;
	return (hRet);
}

//
// System Exclusive Command:DNLOAD_DATA
//
/****************************************************************************

    FUNCTION:   CMD_Download_BE_XXX

	PARAMETERS:	PEFFECT pEffect		- Ptr to a EFFECT data structure
				PENVELOPE pEnvelope	- Ptr to an ENVELOPE data structure 
				PBE_XXX pBE_XXX		- Ptr to a BE_XXX data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage
				DWORD dwFlags		- dwFlags from Kernel

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads BE_XXX type Effect params to the device
				Uses SysEx prototype and ModifyParam methods
				Note: Normally pEnvelope = NULL

****************************************************************************/
HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PBEHAVIORAL_SYS_EX lpData;
	CMidiBehavioral *pMidiBehavioral;
	BOOL fXConstantChanged=FALSE;
	BOOL fYConstantChanged=FALSE;
	BOOL fParam3Changed=FALSE;
	BOOL fParam4Changed=FALSE;

	assert(pEffect && pBE_XXX && pDnloadID);
	if ((NULL == pEffect) || (NULL == pBE_XXX) || (NULL == pDnloadID))
		return (SFERR_INVALID_PARAM);

	DNHANDLE DnloadID =*pDnloadID;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// scale the constants using the fudge factor
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	switch(pEffect->m_SubType)
	{
		case BE_INERTIA:
		case BE_INERTIA_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleMx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleMy))/((int)100);
			break;

		case BE_SPRING:
		case BE_SPRING_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleKx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleKy))/((int)100);
			break;

		case BE_DAMPER:
		case BE_DAMPER_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleBx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleBy))/((int)100);
			break;

		case BE_FRICTION:
		case BE_FRICTION_2D:
			pBE_XXX->m_XConstant = (((int)pBE_XXX->m_XConstant)*((int)pFirmwareParams->dwScaleFx))/((int)100);
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleFy))/((int)100);
			break;

		case BE_WALL:
			pBE_XXX->m_YConstant = (((int)pBE_XXX->m_YConstant)*((int)pFirmwareParams->dwScaleW))/((int)100);
			break;

		default:
			// do not scale
			break;
	}

// If Create New, then create a new object, using SysEx
// else, update the existing Effect object, using ModifyParam
	if (NULL == DnloadID)	// New, Make a new object, use SysEx
	{
		if ((BE_FRICTION == pEffect->m_SubType) || (BE_FRICTION_2D == pEffect->m_SubType))
		{
			pMidiBehavioral = new CMidiFriction(pEffect, pEnvelope, pBE_XXX);
			assert(pMidiBehavioral);
		}
		else	// Wall
			if	(BE_WALL == pEffect->m_SubType)
			{
				pMidiBehavioral = new CMidiWall(pEffect, pEnvelope, pBE_XXX);
				assert(pMidiBehavioral);
			}
			// BE_SPRINGxx, BE_DAMPERxx, BE_INERTIAxx
			else
			{
				pMidiBehavioral = new CMidiBehavioral(pEffect, pEnvelope, pBE_XXX);
				assert(pMidiBehavioral);
			}
		if (NULL == pMidiBehavioral) return (SFERR_INVALID_OBJECT);
		// Generate Sys_Ex packet then prepare for output	
		lpData = (PBEHAVIORAL_SYS_EX) pMidiBehavioral->GenerateSysExPacket();
		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);

		// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
		pMidiBehavioral->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
		hRet = pMidiBehavioral->SendPacket(pDnloadID, pMidiBehavioral->MidiBufferSizeOf());
		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiBehavioral;
		}
	}
	else	// Modify existing
	{
		pMidiBehavioral = (CMidiBehavioral *) g_pJoltMidi->GetEffectByID(*pDnloadID);
		assert(pMidiBehavioral);
		if (NULL == pMidiBehavioral) return (SFERR_INVALID_OBJECT);

		// Check if Type specific params have changed.
		if (BE_WALL == pEffect->m_SubType)
		{
			if ((pBE_XXX->m_XConstant) != pMidiBehavioral->XConstantOf())
				fXConstantChanged=TRUE;		// Wall Type
			if ((pBE_XXX->m_YConstant) != pMidiBehavioral->YConstantOf())
				fYConstantChanged=TRUE;		// Wall Constant
			if ((pBE_XXX->m_Param3) != pMidiBehavioral->Param3Of())
				fParam3Changed=TRUE;		// Wall Angle
			if ((pBE_XXX->m_Param4) != pMidiBehavioral->Param4Of())
				fParam4Changed=TRUE;		// Wall Distance
		}
		else
		{
			if ((pBE_XXX->m_XConstant) != pMidiBehavioral->XConstantOf())
				fXConstantChanged=TRUE;
			if ((pBE_XXX->m_YConstant) != pMidiBehavioral->YConstantOf())
				fYConstantChanged=TRUE;
			if ((BE_FRICTION != pEffect->m_SubType) && (BE_FRICTION_2D != pEffect->m_SubType))
			{
				if ((pBE_XXX->m_Param3) != pMidiBehavioral->Param3Of())
					fParam3Changed=TRUE;
				if ((pBE_XXX->m_Param4) != pMidiBehavioral->Param4Of())
					fParam4Changed=TRUE;
			}
		}

		// Fill in the common Effect and Behavioral specific parameters
		// Only update Duration and Button Play as common effect parameters
		// Double check if DURATION and TRIGGERBUTTON changed, to speed operation
		DWORD dwTempFlags = 0;
		if (pEffect->m_Duration != pMidiBehavioral->DurationOf())
			dwTempFlags = dwTempFlags | DIEP_DURATION;
		if (pEffect->m_ButtonPlayMask != pMidiBehavioral->ButtonPlayMaskOf())
			dwTempFlags = dwTempFlags | DIEP_TRIGGERBUTTON;
		pMidiBehavioral->SetEffectParams(pEffect, pBE_XXX);
		hRet = ModifyEffectParams(DnloadID, pEffect, dwTempFlags);
		if (SUCCESS!=hRet) return hRet;

		if (BE_WALL == pEffect->m_SubType)
		{
			// Generate Sys_Ex packet then prepare for output	
			lpData = (PBEHAVIORAL_SYS_EX) pMidiBehavioral->GenerateSysExPacket();
			assert(lpData);
			if (!lpData) return (SFERR_DRIVER_ERROR);

			// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
			pMidiBehavioral->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
			hRet = pMidiBehavioral->SendPacket(pDnloadID, pMidiBehavioral->MidiBufferSizeOf());
		}
		else // Use ModifyParameter 
		{
			// Type Specific Params
			if (dwFlags & DIEP_TYPESPECIFICPARAMS)
			{
		 
				if (fYConstantChanged)	// KY/BY/MY/FY
				{
					hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (pBE_XXX->m_YConstant * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}
			
				if(fXConstantChanged)	// KX/BX/MX/FX
				{
					hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT) (pBE_XXX->m_XConstant * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}

				if (fParam4Changed)		// CY/VY/AY
				{
					hRet = CMD_ModifyParamByIndex(INDEX5, DnloadID, (SHORT) (pBE_XXX->m_Param4 * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}

				if (fParam3Changed)		// CX/VX/AX
				{
					hRet = CMD_ModifyParamByIndex(INDEX4, DnloadID, (SHORT) (pBE_XXX->m_Param3 * MAX_SCALE));
					if (SUCCESS!=hRet) return hRet;
				}
			}
		}
	}                   
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Download_RTCSpring

	PARAMETERS:	PRTCSPRING_PARAM pRTCSpring	- Ptr to a RTCSPRING_PARAM structure
				PDNHANDLE pDnloadID		- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads RTCSPRING type Effect params to the device
				Uses SysEx prototype and ModifyParam methods

****************************************************************************/
HRESULT CMD_Download_RTCSpring(
 	IN PRTCSPRING_PARAM pRTCSpring,
	IN OUT PDNHANDLE pDnloadID)
{ 
	HRESULT hRet = SUCCESS;
	CMidiRTCSpring *pMidiRTCSpring;

	assert(pRTCSpring && pDnloadID);
	if ((NULL == pRTCSpring) || (NULL == pDnloadID))
		return (SFERR_INVALID_PARAM);

	DNHANDLE DnloadID = SYSTEM_RTCSPRING_ID;
	*pDnloadID = DnloadID;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Note: RTC Spring is a permanent System Effect ID 2
	pMidiRTCSpring = (CMidiRTCSpring *) g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiRTCSpring);
	if (NULL == pMidiRTCSpring) return (SFERR_INVALID_OBJECT);

	// Check if Type specific params have changed, if so, Modify it
	if ((pRTCSpring->m_XKConstant) != pMidiRTCSpring->XKConstantOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX0, DnloadID, 
				(SHORT) (pRTCSpring->m_XKConstant * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YKConstant) != pMidiRTCSpring->YKConstantOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX1, DnloadID, 
				(SHORT) (pRTCSpring->m_YKConstant * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XAxisCenter) != pMidiRTCSpring->XAxisCenterOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX2, DnloadID, 
				(SHORT) (pRTCSpring->m_XAxisCenter * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YAxisCenter) != pMidiRTCSpring->YAxisCenterOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX3, DnloadID, 
				(SHORT) (pRTCSpring->m_YAxisCenter * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XSaturation) != pMidiRTCSpring->XSaturationOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX4, DnloadID, 
				(SHORT) (pRTCSpring->m_XSaturation * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YSaturation) != pMidiRTCSpring->YSaturationOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX5, DnloadID, 
				(SHORT) (pRTCSpring->m_YSaturation * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_XDeadBand) != pMidiRTCSpring->XDeadBandOf())
	{
		if (SUCCESS != (hRet=CMD_ModifyParamByIndex(INDEX6, DnloadID, 
				(SHORT) (pRTCSpring->m_XDeadBand * MAX_SCALE))))
				 return hRet;
	}

	if ((pRTCSpring->m_YDeadBand) != pMidiRTCSpring->YDeadBandOf())
	{
		hRet=CMD_ModifyParamByIndex(INDEX7, DnloadID,
				(SHORT) (pRTCSpring->m_YDeadBand * MAX_SCALE));
	}
	
	pMidiRTCSpring->SetEffectParams(pRTCSpring);
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Dnload_NOP_DELAY

	PARAMETERS:	ULONG ulDuration	- Duration delay

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads NOP_DELAY Effect params to the device
				Uses SysEx prototype

****************************************************************************/
HRESULT CMD_Download_NOP_DELAY(
 	IN ULONG ulDuration,
	IN PEFFECT pEffect,
 	IN OUT PDNHANDLE pDnloadID)
{ 
	HRESULT hRet = SUCCESS;
	PNOP_SYS_EX lpData;
	CMidiDelay *pMidiDelay;
	BOOL fCreateNew = FALSE;

	assert(pDnloadID);
	assert(0 != ulDuration);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, 
// else, update the existing Effect object.
	if (NULL == *pDnloadID) fCreateNew = TRUE;

	if (fCreateNew)	// New, Make a new object
	{
		pMidiDelay = new CMidiDelay(pEffect);
		assert(pMidiDelay);
		if (NULL == pMidiDelay) return (SFERR_INVALID_OBJECT);
		pMidiDelay->SetEffectID(NEW_EFFECT_ID);
	}
	else	// Modify existing
	{
		pMidiDelay = (CMidiDelay *) g_pJoltMidi->GetEffectByID(*pDnloadID);
		assert(pMidiDelay);
		if (NULL == pMidiDelay) return (SFERR_INVALID_OBJECT);
		pMidiDelay->SetEffectID((BYTE) *pDnloadID);
	}
	pMidiDelay->SetDuration(ulDuration);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PNOP_SYS_EX) pMidiDelay->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	pMidiDelay->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiDelay->SendPacket(pDnloadID, sizeof(NOP_SYS_EX));
	if (FAILED(hRet) && fCreateNew) // Create NEW, Failure
	{
		delete pMidiDelay;
	}
	return (hRet);
}


/****************************************************************************

    FUNCTION:   CMD_Dnload_UD_Waveform

	PARAMETERS:	ULONG ulDuration	- what fun!
				PEFFECT pEffect		- Ptr to an EFFECT structure
				ULONG   ulNumVectors- Number of vectors in the array
				PLONG   pUD_Array	- Ptr to a UD_WAVEFORM byte array
				ULONG	ulAction	- Mode for download
				PDNHANDLE pDnloadID - Ptr to a DNHANDLE store
				DWORD dwFlags		- dwFlags from Kernel

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads UD_WAVEFORM Effect params to the device
				Uses SysEx prototype

****************************************************************************/
HRESULT CMD_Download_UD_Waveform(
	IN ULONG ulDuration,
	IN PEFFECT pEffect,
	IN ULONG ulNumVectors,
 	IN PLONG pUD_Array,
	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PUD_WAVEFORM_SYS_EX lpData;
	CMidiUD_Waveform *pMidiUD_Waveform;

	assert(pEffect && pUD_Array);
	assert(ulNumVectors > 0);
	assert(pDnloadID);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, 
// else, update the existing Effect object.
	DNHANDLE DnloadID = *pDnloadID;
	if (NULL == DnloadID)	// New, Make a new object
	{
		pMidiUD_Waveform = new CMidiUD_Waveform(pEffect, ulNumVectors, pUD_Array);
		assert(pMidiUD_Waveform);

		if (NULL == pMidiUD_Waveform) return (SFERR_INVALID_OBJECT);

		if (0 == pMidiUD_Waveform->MidiBufferSizeOf())
		{
			delete pMidiUD_Waveform;
			return (SFERR_INVALID_PARAM);
		}
		// Generate Sys_Ex packet then prepare for output	
		lpData = (PUD_WAVEFORM_SYS_EX) pMidiUD_Waveform->GenerateSysExPacket();
		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);

		// Store the PrimaryBuffer ptr to CMidiEffect::m_pBuffer;
		pMidiUD_Waveform->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
		hRet = pMidiUD_Waveform->SendPacket(pDnloadID, pMidiUD_Waveform->MidiBufferSizeOf());
		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiUD_Waveform;
		}
	}
	else	// Modify existing
	{
		pMidiUD_Waveform = (CMidiUD_Waveform *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiUD_Waveform);
		if (NULL == pMidiUD_Waveform) return (SFERR_INVALID_OBJECT);		

		// fix the output rate (waveform is compressed)
		pEffect->m_ForceOutputRate = pEffect->m_ForceOutputRate*pMidiUD_Waveform->ForceOutRateOf()/pMidiUD_Waveform->OriginalEffectParamOf()->m_ForceOutputRate;

		// Modify EFFECT, and ENVELOPE params
		hRet = ModifyEffectParams(DnloadID, pEffect, dwFlags);
		if (SUCCESS!=hRet) return hRet;
	}
	return (hRet);
}

/****************************************************************************

    FUNCTION:   CMD_Dnload_SYNTH

	PARAMETERS:	PSYNTH pSynth		- Ptr to a SYNTH data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads SE_xxx Effect params to the device
				Uses SysEx prototype

 Algorithm:
 The following dwFlags may be sent by the kernel

	#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
	#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
	#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
	#define DIEP_DURATION 				0x00000001	- dwDuration
	#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
	#define DIEP_GAIN 					0x00000004	- dwGain
	#define DIEP_NODOWNLOAD 			0x80000000	- suppress auto - download
	#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
	#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
	#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
	#define DIEP_TYPESPECIFICPARAMS 	0x00000100	- cbTypeSpecificParams
													  and lpTypeSpecificParams
	 Jolt has two options for downloading - Full SysEx or Modify Parameter
	 Pass the dwFlags to each CMD_xxx function and let the MIDI function
	 determine whether to use SysEx or Modify Parameter.

****************************************************************************/
HRESULT CMD_Download_SYNTH(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PSE_PARAM pSE_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{ 
	HRESULT hRet = SUCCESS;
	PSE_WAVEFORM_SYS_EX lpData;
	CMidiSynthesized *pMidiSynthesized;
	BOOL fFreqChanged = FALSE;
	BOOL fMaxAmpChanged = FALSE;
	BOOL fMinAmpChanged = FALSE;
	DNHANDLE DnloadID =*pDnloadID;
	assert(pEffect && pEnvelope && pSE_Param && pDnloadID);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
// If Create New, then create a new object, and use SysEx method
// else, update the existing Effect object. using ModifyParam method
	if (NULL == DnloadID)	// New, Make a new object
	{
		pMidiSynthesized = new CMidiSynthesized(pEffect, pEnvelope, pSE_Param);
		assert(pMidiSynthesized);
		if (NULL == pMidiSynthesized) return (SFERR_DRIVER_ERROR);

		// Generate Sys_Ex packet then prepare for output	
		lpData = (PSE_WAVEFORM_SYS_EX) pMidiSynthesized->GenerateSysExPacket();

		assert(lpData);
		if (!lpData) return (SFERR_DRIVER_ERROR);
		pMidiSynthesized->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());

		hRet = pMidiSynthesized->SendPacket(pDnloadID, sizeof(SE_WAVEFORM_SYS_EX));

		if (SUCCESS != hRet) // Create NEW, Failure
		{
			delete pMidiSynthesized;
			pMidiSynthesized = NULL;

			return hRet;
		}

		// Hack to fix firmware bug #1138 which causes an infinite duration
		// effect not to be felt on re-start once the effect has been stopped.
		// The hack is to "change" the duration from infinite to infinite
		ULONG ulDuration = pMidiSynthesized->DurationOf();
		if(ulDuration == 0)
		{
			hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, 0);

		}

		return (hRet);
	}
	else	// Modify existing
	{
		pMidiSynthesized = (CMidiSynthesized *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiSynthesized);
		if (NULL == pMidiSynthesized) return (SFERR_INVALID_OBJECT);

		// check to see if they are trying to change sub-type (not allowed)
		if((dwFlags & DIEP_TYPESPECIFICPARAMS) && pEffect->m_SubType != pMidiSynthesized->SubTypeOf())
			return SFERR_NO_SUPPORT;

		if(dwFlags & DIEP_NODOWNLOAD)
			return DI_DOWNLOADSKIPPED;

		// Check if Type specific params have changed.
		if (pSE_Param->m_Freq != pMidiSynthesized->FreqOf())
			fFreqChanged=TRUE;
		if ((pSE_Param->m_MaxAmp) != pMidiSynthesized->MaxAmpOf()) 
			fMaxAmpChanged=TRUE;
		if ((pSE_Param->m_MinAmp) != pMidiSynthesized->MinAmpOf()) 
			fMinAmpChanged=TRUE;

		// Fill in the common Effect and Synth specific parameters
		pMidiSynthesized->SetEffectParams(pEffect, pSE_Param, ulAction);
//		// Fill in the Envelope
//		pMidiSynthesized->SetEnvelope(pEnvelope);

		// Modify EFFECT, ENVELOPE and Type Specific
		hRet = ModifyEffectParams(DnloadID, pEffect, dwFlags);
		if (SUCCESS!=hRet) return hRet;

		hRet = ModifyEnvelopeParams(pMidiSynthesized, DnloadID, pEffect->m_Duration, pEnvelope, dwFlags);
		if (SUCCESS!=hRet) return hRet;
		
		// Fill in the Envelope
		pMidiSynthesized->SetEnvelope(pEnvelope);

		// Type Specific Params
		if (dwFlags & DIEP_TYPESPECIFICPARAMS)
		{
		 	if(fFreqChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX12, DnloadID, (SHORT) pSE_Param->m_Freq);
				if (SUCCESS!=hRet) return hRet;
			}
			if (fMaxAmpChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX13, DnloadID, (SHORT) (pSE_Param->m_MaxAmp * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}
			if (fMinAmpChanged)
			{
				hRet = CMD_ModifyParamByIndex(INDEX14, DnloadID, (SHORT) (pSE_Param->m_MinAmp * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}
		}
	}                   
	return (hRet);
}

/****************************************************************************

    FUNCTION:   CMD_Download_VFX

	PARAMETERS:	PSYNTH pSynth		- Ptr to a SYNTH data structure
				PDNHANDLE pDnloadID	- Ptr to a HANDLE storage

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Downloads SE_xxx Effect params to the device
				Uses SysEx prototype

 Algorithm:
 The following dwFlags may be sent by the kernel

	#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
	#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
	#define DIEP_GAIN 					0x00000004	- dwGain
	#define DIEP_NODOWNLOAD 			0x80000000	- suppress auto - download
	#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
	#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
	#define DIEP_TYPESPECIFICPARAMS 	0x00000100	- cbTypeSpecificParams
													  and lpTypeSpecificParams
	 Jolt has two options for downloading - Full SysEx or Modify Parameter
	 Pass the dwFlags to each CMD_xxx function and let the MIDI function
	 determine whether to use SysEx or Modify Parameter.

****************************************************************************/
HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFXParam,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags)
{
	HRESULT hRet = SUCCESS;
	DNHANDLE DnloadID = *pDnloadID;


	assert(pEffect && !pEnvelope && pVFXParam);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	BOOL bModify = DnloadID != 0;

	if(*pDnloadID == 0)
	{
		// make a new object
		if(pVFXParam->m_PointerType == VFX_FILENAME)
			hRet = CreateEffectFromFile((LPCTSTR)pVFXParam->m_pFileNameOrBuffer, ulAction, (USHORT*)pDnloadID, dwFlags);
		else if(pVFXParam->m_PointerType == VFX_BUFFER)
			hRet = CreateEffectFromBuffer(pVFXParam->m_pFileNameOrBuffer, pVFXParam->m_BufferSize, ulAction, (USHORT*)pDnloadID, dwFlags);
		else
			hRet = SFERR_INVALID_PARAM;

		if(FAILED(hRet)) return hRet;

		DnloadID = *pDnloadID;
	}

	// modify an existing object or the effect just created

	// get the effect associated with this ID
	CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DnloadID);
	assert(pMidiEffect);
	if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

	// change the button play mask only on a modify
	if (bModify && (dwFlags & DIEP_TRIGGERBUTTON))
	{
		// get the button play mask
		ULONG ulButtonPlayMask = pEffect->m_ButtonPlayMask;

		// modify the param in the CMidiEffect
		pMidiEffect->SetButtonPlaymask(ulButtonPlayMask);

		// modify the param in the stick
		hRet = CMD_ModifyParamByIndex(INDEX1, DnloadID, (SHORT)ulButtonPlayMask);
		if (SUCCESS!=hRet) return hRet;
	}

	// see if it is a PL or an atomic effect
	ULONG ulSubType = pMidiEffect->SubTypeOf();
	BOOL bProcessList = (ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE);

	// modify gain and direction
	if(bProcessList)
	{
		// modify gain and direction for each sub-effect

		// convert the pointer to CMidiProcessList
		CMidiProcessList* pMidiProcessList = (CMidiProcessList*)pMidiEffect;

		// get the number of sub-effects and the array
		UINT ulNumEffects = pMidiProcessList->NumEffectsOf();
		PBYTE pEffectArray = pMidiProcessList->EffectArrayOf();
		assert(pEffectArray);
		if(pEffectArray == NULL) return (SFERR_INVALID_OBJECT);

		// calculate the nominal duration of the process list
		ULONG ulNominalDuration = 0;
		for(UINT i=0; i<ulNumEffects; i++)
		{
			// get the download ID of the next sub-effect
			DNHANDLE SubDnloadID = pEffectArray[i];

			// get the sub-effect
			CMidiEffect* pMidiSubEffect = g_pJoltMidi->GetEffectByID(SubDnloadID);
			assert(pMidiSubEffect);
			if (NULL == pMidiSubEffect) return (SFERR_INVALID_OBJECT);

			// get the original effect param
			PEFFECT pOriginalEffectParam = pMidiSubEffect->OriginalEffectParamOf();

			// get the original duration of this sub-effect
			ULONG ulSubEffectDuration = pOriginalEffectParam->m_Duration;
			//ASSERT(ulSubEffectDuration != 0);

			// update the nominal duration of the overall effect to reflect this sub-effect
			if(ulSubType == PL_CONCATENATE)
				ulNominalDuration += ulSubEffectDuration;
			else
				ulNominalDuration = max(ulNominalDuration, ulSubEffectDuration);
		}

		// iterate throught the list of sub-effects
		for(i=0; i<ulNumEffects; i++)
		{
			// get the download ID of the next sub-effect
			DNHANDLE SubDnloadID = pEffectArray[i];

			// get the sub-effect
			CMidiEffect* pMidiSubEffect = g_pJoltMidi->GetEffectByID(SubDnloadID);
			assert(pMidiSubEffect);
			if (NULL == pMidiSubEffect) return (SFERR_INVALID_OBJECT);

			// get the original effect param
			PEFFECT pOriginalEffectParam = pMidiSubEffect->OriginalEffectParamOf();
					
			// Direction? Note: No Direction modify for Behaviorals!!!!
			if ((dwFlags & DIEP_DIRECTION) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
			{
				// calculate the new angle
				ULONG nOriginalAngle2D = pOriginalEffectParam->m_DirectionAngle2D;
				ULONG nDeltaAngle2D = pEffect->m_DirectionAngle2D;
				ULONG nNewAngle2D = (nOriginalAngle2D + nDeltaAngle2D)%360;

				// modify the param in the midi sub-effect
				pMidiSubEffect->SetDirectionAngle(nNewAngle2D);

				// modify the parameter in the stick
				hRet = CMD_ModifyParamByIndex(INDEX2, SubDnloadID, (SHORT)nNewAngle2D);
				if (SUCCESS!=hRet) return hRet;
			}

			// Gain?
			// Gain? Note: No Gain modify for Behaviorals!!!!
			if ((dwFlags & DIEP_GAIN) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
			{
				// calculate the new gain
				ULONG nOriginalGain = pOriginalEffectParam->m_Gain;
				ULONG nOverallGain = pEffect->m_Gain;
				ULONG nNewGain = nOverallGain*nOriginalGain/100;

				// modify the param in the midi effect
				pMidiSubEffect->SetGain((BYTE)nNewGain);

				// modify the parameter in the stick
				hRet = CMD_ModifyParamByIndex(INDEX3, SubDnloadID, (SHORT) (nNewGain * MAX_SCALE));
				if (SUCCESS!=hRet) return hRet;
			}

			if(dwFlags & DIEP_DURATION)
			{
				// calculate the new duration
				ULONG nOriginalDuration = pOriginalEffectParam->m_Duration;
				ULONG nOverallDuration = pEffect->m_Duration;
				ULONG nNewDuration;
				if(nOverallDuration == (ULONG)-1)
				{
					// default length
					nNewDuration = nOriginalDuration;
				}
				else if(nOverallDuration == 0)
				{
					// infinite duration

					// for a concatenated process list we make the last effect infinite, others default
					// for a superimpose process list we make all effects infinite
					if(ulSubType == PL_CONCATENATE)
					{
						if(i == ulNumEffects-1)
						{
							// make last effect in PL infinite
							nNewDuration = 0;
						}
						else
						{
							// make other effects default
							nNewDuration = nOriginalDuration;
						}
					}
					else
					{
						assert(ulSubType == PL_SUPERIMPOSE);

						// make effects infinite
						nNewDuration = 0;
					}
				}
				else
				{
					// scale the duration (at least 1mS)
					nNewDuration = nOriginalDuration*nOverallDuration/ulNominalDuration;
					nNewDuration = max(1, nNewDuration);
				}

				// modify the parameter in the midi sub-effect
				pMidiSubEffect->SetDuration(nNewDuration);

				// modify the parameter in the stick
				if (nNewDuration != 0)
				{
					nNewDuration = (ULONG) ( (float) nNewDuration/TICKRATE);
					if (nNewDuration <= 0) 
						nNewDuration = 1;
				}		
				hRet = CMD_ModifyParamByIndex(INDEX0, SubDnloadID, (SHORT) nNewDuration);
				if (SUCCESS!=hRet) return hRet;
			}
		}
	}
	else
	{
		// modify gain and direction for the atomic effect

		// get the original effect param
		PEFFECT pOriginalEffectParam = pMidiEffect->OriginalEffectParamOf();
				
		// Direction? Note: No Direction modify for Behaviorals!!!!
		if ((dwFlags & DIEP_DIRECTION) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))
		{
			// calculate the new angle
			ULONG nOriginalAngle2D = pOriginalEffectParam->m_DirectionAngle2D;
			ULONG nDeltaAngle2D = pEffect->m_DirectionAngle2D;
			ULONG nNewAngle2D = (nOriginalAngle2D + nDeltaAngle2D)%360;

			// modify the param in the midi effect
			pMidiEffect->SetDirectionAngle(nNewAngle2D);

			// modify the parameter in the stick
			hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT)nNewAngle2D);
			if (SUCCESS!=hRet) return hRet;
		}

		// Gain?
		// Gain? Note: No Gain modify for Behaviorals!!!!
		if ((dwFlags & DIEP_GAIN) && (EF_BEHAVIOR != pOriginalEffectParam->m_Type))		
		{
			// calculate the new gain
			ULONG nOriginalGain = pOriginalEffectParam->m_Gain;
			ULONG nOverallGain = pEffect->m_Gain;
			ULONG nNewGain = nOverallGain*nOriginalGain/100;

			// modify the param in the midi effect
			pMidiEffect->SetGain((BYTE)nNewGain);

			// modify the parameter in the stick
			hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (nNewGain * MAX_SCALE));
			if (SUCCESS!=hRet) return hRet;
		}

		if(dwFlags & DIEP_DURATION)
		{
			// calculate the new duration
			ULONG nOriginalDuration = pOriginalEffectParam->m_Duration;
			ULONG nOverallDuration = pEffect->m_Duration;
			ULONG nNewDuration;
			if(nOverallDuration == (ULONG)-1)
			{
				// default length
				nNewDuration = nOriginalDuration;
			}
			else if(nOverallDuration == 0)
			{
				// infinite duration -- make effect infinite
				nNewDuration = 0;
			}
			else
			{
				// scale the duration (at least 1mS)
				nNewDuration = nOverallDuration;
			}

			// modify the parameter in the midi effect
			pMidiEffect->SetDuration(nNewDuration);

			// modify the parameter in the stick
			if (nNewDuration != 0)
			{
				nNewDuration = (ULONG) ( (float) nNewDuration/TICKRATE);
				if (nNewDuration <= 0) 
					nNewDuration = 1;
			}		
			hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, (SHORT) nNewDuration);
			if (SUCCESS!=hRet) return hRet;
		}

	}

	return hRet;
}


//
// --- System Exclusive Command:PROCESS_DATA
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_ProcessEffect
// Purpose:    	Processes the List
//				IN ULONG ulButtonPlayMask
//				IN OUT PDNHANDLE pDnloadID	- Storage for new Download ID
//				IN int 	nNumEffects			- Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	- Processing mode
//				IN PDNHANDLE pPListArray	- Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				E_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pPListArray:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  
//
//  Byte 0	= MIDI_CMD_EFFECT + Channel #
//									D7 D6  D5  D4  D3  D2  D1  D0
//									-- --  --  --  --  --  --  --
//  Byte 1	= Low byte of Force		 0 
//  Byte 2	= High byte of Force	 0 
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
	IN ULONG ulAction)
{
	HRESULT hRet = SUCCESS;
	PPROCESS_LIST_SYS_EX lpData;
	CMidiProcessList *pMidiProcessList;
	assert(pDnloadID && pPListArray);
	if ((NULL  == pDnloadID) || (NULL == pPListArray))
		return (SFERR_INVALID_PARAM);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	DNHANDLE DnloadID = *pDnloadID;

// If Create New, then create a new object, 
// else, update the existing Effect object.

// Build the special Parameter
	PLIST PList;
	PList.ulNumEffects = (ULONG) nNumEffects;
	PList.ulProcessMode = ulProcessMode; 
	PList.pEffectArray = pPListArray;
	PList.ulAction = ulAction;	

	if (NULL == DnloadID)	// New, Make a new object
	{
		// make sure we are not trying to create a PL within a PL
		for(int i=0; i<nNumEffects; i++)
		{
			// get the next sub-effect
			int nID = pPListArray[i];
			CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DNHANDLE(nID));
			if(pMidiEffect == NULL)
				return SFERR_INVALID_PARAM;

			// make sure it is not a process list
			ULONG ulSubType = pMidiEffect->SubTypeOf();
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_INVALID_PARAM;
		}

		// create the CMidiProcessList object
		pMidiProcessList = new CMidiProcessList(ulButtonPlayMask, &PList);
		assert(pMidiProcessList);
		pMidiProcessList->SetEffectID(NEW_EFFECT_ID);
		pMidiProcessList->SetSubType(ulProcessMode);
	}
	else	// Modify existing
	{
		pMidiProcessList = (CMidiProcessList *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiProcessList);
		if (NULL == pMidiProcessList) return (SFERR_INVALID_OBJECT);
		pMidiProcessList->SetEffectID((BYTE) DnloadID);
	}

	// Fill in the parameters
	pMidiProcessList->SetParams(ulButtonPlayMask, &PList);
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER))
		pMidiProcessList->SetDuration(0);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PPROCESS_LIST_SYS_EX) pMidiProcessList->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	int nSizeBuf = sizeof(SYS_EX_HDR) + 5 + nNumEffects + 2;
	pMidiProcessList->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiProcessList->SendPacket(pDnloadID, nSizeBuf);
	if (SUCCESS != hRet) // Create NEW, Failure
	{
		delete pMidiProcessList;
	}
	else
	{
		// workaround to FW bug #1211, modify PL type with same PL type
		ULONG ulSubType;
		if (PL_SUPERIMPOSE == ulProcessMode) 
			ulSubType = PLIST_SUPERIMPOSE; 
		else
			ulSubType = PLIST_CONCATENATE;  


		hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, (SHORT) ulSubType);
	}

	return (hRet);
}

//
// --- System Exclusive Command:PROCESS_DATA
//
// *** ---------------------------------------------------------------------***
// Function:   	CMD_VFXProcessEffect
// Purpose:    	Processes the List
//				IN ULONG ulButtonPlayMask
//				IN OUT PDNHANDLE pDnloadID	- Storage for new Download ID
//				IN int 	nNumEffects			- Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	- Processing mode
//				IN PDNHANDLE pPListArray	- Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				E_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pPListArray:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  
//
//  Byte 0	= MIDI_CMD_EFFECT + Channel #
//									D7 D6  D5  D4  D3  D2  D1  D0
//									-- --  --  --  --  --  --  --
//  Byte 1	= Low byte of Force		 0 
//  Byte 2	= High byte of Force	 0 
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
	IN ULONG ulAction)
{
	HRESULT hRet = SUCCESS;
	PPROCESS_LIST_SYS_EX lpData;
	CMidiVFXProcessList *pMidiProcessList;
	assert(pDnloadID && pPListArray);
	if ((NULL  == pDnloadID) || (NULL == pPListArray))
		return (SFERR_INVALID_PARAM);

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	DNHANDLE DnloadID = *pDnloadID;

// If Create New, then create a new object, 
// else, update the existing Effect object.

// Build the special Parameter
	PLIST PList;
	PList.ulNumEffects = (ULONG) nNumEffects;
	PList.ulProcessMode = ulProcessMode; 
	PList.pEffectArray = pPListArray;
	PList.ulAction = ulAction;	

	if (NULL == DnloadID)	// New, Make a new object
	{
		// make sure we are not trying to create a PL within a PL
		for(int i=0; i<nNumEffects; i++)
		{
			// get the next sub-effect
			int nID = pPListArray[i];
			CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(DNHANDLE(nID));
			if(pMidiEffect == NULL)
				return SFERR_INVALID_PARAM;

			// make sure it is not a process list
			ULONG ulSubType = pMidiEffect->SubTypeOf();
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_INVALID_PARAM;
		}

		pMidiProcessList = new CMidiVFXProcessList(ulButtonPlayMask, &PList);
		assert(pMidiProcessList);
		if (!pMidiProcessList) return (SFERR_DRIVER_ERROR);

		pMidiProcessList->SetEffectID(NEW_EFFECT_ID);
		pMidiProcessList->SetSubType(ulProcessMode);
	}
	else	// Modify existing
	{
		pMidiProcessList = (CMidiVFXProcessList *) g_pJoltMidi->GetEffectByID(DnloadID);
		assert(pMidiProcessList);
		if (NULL == pMidiProcessList) return (SFERR_INVALID_OBJECT);
		pMidiProcessList->SetEffectID((BYTE) DnloadID);
	}

	// Fill in the parameters
	pMidiProcessList->SetParams(ulButtonPlayMask, &PList);
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER))
		pMidiProcessList->SetDuration(0);

	// Generate Sys_Ex packet then prepare for output	
	lpData = (PPROCESS_LIST_SYS_EX) pMidiProcessList->GenerateSysExPacket();
	assert(lpData);
	if (!lpData) return (SFERR_DRIVER_ERROR);

	int nSizeBuf = sizeof(SYS_EX_HDR) + 5 + nNumEffects + 2;
	pMidiProcessList->SetMidiBufferPtr((LPSTR) g_pJoltMidi->PrimaryBufferPtrOf());
	hRet = pMidiProcessList->SendPacket(pDnloadID, nSizeBuf);
	if (SUCCESS != hRet) // Create NEW, Failure
	{
		delete pMidiProcessList;
	}
	else
	{
		// workaround to FW bug #1211, modify PL type with same PL type
		ULONG ulSubType;
		if (PL_SUPERIMPOSE == ulProcessMode) 
			ulSubType = PLIST_SUPERIMPOSE; 
		else
			ulSubType = PLIST_CONCATENATE;  


		hRet = CMD_ModifyParamByIndex(INDEX0, *pDnloadID, (SHORT) ulSubType);
	}

	return (hRet);
}

/****************************************************************************

    FUNCTION:   ModifyEffectParams

	PARAMETERS:	DNHANDLE DnloadID	- Download ID
				PEFFECT pEffect		- Ptr to EFFECT structure
				DWORD dwFlags		- Flags indicating which changed

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Modifies EFFECT parameters

 Algorithm:

****************************************************************************/
HRESULT ModifyEffectParams(
	IN DNHANDLE DnloadID,
	IN PEFFECT pEffect,
	IN DWORD dwFlags)
{	 
	HRESULT hRet = SUCCESS;
	// Check dwFlags for each parameter that changed.
	// Duration?
	ULONG ulDuration = pEffect->m_Duration;	
	if (dwFlags & DIEP_DURATION)
	{
		if (ulDuration != 0)
		{
			ulDuration = (ULONG) ( (float) ulDuration/TICKRATE);
			if (ulDuration <= 0) 
				ulDuration = 1;
		}		
		hRet = CMD_ModifyParamByIndex(INDEX0, DnloadID, (SHORT) ulDuration);
		if (SUCCESS!=hRet) return hRet;
	}

	// ButtonPlayback?
	if (dwFlags & DIEP_TRIGGERBUTTON)
	{
		hRet = CMD_ModifyParamByIndex(INDEX1, DnloadID, (SHORT) pEffect->m_ButtonPlayMask);
		if (SUCCESS!=hRet) return hRet;
	}

	// Direction?
	if (dwFlags & DIEP_DIRECTION)
	{
		hRet = CMD_ModifyParamByIndex(INDEX2, DnloadID, (SHORT) pEffect->m_DirectionAngle2D);
		if (SUCCESS!=hRet) return hRet;
	}

	// Gain?
	if (dwFlags & DIEP_GAIN)
	{
		hRet = CMD_ModifyParamByIndex(INDEX3, DnloadID, (SHORT) (pEffect->m_Gain * MAX_SCALE));
		if (SUCCESS!=hRet) return hRet;
	}

	// Force Output Rate
	if (dwFlags & DIEP_SAMPLEPERIOD )
	{
		hRet = CMD_ModifyParamByIndex(INDEX4, DnloadID, (SHORT) (pEffect->m_ForceOutputRate));
		if (SUCCESS!=hRet) return hRet;
	}

	return (hRet);
}


/****************************************************************************

    FUNCTION:   ModifyEnvelopeParams

	PARAMETERS:	CMidiSynthesized * pMidiEffect - Ptr to Effect object
				DNHANDLE DnloadID	- Download ID
				PENVELOPE pEnvelope - Ptr to ENVELOPE structure
				DWORD dwFlags		- Flags indicating which changed

	RETURNS:	SUCCESS or ERROR code

   	COMMENTS:	Modifies ENVELOPE parameters

 Algorithm:

****************************************************************************/
HRESULT ModifyEnvelopeParams(
	IN CMidiSynthesized *pMidiEffect,
	IN DNHANDLE DnloadID,
	IN ULONG ulDuration,
	IN PENVELOPE pEnvelope,
	IN DWORD dwFlags)
{
	HRESULT hRet=SUCCESS;
	ULONG ulTimeToSustain; 
	ULONG ulTimeToDecay;

	// Envelope?
	if (dwFlags & DIEP_ENVELOPE)
	{
		if (PERCENTAGE == pEnvelope->m_Type)
		{
			ulTimeToSustain = (ULONG) ((pEnvelope->m_Attack * ulDuration) /100.);
			ulTimeToDecay   = (ULONG) ((pEnvelope->m_Attack + pEnvelope->m_Sustain)
									 * ulDuration /100.);
		}
		else	// TIME option envelope
		{
			ulTimeToSustain = (ULONG) (pEnvelope->m_Attack);
			ulTimeToDecay   = (ULONG) (pEnvelope->m_Attack + pEnvelope->m_Sustain);
		}
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

// REVIEW: Do a parameters changed check in order to speed this up - TOO MANY BYTES!!!
		if (pEnvelope->m_Attack != (pMidiEffect->EnvelopePtrOf())->m_Attack)
		{
			hRet = CMD_ModifyParamByIndex(INDEX7,  DnloadID, (SHORT) ulTimeToSustain);	
			if (SUCCESS!=hRet) return hRet;
		}
		if (   (pEnvelope->m_Attack != (pMidiEffect->EnvelopePtrOf())->m_Attack)
			|| (pEnvelope->m_Sustain != (pMidiEffect->EnvelopePtrOf())->m_Sustain) )
		{
			hRet = CMD_ModifyParamByIndex(INDEX8,  DnloadID, (SHORT) ulTimeToDecay);	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_StartAmp != (pMidiEffect->EnvelopePtrOf())->m_StartAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX9,  DnloadID, (SHORT) (pEnvelope->m_StartAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_SustainAmp != (pMidiEffect->EnvelopePtrOf())->m_SustainAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX10, DnloadID, (SHORT) (pEnvelope->m_SustainAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}

		if (pEnvelope->m_EndAmp != (pMidiEffect->EnvelopePtrOf())->m_EndAmp)
		{
			hRet = CMD_ModifyParamByIndex(INDEX11, DnloadID, (SHORT) (pEnvelope->m_EndAmp * MAX_SCALE));	
			if (SUCCESS!=hRet) return hRet;
		}
	}
	return (hRet);
}

/****************************************************************************

    FUNCTION:   MapEnvelope

	PARAMETERS:	ULONG ulDuration		- Total Duration
				ULONG dwMagnitude
				ULONG * pMaxLevel
				LPDIENVELOPE pIDEnvelope- Ptr to DIENVELOPE structure
				PENVELOPE pEnvelope		- SWForce ENVELOPE

	RETURNS:	none

   	COMMENTS:	Maps DIENVELOPE to ENVELOPE

 Algorithm:

****************************************************************************/
void MapEnvelope( 
	IN ULONG ulDuration,
	IN ULONG dwMagnitude,
	IN ULONG * pMaxLevel,
	IN LPDIENVELOPE pDIEnvelope, 
	IN OUT PENVELOPE pEnvelope)
{
	ULONG ulMaxLevel = *pMaxLevel;
	if (pDIEnvelope)
	{
		// if there is an envelope, MaxLevel must look at attack/fade
		ulMaxLevel = max(ulMaxLevel, pDIEnvelope->dwAttackLevel);
		ulMaxLevel = max(ulMaxLevel, pDIEnvelope->dwFadeLevel);

		pEnvelope->m_Type = TIME;

		// find attack/sustain/decay which sum to ulDuration
		pEnvelope->m_Attack = pDIEnvelope->dwAttackTime/SCALE_TIME;
		pEnvelope->m_Decay = pDIEnvelope->dwFadeTime/SCALE_TIME;
// REVIEW: is this correct for ulDuration == 0?
		if(ulDuration != 0)
			pEnvelope->m_Sustain = ulDuration - pEnvelope->m_Attack - pEnvelope->m_Decay;
		else
			pEnvelope->m_Sustain = 0;

		// convert to StartAmp/SustainAmp/EndAmp, which is a % of the magnitude
		if(ulMaxLevel != 0)
		{
			pEnvelope->m_StartAmp = pDIEnvelope->dwAttackLevel*100/ulMaxLevel;
			pEnvelope->m_SustainAmp = dwMagnitude*100/ulMaxLevel;
			pEnvelope->m_EndAmp = pDIEnvelope->dwFadeLevel*100/ulMaxLevel;
		}
		else
		{
			pEnvelope->m_StartAmp = pDIEnvelope->dwAttackLevel;
			pEnvelope->m_SustainAmp = 100;
			pEnvelope->m_EndAmp = pDIEnvelope->dwFadeLevel;
		}
	}
	else // No Envelope
	{
		pEnvelope->m_Type = TIME;
		pEnvelope->m_Attack = 0;
		pEnvelope->m_Sustain = ulDuration;
		pEnvelope->m_Decay = 0;

		pEnvelope->m_StartAmp = 0;
		pEnvelope->m_SustainAmp = 100;
		pEnvelope->m_EndAmp = 0;
	}
	*pMaxLevel = ulMaxLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\hau_midi.hpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for HAU_MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
			16-Mar-99		waltw	Remove unused DetectMidiDevice declaration
			16-Mar-99		waltw	DEFAULT_GET_DATA_PACKET_DELAY changed from
									1 to 2. 1 worked OK for Win9x, but NT5
									requires a value of 2. See NT RAID# 295373
									(Jolt resets after crash in FlightSym 98)
			29-Mar-99		waltw	Fixed typo by restoring DEFAULT_GET_DATA_PACKET_DELAY
									to 1 and bumping DEFAULT_GET_ID_PACKET_DELAY -> 2
			29-Mar-99		waltw	& dennisle - bump DEFAULT_GET_STATUS_PACKET_DELAY ->2
									This fix may also fix the multi-proc issue.
        
****************************************************************************/
#ifndef _HAU_MIDI_SEEN
#define _HAU_MIDI_SEEN
#include "DX_MAP.hpp"

#define MAX_EFFECT_IDS				32
#define	NEW_EFFECT_ID				0x7f
#define SYSTEM_EFFECT_ID			0x7f
#define SYSTEM_RTCSPRING_ID			0
#define SYSTEM_FRICTIONCANCEL_ID	1
#define SYSTEM_RTCSPRING_ALIAS_ID	0x7e	// Due to internal ID=0 means create new

#define MAX_MIDI_CHANNEL		16
#define DEFAULT_MIDI_CHANNEL	5
#define DEFAULT_MIDI_PORTIO		0x330

#define COMM_WINMM					0x01
#define COMM_MIDI_BACKDOOR			0x02
#define COMM_SERIAL_BACKDOOR		0x03
#define COMM_SERIAL_FILE			0x04
#define MASK_OVERRIDE_MIDI_PATH		0x80000000
#define MASK_SERIAL_BACKDOOR		0x40000000
#define COMM_SERIAL1			1			// COMM Port 1
#define MIN_COMMSERIAL			1
#define MAX_COMMSERIAL			4

#define DEFAULT_JOLT_FORCE_RATE	100
#define DEFAULT_PERCENT			10000

#define MAX_SYS_EX_BUFFER_SIZE	1024		// Maximum Primary buffer size
#define DIFFERENCE_THRESHOLD	32			// Threshold to using absolute data
#define DIFFERENCE_BIT			0x40		// Bit to set for Difference data
#define MAX_MIDI_WAVEFORM_PACKET_SIZE	(256-20)	// Midi SYS_EX packet size
#define MAX_MIDI_WAVEFORM_DATA_SIZE	100		// Midi SYS_EX Data sample window size
#define	MAX_PLIST_EFFECT_SIZE	8			// 8 effects in a PList
#define MAX_PLIST_EFFECT		8			// 8 PLists allowed

#define MAX_INDEX				15
#define MAX_SIZE_SNAME			64								

#define MS_MANUFACTURER_ID		0x0a01 
#define JOLT_PRODUCT_ID			0x01         // REVIEW: Is this correct?

#define DRIVER_ERROR_NO_MIDI_INPUT	0x100	// No open Midi input device
#define DRIVER_ERROR_MIDI_OUTPUT	0x101	// Error outputing to Midi output


//
// --- RTC Spring defaults
//
#define	DEFAULT_RTC_KX		80
#define	DEFAULT_RTC_KY		80
#define	DEFAULT_RTC_X0		0
#define	DEFAULT_RTC_Y0		0
#define	DEFAULT_RTC_XSAT	96
#define	DEFAULT_RTC_YSAT	96
#define	DEFAULT_RTC_XDBAND	16
#define	DEFAULT_RTC_YDBAND	16

//
// --- Effect status code from Device
//
#define SWDEV_STS_EFFECT_STOPPED	0x01
#define SWDEV_STS_EFFECT_RUNNING	0x02

//
// --- Bitmasks for Device Status
//
#define BANDWIDTH_MASK			0x200		// Bandwidth bit
#define COMM_MODE_MASK			0x100		// 0 = MIDI, 1 = Serial
#define AC_FAULT_MASK			0x80		// 1= AC brick fault
#define HOTS_MASK				0x20		// Hands on Throttle Sensor
#define RESET_MASK				0x10		// 1 = Power On Reset detected
#define SHUTDOWN_MASK			0x08		// 0 = normal Shutdown, else 1 = Soft Reset

#define MINIMUM_BANDWIDTH		1
#define MAXIMUM_BANDWIDTH		100			// in %

//
// --- ERROR CODES from Device
//
#define DEV_ERR_SUCCESS			0x00	// Success
#define DEV_ERR_INVALID_ID		0x01	// Effect ID is invalid or not found
#define DEV_ERR_INVALID_PARAM	0x02	// Invalid parameter in data structure
#define DEV_ERR_CHECKSUM		0x03	// Invalid checksum
#define DEV_ERR_TYPE_FULL		0x04	// No more room for specified Effect
#define DEV_ERR_UNKNOWN_CMD		0x05	// Unrecognized command
#define DEV_ERR_PLAYLIST_FULL	0x06	// Play List is full, cannot play any
										// more effects
#define DEV_ERR_PROCESS_LIST_FULL 0x07	// Process List is full


//
// --- MIDI Command codes
//
#define MODIFY_CMD			0xA0
#define EFFECT_CMD	        0xB0
#define SYSTEM_CMD	        0xC0
#define STATUS_CMD			0xD0
#define RESPONSE_CMD	    0xE0		// Device to Host
#define SYS_EX_CMD			0xF0
#define ASSIGN_CMD	        0xF0
#define DNLOAD_CMD	        0xF0
#define UPLOAD_CMD	        0xF0
#define PROCESS_CMD	        0xF0
#define MIDI_EOX			0xF7

//
// --- Second byte sub-commands
//
// --- MIDI_CMD_EFFECT second byte sub-command
#define	NO_OVERRIDE         	0x00
#define DESTINATION_X			0x01
#define DESTINATION_Y			0x02
#define DESTINATION_XY			0x03
#define	PUT_FORCE_X				0x01
#define	PUT_FORCE_Y				0x02
#define	PUT_FORCE_XY			0x03
#define PLAY_EFFECT_SOLO		0x00
#define DESTROY_EFFECT			0x10	
#define	PLAY_EFFECT_SUPERIMPOSE	0x20
#define	STOP_EFFECT				0x30
#define SET_INDEX				0x40


// --- MIDI_CMD_SYSTEM second byte sub-command
#define SWDEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
#define SWDEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
#define SWDEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
#define SWDEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
#define SWDEV_PAUSE		5L		// All Effects are "Paused"
#define SWDEV_STOP_ALL	6L		// Stops all Effects. 
#define SWDEV_KILL_MIDI	7L		// Kills (tri-states) MIDI

// Remap for dinput modes
#define DEV_RESET       SWDEV_SHUTDOWN
#define DEV_FORCE_ON    SWDEV_FORCE_ON
#define DEV_FORCE_OFF   SWDEV_FORCE_OFF
#define DEV_CONTINUE    SWDEV_CONTINUE
#define DEV_PAUSE       SWDEV_PAUSE
#define DEV_STOP_ALL    SWDEV_STOP_ALL

//
// --- ACK and NACK 2nd byte from RESPONSE_CMD
//
#define ACK                 0x00
#define NACK                0x7f
#define ACKNACK_TIMEOUT		50			// 50*1msec timeout = 50msecs
#define ACKNACK_EFFECT_STATUS_TIMEOUT 1	// 1ms Timeout
#define MAX_RETRY_COUNT		10			// Retry count for comm NACKS
//#define MAX_GET_STATUS_PACKET_RETRY_COUNT 30
#define MAX_GET_STATUS_PACKET_RETRY_COUNT 10
#define SHORT_MSG_TIMEOUT	1
#define LONG_MSG_TIMEOUT	2
#define POWER_ON_MSG		0x007F00E5UL
#define RESPONSE_NACK		0x007FE0UL	// Example for MIDI channel 0.
#define RESPONSE_ACK		0x0000E0UL	// " "

// timing delays, in mS
#define DEFAULT_SHORT_MSG_DELAY				1		/* currently unused */
#define DEFAULT_LONG_MSG_DELAY				1
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	1
#define DEFAULT_SHUTDOWN_DELAY				10
#define DEFAULT_HWRESET_DELAY				20		
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	1
#define DEFAULT_GET_EFFECT_STATUS_DELAY		2
#define DEFAULT_GET_DATA_PACKET_DELAY		1
#define DEFAULT_GET_STATUS_PACKET_DELAY		2
#define DEFAULT_GET_ID_PACKET_DELAY			2
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY			0
#define DEFAULT_FORCE_OUT_DELAY				1
#define DEFAULT_DESTROY_EFFECT_DELAY		1
#define DEFAULT_FORCE_OUT_MOD				1

typedef struct _DELAY_PARAMS
{
	DWORD	dwBytes;
	DWORD	dwDigitalOverdrivePrechargeCmdDelay;
	DWORD	dwShutdownDelay;
	DWORD	dwHWResetDelay;
	DWORD	dwPostSetDeviceStateDelay;
	DWORD	dwGetEffectStatusDelay;
	DWORD	dwGetDataPacketDelay;
	DWORD	dwGetStatusPacketDelay;
	DWORD	dwGetIDPacketDelay;
	DWORD	dwGetStatusGateDataDelay;
	DWORD	dwSetIndexDelay;
	DWORD	dwModifyParamDelay;
	DWORD	dwForceOutDelay;
	DWORD	dwShortMsgDelay;
	DWORD	dwLongMsgDelay;
	DWORD	dwDestroyEffectDelay;
	DWORD	dwForceOutMod;
} DELAY_PARAMS, *PDELAY_PARAMS;

void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams);

//
// --- Format of Download command
//     Bytes in SYS EX body (starting from Byte 5 to (n-1)
//
// Byte     Contents
// -----    ---------
//  0       bOpCode			- see detail on OPCODE below
//  1       bSubType		- e.g. ET_UD_WAVEFORM, etc.
//	2		bEffectID		- Effect ID, 0x7f = Create New
//  3       bDurationL		- Low 7 bits duration in 2ms ticks, 0=Forever
//  4       bDurationH		- High 7 bits

//  5       bAngleL			- Low 7 bits Direction Angle
//  7	    bAngleH			- High 2 bits Direction Angle
//	8		bGain			- 7 bits Gain 1 - 100%
//	9		bButtonPlayL	- Low 7 bits button mask
//	10		bButtonPlayH	- High 2 bits button mask
//	11		bForceOutRateL	- Low 7 bits, 1 to 500 Hz
//	12		bForceOutRateH	- High 2 bits
//	13		bLoopCountL		- Low 7 bits Loop Count, Normally 1
//  14      bLoopCountH		- High 7 bits Loop count
//  		
//
//  The next block is optional and starts at Byte 15
//	15		bAttack			- %tage
//	16		bSustain;		- %tage
//  17 		bDecay;			- %tage
//
//  Otherwise, Type specific Parameters start at either Byte 15 or 18
//	18		Type specific parameter bytes here
//	  
//
//  ...
//  n       7 bits Checksum of bytes 0 to n
//
//
//
// --- MIDI_CMD_ASSIGN, MIDI_CMD_DNLOAD, MIDI_CMD_PROCESS
//     second byte sub-command
// Opcode is defined as follows:
// 7  6  5  4  3  2  1  0 
// -  -  -  -  -  -  -  -
// 0  c  c  c  a  a  d  d
//
// where:
//    c  c  c
//    -  -  -
//    0  0  0	- EXTEND_ESCAPE
//	  0  0  1	- MIDI_ASSIGN
//	  0  1  0	- DNLOAD_DATA
//	  0  1  1	- UPLOAD_DATA
//	  1  0  0	- PROCESS_DATA
//	  1  0  1	- reserved
//	  1  1  0	- reserved
//	  1  1  1	- reserved
// 
// and:
//             a  a
//             -  -
//             0  0 - DL_PLAY_STORE only after download
//             0  1 - DL_PLAY_SUPERIMPOSE right after download
//             1  0 - DL_PLAY_SOLO right after download
//			   1  1 - reserved
// and:
//		             d  d
//					 -  -
//					 0  0	- reserved
//					 0  1	- X-Axis
//					 1  0	- Y-Axis
//					 1  1	- X and Y-Axis
//

#define EXTEND_ESCAPE		0x00
#define MIDI_ASSIGN			0x10
#define DNLOAD_DATA			0x20
#define UPLOAD_DATA			0x30
#define PROCESS_DATA		0x40
#define GET_FORCE_EFFECT_VALUE	0x50

// --- Download sub-commands
//
#define DL_PLAY_STORE       0x00
#define DL_PLAY_SUPERIMPOSE 0x04
#define DL_PLAY_SOLO        0x08

//
// --- Process List sub-commands
//
#define PLIST_CONCATENATE      0x01 //0x11	// Temp. s/b 0x01
#define PLIST_SUPERIMPOSE      0x02 //0x12 // Temp. s/b 0x02


//
// --- Special UD_EFFECT parameters
//
#define UD_DIFFERENCE_DATA  0x40


//
// --- Bitmap Indexes into Parameter storage array
//
#define	INDEX0_MASK	 0x00000001L
#define INDEX1_MASK	 0x00000002L
#define INDEX2_MASK	 0x00000004L
#define INDEX3_MASK	 0x00000008L
#define INDEX4_MASK	 0x00000010L
#define INDEX5_MASK	 0x00000020L
#define	INDEX6_MASK	 0x00000040L
#define INDEX7_MASK	 0x00000080L
#define INDEX8_MASK	 0x00000100L
#define INDEX9_MASK	 0x00000200L
#define INDEX10_MASK 0x00000400L
#define INDEX11_MASK 0x00000800L
#define INDEX12_MASK 0x00001000L
#define INDEX13_MASK 0x00002000L
#define INDEX14_MASK 0x00004000L
#define INDEX15_MASK 0x00008000L

#define	INDEX0	0L
#define INDEX1	1L
#define INDEX2	2L
#define INDEX3	3L
#define INDEX4	4L
#define INDEX5	5L
#define	INDEX6	6L
#define INDEX7	7L
#define INDEX8	8L
#define INDEX9	9L
#define INDEX10 10L
#define INDEX11 11L
#define INDEX12 12L
#define INDEX13 13L
#define INDEX14 14L
#define INDEX15 15L

	
//
// --- Effect types
//

#define ET_UD_WAVEFORM      	1   // User Defined Waveform

#define ET_SE_SINE				2	// Sinusoidal
#define ET_SE_COSINE			3	// Cosine
#define ET_SE_SQUARELOW			4	// Square starting Low	
#define ET_SE_SQUAREHIGH		5	// Square starting High	
#define ET_SE_RAMPUP        	6   // Ramp UP			    
#define ET_SE_RAMPDOWN      	7   // Ramp Down		    
#define	ET_SE_TRIANGLEUP    	8	// Triangle rising	    
#define ET_SE_TRIANGLEDOWN		9	// Triangle falling
#define ET_SE_SAWTOOTHUP		10	// Sawtooth rising 
#define ET_SE_SAWTOOTHDOWN		11	// Sawtooth falling

#define ET_BE_DELAY				12  // NOP delay
#define ET_BE_SPRING        	13  // Springs
#define ET_BE_DAMPER        	14  // Dampers
#define ET_BE_INERTIA       	15  // Gravity
#define ET_BE_FRICTION      	16  // Friction
#define ET_BE_WALL 				17 	// Wall (bumper)
#define ET_SE_CONSTANT_FORCE	18	// Constant Force

#define ET_PL_CONCATENATE		19	// Concatenate process list
#define ET_PL_SUPERIMPOSE		20	// Superimpose process list

// ROM Effect IDS
#define ET_RE_ROMID1			32
#define ET_RE_ROMID2			33
#define ET_RE_ROMID3			34
#define ET_RE_ROMID4			35
#define ET_RE_ROMID5			36
#define ET_RE_ROMID6			37
#define ET_RE_ROMID7			38
#define ET_RE_ROMID8			39
#define ET_RE_ROMID9			40
#define ET_RE_ROMID10			41
#define ET_RE_ROMID11			42
#define ET_RE_ROMID12			43
#define ET_RE_ROMID13			44
#define ET_RE_ROMID14			45
#define ET_RE_ROMID15			46
#define ET_RE_ROMID16			47
#define ET_RE_ROMID17			48
#define ET_RE_ROMID18			49
#define ET_RE_ROMID19			50
#define ET_RE_ROMID20			51
#define ET_RE_ROMID21			52
#define ET_RE_ROMID22			53
#define ET_RE_ROMID23			54
#define ET_RE_ROMID24			55
#define ET_RE_ROMID25			56
#define ET_RE_ROMID26			57
#define ET_RE_ROMID27			58
#define ET_RE_ROMID28			59
#define ET_RE_ROMID29			60
#define ET_RE_ROMID30			61
#define ET_RE_ROMID31			62
#define ET_RE_ROMID32			63
#define ET_RE_ROMID33			64
#define ET_RE_ROMID34			65
#define ET_RE_ROMID35			66
#define ET_RE_ROMID36			67
#define ET_RE_ROMID37			68

 								
// more to be defined....		
 
//
// Effect IDs as defined in Jolt device
//
#define	EFFECT_ID_RTC_SPRING		0	// Built-in Return To Center Virtual Spring
#define	EFFECT_ID_FRICTIONCANCEL	1	// Friction cancellation


//
// --- Process List Structure
//
typedef struct _PLIST {
	ULONG	ulNumEffects;
	ULONG	ulProcessMode;	// PLIST_SUPERIMPOSE or PLIST_CONCATENATE
	PDNHANDLE pEffectArray;	// Effect ID[0} . . .
	ULONG	ulAction;
	ULONG	ulDuration;
} PLIST, *PPLIST;

//
// --- Behavioral Effects Structure
//
typedef struct _BE_XXX {
	LONG	m_XConstant;	//(KX/BX/MX/FX/Wall type)	
	LONG	m_YConstant;	//(KY/BY/MY/FY/KWall)
	LONG	m_Param3;		//(CX/VX/AX/Wall angle)
	LONG	m_Param4;		//(CY/VYO/AY/Wall distance)
} BE_XXX, *PBE_XXX;

//
// --- SysEx Messages
//
typedef struct _SYS_EX_HDR {
	BYTE		m_bSysExCmd;	// SysEx Fx command
	BYTE		m_bEscManufID;	// Escape to long Manufac. ID, s/b 0
	BYTE		m_bManufIDL;	// Low byte
	BYTE		m_bManufIDH;	// High byte
	BYTE		m_bProdID;		// Product ID
} SYS_EX_HDR, *PSYS_EX_HDR;

// --- Common Effect parameters
typedef struct _MIDI_EFFECT {
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bAngleL;		// Low 7 bits Direction Angle
	BYTE		bAngleH;		// High 2 bits Direction Angle
	BYTE		bGain;			// 7 bits Gain 1 - 100%
	BYTE		bForceOutRateL;	// Low 7 bits, 1 to 500 Hz
	BYTE		bForceOutRateH;	// High 2 bits
	BYTE		bPercentL;		// Low 7 bits Percent of waveform 1 to 10000
	BYTE		bPercentH;		// High 7 bits Loop Count
} MIDI_EFFECT, *PMIDI_EFFECT;

// --- Envelope
typedef struct MIDI_ENVELOPE {
	BYTE		bAttackLevel;	// Initial Attack amplitude 0 to +127
	BYTE		bSustainL;		// time to Sustain in 2ms ticks
	BYTE		bSustainH;		// 
	BYTE		bSustainLevel;	// Amplitude level to sustain
	BYTE		bDecayL;		// time to Decay in 2ms ticks 
	BYTE		bDecayH;
	BYTE		bDecayLevel;	// Amplitude level to decay
} MIDI_ENVELOPE, *PMIDI_ENVELOPE;
 
// --- Midi Assign
typedef struct _MIDI_ASSIGN_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: MIDI_ASSIGN
	BYTE		bChannel;		// Midi channel 1-16
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_ASSIGN_SYS_EX, *PMIDI_ASSIGN_SYS_EX;

// --- Get Effect Force Value at a tick sample time
typedef struct _MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX  {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: GET_EFFECT_FORCE_VALUE
	BYTE		bEffectID;		// Effect ID
	BYTE		bSampleTimeL;	// Low 7 bits in 2ms ticks
	BYTE		bSampleTimeH;	// High 7 bits in 2ms ticks
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX, *PMIDI_GET_EFFECT_FORCE_VALUE_SYS_EX;


// --- Note: For the following, if bEffectID = 0x7f, then New, else Modify
// --- Download Data - Synthesized Waveform
typedef struct _SE_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// ex: ET_SE_SINE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
// SE Parameters
	BYTE		bFreqL;			// Low 7 bits Frequency 1-2048Hz
	BYTE		bFreqH;			// High 4 bits	  
	BYTE		bMaxAmpL;		// Low 7 bits Maximum Amplitude	+/- 100%
	BYTE		bMaxAmpH;		// High 1 bit
	BYTE		bMinAmpL;		// Low 7 bits Minimum Amplitude	+/- 100%
	BYTE		bMinAmpH;		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} SE_WAVEFORM_SYS_EX, *PSE_WAVEFORM_SYS_EX;

// --- Download Data - NOP Delay
typedef struct _NOP_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID, 0x7F = Create NEw
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bChecksum;
	BYTE		bEOX;
} NOP_SYS_EX, *PNOP_SYS_EX;

// --- Download Data - Behavioral SysEx 
typedef struct _BEHAVIORAL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_SPRING
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_XXX Parameters
	BYTE		bXConstantL;	// Low 7 bits K	(in +/- 100%) X-Axis
	BYTE		bXConstantH;	// High 1 bit K
	BYTE		bYConstantL;	// Low 7 bits K	(in +/- 100%) Y-Axis
	BYTE		bYConstantH;	// High 1 bit K
	BYTE		bParam3L;   	// Low 7 bits Axis center (in +/- 100%)	X-Axis
	BYTE		bParam3H;  		// High 1 bit
	BYTE		bParam4L;   	// Low 7 bits Axis center (in +/- 100%)	Y-Axis
	BYTE		bParam4H;  		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} BEHAVIORAL_SYS_EX, *PBEHAVIORAL_SYS_EX;


// --- Download Data - Friction SysEx
typedef struct _FRICTION_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_FRICTION Parameters
	BYTE		bXFConstantL;	// Low 7 bits F	(in +/- 100%) X-Axis
	BYTE		bXFConstantH;	// High 1 bit F
	BYTE		bYFConstantL;	// Low 7 bits F	(in +/- 100%) Y-Axis
	BYTE		bYFConstantH;	// High 1 bit F
	BYTE		bChecksum;
	BYTE		bEOX;
} FRICTION_SYS_EX, *PFRICTION_SYS_EX;


// --- Download Data - WALL SysEx
#define INNER_WALL				0	// Wall face to center
#define	OUTER_WALL				1	// Wall face away from center

typedef struct _WALL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: e.g. EF_BE_WALL
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_SPRING Parameters
	BYTE		bWallType;		// INNER_WALL or OUTER_WALL
	BYTE		bWallConstantL;	// Low 7 bits: Similar to Spring Constant.  
								//   Value is from +/- 100%. 
	BYTE		bWallConstantH;	// High 1 bit
	BYTE		bWallAngleL;	// Low 7 bits: 0 to 359 degrees
								//   For simple vertical and horizontal walls, 
								//   this value should be set to 0, 90,  180, 270
	BYTE		bWallAngleH;	// Low 2 bit
	BYTE		bWallDistance;  // 7 bits: Distance from Center of stick 0 to 100
	BYTE		bChecksum;
	BYTE		bEOX;
} WALL_SYS_EX, *PWALL_SYS_EX;

// --- Download Data - User Defined Waveform SysEx
typedef struct _UD_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
//	BYTE		bWaveformArray;	// Force Data . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} UD_WAVEFORM_SYS_EX, *PUD_WAVEFORM_SYS_EX;
#define UD_WAVEFORM_START_OFFSET (sizeof(UD_WAVEFORM_SYS_EX))


// --- Download Data - Process List SysEx
typedef struct _PROCESS_LIST_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bEffectArrayID;	// Effect ID[0] . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} PROCESS_LIST_SYS_EX, *PPROCESS_LIST_SYS_EX;
#define PROCESS_LIST_EFFECT_START_OFFSET (sizeof(PROCESS_LIST_SYS_EX))


//
// --- Function Prototypes
//
HRESULT CMD_Init(void);

HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID);

HRESULT CMD_ModifyParam( 
	IN WORD wNewParam);

HRESULT CMD_ModifyParamByIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID, 
	IN WORD wNewParam);

HRESULT CMD_Force_Out(
    IN LONG lForceData, 
    IN ULONG ulAxisMask);

HRESULT CMD_DestroyEffect( 
	IN DNHANDLE hEffectID);

HRESULT CMD_PlayEffectSolo( 
	IN DNHANDLE hEffectID);

HRESULT CMD_PlayEffectSuperimpose( 
	IN DNHANDLE hEffectID);

HRESULT CMD_StopEffect( 
	IN DNHANDLE hEffectID);

HRESULT CMD_SetDeviceState(
	IN ULONG ulMode);

HRESULT CMD_GetEffectStatus(
	IN DNHANDLE hDnloadID, 
	IN OUT PBYTE pStatusCode);

HRESULT CMD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex, 
	IN OUT PLONG pForceValue);

HRESULT CMD_MIDI_Assign(
	IN BYTE bMidiChannel);

HRESULT CMD_Download_NOP_DELAY(
 	IN ULONG ulDuration,
	IN PEFFECT pEffect,
 	IN OUT PDNHANDLE pDnloadID);

HRESULT CMD_Download_UD_Waveform(
	IN ULONG ulDuration,
	IN PEFFECT pEffect,
	IN ULONG ulNumVectors,
 	IN PLONG pUD_Array,
	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_SYNTH(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PSE_PARAM pSE_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFX_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_RTCSpring(
 	IN PRTCSPRING_PARAM pRTCSpring,
	IN OUT PDNHANDLE pDnloadID);

HRESULT CMD_ProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
 	IN ULONG ulAction);

HRESULT CMD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects,
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray,
 	IN ULONG ulAction);

HRESULT ModifyEffectParams(
	IN DNHANDLE DnloadID,
	IN PEFFECT pEffect,
	IN DWORD dwFlags);

class CMidiSynthesized;

HRESULT ModifyEnvelopeParams(
	IN CMidiSynthesized *pMidiEffect,
	IN DNHANDLE DnloadID,
	IN ULONG ulDuration,
	IN PENVELOPE pEnvelope,
	IN DWORD dwFlags);

void MapEnvelope( 
	IN ULONG ulDuration,
	IN ULONG dwMagnitude,
	IN ULONG * pMaxLevel,
	IN LPDIENVELOPE pDIEnvelope, 
	IN OUT PENVELOPE pEnvelope);


#endif // of ifdef _HAU_MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\joyregst.cpp ===
/****************************************************************************

    MODULE:     	joyregst.CPP
	Tab stops 5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for VJOYD Registry entries
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	0.1			20-Jun-96	MEA     original
				12-Mar-99	waltw	Removed dead joyGetOEMProductName &
										joyGetOEMForceFeedbackDriverDLLName
				20-Mar-99	waltw	Nuked dead GetRing0DriverName

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <stdio.h>
#include <TCHAR.h>
#include "joyregst.hpp"
#include "sw_error.hpp"
#include "Registry.h"
#include "FFDevice.h"
#include "CritSec.h"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//#define ACKNACK_1_16_DEFAULT 0x0000949A
#define ACKNACK_1_16_DEFAULT 0x0000955A
#define ACKNACK_1_20_DEFAULT 0x0000955A


MMRESULT joyGetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN OUT ULONG *pCOMMInterface,
			IN OUT ULONG *pCOMMPort)
{

	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	DWORD dwcb = sizeof(DWORD); 

	MMRESULT lr = RegQueryValueEx( hOEMForceFeedbackKey,
			  REGSTR_VAL_COMM_INTERFACE,
			  0, NULL,
			  (LPBYTE) pCOMMInterface,
			  (LPDWORD) &dwcb);
	if (SUCCESS != lr) return (lr);
	lr = RegQueryValueEx( hOEMForceFeedbackKey,
			  REGSTR_VAL_COMM_PORT,
			  0, NULL,
			  (LPBYTE) pCOMMPort,
			  (LPDWORD) &dwcb);
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"joyGetForceFeedbackCOMMInterface:COMMInterface=%lx, COMMPort=%lx\n",
			*pCOMMInterface, *pCOMMPort);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (lr);
}

MMRESULT joySetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN ULONG ulCOMMInterface,
			IN ULONG ulCOMMPort)
{
	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.SetValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(&ulCOMMInterface), sizeof(DWORD), REG_DWORD);
	MMRESULT lr = oemFFKey.SetValue(REGSTR_VAL_COMM_PORT, (BYTE*)(&ulCOMMPort), sizeof(DWORD), REG_DWORD);

	return (lr);
}


HKEY joyOpenOEMForceFeedbackKey(UINT id)
{
	JOYCAPS JoyCaps;
	TCHAR szKey[256];
	TCHAR szValue[256];
	UCHAR szOEMKey[256];

	HKEY hKey;
	DWORD dwcb;
	LONG lr;

// Note: JOYSTICKID1-16 is zero-based, Registry entries for VJOYD is 1-based.
	id++;		
	if (id > joyGetNumDevs() ) return 0;

// open .. MediaResources\CurentJoystickSettings
	joyGetDevCaps((id-1), &JoyCaps, sizeof(JoyCaps));
//
#ifdef _NOJOY
	strcpy(JoyCaps.szRegKey,"msjstick.drv<0004>");
#endif
//
//
	sprintf(szKey,
			"%s\\%s\\%s",
			REGSTR_PATH_JOYCONFIG,
			JoyCaps.szRegKey,
			REGSTR_KEY_JOYCURR);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) return 0;

// Get OEM Key name
	dwcb = sizeof(szOEMKey);
 	sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
	lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &szOEMKey, (LPDWORD) &dwcb);
	RegCloseKey(hKey);
	if (lr != ERROR_SUCCESS) return 0;

// open OEM\name\OEMForceFeedback	from ...MediaProperties
	sprintf(szKey, "%s\\%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey, 
			REGSTR_OEMFORCEFEEDBACK);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) 
		return 0;
	else
		return hKey;
}


/******************************************************
**
** GetAckNackMethodFromRegistry(UINT id)
**
** @mfunct GetAckNackMethodFromRegistry.
**
******************************************************/
DWORD GetAckNackMethodFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD ackNackInfo = 0;
	TCHAR firmwareString[32] = "";
	::wsprintf(firmwareString, TEXT("%d.%d-AckNack"), g_ForceFeedbackDevice.GetFirmwareVersionMajor(), g_ForceFeedbackDevice.GetFirmwareVersionMinor());
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(firmwareString, (BYTE*)&ackNackInfo, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
			if (g_ForceFeedbackDevice.GetFirmwareVersionMinor() < 20) {
				ackNackInfo = ACKNACK_1_16_DEFAULT;
			} else {	// 1.20 and greater
				ackNackInfo = ACKNACK_1_20_DEFAULT;
			}
		} else {	// Firmware greater than 1.0
			ackNackInfo = ACKNACK_1_20_DEFAULT;	// Use the latest I know of
		}
		ffRegKey.SetValue(firmwareString, (BYTE*)&ackNackInfo, sizeof(DWORD), REG_DWORD);
	}

	return ackNackInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\joyregst.hpp ===
/****************************************************************************

    MODULE:     	joyregst.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for VJOYD Registry functions
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original
			12-Mar-99		waltw	Removed dead joyGetOEMProductName &
										joyGetOEMForceFeedbackDriverDLLName
			20-Mar-99		waltw	Nuked dead GetRing0DriverName

****************************************************************************/
#ifndef joyregst_SEEN
#define joyregst_SEEN

#define REGSTR_OEMFORCEFEEDBACK 		        "OEMForceFeedback"
#define REGSTR_VAL_SFORCE_DRIVERDLL		        "Driver DLL"
#define REGSTR_VAL_SFORCE_PRODUCTNAME		    "ProductName"
#define REGSTR_VAL_SFORCE_MANUFACTURERNAME	    "Manufacturer"
#define REGSTR_VAL_SFORCE_PRODUCTVERSION	    "ProductVersion"
#define REGSTR_VAL_SFORCE_DEVICEDRIVERVERSION	"DeviceDriverVersion"
#define REGSTR_VAL_SFORCE_DEVICEFIRMWAREVERSION "DeviceFirmwareVersion"
#define REGSTR_VAL_SFORCE_INTERFACE		        "Interface"
#define REGSTR_VAL_SFORCE_MAXSAMPLERATE	        "MaxSampleRate"
#define REGSTR_VAL_SFORCE_MAXMEMORY		        "MaxMemory"
#define REGSTR_VAL_SFORCE_NUMBEROFSENSORS       "NumberOfSensors"
#define REGSTR_VAL_SFORCE_NUMBEROFAXES          "NumberOfAxes"
#define REGSTR_VAL_SFORCE_EFFECTSCAPS		    "EffectsCaps"
#define REGSTR_VAL_SFORCE_EXTRAINFO		        "ExtraInfo"
#define REGSTR_VAL_COMM_INTERFACE		        "COMMInterface"
#define REGSTR_VAL_COMM_PORT		        	"COMMPort"
#define REGSTR_VAL_RING0_DRIVER					"RING0 Driver"

HKEY 	 joyOpenOEMForceFeedbackKey(UINT id);
MMRESULT joyGetForceFeedbackCOMMInterface(UINT id, ULONG* ulArg1, ULONG* ulArg2);
MMRESULT joySetForceFeedbackCOMMInterface(UINT id, ULONG ulCOMMInterface, ULONG ulCOMMPort);

DWORD GetAckNackMethodFromRegistry(UINT id);

#define REGBITS_DESTROYEFFECT	14
#define REGBITS_PLAYEFFECT		12
#define REGBITS_STOPEFFECT		10
#define REGBITS_SETINDEX		8
#define REGBITS_MODIFYPARAM		6
#define REGBITS_SETDEVICESTATE	4
#define REGBITS_DOWNLOADEFFECT	2
#define REGBITS_DEVICEINIT		0

#define ACKNACK_NOTHING			0x00
#define ACKNACK_BUTTONSTATUS	0x01
#define ACKNACK_STATUSPACKET	0x02

#endif // of if joyregst_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi.hpp ===
/****************************************************************************

    MODULE:     	MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
        
****************************************************************************/
#ifndef _MIDI_SEEN
#define _MIDI_SEEN

#define MMNODRV
#define MMNOSOUND
#define MMNOWAVE
// #define MMNOMIDI  // we need the MIDI definitions
#define MMNOAUX
#define MMNOTIMER
#define MMNOJOY
#define MMNOMMIO
#define MMNOMCI
#include <winuser.h>
#include <mmsystem.h>

//////////////////////////////////////////////////////////////////////////////
//
// manifest constants and macros for MIDI message protocol
//
//////////////////////////////////////////////////////////////////////////////

// MIDI Status Bytes for Channel Voice Messages
#define MIDI_NOTE_OFF           0x80
#define MIDI_NOTE_ON            0x90
#define MIDI_POLY_PRESSURE      0xA0
#define MIDI_CONTROL_CHANGE     0xB0
#define MIDI_PROGRAM_CHANGE     0xC0
#define MIDI_CHANNEL_PRESSURE   0xD0
#define MIDI_AFTERTOUCH         0xD0  // synonym for channel pressure
#define MIDI_PITCH_WHEEL        0xE0

// MIDI Status Bytes for System Common Messages
#define MIDI_SYSEX              0xF0  // beginning of system exclusive message
#define MIDI_MTC_QTR_FRAME      0xF1
#define MIDI_SONG_POSITION_PTR  0xF2
#define MIDI_SONG_SELECT        0xF3
#define MIDI_TUNE_REQUEST       0xF6
#define MIDI_EOX                0xF7  // marks end of system exclusive message

// MIDI Status Bytes for System Real-Time Messages
#define MIDI_TIMING_CLOCK       0xF8
#define MIDI_START              0xFA
#define MIDI_CONTINUE           0xFB
#define MIDI_STOP               0xFC
#define MIDI_ACTIVE_SENSING     0xFE
#define MIDI_SYSTEM_RESET       0xFF

// control numbers for MIDI_CONTROL_CHANGE (MIDI status byte 0xB0)
// note: not a complete list
#define MIDI_MOD_WHEEL              0x01
#define MIDI_BREATH_CONTROL         0x02
#define MIDI_FOOT_CONTROL           0x04
#define MIDI_PORTAMENTO_TIME        0x05
#define MIDI_DATA_ENTRY_SLIDER      0x06
#define MIDI_VOLUME                 0x07
#define MIDI_BALANCE                0x08
#define MIDI_PAN                    0x0A
#define MIDI_EXPRESSION             0x0B
#define MIDI_GENERAL_PURPOSE_1      0x10   
#define MIDI_GENERAL_PURPOSE_2      0x11
#define MIDI_GENERAL_PURPOSE_3      0x12
#define MIDI_GENERAL_PURPOSE_4      0x13
#define MIDI_SUSTAIN                0x40
#define MIDI_PORTAMENTO             0x41
#define MIDI_SOSTENUTO              0x42
#define MIDI_SOFT                   0x43
#define MIDI_HOLD_2                 0x45
#define MIDI_GENERAL_PURPOSE_5      0x50
#define MIDI_GENERAL_PURPOSE_6      0x51
#define MIDI_GENERAL_PURPOSE_7      0x52
#define MIDI_GENERAL_PURPOSE_8      0x53
#define MIDI_EXTERNAL_EFFECTS_DEPTH 0x5B
#define MIDI_TREMELO_DEPTH          0x5C
#define MIDI_CHORUS_DEPTH           0x5D
#define MIDI_CELESTE_DEPTH          0x5E
#define MIDI_PHASER_DEPTH           0x5F
#define MIDI_DATA_INCREMENT         0x60
#define MIDI_DATA_DECREMENT         0x61
#define MIDI_NONREG_PARAM_NUM_MSB   0x62
#define MIDI_NONREG_PARAM_NUM_LSB   0x63
#define MIDI_REG_PARAM_NUM_MSB      0x64
#define MIDI_REG_PARAM_NUM_LSB      0x65
#define MIDI_RESET_ALL_CONTROLLERS  0x79
#define MIDI_LOCAL_CONTROL          0x7A
#define MIDI_ALL_NOTES_OFF          0x7B
#define MIDI_OMNI_MODE_OFF          0x7C
#define MIDI_OMNI_MODE_ON           0x7D
#define MIDI_MONO_MODE_ON           0x7E
#define MIDI_POLY_MODE_ON           0x7F      

// macro to pack a MIDI short message                                                
#define MAKEMIDISHORTMSG(cStatus, cChannel, cData1, cData2)            \
    cStatus | cChannel | (((UINT)cData1) << 8) | (((DWORD)cData2) << 16)
    
// macros to unpack a MIDI short message    
#define MIDI_STATUS(dwMsg)  ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0xF0 : LOBYTE(LOWORD(dwMsg)))
#define MIDI_CHANNEL(dwMsg) ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0x0F : 0)
#define MIDI_DATA1(dwMsg)   (HIBYTE(LOWORD(dwMsg)))
#define MIDI_DATA2(dwMsg)   (LOBYTE(HIWORD(dwMsg))) 

//////////////////////////////////////////////////////////////////////////////
//
// declarations for MIDI wrapper functions
//
//////////////////////////////////////////////////////////////////////////////

#define MIDI_IN      0x0001  // specifies MIDI input device
#define MIDI_OUT     0x0002  // specifies MIDI output device
#define NO_MIDI      0xFF00  // MIDI device unavaible or not selected 

#define MIDI_OPEN    0x0001  // uActivateMode parameter for MidiActivate
#define MIDI_CLOSE   0x0010  // uActivateMode parameter for MidiActivate
#define MIDI_ABANDON 0x0011  // uActivateMode parameter for MidiActivate
#define MIDI_BUSY    0xFF01  // possible MidiActivate return value

#define MIDI_ERRMSG_SIZE 128 // for MidiShowError string buffer

typedef struct _MIDIINFO     // MIDI device information block
{                           
    UINT uDeviceType;        // either MIDI_IN, MIDI_OUT or NO_MIDI
    UINT uDeviceID;          // ID of device chosen by user or NO_MIDI 
    union
    { 
        HMIDIIN  hMidiIn;    // input device handle used if MIDI_IN device
        HMIDIOUT hMidiOut;   // output device handle used if MIDI_OUT device
    };
    MIDIHDR MidiHdr;         // required for system exclusive   
    BOOL fAlwaysKeepOpen;    // access level requested by application
    UINT uDeviceStatus;      // current status of device
} MIDIINFO, *LPMIDIINFO;

// defines for MIDIINFO uDeviceStatus member
#define MIDI_DEVICE_IDLE        0x0000  // device is not in use
#define MIDI_DEVICE_BUSY        0x0001  // device is busy
#define MIDI_DEVICE_ABANDONED   0x0002  // device was reset while busy

    
BOOL MidiInit(LPMIDIINFO, LPMIDIINFO);
MMRESULT MidiGetDeviceName(UINT, UINT, LPWORD, LPWORD, LPSTR);
UINT MidiActivateDevice(LPMIDIINFO, UINT);
UINT MidiSendShortMsg(LPMIDIINFO, BYTE, BYTE, BYTE, BYTE); 
UINT MidiAssignBuffer(LPMIDIINFO, LPSTR, DWORD, BOOL);
UINT MidiSendLongMsg(LPMIDIINFO, BOOL);
UINT MidiRecord(LPMIDIINFO, BOOL);
BOOL MidiExit(LPMIDIINFO, LPMIDIINFO);

#endif // of ifdef _MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_obj.hpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.HPP
	Tab Settings:	5 9

    PURPOSE:    	Header to define SWFF MIDI device objects
    
    FUNCTIONS:
        		Classes with members and methods are kept in this header file

	Version Date        Author  Comments
	0.1		10-Sep-96	MEA     original
	1.1		17-Mar-97	MEA		DX-FF mode

****************************************************************************/
#ifndef MIDI_OBJ_SEEN
#define MIDI_OBJ_SEEN
 
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "dinput.h"
#include "vxdioctl.hpp"
#include "sw_error.hpp"

#define MAX_SCALE	1.27				// 1 to 100 = 1 to 127
#define TICKRATE	2					// 2 ms per tick divisor

#define SWFF_SHAREDMEM_FILE		"SWFF_SharedMemFile"
#define SWFF_MIDIEVENT			"SWFFMidiEvent\0"
#define SWFF_SHAREDMEM_MUTEX	"SWFFSharedMemMutex\0"
#define SWFF_JOLTOUTPUTDATA_MUTEX	"SWFFJoltOutputDataMutex\0"
#define SIZE_SHARED_MEMORY 1024			// 1024 bytes
#define MUTEX_TIMEOUT	10000			// 10 seconds timeout

// spring
#define DEF_SCALE_KX	100
#define DEF_SCALE_KY	100

// damper
#define DEF_SCALE_BX	100
#define DEF_SCALE_BY	100

// inertia
#define DEF_SCALE_MX	80
#define DEF_SCALE_MY	80

// friction
#define DEF_SCALE_FX	100
#define DEF_SCALE_FY	100

// wall
#define DEF_SCALE_W		100

typedef struct _FIRMWARE_PARAMS
{
	DWORD dwScaleKx;
	DWORD dwScaleKy;
	DWORD dwScaleBx;
	DWORD dwScaleBy;
	DWORD dwScaleMx;
	DWORD dwScaleMy;
	DWORD dwScaleFx;
	DWORD dwScaleFy;
	DWORD dwScaleW;
} FIRMWARE_PARAMS, *PFIRMWARE_PARAMS;
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams);

typedef struct _SYSTEM_PARAMS
{
	RTCSPRING_PARAM RTCSpringParam;
} SYSTEM_PARAMS, *PSYSTEM_PARAMS;
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams);


#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

typedef struct _JOYSTICK_PARAMS
{
	DWORD dwXYConst;
	DWORD dwRotConst;
	DWORD dwSldrConst;
	DWORD dwAJPos;
	DWORD dwAJRot;
	DWORD dwAJSldr;
	DWORD dwSprScl;
	DWORD dwBmpScl;
	DWORD dwDmpScl;
	DWORD dwInertScl;
	DWORD dwVelOffScl;
	DWORD dwAccOffScl;
	DWORD dwYMotBoost;
	DWORD dwXMotSat;
	DWORD dwReserved;
	DWORD dwMasterGain;
} JOYSTICK_PARAMS, *PJOYSTICK_PARAMS;
void GetJoystickParams(UINT nJoystickID, PJOYSTICK_PARAMS pJoystickParams);
void UpdateJoystickParams(PJOYSTICK_PARAMS pJoystickParams);



// Shared Memory data structure
typedef struct _SHARED_MEMORY {
	char	m_cWaterMark[MAX_SIZE_SNAME];
	ULONG	m_RefCnt;
	HANDLE	m_hMidiOut;
	MIDIINFO m_MidiOutInfo;
} SHARED_MEMORY, *PSHARED_MEMORY;


// Effect Types conversion structure
typedef struct _EFFECT_TYPE {
	ULONG	ulHostSubType;
	BYTE	bDeviceSubType;
} EFFECT_TYPE, *PEFFECT_TYPE;

//
// --- ROM Effects default parameters structure
//
typedef struct _ROM_FX_PARAM {
	ULONG	m_ROM_Id;
	ULONG	m_ForceOutputRate;
	ULONG	m_Gain;
	ULONG	m_Duration;
} ROM_FX_PARAM, *PROM_FX_PARAM;


// Structure to pass instance data from the application
//   to the low-level callback function. (Output done notification)
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    HMIDIOUT            hMapper;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

class CJoltMidi;
//	--- MIDI Effect base class
class CMidiEffect : public SYS_EX_HDR
{
 protected:
	BYTE	m_OpCode;				// Sub-command opcode: e.g. DNLOAD_DATA
	BYTE	m_SubType;				// Effect SubType: e.g. BE_SPRING
	BYTE	m_bEffectID;			// 0x7F = Create New, else valid Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
	BYTE	m_bAxisMask;
	BYTE	m_bPlayMode;			// DL_PLAY_SUPERIMPOSE || DL_PLAY_SOLO
    LPSTR	m_pBuffer;				// Ptr to a Midi SYS_EX Buffer
	int		m_MidiBufferSize;		// Size of SYS_EX buffer
	int		m_LoopCount;			// Loop Count for the playback
	LONG	m_Duration;				// Atomic Effect Duration (for 1 cycle)
	ENVELOPE	m_Envelope;			// Atomic Envelope (no loop count)
	EFFECT	m_OriginalEffectParam;	// the effect param when the effect was created

 public:
	// Constructor/Destructor
	CMidiEffect(ULONG ulButtonPlayMask);
	CMidiEffect(PEFFECT pEffect, PENVELOPE pEnvelope);
	virtual ~CMidiEffect(void);

	// Methods
	ULONG	SubTypeOf(void);
	BYTE	EffectIDOf(void) { return m_bEffectID; }
	ULONG	DurationOf(void) { return m_Duration * TICKRATE; }
	BYTE	AxisMaskOf(void) { return m_bAxisMask; }
	ULONG	DirectionAngle2DOf(void) 
			{ return(Effect.bAngleL+((USHORT)Effect.bAngleH<<7));}
	BYTE	GainOf(void) { return Effect.bGain; }
	ULONG	ButtonPlayMaskOf(void) 
			{ return(Effect.bButtonPlayL+((USHORT)Effect.bButtonPlayH<<7));}
	ULONG	ForceOutRateOf(void) 
			{ return (Effect.bForceOutRateL+((USHORT)Effect.bForceOutRateH<<7));}
	ULONG	PlayModeOf(void) { 
					if (DL_PLAY_SOLO == m_bPlayMode)
						return PLAY_SOLO;
					else 
						return PLAY_SUPERIMPOSE; }

	int		MidiBufferSizeOf(void) { return m_MidiBufferSize; }
    LPSTR	LockedBufferPtrOf(void) { return m_pBuffer; }
	int		LoopCountOf(void) { return m_LoopCount; }

	PEFFECT OriginalEffectParamOf() { return &m_OriginalEffectParam; }
	ENVELOPE * EnvelopePtrOf() { return &m_Envelope; }

	void	SetSubType(ULONG ulArg);
	void	SetEffectID(BYTE bArg) { m_bEffectID = bArg; }
	void	SetDuration(ULONG ulArg);
	void	SetAxisMask(BYTE bArg) { m_bAxisMask = bArg; }
	void	SetDirectionAngle(ULONG ulArg) 
			{ Effect.bAngleL = (BYTE) ulArg & 0x7f;
			  Effect.bAngleH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetGain(BYTE bArg) { Effect.bGain = (BYTE) (bArg * MAX_SCALE); }
	void	SetButtonPlaymask(ULONG ulArg)
			{ Effect.bButtonPlayL = (BYTE) ulArg & 0x7f;
			  Effect.bButtonPlayH = (BYTE) ((ulArg >> 7) & 0x03);}
	void	SetForceOutRate(ULONG ulArg) 
			{ Effect.bForceOutRateL = (BYTE) ulArg & 0x7f;
			  Effect.bForceOutRateH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetMidiBufferSize(int nArg) { m_MidiBufferSize = nArg; }
	void	SetMidiBufferPtr(LPSTR pArg) { m_pBuffer = pArg; }
	
	void	SetPlayMode(ULONG ulArg) { 
					if (PLAY_SOLO == ulArg) 
						m_bPlayMode = DL_PLAY_SOLO;
					else
						m_bPlayMode = DL_PLAY_SUPERIMPOSE; }

	void	SetLoopCount(ULONG ulAction) 
					{ m_LoopCount = ((ulAction >> 16) & 0xffff); }
	void	SetTotalDuration(void);
	void	SetEnvelope(PENVELOPE pArg) 
				{ m_Envelope.m_Type = pArg->m_Type;
				  m_Envelope.m_Attack = pArg->m_Attack;
				  m_Envelope.m_Sustain = pArg->m_Sustain;
				  m_Envelope.m_Decay = pArg->m_Decay;
				  m_Envelope.m_StartAmp = pArg->m_StartAmp;
				  m_Envelope.m_SustainAmp = pArg->m_SustainAmp;
				  m_Envelope.m_EndAmp = pArg->m_EndAmp; }
	void	ComputeEnvelope(void);
	BYTE  	ComputeChecksum(PBYTE pArg, int nBufferSize); 
	virtual PBYTE GenerateSysExPacket(void) = 0;
	HRESULT SendPacket(PDNHANDLE pDnloadID, int nPacketSize); 

	virtual HRESULT DestroyEffect();
};

//	--- MIDI Behavioral Effect derived class
class CMidiBehavioral : public CMidiEffect
{
 protected:
	BE_XXX	m_BE_XXXParam;	// Behavioral Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiBehavioral(void);

	// Methods
	LONG	XConstantOf(void) { return m_BE_XXXParam.m_XConstant; }
	LONG	YConstantOf(void) { return m_BE_XXXParam.m_YConstant; }
	LONG	Param3Of(void) { return m_BE_XXXParam.m_Param3; }
	LONG	Param4Of(void) { return m_BE_XXXParam.m_Param4; }

	void	SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX);
	void	SetXConstant(LONG lArg) { m_BE_XXXParam.m_XConstant = lArg; }
	void	SetYConstant(LONG lArg) { m_BE_XXXParam.m_YConstant = lArg; }
	void	SetParam3(LONG lArg) { m_BE_XXXParam.m_Param3 = lArg; }
	void	SetParam4(LONG lArg) { m_BE_XXXParam.m_Param4 = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Friction Effect derived class
class CMidiFriction : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiFriction(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Wall Effect derived class
class CMidiWall : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiWall(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI RTC Spring Effect derived class
class CMidiRTCSpring : public CMidiEffect
{
 protected:
	RTCSPRING_PARAM	m_RTCSPRINGParam;	// RTCSpring Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring);
	virtual ~CMidiRTCSpring(void);

	// Methods
	LONG	XKConstantOf(void) { return m_RTCSPRINGParam.m_XKConstant; }
	LONG	YKConstantOf(void) { return m_RTCSPRINGParam.m_YKConstant; }
	LONG	XAxisCenterOf(void) { return m_RTCSPRINGParam.m_XAxisCenter; }
	LONG	YAxisCenterOf(void) { return m_RTCSPRINGParam.m_YAxisCenter; }
	LONG	XSaturationOf(void) { return m_RTCSPRINGParam.m_XSaturation; }
	LONG	YSaturationOf(void) { return m_RTCSPRINGParam.m_YSaturation; }
	LONG	XDeadBandOf(void) { return m_RTCSPRINGParam.m_XDeadBand; }
	LONG	YDeadBandOf(void) { return m_RTCSPRINGParam.m_YDeadBand; }
	void	SetEffectParams(PRTCSPRING_PARAM pRTCSpring);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Delay Effect derived class
class CMidiDelay : public CMidiEffect
{
 protected:
 public:
	// Constructor/Destructor
	CMidiDelay(PEFFECT pEffect);
	virtual ~CMidiDelay(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Synthesized Effect derived class
class CMidiSynthesized : public CMidiEffect
{
 protected:
	ULONG	m_Freq;			// Frequency
	LONG	m_MaxAmp;		// Maximum Amplitude
	LONG	m_MinAmp;		// Minimum Amplitude
 public:
	// Constructor/Destructor
	CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope, PSE_PARAM pParam);
	virtual ~CMidiSynthesized(void);

	// Methods
	ULONG	FreqOf(void)   { return m_Freq; }
	LONG	MaxAmpOf(void) { return m_MaxAmp; }
	LONG	MinAmpOf(void) { return m_MinAmp; }

	void	SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam, ULONG ulMode);
	void	SetFreq(ULONG ulArg) { m_Freq = ulArg; }
	void	SetMaxAmp(LONG lArg) { m_MaxAmp = lArg; }
	void	SetMinAmp(LONG lArg) { m_MinAmp = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI UD_Waveform Effect derived class
class CMidiUD_Waveform : public CMidiEffect
{
 protected:
	EFFECT  m_Effect;
	int		m_NumberOfVectors;// Size of the Array
	PBYTE	m_pArrayData;	// Pointer to an scaled (+/-127) array of forces
	PBYTE	m_pRawData;		// Pointer to unscaled array of forces

 public:
	// Constructor/Destructor
	CMidiUD_Waveform(PEFFECT pEffect);
	CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray);
	virtual ~CMidiUD_Waveform(void);

	// Methods
	PEFFECT EffectPtrOf() { return (PEFFECT) &m_Effect.m_Bytes; }
	int		NumberOfVectorsOf(void) { return m_NumberOfVectors; }
	PBYTE	ArrayDataPtrOf(void) { return m_pArrayData; }
	int		CompressWaveform(PBYTE pSrcArray, PBYTE pDestArray, int nSrcSize, ULONG *pNewRate);
	void	SetEffectParams(PEFFECT pEffect);
	int		SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate);
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Process List Effect derived class
class CMidiProcessList : public CMidiEffect
{
 protected:
	ULONG	m_NumEffects;
	ULONG	m_ProcessMode;	// PL_SUPERIMPOSE or PL_CONCATENATE
	PBYTE	m_pEffectArray;	// Effect ID[0} . . .

 public:
	// Constructor/Destructor
	CMidiProcessList(ULONG ulButtonPlayMask, PPLIST pParam);
	virtual ~CMidiProcessList(void);

	// Methods
	ULONG	NumEffectsOf(void) { return (ULONG) m_NumEffects; }
	PBYTE	EffectArrayOf(void) { return m_pEffectArray; }
	void	SetProcessMode(ULONG ulArg) { m_ProcessMode = ulArg; }
	void	SetParams(ULONG ulButtonPlayMask, PPLIST pPlist);	
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Process List Effect derived class
class CMidiVFXProcessList : public CMidiProcessList
{
 protected:

 public:
	// Constructor/Destructor
	CMidiVFXProcessList(ULONG ulButtonPlayMask, PPLIST pParam);

	// Methods
	virtual HRESULT DestroyEffect();
};

//	--- MIDI Assign Midi channel command "Effect" derived class
class CMidiAssign : public CMidiEffect
{
 protected:
	ULONG	m_Channel;		// Channel 0 - 15
 public:
	// Constructor/Destructor
	CMidiAssign(void);
	virtual ~CMidiAssign(void);

	// Methods
	ULONG	MidiAssignChannelOf(void) { return m_Channel; }

	void	SetMidiAssignChannel(ULONG ulArg) { m_Channel = ulArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- Jolt Device base class
class CJoltMidi
{
 protected:
	LOCAL_PRODUCT_ID m_ProductID;		// Device information
	FIRMWARE_PARAMS	m_FirmwareParams;	// Behavioral effect fudge factors
	DELAY_PARAMS	m_DelayParams;		// Timing parameters

	// Power Cycle Restore Thread variables
#if 0
	DWORD   m_dwThreadID;
	HANDLE  m_hDataEvent;
	HANDLE  m_hDataThread;
	DWORD	m_dwThreadSignal;
	DWORD	m_dwThreadStatus;	        // TRUE = thread is alive, else FALSE
#endif
	ULONG			m_COMMInterface;	// COMM_WINMM || COMM_MIDI_BACKDOOR || COMM_SERIAL_BACKDOOR || COMM_SERIAL_FILE
	ULONG			m_COMMPort;			// e.g. 330, 3F8, or 0 for winmm
	HANDLE			m_hVxD;				// Handle to VxD for IOCTL interface
	HANDLE  		m_hMidiOutputEvent;	// Handle to Midi Output Event
	MIDIOUTCAPS 	m_MidiOutCaps; 		// MIDI Output Device capabilities structures
	int				m_MidiOutDeviceID;	// Midi Output device ID
	BOOL			m_MidiOutOpened;	// TRUE = MidiOutOpen called
	LPCALLBACKINSTANCEDATA m_lpCallbackInstanceData;
	CMidiEffect		*m_pJoltEffectList[MAX_EFFECT_IDS];	// Array of Downloaded Effects IPTrs
	BYTE			m_MidiChannel;		// Midi Channel
	SWFF_ERROR  	m_Error;		 	// System Error codes
	MIDIINFO 		m_MidiOutInfo;		// Midi output Info structure
	BOOL			m_ShutdownSent;		// TRUE = Last command sent was Shutdown
	DIAG_COUNTER	m_DiagCounter;		// For debugging, Diagnostics counter

	SWDEVICESTATE	m_DeviceState;
	HANDLE			m_hPrimaryBuffer;	// Handle to locked memory
	LPBYTE			m_pPrimaryBuffer;	// Pointer to the Primary buffer memory
	PROM_FX_PARAM	m_pRomFxTable;		// Default settings for ROM Effects
	HANDLE	m_hSharedMemoryFile;		// Handle to a memory mapped file
	PSHARED_MEMORY	m_pSharedMemory;	// Pointer to a Shared Memory structure
	HANDLE			m_hSWFFDataMutex;	// Local copy of Mutex handle
//	HANDLE			m_hJoltOutputDataMutex;	// Local copy of Mutex handle (locks Jolt to
//										// single output command at a time.

 public:
	// Constructor/Destructor
	CJoltMidi(void);
	~CJoltMidi(void);

	// Methods
	HANDLE SWFFDataMutexHandleOf() { return m_hSWFFDataMutex; }
	HRESULT Initialize(DWORD dwDeviceID);
#if 0
	HANDLE JoltOutputDataMutexHandleOf() { return m_hJoltOutputDataMutex; }
	DWORD  ThreadIDOf(void) { return m_dwThreadID; }
	HANDLE DataEventOf(void) {return m_hDataEvent; }
	HANDLE DataThreadOf(void) {return m_hDataThread; }
	DWORD  ThreadSignalOf(void) { return m_dwThreadSignal; }
	DWORD  ThreadStatusOf(void) { return m_dwThreadStatus; }
#endif

	HANDLE	MidiOutputEventHandleOf(void) { return m_hMidiOutputEvent; }
	HMIDIOUT MidiOutHandleOf(void) { return HMIDIOUT(m_pSharedMemory->m_hMidiOut); }
	int 	MidiOutDeviceIDOf(void) { return m_MidiOutDeviceID; }
	LPCALLBACKINSTANCEDATA CallbackInstanceDataOf(void) 
					{ return m_lpCallbackInstanceData; }
	BYTE	MidiChannelOf(void) { return m_MidiChannel; }
	void	CJoltGetLastError(PSWFF_ERROR pError)
							{ pError->HCode = m_Error.HCode;
							  pError->ulDriverCode = m_Error.ulDriverCode; }
	MIDIINFO *MidiOutInfoOf(void) { return &m_MidiOutInfo; }
	BOOL	ShutdownSentOf(void) { return m_ShutdownSent; }
	PDIAG_COUNTER DiagCounterPtrOf() { return &m_DiagCounter; }
	PBYTE	PrimaryBufferPtrOf() { return m_pPrimaryBuffer; }

	LOCAL_PRODUCT_ID* ProductIDPtrOf() { return &m_ProductID; }
	PFIRMWARE_PARAMS FirmwareParamsPtrOf() {return &m_FirmwareParams; }
	PDELAY_PARAMS DelayParamsPtrOf() {return &m_DelayParams; }
	ULONG	COMMInterfaceOf() { return m_COMMInterface; }
	ULONG	COMMPortOf() { return m_COMMPort; }

#if 0
	void 	SetThreadIDOf(DWORD dwArg) { m_dwThreadID = dwArg; }
	void 	SetDataEvent(HANDLE hArg) { m_hDataEvent = hArg; }
	void 	SetDataThread(HANDLE hArg) { m_hDataThread = hArg; }
	void 	SetThreadSignal(DWORD dwArg) { m_dwThreadSignal = dwArg; }
	void 	SetThreadStatus(DWORD dwArg) { m_dwThreadStatus = dwArg; }
	BOOL	LockJoltOutputData(void);
	void	UnlockJoltOutputData(void);
#endif

	BOOL	LockSharedMemory(void);
	void	UnlockSharedMemory(void);

	void	SetSWFFDataMutexHandle(HANDLE hArg) { m_hSWFFDataMutex = hArg;}
//	void	SetJoltOutputDataMutexHandle(HANDLE hArg) { m_hJoltOutputDataMutex = hArg;}
	void 	SetMidiOutHandle(HMIDIOUT hArg) { LockSharedMemory();
											  m_pSharedMemory->m_hMidiOut = hArg;
											  UnlockSharedMemory();}	
	void 	SetMidiOutDeviceID(int nArg) {m_MidiOutDeviceID = nArg; }
	void 	SetCallbackInstanceData(LPCALLBACKINSTANCEDATA pArg) 
				{ m_lpCallbackInstanceData = pArg; }
	void	SetMidiChannel(BYTE nArg) { m_MidiChannel = nArg; }
	void	SetShutdownSent(BOOL bArg) { m_ShutdownSent = bArg; }
	void	ClearDiagCounters(void) { m_DiagCounter.m_NACKCounter = 0;
									  m_DiagCounter.m_LongMsgCounter = 0; 
									  m_DiagCounter.m_ShortMsgCounter = 0;
									  m_DiagCounter.m_RetryCounter = 0; }
	void	BumpNACKCounter(void) { m_DiagCounter.m_NACKCounter++; }
	void	BumpLongMsgCounter(void) { m_DiagCounter.m_LongMsgCounter++; }
	void	BumpShortMsgCounter(void) { m_DiagCounter.m_ShortMsgCounter++; }
	void	BumpRetryCounter(void) { m_DiagCounter.m_RetryCounter++; }

	HRESULT	LogError(HRESULT hSystemError, HRESULT DriverError);

	void	SetJoltStatus(JOYCHANNELSTATUS* pJoyStatus);
	HRESULT	GetJoltStatus(LPDIDEVICESTATE);
	HRESULT	GetJoltStatus(PSWDEVICESTATE);
	SWDEVICESTATE GetSWDeviceStateNoUpdate() const { return m_DeviceState; } 

	void	UpdateDeviceMode(ULONG ulMode);
	HRESULT GetJoltID(LOCAL_PRODUCT_ID* pProductID);

	// Downloaded Effects management
	CMidiEffect *GetEffectByID(DNHANDLE hID)
				{ 	assert(hID < 0x7f);
    			  	if (hID >= 0x7f)
    			  		return NULL;
					else
						return m_pJoltEffectList[hID]; }
						
	void	SetEffectByID(DNHANDLE hID, CMidiEffect *pArg) 
				{ m_pJoltEffectList[hID] = pArg; }

	BOOL	NewEffectID(PDNHANDLE pDnloadID);
	void    DeleteDownloadedEffects(void);
	void	RestoreDownloadedEffects(void);
	
	// Midi management
	BOOL	DetectMidiDevice(DWORD dwDeviceID, UINT *pDeviceOutID,
							ULONG *pCOMMInterface, ULONG *pCOMMPort);

	HRESULT	ValidateMidiHandle(void);
	HRESULT OpenOutput(int nDeviceID);
	BOOL	IsMidiOutputOpened(void) { return m_MidiOutOpened; }
	HRESULT MidiSendShortMsg(BYTE cStatus, BYTE cData1,BYTE cData2);
	HRESULT MidiSendLongMsg(void);
	HRESULT MidiAssignBuffer(LPSTR lpData, DWORD dwBufferLength, BOOL fAssign);
	
	// Response from Jolt management
	HRESULT GetAckNackData(int nTimeWait, PACKNACK pAckNack, USHORT regindex);
	HRESULT GetEffectStatus(DWORD DnloadID, PBYTE pStatusCode);
	BOOL	QueryForJolt(void);
	BOOL	FindJoltWinMM(UINT *pDeviceOutID,ULONG *pCOMMInterface,ULONG *pCOMMPort);
	BOOL	FindJoltBackdoor(UINT *pDeviceOutID,ULONG *pCOMMInterface,ULONG *pCOMMPort);

	// Instance Data management
	LPCALLBACKINSTANCEDATA AllocCallbackInstanceData(void);
	void 	FreeCallbackInstanceData(void);

	// Digital OverDrive interface
	HRESULT	InitDigitalOverDrive(DWORD dwDeviceID);
	HANDLE	VxDHandleOf(void) { return m_hVxD; }

	// ROM Effects
	HRESULT SetupROM_Fx(PEFFECT pEffect);

	// Thread
//	HRESULT PowerCycleThreadCreate(void);
};

extern CJoltMidi* g_pJoltMidi;	// Global Jolt Object

#endif    // of ifndef MIDI_OBJ_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swff_pro.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_out.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OUT.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Uses a low-level callback function to get timestamped 
    				MIDI output. The callback function sets an Event to indicate
    				to wake up a blocked object.
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			10-Jan-97	MEA     original

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "midi_obj.hpp"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// Prototypes
void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);



// ----------------------------------------------------------------------------
// Function: 	midiOutputHandler
// Purpose:		
// Parameters:	hMidiIn - Handle for the associated output device.
//				wMsg - One of the MIM_***** messages.
//				dwInstance - Points to CALLBACKINSTANCEDATA structure.
//				dwParam1 - MIDI data.
//				dwParam2 - Timestamp (in milliseconds)
//
// Returns:		none
// Algorithm:
// Comments:
//		Low-level callback function to handle MIDI output.
//      Installed by midiOutOpen().  The Output handler checks for MM_MOM_DONE
//		message and wakes up the thread waiting for completion of MIDI SysEx 
//		output.  Note: Normal Short messages don't get notification!!!
//      This function is accessed at interrupt time, so it should be as 
//      fast and efficient as possible.  You can't make any
//      Windows calls here, except PostMessage().  The only Multimedia
//      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
// ----------------------------------------------------------------------------
void CALLBACK midiOutputHandler(
	IN HMIDIOUT hMidiOut, 
	IN UINT wMsg, 
	IN DWORD dwInstance, 
	IN DWORD dwParam1, 
	IN DWORD dwParam2)
{
	CJoltMidi *pJoltMidi = (CJoltMidi *) dwInstance;
	assert(pJoltMidi);
	BOOL bRet;
    
	switch(wMsg)
    {
        case MOM_OPEN:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: MOM_OPEN.\n");
#endif
            break;

        case MM_MOM_DONE:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: MM_MOM_DONE\n");
#endif
			// Notify task waiting on this object to trigger
			bRet = SetEvent(pJoltMidi->MidiOutputEventHandleOf());
			assert(bRet);
            break;

        default:
#ifdef _DEBUG
			OutputDebugString("midiOutputHandler: default case.\n");
#endif
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
	}

	if (rkey.m_pReferenceCount != NULL) {
		*(rkey.m_pReferenceCount) = 1;
		m_pReferenceCount = rkey.m_pReferenceCount;
		++(*m_pReferenceCount);
	}
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	if (rhs.m_pReferenceCount != NULL)
	{
		*(rhs.m_pReferenceCount) = 1;
		m_pReferenceCount = rhs.m_pReferenceCount;
		++(*m_pReferenceCount);
	}

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\midi_obj.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for SWFF MIDI device object

    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -----------------------------------------
	0.1			10-Sep-96	MEA     original
	1.1			20-May-97	MEA		Added Mutex and Thread safe code
				17-Jun-97	MEA		Fixed bug Midi Handle lost if 1st process
									terminated.
				16-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
									and pass down food chain
				16-Mar-99	waltw	GetRing0DriverName in InitDigitalOverDrive
									now passes down joystick ID
				20-Mar-99	waltw	Added dwDeviceID param to DetectMidiDevice
				20-Mar-99	waltw	Comment out invalid call to CloseHandle in dtor

****************************************************************************/
#include <assert.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mmsystem.h>
#include "SW_Error.hpp"
#include "midi_obj.hpp"
#include "vxdioctl.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "CritSec.h"

#define NT50 1

#include "DTrans.h"
DataTransmitter* g_pDataTransmitter = NULL;

/****************************************************************************

   Declaration of externs

****************************************************************************/
extern void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;

/****************************************************************************

   Declaration of variables

****************************************************************************/


/****************************************************************************

   Macros etc

****************************************************************************/

#ifdef _DEBUG
extern char g_cMsg[160];
void DebugOut(LPCTSTR szDebug)
{
	g_CriticalSection.Enter();
	OutputDebugString(szDebug);
	g_CriticalSection.Leave();

#ifdef _LOG_DEBUG
#pragma message("Compiling with Debug Log to sw_effct.txt")
	FILE *pf = fopen("sw_effct.txt", "a");
	if (pf != NULL)
	{
		fputs(szDebug, pf);
		fclose(pf);
	}
#endif // _LOG_DEBUG
}
#else !_DEBUG
#define DebugOut(x)
#endif // _DEBUG


// ****************************************************************************
// *** --- Member functions for base CJoltMidi
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::CJoltMidi
// Purpose:		Constructor(s)/Destructor for CJoltMidi Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CJoltMidi::CJoltMidi(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	static char cWaterMark[MAX_SIZE_SNAME] = {"SWFF_SHAREDMEMORY MEA"};
	BOOL bAlreadyMapped = FALSE;
#ifdef _DEBUG
	DebugOut("sw_effct(DX):CJoltMidi::CJoltMidi\n");
#endif
	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

	// Create an in-memory memory-mapped file
	m_hSharedMemoryFile = CreateFileMapping((HANDLE) 0xFFFFFFFF,
							NULL, PAGE_READWRITE, 0, SIZE_SHARED_MEMORY,
    							__TEXT(SWFF_SHAREDMEM_FILE));

	if (m_hSharedMemoryFile == NULL)
	{
#ifdef _DEBUG
	    DebugOut("sw_effct(DX):ERROR! Failed to create Memory mapped file\n");
#endif
	}
	else
	{
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	    {
			bAlreadyMapped = TRUE;
	    }
		// File mapping created successfully.
		// Map a view of the file into the address space.
		m_pSharedMemory = (PSHARED_MEMORY) MapViewOfFile(m_hSharedMemoryFile,
			              FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
		if ((BYTE *) m_pSharedMemory == NULL)
		{
#ifdef _DEBUG
		    DebugOut("sw_effct(DX):ERROR! Failed to Map view of shared memory\n");
#endif
		}

// ***** Shared Memory Access *****
		LockSharedMemory();
		if (!bAlreadyMapped)
		{
			// Set watermark and initialize, Bump Ref Count
			memcpy(&m_pSharedMemory->m_cWaterMark[0], &cWaterMark[0], MAX_SIZE_SNAME);
			m_pSharedMemory->m_RefCnt = 0;
		}
		m_pSharedMemory->m_RefCnt++;
	}
#ifdef _DEBUG
		wsprintf(g_cMsg, "sw_effct(DX): Shared Memory:%lx, m_RefCnt:%d\n",m_pSharedMemory,
				m_pSharedMemory->m_RefCnt);
		DebugOut(g_cMsg);
#endif
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****

// --- END OF CRITICAL SECTION
//
}

// --- Destructor
CJoltMidi::~CJoltMidi()
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	BOOL bKillObject = FALSE;

#ifdef _DEBUG
	DebugOut("sw_effct(DX):CJoltMidi::~CJoltMidi()\n");
#endif
	// Normal CJoltMidi Destructor
	// Free all buffers and other data
    if (m_lpCallbackInstanceData) FreeCallbackInstanceData();

	// Free the MIDI Effect objects (except RTC Spring)
	DeleteDownloadedEffects();

// Free the Primary SYS_EX locked memory
	if (m_hPrimaryBuffer)
	{
	    GlobalUnlock(m_hPrimaryBuffer);
    	GlobalFree(m_hPrimaryBuffer);
	}

// ***** Shared Memory Access *****
	LockSharedMemory();
	// Decrement Ref Count and clean up if equal to zero.
	m_pSharedMemory->m_RefCnt--;
#ifdef _DEBUG
	wsprintf(g_cMsg,"CJoltMidi::~CJoltMidi. RefCnt = %d\n",m_pSharedMemory->m_RefCnt);
	DebugOut(g_cMsg);
#endif

	if (0 == m_pSharedMemory->m_RefCnt)	
	{
		bKillObject = TRUE;

		// Tri-state Midi lines
		CMD_SetDeviceState(SWDEV_KILL_MIDI);

		if (m_pSharedMemory->m_hMidiOut) {
			if (COMM_WINMM == m_COMMInterface) {
				DebugOut("CJoltMidi::~CJoltMidi. Resetting and closing Midi handles\n");

				// Reset, close and release Midi Handles
				midiOutReset(HMIDIOUT(m_pSharedMemory->m_hMidiOut));
				midiOutClose(HMIDIOUT(m_pSharedMemory->m_hMidiOut));
			}
			// This is bogus - midiOutClose has already closed this handle
			// if (g_pDataTransmitter == NULL) {		// DataTransmitter closes its own handle
			//  	CloseHandle(m_pSharedMemory->m_hMidiOut);
			// }
			m_pSharedMemory->m_hMidiOut = NULL;
		}

		// Kill Data Transmitter
		if (g_pDataTransmitter != NULL) {
			delete g_pDataTransmitter;
			g_pDataTransmitter = NULL;
		}


		// Release Mutex handles
//		if (m_hSWFFDataMutex) CloseHandle(m_hSWFFDataMutex); -- Unlock will take care of this

		// Kill RTC Spring object
		if (m_pJoltEffectList[SYSTEM_RTCSPRING_ID])
		{
			delete m_pJoltEffectList[SYSTEM_RTCSPRING_ID];
			m_pJoltEffectList[SYSTEM_RTCSPRING_ID] = NULL;
		}
		// Release the Midi Output Event handles
		if (m_hMidiOutputEvent)	
		{
			CloseHandle (m_hMidiOutputEvent);
			m_hMidiOutputEvent = NULL;
		}
	}

	UnlockSharedMemory();
// ***** End of Shared Memory Access *****

	// Release Memory Mapped file handles
	if (m_hSharedMemoryFile)
	{
		BOOL bRet = UnmapViewOfFile((LPCVOID) m_pSharedMemory);
		bRet = CloseHandle(m_hSharedMemoryFile);
	}

	// Close VxD handles
	if (g_pDriverCommunicator != NULL)
	{
		delete g_pDriverCommunicator;
		g_pDriverCommunicator = NULL;
	}

	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

// --- END OF CRITICAL SECTION
//
	if (bKillObject)
	{
		// Delete the critical section object
//		DeleteCriticalSection(&g_SWFFCriticalSection);
	}
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::Initialize
// Purpose:		Initializer
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::Initialize(DWORD dwDeviceID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet = SUCCESS;

	// initialize the MIDI output information block
	m_MidiOutInfo.uDeviceType     = MIDI_OUT;
	m_MidiOutInfo.hMidiOut        = NULL;
    m_MidiOutInfo.fAlwaysKeepOpen = TRUE;
    m_MidiOutInfo.uDeviceStatus   = MIDI_DEVICE_IDLE;
	m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;
	m_MidiOutInfo.MidiHdr.dwUser = 0;
	m_MidiOutInfo.MidiHdr.dwOffset = 0;
	m_MidiOutInfo.MidiHdr.dwFlags = 0;
	
    // Allocate and lock global memory for SysEx messages
    m_hPrimaryBuffer = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, MAX_SYS_EX_BUFFER_SIZE);
	assert(m_hPrimaryBuffer);
	if(NULL == m_hPrimaryBuffer)
	{
		return (SFERR_DRIVER_ERROR);
	}

    m_pPrimaryBuffer = (LPBYTE) GlobalLock(m_hPrimaryBuffer);
	assert(m_pPrimaryBuffer);
    if(NULL == m_pPrimaryBuffer)
	{
	   	GlobalFree(m_hPrimaryBuffer);
		return (SFERR_DRIVER_ERROR);
	}

	// Initialize the IOCTL interface to VjoyD mini-driver
	hRet = InitDigitalOverDrive(dwDeviceID);
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Digital OverDrive\n");
		return (hRet);
	}
	else
		DebugOut("InitDigitalOverDrive - Success\n");

	// Create a Callback Event
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (NULL == hEvent)
	{
		// Create an Event for notification when Midi Output has completed
		m_hMidiOutputEvent = CreateEvent(NULL,  // No security
                          TRUE,			// Manual reset
                          FALSE,		// Initial event is non-signaled
                          SWFF_MIDIEVENT );		// Named
		assert(m_hMidiOutputEvent);
	}
	else
		m_hMidiOutputEvent = hEvent;

	// We are only called after g_pJoltMidi is created
	assert(g_pJoltMidi);
	PDELAY_PARAMS pDelayParams = g_pJoltMidi->DelayParamsPtrOf();
	GetDelayParams(dwDeviceID, pDelayParams);

	// Reset HW first
	g_pDriverCommunicator->ResetDevice();
	Sleep(DelayParamsPtrOf()->dwHWResetDelay);

	// Set MIDI channel to default then Detect a Midi Device
	SetMidiChannel(DEFAULT_MIDI_CHANNEL);
	if (!DetectMidiDevice(dwDeviceID,				// joystick ID
						  &m_MidiOutInfo.uDeviceID,	// Midi Device ID
						  &m_COMMInterface, 		// COMM_WINMM||COMM_BACKDOOR
						  							// ||COMM_SERIAL
						  &m_COMMPort))				// Port address
	{
		DebugOut("SW_EFFCT: Warning! No Midi Device detected\n");
		return (SFERR_DRIVER_ERROR);
	}
	else
	{
#ifdef _DEBUG
		wsprintf(g_cMsg,"DetectMidiDevice returned: DeviceID=%d, COMMInterface=%x, COMMPort=%x\n",
			m_MidiOutInfo.uDeviceID, m_COMMInterface, m_COMMPort);
		DebugOut(g_cMsg);
#endif
	}

// Allocate the Instance data buffer
    m_lpCallbackInstanceData = AllocCallbackInstanceData();
	assert(m_lpCallbackInstanceData);

// Initialize Midi channel, then open the Input and Output channels
	m_MidiChannel = DEFAULT_MIDI_CHANNEL;

	// Send Initialization packet(s) to Jolt
	hRet = CMD_Init();
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Jolt\n");
		return (hRet);
	}		
	else
		DebugOut("JOLT CMD_Init - Success\n");

	// At this point, we have a valid MIDI path...
	// Continue by setting up the ROM Effects default table entries
							 // ID  , OutputRate, Gain, Duration
	static	ROM_FX_PARAM RomFxTable [] = {{ RE_ROMID1 , 100, 100, 12289 }, // Random Noise
								  { RE_ROMID2 , 100, 100,  2625 }, // AircraftCarrierTakeOff
								  { RE_ROMID3 , 100,  50,   166 }, // BasketballDribble
								  { RE_ROMID4 , 100,  14, 10000 }, // CarEngineIdling
								  { RE_ROMID5 , 100,  30,  1000 }, // Chainsaw
								  { RE_ROMID6 , 100, 100,  1000 }, // ChainsawingThings
								  { RE_ROMID7 , 100,  40, 10000 }, // DieselEngineIdling
								  { RE_ROMID8 , 100, 100,   348 }, // Jump
								  { RE_ROMID9 , 100, 100,   250 }, // Land
								  { RE_ROMID10, 200, 100,  1000 }, // MachineGun
								  { RE_ROMID11, 100, 100,    83 }, // Punched
								  { RE_ROMID12, 100, 100,  1000 }, // RocketLauncher
								  { RE_ROMID13, 100,  98,   500 }, // SecretDoor
								  { RE_ROMID14, 100,  66,    25 }, // SwitchClick
								  { RE_ROMID15, 100,  75,   500 }, // WindGust
								  { RE_ROMID16, 100, 100,  2500 }, // WindShear
								  { RE_ROMID17, 100, 100,    50 }, // Pistol
								  { RE_ROMID18, 100, 100,   295 }, // Shotgun
								  { RE_ROMID19, 500,  95,  1000 }, // Laser1
								  { RE_ROMID20, 500,  96,  1000 }, // Laser2
								  { RE_ROMID21, 500, 100,  1000 }, // Laser3
								  { RE_ROMID22, 500, 100,  1000 }, // Laser4
								  { RE_ROMID23, 500, 100,  1000 }, // Laser5
								  { RE_ROMID24, 500,  70,  1000 }, // Laser6
								  { RE_ROMID25, 100, 100,    25 }, // OutOfAmmo
								  { RE_ROMID26, 100,  71,  1000 }, // LigntningGun
								  { RE_ROMID27, 100, 100,   250 }, // Missile
								  { RE_ROMID28, 100, 100,  1000 }, // GatlingGun
								  { RE_ROMID29, 500,  97,   250 }, // ShortPlasma
								  { RE_ROMID30, 500, 100,   500 }, // PlasmaCannon1
								  { RE_ROMID31, 500,  99,   625 }, // PlasmaCannon2
								  { RE_ROMID32, 100, 100,   440 }}; // Cannon
//								  { RE_ROMID33, 100,  68,  1000 }, // FlameThrower
//								  { RE_ROMID34, 100, 100,    75 }, // BoltActionRifle
//								  { RE_ROMID35, 500, 100,   300 }, // Crossbow
//								  { RE_ROMID36, 100, 100,  1000 }, // Sine
//								  { RE_ROMID37, 100, 100,  1000 }}; // Cosine
	m_pRomFxTable = &RomFxTable[0];

// ***** Shared Memory Access *****
	LockSharedMemory();
	LONG lRefCnt = m_pSharedMemory->m_RefCnt;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		
	// Initialize the RTC_Spring object
	SYSTEM_PARAMS SystemParams;
	GetSystemParams(dwDeviceID, &SystemParams);

	RTCSPRING_PARAM RTCSpring = { sizeof(RTCSPRING_PARAM),
								  DEFAULT_RTC_KX,
								  DEFAULT_RTC_KY,
								  DEFAULT_RTC_X0,
								  DEFAULT_RTC_Y0,
								  DEFAULT_RTC_XSAT,
								  DEFAULT_RTC_YSAT,
								  DEFAULT_RTC_XDBAND,
								  DEFAULT_RTC_YDBAND };

	
	CMidiRTCSpring * pMidiRTCSpring = new CMidiRTCSpring(&RTCSpring);

	SetEffectByID(SYSTEM_RTCSPRING_ID, pMidiRTCSpring);

	DNHANDLE DnHandle;
	CMD_Download_RTCSpring(&(SystemParams.RTCSpringParam),&DnHandle);

	// initialize the joystick params
	JOYSTICK_PARAMS JoystickParams;
	GetJoystickParams(dwDeviceID, &JoystickParams);
	UpdateJoystickParams(&JoystickParams);

	// initialize the firmware params fudge factors (for the first time)
	// in the case of the FFD interface, this will be the only time they
	// are initialized, which may cause a problem because joystick is assumed
	// to be ID1
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	GetFirmwareParams(dwDeviceID, pFirmwareParams);

// --- END OF CRITICAL SECTION
//
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::LockSharedMemory
// Purpose:     Creates a Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     TRUE if Mutex available else FALSE

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::LockSharedMemory(void)
{
	DWORD dwRet;
	{ // --- THIS IS A CRITICAL SECTION
		CriticalLock cl;

		// Create the SWFF mutex
		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, SWFF_SHAREDMEM_MUTEX);
		if (NULL == hMutex) {
			// Doesn't exist yet, so create it
			hMutex = CreateMutex(NULL, TRUE, SWFF_SHAREDMEM_MUTEX);
			if (NULL == hMutex)
			{
#ifdef _DEBUG
				DebugOut("Error! Could not create SWFFDataMutex\n");
#endif
				m_hSWFFDataMutex = NULL;
				return (FALSE);
			}
		}
		// SUCCESS
		m_hSWFFDataMutex = hMutex;
		dwRet = WaitForSingleObject(m_hSWFFDataMutex, MUTEX_TIMEOUT);
	} 	// --- END OF CRITICAL SECTION

	if (WAIT_OBJECT_0 == dwRet)
		return (TRUE);
	else
	{
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"CJoltMidi::LockSharedMemory() error return: %lx\n", dwRet);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif		
		return (FALSE);
	}
}


// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::UnlockSharedMemory
// Purpose:     Releases Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     none

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
void CJoltMidi::UnlockSharedMemory(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	if (NULL != m_hSWFFDataMutex)
	{
		ReleaseMutex(m_hSWFFDataMutex);
		CloseHandle(m_hSWFFDataMutex);
		m_hSWFFDataMutex=NULL;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::NewEffectID
// Purpose:		Generates a new Effect ID
// Parameters:	PDNHANDLE pDnloadID	- Pointer to a new Effect ID
//
// Returns:		TRUE if successful, else FALSE
// Algorithm:
// ----------------------------------------------------------------------------
BOOL CJoltMidi::NewEffectID(PDNHANDLE pDnloadID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	BOOL bRet = FALSE;
	int nID_Index = 2;		// ID0 = RTC Spring, ID1 = Friction cancellation
	for (int i=nID_Index; i<MAX_EFFECT_IDS; i++)
	{
		if (NULL == m_pJoltEffectList[i])
		{
			*pDnloadID = (DNHANDLE) i;
#ifdef _DEBUG
			wsprintf(g_cMsg,"New Effect ID=%d\n",i);
			DebugOut(g_cMsg);
#endif
			bRet = TRUE;
			break;
		}
	}

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (bRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::DeleteDownloadedEffects
// Purpose:		Deletes all downloaded Effects
// Parameters:	none
//
// Returns:
// Algorithm:
// Note: Does not delete System Effect IDs like RTC_SPRING and FRICTION CANCEL
//
// ----------------------------------------------------------------------------
void CJoltMidi::DeleteDownloadedEffects(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

#ifdef _DEBUG
	DebugOut("CJoltMidi::DeleteDownloadedEffects()\n");
#endif
	// Free the MIDI Effect objects
	for (int i=(SYSTEM_RTCSPRING_ID+1); i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i])
		{
			delete m_pJoltEffectList[i];
			m_pJoltEffectList[i]= NULL;
		}
	}

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::RestoreDownloadedEffects
// Purpose:		Restores all Downloaded Effects
// Parameters:	none
//
// Returns:
// Algorithm:
// ----------------------------------------------------------------------------
void CJoltMidi::RestoreDownloadedEffects(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet;
	DNHANDLE DummyID;

#ifdef _DEBUG
	DebugOut("CJoltMidi::RestoreDownloadedEffects()\n");
#endif
	// Walk the list and restore the MIDI Effect objects
	for (int i=0; i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i])
		{
#ifdef _DEBUG
			wsprintf(g_cMsg,"Restoring Effect ID:%d\n", i);
			DebugOut(g_cMsg);
#endif
			// Generate Sys_Ex packet then prepare for output	
			(m_pJoltEffectList[i])->GenerateSysExPacket();
			int nSizeBuf = (m_pJoltEffectList[i])->MidiBufferSizeOf();
			int nRetries = MAX_RETRY_COUNT;
			while (nRetries > 0)
			{
				hRet = (m_pJoltEffectList[i])->SendPacket(&DummyID, nSizeBuf);
				if (SUCCESS == hRet) break;
				BumpRetryCounter();
				nRetries--;
			}
			assert(SUCCESS == hRet);
		}
	}
// --- END OF CRITICAL SECTION
//
}


// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::OpenOutput
// Purpose:		Opens Midi Output
// Parameters:	int nDeviceID - MIDI device ID 0-based.
//
// Returns:		success or Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::OpenOutput(int nDeviceID)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

// ***** Shared Memory Access *****
	LockSharedMemory();	
	// Return if already opened by another task
	if (m_pSharedMemory->m_hMidiOut)
	{
		m_MidiOutInfo = m_pSharedMemory->m_MidiOutInfo;
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		return (SUCCESS);
	}

	MMRESULT wRtn;
	// Get MIDI input device caps
	assert(nDeviceID <= (int) midiOutGetNumDevs());
	wRtn = midiOutGetDevCaps(nDeviceID, (LPMIDIOUTCAPS) &m_MidiOutCaps,
                               sizeof(MIDIOUTCAPS));
	if(MMSYSERR_NOERROR != wRtn)
	{
#ifdef _DEBUG
		midiOutGetErrorText(wRtn, (LPSTR)g_cMsg, sizeof(g_cMsg));
    	DebugOut(g_cMsg);
		DebugOut(":midiOutGetDevCaps\n");
#endif
		return (SFERR_DRIVER_ERROR);
	}

	// Now open, with Callback handler
	HANDLE hMidiOut = NULL;
	wRtn = midiOutOpen((LPHMIDIOUT)&hMidiOut,
                      nDeviceID,
//                      (DWORD) m_hMidiOutputEvent,
                      (DWORD) NULL,
                      (DWORD) this,			// the CJoltMidi object
                      CALLBACK_EVENT);

	if(MMSYSERR_NOERROR != wRtn)
	{
#ifdef _DEBUG
		midiOutGetErrorText(wRtn, (LPSTR)g_cMsg, sizeof(g_cMsg));
		DebugOut(g_cMsg);
		wsprintf(g_cMsg, "midiOutOpen(%u)\n", nDeviceID);
		DebugOut(g_cMsg);
#endif
		return (SFERR_DRIVER_ERROR);
	}
	m_MidiOutInfo.hMidiOut = HMIDIOUT(hMidiOut);
	m_MidiOutDeviceID = nDeviceID;
	m_MidiOutOpened = TRUE;
	m_pSharedMemory->m_MidiOutInfo = m_MidiOutInfo;

	// Copy Midi Output handle to SharedMemory
	m_pSharedMemory->m_hMidiOut = hMidiOut;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****

// --- END OF CRITICAL SECTION
//
	return (SUCCESS);
}


// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::AllocCallbackInstanceData
// Purpose:		Allocates a CALLBACKINSTANCEDATA structure.  This structure is
//				used to pass information to the low-level callback function,
//				each time it receives a message. Because this structure is
//				accessed by the low-level callback function, it must be
//				allocated using GlobalAlloc() with the  GMEM_SHARE and
//				GMEM_MOVEABLE flags and page-locked with GlobalPageLock().
//
// Parameters:	none
//
// Returns:		A pointer to the allocated CALLBACKINSTANCE data structure.
//				else NULL if Fail
// Algorithm:
// ----------------------------------------------------------------------------
LPCALLBACKINSTANCEDATA CJoltMidi::AllocCallbackInstanceData(void)
{
    HANDLE hMem;
    LPCALLBACKINSTANCEDATA lpBuf;

    // Allocate and lock global memory.
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CALLBACKINSTANCEDATA));
    if(hMem == NULL) return NULL;

    lpBuf = (LPCALLBACKINSTANCEDATA)GlobalLock(hMem);
    if(lpBuf == NULL)
    {
        GlobalFree(hMem);
        return NULL;
    }

	// Save the handle.
    lpBuf->hSelf = hMem;
    return lpBuf;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::FreeCallbackInstanceData
// Purpose:		Frees the memory for the CALLBACKINSTANCEDATA structure
// Parameters:	none
//
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CJoltMidi::FreeCallbackInstanceData(void)
{
LPCALLBACKINSTANCEDATA lpBuf = m_lpCallbackInstanceData;
    HANDLE hMem;

// Save the handle until we're through here.
    hMem = lpBuf->hSelf;

// Free the structure.
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetAckNackData
// Purpose:		Waits for a Response ACK
//
// Parameters:	int nTImeWait		- Time to wait in 1 ms increment, 0=no wait
//				PACKNACK pAckNack	- Pointer to ACKNACK structure
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetAckNackData(
	IN int nTimeWait,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	assert(pAckNack);
// Use IOCTL from VxD to get AckNack data
// Wait for Event to be set
	if (nTimeWait && m_hMidiOutputEvent)
	{
		DWORD dwRet = WaitForSingleObject(m_hMidiOutputEvent, nTimeWait);
		//		:
#ifdef _DEBUG
		wsprintf(g_cMsg,"WaitForSingleObject %lx returned %lx, nTimeWait=%ld\n", m_hMidiOutputEvent, dwRet, nTimeWait);
		DebugOut(g_cMsg);
#endif
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);
	}

	HRESULT hRet = g_pDriverCommunicator->GetAckNack(*pAckNack, regindex);

// --- END OF CRITICAL SECTION
//
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetEffectStatus
// Purpose:		Checks status of Effect
//
// Parameters:	int DnloadID		- Effect ID
//				PBYTE pStatusCode	- Ptr to a byte for status code
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetEffectStatus(
	IN DWORD DnloadID ,
	IN OUT PBYTE pStatusCode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	assert(pStatusCode);
	HRESULT hRet = CMD_GetEffectStatus((DNHANDLE) DnloadID, pStatusCode);

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::InitDigitalOverDrive
// Purpose:		Initialize the VxD interface
//
// Parameters:	none
//
// Returns:		SUCCESS or Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT	CJoltMidi::InitDigitalOverDrive(DWORD dwDeviceID)
{
	if (g_pDriverCommunicator != NULL)
	{	// Attempt to reinit
		ASSUME_NOT_REACHED();
		return S_OK;
	}

//
// --- THIS IS A CRITICAL SECTION
//
	HRESULT hRet = SUCCESS;
	DWORD driverMajor = 0xFFFFFFFF;
	DWORD driverMinor = 0xFFFFFFFF;

	g_CriticalSection.Enter();
	// This fork works on NT5 only (VxD stuff removed)
	assert(g_ForceFeedbackDevice.IsOSNT5() == TRUE);
	{
		g_pDriverCommunicator = new HIDFeatureCommunicator;
		if (g_pDriverCommunicator == NULL)
		{
			g_CriticalSection.Leave();
			return DIERR_OUTOFMEMORY;
		}
		if (((HIDFeatureCommunicator*)g_pDriverCommunicator)->Initialize(dwDeviceID) == FALSE)
		{	// Could not load the driver
			hRet = SFERR_DRIVER_ERROR;
		}
	}

	if (FAILED(hRet))
	{
		return hRet;
	}

	// Loaded driver, get the version
	g_pDriverCommunicator->GetDriverVersion(driverMajor, driverMinor);

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

	g_ForceFeedbackDevice.SetDriverVersion(driverMajor, driverMinor);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltStatus
// Purpose:		Returns JOLT Device Status using SWForce SWDEVICESTATE struct
//
// Parameters:	LPDEVICESTATE pDeviceState
//
// Returns:		none
//				
// Algorithm:	copies SWDEVICESTATUS to caller
// Internal Representation:
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
									//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
									// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// TRUE=SERIAL, FALSE=MIDI
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltStatus(PSWDEVICESTATE pDeviceState)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	
	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
	
	HRESULT hRet = g_pDriverCommunicator->GetStatus(statusPacket);
	if (hRet == SUCCESS) {
		// Store/update Jolt's status in main object
		SetJoltStatus(&statusPacket);
		memcpy(pDeviceState, &m_DeviceState, sizeof(SWDEVICESTATE));
	}

//
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltStatus
// Purpose:		Returns JOLT Device Status
//
// Parameters:	LPDEVICESTATE pDeviceState using DXFF DEVICESTATE
//
// Returns:		none
//				
// Algorithm:	copies SWDEVICESTATUS to caller converted to DEVICESTATE
// Internal Representation:
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//    0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								//    Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// DirectInputEffect Representation
//typedef struct DEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
//where:
//// dwState values:
//DS_FORCE_SHUTDOWN   0x00000001
//DS_FORCE_ON         0x00000002
//DS_FORCE_OFF        0x00000003
//DS_CONTINUE         0x00000004
//DS_PAUSE            0x00000005
//DS_STOP_ALL         0x00000006
//
// dwSwitches values:
//DSW_ACTUATORSON         0x00000001
//DSW_ACTUATORSOFF        0x00000002
//DSW_POWERON             0x00000004
//DSW_POWEROFF            0x00000008
//DSW_SAFETYSWITCHON      0x00000010
//DSW_SAFETYSWITCHOFF     0x00000020
//DSW_USERFFSWITCHON      0x00000040
//DSW_USERFFSWTTCHOFF     0x00000080
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltStatus(LPDIDEVICESTATE pDeviceState)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};

	HRESULT hRet = g_pDriverCommunicator->GetStatus(StatusPacket);
	if (hRet != SUCCESS)  {
		return (hRet);
	}
	
	// Store/update Jolts status
	SetJoltStatus(&StatusPacket);
#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: DXFF:dwDeviceStatus=%.8lx\n",&szDeviceName, StatusPacket.dwDeviceStatus);	
	DebugOut(g_cMsg);
#endif

	pDeviceState->dwState = 0;
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//		 So, also Map the redundant info that DI needs if necessary
	switch(m_DeviceState.m_ForceState)
	{
		case SWDEV_SHUTDOWN:
			pDeviceState->dwState = DIGFFS_ACTUATORSON;
			break;
		
		case SWDEV_FORCE_ON:
			pDeviceState->dwState = DIGFFS_ACTUATORSON;
			break;

		case SWDEV_FORCE_OFF:
			pDeviceState->dwState = DIGFFS_ACTUATORSOFF;
			break;
		
		default:
			break;
	}

	// see if the stick is empty
	// remember that ID's start at 2
	BOOL bEmpty = TRUE;
	for (int i=2; i<MAX_EFFECT_IDS; i++)
	{
		if (m_pJoltEffectList[i] != NULL)
			bEmpty = FALSE;
	}
	
	if(bEmpty)
		pDeviceState->dwState |= DIGFFS_EMPTY;


	switch(m_DeviceState.m_EffectState)
	{
		case SWDEV_PAUSE:
			pDeviceState->dwState |= DIGFFS_PAUSED;
			break;

		case SWDEV_CONTINUE:
			break;

		case SWDEV_STOP_ALL:
			pDeviceState->dwState |= DIGFFS_STOPPED;
			break;

		default:
			break;
	}

	if(m_DeviceState.m_HOTS)
		pDeviceState->dwState |= DIGFFS_SAFETYSWITCHON;
	else
		pDeviceState->dwState |= DIGFFS_SAFETYSWITCHOFF;

	if (m_DeviceState.m_ACBrickFault)
		pDeviceState->dwState |= DIGFFS_POWEROFF;
	else
		pDeviceState->dwState |= DIGFFS_POWERON;

	pDeviceState->dwLoad = 0;	//m_DeviceState.m_BandWidth * SCALE_GAIN;

// --- END OF CRITICAL SECTION
//
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::SetJoltStatus
// Purpose:		Sets JOLT Device Status
//
// Parameters:	PJOYCHANNELSTATUS pJoyChannelStatus
//
// Returns:		none
//				
// Algorithm:	Sets SWDEVICESTATE from caller

//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_FORCE_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0(FALSE) = Hands Off, 1 (TRUE) = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0(FALSE) = AC Brick OK, 1(TRUE) = AC Fault
//	ULONG	m_ResetDetect;		// 1(TRUE) = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1(TRUE) = Shutdown detected
//	ULONG	m_CommMode;			// 0(FALSE) = Midi, 1(TRUE) = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
// ----------------------------------------------------------------------------
void CJoltMidi::SetJoltStatus(JOYCHANNELSTATUS* pJoyChannelStatus)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	if (pJoyChannelStatus->dwDeviceStatus & HOTS_MASK)
		m_DeviceState.m_HOTS = TRUE;
	else
		m_DeviceState.m_HOTS = FALSE;

	if (pJoyChannelStatus->dwDeviceStatus & BANDWIDTH_MASK)
		m_DeviceState.m_BandWidth = MINIMUM_BANDWIDTH;
	else
		m_DeviceState.m_BandWidth = MAXIMUM_BANDWIDTH;
	
	if (pJoyChannelStatus->dwDeviceStatus & AC_FAULT_MASK)
		m_DeviceState.m_ACBrickFault = TRUE;
	else
		m_DeviceState.m_ACBrickFault = FALSE;


	if (pJoyChannelStatus->dwDeviceStatus & COMM_MODE_MASK)
		m_DeviceState.m_CommMode = TRUE;	// Serial RS232
	else
		m_DeviceState.m_CommMode = FALSE;	// Midi port

	if (pJoyChannelStatus->dwDeviceStatus & RESET_MASK)
		m_DeviceState.m_ResetDetect = TRUE;	// Power ON Reset entered
	else
		m_DeviceState.m_ResetDetect = FALSE;
//REVIEW: If we detected a Reset, shouldn't we go through re-init of object?

	if (pJoyChannelStatus->dwDeviceStatus & SHUTDOWN_MASK)
		m_DeviceState.m_ShutdownDetect = TRUE;	// Soft Reset received
	else
		m_DeviceState.m_ShutdownDetect = FALSE;

// --- END OF CRITICAL SECTION
//
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::UpdateDeviceMode
// Purpose:		Sets JOLT Device Mode
//
// Parameters:	ULONG ulMode
//
// Returns:		none
//				
// Algorithm:
// This is the SideWinder State structure
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
void CJoltMidi::UpdateDeviceMode(ULONG ulMode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	switch (ulMode)
	{
		case SWDEV_FORCE_ON:			// REVIEW
		case SWDEV_FORCE_OFF:
			m_DeviceState.m_ForceState = ulMode;
			break;

		case SWDEV_SHUTDOWN:
			m_DeviceState.m_ForceState = ulMode;
			m_DeviceState.m_EffectState = 0;
			break;

		case SWDEV_STOP_ALL:
		case SWDEV_CONTINUE:
		case SWDEV_PAUSE:
			m_DeviceState.m_EffectState = ulMode;
			break;

		default:
			break;
	}
// --- END OF CRITICAL SECTION
//
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltID
// Purpose:		Returns JOLT ProductID
//
// Parameters:	LOCAL_PRODUCT_ID pProductID	- Pointer to a LOCAL_PRODUCT_ID structure
//
// Returns:		none
//				
// Algorithm:	
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltID(LOCAL_PRODUCT_ID* pProductID)
{
	HRESULT hRet;
	assert(pProductID->cBytes = sizeof LOCAL_PRODUCT_ID);
	if (pProductID->cBytes != sizeof LOCAL_PRODUCT_ID) return (SFERR_INVALID_STRUCT_SIZE);

//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		if (SUCCESS == (hRet = g_pDriverCommunicator->GetID(*pProductID))) break;
	}
	if (SUCCESS == hRet)
	{
		memcpy(&m_ProductID, pProductID, sizeof LOCAL_PRODUCT_ID);
	}
	else
		DebugOut("GetJoltID: Warning! GetIDPacket - Fail\n");

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::LogError
// Purpose:		Logs Error codes
//
// Parameters:	HRESULT SystemError		- System Error code
//				HRESULT DriverError		- Driver Error code
//
// Returns:		SWFORCE Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
typedef struct _DRIVERERROR {
	ULONG	ulDriverCode;
	LONG	lSystemCode;
} DRIVERERROR, *PDRIVERERROR;

HRESULT	CJoltMidi::LogError(
	IN HRESULT SystemError,
	IN HRESULT DriverError)
{
// REVIEW: map MM error codes to our SWForce codes

	DRIVERERROR DriverErrorCodes[] = {
		{DEV_ERR_INVALID_ID        , SWDEV_ERR_INVALID_ID},
		{DEV_ERR_INVALID_PARAM     , SWDEV_ERR_INVALID_PARAM},
		{DEV_ERR_CHECKSUM          , SWDEV_ERR_CHECKSUM},
		{DEV_ERR_TYPE_FULL         , SWDEV_ERR_TYPE_FULL},
		{DEV_ERR_UNKNOWN_CMD       , SWDEV_ERR_UNKNOWN_CMD},
		{DEV_ERR_PLAYLIST_FULL     , SWDEV_ERR_PLAYLIST_FULL},
		{DEV_ERR_PROCESS_LIST_FULL , SWDEV_ERR_PROCESSLIST_FULL} };

	int nDriverErrorCodes = sizeof(DriverErrorCodes)/(sizeof(DRIVERERROR));
	for (int i=0; i<nDriverErrorCodes; i++)
	{
		if (DriverError == (LONG) DriverErrorCodes[i].ulDriverCode)
		{
			SystemError = DriverErrorCodes[i].lSystemCode;
			break;
		}
	}
	// Store in Jolt object
	m_Error.HCode = SystemError;
	m_Error.ulDriverCode = DriverError;

#ifdef _DEBUG
	wsprintf(g_cMsg,"LogError: SystemError=%.8lx, DriverError=%.8lx\n",
			 SystemError, DriverError);
	DebugOut(g_cMsg);
#endif
	return SystemError;
}

//
// ----------------------------------------------------------------------------
// Function: 	SetupROM_Fx
// Purpose:		Sets up parameters for ROM Effects
// Parameters:  PEFFECT pEffect
//				
//
// Returns:		pEffect is updated with new ROM parameters
//				OutputRate
//				Gain
//				Duration
//	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::SetupROM_Fx(
	IN OUT PEFFECT pEffect)
{
	assert(pEffect);
	if (NULL == pEffect) return (SFERR_INVALID_PARAM);
							
	ULONG ulSubType = pEffect->m_SubType;
	BOOL bFound = FALSE;
	for (int i=0; i< MAX_ROM_EFFECTS; i++)
	{
		if (ulSubType == m_pRomFxTable[i].m_ROM_Id)
		{
			bFound = TRUE;
			break;
		}
	}
	if (!bFound) return (SFERR_INVALID_OBJECT);
	// Found, so fill in the default parameters, use Default if Gain=1, Duration=-1, OutputRate=-1
	BOOL bDefaultDuration = (ULONG)-1 == pEffect->m_Duration;
	if (1 == pEffect->m_Gain) pEffect->m_Gain = m_pRomFxTable[i].m_Gain;
	if (bDefaultDuration) pEffect->m_Duration = m_pRomFxTable[i].m_Duration;
	if ((ULONG)-1 == pEffect->m_ForceOutputRate)
	{
		pEffect->m_ForceOutputRate = m_pRomFxTable[i].m_ForceOutputRate;
	}
	else if(bDefaultDuration && pEffect->m_ForceOutputRate != 0)
	{
		// scale the duration to correspond to the output rate
		pEffect->m_Duration = pEffect->m_Duration*m_pRomFxTable[i].m_ForceOutputRate/pEffect->m_ForceOutputRate;
	}
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	DetectMidiDevice
// Purpose:    	Determines Midi Output Device ID
// Parameters:
//				DWORD dwDeviceID		- joystick ID
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//				else FALSE
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::DetectMidiDevice(
	IN DWORD dwDeviceID,
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet;
	BOOL bMidiOutFound = FALSE;
	int nMidiOutDevices;

	// Valid Serial and MIDI ports table
	ULONG MIDI_Ports[] = {0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
						0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	ULONG Serial_Ports[] = { 1, 2, 3, 4 };	// Entry0 is default
	int nMIDI_Ports = sizeof(MIDI_Ports)/sizeof(ULONG);
	int nSerial_Ports = sizeof(Serial_Ports)/sizeof(ULONG);

	// Set defaults
	*pCOMMInterface = COMM_WINMM;
	*pCOMMPort      = NULL;
	*pDeviceOutID 	= 0;

	SWDEVICESTATE SWDeviceState = {sizeof(SWDEVICESTATE)};
	
	// Turn on tristated Jolt MIDI lines by call GetIDPacket()
	LOCAL_PRODUCT_ID ProductID = {sizeof LOCAL_PRODUCT_ID };
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);	
	if (SUCCESS != GetJoltID(&ProductID))
	{
		DebugOut("DetectMidiDevice: Warning! GetIDPacket - Fail\n");
		return (FALSE);
	}

#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: ProductID=%.8lx, FWVersion=%d.%.2ld\n",
		&szDeviceName,	
		m_ProductID.dwProductID,
		m_ProductID.dwFWMajVersion,
		m_ProductID.dwFWMinVersion);
	DebugOut(g_cMsg);
#endif
	// Set the device firmware version from GetID
	g_ForceFeedbackDevice.SetFirmwareVersion(dwDeviceID, m_ProductID.dwFWMajVersion, m_ProductID.dwFWMinVersion);

	// Get Device status prior to starting detection
	BOOL statusPacketFailed = (GetJoltStatus(&SWDeviceState) != SUCCESS);
	if (statusPacketFailed)
	{
		DebugOut("DetectMidiDevice: Warning! StatusPacket - Fail\n");
	}
	if (statusPacketFailed == FALSE) {
#ifdef _DEBUG
		wsprintf(g_cMsg, "RESETDetect=%.8lx, SHUTDOWNDetect=%.8lx, COMMMode=%.8lx\n",
			SWDeviceState.m_ResetDetect,
			SWDeviceState.m_ShutdownDetect,
			SWDeviceState.m_CommMode);
		DebugOut(g_cMsg);
#endif
		// Make sure HW Reset Detect bit is cleared after GetID
		if (SWDeviceState.m_ResetDetect) {
    		DebugOut("DetectMidiDevice: Error! Jolt ResetDetect bit not cleared after GetID\n");
			return (FALSE);
		}
	}

	// See if Serial Dongle connected, otherwise must be MIDI device
    DebugOut("sw_effct:Trying Auto HW Detection: MIDI Serial Port Device...\n");

	// Get Registry values, If high bit of COMMInterface is set, then force override
	// otherwise, do automatic scanning as follows:
	// 1.  Backdoor mode
	// 2.  WinMM mode
	//
	// joyGetForceFeedbackCOMMInterface's 1st param changed to joystick ID
	if (SUCCESS != joyGetForceFeedbackCOMMInterface(dwDeviceID, pCOMMInterface, pCOMMPort)) {
		DebugOut("DetectMidiDevice: Registry key(s) missing! Bailing Out...\n");
		return (FALSE);
	}
#ifdef _DEBUG
	wsprintf(g_cMsg, "DetectMidiDevice: Registry.COMMInterface=%lx, Registry.COMMPort=%lx\n",
			*pCOMMInterface, *pCOMMPort);
	DebugOut(g_cMsg);
#endif																		

	ULONG regInterface = *pCOMMInterface;

	// Was a serial dongle detected, or did we fail to get status
	if (SWDeviceState.m_CommMode || statusPacketFailed) {	// Use serial (regardless what registry says!)
		DebugOut("DetectMidiDevice: Serial Port interface detected.\n");


		// Set to backdoor serial method by default
		*pCOMMInterface = COMM_SERIAL_BACKDOOR;
		m_COMMInterface = COMM_SERIAL_BACKDOOR;

		// Use front-door (serial file method) only, if NT5
		// since there is no backdoor on NT5 registry is irrelevent
		if (g_ForceFeedbackDevice.IsOSNT5()) {
			*pCOMMInterface = COMM_SERIAL_FILE;
			m_COMMInterface = COMM_SERIAL_FILE;
		} else if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() != 16)) {
			// Firmware is not 1.16 (which can't use the frontdoor serial with quick ack/nack)
			if (!(regInterface & MASK_SERIAL_BACKDOOR)) {	// Is back door forced by registry
				*pCOMMInterface = COMM_SERIAL_FILE;	// Use Serial File method
				m_COMMInterface = COMM_SERIAL_FILE;
			}
		}

		// See if already detected and ready to use
		// ***** Shared Memory Access *****
		LockSharedMemory();
		HANDLE hMidiOut = m_pSharedMemory->m_hMidiOut;
		UnlockSharedMemory();
		// ***** End of Shared Memory Access *****

		// Return if already opened by another task
		if (NULL != hMidiOut) {
			bMidiOutFound = TRUE;
		} else {		// Use the serial transmitter to find the proper port (even if backdoor selected)
			if (g_pDataTransmitter != NULL) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			g_pDataTransmitter = new SerialDataTransmitter();

			if (g_pDataTransmitter->Initialize()) {
				LockSharedMemory();
				m_pSharedMemory->m_hMidiOut = g_pDataTransmitter->GetCOMMHandleHack();
				UnlockSharedMemory();
				bMidiOutFound = TRUE;
			}

			// If Serial Backdoor let the driver know which port, kill DataTransmitter (without closing port)
			if (m_COMMInterface == COMM_SERIAL_BACKDOOR) {
				hRet = g_pDriverCommunicator->SetBackdoorPort(g_pDataTransmitter->GetSerialPortHack());
				if (hRet != SUCCESS) { // Low level driver fails, use normal serial routines not backdoor
					DebugOut("\nDetectMidiDevice: Warning! Could not set serial I/O port, cannot use backdoor serial\n");
					*pCOMMInterface = COMM_SERIAL_FILE;
					m_COMMInterface = COMM_SERIAL_FILE;
				} else {
					g_pDataTransmitter->StopAutoClose();
					delete g_pDataTransmitter;
					g_pDataTransmitter = NULL;
				}
			}
		}

		if (bMidiOutFound)
		{
			regInterface = (regInterface & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | m_COMMInterface;
			// joySetForceFeedbackCOMMInterface's 1st param changed to joystick ID
			joySetForceFeedbackCOMMInterface(dwDeviceID, regInterface, *pCOMMPort);
		}

		if ((statusPacketFailed == FALSE) || bMidiOutFound)
		{
			return (bMidiOutFound);
		}
	}	// End of Serial Port Auto HW selection

	// No Serial HW dongle detected, check if any Midi device for WinMM and Backdoor
	DebugOut("sw_effct:Scanning MIDI Output Devices\n");
	nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) {
		DebugOut("DetectMidiDevice: No MIDI devices present\n");
		return (FALSE);
	}

#if 0
	// Try the midi pin solution
	g_pDataTransmitter = new PinTransmitter();
	if (g_pDataTransmitter->Initialize()) {
		// Use backdoor flag for now
		m_COMMInterface = COMM_MIDI_BACKDOOR;
		*pCOMMInterface = COMM_MIDI_BACKDOOR;
		return TRUE;
	}
	// Pin failed delete transmitter continue looking
	delete g_pDataTransmitter;
	g_pDataTransmitter = NULL;
#endif


	ULONG ulPort = *pCOMMPort;
	if ( !(*pCOMMInterface & MASK_OVERRIDE_MIDI_PATH) ) {	// Use Automatic detection
		DebugOut("DetectMidiDevice: Auto Detection. Trying Backdoor\n");
		// Back Door
		bMidiOutFound = FindJoltBackdoor(pDeviceOutID, pCOMMInterface, pCOMMPort);
		if (!bMidiOutFound) {	// Try Front Door
			DebugOut("DetectMidiDevice: trying WINMM...\n");
			bMidiOutFound = FindJoltWinMM(pDeviceOutID, pCOMMInterface, pCOMMPort);
		}
		if (bMidiOutFound) {
			regInterface = (regInterface & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | m_COMMInterface;
			joySetForceFeedbackCOMMInterface(*pDeviceOutID, regInterface, *pCOMMPort);
		}
		return (bMidiOutFound);
	}

	// Over-ride since high bit is set
	*pCOMMInterface &= ~(MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR);	// Mask out high bit (and second bit)
	switch (*pCOMMInterface)
	{
		case COMM_WINMM:
			bMidiOutFound = FindJoltWinMM(pDeviceOutID, pCOMMInterface, pCOMMPort);
			if (!bMidiOutFound) {
				DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values!\n");
			}
			return (bMidiOutFound);
			
		case COMM_MIDI_BACKDOOR:
			int i;
			for (i=0;i<nMIDI_Ports;i++)
			{
				if (ulPort == MIDI_Ports[i])
				{
					bMidiOutFound = TRUE;
					break;
				}
			}
			break;

		case COMM_SERIAL_BACKDOOR:		// mlc - This should never work if no dongle detected
			for (i=0;i<nSerial_Ports;i++)
			{
				if (ulPort == Serial_Ports[i])
				{
					bMidiOutFound = TRUE;
					break;
				}
			}			
			break;					

		default:
			bMidiOutFound	= FALSE;
			break;
	}

	if (!bMidiOutFound)
	{
		DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values\n");
		return (bMidiOutFound);
	}

	// We have the forced Port #, Let's see if Jolt is out there
#ifdef _DEBUG
	wsprintf(g_cMsg,"DetectMidiDevice: (Over-ride) MIDI%.8lx Query - ", ulPort);
	DebugOut(g_cMsg);
#endif
	bMidiOutFound = FALSE;
	hRet = g_pDriverCommunicator->SetBackdoorPort(ulPort);

	if (SUCCESS != hRet)
	{
		DebugOut("\nDetectMidiDevice: Warning! Could not Set Midi/Serial I/O Port\n");
	}
	else
	{
		if (QueryForJolt())
		{
			DebugOut(" Success!\n");
			bMidiOutFound = TRUE;
		}
		else
			DebugOut(" No Answer\n");
	}		

// --- END OF CRITICAL SECTION
//
	return (bMidiOutFound);
}



// *** ---------------------------------------------------------------------***
// Function:   	FindJoltWinMM
// Purpose:    	Searches for Jolt using WinMM
// Parameters: 	none
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::FindJoltWinMM(
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
	HRESULT hRet;
	WORD wTechnology;	// looking for MOD_MIDIPORT
	WORD wChannelMask;	// ==0xFFFF if all 16 channels
	BOOL bMidiOutFound = FALSE;
	
	// Device Capabilities
    MIDIOUTCAPS midiOutCaps;

    int nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) return (FALSE);

	m_COMMInterface = COMM_WINMM;	
	for (int nIndex=0;nIndex<(nMidiOutDevices);nIndex++)
	{
        MMRESULT ret = midiOutGetDevCaps(nIndex, &midiOutCaps, sizeof(midiOutCaps));
		if (ret != MMSYSERR_NOERROR) break;
		wTechnology = midiOutCaps.wTechnology;
		wChannelMask= midiOutCaps.wChannelMask;
#ifdef _DEBUG
		g_CriticalSection.Enter();
        wsprintf(g_cMsg,"FindJoltWinMM: Technology=%x," \
         		"ChannelMask=%x, Mid=%d, Pid=%d\r\n", midiOutCaps.szPname,
         		wTechnology, wChannelMask, midiOutCaps.wMid,
         		midiOutCaps.wPid);
        DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		// Check if this is a MOD_MIDIPORT device
		//REVIEW: Need to check for multiple MOD_MIDIPORT devices
		if (wTechnology == MOD_MIDIPORT)
		{
			*pDeviceOutID = (UINT) nIndex;
#ifdef _DEBUG
			DebugOut("DetectMidiDevice: Opening WinMM Midi Output\n");
#endif
			hRet = OpenOutput(m_MidiOutInfo.uDeviceID);
			if (SUCCESS != hRet)
			{	
				DebugOut("DetectMidiDevice: Error! Could not Open WinMM Midi Output\n");
				return (FALSE);
			}
			else
			{
				DebugOut("Open Midi Output - Success.\nQuery for Jolt Device - ");
				if (QueryForJolt())
				{
					DebugOut(" Success!\n");
					bMidiOutFound = TRUE;
				}
				else
				{
					DebugOut(" No Answer\n");
					bMidiOutFound = FALSE;
					break;
				}
				return (bMidiOutFound);
			}
		} // end of MOD_MIDIPORT
	}
	return (bMidiOutFound);
}


// *** ---------------------------------------------------------------------***
// Function:   	FindJoltBackdoor
// Purpose:    	Searches for Jolt using BackDoor
// Parameters: 	none
//				UINT *pDeviceOutID		- Ptr to Midi Out Device ID
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::FindJoltBackdoor(
	IN OUT UINT *pDeviceOutID,
	OUT ULONG *pCOMMInterface,
	OUT ULONG *pCOMMPort)
{
    int nMidiOutDevices = midiOutGetNumDevs();	
	if (0 == nMidiOutDevices) return (FALSE);

	HRESULT hRet;
	// Valid Serial and MIDI ports table
	ULONG MIDI_Ports[] = {0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
						0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	int nMIDI_Ports = sizeof(MIDI_Ports)/sizeof(ULONG);
	BOOL bMidiOutFound = FALSE;
	
	m_COMMInterface = COMM_MIDI_BACKDOOR;
	*pCOMMInterface = COMM_MIDI_BACKDOOR;
	*pCOMMPort = 0;
	for (int i=0;i<nMIDI_Ports;i++)
	{
#ifdef _DEBUG
        wsprintf(g_cMsg,"FindJoltBackdoor: Midi Port:%lx - ", MIDI_Ports[i]);
        DebugOut(g_cMsg);
#endif
		// We have the Port #, Let's see if Jolt is out there
		hRet = g_pDriverCommunicator->SetBackdoorPort(MIDI_Ports[i]);
		if (SUCCESS == hRet)
		{
			if (QueryForJolt())
			{
				DebugOut(" Success!\n");
				bMidiOutFound = TRUE;
				*pCOMMPort = MIDI_Ports[i];
				break;
			}
			else
				DebugOut(" No Answer\n");
		}		
	}
	return (bMidiOutFound);
}


// *** ---------------------------------------------------------------------***
// Function:   	QueryForJolt
// Purpose:    	Sends Shutdown and Queries for Shutdown status bit
// Parameters: 	none
// Returns:    	BOOL TRUE if Jolt found, else FALSE
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::QueryForJolt(void)
{
	HRESULT hRet;

// Send Shutdown command then detect if Shutdown Detect bit is set
	SWDEVICESTATE SWDeviceState = {sizeof(SWDEVICESTATE)};
	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		// Send a ShutDown, then check for response
		MidiSendShortMsg((SYSTEM_CMD|DEFAULT_MIDI_CHANNEL), SWDEV_SHUTDOWN, 0);
		Sleep(DelayParamsPtrOf()->dwShutdownDelay);	// 10 ms		
		if (SUCCESS == (hRet=GetJoltStatus(&SWDeviceState))) break;
	}
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);		
	// Clear the Previous state and turn on tri-state buffers
	LOCAL_PRODUCT_ID ProductID = {sizeof LOCAL_PRODUCT_ID };
	hRet = GetJoltID(&ProductID);
	if (SUCCESS != hRet)
	{
#ifdef _DEBUG
    	DebugOut("QueryForJolt: Driver Error. Get Jolt Status/ID\n");
#endif
		return (FALSE);
	}
	if (SWDeviceState.m_ShutdownDetect)
		return (TRUE);
	else
		return (FALSE);
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendShortMsg
// Purpose:    	Send status, channel and data.
// Parameters:
//				BYTE cStatus	-  MIDI status byte for this message
//				BYTE cData1		-  MIDI data byte for this message
//				BYTE cData2		-  2nd MIDI data byte for this message (may be 0)
// Returns:    	HRESULT
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendShortMsg(
    IN BYTE cStatus,
    IN BYTE cData1,
    IN BYTE cData2)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

    DWORD dwMsg;
    HRESULT hRet = SUCCESS;
// For diagnostics, record the attempts at this message
	BumpShortMsgCounter();

    if ((m_COMMInterface == COMM_WINMM) && (NULL == m_MidiOutInfo.hMidiOut))
    {
		DebugOut("SW_EFFECT: No Midi Out Devs opened\r\n     ");
		ASSUME_NOT_REACHED();
    	return (SFERR_DRIVER_ERROR);
    }

	// pack the message and send it
    dwMsg = MAKEMIDISHORTMSG(cStatus, m_MidiChannel, cData1, cData2);
	if (COMM_WINMM == m_COMMInterface)
	{
		// Clear the Event Callback
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);

		// send the message only if valid Handle
		if (SUCCESS == ValidateMidiHandle())
		{
			hRet = midiOutShortMsg(m_MidiOutInfo.hMidiOut, dwMsg);
		}
		else
		{
			return (SFERR_DRIVER_ERROR);
		}
		if (SUCCESS != hRet) hRet = SFERR_DRIVER_ERROR;
	}
	else
	{
		hRet = g_pDriverCommunicator->SendBackdoorShortMidi(dwMsg);
	}
// --- END OF CRITICAL SECTION
//
    return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendLongMsg
// Purpose:    	Send system exclusive message or series of short messages.
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendLongMsg(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
    HRESULT hRet = SUCCESS;
// For diagnostics, record the attempts at this message
	BumpLongMsgCounter();

    if (m_MidiOutInfo.uDeviceType != MIDI_OUT)
    {
#ifdef _DEBUG
		MessageBox(NULL, "Must use a MIDI output device",
            "MidiSendLongMsg", MB_ICONSTOP);
#endif
		return (SFERR_DRIVER_ERROR);
    }

	if (COMM_WINMM == m_COMMInterface)
	{
		// Clear the Event Callback
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);

		// send the long message only if valid Handle
		if (SUCCESS == ValidateMidiHandle())
			hRet = midiOutLongMsg(m_MidiOutInfo.hMidiOut,
    	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
		else
		{
			return (SFERR_DRIVER_ERROR);
		}

		if (SUCCESS == hRet)
			m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_BUSY;
    	else
		{
			if (m_MidiOutInfo.MidiHdr.dwFlags != MHDR_DONE)
    		{
    	    	// abort the current message
    	    	hRet = midiOutReset(m_MidiOutInfo.hMidiOut);
    	    	
    	    	// set the device status because buffer(s) have been marked as
    	    	// done and returned to the application
    	    	if (SUCCESS == hRet)
    	    	    m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_ABANDONED;
    		}
    		else
    	    	// tried to abort but the operation was already complete
    	    	m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;
		}
		if (SUCCESS != hRet) hRet = (SFERR_DRIVER_ERROR);
    }
	else
	{
		hRet = g_pDriverCommunicator->SendBackdoorLongMidi(PBYTE(m_MidiOutInfo.MidiHdr.lpData));
	}
	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwLongMsgDelay);

// --- END OF CRITICAL SECTION
//
    return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	ValidateMidiHandle
// Purpose:    	Validates Midi handle and reopens if necessary
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::ValidateMidiHandle(void)
{
	HRESULT hRet = SUCCESS;
	UINT dwID;
	if (MMSYSERR_INVALHANDLE == midiOutGetID(m_MidiOutInfo.hMidiOut, &dwID))
	{
#ifdef _DEBUG
		DebugOut("CJoltMidi::MidiValidateHandle - Midi Handle invalid. Re-opening...\n");
#endif
		// Clear old global handle and Re-open Midi channel
		// ***** Shared Memory Access *****
		LockSharedMemory();
		m_pSharedMemory->m_hMidiOut = NULL;
		UnlockSharedMemory();
		// ***** End of Shared Memory Access *****			
		hRet = OpenOutput(m_MidiOutInfo.uDeviceID);
	}
	return (hRet);
}


// *** ---------------------------------------------------------------------***
// Function:   	MidiAssignBuffer
// Purpose:    	Assign lpData and dwBufferLength members and prepare the
//              MIDIHDR.  Also add the buffer if it is an input buffer.
//              If the third parameter is false, unprepare and reinitialize
//              the header.
// Parameters:
//			    LPSTR lpData    - address of buffer, NULL if cleaning up
//				DWORD dwBufferLength	- buffer size in bytes
//				BOOL fAssign	- TRUE = Assign, FALSE = cleanup
//
// Returns:    	SUCCESS or SFERR_DRIVER_ERROR
//				
// Note: assumes m_pMidiOutInfo structure is valid
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiAssignBuffer(
    LPSTR lpData,             // address of buffer, NULL if cleaning up
    DWORD dwBufferLength,     // size of buffer in bytes, 0L if cleaning up
    BOOL fAssign)             // TRUE = assign, FALSE = cleanup
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;
#ifdef _DEBUG
    DebugOut("MidiAssignBuffer:\n");
#endif
    HRESULT hRet = SUCCESS;
    if (m_MidiOutInfo.uDeviceType == MIDI_OUT)
    {
		if ((COMM_WINMM == m_COMMInterface) && !m_MidiOutInfo.hMidiOut)
        {
            if (!fAssign && m_MidiOutInfo.uDeviceStatus == MIDI_DEVICE_ABANDONED)
            {
                // clear the device status
                m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;

                // don't return an error for this case because if the user aborts
                // the transmission of a long message before it completes the
                // buffers will be marked as done and returned to the application,
                // just as when recording successfully completes.  So it is ok
                // for this function to be called (with fAssign = FALSE) when
                // hMidiIn = 0, as long as uDeviceStatus = MIDI_DEVICE_ABANDONED.
				return (SUCCESS);
            }
            else
            {
                // all other cases are an application error
#ifdef _DEBUG
                MessageBox(NULL, "Must open MIDI output device first",
                    "MidiAssignBuffer", MB_ICONSTOP);
#endif
                // because this failed call might result in an input or output
                // device being reset (if the application is written to do so),
                // an MM_MOM_DONE or MM_MIM_LONGDATA message could be sent to
                // the application.  This might result in an additional call to
                // this routine, so set the device status to prevent another
                // error message
                m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_ABANDONED;
                return (SFERR_DRIVER_ERROR);
            }
        }
    }
    else
    {
#ifdef _DEBUG
        DebugOut("\r\nMidiAssignBuffer: uDeviceType bad");
#endif
        return (SFERR_INVALID_PARAM);
    }

    if (fAssign)
    {
		// check for the buffer's address and size
        if (!lpData || !dwBufferLength)
        {
#ifdef _DEBUG
            MessageBox(NULL, "Must specify a buffer and size",
                "MidiAssignBuffer", MB_ICONSTOP);
#endif
	        return (SFERR_INVALID_PARAM);
        }
        // assign buffer to the MIDIHDR
        m_MidiOutInfo.MidiHdr.lpData = lpData;
        m_MidiOutInfo.MidiHdr.dwBufferLength = dwBufferLength;
        m_MidiOutInfo.MidiHdr.dwBytesRecorded = dwBufferLength;

 		if (COMM_WINMM == m_COMMInterface)
        {
        	// prepare the MIDIHDR
        	m_MidiOutInfo.MidiHdr.dwFlags = 0;
        	hRet = midiOutPrepareHeader(m_MidiOutInfo.hMidiOut,
        	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
		}
	}
    else
    {   // unprepare the MIDIHDR
 		if (COMM_WINMM == m_COMMInterface)
        {
			if ((m_MidiOutInfo.MidiHdr.dwFlags & MHDR_DONE) != MHDR_DONE)
			{
				//hRet = midiOutReset(m_MidiOutInfo.hMidiOut);
			}
			if (SUCCESS == hRet)
        	{
				hRet = midiOutUnprepareHeader(m_MidiOutInfo.hMidiOut,
        	        &(m_MidiOutInfo.MidiHdr), sizeof(MIDIHDR));
        	}
		}
		else
			hRet = SUCCESS;

		if (SUCCESS == hRet)
		{
        	// reinitialize MIDIHDR to guard against casual re-use
        	m_MidiOutInfo.MidiHdr.lpData = NULL;
        	m_MidiOutInfo.MidiHdr.dwBufferLength = 0;
			m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;			
        	// clear the device status
        	m_MidiOutInfo.uDeviceStatus = MIDI_DEVICE_IDLE;
		}
    }

    if (SUCCESS != hRet) hRet = SFERR_DRIVER_ERROR;
#ifdef _DEBUG
    wsprintf(g_cMsg, "Returning from MidiAssignBuffer: %lx\n", hRet);
#endif

// --- END OF CRITICAL SECTION
//
	return (hRet);
}


// ****************************************************************************
// *** --- Helper functions for CJoltMidi
//
// ****************************************************************************
//
#define REGSTR_VAL_FIRMWARE_PARAMS	"FirmwareParams"
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(FIRMWARE_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_FIRMWARE_PARAMS,
							  NULL, NULL,
							  (PBYTE)pFirmwareParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pFirmwareParams->dwScaleKx = DEF_SCALE_KX;
		pFirmwareParams->dwScaleKy = DEF_SCALE_KY;
		pFirmwareParams->dwScaleBx = DEF_SCALE_BX;
		pFirmwareParams->dwScaleBy = DEF_SCALE_BY;
		pFirmwareParams->dwScaleMx = DEF_SCALE_MX;
		pFirmwareParams->dwScaleMy = DEF_SCALE_MY;
		pFirmwareParams->dwScaleFx = DEF_SCALE_FX;
		pFirmwareParams->dwScaleFy = DEF_SCALE_FY;
		pFirmwareParams->dwScaleW  = DEF_SCALE_W;
	}
}

#define REGSTR_VAL_SYSTEM_PARAMS	"SystemParams"
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(SYSTEM_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_SYSTEM_PARAMS,
							  NULL, NULL,
							  (PBYTE)pSystemParams,
							  &dwcb);

		// scale them
		pSystemParams->RTCSpringParam.m_XKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_YKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_XAxisCenter /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YAxisCenter = -pSystemParams->RTCSpringParam.m_YAxisCenter/SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XDeadBand	/= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YDeadBand	/= SCALE_POSITION;



		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pSystemParams->RTCSpringParam.m_Bytes		= sizeof(RTCSPRING_PARAM);
		pSystemParams->RTCSpringParam.m_XKConstant	= DEFAULT_RTC_KX;
		pSystemParams->RTCSpringParam.m_YKConstant	= DEFAULT_RTC_KY;
		pSystemParams->RTCSpringParam.m_XAxisCenter = DEFAULT_RTC_X0;
		pSystemParams->RTCSpringParam.m_YAxisCenter = DEFAULT_RTC_Y0;
		pSystemParams->RTCSpringParam.m_XSaturation = DEFAULT_RTC_XSAT;
		pSystemParams->RTCSpringParam.m_YSaturation = DEFAULT_RTC_YSAT;
		pSystemParams->RTCSpringParam.m_XDeadBand	= DEFAULT_RTC_XDBAND;
		pSystemParams->RTCSpringParam.m_YDeadBand	= DEFAULT_RTC_YDBAND;
	}
}

#define REGSTR_VAL_DELAY_PARAMS	"TimingParams"
void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(DELAY_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_DELAY_PARAMS,
							  NULL, NULL,
							  (PBYTE)pDelayParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pDelayParams->dwBytes								= sizeof(DELAY_PARAMS);
		pDelayParams->dwDigitalOverdrivePrechargeCmdDelay	= DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY;
		pDelayParams->dwShutdownDelay						= DEFAULT_SHUTDOWN_DELAY;
		pDelayParams->dwHWResetDelay						= DEFAULT_HWRESET_DELAY;
		pDelayParams->dwPostSetDeviceStateDelay				= DEFAULT_POST_SET_DEVICE_STATE_DELAY;
		pDelayParams->dwGetEffectStatusDelay				= DEFAULT_GET_EFFECT_STATUS_DELAY;
		pDelayParams->dwGetDataPacketDelay					= DEFAULT_GET_DATA_PACKET_DELAY;
		pDelayParams->dwGetStatusPacketDelay				= DEFAULT_GET_STATUS_PACKET_DELAY;
		pDelayParams->dwGetIDPacketDelay					= DEFAULT_GET_ID_PACKET_DELAY;
		pDelayParams->dwGetStatusGateDataDelay				= DEFAULT_GET_STATUS_GATE_DATA_DELAY;
		pDelayParams->dwSetIndexDelay						= DEFAULT_SET_INDEX_DELAY;
		pDelayParams->dwModifyParamDelay					= DEFAULT_MODIFY_PARAM_DELAY;
		pDelayParams->dwForceOutDelay						= DEFAULT_FORCE_OUT_DELAY;
		pDelayParams->dwShortMsgDelay						= DEFAULT_SHORT_MSG_DELAY;
		pDelayParams->dwLongMsgDelay						= DEFAULT_LONG_MSG_DELAY;
		pDelayParams->dwDestroyEffectDelay					= DEFAULT_DESTROY_EFFECT_DELAY;
		pDelayParams->dwForceOutMod							= DEFAULT_FORCE_OUT_MOD;

		// write the defaults to the registry
		hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
		if(hKey)
		{
			// Modify Registry Values
			RegSetValueEx ( hKey, REGSTR_VAL_DELAY_PARAMS, 0, REG_BINARY, (const unsigned char *)pDelayParams, sizeof(DELAY_PARAMS) );

			// Close Key
			RegCloseKey(hKey);
		}

	}
	if(pDelayParams->dwForceOutMod == 0)
		pDelayParams->dwForceOutMod = 1;
}

#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"
void GetJoystickParams(UINT nJoystickID, PJOYSTICK_PARAMS pJoystickParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(JOYSTICK_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_JOYSTICK_PARAMS,
							  NULL, NULL,
							  (PBYTE)pJoystickParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pJoystickParams->dwXYConst		= DEF_XY_CONST;
		pJoystickParams->dwRotConst		= DEF_ROT_CONST;
		pJoystickParams->dwSldrConst	= DEF_SLDR_CONST;
		pJoystickParams->dwAJPos		= DEF_AJ_POS;
		pJoystickParams->dwAJRot		= DEF_AJ_ROT;
		pJoystickParams->dwAJSldr		= DEF_AJ_SLDR;
		pJoystickParams->dwSprScl		= DEF_SPR_SCL;
		pJoystickParams->dwBmpScl		= DEF_BMP_SCL;
		pJoystickParams->dwDmpScl		= DEF_DMP_SCL;
		pJoystickParams->dwInertScl		= DEF_INERT_SCL;
		pJoystickParams->dwVelOffScl	= DEF_VEL_OFFSET_SCL;
		pJoystickParams->dwAccOffScl	= DEF_ACC_OFFSET_SCL;
		pJoystickParams->dwYMotBoost	= DEF_Y_MOT_BOOST;
		pJoystickParams->dwXMotSat		= DEF_X_MOT_SATURATION;
		pJoystickParams->dwReserved		= 0;
		pJoystickParams->dwMasterGain	= 0;
	}
}

void UpdateJoystickParams(PJOYSTICK_PARAMS pJoystickParams)
{
	// modify the Joystick Params by modifying the SYSTEM_EFFECT_ID
	// note that some parameters must be divided by 2 before being sent
	// Jolt will multiply by 2 to restore to original
	CMD_ModifyParamByIndex(INDEX0, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwXYConst))/2);
	CMD_ModifyParamByIndex(INDEX1, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwRotConst))/2);
	CMD_ModifyParamByIndex(INDEX2, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwSldrConst));
	CMD_ModifyParamByIndex(INDEX3, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJPos));
	CMD_ModifyParamByIndex(INDEX4, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJRot));
	CMD_ModifyParamByIndex(INDEX5, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAJSldr));
	CMD_ModifyParamByIndex(INDEX6, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwSprScl));
	CMD_ModifyParamByIndex(INDEX7, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwBmpScl));
	CMD_ModifyParamByIndex(INDEX8, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwDmpScl));
	CMD_ModifyParamByIndex(INDEX9, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwInertScl));
	CMD_ModifyParamByIndex(INDEX10, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwVelOffScl));
	CMD_ModifyParamByIndex(INDEX11, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwAccOffScl));
	CMD_ModifyParamByIndex(INDEX12, SYSTEM_EFFECT_ID, ((WORD)(pJoystickParams->dwYMotBoost))/2);
	CMD_ModifyParamByIndex(INDEX13, SYSTEM_EFFECT_ID, (WORD)(pJoystickParams->dwXMotSat));
}



// ****************************************************************************
// *** --- Member functions for base class CMidiEffect
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(IN ULONG ulButtonPlayMask)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	Effect.bDurationL	= 1;				// in 2ms increments
	Effect.bDurationH	= 0;				// in 2ms increments
	Effect.bAngleL		= 0;				// 0 to 359 degrees
	Effect.bAngleH		= 0;
	Effect.bGain		= (BYTE) 100;		// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL= DEFAULT_JOLT_FORCE_RATE;	// 1 to 500 Hz
	Effect.bForceOutRateH=0;
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default
}


// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_OpCode    		= DNLOAD_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:DNLOAD_DATA
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	SetDuration(pEffect->m_Duration);
	Effect.bDurationL	= (BYTE)  (m_Duration & 0x7f);					// in 2ms increments
	Effect.bDurationH	= (BYTE) ((m_Duration >> 7 ) & 0x7f);			// in 2ms increments
	Effect.bAngleL		= (BYTE)  (pEffect->m_DirectionAngle2D & 0x7f);	// 0 to 359 degrees
	Effect.bAngleH		= (BYTE) ((pEffect->m_DirectionAngle2D >> 7 ) & 0x7f);
	Effect.bGain		= (BYTE)  (pEffect->m_Gain & 0x7f);				// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE)  (pEffect->m_ButtonPlayMask & 0x7f);
	Effect.bButtonPlayH = (BYTE) ((pEffect->m_ButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL=(BYTE)  (pEffect->m_ForceOutputRate & 0x7f);	// 1 to 500 Hz
	Effect.bForceOutRateH=(BYTE) ((pEffect->m_ForceOutputRate >> 7 ) & 0x03);
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default

	// Set Envelope members
	if (pEnvelope)
	{
		m_Envelope.m_Type = pEnvelope->m_Type;
		m_Envelope.m_Attack = pEnvelope->m_Attack;
		m_Envelope.m_Sustain = pEnvelope->m_Sustain;
		m_Envelope.m_Decay = pEnvelope->m_Decay;
		m_Envelope.m_StartAmp = (ULONG) (pEnvelope->m_StartAmp);
		m_Envelope.m_SustainAmp = (ULONG) (pEnvelope->m_SustainAmp);
		m_Envelope.m_EndAmp = (ULONG) (pEnvelope->m_EndAmp);
	}

	// save the original effect params
	m_OriginalEffectParam = *pEffect;
}

// --- Destructor
CMidiEffect::~CMidiEffect()
{
	memset(this, 0, sizeof(CMidiEffect));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetDuration
// Purpose:		Sets the Duration member
// Parameters:	ULONG ulArg	- the duration
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetDuration(ULONG ulArg)
{
	if (ulArg != 0)
	{
		ulArg = (ULONG) ( (float) ulArg/TICKRATE);
		if (ulArg <= 0) ulArg = 1;
	}
	m_Duration = ulArg;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetTotalDuration
// Purpose:		Modifies the Effect.bDurationL/H parameter for Loop Counts
// Parameters:	none
//
// Returns:		Effect.bDurationL/H is filled with total duration
// Algorithm:
//	Notes: Percentage is 1 to 10000
//	Total Duration = ((Percentage of waveform)/10000) * Duration * Loop Count
//	Example: Loop count of 1, the Percentage of waveform =10000,
//			 Total Duration = (10000/10000) * 1 * Duration
//
// ----------------------------------------------------------------------------
void CMidiEffect::SetTotalDuration(void)
{
	ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);
	ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
	Effect.bDurationL = (BYTE) ulTotalDuration & 0x7f;
	Effect.bDurationH = (BYTE) (ulTotalDuration >> 7) & 0x7f;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeEnvelope
// Purpose:		Computes the Envelope for the Effect, Loopcount in consideration
// Parameters:	none
// Returns:		none
// Algorithm:
//For our standard PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline
// m_EndAmp = m_StartAmp;
// where: baseline = (Effect.m_MaxAmp + Effect.m_MinAmp)/2;
// ----------------------------------------------------------------------------
void CMidiEffect::ComputeEnvelope(void)
{
	ULONG ulTimeToSustain;
	ULONG ulTimeToDecay;

	//REVIEW: TIME vs PERCENTAGE option
	if (PERCENTAGE == m_Envelope.m_Type)
	{
		ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);		
		ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
		ulTimeToSustain = (ULONG) ((m_Envelope.m_Attack * ulTotalDuration) /100.);
		ulTimeToDecay   = (ULONG) ((m_Envelope.m_Attack + m_Envelope.m_Sustain)
								 * ulTotalDuration /100.);
	}
	else	// TIME option envelope
	{
		ulTimeToSustain = (ULONG) (m_Envelope.m_Attack);
		ulTimeToDecay   = (ULONG) (m_Envelope.m_Attack + m_Envelope.m_Sustain);
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

	}
		Envelope.bAttackLevel  = (BYTE) (m_Envelope.m_StartAmp & 0x7f);
		Envelope.bSustainLevel = (BYTE) (m_Envelope.m_SustainAmp & 0x7f);
		Envelope.bDecayLevel   = (BYTE) (m_Envelope.m_EndAmp & 0x7f);

		Envelope.bSustainL = (BYTE) (ulTimeToSustain & 0x7f);
		Envelope.bSustainH = (BYTE) ((ulTimeToSustain >> 7) & 0x7f);
		Envelope.bDecayL   = (BYTE) (ulTimeToDecay & 0x7f);
		Envelope.bDecayH   = (BYTE) ((ulTimeToDecay >> 7) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Returns the SubType for the Effect
// Parameters:	none
// Returns:		ULONG - DirectEffect style SubType
// Algorithm:
// ----------------------------------------------------------------------------
ULONG CMidiEffect::SubTypeOf(void)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (m_SubType == EffectTypes[i].bDeviceSubType)
			return EffectTypes[i].ulHostSubType;
	}
	return (NULL);		
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Sets the SubType for the Effect
// Parameters:	ULONG - DirectEffect style SubType
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetSubType(ULONG ulSubType)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (ulSubType == EffectTypes[i].ulHostSubType)
		{
			m_SubType = EffectTypes[i].bDeviceSubType;
			return;
		}
	}
	m_SubType = NULL;	
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeChecksum
// Purpose:		Computes current checksum in the m_pBuffer
// Parameters:	none
// Returns:		Midi packet block is checksummed
// Algorithm:
// ----------------------------------------------------------------------------
BYTE CMidiEffect::ComputeChecksum(PBYTE pBuffer, int nBufferSize)
{
	assert(pBuffer);
	int nStart = sizeof(SYS_EX_HDR);
	PBYTE pBytePacket = pBuffer;
	pBytePacket += nStart;
	BYTE nSum = 0;
	// Checksum only the bytes in the "Body" and s/b 7 bit checksum.
	for (int i=nStart;i < (nBufferSize-2);i++)
	{
		nSum += *pBytePacket;
		pBytePacket++;
	}
	return ((-nSum) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SendPacket
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::SendPacket(PDNHANDLE pDnloadID, int nPacketSize)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	HRESULT hRet = SUCCESS;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	// Prepare the buffer for SysEx output
	hRet = g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer,
			(DWORD) nPacketSize, TRUE);

	assert(SUCCESS == hRet);
	if (SUCCESS != hRet)
	{
		return (hRet);
	}

	ACKNACK AckNack = {sizeof(ACKNACK)};
	for(int i=0; i<MAX_RETRY_COUNT; i++)
	{
		g_pJoltMidi->BumpLongMsgCounter();
		// Send the message and Wait for the ACK + Download ID
		hRet = g_pJoltMidi->MidiSendLongMsg();
		assert(SUCCESS == hRet);
		if (SUCCESS != hRet)
		{
#ifdef _DEBUG
			OutputDebugString("SendPacket Error: MidiSendLongMsg()\n");
#endif
			// Release the Midi buffers	and Return
			g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer, 0, FALSE);
			return (hRet);
		}

		// Wait for ACK.  Note: WinMM has callback Event notification
		// while Backdoor and serial does not.
		if (COMM_WINMM == g_pJoltMidi->COMMInterfaceOf())
		{	
			hRet = g_pJoltMidi->GetAckNackData(10, &AckNack, REGBITS_DOWNLOADEFFECT);
		}
		else   // Serial or Backdoor
		{
			if ((COMM_SERIAL_FILE == g_pJoltMidi->COMMInterfaceOf()) || (COMM_SERIAL_BACKDOOR == g_pJoltMidi->COMMInterfaceOf()))			
			{
				hRet = g_pJoltMidi->GetAckNackData(LONG_MSG_TIMEOUT, &AckNack, REGBITS_DOWNLOADEFFECT);
			}
			else	// Backdoor, hopefully to keep Jeff(Mr. Performance '97) happy
			{
				hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack, REGBITS_DOWNLOADEFFECT);
			}
		}
		//	:

#ifdef _DEBUG
		if (SUCCESS!=hRet)
			OutputDebugString("Error getting ACKNACK data\n");
		if (ACK != AckNack.dwAckNack)
			g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode);
#endif
	
		// NOTE: Special check for Device-Full because in certain circumstances
		// (e.g. create multiple ROM effects after STOP_ALL command), retries of
		// creation will succeed even though device is full
		if (ACK == AckNack.dwAckNack || (NACK == AckNack.dwAckNack && AckNack.dwErrorCode == DEV_ERR_TYPE_FULL))
			break;
		// ******
	}

	// Release the Midi buffers
	g_pJoltMidi->MidiAssignBuffer((LPSTR) m_pBuffer, 0, FALSE);
	if (SUCCEEDED(hRet) && (ACK == AckNack.dwAckNack))
	{
		// Store in Device ID List Array
		// First we need to generate a new Effect ID if necessary
		if (NEW_EFFECT_ID == m_bEffectID)
		{
			DNHANDLE DnloadID;
			if (g_pJoltMidi->NewEffectID(&DnloadID))	// Successful ID created
			{
				m_bEffectID = (BYTE) DnloadID;
				*pDnloadID = DnloadID;
				g_pJoltMidi->SetEffectByID((BYTE) *pDnloadID, this);
			}
		}
	}
	else	// Failure of some sort
	{
		if(NACK == AckNack.dwAckNack)
		{
			g_pJoltMidi->BumpNACKCounter();
			switch (AckNack.dwErrorCode)
			{
				case DEV_ERR_TYPE_FULL:
				case DEV_ERR_PROCESS_LIST_FULL:
				case DEV_ERR_PLAYLIST_FULL:
					hRet = g_pJoltMidi->LogError(SFERR_FFDEVICE_MEMORY,
										AckNack.dwErrorCode);
					break;
				
				default:
				case DEV_ERR_INVALID_PARAM:
				case DEV_ERR_CHECKSUM:
				case DEV_ERR_UNKNOWN_CMD:
				case DEV_ERR_INVALID_ID:
					hRet = g_pJoltMidi->LogError(SFERR_DEVICE_NACK,
										AckNack.dwErrorCode);
					break;
			}
		}
	}

// --- END OF CRITICAL SECTION
//
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::DestroyEffect
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::DestroyEffect()
{
	HRESULT hRet;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	hRet = g_pJoltMidi->MidiSendShortMsg(EFFECT_CMD,DESTROY_EFFECT,EffectIDOf());
	if(!FAILED(hRet))
		g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

	Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay);

	return hRet;
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiBehavioral
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::CMidiBehavioral
// Purpose:		Constructor(s)/Destructor for CMidiBehavioral Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiBehavioral::CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope,
				PBE_XXX pBE_XXX):CMidiEffect(pEffect, NULL)
{
	SetSubType(pEffect->m_SubType);
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
	m_MidiBufferSize = sizeof(BEHAVIORAL_SYS_EX);
}

// --- Destructor
CMidiBehavioral::~CMidiBehavioral()
{
	memset(this, 0, sizeof(CMidiBehavioral));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiBehavioral::SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for BE_XXX
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiBehavioral::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PBEHAVIORAL_SYS_EX pBuf = (PBEHAVIORAL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Behavioral params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXConstantL  	= (BYTE)  XConstant & 0x7f;
	pBuf->bXConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYConstantL  	= (BYTE)  YConstant & 0x7f;
	pBuf->bYConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;

	LONG Param3 		= (LONG) (Param3Of()  * MAX_SCALE);
	LONG Param4 		= (LONG) (Param4Of()  * MAX_SCALE);
	pBuf->bParam3L  	= (BYTE)  Param3 & 0x7f;
	pBuf->bParam3H 		= (BYTE) (Param3 >> 7 ) & 0x01;
	pBuf->bParam4L  	= (BYTE)  Param4 & 0x7f;
	pBuf->bParam4H 		= (BYTE) (Param4 >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;

	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(BEHAVIORAL_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiFriction
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::CMidiFriction
// Purpose:		Constructor(s)/Destructor for CMidiFriction Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiFriction::CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(FRICTION_SYS_EX);
}

// --- Destructor
CMidiFriction::~CMidiFriction()
{
	memset(this, 0, sizeof(CMidiFriction));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiFriction::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PFRICTION_SYS_EX pBuf = (PFRICTION_SYS_EX) pSysExBuffer;

	SetTotalDuration();	// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_FRICTION params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXFConstantL  = (BYTE)  XConstant & 0x7f;
	pBuf->bXFConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYFConstantL  = (BYTE)  YConstant & 0x7f;
	pBuf->bYFConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;
	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(FRICTION_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiWall
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::CMidiWall
// Purpose:		Constructor(s)/Destructor for CMidiWall Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiWall::CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(WALL_SYS_EX);
}

// --- Destructor
CMidiWall::~CMidiWall()
{
	memset(this, 0, sizeof(CMidiWall));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiWall::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PWALL_SYS_EX pBuf = (PWALL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL		= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH		= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_WALL params
	LONG WallType 			= (LONG) (XConstantOf());
	LONG WallConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	LONG WallAngle			= (LONG)  Param3Of();
	LONG WallDistance		= (LONG) (Param4Of() * MAX_SCALE);

	pBuf->bWallType  		= (BYTE) (WallType & 0x01);
	pBuf->bWallConstantL  	= (BYTE) (WallConstant & 0x7f);
	pBuf->bWallConstantH	= (BYTE) ((WallConstant >> 7 ) & 0x01); //+/-100
	pBuf->bWallAngleL  		= (BYTE) (WallAngle & 0x7f);			// 0 to 359
	pBuf->bWallAngleH	 	= (BYTE) ((WallAngle >> 7 ) & 0x03);
	pBuf->bWallDistance		= (BYTE) (WallDistance & 0x7f);
	pBuf->bEffectID 		=  m_bEffectID;

	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
	  									sizeof(WALL_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiRTCSpring
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::CMidiRTCSpring
// Purpose:		Constructor(s)/Destructor for CMidiRTCSpring Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiRTCSpring::CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring):CMidiEffect(NULL)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// --- Destructor
CMidiRTCSpring::~CMidiRTCSpring()
{
	memset(this, 0, sizeof(CMidiRTCSpring));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::SetEffectParams
// Purpose:		Sets parameters
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiRTCSpring::SetEffectParams(PRTCSPRING_PARAM pRTCSpring)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::GenerateSysExPacket
// Purpose:		virtual
// Parameters:	none
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiRTCSpring::GenerateSysExPacket(void)
{
	return (NULL);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiDelay
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::CMidiDelay
// Purpose:		Constructor(s)/Destructor for CMidiDelay Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiDelay::CMidiDelay(PEFFECT pEffect) : CMidiEffect(pEffect, NULL)
{
	m_SubType   = ET_BE_DELAY;		// BE Effect Type: BE_DELAY
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS | PLAY_SUPERIMPOSE;
	m_MidiBufferSize = sizeof(NOP_SYS_EX);
}

// --- Destructor
CMidiDelay::~CMidiDelay()
{
	memset(this, 0, sizeof(CMidiDelay));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiDelay::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PNOP_SYS_EX pBuf = (PNOP_SYS_EX) pSysExBuffer;

	pBuf->bEffectID		=  m_bEffectID;
	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bChecksum		= ComputeChecksum((PBYTE) pSysExBuffer,
					 				sizeof(NOP_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiSynthesized
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::CMidiSynthesized
// Purpose:		Constructor(s)/Destructor for CMidiSynthesized Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiSynthesized::CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope,
						PSE_PARAM pParam ) : CMidiEffect(pEffect, pEnvelope)
{
	SetSubType(pEffect->m_SubType);				// SE Effect Type
//	Effect.bForceOutRateL= (BYTE) pParam->m_SampleRate & 0x7f;	// 1 to 500 Hz
//	Effect.bForceOutRateH= (BYTE) ((pParam->m_SampleRate >> 7) & 0x3);
	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);

	m_Freq		= pParam->m_Freq;				// Frequency
	m_MaxAmp	= pParam->m_MaxAmp;				// Maximum Amplitude
	// Special case a SE_CONSTANT_FORCE
	if (SE_CONSTANT_FORCE == pEffect->m_SubType)
		m_MinAmp = 0;
	else
		m_MinAmp = pParam->m_MinAmp;			// Minimum Amplitude

	m_MidiBufferSize = sizeof(SE_WAVEFORM_SYS_EX);
}

// --- Destructor
CMidiSynthesized::~CMidiSynthesized()
{
	memset(this, 0, sizeof(CMidiSynthesized));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiSynthesized::SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam,
									   ULONG ulAction)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	//Set the loop count from HIWORD of ulAction
	m_LoopCount = (ulAction >> 16) & 0xffff;
	if (0 == m_LoopCount) m_LoopCount++;

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for SE_xxx
	m_Freq	 = pParam->m_Freq;
	m_MaxAmp = pParam->m_MaxAmp;
	m_MinAmp = pParam->m_MinAmp;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiSynthesized::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);

	// Compute total with Loop count parameter, Note: Envelope parameters are
	// adjusted according to the Loop Count parameter, if affected.
	SetTotalDuration();
	ComputeEnvelope();

	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID + MIDI_EFFECT
	//			+ MIDI_ENVELOPE
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR)+3+sizeof(MIDI_EFFECT)+
				sizeof(MIDI_ENVELOPE)) );

	PSE_WAVEFORM_SYS_EX pBuf = (PSE_WAVEFORM_SYS_EX) pSysExBuffer;
	
	// Scale the gain, and Envelope amplitudes
	pBuf->Effect.bGain = (BYTE) (pBuf->Effect.bGain * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bAttackLevel  = (BYTE) (pBuf->Envelope.bAttackLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bSustainLevel = (BYTE) (pBuf->Envelope.bSustainLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bDecayLevel   = (BYTE) (pBuf->Envelope.bDecayLevel * MAX_SCALE) & 0x7f;

	// Copy the SE specific parameters
	LONG MaxAmp = (LONG) (m_MaxAmp * MAX_SCALE);
	LONG MinAmp = (LONG) (m_MinAmp * MAX_SCALE);
	pBuf->bFreqL   	= (BYTE)  (m_Freq & 0x7f);
	pBuf->bFreqH   	= (BYTE) ((m_Freq >> 7 ) & 0x03); 	// 1 to 500
	pBuf->bMaxAmpL 	= (BYTE)  (MaxAmp & 0x7f);
	pBuf->bMaxAmpH 	= (BYTE) ((MaxAmp >> 7 ) &0x01); 	// +127 to -128

	pBuf->bMinAmpL 	= (BYTE)  (MinAmp & 0x7f);
	pBuf->bMinAmpH 	= (BYTE) ((MinAmp >> 7 ) & 0x01);

	pBuf->bChecksum	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(SE_WAVEFORM_SYS_EX));
	pBuf->bEOX	   	= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CUD_Waveform
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CUD_Waveform::CUD_Waveform
// Purpose:		Constructor(s)/Destructor for CUD_Waveform Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiUD_Waveform::CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray) : CMidiEffect(pEffect, NULL),
	m_pRawData(NULL)
{
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS;// Sub-command opcode: DNLOAD_DATA
	m_SubType   = ET_UD_WAVEFORM;	// Effect Type: UD_WAVEFORM

	assert(pArray);
	// Create the buffer to hold the waveform data, compress it,
	// then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	// Set a fixed maximum size
	DWORD nSize = MAX_MIDI_WAVEFORM_DATA_SIZE + 2;
	m_pArrayData = new BYTE[nSize];
//	m_pRawData = new BYTE [nSize*2];
	assert(m_pArrayData);

	ULONG NewForceRate;
	m_MidiBufferSize = SetTypeParams(ulNumVectors, pArray, &NewForceRate);

	// Copy structures to object
	memcpy(&m_Effect.m_Bytes, pEffect, sizeof(EFFECT));
	SetForceOutRate(NewForceRate);
	m_Effect.m_Gain = m_Effect.m_Gain & 0x7f;
	m_Effect.m_Duration = (ULONG) ((float) (m_Effect.m_Duration / TICKRATE));
	m_Duration = m_Effect.m_Duration;
}

// --- Destructor
CMidiUD_Waveform::~CMidiUD_Waveform()
{
	if (m_pArrayData) delete [] m_pArrayData;
	memset(this, 0, sizeof(CMidiUD_Waveform));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetEffectParams
// Purpose:		Sets the Effect specific parameters
// Parameters:	PEFFECT pEffect
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiUD_Waveform::SetEffectParams(PEFFECT pEffect)
{	
	// Set the MIDI_EFFECT parameters
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);	
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetTypeParams
// Purpose:		Sets the type specific parameters
// Parameters:	int nSize		- size of the array
//				PLONG pArray - Pointer to an ARRAY of force values
//				
// Returns:		MidiBuffer size for the packet
// Algorithm:
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate)
{	
	// Compress the buffer data then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	m_NumberOfVectors = 0;

	m_pRawData = new BYTE [nSize*2];

	if (m_pRawData != NULL)
	{
		// Convert to -128 to +127
		for (int i=0; i<nSize; i++)
		{
			m_pRawData[i] = (BYTE) ((LONG) (pArray[i] * MAX_SCALE));		
		}

		m_NumberOfVectors = CompressWaveform(&m_pRawData[0], m_pArrayData, nSize, pNewRate);
		assert(m_NumberOfVectors <= (MAX_MIDI_WAVEFORM_DATA_SIZE));
		delete [] m_pRawData;
		m_pRawData = 0;
	}
	if (0 == m_NumberOfVectors)		// No room!
		return (0);
	m_MidiBufferSize = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX) + 2);
	return (m_MidiBufferSize);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::CompressWaveform
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	PBYTE pSrcArray		- Source Array pointer
//				PBYTE pDestArray 	- Dest. Array Pointer
//				int nSize			- Size in Bytes of the Source Array
//
// Returns:		int 	- Size of the compressed Array (in bytes)
// Algorithm:
// To "compress" we need to fit the entire waveform into 98 points (there is a
// FW bug that limits us to 100 points only, and we need at least two samples
// for the starting Absolute mode point.
// 1.  Determine how many points over 98.
//     nSrcSize:    Total sample size
//     nMaxSamples: Maximum samples to squeeze into = 98
//	   nOver:		nSrcSize - nMaxSamples
//	   nSkipSample:	# of points to keep before skipping one
//					= nSrcSize/nOver
//	   while ( Sample is less than nSrcSize, bump index)
//	   {
//		  if ( (index % nSkipSample) == 0)	// no remainder
//		  {
//			index++							// bump to skip the next sample
//		  }
//		  Compress the data
//	   }
//
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::CompressWaveform(
	IN PBYTE pSrcArray,
	IN OUT PBYTE pDestArray,
	IN int nSrcSize,
	OUT ULONG *pNewForceRate)
{
	assert(pSrcArray && pDestArray);
	LONG nDifference;

	// 8 bits (-128 to +127) Starting Absolute Data Value
	pDestArray[0] = pSrcArray[0] & 0x3f;
	pDestArray[1] = (pSrcArray[0] >> 6) & 0x03;

//	int nMaxSamples = MAX_MIDI_WAVEFORM_DATA_SIZE;

	int nSkipSample, nSrcIndex, nDestIndex;
	int nAbsolute = 0;
	int nRelative = 0;
	//
	// Start with Finest Resolution, then reduce until # of Samples <= nMaxSamples
	//
	nSkipSample = nSrcSize;
	while (TRUE)
	{
		nSrcIndex = 0;				// 1st sample already accounted for
		nDestIndex = 2;
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"nSkipSample=%d\n",nSkipSample);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		while (nSrcIndex < nSrcSize)
		{
			nSrcIndex++;
			if (0 == (nSrcIndex % nSkipSample))
			{
				nSrcIndex++;			// Skip next one
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-2]);
			}
			else
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-1]);

			// make sure we do not write outside of array bounds
			if(nDestIndex > MAX_MIDI_WAVEFORM_DATA_SIZE) break;

			if (abs(nDifference) < DIFFERENCE_THRESHOLD)
			{
				pDestArray[nDestIndex] = (BYTE)((nDifference & 0x3f) | DIFFERENCE_BIT);
				nDestIndex++;
				nRelative++;
			}
			else	// Switch to Absolute Data (8 bits)
			{
				pDestArray[nDestIndex] 	 = pSrcArray[nSrcIndex] & 0x3f;
				pDestArray[nDestIndex+1] = (pSrcArray[nSrcIndex] >> 6) & 0x3;
				nDestIndex = nDestIndex+2;
				nAbsolute++;
			}
		}
		if (nDestIndex <= MAX_MIDI_WAVEFORM_DATA_SIZE) break;
		// Reduce the resolution
		if (nSkipSample < 8)
			nSkipSample--;
		else
			nSkipSample = nSkipSample/2;
		if (1 == nSkipSample) return (0);	// Sorry charlie, no room!
		nAbsolute = 0;
		nRelative = 0;
	}

	// Done
	ULONG ulOriginalForceRate = ForceOutRateOf();
//	*pNewForceRate = (ulOriginalForceRate - (ULONG) (ulOriginalForceRate * ((float) nSkipSample / (float) nSrcSize)))/nSkipSample;
	*pNewForceRate = (ULONG) ((1.0f - (1.0f/nSkipSample)) * ulOriginalForceRate);


#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "CompressWaveform: nSrcSize=%d, nSkipSample=%d, NewForceRate=%d\n",
			nSrcSize, nSkipSample, *pNewForceRate);
	DebugOut(g_cMsg);
	wsprintf(g_cMsg,"\nTotal Absolute Data:%d, Relative Data:%d", nAbsolute, nRelative);
	DebugOut(g_cMsg);
	g_CriticalSection.Leave();
#endif


#ifdef _SHOWCOMPRESS
#pragma message("Compiling with SHOWCOMPRESS")
	g_CriticalSection.Enter();
	DebugOut("CMidiUD_Waveform::CompressWaveform(..) \npSrcArray Dump (Decimal)\n");
	for (int i=0; i<nSrcSize; i++)
	{
		wsprintf(g_cMsg," %0.4ld",((char) pSrcArray[i]));
		DebugOut(g_cMsg);
	}
	DebugOut("\npDestArray Dump (HEX)\n");

	for (i=0; i<nDestIndex; i++)
	{
		wsprintf(g_cMsg," %0.4x",pDestArray[i]);
		DebugOut(g_cMsg);
	}
	g_CriticalSection.Leave();
#endif
	return (nDestIndex);
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiUD_Waveform::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PUD_WAVEFORM_SYS_EX pBuf = (PUD_WAVEFORM_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->Effect.bDurationL     = (BYTE) (m_Duration & 0x7f);
	pBuf->Effect.bDurationH     = (BYTE) (m_Duration >> 7) & 0x7f;		
	pBuf->Effect.bAngleL	    =  Effect.bAngleL & 0x7f;	
	pBuf->Effect.bAngleH	    =  Effect.bAngleH & 0x7f;			
	pBuf->Effect.bGain		    = (BYTE) (Effect.bGain * MAX_SCALE) & 0x7f;	
	pBuf->Effect.bButtonPlayL   =  Effect.bButtonPlayL  & 0x7f;		
	pBuf->Effect.bButtonPlayH   =  Effect.bButtonPlayH  & 0x7f;	
	pBuf->Effect.bForceOutRateL =  Effect.bForceOutRateL & 0x7f;		
	pBuf->Effect.bForceOutRateH =  Effect.bForceOutRateH & 0x7f;
	pBuf->Effect.bPercentL	    =  Effect.bPercentL & 0x7f;
	pBuf->Effect.bPercentH	    =  Effect.bPercentH & 0x7f;

	// Fill in the Array Data
	PBYTE pArray = ((PBYTE) pBuf) + UD_WAVEFORM_START_OFFSET;
	memcpy(pArray, m_pArrayData, m_NumberOfVectors);	// Already scaled!

	pBuf->bEffectID	=  m_bEffectID;
	int nArraySize  = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX));
	pSysExBuffer[nArraySize] = 0;
	pSysExBuffer[nArraySize+1] = 0;
	pSysExBuffer[nArraySize] = ComputeChecksum((PBYTE) pSysExBuffer, (nArraySize+2));
	pSysExBuffer[nArraySize+1]= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiProcessList
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::CMidiProcessList
// Purpose:		Constructor(s)/Destructor for CMidiProcessList Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiProcessList::CMidiProcessList(ULONG ulButtonPlayMask, PPLIST pParam)
	: CMidiEffect(ulButtonPlayMask)
{
	m_OpCode    = PROCESS_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:PROCESS_DATA
	m_NumEffects  = pParam->ulNumEffects;
	if (m_NumEffects > MAX_PLIST_EFFECT_SIZE) m_NumEffects = MAX_PLIST_EFFECT_SIZE;
	assert(m_NumEffects > 0 && m_NumEffects <= MAX_PLIST_EFFECT_SIZE);

	m_ProcessMode = pParam->ulProcessMode;
	m_pEffectArray = new BYTE [m_NumEffects];

	if (m_pEffectArray != NULL)
	{
		for (int i=0; i< (int) m_NumEffects; i++)
		{
			m_pEffectArray[i] = (BYTE) (pParam->pEffectArray)[i];
		}
	}
	m_MidiBufferSize = sizeof(SYS_EX_HDR)+5+m_NumEffects + 2;
}

// --- Destructor
CMidiProcessList::~CMidiProcessList()
{
	if (m_pEffectArray) delete [] m_pEffectArray;
	memset(this, 0, sizeof(CMidiProcessList));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::SetParams
// Purpose:		Sets the type specific parameters
// Parameters:	PPLIST pParam
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiProcessList::SetParams(ULONG ulButtonPlayMask, PPLIST pParam)
{
	m_NumEffects  = pParam->ulNumEffects;
	if (m_NumEffects > MAX_PLIST_EFFECT_SIZE) m_NumEffects = MAX_PLIST_EFFECT_SIZE;
	assert(m_NumEffects > 0 && m_NumEffects <= MAX_PLIST_EFFECT_SIZE);

	Effect.bButtonPlayL = (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);

	m_ProcessMode = pParam->ulProcessMode;

	if (m_pEffectArray != NULL)
	{
		for (int i=0; i< (int) m_NumEffects; i++)
		{
			m_pEffectArray[i] = (BYTE) (pParam->pEffectArray)[i];
		}
	}
}

// ----------------------------------------------------------------------------
// Function: 	CMidiProcessList::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiProcessList::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID  + m_bButtonPlayL
	//	+ m_bButtonPlayH
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR) + 5 ));
	PPROCESS_LIST_SYS_EX pBuf = (PPROCESS_LIST_SYS_EX) pSysExBuffer;

	if (PL_SUPERIMPOSE == m_ProcessMode)
		pBuf->bSubType = PLIST_SUPERIMPOSE;
	else
		pBuf->bSubType = PLIST_CONCATENATE;

	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Copy the PLIST specific parameters
	memcpy(&pBuf->bEffectArrayID, m_pEffectArray, m_NumEffects);
	PBYTE pChecksum = (PBYTE) ( &pBuf->bEffectArrayID + m_NumEffects );

	pChecksum[0] = ComputeChecksum((PBYTE) pSysExBuffer,
							sizeof(SYS_EX_HDR)+5+m_NumEffects+2);					
	pChecksum[1] = MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiVFXProcessList
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiVFXProcessList::CMidiVFXProcessList
// Purpose:		Constructor(s)/Destructor for CMidiVFXProcessList Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiVFXProcessList::CMidiVFXProcessList(ULONG ulButtonPlayMask, PPLIST pParam)
	: CMidiProcessList(ulButtonPlayMask, pParam)
{
}

// ----------------------------------------------------------------------------
// Function: 	CMidiVFXEffect::DestroyEffect
// Purpose:		Sends the Short Message for itself and children
// Parameters:
// Returns:		Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiVFXProcessList::DestroyEffect()
{
	HRESULT hRet;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// destroy the children
	for (int i=0; i< (int) m_NumEffects; i++)
	{
		// get the CMidiEffect object corresponding to child ID
		CMidiEffect* pMidiEffect = g_pJoltMidi->GetEffectByID(m_pEffectArray[i]);
		assert(NULL != pMidiEffect);
		if (NULL == pMidiEffect) return (SFERR_INVALID_OBJECT);

		// destroy the effect
		hRet = pMidiEffect->DestroyEffect();

		// remove it from the map
		if(!FAILED(hRet))
			g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

		// delete the object
		delete pMidiEffect;
	}

	// destroy itself
	hRet = CMidiEffect::DestroyEffect();

	// remove it from the map
	if(!FAILED(hRet))
		g_pJoltMidi->SetEffectByID(EffectIDOf(), NULL);

	return hRet;
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiAssign
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiAssign::CMidiAssign
// Purpose:		Constructor(s)/Destructor for CMidiAssign Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiAssign::CMidiAssign(void) : CMidiEffect(NULL)
{
//
// --- THIS IS A CRITICAL SECTION
//
	CriticalLock cl;

	m_OpCode    = MIDI_ASSIGN;					// Sub-command opcode
	m_SubType   = 0;							// not used
	m_Channel 	= DEFAULT_MIDI_CHANNEL;			// Midi channel
	m_MidiBufferSize = sizeof(MIDI_ASSIGN_SYS_EX);

// --- END OF CRITICAL SECTION
//
}

// --- Destructor
CMidiAssign::~CMidiAssign()
{
	memset(this, 0, sizeof(CMidiAssign));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiAssign::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiAssign::GenerateSysExPacket(void)
{
	if (NULL == g_pJoltMidi) return ((PBYTE) NULL);

	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );

	PMIDI_ASSIGN_SYS_EX pBuf = (PMIDI_ASSIGN_SYS_EX) pSysExBuffer;

	pBuf->bChannel  		= (BYTE) (m_Channel & 0x0f);
	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(MIDI_ASSIGN_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\swd_guid.hpp ===
/****************************************************************************

    MODULE:     	SWD_GUID.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:            CLSIDs and IIDs defined for DirectInputForce

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SWD_GUID_SEEN
#define _SWD_GUID_SEEN

#ifdef INITGUIDS
#include <initguid.h>
#endif //INITGUIDS


/*
 * GUIDs
 *
 */

//
// --- SideWinder Force Feedback Device Driver Interface
//
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{e84cd1b1-81fa-11d0-94ab-0080c74c7e95}")
#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

//
// --- Effect GUIDs
//
DEFINE_GUID(GUID_Wall, /* e84cd1a1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ProcessList, /* e84cd1a2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// Built in ROM Effects
DEFINE_GUID(GUID_RandomNoise, /* e84cd1a3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_AircraftCarrierTakeOff, /* e84cd1a4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_BasketballDribble, /* e84cd1a5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_CarEngineIdle, /* e84cd1a6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawIdle, /* e84cd1a7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawInAction, /* e84cd1a8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_DieselEngineIdle, /* e84cd1a9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Jump, /* e84cd1aa-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1aa,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Land, /* e84cd1ab-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ab,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_MachineGun, /* e84cd1ac-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ac,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Punched, /* e84cd1ad-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ad,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_RocketLaunch, /* e84cd1ae-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ae,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SecretDoor, /* e84cd1af-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1af,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SwitchClick, /* e84cd1b0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindGust, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindShear, /* e84cd1b2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Pistol, /* e84cd1b3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Shotgun, /* e84cd1b4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser1, /* e84cd1b5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser2, /* e84cd1b6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser3, /* e84cd1b7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser4, /* e84cd1b8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser5, /* e84cd1b9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser6, /* e84cd1ba-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ba,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_OutOfAmmo, /* e84cd1bb-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bb,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_LightningGun, /* e84cd1bc-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bc,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Missile, /* e84cd1bd-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bd,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_GatlingGun, /* e84cd1be-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1be,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ShortPlasma, /* e84cd1bf-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bf,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon1, /* e84cd1c0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon2, /* e84cd1c1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Cannon, /* e84cd1c2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RawForce, /* e84cd1c6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_VFXEffect, /* e84cd1c7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RTCSpring, /* e84cd1c8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

//
// --- UNUSED but reserved for future GUIDs
//


#endif //_SWD_GUID_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\swd_guid.cpp ===
/****************************************************************************

    MODULE:         SWD_GUID.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPODE:    	Instantiate GUIDS
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce

****************************************************************************/
#ifdef   WIN32
#define  INITGUIDS
#include <objbase.h>
#else
#include <memory.h>
#include <string.h>
#include <compobj.h>
#endif
#include <initguid.h>
#include "dinput.h"
#include "dinputd.h"
#include "SWD_Guid.hpp"
#include <dmusicc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cfact.cpp ===
/****************************************************************************

    MODULE:     	SW_CFact.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Class Object structured in a DLL server.
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#include "SW_CFact.hpp"
#include "SWD_Guid.hpp"

#include <olectl.h>	// Self Reg errors

// Needed for auto registration
#include "Registry.h"
#include "CritSec.h"

// Define CriticalSection object for everyone
CriticalSection g_CriticalSection;

//
// Global Data
//
ULONG       g_cObj=0;	//Count number of objects and number of locks.
ULONG       g_cLock=0;
HINSTANCE	g_MyInstance = NULL;

//
// External Functions
//

//
// Internal Function Prototypes
//


//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif

#define BUFSIZE 80


/*
 * DllMain
 *
 * Purpose:
 *  Entry point provides the proper structure for each environment.
 */

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	switch (ulReason) {
		case DLL_PROCESS_ATTACH: {
			//
			// DLL is attaching to the address space of the current process.
			//
			g_MyInstance = hInstance;
#ifdef _DEBUG
			::OutputDebugString("sw_effct.dll: DLL_PROCESS_ATTACH\r\n");
#endif
			return TRUE;
		}

		case DLL_THREAD_ATTACH:
     	//
     	// A new thread is being created in the current process.
     	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_THREAD_ATTACH\r\n");
#endif
	   		break;

       	case DLL_THREAD_DETACH:
     	//
     	// A thread is exiting cleanly.
     	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_THREAD_DETACH\r\n");
#endif
     		break;

		case DLL_PROCESS_DETACH:
    	//
    	// The calling process is detaching the DLL from its address space.
    	//
#ifdef _DEBUG
            OutputDebugString("sw_effct.dll: DLL_PROCESS_DETACH\r\n");
#endif
			break;
	}
   return(TRUE);
}

// ----------------------------------------------------------------------------
// Function: 	DllRegisterServer
//
// Purpose:		Auto-magically puts default entries into registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	// Register CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_DirectInputEffectDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR fileName[MAX_PATH];
			DWORD nameSize = ::GetModuleFileName(g_MyInstance, fileName, MAX_PATH);
			if (nameSize > 0) {
				fileName[nameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)fileName, sizeof(fileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
		// NotInsertable ""
		RegistryKey notInsertableKey = driverKey.OpenCreateSubkey(TEXT("NotInsertable"));
		if (notInsertableKey != c_InvalidKey) {
			notInsertableKey.SetValue(NULL, (BYTE*)TEXT(""), sizeof(TEXT(""))/sizeof(TCHAR), REG_SZ);
		}
		// ProgID "Sidewinder ForceFeedback blah blah2.0"
		RegistryKey progIDKey = driverKey.OpenCreateSubkey(TEXT("ProgID"));
		if (progIDKey != c_InvalidKey) {
			progIDKey.SetValue(NULL, (BYTE*)PROGID_NAME, sizeof(PROGID_NAME)/sizeof(TCHAR), REG_SZ);
		}
		// VersionIndpendentProgID "Sidewinder ForceFeedback blah blah"
		RegistryKey progIDVersionlessKey = driverKey.OpenCreateSubkey(TEXT("VersionIndpendentProgID"));
		if (progIDVersionlessKey != c_InvalidKey) {
			progIDVersionlessKey.SetValue(NULL, (BYTE*)PROGID_NOVERSION_NAME, sizeof(PROGID_NOVERSION_NAME)/sizeof(TCHAR), REG_SZ);
		}
	} else {
		return SELFREG_E_CLASS;
	}

	// Made it here valid driver key
	return S_OK;
}

// ----------------------------------------------------------------------------
// Function: 	DllUnregisterServer
//
// Purpose:		Auto-magically removed default entries from registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_DirectInputEffectDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			driverKey.RemoveSubkey(TEXT("NotInsertable"));
			driverKey.RemoveSubkey(TEXT("ProgID"));
			driverKey.RemoveSubkey(TEXT("VersionIndpendentProgID"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_DirectInputEffectDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}

// ----------------------------------------------------------------------------
// Function: 	DllGetClassObject
//
// Purpose:		Provides an IClassFactory for a given CLSID that this DLL is
//				registered to support.  This DLL is placed under the CLSID
//				in the registration database as the InProcServer.
//
// Parameters:  REFCLSID clsID	- REFCLSID that identifies the class factory
//                				  desired.  Since this parameter is passed this
//                				  DLL can handle any number of objects simply
//                				  by returning different class factories here
//                				  for different CLSIDs.
//
//				REFIID riid     - REFIID specifying the interface the caller 
//				                  wants on the class object, usually 
//								  IID_ClassFactory.
//
//				PPVOID ppv      - PPVOID in which to return the interface ptr.
//
// Returns:		HRESULT         NOERROR on success, otherwise an error code.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT             hr;
    CDirectInputEffectDriverClassFactory *pObj;

#ifdef _DEBUG
    OutputDebugString("sw_effct.dll: DllGetClassObject()\r\n");
#endif                 
    if (CLSID_DirectInputEffectDriver !=rclsid) return ResultFromScode(E_FAIL);

    pObj=new CDirectInputEffectDriverClassFactory();

    if (NULL==pObj) return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))	delete pObj;
    return hr;
}


// ----------------------------------------------------------------------------
// Function: 	DllCanUnloadNow
//
// Purpose:		Answers if the DLL can be freed, that is, if there are no
//				references to anything this DLL provides.
//				
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //Our answer is whether there are any object or locks
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


// ----------------------------------------------------------------------------
// Function: 	ObjectDestroyed
//
// Purpose:		Function for the DirectInputEffectDriver object to call when it gets destroyed.
//				Since we're in a DLL we only track the number of objects here,
//				letting DllCanUnloadNow take care of the rest.
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
void ObjectDestroyed(void)
{
    g_cObj--;
    return;
}


/*
 * CVIObjectClassFactory::CVIObjectClassFactory
 * CVIObjectClassFactory::~CVIObjectClassFactory
 *
 * Constructor Parameters:
 *  None
 */

CDirectInputEffectDriverClassFactory::CDirectInputEffectDriverClassFactory(void)
{
    m_cRef=0L;
    return;
}

CDirectInputEffectDriverClassFactory::~CDirectInputEffectDriverClassFactory(void)
{
    return;
}




/*
 * CDirectInputEffectDriverClassFactory::QueryInterface
 * CDirectInputEffectDriverClassFactory::AddRef
 * CDirectInputEffectDriverClassFactory::Release
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    	return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::Release(void)
{
    if (0L!=--m_cRef) return m_cRef;
    delete this;
    return 0L;
}

/*
 * CDirectInputEffectDriverClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a DirectInputEffectDriver object returning an interface pointer.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired
 *                  interface pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
 *                  if we cannot support the requested interface.
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, 
    REFIID riid, PPVOID ppvObj)
{
    PCDirectInputEffectDriver       pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    pObj=new CDirectInputEffectDriver(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj) return hr;

    if (pObj->Init()) hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))	
    	delete pObj;
    else
        g_cObj++;
    return hr;
}


/*
 * CDirectInputEffectDriverClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the DLL.  If the
 *  lock count goes to zero and there are no objects, the DLL
 *  is allowed to unload.  See DllCanUnloadNow.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */
STDMETHODIMP CDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
        g_cLock--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_globs.cpp ===
/****************************************************************************

    MODULE:     	SW_GLOBS.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	SWFF_PRO Global Variables
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.1    		15-May-97   MEA     original
				20-Mar-99	waltw	Added validity checks into functions that use
									g_pJoltMidi. Because of structure of code,
									some of these are redundant but safer than
									depending on call tree not changing.

****************************************************************************/
#include <windows.h>
#include "midi_obj.hpp"

//
// Globals
//

#ifdef _DEBUG
char g_cMsg[160];
TCHAR szDeviceName[MAX_SIZE_SNAME] = {"Microsoft SideWinder Force Feedback Pro"};
#endif

// 
// *** Global on per process space only
//
CJoltMidi *g_pJoltMidi = NULL;


// *** End of Globals on per process space
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_error.hpp ===
/****************************************************************************

    MODULE:     	SW_Error.HPP
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for Error Codes
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original

****************************************************************************/
#ifndef SW_Error_SEEN
#define SW_Error_SEEN

#include <winerror.h>
#include <windows.h>
#include <mmsystem.h>


typedef struct _SWFF_ERROR {
	HRESULT	HCode;			// HRESULT code
	ULONG	ulDriverCode;	// Error code from device driver
} SWFF_ERROR, *PSWFF_ERROR;


//---------------------------------------------------------------------------
// Error Status Codes
//---------------------------------------------------------------------------
/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */

// SWForce Errors
#define MAKE_FF_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_FF_E( err )  (MAKE_FF_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_FF_S( warn ) (MAKE_FF_SCODE( 0, FACILITY_ITF, warn ))

#define DINPUT_DRIVER_ERR_BASE	0x500

#define SUCCESS					0x00										// successful
#define SFERR_INVALID_OBJECT		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 1)	// Invalid object ID
#define SFERR_INVALID_PARAM			DIERR_INVALIDPARAM						// Invalid parameters
#define SFERR_NO_SUPPORT			DIERR_UNSUPPORTED						// Function not supported
#define SFERR_INVALID_DEVICE		DIERR_DEVICENOTREG						// Device not found
#define	SFERR_FFDEVICE_MEMORY		DIERR_DEVICEFULL						// Out of download RAM
#define SFERR_END_OF_LIST			MAKE_FF_S(DINPUT_DRIVER_ERR_BASE + 6)	// End of the list
#define SFERR_DEVICE_NACK			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 7)	// Device NACK received
#define SFERR_INVALID_STRUCT_SIZE 	DIERR_INVALIDPARAM						// Invalid structure passed
#define SFERR_EFFECT_NOT_IN_DEVICE 	DIERR_NOTDOWNLOADED					// Effect was not downloaded, so
																			// cannot unload.
#define SFERR_RAW_OUT_DATAEVENT_CREATION 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 10)	// Could not create Event
#define SFERR_RAW_OUT_THREAD_CREATION 		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 11)	// Could not create a thread
#define SFERR_EFFECT_STATUS_BUSY DIERR_EFFECTPLAYING								// Device busy playing Effect
#define SFERR_OUT_OF_FF_MEMORY		DIERR_OUTOFMEMORY								// FF system has run out of memory
																					//  cannot create new Effect
#define SFERR_SYSTEM_INIT			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 14)	// Could not create SWForce
#define SFERR_DRIVER_ERROR      	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 15)  // Driver error detected
#define SFERR_NON_FF_DEVICE     	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 16)  // This is a non-FF device, driver not found
#define SFERR_INVALID_HAL_OBJECT 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 17)	// HAL cannot emulate this object
#define SFERR_INVALID_MEMBER_VALUE 	DIERR_INVALIDPARAM						// Data structure has invalid member value

// VFX_ error codes
#define VFX_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 100
#define VFX_ERR_FILE_NOT_FOUND				HRESULT_FROM_WIN32(MMIOERR_FILENOTFOUND)
#define VFX_ERR_FILE_OUT_OF_MEMORY			DIERR_OUTOFMEMORY
#define VFX_ERR_FILE_CANNOT_OPEN			HRESULT_FROM_WIN32(MMIOERR_CANNOTOPEN)
#define VFX_ERR_FILE_CANNOT_CLOSE			HRESULT_FROM_WIN32(MMIOERR_CANNOTCLOSE)
#define VFX_ERR_FILE_CANNOT_READ			HRESULT_FROM_WIN32(MMIOERR_CANNOTREAD)
#define VFX_ERR_FILE_CANNOT_WRITE			HRESULT_FROM_WIN32(MMIOERR_CANNOTWRITE)
#define VFX_ERR_FILE_CANNOT_SEEK			HRESULT_FROM_WIN32(MMIOERR_CANNOTSEEK)
#define VFX_ERR_FILE_UNKNOWN_ERROR			MAKE_FF_E(VFX_ERR_BASE + 8)
#define VFX_ERR_FILE_BAD_FORMAT				MAKE_FF_E(VFX_ERR_BASE + 9)
#define VFX_ERR_FILE_ACCESS_DENIED			HRESULT_FROM_WIN32(MMIOERR_ACCESSDENIED)
#define VFX_ERR_FILE_SHARING_VIOLATION		HRESULT_FROM_WIN32(MMIOERR_SHARINGVIOLATION)
#define VFX_ERR_FILE_NETWORK_ERROR			HRESULT_FROM_WIN32(MMIOERR_NETWORKERROR)
#define VFX_ERR_FILE_TOO_MANY_OPEN_FILES	HRESULT_FROM_WIN32(MMIOERR_TOOMANYOPENFILES)
#define VFX_ERR_FILE_INVALID				HRESULT_FROM_WIN32(MMIOERR_INVALIDFILE)
#define VFX_ERR_FILE_END_OF_FILE			MAKE_FF_E(VFX_ERR_BASE + 15)

// SideWinder Driver Error codes
#define SWDEV_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 200
#define SWDEV_ERR_INVALID_ID				MAKE_FF_E(SWDEV_ERR_BASE + 1)  // Invalid Download ID
#define SWDEV_ERR_INVALID_PARAM				MAKE_FF_E(SWDEV_ERR_BASE + 2)  // Invalid Download Parameter
#define SWDEV_ERR_CHECKSUM					MAKE_FF_E(SWDEV_ERR_BASE + 3)  // Invalid Checksum in COMM Packet
#define SWDEV_ERR_TYPE_FULL					MAKE_FF_E(SWDEV_ERR_BASE + 4)  // No More RAM space for Effect Type
#define SWDEV_ERR_UNKNOWN_CMD				MAKE_FF_E(SWDEV_ERR_BASE + 5)  // Unrecognized Device command
#define SWDEV_ERR_PLAYLIST_FULL				MAKE_FF_E(SWDEV_ERR_BASE + 6)  // Play List is full, cannot play any more Effects
#define SWDEV_ERR_PROCESSLIST_FULL			MAKE_FF_E(SWDEV_ERR_BASE + 7)  // Process List is full, cannot download 


#endif // of ifndef SW_Error_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cfact.hpp ===
/****************************************************************************

    MODULE:     	SW_CFACT.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definitions, classes, and prototypes for a DLL that
    				provides Effect objects to any other object user.

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce	
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SW_CFACT_SEEN
#define _SW_CFACT_SEEN


//Get the object definitions
#include "SW_objec.hpp"

void ObjectDestroyed(void);

//SW_CFACT.CPP
//This class factory object creates DirectInputEffectDriver objects.

class CDirectInputEffectDriverClassFactory : public IClassFactory
{
 protected:
 	ULONG           m_cRef;

 public:
    CDirectInputEffectDriverClassFactory(void);
    ~CDirectInputEffectDriverClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                             , PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDirectInputEffectDriverClassFactory *PCDirectInputEffectDriverClassFactory;

#endif //_SW_CFACT_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_cimpi.cpp ===
/****************************************************************************

    MODULE:     	SW_CImpI.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IDEffect Implementation.
    
    Function(s):
					CImpIDirectInputEffectDriver::DeviceID
					CImpIDirectInputEffectDriver::GetVersions
    			    CImpIDirectInputEffectDriver::Escape
				    CImpIDirectInputEffectDriver::SetGain
    			    CImpIDirectInputEffectDriver::SendForceFeedbackCommand
    			    CImpIDirectInputEffectDriver::GetForceFeedbackState
    			    CImpIDirectInputEffectDriver::DownloadEffect
    			    CImpIDirectInputEffectDriver::DestroyEffect
    			    CImpIDirectInputEffectDriver::StartEffect
    			    CImpIDirectInputEffectDriver::StopEffect
    			    CImpIDirectInputEffectDriver::GetEffectStatus

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
  	1.0    	06-Feb-97   MEA     original, Based on SWForce
			23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
			23-Mar-97	MEA/DS	Added VFX support
			13-Mar-99	waltw	Deleted unused m_pJoltMidi and accessors
			15-Mar-99	waltw	Get version info from ntverp.h (was version.h)
			16-Mar-99	waltw	GetFirmwareParams, GetSystemParams,
								CMD_Download_RTCSpring, GetDelayParams,
								GetJoystickParams, & UpdateJoystickParams
								calls removed from DeviceID since they are
								called from g_pJoltMidi->Initialize.

****************************************************************************/
#include <windows.h>
#include <math.h>
#include <assert.h>
#include "dinput.h"
#include "dinputd.h"
#include "SW_objec.hpp"
#include "hau_midi.hpp"
#include "ffd_swff.hpp"
#include "FFDevice.h"
#include "ntverp.h"
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
#endif
extern CJoltMidi *g_pJoltMidi;





// ****************************************************************************
// *** --- Member functions for base class CImpIDirectInputEffectDriver Interface
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CImpIDirectInputEffectDriver Object
// Parameters:  PCDirectInputEffectDriver pObj	- Ptr to the outer object
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver(PCDirectInputEffectDriver pObj)
{
    m_cRef=0;
    m_pObj=pObj;
    return;
}

CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver(void)
{
#ifdef _DEBUG
	OutputDebugString("CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver()\n");
#endif
	// Destroy the CEffect object we created and release any interfaces
	if (g_pJoltMidi) 
	{
		delete g_pJoltMidi;
		g_pJoltMidi = NULL;
	}

#ifdef _DEBUG
		// No critical section here because g_SWFFCriticalSection already destroyed
		wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::~CimpIDEffect()\n");
		OutputDebugString(g_cMsg);
#endif
}

// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::QueryInterface
//				CImpIDirectInputEffectDriver::AddRef
//				CImpIDirectInputEffectDriver::Release
//
// Purpose:		IUnknown members that delegate to m_pObj
// Parameters:  
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
STDMETHODIMP CImpIDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
    return m_pObj->QueryInterface(riid, ppv);
}

DWORD CImpIDirectInputEffectDriver::AddRef(void)
{
//
//  We maintain an "interface reference count" for debugging
//  purposes, because the client of an object should match
//  AddRef and Release calls through each interface pointer.
//  
    ++m_cRef;
    return m_pObj->AddRef();
}

DWORD CImpIDirectInputEffectDriver::Release(void)
{
//	m_cRef is again only for debugging.  It doesn't affect
//	CSWEffect although the call to m_pObj->Release does.
	--m_cRef;
    return m_pObj->Release();
}


// ----------------------------------------------------------------------------
// Function:    DeviceID
//
// Purpose:     
// Parameters:  DWORD dwExternalID		-The joystick ID number being us
//				DWORD fBegin			-Nonzero if access to the device is beginning; Zero if ending
//				DWORD dwInternalID		-Internal joystick id
//				LPVOID lpReserved		-Reserved for future use (HID)
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DeviceID(
	IN DWORD dwDirectInputVersion,
    IN DWORD dwExternalID,
    IN DWORD fBegin,
    IN DWORD dwInternalID,
	LPVOID lpReserved)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::DeviceID(%lu, %lu, %lu, %lu, %lx)\n", dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, lpReserved);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	assert(NULL == g_pJoltMidi);
	
	// Create and Initialize our CJoltMidi object
#ifdef _DEBUG
	OutputDebugString("Creating and Initializing CJoltMidi object\n");
#endif
	g_pJoltMidi = new CJoltMidi();
	if (NULL == g_pJoltMidi)
	{
		return (E_OUTOFMEMORY);
	}
	else
	{
		return g_pJoltMidi->Initialize(dwExternalID);
	}
}


// ----------------------------------------------------------------------------
// Function:    GetVersions
//
// Purpose:     
// Parameters:  LPDIDRIVERVERSIONS pvers -Pointer to structure which receives version info
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetVersions(
	IN OUT LPDIDRIVERVERSIONS pvers)
{
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	LOCAL_PRODUCT_ID* pProductID = g_pJoltMidi->ProductIDPtrOf();
	if(pProductID == NULL)
		return E_FAIL;

	pvers->dwFirmwareRevision = (pProductID->dwFWMajVersion << 8) | (pProductID->dwFWMinVersion);
	pvers->dwHardwareRevision = pProductID->dwProductID;

	// Get version from ntverp.h (was FULLVersion from version.h)
	pvers->dwFFDriverVersion = VER_PRODUCTVERSION_DW;

#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::GetVersions(%lu, %lu, %lu)\n", pvers->dwFirmwareRevision, pvers->dwHardwareRevision, pvers->dwFFDriverVersion);
	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function:    Escape
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				LPDIEFFESCAPE pEsc	- Pointer to a DIFEFESCAPE struct
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::Escape(
    IN DWORD dwDeviceID,
	IN DWORD dwEffectID,
	IN OUT LPDIEFFESCAPE pEsc )
{
	HRESULT hRet = SUCCESS;
	return (hRet);
}


// ----------------------------------------------------------------------------
// Function:    SetGain
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwGain		- Device gain
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SetGain(
    IN DWORD dwDeviceID,
    IN DWORD dwGain)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SetGain: %s Gain=%ld\r\n", &szDeviceName, dwGain);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if ((dwGain <= 0) || (dwGain > MAX_GAIN)) return (SFERR_INVALID_PARAM);
	dwGain = dwGain / SCALE_GAIN;
	return(CMD_ModifyParamByIndex(INDEX15, SYSTEM_EFFECT_ID, (USHORT)(dwGain * MAX_SCALE)));
}

// ----------------------------------------------------------------------------
// Function:    SendForceFeedbackCommand
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwState		- Command to set Device state
//
//
// Returns:		SUCCESS or Error code
//
// Need to map the following DX to Jolt
// DS_FORCE_SHUTDOWN   0x00000001	// Actuators (Motors) are enabled.
// DS_FORCE_ON         0x00000002	// Actuators (Motors) are disabled.
// DS_FORCE_OFF        0x00000003	// All Effects are "Paused"
// DS_CONTINUE         0x00000004	// All "Paused" Effects are continued
// DS_PAUSE            0x00000005	// All Effects are stopped.
// DS_STOP_ALL         0x00000006	// All Effects destroyed,Motors disabled
//
//	Jolt Device ulMode:
//	SWDEV_SHUTDOWN 		1L			// All Effects destroyed, Motors disabled
//	SWDEV_FORCE_ON 		2L			// Motors enabled.  "Un-Mute"
//	SWDEV_FORCE_OFF		3L			// Motors disabled.	"Mute"
//	SWDEV_CONTINUE 		4L			// All "Paused" Effects are allow to continue
//	SWDEV_PAUSE	   		5L			// All Effects are "Paused"
//	SWDEV_STOP_ALL 		6L			// Stops all Effects.  
//   	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SendForceFeedbackCommand(
    IN DWORD dwDeviceID,
    IN DWORD dwState)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SendForceFeedbackCommand: %s State=%ld\r\n", &szDeviceName, dwState);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	HRESULT hRet = SUCCESS;

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Convert to Jolt modes
	ULONG ulDeviceMode;
	switch(dwState)
	{
		case DISFFC_SETACTUATORSON:	
			ulDeviceMode = SWDEV_FORCE_ON;
			break;

		case DISFFC_SETACTUATORSOFF:
			ulDeviceMode = SWDEV_FORCE_OFF;
			break;

		case DISFFC_PAUSE:		
			ulDeviceMode = SWDEV_PAUSE;
			break;

		case DISFFC_CONTINUE:	
			ulDeviceMode = SWDEV_CONTINUE;
			break;

		case DISFFC_STOPALL:		
			ulDeviceMode = SWDEV_STOP_ALL;
			break;

		case DISFFC_RESET:		
			ulDeviceMode = SWDEV_SHUTDOWN;
			break;

		default:
			return (SFERR_INVALID_PARAM);
	}
	hRet = CMD_SetDeviceState(ulDeviceMode);
	if (SUCCESS == hRet)
		g_pJoltMidi->UpdateDeviceMode(ulDeviceMode);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    GetForceFeedbackState
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				LPDIDEVICESTATE pDeviceState	- Pointer to a DIDEVICESTATE struct
//
// Returns:		SUCCESS or Error code and state updated in pDeviceState
//
// Member: dwState
//		DS_FORCE_SHUTDOWN   	0x00000001
//		DS_FORCE_ON         	0x00000002
//		DS_FORCE_OFF        	0x00000003
//		DS_CONTINUE         	0x00000004
//		DS_PAUSE            	0x00000005
//		DS_STOP_ALL         	0x00000006
//
// Member: dwSwitches
//		DSW_ACTUATORSON         0x00000001
//		DSW_ACTUATORSOFF        0x00000002
//		DSW_POWERON             0x00000004
//		DSW_POWEROFF            0x00000008
//		DSW_SAFETYSWITCHON      0x00000010
//		DSW_SAFETYSWITCHOFF     0x00000020
//		DSW_USERFFSWITCHON      0x00000040
//		DSW_USERFFSWTTCHOFF     0x00000080
//
// Algorithm:
// This is the DI Device State structure
//typedef struct DIDEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
// This is the SideWinder State structure (copy kept in CJoltMidi object)
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetForceFeedbackState(
    IN DWORD dwDeviceID,
    IN LPDIDEVICESTATE pDeviceState)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "GetForceFeedbackState: %s\r\n", &szDeviceName[0]);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	assert(pDeviceState);
	if (NULL == pDeviceState) return (SFERR_INVALID_PARAM);
	assert(pDeviceState->dwSize == sizeof(DIDEVICESTATE));
	if (pDeviceState->dwSize != sizeof(DIDEVICESTATE) )return (SFERR_INVALID_STRUCT_SIZE);

	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 20)) {
		if ((g_pJoltMidi) && (g_pJoltMidi->GetSWDeviceStateNoUpdate().m_ForceState == SWDEV_FORCE_OFF)) {	// Echo state back to fix 1.20 bug
			CMD_SetDeviceState(SWDEV_FORCE_OFF);
		} else {
			CMD_SetDeviceState(SWDEV_FORCE_ON);
		}
	}

	// zero out the device state structure then pass to GetJoltStatus(LPDEVICESTATE)
	pDeviceState->dwState = 0;
	//pDeviceState->dwSwitches = 0;
	pDeviceState->dwLoad = 0;
   	HRESULT hRet = g_pJoltMidi->GetJoltStatus(pDeviceState);
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "dwState=%.8lx, dwLoad=%d\n",
		 pDeviceState->dwState, pDeviceState->dwLoad);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    DownloadEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				DWORD dwInternalEffectType	- Internal Effect Type
//				IN OUT LPDWORD pDnloadID	- Pointer to a DWORD for DnloadID
//				IN LPCDIEFFECT pEffect		- Pointer to a DIEFFECT structure
//				IN DWORD dwFlags			- for parameters that changed
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// The following dwFlags may be sent by the kernel
//
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Jolt has two options for downloading - Full SysEx or Modify Parameter
// Pass the dwFlags to each CMD_xxx function and let the MIDI function
// determine whether to use SysEx or Modify Parameter.
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DownloadEffect(
    IN DWORD dwDeviceID,
    IN DWORD dwInternalEffectType,
    IN OUT LPDWORD pDnloadID,
    IN LPCDIEFFECT pEffect,
	IN DWORD dwFlags)
{
	HRESULT hRet = SUCCESS;
	BOOL bTruncated = FALSE;	// TRUE if some effect parameters out of range

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DownloadEffect. DnloadID= %ld, Type=%lx, dwFlags= %lx\r\n",
   					&szDeviceName[0], *pDnloadID, dwInternalEffectType, dwFlags);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

	// Compute the Axis Mask equivalent
	int nAxes = pEffect->cAxes;
	if (nAxes > 2) return (SFERR_NO_SUPPORT);
	BYTE bAxisMask = 0;

	for (int i=0; i<nAxes; i++)
	{
		int nAxisNumber = DIDFT_GETINSTANCE(pEffect->rgdwAxes[i]);
		bAxisMask |= 1 << nAxisNumber;
	}

	// check to see if the X and Y axes were switched
	BOOL bAxesReversed = FALSE;
	if(nAxes == 2 && DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
		bAxesReversed = TRUE;

	// convert dwTriggerButton to a Button Mask
	ULONG ulButtonPlayMask = 0;
	if (pEffect->dwTriggerButton != -1)
	{	
		int nButtonNumber = DIDFT_GETINSTANCE(pEffect->dwTriggerButton);
		// map button 10 to button 9
		if(nButtonNumber == 9)
			nButtonNumber = 8;
		else if(nButtonNumber == 8)
			return SFERR_NO_SUPPORT;

		ulButtonPlayMask = 1 << nButtonNumber;
	}

	// Compute the Direction Angle
	ULONG nDirectionAngle2D, nDirectionAngle3D;
	nDirectionAngle3D = 0;

	if (pEffect->dwFlags & DIEFF_POLAR)
	{
		if (2 != nAxes) return (SFERR_INVALID_PARAM);
		nDirectionAngle2D = pEffect->rglDirection[0]/SCALE_DIRECTION;
	}
	//else if(pEffect->dwFlags & DIEFF_SPHERICAL)
	//{
	//	nDirectionAngle2D = (pEffect->rglDirection[0]/SCALE_DIRECTION + 90)%360;
	//}
	else	// Rectangular, so convert to Polar
	{
		// Special case 1D Effects
		if (1 == nAxes)
		{
			if (X_AXIS == (bAxisMask & X_AXIS)) 
				nDirectionAngle2D = 90;
			else
				nDirectionAngle2D = 0;
		}
		else
		{
			// get the x-component
			int nXComponent;
			if(bAxisMask & X_AXIS)
				nXComponent = pEffect->rglDirection[bAxesReversed ? 1 : 0];
			else
				nXComponent = 0;

			// get the y-component
			int nYComponent;
			if(bAxisMask & Y_AXIS)
			{
				if(bAxisMask & X_AXIS)
					nYComponent = -pEffect->rglDirection[bAxesReversed ? 0 : 1];
				else
					nYComponent = -pEffect->rglDirection[bAxesReversed ? 1 : 0];
			}
			else
				nYComponent = 0;

			// calculate the angle in degrees
			double lfAngle = atan2((double)nYComponent, (double)nXComponent)*180.0/3.14159;

			// convert it to our kind of angle
			int nAngle;
			if(lfAngle >= 0.0)
				nAngle = -(int)(lfAngle + 0.5) + 90;
			else
				nAngle = -(int)(lfAngle - 0.5) + 90;
			if(nAngle < 0)
				nAngle += 360;
			else if(nAngle >= 360)
				nAngle -= 360;
			nDirectionAngle2D = nAngle;
		}
	}
	
	// Scale the Duration, Gain
	ULONG ulDuration;
	if(pEffect->dwDuration == INFINITE)
		ulDuration = 0;
	else
		ulDuration = max(1, (ULONG) (pEffect->dwDuration/SCALE_TIME));
	ULONG ulGain = (ULONG) (pEffect->dwGain/SCALE_GAIN);
	ULONG ulAction = PLAY_STORE;

	int nSamples;
	
	// universal characteristics
	DWORD dwMagnitude;	// DX units
	LONG lOffset;		// DX units
	ULONG ulFrequency;	// SW units
	ULONG ulMaxLevel;

	// Create Jolt Behavior Effects
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;
	LPDICONDITION pDICondition;
	LPDICUSTOMFORCE pDICustomForce;
	LPDIENVELOPE pDIEnvelope;

	float T;
	PLONG pScaledForceData;

	// Note: HIWORD(dwInternalEffectType) = Major Type
	//		 LOWORD(dwInternalEffectType) = Minor Type
	// Decode the type of Download to use
	hRet = SFERR_INVALID_PARAM;
	ULONG ulType = HIWORD(dwInternalEffectType);
	ULONG ulSubType = LOWORD(dwInternalEffectType);
	
	// if this is a modify, make sure we are not trying to modify
	// parameters which are not modifiable
	BOOL bAttemptToModifyUnmodifiable = FALSE;
	if(*pDnloadID != 0)
	{
		// get a bitmask of the parameters that can be modified
		DWORD dwModifyCaps = 0;
		switch(ulType)
		{
			case EF_BEHAVIOR:
				switch(ulSubType)
				{
					case BE_WALL:
						dwModifyCaps = DIEP_DURATION | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
						break;
					default:
						// all other behavioral/condition effects
						dwModifyCaps = DIEP_DURATION | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
						break;
				}
				break;
			case EF_USER_DEFINED:
				// custom force
				dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION;
				break;
			case EF_ROM_EFFECT:
				dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE;
				break;
			case EF_SYNTHESIZED:
				switch(ulSubType)
				{
					case SE_CONSTANT_FORCE:
						dwModifyCaps = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
						break;
					default:
						dwModifyCaps = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
						break;
				}
				break;
			case EF_VFX_EFFECT:
				dwModifyCaps = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_DIRECTION;
				break;
			case EF_RAW_FORCE:
				dwModifyCaps = DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS;
				break;
			case EF_RTC_SPRING:
				dwModifyCaps = DIEP_TYPESPECIFICPARAMS;
				break;
			default:
				break;
		}

		// At this point dwModifyCaps is a bitmask of the parameters that can
		// be modified for this type of effect.

		// see if there are any bits set that correspond to parameters we cannot modify
		DWORD dwModifyFlags = DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON
								| DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION
								| DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS;
		if(~dwModifyCaps & dwFlags & dwModifyFlags)
			bAttemptToModifyUnmodifiable = TRUE;

		// clear the bits in dwFlags that correspond to parameters we cannot modify
		dwFlags &= dwModifyCaps | ~dwModifyFlags;
	}

	// Map the common Effect parameters
	EFFECT effect = {sizeof(EFFECT)};
	effect.m_SubType = ulSubType;
	effect.m_AxisMask = (ULONG) bAxisMask;
	effect.m_DirectionAngle2D = nDirectionAngle2D;
	effect.m_DirectionAngle3D = 0;
	effect.m_Duration = ulDuration;
	effect.m_Gain = ulGain;
	effect.m_ButtonPlayMask = ulButtonPlayMask;

	ENVELOPE envelope = {sizeof(ENVELOPE)};
	SE_PARAM seParam = {sizeof(SE_PARAM)};

	switch (ulType)
	{
		case EF_BEHAVIOR:
			pDICondition = (LPDICONDITION) pEffect->lpvTypeSpecificParams;
			// Map the EFFECT Type
			effect.m_Type = EF_BEHAVIOR;

			// Because in DX 1D and 2D conditions have the same type, we must
			// convert to appropriate subtype depending on axis mask
			if(ulSubType != BE_WALL && ulSubType != BE_DELAY && bAxisMask == (X_AXIS|Y_AXIS))
			{
				ulSubType++;
				effect.m_SubType = ulSubType;
			}
			
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pDICondition[0].lPositiveCoefficient/SCALE_CONSTANTS;
						BE_xxx.m_YConstant = 0;
						BE_xxx.m_Param3 = pDICondition[0].lOffset/SCALE_POSITION;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pDICondition[0].lPositiveCoefficient/SCALE_CONSTANTS;
							BE_xxx.m_XConstant = 0;
							BE_xxx.m_Param4 = -pDICondition[0].lOffset/SCALE_POSITION;
							BE_xxx.m_Param3= 0;
						}
					}

					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damper
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;

					BE_xxx.m_XConstant = pDICondition[bAxesReversed ? 1 : 0].lPositiveCoefficient/SCALE_CONSTANTS;
					BE_xxx.m_YConstant = pDICondition[bAxesReversed ? 0 : 1].lPositiveCoefficient/SCALE_CONSTANTS;
					BE_xxx.m_Param3 = pDICondition[bAxesReversed ? 1 : 0].lOffset/SCALE_POSITION;
					BE_xxx.m_Param4 = -pDICondition[bAxesReversed ? 0 : 1].lOffset/SCALE_POSITION;
					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					// check for NULL typespecificparams
					if(pEffect->lpvTypeSpecificParams == NULL)
						return (SFERR_INVALID_PARAM);

					pBE_Wall = (PBE_WALL_PARAM) pEffect->lpvTypeSpecificParams;
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					// Range check params
					if (pBE_Wall->m_Bytes != sizeof(BE_WALL_PARAM))
						return (SFERR_INVALID_PARAM);
					if ((pBE_Wall->m_WallType != INNER_WALL) && (pBE_Wall->m_WallType != OUTER_WALL))
						return (SFERR_INVALID_PARAM);
					if ((pBE_Wall->m_WallConstant < MIN_CONSTANT) || (pBE_Wall->m_WallConstant > MAX_CONSTANT))
						return (SFERR_INVALID_PARAM);
					if (/*(pBE_Wall->m_WallDistance < 0) || */(pBE_Wall->m_WallDistance > MAX_POSITION))
						return (SFERR_INVALID_PARAM);

					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 9000)
						|| (pBE_Wall->m_WallAngle == 18000)
						|| (pBE_Wall->m_WallAngle == 27000) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant/SCALE_CONSTANTS;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle/SCALE_DIRECTION;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance/SCALE_POSITION;
						if(dwFlags & DIEP_NODOWNLOAD)
							return DI_DOWNLOADSKIPPED;
						hRet = CMD_Download_BE_XXX(&effect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						return SFERR_INVALID_PARAM;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
					if(dwFlags & DIEP_NODOWNLOAD)
						return DI_DOWNLOADSKIPPED;
					hRet = CMD_Download_NOP_DELAY(ulDuration, &effect, (PDNHANDLE) pDnloadID);
					break;

				default:
					return SFERR_NO_SUPPORT;
			}
			break;

		case EF_USER_DEFINED:
		{
			if(ulSubType == PL_CONCATENATE || ulSubType == PL_SUPERIMPOSE)
				return SFERR_NO_SUPPORT;

			// check for an envelope (we do not support envelopes)
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			if(pDIEnvelope)
			{
				// try to be somewhat smart about not supporting envelopes
				if(pDIEnvelope->dwAttackTime != 0 && pDIEnvelope->dwAttackLevel != 10000
					|| pDIEnvelope->dwFadeTime != 0 && pDIEnvelope->dwFadeLevel != 10000)
				{
					return SFERR_NO_SUPPORT;
				}
			}

			// check for modifying type-specific (we do not support)
			if(*pDnloadID != 0 && (dwFlags & DIEP_TYPESPECIFICPARAMS))
				return SFERR_NO_SUPPORT;

			pDICustomForce = (LPDICUSTOMFORCE) pEffect->lpvTypeSpecificParams;
			if (pDICustomForce->cChannels > 1) return (SFERR_NO_SUPPORT);
			// Map the EFFECT type
			effect.m_Type = EF_USER_DEFINED;

			DWORD dwSamplePeriod = pDICustomForce->dwSamplePeriod;
			if (dwSamplePeriod == 0) {
				dwSamplePeriod = pEffect->dwSamplePeriod;
			}
			if (dwSamplePeriod == 0) {		// 0 indicates use default
				return SFERR_NO_SUPPORT;
			} else  {
				T = (float) ((dwSamplePeriod/(float)SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = (ULONG) ((float) 1.0/ T);
				if (0 == effect.m_ForceOutputRate) effect.m_ForceOutputRate = 1;
			}

			// Scale the Force values to +/-100
			nSamples = pDICustomForce->cSamples;
			pScaledForceData = new LONG[nSamples];
			if (NULL == pScaledForceData) return (SFERR_DRIVER_ERROR);

			for (i=0; i<nSamples; i++)
			{
				LONG lForceData = pDICustomForce->rglForceData[i];
				if(lForceData > DI_FFNOMINALMAX)
				{
					lForceData = DI_FFNOMINALMAX;
					bTruncated = TRUE;
				}
				else if(lForceData < -DI_FFNOMINALMAX)
				{
					lForceData = -DI_FFNOMINALMAX;
					bTruncated = TRUE;
				}
				pScaledForceData[i] = lForceData/SCALE_GAIN;
			}
			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;

			// give a short duration effect the shortest possible duration
			// that does not translate to zero, (which implies infinite duration)
			if(ulDuration == 1)
			{
				ulDuration = 2;
				effect.m_Duration = ulDuration;
			}

			hRet = CMD_Download_UD_Waveform(ulDuration, &effect, 
					pDICustomForce->cSamples,
					pScaledForceData, 
					ulAction, (PDNHANDLE) pDnloadID, dwFlags);
			delete [] pScaledForceData;
			break;
		}

		case EF_ROM_EFFECT:
			// Map the EFFECT type
			effect.m_Type = EF_ROM_EFFECT;

			// check for default output rate
			if(pEffect->dwSamplePeriod == DEFAULT_ROM_EFFECT_OUTPUTRATE) {
				// signal default output rate by setting to -1
				effect.m_ForceOutputRate = (ULONG)-1;
			} else if (pEffect->dwSamplePeriod == 0) {
				effect.m_ForceOutputRate = 100;
			} else {
				T = (float) ((pEffect->dwSamplePeriod/SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = max(1, (ULONG) ((float) 1.0/ T));
			}

			// check for default duration
			if(pEffect->dwDuration == DEFAULT_ROM_EFFECT_DURATION)
			{
				// signal default duration by setting to -1
				ulDuration = (ULONG)-1;
				effect.m_Duration = ulDuration;
			}

			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(&effect))
				return (SFERR_INVALID_OBJECT);

			// update the duration if it was changed in SetupROM_Fx(...)
			ulDuration = effect.m_Duration;
			
			// Map the Envelope
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			dwMagnitude = 10000;
			ulMaxLevel = dwMagnitude;
			MapEnvelope(ulDuration, dwMagnitude, &ulMaxLevel, pDIEnvelope, &envelope);

			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;		// unused by ROM Effect
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;

			// set the sample rate
			seParam.m_SampleRate = effect.m_ForceOutputRate;

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_SYNTH(&effect, &envelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);			
			break;
			

		case EF_SYNTHESIZED:
		{
			// Map the EFFECT type
			effect.m_Type = EF_SYNTHESIZED;

			// treat constant force as a special case
			int nConstantForceSign = 1;

			if(ulSubType == SE_CONSTANT_FORCE)
			{
				// cast the type-specific parameters to constant force type
				LPDICONSTANTFORCE pDIConstantForce = (LPDICONSTANTFORCE) pEffect->lpvTypeSpecificParams;

				// see if this is the special case of negative constant force
				if(pDIConstantForce->lMagnitude < 0)
					nConstantForceSign = -1;

				// find the magnitude, offset, and frequency
				dwMagnitude = abs(pDIConstantForce->lMagnitude);
				lOffset = 0;
				ulFrequency = 1;
			}
			else if(ulSubType == SE_RAMPUP)
			{
				// cast the type-specific parameters to ramp type
				LPDIRAMPFORCE pDIRampForce = (LPDIRAMPFORCE) pEffect->lpvTypeSpecificParams;

				// temporary variables
				int nStart = pDIRampForce->lStart;
				int nEnd = pDIRampForce->lEnd;

				// map the subtype based on direction of ramp
				if(nEnd < nStart)
				{
					ulSubType = SE_RAMPDOWN;
					effect.m_SubType = ulSubType;
				}

				// find magnitude, offset, and frequency
				dwMagnitude = abs(nStart - nEnd)/2;
				lOffset = (nStart + nEnd)/2;
				ulFrequency = 1;
			}
			else
			{
				// cast the type-specific parameters to periodic type
				LPDIPERIODIC pDIPeriodic = (LPDIPERIODIC) pEffect->lpvTypeSpecificParams;

				// map the subtype based on the phase
				DWORD dwPhase = pDIPeriodic->dwPhase;
				if(dwPhase != 0)
				{
					if(ulSubType == SE_SINE && dwPhase == 9000)
					{
						ulSubType = SE_COSINE;
						effect.m_SubType = ulSubType;
					}
					else if(ulSubType == SE_SQUAREHIGH && dwPhase == 18000)
					{
						ulSubType = SE_SQUARELOW;
						effect.m_SubType = ulSubType;
					}
					else if(ulSubType == SE_TRIANGLEUP && dwPhase == 18000)
					{
						ulSubType = SE_TRIANGLEDOWN;
						effect.m_SubType = ulSubType;
					}
					else
						return SFERR_NO_SUPPORT;
				}
				// find magnitude, offset, and frequency
				dwMagnitude = pDIPeriodic->dwMagnitude;
				lOffset = pDIPeriodic->lOffset;
				T = (float) ((pDIPeriodic->dwPeriod/SCALE_TIME)/1000.);
				ulFrequency = max(1, (ULONG) ((float) 1.0/ T));
			}

			if (pEffect->dwSamplePeriod)
			{
				T = (float) ((pEffect->dwSamplePeriod/SCALE_TIME)/1000.);
				effect.m_ForceOutputRate = max(1, (ULONG) ((float) 1.0/ T));
			}
			else
				effect.m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;
			
			// Map the SE_PARAM
			// set the frequency and Sample rate
			seParam.m_Freq = ulFrequency;
			seParam.m_SampleRate = DEFAULT_JOLT_FORCE_RATE;

			// see if the offset is out of range
			if(lOffset > DI_FFNOMINALMAX)
			{
				lOffset = DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}
			else if(lOffset < -DI_FFNOMINALMAX)
			{
				lOffset = -DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}

			// see if the magnitude is out of range
			DWORD dwPeak = abs(lOffset) + dwMagnitude;
			if(dwPeak > DI_FFNOMINALMAX)
			{
				dwMagnitude -= dwPeak - DI_FFNOMINALMAX;
				bTruncated = TRUE;
			}
			
			// MaxLevel is the peak magnitude throughout attack/sustain/decay
			ulMaxLevel = dwMagnitude;

			// Map the Envelope
			pDIEnvelope = (LPDIENVELOPE) pEffect->lpEnvelope;
			MapEnvelope(ulDuration, dwMagnitude, &ulMaxLevel, pDIEnvelope, &envelope);

			// use MaxLevel and Offset to find MinAmp/MaxAmp
			if(ulSubType == SE_CONSTANT_FORCE)
			{
				// constant force is a special case
				seParam.m_MaxAmp = nConstantForceSign*((int)ulMaxLevel + lOffset)/SCALE_GAIN;
				seParam.m_MinAmp = 0;
			}
			else
			{
				seParam.m_MinAmp = (-(int)ulMaxLevel + lOffset)/SCALE_GAIN;
				seParam.m_MaxAmp = ((int)ulMaxLevel + lOffset)/SCALE_GAIN;
			}

			if(*pDnloadID == 0 && (dwFlags & DIEP_NODOWNLOAD))
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_SYNTH(&effect, &envelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);
			break;
		}

		case EF_VFX_EFFECT:
		{
			PVFX_PARAM pVFXParam = (PVFX_PARAM)pEffect->lpvTypeSpecificParams;

			// parameter checking
			if(pVFXParam == NULL)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_Bytes != sizeof(VFX_PARAM))
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_PointerType != VFX_FILENAME && pVFXParam->m_PointerType != VFX_BUFFER)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_PointerType == VFX_BUFFER && pVFXParam->m_BufferSize == 0)
				return (SFERR_INVALID_PARAM);
			if(pVFXParam->m_pFileNameOrBuffer == NULL)
				return (SFERR_INVALID_PARAM);

			// check for modifying type-specific (we do not support)
			if(*pDnloadID != 0 && (dwFlags & DIEP_TYPESPECIFICPARAMS))
				return SFERR_NO_SUPPORT;

			// check for default duration
			if(pEffect->dwDuration == DEFAULT_VFX_EFFECT_DURATION)
			{
				// signal default duration by setting duration to -1
				ulDuration = (ULONG)-1;
				effect.m_Duration = ulDuration;
			}


			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = CMD_Download_VFX(&effect, NULL, pVFXParam, ulAction, (USHORT*)pDnloadID, dwFlags);

			break;
		}

		case EF_RAW_FORCE:
		{
			// cast the type-specific parameters to constant force type
			LPDICONSTANTFORCE pDIConstantForce = (LPDICONSTANTFORCE) pEffect->lpvTypeSpecificParams;
			if(pDIConstantForce == NULL)
				return SFERR_INVALID_PARAM;
			LONG nForceValue = pDIConstantForce->lMagnitude/SCALE_GAIN;
			if(nForceValue > 100 || nForceValue < -100)
				return SFERR_INVALID_PARAM;

			// translate to a FORCE structure
			FORCE force;
			force.m_Bytes = sizeof(FORCE);
			force.m_AxisMask = (ULONG)bAxisMask;
			force.m_DirectionAngle2D = nDirectionAngle2D;
			force.m_DirectionAngle3D = 0;
			force.m_ForceValue = nForceValue;

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;
			hRet = FFD_PutRawForce(&force);
			if(!FAILED(hRet))
				*pDnloadID = SYSTEM_EFFECT_ID;

			break;
		}

		case EF_RTC_SPRING:
		{
			PRTCSPRING_PARAM pRTCSpringParam = (PRTCSPRING_PARAM)pEffect->lpvTypeSpecificParams;
			RTCSPRING_PARAM RTCSpringParam;


			// Parameter validate
			if (pRTCSpringParam == NULL)
				return SFERR_INVALID_PARAM;

			if (pRTCSpringParam->m_Bytes != sizeof(RTCSPRING_PARAM))
				return SFERR_INVALID_PARAM;

			if ((pRTCSpringParam->m_XKConstant < MIN_CONSTANT) 
				|| (pRTCSpringParam->m_XKConstant > MAX_CONSTANT))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YKConstant < MIN_CONSTANT) 
				|| (pRTCSpringParam->m_YKConstant > MAX_CONSTANT))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XAxisCenter < MIN_POSITION) 
				|| (pRTCSpringParam->m_XAxisCenter > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YAxisCenter < MIN_POSITION) 
				|| (pRTCSpringParam->m_YAxisCenter > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XSaturation < MIN_POSITION) 
				|| (pRTCSpringParam->m_XSaturation > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YSaturation < MIN_POSITION) 
				|| (pRTCSpringParam->m_YSaturation > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_XDeadBand < MIN_POSITION) 
				|| (pRTCSpringParam->m_XDeadBand > MAX_POSITION))
				return (SFERR_INVALID_PARAM);
			if ((pRTCSpringParam->m_YDeadBand < MIN_POSITION) 
				|| (pRTCSpringParam->m_YDeadBand > MAX_POSITION))
				return (SFERR_INVALID_PARAM);

			if(dwFlags & DIEP_NODOWNLOAD)
				return DI_DOWNLOADSKIPPED;

			// Scale to Jolt numbers
			RTCSpringParam.m_XKConstant  =  pRTCSpringParam->m_XKConstant/SCALE_CONSTANTS;
			RTCSpringParam.m_YKConstant  =  pRTCSpringParam->m_YKConstant/SCALE_CONSTANTS;
			RTCSpringParam.m_XAxisCenter =  pRTCSpringParam->m_XAxisCenter/SCALE_POSITION;
			RTCSpringParam.m_YAxisCenter = -pRTCSpringParam->m_YAxisCenter/SCALE_POSITION;
			RTCSpringParam.m_XSaturation =  pRTCSpringParam->m_XSaturation/SCALE_POSITION;
			RTCSpringParam.m_YSaturation =  pRTCSpringParam->m_YSaturation/SCALE_POSITION;
			RTCSpringParam.m_XDeadBand   =  pRTCSpringParam->m_XDeadBand/SCALE_POSITION;
			RTCSpringParam.m_YDeadBand   =  pRTCSpringParam->m_YDeadBand/SCALE_POSITION;

			hRet = CMD_Download_RTCSpring(&RTCSpringParam, (USHORT*)pDnloadID);
			*pDnloadID = SYSTEM_RTCSPRING_ALIAS_ID;		// Jolt returns ID0 for RTC Spring
														// so return an alias to that
			break;
		}

		default:
			hRet = SFERR_INVALID_PARAM;
	}
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "DownloadEffect. DnloadID = %ld, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// after successful download, check to see if kernel told us to start/restart effect
	if(!FAILED(hRet) && *pDnloadID != 0 && (dwFlags & DIEP_START))
	{
		hRet = CMD_StopEffect((USHORT)*pDnloadID);
		if(FAILED(hRet)) return hRet;
		hRet = CMD_PlayEffectSuperimpose((USHORT)*pDnloadID);
	}

	if(!FAILED(hRet) && bTruncated)
		return DI_TRUNCATED;
	else if(!FAILED(hRet) && bAttemptToModifyUnmodifiable)
		return S_FALSE;
	else
		return (hRet);
}


// ----------------------------------------------------------------------------
// Function:    DestroyEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to destroy
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DestroyEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DestroyEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// Note: Cannot allow actually destroying the SYSTEM Effects
	// so either fake it, or stop the System Effect.
	if (SYSTEM_FRICTIONCANCEL_ID == DnloadID)
		return SUCCESS;

	// Note: SYSTEM_EFFECT_ID is used for PutRawForce
	if (   (SYSTEM_EFFECT_ID == DnloadID)
		|| (SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		|| (SYSTEM_RTCSPRING_ID == DnloadID))
	{
		return (StopEffect(dwDeviceID, SYSTEM_EFFECT_ID));
	}

	return(CMD_DestroyEffect((DNHANDLE) DnloadID));
}

// ----------------------------------------------------------------------------
// Function:    StartEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Start
//				DWORD dwMode		- Playback mode
//				DWORD dwCount		- Loop count
//
//
// Returns:		SUCCESS or Error code
//
//  dwMode: Playback mode is available with the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StartEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    IN DWORD dwMode,
    IN DWORD dwCount)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StartEffect. DnloadID:%ld, Mode:%lx, Count:%lx\r\n",
   			  &szDeviceName[0], DnloadID, dwMode, dwCount);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// special case for raw force
	if(SYSTEM_EFFECT_ID == DnloadID)
	{
		// start has no meaning for raw force
		return S_FALSE;
	}

	// Special case RTC Spring ID
	if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID

	HRESULT hRet = SUCCESS;
	// Don't support PLAY_LOOP for this version
	if (dwCount != 1) 	return (SFERR_NO_SUPPORT);
	// Is it PLAY_SOLO?
	if (dwMode & DIES_SOLO)
	{
		hRet = CMD_PlayEffectSolo((DNHANDLE) DnloadID);
	}
	else
	{
		hRet = CMD_PlayEffectSuperimpose((DNHANDLE) DnloadID);
	}
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function:    StopEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Stop
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StopEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StopEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	// special case for putrawforce
	if(SYSTEM_EFFECT_ID == DnloadID)
	{
		// stop has no meaning for raw force
		return S_FALSE;
	}
	else
	{
	// Special case RTC Spring ID
		if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
			DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID
	}
	return (CMD_StopEffect((DNHANDLE) DnloadID));
}

// ----------------------------------------------------------------------------
// Function:    GetEffectStatus
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	-	 Device ID
//				DWORD DnloadID			- Download ID to get Status
//				LPDWORD pdwStatusCode	- Pointer to a DWORD for Status
//
//
// Returns:		SUCCESS or Error code
//				Status Code: DEV_STS_EFFECT_STOPPED
//							 DEV_STS_EFFECT_RUNNING
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetEffectStatus(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    OUT LPDWORD pdwStatusCode)
{
	HRESULT hRet = SUCCESS;
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "GetEffectStatus, DnloadID=%d\r\n", DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

// Special case RTC Spring ID
	if(SYSTEM_RTCSPRING_ALIAS_ID == DnloadID)
		DnloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring
											// so return send alias ID	
	assert(pdwStatusCode);
	BYTE bStatusCode;

	hRet = g_pJoltMidi->GetEffectStatus(DnloadID, &bStatusCode);
	if (SUCCESS != hRet) return hRet;
	if (SWDEV_STS_EFFECT_RUNNING == bStatusCode) 
		*pdwStatusCode = DIEGES_PLAYING;
	else
		*pdwStatusCode = NULL;	// Stopped

	return (hRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_objec.cpp ===
/****************************************************************************

    MODULE:     	SW_OBJEC.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IUnknown Method(s) for DirectInputEffectDriver Class objects
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
				16-Mar-99	waltw	Moved CJoltMidi initialization from
									CDirectInputEffectDriver::Init to
									CImpIDirectInputEffectDriver::DeviceID

****************************************************************************/
#include "SW_objec.hpp"

//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif
extern HANDLE g_hSWFFDataMutex;



// ****************************************************************************
// *** --- Member functions for base class CDirectInputEffectDriver
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::CDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CDirectInputEffectDriver Object
// Parameters:  LPUNKNOWN 		pUnkOuter	 - Ptr to a controlling unknown.
//				PFNDESTROYED	pfnDestroy   - Call when object is destroyed.
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CDirectInputEffectDriver::CDirectInputEffectDriver(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy)
{
#ifdef _DEBUG
   	OutputDebugString("CDirectInputEffectDriver::CDirectInputEffectDriver()\r\n");
#endif

    m_cRef=0;

    m_pImpIDirectInputEffectDriver=NULL;
    m_pUnkOuter=pUnkOuter;
    m_pfnDestroy=pfnDestroy;
    return;
}

CDirectInputEffectDriver::~CDirectInputEffectDriver(void)
{
#ifdef _DEBUG
   	OutputDebugString("CDirectInputEffectDriver::~CDirectInputEffectDriver()\r\n");
#endif

//Delete the interface implementations created in Init
    DeleteInterfaceImp(m_pImpIDirectInputEffectDriver);
    return;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::Init
// Purpose:		Instantiates the interface implementations for this object.
// Parameters:  none
//				
// Returns:		BOOL	- TRUE if initialization succeeds, FALSE otherwise.
// Algorithm:
//
// Note:
//		Creating the interfaces means creating instances of
//		the interface implementation classes.  The constructor
//		parameters is a pointer to CDirectInputEffectDriver that has the
//		IUnknown functions to which the interface implementations
//		delegate.
//
// ----------------------------------------------------------------------------
BOOL CDirectInputEffectDriver::Init(void)
{
#ifdef _DEBUG
	OutputDebugString("CDirectInputEffectDriver::Init\n");
#endif

    m_pImpIDirectInputEffectDriver=new CImpIDirectInputEffectDriver(this);
    if (NULL==m_pImpIDirectInputEffectDriver)
		return FALSE;

	return TRUE;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::QueryInterface
// Purpose:		Manages the interfaces for this object which supports the
//				IUnknown, and IDirectInputEffectDriver interfaces.
//
// Parameters:  REFIID riid		- REFIID of the interface to return.
//				PPVOID ppv      - PPVOID in which to store the pointer.
//
//				
// Returns:		HRESULT         NOERROR on success, E_NOINTERFACE if the
//				                interface is not supported.
//
// Algorithm:
//
// Note:
//		IUnknown comes from CDirectInputEffectDriver.  Note that here and in
//		the lines below we do not need to explicitly typecast
//		the object pointers into interface pointers because
//		the vtables are identical.  If we had additional virtual
//		member functions in the object, we would have to cast
//		in order to set the right vtable.  This is demonstrated
//		in the multiple-inheritance version, CObject3.
//
// ----------------------------------------------------------------------------
STDMETHODIMP CDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
	//Always NULL the out-parameters
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    //Other interfaces come from interface implementations
    if (IID_IDirectInputEffectDriver==riid)
        *ppv=m_pImpIDirectInputEffectDriver;

    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::AddRef and CDirectInputEffectDriver::Release
// Purpose:		Reference counting members.  When Release sees a zero count
//				the object destroys itself.
//
// Parameters:  none
//				
// Returns:		DWORD	m_cRef value
//
// Algorithm:
//
// Note:
//
// ----------------------------------------------------------------------------
DWORD CDirectInputEffectDriver::AddRef(void)
{
	return ++m_cRef;
}

DWORD CDirectInputEffectDriver::Release(void)
{
    if (0!=--m_cRef) return m_cRef;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\version.h ===
/*******************************************************************************
**
**       MODULE: VERSION.H
**
**  DESCRIPTION: Contains version numbers for Vger Project
**
**
**       AUTHOR: Manolito Adan
**
**
**      CREATED: 30-Sep-96
**		REVISED: 23-Dec-96
**				 15-Mar-99	waltw	Now get info from ntverp.h & common.ver in
**									NT build tree
**
**
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T    C O R P   1 9 8 1 - 1 9 9 4.
**
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\sw_objec.hpp ===
/****************************************************************************

    MODULE:     	SW_Objec.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definition of the CDirectInputEffectDriver class that uses interface
					implementations to provide IDirectInputEffectDriver
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
				26-Feb-97	MEA		Added SetGain
				13-Mar-99	waltw	Deleted unused m_pJoltMidi and accessors

****************************************************************************/
#ifndef _SW_OBJEC_SEEN
#define _SW_OBJEC_SEEN

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include "dinput.h"
#include "dinputd.h"
#include "midi_obj.hpp"
#include "dx_map.hpp"


//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                 {\
                delete p;\
                p=NULL;\
                }\
            }

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID


/*
 * The object we want to provide in OLE supports the IUnknown,
 * IDirectInputEffectDriver interfaces.
 *
 * The C++ class, CDirectInputEffectDriver, implements these interfaces with
 * "interface implementations" where the C++ class itself inherits
 * from and implements IUnknown members and then contains
 * other C++ classes that each separately inherit from the other
 * interfaces.  The other classes are the "interface implementations."
 */


/*
 * In this technique you'll generally need forward references
 * like this for use in declaring the object class.
 */
class CImpIDirectInputEffectDriver;
typedef CImpIDirectInputEffectDriver *PCImpIDirectInputEffectDriver;

//The C++ class that manages the actual object.
class CDirectInputEffectDriver : public IUnknown
{
    /*
     * Usually interface implementations will need back pointers
     * to the object itself since this object usually manages
     * the important data members.  In that case, make the
     * interface implementation classes friends of the object.
     */

    friend CImpIDirectInputEffectDriver;

 protected:
 	ULONG           m_cRef;         //Object reference count
    LPUNKNOWN       m_pUnkOuter;    //Controlling unknown

    PFNDESTROYED    m_pfnDestroy;   //To call on closure

    /*
     * I use "m_pImpI" as a prefix to differentiate interface
     * implementations for this object from other interface
     * pointer variables I might hold to other objects, which
     * would be prefixed with "m_pI".
     */
    PCImpIDirectInputEffectDriver  m_pImpIDirectInputEffectDriver;

 public:
     CDirectInputEffectDriver(LPUNKNOWN, PFNDESTROYED);
     ~CDirectInputEffectDriver(void);

     BOOL Init(void);

     //IUnknown members
     STDMETHODIMP         QueryInterface(REFIID, PPVOID);
     STDMETHODIMP_(DWORD) AddRef(void);
     STDMETHODIMP_(DWORD) Release(void);
};


typedef CDirectInputEffectDriver *PCDirectInputEffectDriver;


/*
 * Interface implementation classes are C++ classes that
 * each singly inherit from an interface.  Their IUnknown
 * members delegate calls to CDirectInputEffectDriver's IUnknown members--
 * since IUnknown members affect the entire *object*, and
 * since these interfaces are not the object itself, we must
 * delegate to implement the correct behavior.
 */

class CImpIDirectInputEffectDriver : public IDirectInputEffectDriver
{
 private:
	DWORD		m_cRef;         //For debugging
	PCDirectInputEffectDriver	m_pObj;	//Back pointer for delegation

 public:
    CImpIDirectInputEffectDriver(PCDirectInputEffectDriver);
    ~CImpIDirectInputEffectDriver(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(DWORD) AddRef(void);
    STDMETHODIMP_(DWORD) Release(void);

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID);
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS);
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE);
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD);
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD);
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE);
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD);
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD);
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD);
};

#endif _SW_OBJEC_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\vxdioctl.hpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.HPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header file for VXDIOCTL.CPP
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL	
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				20-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!

****************************************************************************/
#ifndef __VXDIOCTL_HPP__
#define __VXDIOCTL_HPP__

#include <windows.h>
#include "FFeature.h"

#ifndef override
#define override
#endif

//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

//--------------------- Host converted Channel ID Structure -----------------
struct LOCAL_PRODUCT_ID {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
};

// Bitmasks for Response Status - 1.xx (we don't support version 1 - informational only)
//#define STATUS_GATE_1XX			0x08
//#define RUNNING_MASK_1XX			0x04
//#define ACKNACK_MASK_1XX			0x02
//#define SCLK_MASK_1XX				0x01

// Bitmasks for Response Status - Version 2
#define STATUS_GATE_200				0x80
#define RUNNING_MASK_200			0x40
#define ACKNACK_MASK_200			0x20
#define SCLK_MASK_200				0x10

/************************************************************************
**
**	@class DriverCommunicator |
**		This is the interface for driver communications
**
*************************************************************************/
class DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DriverCommunicator() {};
		//@cmember destructor
		virtual ~DriverCommunicator() {};

		virtual HRESULT ResetDevice() { return E_NOTIMPL; }
		virtual HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor) { return E_NOTIMPL; }
		virtual HRESULT GetID(LOCAL_PRODUCT_ID& rProductID) { return E_NOTIMPL; }
		virtual HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus) { return E_NOTIMPL; }
		virtual HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex) { return E_NOTIMPL; }
		virtual HRESULT GetStatusGateData(DWORD& dwGateData) { return E_NOTIMPL; }
		virtual HRESULT SetBackdoorPort(ULONG ulPortAddress) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoorShortMidi(DWORD dwMidiMessage) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoorLongMidi(BYTE* pMidiData) { return E_NOTIMPL; }
};


/************************************************************************
**
**	@class HIDFeatureCommunicator |
**		Communicates with the HID driver via HID Features (NT5)
**
*************************************************************************/
class HIDFeatureCommunicator :
	public DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		HIDFeatureCommunicator();
		//@cmember destructor
		override ~HIDFeatureCommunicator();

		BOOL Initialize(UINT uJoystickId);
		override HRESULT ResetDevice();
		override HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor);
		override HRESULT GetID(LOCAL_PRODUCT_ID& rProductID);
		override HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus);
		override HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex);
		override HRESULT GetStatusGateData(DWORD& rdwGateData);
		override HRESULT SendBackdoorShortMidi(DWORD dwMidiMessage);
		override HRESULT SendBackdoorLongMidi(BYTE* pMidiData);
	//@access Private Data Members
	private:
		CForceFeatures m_ForceFeature;
};


extern DriverCommunicator* g_pDriverCommunicator;

/********************************** Old dead code ***********************************/
#if 0
#define NT_VXD
#ifdef NT_VXD
// REVIEW: swforce.sys should use _JOYCHANNELID instead of _PRODUCT_ID
#define _PRODUCT_ID _JOYCHANNELID
#define PRODUCT_ID JOYCHANNELID
#define PPRODUCT_ID PJOYCHANNELID
#include "swforce.h"
#undef _PRODUCT_ID
#undef PRODUCT_ID
#undef PPRODUCT_ID
#endif

#define IOCTL_OPEN               	0
#define IOCTL_GET_DRIVERVERSION		1
#define IOCTL_GET_DATAPACKET  		2
#define IOCTL_GET_STATUSPACKET 		3
#define IOCTL_GET_IDPACKET 	   		4
#define IOCTL_GET_DIAGNOSTICS		5
#define IOCTL_MIDISENDSHORTMSG   	6
#define IOCTL_GET_ACKNACK			7
#define IOCTL_SET_MIDIPORT			8
#define IOCTL_MIDISENDLONGMSG		9
#define	IOCTL_HW_RESET				10

#define	COMM_DEFAULT_MIDI_PORT		0
#define COMM_COM1					1
#define COMM_COM2					2
#define COMM_COM3					3
#define COMM_COM4					4
#define COMM_MIDI300				0x300


//----------------------- Joystick Diagnostics Counters Data Structure ---
typedef struct _DIAGNOSTIC_COUNTER {
	DWORD	cBytes;
	DWORD	DataFailCount;			// GetData
	DWORD	StatusFailCount;		// GetStatus
	DWORD	IDFailCount;			// GetID
	DWORD	AckNackFailCount;		// Get Ack/Nack
	DWORD	DataPacketCount;		
	DWORD	StatusPacketCount;
	DWORD	IDPacketCount;
	DWORD	AckNackPacketCount;
	DWORD	TotalPktFails;

} DIAGNOSTIC_COUNTER, *PDIAGNOSTIC_COUNTER;


//--------------------- Joystick Channel Data Structure --------------------
typedef struct _JOYCHANNELDATA {
	DWORD	cBytes;
	DWORD	dwXAxis;
	DWORD	dwYAxis;
	DWORD	dwThrottle;
	DWORD	dwRudder;
	DWORD	dwHatSwitch;
	DWORD	dwButtons;
} JOYCHANNELDATA,   *PJOYCHANNELDATA;

//--------------------- Joystick Channel Status Structure --------------------
#ifndef NT_VXD
typedef struct _JOYCHANNELSTATUS {
	DWORD	cBytes;
	LONG	dwXVel;
	LONG	dwYVel;
	LONG	dwXAccel;
	LONG	dwYAccel;
	DWORD	dwDeviceStatus;
} JOYCHANNELSTATUS, *PJOYCHANNELSTATUS;
#endif !NT_VXD

//--------------------- Joystick Channel ID Structure -----------------------
#ifndef NT_VXD
typedef struct _JOYCHANNELID  {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWVersion;
} JOYCHANNELID, *PJOYCHANNELID;
#endif !NT_VXD

//--------------------- Host converted Channel ID Structure -----------------
typedef struct _PRODUCT_ID  {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
} PRODUCT_ID, *PPRODUCT_ID;


//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;


//
// --- IOCTL interface to Digital OverDrive mini-driver ---------------------
//
HANDLE WINAPI GetDevice(
	IN const char* vxdName);

BOOL WINAPI CloseDevice(
	IN HANDLE hVxD);


HRESULT QueryDriverVersion(DWORD& major, DWORD& minor);

HRESULT WINAPI GetDataPacket(
	IN HANDLE hDevice,
	IN OUT PJOYCHANNELDATA pDataPacket);

HRESULT WINAPI GetStatusPacket(
	IN HANDLE hDevice, 
	IN OUT PJOYCHANNELSTATUS pStatusPacket);

HRESULT WINAPI GetIDPacket(
	IN HANDLE hDevice, 
	IN OUT PPRODUCT_ID pID);

HRESULT WINAPI GetDiagnostics(
	IN HANDLE hDevice, 
	IN OUT PDIAGNOSTIC_COUNTER pDiagnostics);

HRESULT WINAPI GetAckNack(
	IN HANDLE hDevice,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex);

HRESULT WINAPI GetStatusGateData(
	IN HANDLE hDevice,
	IN OUT DWORD *pdwStatusGateData);

HRESULT WINAPI SendBackDoorShortMidi(
	IN HANDLE hDevice,
	IN ULONG ulData);

HRESULT WINAPI SendBackDoorLongMidi(
	IN HANDLE hDevice,
	IN PBYTE pData);

HRESULT WINAPI SetMidiPort(
	IN HANDLE hDevice,
	IN ULONG  ulPort);

HRESULT WINAPI JoltHWReset(
	IN HANDLE hDevice);

#endif
#endif __VXDIOCTL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dtrans.cpp ===
//@doc
/******************************************************
**
** @module DTRANS.CPP | DataTransmitter implementation file
**
** Description:
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
**	21-Mar-99	waltw	Removed unused ReportTransmission (Win9x only)
**	22-Mar-99	waltw	Added DWORD dwDeviceID param to Initialize
**						members of DataTransmitter and derived classes
**
** (c) 1986-1999 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "FFDevice.h"
#include "DTrans.h"
#include "DPack.h"
#include "WinIOCTL.h"	// For IOCTLs
#include "VxDIOCTL.hpp"
#include "SW_error.hpp"
#include "midi_obj.hpp"
#include "joyregst.hpp"
#include "CritSec.h"

DataTransmitter* g_pDataTransmitter = NULL;

extern CJoltMidi *g_pJoltMidi;

#ifdef _DEBUG
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

const char cCommPortNames[4][5] = { "COM1", "COM2", "COM3", "COM4" };
const unsigned short c1_16_BytesPerShot = 3;
const DWORD c1_16_SerialSleepTime = 1;

/****************** DataTransmitter class ***************/
HRESULT DataTransmitter::Transmit(ACKNACK& ackNack)
{
	ackNack.cBytes = 0;	// Indicated not valid (ack/nack not done)

	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	BOOL forcedToggle = FALSE;
	if (m_NackToggle == 2) {	// When Not yet sunk up == 2, probably initializing if 2 (synch up)
		ULONG portByte = 0;
		g_pDriverCommunicator->GetPortByte(portByte); // don't care about success, always fails on old driver
		if (portByte & STATUS_GATE_200) {
			SetNextNack(1);
		} else {
			SetNextNack(0);
		}
		forcedToggle = TRUE;
	}

	DataPacket* pNextPacket = NULL;
	for (USHORT packetIndex = 0; packetIndex < g_pDataPackager->GetNumDataPackets();  packetIndex++) {
		pNextPacket = g_pDataPackager->GetPacket(packetIndex);
		ASSUME_NOT_NULL(pNextPacket);
		if (pNextPacket == NULL) {
			return SFERR_DRIVER_ERROR;
		}
		BOOL success = FALSE;
		int retries = int(pNextPacket->m_NumberOfRetries);
		do {
			m_NackToggle = (m_NackToggle + 1) % 2;	// Verions 2.0 switches button-line ack/nack methods each time
			ULONG portByte = 0;
			BOOL error = FALSE;
			if (g_pDriverCommunicator->GetPortByte(portByte) == SUCCESS) {	// Will fail on old driver
				if (portByte & STATUS_GATE_200) {	// Line is high
					if (m_NackToggle != 0) { // We should be expecting low
						m_NackToggle = 0;		// Update it if wrong
						error = TRUE;
						DebugOut("SW_WHEEL.DLL: Status Gate is out of Synch (High - Expecting Low)!!!\r\n");
					}
				} else {	// Line is low
					if (m_NackToggle != 1) { // We should be expecting high
						m_NackToggle = 1;		// Update it if wrong
						error = TRUE;
						DebugOut("SW_WHEEL.DLL: Status Gate is out of Synch (Low - Expecting High)!!!\r\n");
					}
				}
			}

			Send(pNextPacket->m_pData, pNextPacket->m_BytesOfData);

			if (pNextPacket->m_AckNackDelay != 0) {
				Sleep(pNextPacket->m_AckNackDelay);
			}
			
			ackNack.cBytes = sizeof(ACKNACK);
			HRESULT hr = g_pJoltMidi->GetAckNackData(pNextPacket->m_AckNackTimeout, &ackNack, (USHORT)pNextPacket->m_AckNackMethod);
			if 	(forcedToggle == TRUE) {
				m_NackToggle = 2;
			}
			if (hr != SUCCESS) {
				return SFERR_DRIVER_ERROR;
			}
			success = (ackNack.dwAckNack == ACK);
			if (success == FALSE) {		// We don't want to bother retrying on certian error codes, retrying is worthless
				success = ((ackNack.dwErrorCode == DEV_ERR_MEM_FULL_200) || (ackNack.dwErrorCode == DEV_ERR_PLAY_FULL_200) || (ackNack.dwErrorCode == DEV_ERR_INVALID_ID_200));
			}
		} while (!success && (--retries > 0));
		if (ackNack.dwAckNack == NACK) {
			return SFERR_DEVICE_NACK;
		}
	}
	g_pDataPackager->ClearPackets();
	return SUCCESS;
}

/****************** SerialDataTransmitter class ***************/

/******************************************************
**
** SerialDataTransmitter::SerialDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialDataTransmitter::SerialDataTransmitter() : DataTransmitter(),
	m_SerialPort(INVALID_HANDLE_VALUE),
	m_SerialPortIDHack(0)
{
}

/******************************************************
**
** SerialDataTransmitter::~SerialDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
SerialDataTransmitter::~SerialDataTransmitter()
{
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}
}


/******************************************************
**
** SerialDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialDataTransmitter::Initialize(DWORD dwDeviceID)
{
	// If already open, close for reinitialization
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}

	for (unsigned int portNum = 0; portNum < 4; portNum++) {
		DebugOut(cCommPortNames[portNum]);
		DebugOut(":\r\n");
		m_SerialPort = ::CreateFile(cCommPortNames[portNum], GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (m_SerialPort != INVALID_HANDLE_VALUE) {
			DCB CommDCB;
			if (::GetCommState(m_SerialPort, &CommDCB)) {
#ifdef _DEBUG
				char dbgout[255];
				wsprintf(dbgout, "Baud Rate = 0x%08X (38400 = 0x%08X)\r\n", CommDCB.BaudRate, CBR_38400);
				_RPT0(_CRT_WARN, dbgout);
#endif _DEBUG
				CommDCB.BaudRate = CBR_38400;
				CommDCB.StopBits = ONESTOPBIT;
				CommDCB.ByteSize = 8;
				CommDCB.Parity = NOPARITY;
				if (!::SetCommState(m_SerialPort, &CommDCB)) {
					DebugOut("Unabled to set baud rate\r\n");
				}
			}
			::GetCommState(m_SerialPort, &CommDCB);

			if (g_ForceFeedbackDevice.DetectHardware()) {
				m_SerialPortIDHack = portNum + 1;
				// Write to shared file
				DebugOut(" Opened and FFDev Detected\r\n");
				break;	// Exit from for loop
			}
			// Not found
			::CloseHandle(m_SerialPort);
			DebugOut(" Opened but FFDev NOT detected\r\n");
			m_SerialPort = INVALID_HANDLE_VALUE;
		} else {
			DebugOut(" Not able to open\r\n");
		}
	}
	if (m_SerialPort != INVALID_HANDLE_VALUE) {	// Found it
		DWORD oldPortID;
		DWORD oldAccessMethod;
		joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
		DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_SERIAL_FILE;
		if ((accessMethod != oldAccessMethod) || (portNum != oldPortID)) {
			joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, portNum);
		}
		return TRUE;
	}
	return FALSE;
}

/******************************************************
**
** SerialDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL SerialDataTransmitter::Send(BYTE* data, UINT numBytes) const
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_SerialPort == NULL) {
		return FALSE;
	}

	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)) {
		DWORD subTotalWritten;
		DWORD totalWritten = 0;
		DWORD numLeft = numBytes;
		while (numLeft > c1_16_BytesPerShot) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), c1_16_BytesPerShot, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
			numLeft -= subTotalWritten;
			Sleep(c1_16_SerialSleepTime);
		}
		if (numLeft > 0) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), numLeft, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
		}
		return (totalWritten == numBytes);
	}

	// Firmware other than 1.16
	DWORD numWritten;
	if (::WriteFile(m_SerialPort, data, numBytes, &numWritten, NULL) == FALSE) {
		return FALSE;
	}
	return (numWritten == numBytes);
}


/****************** WinMMDataTransmitter class ******************/
/******************************************************
**
** WinMMDataTransmitter::WinMMDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
WinMMDataTransmitter::WinMMDataTransmitter() : DataTransmitter(),
	m_MidiOutHandle(NULL)
{
	// Check for callback event
	m_EventMidiOutputFinished = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (m_EventMidiOutputFinished == NULL) {	// Event not yet created
		m_EventMidiOutputFinished = CreateEvent(NULL, TRUE, FALSE, SWFF_MIDIEVENT);
	}
}

/******************************************************
**
** WinMMDataTransmitter::~WinMMDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
WinMMDataTransmitter::~WinMMDataTransmitter()
{
	// Kill MidiOutputEvent
	if (m_EventMidiOutputFinished != NULL) {
		CloseHandle(m_EventMidiOutputFinished);
		m_EventMidiOutputFinished = NULL;
	}

	// Close MidiHandle	-- Check shared memory
	if (m_MidiOutHandle != NULL) {
		if ((NULL != g_pJoltMidi) && (g_pJoltMidi->GetSharedMemoryReferenceCount() == 0)) {	// Just me (reference count has already been lowered for me)
			// Reset, close and release Midi Handles
			::midiOutReset(m_MidiOutHandle);
			::midiOutClose(m_MidiOutHandle);
			m_MidiOutHandle = NULL;
		} else {
			DebugOut("SW_WHEEL.DLL: Cannot close midi in use by another process\r\n");
		}
	}
}


/******************************************************
**
** WinMMDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL WinMMDataTransmitter::Initialize(DWORD dwDeviceID)
{
	// Wouldn't want to people initializing at the same time
	g_CriticalSection.Enter();

	if (NULL == g_pJoltMidi)
	{
		g_CriticalSection.Leave();
		return (FALSE);
	}
	// Check to see if another task has already opened MidiPort
	if (g_pJoltMidi->MidiOutHandleOf() != NULL) {
		m_MidiOutHandle = g_pJoltMidi->MidiOutHandleOf();
		DebugOut("SW_WHEEL.DLL: Using winmm handle from another process\r\n");
		g_CriticalSection.Leave();
		return TRUE;
	}

	try {
		UINT numMidiDevices = ::midiOutGetNumDevs();
		if (numMidiDevices == 0) {
			throw 0;	// No devices to check
		}

		MIDIOUTCAPS midiOutCaps;
		for (UINT midiDeviceID = 0; midiDeviceID < numMidiDevices; midiDeviceID++) {
			// Get dev-caps
			MMRESULT midiRet = ::midiOutGetDevCaps(midiDeviceID, &midiOutCaps, sizeof(midiOutCaps));
			if (midiRet != MMSYSERR_NOERROR) {
				throw 0;	// Something went ugly - All ids should be valid upto numMidiDevs
			}

			// Midi hardware-port device (thats what we are looking for)
			if (midiOutCaps.wTechnology == MOD_MIDIPORT) {
				DebugOut("DetectMidiDevice: Opening WinMM Midi Output\n");

				// Try to open the thing

				UINT openRet = ::midiOutOpen(&m_MidiOutHandle, midiDeviceID, (DWORD) m_EventMidiOutputFinished, (DWORD) this, CALLBACK_EVENT);
//				UINT openRet = ::midiOutOpen(&m_MidiOutHandle, midiDeviceID, (DWORD) NULL, (DWORD) this, CALLBACK_EVENT);
				if ((openRet != MMSYSERR_NOERROR) || (m_MidiOutHandle == NULL)) {
					throw 0;	// Unable to open midi handle for midi-device
				}

				DebugOut("Open Midi Output - Success.\r\n");
				if (g_ForceFeedbackDevice.DetectHardware()) {
					// Found Microsoft FF hardware - Set all the stuff and return happy
					g_pJoltMidi->SetMidiOutHandle(m_MidiOutHandle);

					// Tell the Registry WinMM was okay
					DWORD oldPortID;
					DWORD oldAccessMethod;
					joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
					DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_WINMM;
					if ((accessMethod != oldAccessMethod) || (oldPortID != 0)) {
						joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, 0);
					}
					g_CriticalSection.Leave();
					return TRUE;
				}

				// Not what we were looking for - close and continue
				::midiOutClose(m_MidiOutHandle);
				m_MidiOutHandle = NULL;
			}	// End of ModMidiPort found
		}	// End of for loop
		throw 0; // Did not find MS FFDevice
	} catch (...) {
		m_MidiOutHandle = NULL;
		DebugOut("Failure to initlaize WinMMDataTransmitter\r\n");
		g_CriticalSection.Leave();
		return FALSE;
	}
}

/******************************************************
**
** WinMMDataTransmitter::MakeShortMessage()
**
** returns: DWORD WinMM MidiShort message
** @mfunc MakeShortMessage.
**
******************************************************/
DWORD WinMMDataTransmitter::MakeShortMessage(BYTE* data, UINT numBytes) const
{
	DWORD shortMessage = data[0];
	if (numBytes > 1) {
		shortMessage |= (data[1] << 8);
		if (numBytes < 2) {
			shortMessage |= (data[2] << 16);
		}
	}
	return shortMessage;
}

/******************************************************
**
** WinMMDataTransmitter::MakeLongMessageHeader()
**
** returns: SUCCESS indication and WinMM MidiLong message header
** @mfunc MakeLongMessageHeader.
**
******************************************************/
BOOL WinMMDataTransmitter::MakeLongMessageHeader(MIDIHDR& longHeader, BYTE* data, UINT numBytes) const
{
    longHeader.lpData = LPSTR(data);
    longHeader.dwBufferLength = numBytes;
    longHeader.dwBytesRecorded = numBytes;
    longHeader.dwFlags = 0;
	longHeader.dwUser = 0;
	longHeader.dwOffset = 0;

    return (::midiOutPrepareHeader(m_MidiOutHandle, &longHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
}

/******************************************************
**
** WinMMDataTransmitter::DestroyLongMessageHeader()
**
** returns: TRUE if header was unprepared
** @mfunc DestroyLongMessageHeader.
**
******************************************************/
BOOL WinMMDataTransmitter::DestroyLongMessageHeader(MIDIHDR& longHeader) const
{
    return (::midiOutUnprepareHeader(m_MidiOutHandle, &longHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
}

/******************************************************
**
** WinMMDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL WinMMDataTransmitter::Send(BYTE* data, UINT numBytes) const
{
	// Do we have a valid midi port (hopefully with MS FF device connected)
	if (m_MidiOutHandle == NULL) {
		return FALSE;
	}

	// Sanity check
	if ((data == NULL) || (numBytes == 0)) {
		return FALSE;
	}

	// Clear the Event Callback
	::ResetEvent(m_EventMidiOutputFinished);

	// Short message
	if (data[0] < 0xF0) {
		DWORD shortMessage = MakeShortMessage(data, numBytes);
		return (::midiOutShortMsg(m_MidiOutHandle, shortMessage) == MMSYSERR_NOERROR);
	}

	// Long message
	BOOL retVal = FALSE;
	MIDIHDR midiHeader;
	if (MakeLongMessageHeader(midiHeader, data, numBytes)) {
		retVal = (::midiOutLongMsg(m_MidiOutHandle, &midiHeader, sizeof(MIDIHDR)) == MMSYSERR_NOERROR);
		DestroyLongMessageHeader(midiHeader);

		if (retVal == FALSE) {	// Didn't work, kick it
			::midiOutReset(m_MidiOutHandle);
		}
	}

	return retVal;
}

/******************************************************
**
** WinMMDataTransmitter::WaitTillSendFinished()
**
** returns: TRUE when all data is successfully sent or
**			FALSE for timeOut
** @mfunc Send.
**
******************************************************/
BOOL WinMMDataTransmitter::WaitTillSendFinished(DWORD timeOut)
{
	BOOL retVal = FALSE;
	if (m_EventMidiOutputFinished != NULL) {
		retVal = (::WaitForSingleObject(m_EventMidiOutputFinished, timeOut) == WAIT_OBJECT_0);
		::ResetEvent(m_EventMidiOutputFinished);
	}
	return retVal;
}

/****************** BackdoorDataTransmitter class ***************/

/******************************************************
**
** BackdoorDataTransmitter::BackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
BackdoorDataTransmitter::BackdoorDataTransmitter() : DataTransmitter(),
	m_DataPort(INVALID_HANDLE_VALUE)
{
	m_OldBackdoor = (g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (g_ForceFeedbackDevice.GetDriverVersionMinor() == 0);
}

/******************************************************
**
** BackdoorDataTransmitter::~BackdoorDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
BackdoorDataTransmitter::~BackdoorDataTransmitter()
{
	if (m_DataPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_DataPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_DataPort = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** BackdoorDataTransmitter::Initialize()
**
** returns: This base class only does error checking on preset values
** @mfunc Initialize.
**
******************************************************/
BOOL BackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (g_ForceFeedbackDevice.IsOSNT5()) {
		return FALSE;	// NT5 cannot use backdoor!
	}

	return TRUE;
}

/******************************************************
**
** BackdoorDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL BackdoorDataTransmitter::Send(BYTE* pData, UINT numBytes) const
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_DataPort == NULL) {
		return FALSE;
	}

	return SUCCEEDED(g_pDriverCommunicator->SendBackdoor(pData, numBytes));
}

/****************** SerialBackdoorDataTransmitter class ***************/

/******************************************************
**
** SerialBackdoorDataTransmitter::SerialBackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialBackdoorDataTransmitter::SerialBackdoorDataTransmitter() : BackdoorDataTransmitter()
{
}

/******************************************************
**
** SerialBackdoorDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialBackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

	SerialDataTransmitter serialFrontDoor;

	// This is funky
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}
	g_pDataTransmitter = &serialFrontDoor;

	if (serialFrontDoor.Initialize(dwDeviceID)) {
		m_DataPort = HANDLE(serialFrontDoor.GetSerialPortHack());
		if (g_pDriverCommunicator->SetBackdoorPort(ULONG(m_DataPort)) == SUCCESS) {
			serialFrontDoor.StopAutoClose();
			DWORD oldPortID, oldAccessMethod;
			joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
			DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_SERIAL_BACKDOOR;
			joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, oldPortID);
			g_pDataTransmitter = this;
			return TRUE;
		}
	}
	g_pDataTransmitter = this;
	return FALSE;
}

/****************** MidiBackdoorDataTransmitter class ***************/

/******************************************************
**
** MidiBackdoorDataTransmitter::MidiBackdoorDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
MidiBackdoorDataTransmitter::MidiBackdoorDataTransmitter() : BackdoorDataTransmitter()
{
}

/******************************************************
**
** MidiBackdoorDataTransmitter::~MidiBackdoorDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
MidiBackdoorDataTransmitter::~MidiBackdoorDataTransmitter()
{
	m_DataPort = NULL;		// Prevent attempt to ::CloseHandle(m_DataPort)
}

/******************************************************
**
** MidiBackdoorDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL MidiBackdoorDataTransmitter::Initialize(DWORD dwDeviceID)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

    if (midiOutGetNumDevs() == 0) {
		return FALSE;	// No midi-devices backdoor check is worthless
	}

	// Valid MIDI ports table for backdoor - ordered by probability of working
	DWORD midiPorts[] = {0x330, 0x300, 0x320, 0x340, 0x310, 0x350, 0x360, 0x370, 0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0};
	int numMidiPorts = sizeof(midiPorts)/sizeof(DWORD);

	m_DataPort = NULL;

	for (int i=0; i < numMidiPorts; i++) {
#ifdef _DEBUG
		char buff[256];
        wsprintf(buff, "MidiBackdoorDataTransmitter::Initialize(): Midi Port:%lx - ", midiPorts[i]);
        DebugOut(buff);
#endif
		// We have the Port #, Let's see if Jolt is out there
		m_DataPort = HANDLE(midiPorts[i]);
		if (g_pDriverCommunicator->SetBackdoorPort(ULONG(m_DataPort)) == SUCCESS) {
			if (g_ForceFeedbackDevice.DetectHardware()) {
				DebugOut(" Success!\n");

				DWORD oldPortID;
				DWORD oldAccessMethod;
				joyGetForceFeedbackCOMMInterface(dwDeviceID, &oldAccessMethod, &oldPortID);
				DWORD accessMethod = (oldAccessMethod & (MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR)) | COMM_MIDI_BACKDOOR;
				if ((accessMethod != oldAccessMethod) || (ULONG(m_DataPort) != oldPortID)) {
					joySetForceFeedbackCOMMInterface(dwDeviceID, accessMethod, ULONG(m_DataPort));
				}
//				joySetForceFeedbackCOMMInterface(0, COMM_MIDI_BACKDOOR, ULONG(m_DataPort));
				return TRUE;
			} else {
				m_DataPort = NULL;
				DebugOut(" No Answer\n");
			}
		}		
	}

	// If we have fallen through we have failed
	return FALSE;
}

/******************************************************
**
** MidiBackdoorDataTransmitter::InitializeSpecific(HANDLE specificHandle)
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL MidiBackdoorDataTransmitter::InitializeSpecific(DWORD dwDeviceID, HANDLE specificHandle)
{
	if (!BackdoorDataTransmitter::Initialize(dwDeviceID)) {
		return FALSE;
	}

    if (midiOutGetNumDevs() == 0) {
		return FALSE;	// No midi-devices backdoor check is worthless
	}

	m_DataPort = NULL;

	// We have the Port #, Let's see if Jolt is out there
	if (g_pDriverCommunicator->SetBackdoorPort(ULONG(specificHandle) == SUCCESS)) {
		if (g_ForceFeedbackDevice.DetectHardware()) {
			m_DataPort = specificHandle;
//			No need to set registry the registry is what brought us here
			return TRUE;
		}
	}

	// If we have fallen through we have failed
	return FALSE;
}

#if 0
/************************** PinTransmitter Class ******************************/

/******************************************************
**
** PinTransmitter::PinTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
PinTransmitter::PinTransmitter() : DataTransmitter(),
	m_UartFilter(INVALID_HANDLE_VALUE),
	m_MidiPin(INVALID_HANDLE_VALUE),
	m_MidiOutEvent(INVALID_HANDLE_VALUE)
{
}

/******************************************************
**
** PinTransmitter::~PinTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
PinTransmitter::~PinTransmitter()
{
	// Close the send event
	if (IsHandleValid(m_MidiOutEvent)) {
		::CloseHandle(m_MidiOutEvent);
		m_MidiOutEvent = NULL;
	}

	// Close the pin
	if (IsHandleValid(m_MidiPin)) {
		::CloseHandle(m_MidiPin);
		m_MidiPin = INVALID_HANDLE_VALUE;
	}

	// Close the Uart
	if (IsHandleValid(m_UartFilter)) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** PinTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL PinTransmitter::Initialize()
{
	// Load the ksUserLibrary and grab the create pin function
	HINSTANCE ksUserLib = ::LoadLibrary(TEXT("KsUser.dll"));
	if (ksUserLib == NULL) {
		return FALSE;
	}
	KSCREATEPIN pfCreatePin = (KSCREATEPIN)::GetProcAddress(ksUserLib, TEXT("KsCreatePin"));
	if (pfCreatePin == NULL) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Open the Uart
	m_UartFilter = ::CreateFile(UART_FILTER_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (m_UartFilter == INVALID_HANDLE_VALUE) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Create Overlapped event
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	// Get the number of pins
	KSP_PIN ksPinProp;
	::memset(&ksPinProp, 0, sizeof(ksPinProp));
	ksPinProp.Property.Set = KSPROPSETID_Pin;
	ksPinProp.Property.Id = KSPROPERTY_PIN_CTYPES;
	ksPinProp.Property.Flags = KSPROPERTY_TYPE_GET;
	DWORD numPins = 0;
	OverLappedPinIOCTL(overlapped, ksPinProp, &numPins, sizeof(numPins));

	// Check each pin for proper type, then try to create
	BOOL wasCreated = FALSE;
	for (UINT pinNum = 0; (pinNum < numPins) && (wasCreated == FALSE); pinNum++) {
		ksPinProp.PinId = pinNum;
		ksPinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
		KSPIN_DATAFLOW dataFlow = (KSPIN_DATAFLOW)0;
		if (OverLappedPinIOCTL(overlapped, ksPinProp, &dataFlow, sizeof(dataFlow)) == TRUE) {
			if (dataFlow == KSPIN_DATAFLOW_IN) {
				ksPinProp.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
				KSPIN_COMMUNICATION communication = KSPIN_COMMUNICATION_NONE;
				if (OverLappedPinIOCTL(overlapped, ksPinProp, &communication, sizeof(communication)) == TRUE) {
					if ((communication == KSPIN_COMMUNICATION_SINK) || (communication == KSPIN_COMMUNICATION_BOTH)) {
						wasCreated = CreatePinInstance(pinNum, pfCreatePin);
					}
				}
			}
		}
	}
	::FreeLibrary(ksUserLib);
	::CloseHandle(overlapped.hEvent);
	if (wasCreated == FALSE) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
		return FALSE;
	}
	return TRUE;
}

/******************************************************
**
** PinTransmitter::OverLappedPinIOCTL()
**
** returns: TRUE if able to proform Pin Property IOCTL
** @mfunc OverLappedPinIOCTL.
******************************************************/
BOOL PinTransmitter::OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize)
{
	// IOCTL the Property
	if (::DeviceIoControl(m_UartFilter, IOCTL_KS_PROPERTY, &ksPinProp, sizeof(ksPinProp), pData, dataSize, NULL, &overlapped) == TRUE) {
		return TRUE;
	}

	// Failed IOCTL check if more time is needed
	if (::GetLastError() != ERROR_IO_PENDING) {
		return FALSE;
	}

	// Do wait
	if (::WaitForSingleObject(overlapped.hEvent, 3000) == WAIT_OBJECT_0) {
		return TRUE;	// Waiting paid off
	}
	return FALSE;	// Grew tired of waiting
}

/******************************************************
**
** PinTransmitter::CreatePinInstance()
**
** returns: TRUE if able to create the requested pin instance
** @mfunc CreatePinInstance.
******************************************************/
BOOL PinTransmitter::CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin)
{
	// Set the pin format
	KSDATAFORMAT ksDataFormat;
	::memset(&ksDataFormat, 0, sizeof(ksDataFormat));
	ksDataFormat.FormatSize = sizeof(ksDataFormat);
	ksDataFormat.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
	ksDataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
	ksDataFormat.Specifier = KSDATAFORMAT_SPECIFIER_NONE;

	// Set the pin connection information
	KSPIN_CONNECT* pConnectionInfo = (KSPIN_CONNECT*) new BYTE[sizeof(KSPIN_CONNECT) + sizeof(ksDataFormat)];
	::memset(pConnectionInfo, 0, sizeof(KSPIN_CONNECT));
	pConnectionInfo->Interface.Set = KSINTERFACESETID_Standard;
	pConnectionInfo->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
	pConnectionInfo->Medium.Set = KSMEDIUMSETID_Standard;
	pConnectionInfo->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
	pConnectionInfo->PinId = pinNumber;
	pConnectionInfo->Priority.PriorityClass = KSPRIORITY_NORMAL;
	pConnectionInfo->Priority.PrioritySubClass  = 1;
	::memcpy(pConnectionInfo + 1, &ksDataFormat, sizeof(ksDataFormat));

	DWORD status = pfCreatePin(m_UartFilter, pConnectionInfo, FILE_WRITE_ACCESS, &m_MidiPin);
	delete[] pConnectionInfo;
	if (status != NO_ERROR) {
#ifdef _DEBUG
		TCHAR buff[256];
		wsprintf(buff, TEXT("Error Creating Pin: 0x%08X\r\n"), status);
		_RPT0(_CRT_WARN, buff);
#endif
		return FALSE;
	}

	SetPinState(KSSTATE_PAUSE);

	return TRUE;
}

/******************************************************
**
** PinTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL PinTransmitter::Send(BYTE* pData, UINT numBytes)
{
	if (!IsHandleValid(m_MidiPin)) {
		return FALSE;
	}

	BYTE musicData[c_LongMsgMax + sizeof(KSMUSICFORMAT)];
	::memset(musicData, 0, sizeof(musicData));
	((KSMUSICFORMAT*)musicData)->ByteCount = numBytes;
	::memcpy(((KSMUSICFORMAT*)musicData) + 1, pData, numBytes);

	KSSTREAM_HEADER ksStreamHeader;
	::memset(&ksStreamHeader, 0, sizeof(ksStreamHeader));
	ksStreamHeader.Size = sizeof(ksStreamHeader);
	ksStreamHeader.PresentationTime.Numerator = 1;
	ksStreamHeader.PresentationTime.Denominator = 1;
	ksStreamHeader.FrameExtent = sizeof(musicData);
	ksStreamHeader.DataUsed = sizeof KSMUSICFORMAT + numBytes;
	ksStreamHeader.Data = (void*)musicData;

	if (!IsHandleValid(m_MidiOutEvent)) {
		m_MidiOutEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = m_MidiOutEvent;


	SetPinState(KSSTATE_RUN);
	if (!DeviceIoControl(m_MidiPin, IOCTL_KS_WRITE_STREAM, NULL, 0,
							&ksStreamHeader, sizeof(ksStreamHeader), NULL, &overlapped)) {
		if (GetLastError() == ERROR_IO_PENDING) {
			::WaitForSingleObject(overlapped.hEvent, 3000);
		}
	}
	SetPinState(KSSTATE_PAUSE);
	return TRUE;
}

/******************************************************
**
** PinTransmitter::SetPinState()
**
** returns: Nothing
** @mfunc SetPinState.
**
******************************************************/
void PinTransmitter::SetPinState(KSSTATE state)
{
	if (!IsHandleValid(m_MidiPin)) {
		return;
	}

	KSPROPERTY ksProperty;
	::memset(&ksProperty, 0, sizeof(ksProperty));
	ksProperty.Set = KSPROPSETID_Connection;
	ksProperty.Id = KSPROPERTY_CONNECTION_STATE;
	ksProperty.Flags = KSPROPERTY_TYPE_SET;

	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (IsHandleValid(overlapped.hEvent)) {
		if( !DeviceIoControl(m_MidiPin, IOCTL_KS_PROPERTY, &ksProperty, sizeof ksProperty, &state, sizeof state, NULL, &overlapped )) {
			if (GetLastError() == ERROR_IO_PENDING) {
				WaitForSingleObject(overlapped.hEvent, 30000);
			}
		}
		::CloseHandle(overlapped.hEvent);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dpack.h ===
//@doc
/******************************************************
**
** @module DPACK.H | Definition file for DataPackager and DataPacket
**
** Description:
**		The Data Packager allows virtualization of the
**	commands into the different firmware versions packet format
**		DataPackager - Base class that defines the functionality of all DataPackagers
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**
** Classes:
**		DataPackager
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**		DataPacket - Array of bytes for download. If there are 32 or less items
**				it is fixed on the stack if more are requested it is heap based.
**				(most things use less than 32)
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DPACK_H__
#define	__DPACK_H__

#include "DX_Map.hpp"

#ifndef override
#define override
#endif

#define MODIFY_CMD_200	0xF1
#define EFFECT_CMD_200	0xF2

class InternalEffect;

//
// @class DataPacket class
//
class DataPacket
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPacket();
		~DataPacket();

		BOOL AllocateBytes(DWORD numBytes);

		BYTE* m_pData;
		BYTE m_pFixedData[32];
		DWORD m_BytesOfData;
		UINT m_AckNackMethod;
		DWORD m_AckNackDelay;
		DWORD m_AckNackTimeout;
		DWORD m_NumberOfRetries;
};
typedef DataPacket* DataPacketPtr;

//
// @class DataPackager class
//
class DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager();
		virtual ~DataPackager();

		void SetDirectInputVersion(DWORD diVersion) { m_DirectInputVersion = diVersion; }

		// Commands to be packaged
		virtual HRESULT Escape(DWORD effectID, LPDIEFFESCAPE pEscape);
		virtual HRESULT SetGain(DWORD gain);
		virtual HRESULT SendForceFeedbackCommand(DWORD state);
		virtual HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		virtual HRESULT CreateEffect(const InternalEffect& effect, DWORD diFlags);
		virtual HRESULT ModifyEffect(InternalEffect& currentEffect, InternalEffect& newEffect, DWORD modFlags);
		virtual HRESULT DestroyEffect(DWORD downloadID);
		virtual HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		virtual HRESULT StopEffect(DWORD downloadID);
		virtual HRESULT GetEffectStatus(DWORD downloadID);
		virtual HRESULT SetMidiChannel(BYTE channel);
		virtual HRESULT ForceOut(LONG lForceData, ULONG ulAxisMask);

		// Access to packages
		USHORT GetNumDataPackets() const { return m_NumDataPackets; }
		DataPacket* GetPacket(USHORT packet) const;

		void ClearPackets();
		BOOL AllocateDataPackets(USHORT numPackets);
	private:
		DataPacket* m_pDataPackets;
		DataPacket m_pStaticPackets[3];
		USHORT m_NumDataPackets;
		DWORD m_DirectInputVersion;
};

//
// @class DataPackager class
//
class DataPackager100 : public DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager100() : DataPackager() {};

		// Commands to be packaged
		override HRESULT SetGain(DWORD gain);
		override HRESULT SendForceFeedbackCommand(DWORD state);
		override HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		override HRESULT DestroyEffect(DWORD downloadID);
		override HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		override HRESULT StopEffect(DWORD downloadID);
		override HRESULT GetEffectStatus(DWORD downloadID);
		override HRESULT SetMidiChannel(BYTE channel);
		override HRESULT ForceOut(LONG lForceData, ULONG ulAxisMask);
};

//
// @class DataPackager class
//
class DataPackager200 : public DataPackager
{
	//@access Constructor
	public:
		//@cmember constructor
		DataPackager200() : DataPackager() {};

		// Commands to be packaged
		override HRESULT SetGain(DWORD gain);
		override HRESULT SendForceFeedbackCommand(DWORD state);
		override HRESULT GetForceFeedbackState(DIDEVICESTATE* pDeviceState);
		override HRESULT CreateEffect(const InternalEffect& effect, DWORD diFlags);
		override HRESULT DestroyEffect(DWORD downloadID);
		override HRESULT StartEffect(DWORD downloadID, DWORD mode, DWORD count);
		override HRESULT StopEffect(DWORD downloadID);
		override HRESULT GetEffectStatus(DWORD downloadID);
		override HRESULT ForceOut(LONG forceData, ULONG axisMask);
	private:
		BYTE EffectCommandParity(const DataPacket& packet) const;
		BYTE DeviceCommandParity(const DataPacket& packet) const;
};

extern DataPackager* g_pDataPackager;

#endif	__DPACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\critsec.h ===
//@doc
/******************************************************
**
** @module CRITSEC.H | Header file for CriticalSection class
**
** Description:
**		Critical Section - Encapsulation of CriticalSection object
**
** History:
**	Created 03/02/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__CRITSEC_H__
#define	__CRITSEC_H__

#include <winbase.h>
#include <winuser.h>
#include <crtdbg.h>

// Assumption macros (I don't like asserts msg boxes)
#ifdef _DEBUG
	inline void myassume(BOOL condition, const char* fname, int line)
	{
		if (!condition) {
			char buff[256];
			::wsprintf(buff, "SW_WHEEL.DLL: Assumption Failed in %s on line %d\r\n", fname, line);
			_RPT0(_CRT_WARN, buff);
		}
	}

	#define ASSUME(x) myassume(x, __FILE__, __LINE__);
	#define ASSUME_NOT_NULL(x) myassume(x != NULL, __FILE__, __LINE__);
	#define ASSUME_NOT_REACHED() myassume(FALSE, __FILE__, __LINE__);
#else	!_DEBUG
	#define ASSUME(x)
	#define ASSUME_NOT_NULL(x)
	#define ASSUME_NOT_REACHED()
#endif _DEBUG

//
// @class CriticalSection class
//
class CriticalSection
{
	public:
		CriticalSection() : m_EntryDepth(0)
		{
			__try
			{
				::InitializeCriticalSection(&m_OSCriticalSection); 
				m_Initialized = TRUE;
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				m_Initialized = FALSE;
			}
		}
		~CriticalSection() {
			ASSUME(m_EntryDepth == 0);
			::DeleteCriticalSection(&m_OSCriticalSection);
		}

		bool IsInitialized() const
		{
			if (m_Initialized == TRUE)
			{
				return true;
			}
			return false;
		}

		bool Enter() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			m_EntryDepth++;
			::EnterCriticalSection(&m_OSCriticalSection);
			return true;
		}

		bool Leave() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			ASSUME(m_EntryDepth > 0);
			m_EntryDepth--;
			::LeaveCriticalSection(&m_OSCriticalSection);
			return true;
		}

/*	-- Windows NT Only
		BOOL TryEntry() {
			if (::TryEnterCriticalSection(&m_OSCriticalSection) != 0) {
				m_EntryDepth++;
				return TRUE;
			}
			return FALSE;
		}

		BOOL WaitEntry(short timeOut, BOOL doSleep) {
			// right now timeout is just a loop (since it is not being used anyways)
			while(1) {
				if (TryEntry()) { return TRUE; }
				if (--timeOut > 0) {
					if (doSleep) { ::Sleep(0); }
				} else {
					return FALSE;
				}
			}
		}
 -- Windows NT Only */
	private:
		CriticalSection& operator=(CriticalSection& rhs);	// Cannot be copied

		CRITICAL_SECTION m_OSCriticalSection;
		short m_EntryDepth;
		short m_Initialized;
};
extern CriticalSection g_CriticalSection;

//
// @class CriticalLock class
//
// Critical lock is usefor functions with multiple-exit points. Create a stack CriticalLock
// -- object and everything is taken care of for you when it's lifetime ends.
class CriticalLock
{
	public:
		CriticalLock() { g_CriticalSection.Enter(); }
		~CriticalLock() { g_CriticalSection.Leave(); }
};

#endif	__CRITSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\vxdioctl.cpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.CPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for communicating with VJoyD min-driver specific
    				to Jolt Midi device
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				17-Jun-97	MEA		Added MAX_RETRY_COUNT on IOCTLs
				20-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				20-Mar-99	waltw	Nuked unused IsHandleValid

****************************************************************************/

#include "vxdioctl.hpp"
//#include <crtdbg.h>			// For RPT macros
#include <WINIOCTL.H>		// For IOCTL definitions (CTL_CODE)
#include "FFDevice.h"		// For g_ForceFeedbackDevice
#include "sw_error.hpp"		// For Sidewinder HRESULT Error codes
#include "hau_midi.hpp"		// For MAX_RETRY_COUNT and others
#include "midi_obj.hpp"		// Global Jolt midi object and definition
#include "JoyRegst.hpp"		// The differnt types of ACK_NACK
#include "DTrans.h"			// For global Data Transmitter

DriverCommunicator* g_pDriverCommunicator = NULL;
extern DataTransmitter* g_pDataTransmitter;
extern HINSTANCE g_MyInstance;


// Bitmasks for FW Version 
#define FW_MAJOR_VERSION			0x40		// Bit 6
#define FW_MINOR_VERSION			0x3F		// Bit 5-0
#define FW_PRODUCT_ID				0xff

// Bitmasks for Get Status packet dwDeviceStatus member
#define ERROR_STATUS_MASK			0x07		// only bits 0-2 valid


/********************************** HIDFeatureCommunicator class ***********************************/

/****************************************
**
**	HIDFeatureCommunicator::HIDFeatureCommunicator()
**
**	@mfunc Constructor for VxD Communications path
**
*****************************************/
HIDFeatureCommunicator::HIDFeatureCommunicator() :
	DriverCommunicator(),
	m_ForceFeature()
{
}

/****************************************
**
**	HIDFeatureCommunicator::~HIDFeatureCommunicator()
**
**	@mfunc Destructor for VxD communications path
**
*****************************************/
HIDFeatureCommunicator::~HIDFeatureCommunicator()
{
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::Initialize(UINT uJoystickId)
**
**	@mfunc Opens the driver for communications via IOCTLs
**
**	@rdesc TRUE if driver opened, FALSE otherwise
**
*****************************************/
BOOL HIDFeatureCommunicator::Initialize
(
	UINT uJoystickId //@parm Joystick ID to use
)
{
	if (g_ForceFeedbackDevice.IsOSNT5() == FALSE)
	{	// Only allowable on NT5
		return FALSE;
	}

	return (SUCCEEDED(m_ForceFeature.Initialize(uJoystickId, g_MyInstance)));
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::ResetDevice()
**
**	@mfunc Sends the driver a device reset IOCTL
**
**	@rdesc S_OK if IOCTL suceeds, 
**
*****************************************/
HRESULT HIDFeatureCommunicator::ResetDevice()
{
	return m_ForceFeature.DoReset();
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor)
**
**	@mfunc IOCTLs a version request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetDriverVersion
(
	DWORD& rdwMajor,	//@parm reference to returned major part of version
	DWORD& rdwMinor		//@parm reference to returned minor part of version
)
{
	ULONG ulVersion = m_ForceFeature.GetVersion();
	rdwMajor = (ulVersion >> 16) & 0x0000FFFF;
	rdwMinor = ulVersion & 0x0000FFFF;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetID(LOCAL_PRODUCT_ID& rProductID)
**
**	@mfunc IOCTLs a product id request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetID
(
	LOCAL_PRODUCT_ID& rProductID	//@parm reference to local product id structure for return value
)
{
	if (rProductID.cBytes != sizeof LOCAL_PRODUCT_ID)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Create report packet and request
	PRODUCT_ID_REPORT productIDReport;
	productIDReport.ProductId.cBytes = sizeof PRODUCT_ID;
	HRESULT hr = m_ForceFeature.GetId(productIDReport);
	if (FAILED(hr))
	{	// There was a problem
		return hr;
	}

	// Decode to local packet
	rProductID.dwProductID = productIDReport.ProductId.dwProductID & FW_PRODUCT_ID;
	rProductID.dwFWMajVersion = 1;
	if (productIDReport.ProductId.dwFWVersion & FW_MAJOR_VERSION)
	{
		rProductID.dwFWMajVersion++;
	}
	rProductID.dwFWMinVersion = productIDReport.ProductId.dwFWVersion & FW_MINOR_VERSION;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatus(JOYCHANNELSTATUS& rChannelStatus)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatus
(
	JOYCHANNELSTATUS& rChannelStatus	//@parm reference to status packet for result
)
{
	if (rChannelStatus.cBytes != sizeof JOYCHANNELSTATUS)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create report packet and perform request
	JOYCHANNELSTATUS_REPORT statusReport;
	statusReport.JoyChannelStatus.cBytes = sizeof JOYCHANNELSTATUS;

	HRESULT hr = S_OK;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		hr = m_ForceFeature.GetStatus(statusReport);

		if (FAILED(hr))
		{	// There was a problem
			if (i > 5)
			{
				Sleep(1);
			}
		}
		else
		{
			break;
		}
	}

	if (SUCCEEDED(hr))
	{	// Get the data from report packet
		::memcpy(&rChannelStatus, &(statusReport.JoyChannelStatus), sizeof JOYCHANNELSTATUS);
	}
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetAckNack
(
	ACKNACK& rAckNack,	//@parm Structure for return of acking
	USHORT usRegIndex	//@parm Index to what type of ack/nack to do
)
{
	if (rAckNack.cBytes != sizeof ACKNACK)
	{	// Invalid structure size
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Determine how to get the result
	switch (g_ForceFeedbackDevice.GetAckNackMethod(usRegIndex))
	{
		case ACKNACK_NOTHING:
		{	// This one is real easy - do nothing
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		case ACKNACK_BUTTONSTATUS:
		{	// Look at the button status (status gate)
			ULONG_REPORT report;
			HRESULT hr = m_ForceFeature.GetAckNak(report);
			if (FAILED(hr))
			{	// There was a problem
				return hr;
			}

			if (report.uLong & ACKNACK_MASK_200)
			{ // NACK error, so get Error code
				rAckNack.dwAckNack = NACK;
				JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
				if (FAILED(hr = GetStatus(statusPacket)))
				{	// Failed to get status error
					return hr;
				}
				rAckNack.dwErrorCode = (statusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return S_OK;
			}
			// ACK success
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;

			if (report.uLong & RUNNING_MASK_200)
			{	// Current driver and effect running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			}
			else
			{	// Effect not running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return S_OK;
		}
		case ACKNACK_STATUSPACKET:
		{	// Use the Status Packet Error code field to determine ACK or NACK and Get Error code
			JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
 
			HRESULT hr = GetStatus(statusPacket);
			if (FAILED(hr))
			{	// Failed (retried inside GetStatus)
				return SFERR_DRIVER_ERROR;
			}
			rAckNack.dwErrorCode = statusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
			rAckNack.dwAckNack = (rAckNack.dwErrorCode) ? NACK : ACK;
			return S_OK;
		}
		default:
		{	// Someone put garbage in the registry (do nothing)
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		
	}

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatusGateData(DWORD& rdwGateData)
**
**	@mfunc IOCTLs a status gate request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatusGateData
(
	DWORD& rdwGateData	//@parm reference to return gate data
)
{
	ULONG_REPORT report;
	HRESULT hr = m_ForceFeature.GetAckNak(report);
	rdwGateData = report.uLong;
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::SendBackdoorShortMidi(DWORD dwMidiMessage)
**
**	@mfunc IOCTLs a request sending a message through midi backdoor
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::SendBackdoorShortMidi
(
	DWORD dwMidiMessage	//@parm Midi Channel Message to send via IOCTL
)
{
	// Byte count
	short int sByteCount = 3;
	BYTE bCmd = BYTE(dwMidiMessage & 0xF0);
	if ((bCmd == 0xC0 ) || (bCmd == 0xD0)) {
		sByteCount = 2;
	}

	// Send via data transmitter
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send((BYTE*)(&dwMidiMessage), sByteCount)) {
			return S_OK;
		}
        return SFERR_DRIVER_ERROR;
	}

	// Must use the data transmitter there is no backdoor in NT5
	return E_FAIL;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::SendBackdoorLongMidi(BYTE* pMidiData)
**
**	@mfunc IOCTLs a request sending a message through midi backdoor
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::SendBackdoorLongMidi
(
	BYTE* pMidiData	//@parm Array of bytes to send out
)
{
	// Count the bytes
	short int sByteCount = 1;
	while (!(pMidiData[sByteCount++] & 0x80));

	// Send via data transmitter?
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send(pMidiData, sByteCount)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// There is no real backdoor in NT
	return E_FAIL;
}

/********************************** Old dead code ***********************************/
#if 0
#include <windows.h>

#include <WINIOCTL.H>

#include "vxdioctl.hpp"
#include "SW_error.hpp"
#include "version.h"
#include "hau_midi.hpp"
#include "midi_obj.hpp"

#include "DTrans.h"
#include "FFDevice.h"
#include "joyregst.hpp"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

#ifdef _DEBUG
extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
#define DebugOut(x)
#endif _DEBUG


extern DataTransmitter* g_pDataTransmitter;
DWORD g_PreviousShortMidi = 0;

class CJoltMidi;
extern CJoltMidi *g_pJoltMidi;

//
// --- IOCTL Functions
//
/****************************************************************************

    FUNCTION:   GetDevice

	PARAMETERS:	IN const char* vxdName	- Name of VxD

	RETURNS:	valid HANDLE if successful or NULL

   	COMMENTS:	

****************************************************************************/
HANDLE WINAPI GetDevice(
	IN const char* vxdName)
{
	char fileName[64];
	HANDLE retVal;

	if (g_ForceFeedbackDevice.IsOSNT5()) { // Need to start MSGameIO
		try {
			// Open the Service Control Managere
			SC_HANDLE serviceControlManager = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (serviceControlManager == NULL) {
				throw 0;
			}
			// Open the Service
			SC_HANDLE ring0DriverService = ::OpenService(serviceControlManager, vxdName, SERVICE_QUERY_STATUS | SERVICE_START);
			if (ring0DriverService == NULL) {
				throw 0;
			}
			// Start for service
			if (!::StartService(ring0DriverService, 0, NULL)) {
				throw 0;
			}
			// Did it start yet - Do some fancy waiting
			SERVICE_STATUS serviceStatus;
			DWORD lastCheckPoint = 0;
			do {
				if (!::QueryServiceStatus(ring0DriverService, &serviceStatus)) {
					throw 0;
				}
				if (serviceStatus.dwCurrentState == SERVICE_START_PENDING) {
					if (serviceStatus.dwCheckPoint <= lastCheckPoint) {
						DebugOut("Failed to start service\r\n");
						break;	
					}
					lastCheckPoint = serviceStatus.dwCheckPoint;
					::Sleep(serviceStatus.dwWaitHint);
				} else {
					DebugOut("Service Started (maybe), Yeah!\r\n");
					break;
				}
			} while (1);
			::CloseServiceHandle(ring0DriverService);		// Close the Ring0 Handle
			::CloseServiceHandle(serviceControlManager);	// Close the service control manager handle
		} catch(...) {
			DWORD errorCode = ::GetLastError();
			if (errorCode == ERROR_ACCESS_DENIED) {	// We are screwed
				DebugOut("Access is denied\r\n");
			} else {
				DebugOut("Unable to start service\r\n");
			}
		}
	}


	wsprintf(fileName, "\\\\.\\%s", vxdName);
	retVal = CreateFile(fileName, GENERIC_READ | GENERIC_WRITE,
		0, 0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
#ifdef _DEBUG
	wsprintf(g_cMsg, "GetDevice: %s -- Vxd Handle: 0x%X\r\n", vxdName, retVal);
	OutputDebugString(g_cMsg);
#endif
	return retVal;
}

/****************************************************************************

    FUNCTION:   CloseDevice

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle

	RETURNS:	BOOL TRUE if successful else FALSE

   	COMMENTS:	

****************************************************************************/
BOOL WINAPI CloseDevice(
	IN HANDLE hVxD)
{
	if (hVxD != INVALID_HANDLE_VALUE)
		return (CloseHandle(hVxD));
	return FALSE;
}


/****************************************************************************

    FUNCTION:   QueryDriverVersion

	PARAMETERS:	DWORD& major, DWORD& minor - Major and Minor parts of driver version

	RETURNS:	BOOL TRUE if successful else FALSE

   	COMMENTS:	

****************************************************************************/
HRESULT QueryDriverVersion(DWORD& major, DWORD& minor)
{
	if ((g_pJoltMidi == NULL) || (g_pJoltMidi->VxDHandleOf() == INVALID_HANDLE_VALUE)) {
		return SFERR_DRIVER_ERROR;
	}

	DWORD version = 0x00000000;
	DWORD bytesReturned = 0;
//	HRESULT hr = DeviceIoControl(g_pJoltMidi->VxDHandleOf(), DIOC_GETVERSION, NULL, 0, &version, 4, &bytesReturned, NULL);
	if (::DeviceIoControl(g_pJoltMidi->VxDHandleOf(), IOCTL_GET_VERSION, NULL, 0, &version, 4, &bytesReturned, NULL)) {
		major = (version >> 16) & 0x0000FFFF;
		minor = version & 0x0000FFFF;
	}
	return S_OK;
}


/****************************************************************************

    FUNCTION:   GetDataPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PJOYCHANNELDATA pDataPacket	- Pointer to JOYCHANNELDATA
									structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	No longer a valid IOCTL (mlc)

****************************************************************************/
HRESULT WINAPI GetDataPacket(
	IN HANDLE hDevice,
	IN OUT PJOYCHANNELDATA pDataPacket)
{
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   GetStatusPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PJOYCHANNELSTATUS pStatusPacket	- Pointer to
									JOYCHANNELSTATUS structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetStatusPacket(
	IN HANDLE hDevice, 
	IN OUT PJOYCHANNELSTATUS pStatusPacket)
{
	DWORD   dwBytesReturned;

	if (INVALID_HANDLE_VALUE == hDevice) {
		return SFERR_DRIVER_ERROR;
	}

	if (pStatusPacket->cBytes != sizeof(JOYCHANNELSTATUS)) {
		return (SFERR_INVALID_STRUCT_SIZE);
	}

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETSTATUS : IOCTL_GET_STATUSPACKET;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		// Send the IOCTL
		BOOL bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
                               (LPVOID) pStatusPacket,
                               (DWORD)  sizeof(JOYCHANNELSTATUS),
                               (LPVOID) pStatusPacket,
                               (DWORD)  sizeof(JOYCHANNELSTATUS),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 


		if (bRetFlag) {
			// Convert values to a signed LONG
			pStatusPacket->dwXVel = (LONG)((char)(pStatusPacket->dwXVel));
			pStatusPacket->dwYVel = (LONG)((char)(pStatusPacket->dwYVel));
			pStatusPacket->dwXAccel = (LONG)((char)(pStatusPacket->dwXAccel));
			pStatusPacket->dwXAccel = (LONG)((char)(pStatusPacket->dwYAccel));
			return SUCCESS;
		}
		if(i>5) {
			Sleep(1);
		}

	}
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   GetIDPacket

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PPRODUCT_ID pID	- Pointer to PRODUCT_ID structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetIDPacket(
	IN HANDLE hDevice, 
	IN OUT PPRODUCT_ID pID)
{
	DWORD   dwBytesReturned;

	if (INVALID_HANDLE_VALUE == hDevice)
		return SFERR_DRIVER_ERROR;

	if (pID->cBytes != sizeof(PRODUCT_ID))
		return (SFERR_INVALID_STRUCT_SIZE);

	JOYCHANNELID IDPacket = {sizeof(JOYCHANNELID)};

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETID : IOCTL_GET_IDPACKET;
	for (int i=0; i<MAX_RETRY_COUNT; i++)
	{
		// Send the IOCTL
		BOOL bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
								(LPVOID) &IDPacket,
								(DWORD)  sizeof(JOYCHANNELID),
								(LPVOID) &IDPacket,
								(DWORD)  sizeof(JOYCHANNELID),
								(LPDWORD)  &dwBytesReturned,
								(LPOVERLAPPED) NULL); 

		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetIDPacketDelay);	

		// Any error codes are returned in the first DWORD of the structure
		if (bRetFlag) {
			pID->dwProductID = IDPacket.dwProductID & FW_PRODUCT_ID;
			pID->dwFWMajVersion = 1;
			if (IDPacket.dwFWVersion & FW_MAJOR_VERSION) 
				pID->dwFWMajVersion++;
			pID->dwFWMinVersion = IDPacket.dwFWVersion & FW_MINOR_VERSION;
			return SUCCESS;
		}                                          
	}
	return SFERR_DRIVER_ERROR;
}

/****************************************************************************

    FUNCTION:   GetDiagnostics

	PARAMETERS:	IN HANDLE hVxD -	valid VxD Handle
				IN OUT PDIAGNOSTIC_COUNTER pDiagnostics	- Pointer to
									DIAGNOSTIC_COUNTER structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetDiagnostics(
	IN HANDLE hDevice, 
	IN OUT PDIAGNOSTIC_COUNTER pDiagnostics)
{
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	if (pDiagnostics->cBytes != sizeof(DIAGNOSTIC_COUNTER))
		return (SFERR_INVALID_STRUCT_SIZE);

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
                               (DWORD)  IOCTL_GET_DIAGNOSTICS,
                               (LPVOID) pDiagnostics,
                               (DWORD)  sizeof(DIAGNOSTIC_COUNTER),
                               (LPVOID) pDiagnostics,
                               (DWORD)  sizeof(DIAGNOSTIC_COUNTER),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 
    // Any error codes are returned in the first DWORD of the structure
    if (!bRetFlag || (dwBytesReturned != sizeof(DIAGNOSTIC_COUNTER)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);
}


/****************************************************************************

    FUNCTION:   GetAckNack

	PARAMETERS:	IN HANDLE hVxD 				-	valid VxD Handle
				IN OUT PACKNACK pAckNack	- Pointer to ACKNACK structure

	RETURNS:	SUCCESS or error code

   	COMMENTS:	
	typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

****************************************************************************/
HRESULT WINAPI GetAckNack(
	IN HANDLE hDevice,
	IN OUT PACKNACK pAckNack,
	IN USHORT regindex)
{
	if (INVALID_HANDLE_VALUE == hDevice) {
		return SFERR_DRIVER_ERROR;
	}

	if (pAckNack->cBytes != sizeof(ACKNACK)) {
		return SFERR_INVALID_STRUCT_SIZE;
	}

	switch (g_ForceFeedbackDevice.GetAckNackMethod(regindex)) {
		case ACKNACK_NOTHING: {
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;
			return SUCCESS;
		}
		case ACKNACK_BUTTONSTATUS: {
			DWORD   dwBytesReturned;
			BOOL    bRetFlag;
			DWORD	dwIn;

			DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETACKNACK : IOCTL_GET_ACKNACK;

			// Send the IOCTL
			bRetFlag = DeviceIoControl(hDevice,
										ioctlID,
									   (LPVOID) &dwIn,
									   (DWORD)  sizeof(DWORD),
									   (LPVOID) &dwIn,
									   (DWORD)  sizeof(DWORD),
									   (LPDWORD)  &dwBytesReturned,
									   (LPOVERLAPPED) NULL); 
  
			if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) ) {
				return (SFERR_DRIVER_ERROR);
			}                                          

			if (((g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (dwIn & ACKNACK_MASK_1XX))
					|| ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & ACKNACK_MASK_200))) { // NACK error, so get Error code
				pAckNack->dwAckNack = NACK;
				JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};
				if (FAILED(GetStatusPacket(hDevice, &StatusPacket))) {
					return (SFERR_DRIVER_ERROR);
				}
				pAckNack->dwErrorCode = (StatusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return SUCCESS;
			}
			// ACK success
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;

			if (((g_ForceFeedbackDevice.GetDriverVersionMajor() == 1) && (dwIn & RUNNING_MASK_1XX))
					|| ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & RUNNING_MASK_200))) {
				pAckNack->dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			} else {
				pAckNack->dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return SUCCESS;
		}
		case ACKNACK_STATUSPACKET: {
			// Use the Status Packet Error code field to determine ACK or NACK
			// Get Error code
			JOYCHANNELSTATUS StatusPacket = {sizeof(JOYCHANNELSTATUS)};
 
			HRESULT hRet = GetStatusPacket(hDevice, &StatusPacket);		// Retry count in GetStatusPacket function
			if (FAILED(hRet)) {
				DebugOut("GetStatusPacket Error\n");
				hRet = SFERR_DRIVER_ERROR;
			} else {
				pAckNack->dwErrorCode = StatusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
				pAckNack->dwAckNack = (pAckNack->dwErrorCode) ? NACK : ACK;
			}
			return hRet;
		}
		default: {	// Someone put garbage in the registry (do nothing)
			pAckNack->dwAckNack = ACK;
			pAckNack->dwErrorCode = 0;
			return SUCCESS;
		}
		
	}
}


/****************************************************************************

    FUNCTION:   GetStatusGateData

	PARAMETERS:	IN HANDLE hVxD 					- valid VxD Handle
				IN OUT DWORD *pdwStatusGateData	- Pointer to Status Gate

	RETURNS:	SUCCESS or error code

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI GetStatusGateData(
	IN HANDLE hDevice,
	IN OUT DWORD *pdwStatusGateData)
{
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	HRESULT hRet = SFERR_DRIVER_ERROR;
	if (INVALID_HANDLE_VALUE == hDevice)
		return (hRet);

	if (NULL == pdwStatusGateData)
		return (SFERR_INVALID_PARAM);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_GETACKNACK : IOCTL_GET_ACKNACK;
	for (int i=0; i<MAX_RETRY_COUNT; i++)
	{
		// Obtain Status Gate data
		// Send the IOCTL
		bRetFlag = DeviceIoControl(hDevice,
                               ioctlID,
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 

		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusGateDataDelay);	

  
		if (bRetFlag && (dwBytesReturned == sizeof(DWORD)))
		{
			hRet = SUCCESS;
			break;
		}                                          
	}

	*pdwStatusGateData = dwIn;
	return (hRet);
}


/****************************************************************************

    FUNCTION:   SendBackDoorShortMidi

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulData 	- DWORD to send
	RETURNS:	

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI SendBackDoorShortMidi(
	IN HANDLE hDevice,
	IN ULONG ulData)
{
#ifdef _DEBUG
//	wsprintf(g_cMsg, "SendBackDoorShortMidi Data=%.8lx\r\n", ulData);
//	OutputDebugString(g_cMsg);
#endif
	DWORD	dwIn;
	DWORD   bytesReturned;

	// Byte count
	int numBytes = 3;
	DWORD cmd = ulData & 0xF0;
	if ((cmd == 0xC0 ) || (cmd == 0xD0)) {
		numBytes = 2;
	}

	// Send via data transmitter
	if (g_pDataTransmitter != NULL) {
		g_PreviousShortMidi = ulData;
		if (g_pDataTransmitter->Send((BYTE*)(&ulData), numBytes)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// Is there a proper ring0 driver?
	if (INVALID_HANDLE_VALUE == hDevice) {
		return (SFERR_DRIVER_ERROR);
	}

	// Send via new single send IOCTL
	if (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) {
		if (DeviceIoControl(hDevice, IOCTL_SWFORCE_SENDDATA, (void*)&ulData, DWORD(numBytes),
									(void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
									(LPOVERLAPPED) NULL)) {
			if (bytesReturned == DWORD(numBytes)) {
				return SUCCESS;
			}
		}
    
		return SFERR_DRIVER_ERROR;
	}

	// Send the IOCTL the old way
    if (DeviceIoControl(hDevice, IOCTL_MIDISENDSHORTMSG, (void*)&ulData, sizeof(DWORD),
                               (void*)&dwIn, sizeof(DWORD), &bytesReturned,
                               (LPOVERLAPPED) NULL)) {
		if (bytesReturned == sizeof(DWORD)) {
				return (SUCCESS);

		}
	}
	return SFERR_DRIVER_ERROR;
}

/****************************************************************************

    FUNCTION:   SendBackDoorLongMidi

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulData 	- DWORD to send
	RETURNS:	

   	COMMENTS:	

****************************************************************************/
HRESULT WINAPI SendBackDoorLongMidi(
	IN HANDLE hDevice,
	IN PBYTE  pData)
{
#ifdef _VERBOSE
#pragma message("Compiling with VERBOSE mode")
#ifdef _DEBUG
	wsprintf(g_cMsg, "SendBackDoorLongMidi pData\n%.2x ", pData[0]);
	OutputDebugString(g_cMsg);
	int i=1;
	while(TRUE)
	{
		wsprintf(g_cMsg,"%.2x ", pData[i]);
		OutputDebugString(g_cMsg);
		if (pData[i] & 0x80) 
			break;
		else
			i++;
	}
	OutputDebugString("\n");
#endif

#endif
	DWORD	dwIn;
	DWORD   bytesReturned;

	// Count the bytes
	int numBytes = 1;
	while (!(pData[numBytes++] & 0x80));

	// Send via data transmitter?
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send(pData, numBytes)) {
			return (SUCCESS);
		}
        return (SFERR_DRIVER_ERROR);
	}

	// Is there a proper ring0 driver?
	if (INVALID_HANDLE_VALUE == hDevice) {
		return (SFERR_DRIVER_ERROR);
	}

	// Send via new single send IOCTL
	if (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) {
		if (DeviceIoControl(hDevice, IOCTL_SWFORCE_SENDDATA, (void*)pData, DWORD(numBytes),
									(void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
									(LPOVERLAPPED) NULL)) {
			if (bytesReturned == DWORD(numBytes)) {
				return SUCCESS;
			}
		}
    
		return SFERR_DRIVER_ERROR;
	}

	// Send the IOCTL the old way
    if (DeviceIoControl(hDevice, IOCTL_MIDISENDLONGMSG, (void*)pData, sizeof(DWORD),
                               (void*)&dwIn, sizeof(DWORD), (DWORD*)&bytesReturned,
                               (LPOVERLAPPED) NULL)) {
		if (bytesReturned == sizeof(DWORD)) {
			return SUCCESS;
		}
	}
	return SFERR_DRIVER_ERROR;
}


/****************************************************************************

    FUNCTION:   SetMidiPort

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd
				IN ULONG ulPort 	- Port #
	RETURNS:	

   	COMMENTS:	
				  0 = DEFAULT MIDI UART 330
				  1 = COM1
				  2 = COM2
				  3 = COM3
				  4 = COM4
				  or other MIDI port 340, etc...

****************************************************************************/
HRESULT WINAPI SetMidiPort(
	IN HANDLE hDevice,
	IN ULONG  ulPort)
{
	if (g_ForceFeedbackDevice.IsOSNT5()) {
		return SUCCESS;
	}

#ifdef _DEBUG
	wsprintf(g_cMsg, "SetMidiPort Port %lx\r\n", ulPort);
	OutputDebugString(g_cMsg);
#endif
	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_SETPORT : IOCTL_SET_MIDIPORT;

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
                               ioctlID,
                               (LPVOID) &ulPort,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL);
    
    if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);

}

/****************************************************************************

    FUNCTION:   JoltHWReset

	PARAMETERS:	IN HANDLE hDevice	- Handle to Vxd

	RETURNS:	

   	COMMENTS:	
				  Jolt is Reset (4 knocks)

****************************************************************************/
HRESULT WINAPI JoltHWReset(
	IN HANDLE hDevice)
{
#ifdef _DEBUG
	wsprintf(g_cMsg, "JoltHWReset\r\n");
	OutputDebugString(g_cMsg);
#endif

	DWORD   dwBytesReturned;
	BOOL    bRetFlag;
	DWORD	dwIn;

	if (INVALID_HANDLE_VALUE == hDevice)
		return (SFERR_DRIVER_ERROR);

	DWORD ioctlID = (g_ForceFeedbackDevice.GetDriverVersionMajor() > 1) ? IOCTL_SWFORCE_RESET : IOCTL_HW_RESET;

	// Send the IOCTL
    bRetFlag = DeviceIoControl(hDevice,
								ioctlID,
                               (LPVOID) NULL,
                               (DWORD)  sizeof(DWORD),
                               (LPVOID) &dwIn,
                               (DWORD)  sizeof(DWORD),
                               (LPDWORD)  &dwBytesReturned,
                               (LPOVERLAPPED) NULL); 
    
    if (!bRetFlag || (dwBytesReturned != sizeof(DWORD)) )
    {
        return (SFERR_DRIVER_ERROR);
    }                                          
	return (SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dpack.cpp ===
//@doc
/******************************************************
**
** @module DPACK.CPP | DataPackager implementation file
**
** Description:
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "DPack.h"
#include "FFDevice.h"
#include "Midi_Obj.hpp"
#include "joyregst.hpp"
#include "SW_Error.hpp"
#include "Hau_midi.hpp"
#include "CritSec.h"

DataPackager* g_pDataPackager = NULL;
extern CJoltMidi* g_pJoltMidi;

//
// --- MIDI Command codes 200
//
#define PLAYSOLO_OP_200		0x00
#define DESTROY_OP_200		0x01
#define PLAYSUPER_OP_200	0x02
#define STOP_OP_200			0x03
#define STATUS_OP_200		0x04
#define FORCEX_OP_200		0x06
#define FORCEY_OP_200		0x07

//#define MODIFY_CMD_200		0xF1  -- In Header
//#define EFFECT_CMD_200		0xF2  -- In Header
#define DEVICE_CMD_200		0xF3
#define SHUTDOWN_OP_200		0x01
#define ENABLE_OP_200		0x02
#define DISABLE_OP_200		0x03
#define PAUSE_OP_200		0x04
#define CONTINUE_OP_200		0x05
#define STOPALL_OP_200		0x06
#define KILLMIDI_OP_200		0x07

#define GAIN_SCALE_200		78.74
#define PERCENT_SHIFT		10000
#define PERCENT_TO_DEVICE	158

/************** DataPacket class ******************/
DataPacket::DataPacket() :
	m_BytesOfData(0),
	m_AckNackMethod(0),
	m_AckNackDelay(0),
	m_AckNackTimeout(0),
	m_NumberOfRetries(0)
{
	m_pData = m_pFixedData;
}

DataPacket::~DataPacket()
{
	if (m_pData != m_pFixedData) {
		delete[] m_pData;
	}
	m_pData = NULL;
	m_BytesOfData = 0;
}

BOOL DataPacket::AllocateBytes(DWORD numBytes)
{	
	if (m_pData != m_pFixedData) {
		delete[] m_pData;
	}
	if (numBytes <= 32) {
		m_pData = m_pFixedData;
	} else {
		m_pData = new BYTE[numBytes];
	}
	m_BytesOfData = numBytes;
	m_AckNackMethod = ACKNACK_NOTHING;
	m_AckNackDelay = 0;
	m_AckNackTimeout = 0;
	m_NumberOfRetries = 0;

	return (m_pData != NULL);
}


/************** DataPackeger class ******************/
DataPackager::DataPackager() :
	m_NumDataPackets(0),
	m_DirectInputVersion(0)
{
	m_pDataPackets = m_pStaticPackets;
}

DataPackager::~DataPackager()
{
	if (m_pDataPackets != m_pStaticPackets) {
		delete[] m_pDataPackets;
	}
	m_NumDataPackets = 0;
	m_pDataPackets = NULL;
}

HRESULT DataPackager::Escape(DWORD effectID, LPDIEFFESCAPE pEscape)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SetGain(DWORD gain)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SendForceFeedbackCommand(DWORD state)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::GetForceFeedbackState(DIDEVICESTATE* pDeviceState)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::CreateEffect(const InternalEffect& effect, DWORD diFlags)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* commandPacket = GetPacket(0);
	HRESULT hr = effect.FillCreatePacket(*commandPacket);
	if (FAILED(hr)) {
		ClearPackets();
	}
	return hr;
}

HRESULT DataPackager::ModifyEffect(InternalEffect& currentEffect, InternalEffect& newEffect, DWORD modFlags)
{
	return currentEffect.Modify(newEffect, modFlags);
}

HRESULT DataPackager::DestroyEffect(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::StopEffect(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::GetEffectStatus(DWORD downloadID)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::SetMidiChannel(BYTE channel)
{
	ClearPackets();
	return SUCCESS;
}

HRESULT DataPackager::ForceOut(LONG lForceData, ULONG ulAxisMask)
{
	ClearPackets();
	return SUCCESS;
}

DataPacket* DataPackager::GetPacket(USHORT packet) const
{
	if ((packet >= 0) && (packet < m_NumDataPackets)) {
		return (m_pDataPackets + packet);
	}
	return NULL;
}

BOOL DataPackager::AllocateDataPackets(USHORT numPackets)
{
	// Out with the old
	if (m_pDataPackets != m_pStaticPackets) {	// Allocated, need to deallocate
		delete[] m_pDataPackets;
	} else {	// Static, need to uninitialize
		for (int i = 0; i < m_NumDataPackets; i++) {
			m_pStaticPackets[i].AllocateBytes(0);
		}
	}

	// In with the new
	if (numPackets <= 3) {
		m_pDataPackets = m_pStaticPackets;
	} else {
		m_pDataPackets = new DataPacket[numPackets];
	}
	m_NumDataPackets = numPackets;

	return (m_pDataPackets != NULL);
}

void DataPackager::ClearPackets()
{
	if (m_pDataPackets != m_pStaticPackets) {	// Were allocated (deallocate)
		delete[] m_pDataPackets;
		m_pDataPackets = m_pStaticPackets;
	} else {	// Static, need to uninitialize
		for (int i = 0; i < m_NumDataPackets; i++) {
			m_pStaticPackets[i].AllocateBytes(0);
		}
	}
	m_NumDataPackets = 0;
}

/************** DataPackeger100 class ******************/

HRESULT DataPackager100::SetGain(DWORD gain)
{
	if (!AllocateDataPackets(2)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* setIndexPacket = GetPacket(0);
	if (!setIndexPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	setIndexPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	setIndexPacket->m_pData[1] = SET_INDEX | (BYTE) (INDEX15 << 2);
	setIndexPacket->m_pData[2] = SYSTEM_EFFECT_ID;
	setIndexPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	setIndexPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	// Packet to set modify data[index] of current effect
	DataPacket* modifyParamPacket = GetPacket(1);
	if (!modifyParamPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	modifyParamPacket->m_pData[0] = MODIFY_CMD | DEFAULT_MIDI_CHANNEL;
	gain /= SCALE_GAIN;
	gain *= DWORD(MAX_SCALE);
	modifyParamPacket->m_pData[1] = BYTE(gain & 0x7f);
	modifyParamPacket->m_pData[2] = (BYTE) ((gain >> 7) & 0x7f);
	modifyParamPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyParamPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager100::SendForceFeedbackCommand(DWORD state)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* commandPacket = GetPacket(0);
	if (!commandPacket->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	commandPacket->m_pData[0] = SYSTEM_CMD | DEFAULT_MIDI_CHANNEL;
	switch (state) {
		case DISFFC_SETACTUATORSON:
			commandPacket->m_pData[1] = SWDEV_FORCE_ON; break;
		case DISFFC_SETACTUATORSOFF:
			commandPacket->m_pData[1] = SWDEV_FORCE_OFF; break;
		case DISFFC_PAUSE:
			commandPacket->m_pData[1] = SWDEV_PAUSE; break;
		case DISFFC_CONTINUE:
			commandPacket->m_pData[1] = SWDEV_CONTINUE; break;
		case DISFFC_STOPALL:
			commandPacket->m_pData[1] = SWDEV_STOP_ALL; break;
		case DISFFC_RESET:
			commandPacket->m_pData[1] = SWDEV_SHUTDOWN; break;
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	commandPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	commandPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
	commandPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::GetForceFeedbackState(LPDIDEVICESTATE pDeviceState)
{
	return DataPackager::GetForceFeedbackState(pDeviceState);
}

HRESULT DataPackager100::DestroyEffect(DWORD downloadID)
{
	ClearPackets();

	// Note: Cannot allow actually destroying the SYSTEM Effects - Control panel might call this
	if ((downloadID == SYSTEM_FRICTIONCANCEL_ID) || (downloadID == SYSTEM_EFFECT_ID) ||
		(downloadID == SYSTEM_RTCSPRING_ALIAS_ID) || (downloadID == SYSTEM_RTCSPRING_ID)) {
		ASSUME_NOT_REACHED();
		return S_FALSE;		// User should have no acces to these
	}

	{	// Check for valid Effect and destroy it
		InternalEffect* pEffect = g_ForceFeedbackDevice.RemoveEffect(downloadID);
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();
			return SFERR_INVALID_OBJECT;
		}
		delete pEffect;
	}

	// Allocate DestroyEffect packet
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for destroy effect
	DataPacket* destroyPacket = GetPacket(0);
	if (!destroyPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	destroyPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	destroyPacket->m_pData[1] = DESTROY_EFFECT;
	destroyPacket->m_pData[2] = BYTE(downloadID);
	destroyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DESTROYEFFECT);
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	destroyPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay;
	destroyPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	if (downloadID == SYSTEM_EFFECT_ID) { // start has no meaning for raw force
		ClearPackets();
		return S_FALSE;
	}

	if (count != 1) { // Don't support PLAY_LOOP for this version
		ClearPackets();
		return SFERR_NO_SUPPORT;
	}

	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) { 	// Remap RTC Spring ID Alias
		downloadID = SYSTEM_RTCSPRING_ID;
	}

	ASSUME(BYTE(downloadID) < MAX_EFFECT_IDS);	// Small sanity check

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ClearPackets();
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for play effect
	DataPacket* playPacket = GetPacket(0);
	if (!playPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	playPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	playPacket->m_pData[2] = BYTE(downloadID);
	playPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_PLAYEFFECT);
	playPacket->m_AckNackTimeout = LONG_MSG_TIMEOUT;

	if (mode & DIES_SOLO) {	// Is it PLAY_SOLO?
		playPacket->m_pData[1] = PLAY_EFFECT_SOLO;
//		pMidiEffect->SetPlayMode(PLAY_SOLO); // Update the playback mode for this Effect
	} else {
		playPacket->m_pData[1] = PLAY_EFFECT_SUPERIMPOSE;
//		pMidiEffect->SetPlayMode(PLAY_SUPERIMPOSE); // Update the playback mode for this Effect
	}

	return SUCCESS;
}

HRESULT DataPackager100::StopEffect(DWORD downloadID)
{
	// Special case for putrawforce (Cannot stop - this is up for discussion)
	if (downloadID == SYSTEM_EFFECT_ID) {
		ClearPackets();
		return S_FALSE;
	}

	// Remap alias ID properly
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = SYSTEM_RTCSPRING_ID;		// Jolt returned ID0 for RTC Spring so return send alias ID
	}

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ASSUME_NOT_REACHED();
		ClearPackets();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* stopPacket = GetPacket(0);
	if (!stopPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	stopPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	stopPacket->m_pData[1] = STOP_EFFECT;
	stopPacket->m_pData[2] = BYTE(downloadID);
	stopPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_STOPEFFECT);
	stopPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::GetEffectStatus(DWORD downloadID)
{
	// Special case RTC Spring ID
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = SYSTEM_RTCSPRING_ID;	// Jolt returned ID0 for RTC Spring so return send alias ID	
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	packet->m_pData[0] = STATUS_CMD | DEFAULT_MIDI_CHANNEL;
	packet->m_pData[1] = BYTE(downloadID);
	packet->m_AckNackMethod = ACKNACK_NOTHING;
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	packet->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay;

	return SUCCESS;
}

HRESULT DataPackager100::SetMidiChannel(BYTE channel)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for channel set
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(9)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	// SysEx Header
	packet->m_pData[0] = SYS_EX_CMD;							// SysEX CMD
	packet->m_pData[1] = 0;									// Escape to Manufacturer ID
	packet->m_pData[2] = MS_MANUFACTURER_ID & 0x7f;			// Manufacturer High Byte
	packet->m_pData[3] = (MS_MANUFACTURER_ID >> 8) & 0x7f;	// Manufacturer Low Byte (note shifted 8!)
	packet->m_pData[4] = JOLT_PRODUCT_ID;					// Product ID

	// Midi Assign specific
	packet->m_pData[5] = MIDI_ASSIGN;						// Opcode, midi assign
	packet->m_pData[6] = channel & 0x7F;						// 7 bit channel ID

	// Midi Footer
	packet->m_pData[7] = InternalEffect::ComputeChecksum(*packet, 7);	// Checksum
	packet->m_pData[8] = MIDI_EOX;										// End of SysEX command

	packet->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DEVICEINIT);
	packet->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager100::ForceOut(LONG forceData, ULONG axisMask)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* pPacket = GetPacket(0);
	if (!pPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	pPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	pPacket->m_pData[1] = BYTE(int(forceData) << 2) & 0x7c;
	switch (axisMask) {
		case X_AXIS: {
			pPacket->m_pData[1] |= PUT_FORCE_X; break;
		}
		case Y_AXIS: {
			pPacket->m_pData[1] |= PUT_FORCE_Y; break;
		}
//		case X_AXIS | Y_AXIS: {		// Never Sent!!!
//			pPacket->m_pData[1] |= PUT_FORCE_XY; break;
//		}
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	pPacket->m_pData[2] = BYTE(int(forceData) >> 5) & 0x7f;

	pPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	pPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

/************** DataPackeger200 class ******************/

BYTE DataPackager200::EffectCommandParity(const DataPacket& packet) const
{
	BYTE w = packet.m_pData[0] ^ (packet.m_pData[1] & 0xF0) ^ packet.m_pData[2];
	return (w >> 4) ^ (w & 0x0F);
}

BYTE DataPackager200::DeviceCommandParity(const DataPacket& packet) const
{
	BYTE w = packet.m_pData[0] ^ (packet.m_pData[1] & 0xF0);
	return (w >> 4) ^ (w & 0x0F);
}


// Gain is parameter 0 from effect 0
HRESULT DataPackager200::SetGain(DWORD gain)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* modifyPacket = GetPacket(0);
	if ((modifyPacket == NULL) || (!modifyPacket->AllocateBytes(6))) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	DWORD value = DWORD(double(gain)/GAIN_SCALE_200);
	modifyPacket->m_pData[0] = MODIFY_CMD_200;
	modifyPacket->m_pData[1] = 0;	// Temporary for checksum calc.
	modifyPacket->m_pData[2] = 0;
	modifyPacket->m_pData[3] = 0;
	modifyPacket->m_pData[4] = BYTE(value & 0x7F);
	modifyPacket->m_pData[5] = 0;	// Gain is only 0 to 127

	// New checksum method just to be annoying
	BYTE checksum = modifyPacket->m_pData[0] + modifyPacket->m_pData[4];
	checksum = 0 - checksum;
	checksum &= 0xFF;
	modifyPacket->m_pData[1] = BYTE(checksum & 0x7F);
	modifyPacket->m_pData[2] |= BYTE(checksum >> 1) & 0x40;

	modifyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::SendForceFeedbackCommand(DWORD state)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set requested System Command
	DataPacket* commandPacket = GetPacket(0);
	if (!commandPacket->AllocateBytes(2)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	commandPacket->m_pData[0] = DEVICE_CMD_200;
	switch (state) {
		case DISFFC_SETACTUATORSON:
			commandPacket->m_pData[1] = ENABLE_OP_200; break;
		case DISFFC_SETACTUATORSOFF:
			commandPacket->m_pData[1] = DISABLE_OP_200; break;
		case DISFFC_PAUSE:
			commandPacket->m_pData[1] = PAUSE_OP_200; break;
		case DISFFC_CONTINUE:
			commandPacket->m_pData[1] = CONTINUE_OP_200; break;
		case DISFFC_STOPALL:
			commandPacket->m_pData[1] = STOPALL_OP_200; break;
		case DISFFC_RESET:
			commandPacket->m_pData[1] = SHUTDOWN_OP_200; break;
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	commandPacket->m_pData[1] = BYTE(commandPacket->m_pData[1] << 4);
	commandPacket->m_pData[1] |= DeviceCommandParity(*commandPacket) & 0x0F;

	commandPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
	commandPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	commandPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
	commandPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;

	return SUCCESS;
}

HRESULT DataPackager200::GetForceFeedbackState(DIDEVICESTATE* pDeviceState)
{
	return DataPackager::GetForceFeedbackState(pDeviceState);
}

HRESULT DataPackager200::CreateEffect(const InternalEffect& effect, DWORD diFlags)
{
	// Figure out the number of packets nessacary
	UINT totPackets = effect.GetModifyOnlyNeeded() + 1;

	if (!AllocateDataPackets((USHORT)totPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	DataPacket* createPacket = GetPacket(0);
	HRESULT hr = effect.FillCreatePacket(*createPacket);
	if (hr != SUCCESS) {
		ClearPackets();
		return hr;
	}
	createPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DOWNLOADEFFECT);
	createPacket->m_AckNackDelay = 0;
	createPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	createPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	hr = effect.FillModifyOnlyParms();	// Add the params that can only be modified
	if (hr != SUCCESS) {
		ClearPackets();
	}

	return hr;
}


HRESULT DataPackager200::DestroyEffect(DWORD downloadID)
{
	ClearPackets();

	// Note: Cannot allow actually destroying the SYSTEM Effects - Control panel might call this
	if ((downloadID == SYSTEM_FRICTIONCANCEL_ID) || (downloadID == SYSTEM_EFFECT_ID) ||
		(downloadID == SYSTEM_RTCSPRING_ALIAS_ID) || (downloadID == ID_RTCSPRING_200)) {
		ASSUME_NOT_REACHED();
		return S_FALSE;		// User should have no acces to these
	}

	{	// Check for valid Effect and destroy it
		InternalEffect* pEffect = g_ForceFeedbackDevice.RemoveEffect(downloadID);
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();
			return SFERR_INVALID_OBJECT;
		}
		delete pEffect;
	}

	// Allocate DestroyEffect packet
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for destroy effect
	DataPacket* destroyPacket = GetPacket(0);
	if (!destroyPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	destroyPacket->m_pData[0] = EFFECT_CMD_200;
	destroyPacket->m_pData[1] = BYTE(DESTROY_OP_200 << 4);
	destroyPacket->m_pData[2] = BYTE(downloadID);
	destroyPacket->m_pData[1] |= EffectCommandParity(*destroyPacket) & 0x0F;
	destroyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_DESTROYEFFECT);
	destroyPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwDestroyEffectDelay;
	destroyPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	destroyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::StartEffect(DWORD downloadID, DWORD mode, DWORD count)
{
	if ((downloadID == SYSTEM_EFFECT_ID) || (downloadID == RAW_FORCE_ALIAS)) { // start has no meaning for raw force
		ClearPackets();
		return S_FALSE;
	}

#ifdef _DEBUG
	if (downloadID != SYSTEM_RTCSPRING_ALIAS_ID) { 	// Remap RTC Spring ID Alias
		ASSUME(BYTE(downloadID) < MAX_EFFECT_IDS);	// Small sanity check
	}
#endif _DEBUG

	InternalEffect* pEffect = g_ForceFeedbackDevice.GetEffect(downloadID);
	if (pEffect == NULL) { // Check for valid Effect
		ClearPackets();
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_OBJECT;
	}

	if (count == 0) {	// I can do this easily
		ClearPackets();
		return S_OK;
	}

	BOOL truncate = FALSE;
	if (count == INFINITE) {	// Device expects zero for infinite
		count = 0;
	} else if (count > 127) {	// Device MAX
		count = 127;
		truncate = TRUE;
	}

	int allocCount = 1;
	if ((mode & DIES_SOLO) && count != 1) {
		allocCount = 2;	// Need to stopall for SOLO with count
	}
	if (!AllocateDataPackets((USHORT)allocCount)) {
		return SFERR_DRIVER_ERROR;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	if (count != 1) { // Special case, done via modify
		BYTE nextPacket = 0;
		if (mode & DIES_SOLO) {	// need to stop all first
			DataPacket* stopAllPacket = GetPacket(0);
			if (!stopAllPacket->AllocateBytes(2)) {
				ClearPackets();
				return SFERR_DRIVER_ERROR;
			}
			stopAllPacket->m_pData[0] = DEVICE_CMD_200;
			stopAllPacket->m_pData[1] = STOPALL_OP_200 << 4;
			stopAllPacket->m_pData[1] |= DeviceCommandParity(*stopAllPacket) & 0x0F;
			stopAllPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETDEVICESTATE);
			stopAllPacket->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwHWResetDelay;
			stopAllPacket->m_AckNackTimeout = ACKNACK_TIMEOUT;
			stopAllPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

			nextPacket = 1;
		}
		HRESULT hr = pEffect->FillModifyPacket200(nextPacket, pEffect->GetRepeatIndex(), count);
		if ((hr == S_OK) && (truncate == TRUE)) {
			return DI_TRUNCATED;
		}
		return hr;
	}

	// Packet for play effect
	DataPacket* playPacket = GetPacket(0);
	if (!playPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	playPacket->m_pData[0] = EFFECT_CMD_200;
	playPacket->m_pData[2] = BYTE(pEffect->GetDeviceID());
	playPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_PLAYEFFECT);
	playPacket->m_AckNackTimeout = LONG_MSG_TIMEOUT;
	playPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	if (mode & DIES_SOLO) {	// Is it PLAY_SOLO?
		playPacket->m_pData[1] = PLAYSOLO_OP_200;
	} else {
		playPacket->m_pData[1] = PLAYSUPER_OP_200;
	}
	playPacket->m_pData[1] = BYTE(playPacket->m_pData[1] << 4);
	playPacket->m_pData[1] |= EffectCommandParity(*playPacket) & 0x0F;

	return SUCCESS;
}

HRESULT DataPackager200::StopEffect(DWORD downloadID)
{
	// Special case for putrawforce (Cannot stop - this is up for discussion)
	if ((downloadID == SYSTEM_EFFECT_ID) || (downloadID == RAW_FORCE_ALIAS)) {
		ClearPackets();
		return S_FALSE;
	}

	// Remap alias ID properly
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = ID_RTCSPRING_200;		// Jolt returned ID0 for RTC Spring so return send alias ID
	}

	if (g_ForceFeedbackDevice.GetEffect(downloadID) == NULL) { // Check for valid Effect
		ASSUME_NOT_REACHED();
		ClearPackets();
		return SFERR_INVALID_OBJECT;
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for stop effect
	DataPacket* stopPacket = GetPacket(0);
	if (!stopPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	stopPacket->m_pData[0] = EFFECT_CMD_200;
	stopPacket->m_pData[1] = BYTE(STOP_OP_200 << 4);
	stopPacket->m_pData[2] = BYTE(downloadID);
	stopPacket->m_pData[1] |= EffectCommandParity(*stopPacket) & 0x0F;
	stopPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_STOPEFFECT);
	stopPacket->m_AckNackTimeout = SHORT_MSG_TIMEOUT;
	stopPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT DataPackager200::GetEffectStatus(DWORD downloadID)
{
	// Special case RTC Spring ID
	if (downloadID == SYSTEM_RTCSPRING_ALIAS_ID) {
		downloadID = ID_RTCSPRING_200;	// Jolt returned ID0 for RTC Spring so return send alias ID	
	}

	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet for status effect command
	DataPacket* packet = GetPacket(0);
	if (!packet->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	packet->m_pData[0] = EFFECT_CMD_200;
	packet->m_pData[1] = BYTE(STATUS_OP_200 << 4);
	packet->m_pData[2] = BYTE(downloadID);
	packet->m_pData[1] |= EffectCommandParity(*packet) & 0x0F;
	packet->m_AckNackMethod = ACKNACK_BUTTONSTATUS;
	packet->m_AckNackDelay = g_pJoltMidi->DelayParamsPtrOf()->dwGetEffectStatusDelay;
	packet->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;

}

HRESULT DataPackager200::ForceOut(LONG forceData, ULONG axisMask)
{
	if (!AllocateDataPackets(1)) {
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set index15 (gain) of System Effect
	DataPacket* pPacket = GetPacket(0);
	if (!pPacket->AllocateBytes(3)) {
		ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	pPacket->m_pData[0] = EFFECT_CMD_200;
	switch (axisMask) {
		case X_AXIS: {
			pPacket->m_pData[1] = BYTE(FORCEX_OP_200 << 4); break;
		}
		case Y_AXIS: {
			pPacket->m_pData[1] = BYTE(FORCEY_OP_200 << 4); break;
		}
		default: {
			ClearPackets();
			return SFERR_INVALID_PARAM;
		}
	}
	BYTE calc = BYTE((PERCENT_SHIFT - forceData)/PERCENT_TO_DEVICE);
	pPacket->m_pData[2] = BYTE(calc & 0x7f);
	pPacket->m_pData[1] |= EffectCommandParity(*pPacket) & 0x0F;

	pPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	pPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dx_map.hpp ===
/****************************************************************************

    MODULE:     	DX_MAP.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Mapper for converting SWForce FFD_ to DirectInput Force
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	14-Feb-97       MEA     original
        
****************************************************************************/
#ifndef _DX_MAP_SEEN
#define _DX_MAP_SEEN
#include <windows.h>
#include "dinput.h"
#include "dinputd.h"


// Diagnostics Counters
typedef struct _DIAG_COUNTER
{
	ULONG			m_NACKCounter;		// For Debugging, how many NACKS
	ULONG			m_LongMsgCounter;  	// How many SysEx messages
	ULONG			m_ShortMsgCounter;	// How many 3 byte Short messages
	ULONG			m_RetryCounter;		// Number of retries
} DIAG_COUNTER, *PDIAG_COUNTER;

//
// --- Mapping from DX to SWForce FFD
//

typedef struct IDirectInputEffect	 *PSWEFFECT;  
typedef struct IDirectInputEffect	**PPSWEFFECT;  

#define SW_NUMBER_OF_BUTTONS 9

#define DNHANDLE	USHORT		// Download Effect Handle type
#define PDNHANDLE	DNHANDLE *	// Pointer

#define MIN_ANGLE			0
#define MAX_ANGLE			36000
#define MIN_FORCEOUTPUTRATE 1
#define MIN_GAIN			1
#define MAX_GAIN			10000
#define MAX_FORCE			10000
#define MIN_FORCE			-10000
#define MIN_TIME_PERIOD		1
#define MAX_TIME_PERIOD		4294967296L	// 4096 * 10^^6 usecs
#define MAX_POSITION		10000
#define MIN_POSITION		-10000
#define MAX_CONSTANT		10000
#define MIN_CONSTANT		-10000

#define SCALE_GAIN			100		// DX is +/- 10000, SWForce in +/-100
#define SCALE_TIME			1000	// DX is in microseconds, SWForce in msec
#define	SCALE_POSITION		100		// DX is +/- 10000, SWForce in +/- 100+
#define	SCALE_CONSTANTS		100		// DX is +/- 10000, SWForce in +/- 100+
#define SCALE_DIRECTION		100		// DX is 0 to 35900, SWForce is 0 to 359

// 
// --- Default Values
//
#define	DEFAULT_OFFSET			0
#define DEFAULT_ATTACK_LEVEL	0
#define DEFAULT_ATTACK_TIME		0
#define DEFAULT_SUSTAIN_LEVEL	10000
#define DEFAULT_FADE_LEVEL		0
#define DEFAULT_FADE_TIME		0

// PlaybackEffect Command Modes
#define PLAY_SUPERIMPOSE	0x01
#define PLAY_SOLO			0x02
#define PLAY_STORE			0x04	// Store only
#define PLAY_UPDATE			0x08
//reserved					0x10
#define PLAY_LOOP			0x20
#define PLAY_FOREVER		0x40
#define PLAY_STOP			0x80
#define PLAY_MODE_MASK		0xff

#define DEV_SHUTDOWN		DEV_RESET

//
// --- Effect Status
//
#define ES_HOST			0x00000001L	// Effect is in HOST memory
#define ES_DOWNLOADED	0x00000002L	// Effect is downloaded
#define ES_STOPPED		0x00000004L	// Effect is stopped
#define ES_PLAYING		0x00000008L	// Effect is playing

//
// --- Axis Masks
//
#define X_AXIS		0x01
#define Y_AXIS		0x02
#define Z_AXIS		0x04
#define ROT_X_AXIS	0x08
#define ROT_Y_AXIS	0x10
#define ROT_Z_AXIS	0x20

//
// --- Button Masks
//
#define BUTTON1_PLAY 	0x00000001L	// Trigger button (usually)
#define BUTTON2_PLAY	0x00000002L
#define BUTTON3_PLAY	0x00000004L
#define BUTTON4_PLAY	0x00000008L
#define BUTTON5_PLAY	0x00000010L
#define BUTTON6_PLAY	0x00000020L
#define BUTTON7_PLAY	0x00000040L
#define BUTTON8_PLAY	0x00000080L
#define BUTTON9_PLAY	0x00000100L
#define BUTTON10_PLAY	0x00000200L
#define BUTTON11_PLAY	0x00000400L
#define BUTTON12_PLAY	0x00000800L
#define BUTTON13_PLAY	0x00001000L
#define BUTTON14_PLAY	0x00002000L
#define BUTTON15_PLAY	0x00004000L
#define BUTTON16_PLAY	0x00008000L	// . . . 16th button

// 
// --- Force Feedback Device State
//
typedef struct _SWDEVICESTATE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0 = Hands Off, 1 = Hands On
	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
} SWDEVICESTATE, *PSWDEVICESTATE;


#define MAX_SIZE_SNAME	64

//
//
// --- Force Feedback Device Capabilities
//
typedef struct _FFDEVICEINFO {
	ULONG	m_Bytes;		// Size of this structure
	TCHAR	m_ProductName[MAX_SIZE_SNAME];	// Device Name 64 chars
	TCHAR	m_ManufacturerName[MAX_SIZE_SNAME]; // Manufacturer
	ULONG	m_ProductVersion;	// Device Product Version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceDriverVersion;	// Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceFirmwareVersion; // Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_Interface;		// HIWORD: OUTPUT:HID_INTERFACE||VJOYD_INTERFACE 
								// LOWORD: INPUT: HID_INTERFACE||VJOYD_INTERFACE 
	ULONG	m_MaxSampleRate;	// Maximum Force output rate
	ULONG	m_MaxMemory;		// Max amount of RAM
	ULONG	m_NumberOfSensors;	// SENSOR_AXIS total in the device (INPUT)
	ULONG	m_NumberOfAxes;		// ACTUATOR_AXIS total in the device (OUTPUT)
	ULONG	m_EffectsCaps;		// Built-in Effects capability
	ULONG	m_Reserved;			// 
	ULONG	m_JoystickID;		// VJOYD Joystick ID (0-based)
	ULONG	m_ExtraInfo;		// For future stuff
} FFDEVICEINFO, *PFFDEVICEINFO;


//
// --- AXISCAPS Sensor or Actuator Axes capabilities
//
typedef struct _AXISCAPS {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bit position for Actuator or Sensor Axes
	ULONG	m_LogicalExtentMin;	// Minimum logical extent
	ULONG	m_LogicalExtentMax;	// Maximum logical extent
	ULONG	m_PhysicalExtentMin;// Minimum physical extent
	ULONG	m_PhysicalExtentMax;// Maximum Physical extent
	ULONG	m_Units;			// HID style physical SI units
	ULONG	m_Resolution;		// Position increments per physical SI unit
	ULONG	m_ServoLoopRate;	// Loop rate in cycles/sec
} AXISCAPS, *PAXISCAPS;


typedef struct _FORCE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_DirectionAngle2D;	// From X-Axis = theta1
	LONG	m_DirectionAngle3D;	// From Z-Axis = (theta2, note: theta1+theta2)>= 90
	LONG	m_ForceValue;		// Actual force in +/- 100%
} FORCE, *PFORCE;


typedef struct _FORCECONTEXT {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_Position;			// Position along the Axis -32768 to +32767
	LONG	m_Velocity;			// Velocity in -32768 to +32767 units TBD
	LONG	m_Acceleration;		// Acceleration in -32768 to +32767 units TBD
} FORCECONTEXT, *PFORCECONTEXT;


// The following are Type Specific parameters structures
//
//

//
// -- an Effect structure
//
typedef struct _EFFECT {
	ULONG	m_Bytes;			// Size of this structure
	TCHAR	m_Name[MAX_SIZE_SNAME];
	ULONG	m_Type;				// Major Effect type, e.g. EF_BEHAVIOR, etc..
	ULONG	m_SubType;			// Minor Effect type, e.g. SE_xxx,BE_xxx,UD_xxx
	ULONG	m_AxisMask;			// Bitmask for axis to send the effect, 
								//   If NULL, use value from Device Capabilities
	ULONG	m_DirectionAngle2D;	// From Y-Axis (cone) = theta1
	ULONG	m_DirectionAngle3D;	// From Z-Axis (cone) = theta2
								//  note: theta1+theta2)>= 90
	ULONG	m_Duration;			// Duration in ms., 00 = infinite
	ULONG	m_ForceOutputRate;	// Sample Rate for Force Data output
	ULONG	m_Gain;				// Gain to apply, normally this is set
								// to 100. Gain is 1 to  100.
	ULONG	m_ButtonPlayMask;	// Mask to indicate which button to assign Effect
} EFFECT, *PEFFECT;


//
// --- ENVELOPE
//
// Note:  There are two types of Envelope control, using PERCENTAGE,
// and using TIME.  
// PERCENTAGE defines Envelope using Percentage for the Attack,Sustain and Decay
//
// TIME Envelope type will require the time in 1 millisecond increment, and
// m_StartAmp is the Amplitude to start the waveform, while m_EndAmp is used
// to decay or end the waveform. m_SustainAmp is used to set Sustain amplitude
//
#define PERCENTAGE	0x00000000	// Envelope is in percentage values
#define TIME		0x00000001	// Envelope is in 1 millisecond time increments

//For PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Note: Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline -->>> (m_MaxAmp - m_MinAmp)/2
// m_EndAmp = m_StartAmp;
//
//Valid Ranges:
//PERCENTAGE mode:  
//		m_Attack, m_Sustain, m_Decay = 1 to 100%, and must sum up to 100%
//TIME mode:
//		m_Attack = 0 to 32,768 ms,
//      m_Sustain = 0 to 32,768 ms
//      m_Decay = 0 to 32,768 ms.   (All are in 1 ms increments).
//Note: For an infinite duration (value in m_Duration = 0), the Effect will 
//      never decay and m_Decay is ignored.
//
// Envelopes are only valid for Synthesized Waveforms (SE_XXX) type
//
//
typedef struct _ENVELOPE {
	ULONG	m_Bytes;		// Size of this structure
	ULONG	m_Type;			// PERCENTAGE || TIME
	ULONG	m_Attack;		// Rise time to Sustain Value
							//  in % of Duration, or in msec Time
	ULONG	m_Sustain;		// Sustain time at Sustain Value in % Duration,
							//  or in msec Time
	ULONG	m_Decay;		// Decay time to Minimum Value,
							//  in % of Duration, or in msec Time
	ULONG	m_StartAmp;		// Amplitude to start the Envelope, from baseline		
	ULONG	m_EndAmp;		// Amplitude to End the Envelope, from baseline
	ULONG	m_SustainAmp;	// Amplitude to Sustain the Envelope, from baseline
} ENVELOPE, *PENVELOPE;


//
// ---	EF_BEHAVIOR = {BE_SPRINGxx||BE_DAMPERxx||BE_INTERTIAxx||BE_FRICTIONxx
//						||BE_WALL||BE_DELAY}
//  Note: Behavioral Effects do not have an Envelope.
//
typedef struct _BE_SPRING_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_Kconstant;		// K constant
	LONG	m_AxisCenter;		// Center of the function
} BE_SPRING_PARAM, *PBE_SPRING_PARAM;

typedef struct _BE_SPRING_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_XKconstant;		// X_Axis K constant
	LONG	m_XAxisCenter;		// X_Axis Center
	LONG	m_YKconstant;		// Y_Axis K constant
	LONG	m_YAxisCenter;		// Y_Axis Center
} BE_SPRING_2D_PARAM, *PBE_SPRING_2D_PARAM;

typedef struct _BE_DAMPER_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Bconstant;		// B constant
	LONG	m_V0;				// Initial Velocity
} BE_DAMPER_PARAM, *PBE_DAMPER_PARAM;

typedef struct _BE_DAMPER_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XBconstant;		// X_AXIS B constant
	LONG	m_XV0;				// X_AXIS Initial Velocity
	LONG	m_YBconstant;		// Y_Axis B constant
	LONG	m_YV0;				// Y_AXIS Initial Velocity
} BE_DAMPER_2D_PARAM, *PBE_DAMPER_2D_PARAM;

typedef struct _BE_INERTIA_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_Mconstant;		// M constant
	LONG	m_A0;				// Initial Acceleration
} BE_INERTIA_PARAM, *PBE_INERTIA_PARAM;

typedef struct _BE_INERTIA_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XMconstant;		// X_AXIS M constant
	LONG	m_XA0;				// X_AXIS Initial Acceleration
	LONG	m_YMconstant;		// Y_AXIS M constant
	LONG	m_YA0;				// Y_AXIS Initial Acceleration
} BE_INERTIA_2D_PARAM, *PBE_INERTIA_2D_PARAM;

typedef struct _BE_FRICTION_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Fconstant;        // F Friction constant
} BE_FRICTION_PARAM, *PBE_FRICTION_PARAM;

typedef struct _BE_FRICTION_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XFconstant;		// X_AXIS F Friction constant
	LONG	m_YFconstant;		// Y_AXIS F Friction constant
} BE_FRICTION_2D_PARAM, *PBE_FRICTION_2D_PARAM;

//
// --- WALL Effect
//
#define WALL_INNER			0	// Wall material:from center to Wall Distance
#define WALL_OUTER			1	// Wall material:greater than Wall Distance

typedef struct _BE_WALL_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG 	m_WallType;			// WALL_INNER or WALL_OUTER
	LONG	m_WallConstant;		// in +/- 10000%
	ULONG	m_WallAngle;		// 0 to 35900
	ULONG	m_WallDistance;		// Distance from Wall face normal to center. 0 to 100
} BE_WALL_PARAM, *PBE_WALL_PARAM;

//
// ---	DELAY Effect
//
// Use EFFECT.m_SubType = BE_DELAY
// This has no type specific parameters.
//

//
// ---	EF_SYNTHESIZED = {  SE_CONSTANT_FORCE||SE_SINE||SE_SQUARE||SE_RAMPUP
//						  ||SE_RAMPDN||SE_TRIANGLE||SE_SAWTOOTH}
typedef struct _SE_PARAM {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_Freq;				// Frequency in Hz units
	ULONG	m_SampleRate;		// Sample rate in Hz units
	LONG	m_MaxAmp;			// Maximum Amplitude in Force units
	LONG	m_MinAmp;			// Minimum Amplitude in Force units
} SE_PARAM, *PSE_PARAM;

//
// ---	EF_USER_DEFINED = { Waveform defined by the user }
//
// Subtype: UD_WAVEFORM
typedef struct _UD_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_NumVectors;		// Number of entries in the Array
	LONG *	m_pForceData;		// Ptr to an array of LONG Force values.
} UD_PARAM, *PUD_PARAM;

//
// { Process List defined by the user }
// Subtype: PL_CONCATENATE || PL_SUPERIMPOSE
//
typedef struct _PL_PARAM {
	ULONG		m_Bytes;		// Size of this structure
	ULONG		m_NumEffects;	// # of Effects in list
	PPSWEFFECT	m_pProcessList;	// Ptr to a list of ISWEffect pointers
} PL_PARAM, *PPL_PARAM;

//
// ---	EF_ROM_EFFECT = { ROM Built-in Waveforms defined by the OEM }
//
// This has no type specific parameters.
// Subtypes:  See further below

#define DEFAULT_ROM_EFFECT_GAIN		100		// Set dwGain to this for Default
											// ROM Effect gain
#define DEFAULT_ROM_EFFECT_DURATION	1000	// Set dwDuration to this for Default
											// ROM Effect Duration
#define DEFAULT_ROM_EFFECT_OUTPUTRATE	1000	// Set dwSampleRate to this for 
												// Default ROM Effect output rate

//
// ---	EF_VFX_EFFECT = { FRC file effects }
//
// Subtypes:  none

#define VFX_FILENAME	0L
#define VFX_BUFFER		1L

typedef struct _VFX_PARAM
{
	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
} VFX_PARAM, *PVFX_PARAM;

//
// --- RTC Spring Effect Structure
//
typedef struct _RTCSPRING_PARAM{
	ULONG	m_Bytes;				// Size of this structure
	LONG	m_XKConstant;			// K Constant for X-axis
	LONG	m_YKConstant;			// "   "      for Y-axis
	LONG	m_XAxisCenter;			// RTC Spring center for X-axis
	LONG	m_YAxisCenter;			// "   "      "      for Y-axis
	LONG	m_XSaturation;			// Saturation for X-axis
	LONG	m_YSaturation;			// "          for Y-axis
	LONG	m_XDeadBand;			// Deadband for X-axis
	LONG	m_YDeadBand;			// "        for Y-axis
} RTCSPRING_PARAM, *PRTCSPRING_PARAM;


//
// --- Major Type: Effects categories
//
#define	EF_BEHAVIOR		1L	// Behavioral Effect, e.g. Spring, Damper, etc.
#define	EF_SYNTHESIZED	2L	// Synthesized Effect, e.g. Sine, Square
#define EF_USER_DEFINED	3L	// User Defined Waveform
#define EF_ROM_EFFECT	4L	// ROM Built-in Waveforms defined by the OEM 
#define EF_VFX_EFFECT	5L	// FRC file effects
#define EF_RAW_FORCE	6L	// For PutRawForce
#define EF_RTC_SPRING	7L	// Permanent RTC Spring

//
// --- Subtypes for EF_BEHAVIOR
//
#define BE_SPRING	   	1L
#define BE_SPRING_2D   	2L
#define BE_DAMPER	   	3L
#define BE_DAMPER_2D   	4L
#define BE_INERTIA	   	5L
#define BE_INERTIA_2D  	6L
#define BE_FRICTION	   	7L
#define BE_FRICTION_2D	8L
#define BE_WALL			9L
#define BE_DELAY		10L
//
// --- DXFF map
//
#define ID_SPRING			(BE_SPRING 			+ (EF_BEHAVIOR<<16))
#define ID_DAMPER			(BE_DAMPER 			+ (EF_BEHAVIOR<<16))
#define ID_INERTIA			(BE_INERTIA 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION			(BE_FRICTION 		+ (EF_BEHAVIOR<<16))
// --- SWForce extensions
#define ID_SPRING_2D		(BE_SPRING_2D 		+ (EF_BEHAVIOR<<16))
#define ID_DAMPER_2D		(BE_DAMPER_2D 		+ (EF_BEHAVIOR<<16))
#define ID_INERTIA_2D		(BE_INERTIA_2D 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION_2D		(BE_FRICTION_2D 	+ (EF_BEHAVIOR<<16))
#define ID_WALL				(BE_WALL 			+ (EF_BEHAVIOR<<16))
#define ID_DELAY			(BE_DELAY 			+ (EF_BEHAVIOR<<16))

//
// --- Subtypes for EF_SYNTHESIZE
//								
#define SE_CONSTANT_FORCE	101L
#define SE_SINE				102L
#define SE_COSINE			103L
#define	SE_SQUARELOW		104L
#define	SE_SQUAREHIGH		105L
#define	SE_RAMPUP  			106L
#define	SE_RAMPDOWN			107L
#define	SE_TRIANGLEUP		108L
#define	SE_TRIANGLEDOWN		109L
#define	SE_SAWTOOTHUP		110L
#define	SE_SAWTOOTHDOWN		111L
//
// --- DXFF map
//
#define ID_CONSTANTFORCE	(SE_CONSTANTFORCE 	+ (EF_SYNTHESIZED<<16))
#define ID_RAMPFORCE		(SE_RAMPUP  	  	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARE			(SE_SQUARELOW	  	+ (EF_SYNTHESIZED<<16))
#define ID_SINE				(SE_SINE		  	+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLE			(SE_TRIANGLEUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHUP		(SE_SAWTOOTHUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHDOWN		(SE_SAWTOOTHDOWN	+ (EF_SYNTHESIZED<<16))
#define ID_RAMP				(SE_RAMPUP		  	+ (EF_SYNTHESIZED<<16))
//
// --- SWForce extensions
//
#define ID_COSINE			(SE_COSINE		 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUAREHIGH		(SE_SQUAREHIGH	 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARELOW		(SE_SQUARELOW		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPUP  			(SE_RAMPUP  		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPDOWN			(SE_RAMPDOWN		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEUP		(SE_TRIANGLEUP		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEDOWN		(SE_TRIANGLEDOWN	+ (EF_SYNTHESIZED<<16))

//
// --- Subtypes for EF_USER_DEFINED
//
#define UD_WAVEFORM			201L
#define PL_CONCATENATE		202L
#define PL_SUPERIMPOSE		203L
//
// --- DXFF map
//
#define ID_CUSTOMFORCE		(UD_WAVEFORM	 	+ (EF_USER_DEFINED<<16))
//
// --- SWForce extensions
//
#define ID_PL_CONCATENATE	(PL_CONCATENATE 	+ (EF_USER_DEFINED<<16))
#define ID_PL_SUPERIMPOSE	(PL_SUPERIMPOSE 	+ (EF_USER_DEFINED<<16))

//
// --- Subtypes for EF_ROM_EFFECT
// starts at 0x12D
#define RE_ROMID_START	301L
#define	RE_ROMID1		(RE_ROMID_START     )	
#define	RE_ROMID2		(RE_ROMID_START +  1)		
#define	RE_ROMID3		(RE_ROMID_START +  2)			
#define	RE_ROMID4		(RE_ROMID_START +  3)		
#define	RE_ROMID5		(RE_ROMID_START +  4)		
#define	RE_ROMID6		(RE_ROMID_START +  5)	
#define RE_ROMID7		(RE_ROMID_START +  6)
#define	RE_ROMID8		(RE_ROMID_START +  7)	
#define	RE_ROMID9		(RE_ROMID_START +  8)		
#define	RE_ROMID10		(RE_ROMID_START +  9)			
#define	RE_ROMID11		(RE_ROMID_START + 10)		
#define	RE_ROMID12		(RE_ROMID_START + 11)		
#define	RE_ROMID13		(RE_ROMID_START + 12)	
#define RE_ROMID14		(RE_ROMID_START + 13)
#define	RE_ROMID15		(RE_ROMID_START + 14)		
#define	RE_ROMID16		(RE_ROMID_START + 15)	
#define RE_ROMID17		(RE_ROMID_START + 16)
#define	RE_ROMID18		(RE_ROMID_START + 17)	
#define	RE_ROMID19		(RE_ROMID_START + 18)
#define	RE_ROMID20		(RE_ROMID_START + 19)			
#define	RE_ROMID21		(RE_ROMID_START + 20)		
#define	RE_ROMID22		(RE_ROMID_START + 21)		
#define	RE_ROMID23		(RE_ROMID_START + 22)	
#define RE_ROMID24		(RE_ROMID_START + 23)
#define	RE_ROMID25		(RE_ROMID_START + 24)		
#define	RE_ROMID26		(RE_ROMID_START + 25)	
#define RE_ROMID27		(RE_ROMID_START + 26)
#define	RE_ROMID28		(RE_ROMID_START + 27)
#define	RE_ROMID29		(RE_ROMID_START + 28)
#define	RE_ROMID30		(RE_ROMID_START + 29)
#define RE_ROMID31		(RE_ROMID_START + 30)
#define RE_ROMID32		(RE_ROMID_START + 31)
#if 0
#define	RE_ROMID33		(RE_ROMID_START + 32)	
#define RE_ROMID34		(RE_ROMID_START + 33)
#define	RE_ROMID35		(RE_ROMID_START + 34)		
#define	RE_ROMID36		(RE_ROMID_START + 35)	
#define RE_ROMID37		(RE_ROMID_START + 36)
#define	RE_ROMID38		(RE_ROMID_START + 37)	
#define	RE_ROMID39		(RE_ROMID_START + 38)
#define	RE_ROMID40		(RE_ROMID_START + 39)			
#define	RE_ROMID41		(RE_ROMID_START + 40)		
#define	RE_ROMID42		(RE_ROMID_START + 41)		
#define	RE_ROMID43		(RE_ROMID_START + 42)	
#define RE_ROMID44		(RE_ROMID_START + 43)
#define	RE_ROMID45		(RE_ROMID_START + 44)		
#define	RE_ROMID46		(RE_ROMID_START + 45)	
#define RE_ROMID47		(RE_ROMID_START + 46)
#define	RE_ROMID48		(RE_ROMID_START + 47)
#define	RE_ROMID49		(RE_ROMID_START + 48)
#define	RE_ROMID50		(RE_ROMID_START + 49)
#define RE_ROMID51		(RE_ROMID_START + 50)
#define RE_ROMID52		(RE_ROMID_START + 51)
#define	RE_ROMID53		(RE_ROMID_START + 52)	
#define RE_ROMID54		(RE_ROMID_START + 53)
#define	RE_ROMID55		(RE_ROMID_START + 54)		
#define	RE_ROMID56		(RE_ROMID_START + 55)	
#define RE_ROMID57		(RE_ROMID_START + 56)
#define	RE_ROMID58		(RE_ROMID_START + 57)	
#define	RE_ROMID59		(RE_ROMID_START + 58)
#define	RE_ROMID60		(RE_ROMID_START + 59)			
#define	RE_ROMID61		(RE_ROMID_START + 60)		
#define	RE_ROMID62		(RE_ROMID_START + 61)		
#define	RE_ROMID63		(RE_ROMID_START + 62)	
#define RE_ROMID64		(RE_ROMID_START + 63)
#endif
#define MAX_ROM_EFFECTS (RE_ROMID32 - RE_ROMID_START + 1)

//
// --- DXFF map
//
#define ID_RANDOM_NOISE				(RE_ROMID1  + (EF_ROM_EFFECT<<16))
#define ID_AIRCRAFT_CARRIER_TAKEOFF	(RE_ROMID2	+ (EF_ROM_EFFECT<<16))
#define ID_BASKETBALL_DRIBBLE		(RE_ROMID3	+ (EF_ROM_EFFECT<<16))
#define ID_CAR_ENGINE_IDLE			(RE_ROMID4	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IDLE			(RE_ROMID5	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IN_ACTION		(RE_ROMID6	+ (EF_ROM_EFFECT<<16))
#define ID_DIESEL_ENGINE_IDLE		(RE_ROMID7	+ (EF_ROM_EFFECT<<16))
#define ID_JUMP						(RE_ROMID8	+ (EF_ROM_EFFECT<<16))
#define ID_LAND						(RE_ROMID9	+ (EF_ROM_EFFECT<<16))
#define ID_MACHINEGUN				(RE_ROMID10 + (EF_ROM_EFFECT<<16))
#define ID_PUNCHED					(RE_ROMID11 + (EF_ROM_EFFECT<<16))
#define ID_ROCKET_LAUNCH			(RE_ROMID12 + (EF_ROM_EFFECT<<16))
#define ID_SECRET_DOOR				(RE_ROMID13 + (EF_ROM_EFFECT<<16))
#define ID_SWITCH_CLICK				(RE_ROMID14 + (EF_ROM_EFFECT<<16))
#define ID_WIND_GUST				(RE_ROMID15 + (EF_ROM_EFFECT<<16))
#define ID_WIND_SHEAR				(RE_ROMID16 + (EF_ROM_EFFECT<<16))
#define ID_PISTOL					(RE_ROMID17 + (EF_ROM_EFFECT<<16))
#define ID_SHOTGUN					(RE_ROMID18 + (EF_ROM_EFFECT<<16))
#define ID_LASER1					(RE_ROMID19 + (EF_ROM_EFFECT<<16))
#define ID_LASER2					(RE_ROMID20 + (EF_ROM_EFFECT<<16))
#define ID_LASER3					(RE_ROMID21 + (EF_ROM_EFFECT<<16))
#define ID_LASER4					(RE_ROMID22 + (EF_ROM_EFFECT<<16))
#define ID_LASER5					(RE_ROMID23 + (EF_ROM_EFFECT<<16))
#define ID_LASER6					(RE_ROMID24 + (EF_ROM_EFFECT<<16))
#define ID_OUT_OF_AMMO				(RE_ROMID25 + (EF_ROM_EFFECT<<16))
#define ID_LIGHTNING_GUN			(RE_ROMID26 + (EF_ROM_EFFECT<<16))
#define ID_MISSILE					(RE_ROMID27 + (EF_ROM_EFFECT<<16))
#define ID_GATLING_GUN				(RE_ROMID28 + (EF_ROM_EFFECT<<16))
#define ID_SHORT_PLASMA				(RE_ROMID29 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON1			(RE_ROMID30 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON2			(RE_ROMID31 + (EF_ROM_EFFECT<<16))
#define ID_CANNON					(RE_ROMID32 + (EF_ROM_EFFECT<<16))
//#define ID_FLAME_THROWER			(RE_ROMID33 + (EF_ROM_EFFECT<<16))
//#define ID_BOLT_ACTION_RIFLE		(RE_ROMID34 + (EF_ROM_EFFECT<<16))
//#define ID_CROSSBOW					(RE_ROMID35 + (EF_ROM_EFFECT<<16))



#endif // of ifdef _DX_MAP_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\effect.cpp ===
//@doc
/******************************************************
**
** @module EFFECT.CPP | InternalEffect implementation file
**
** Description:
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
**		23-Mar-99	waltw	IsReallyPlaying  now uses data returned by
**							Transmit instead of obsolete GetStatusGateData
**
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Effect.h"
#include "DPack.h"
#include "DTrans.h"
#include "FFDevice.h"
#include "joyregst.hpp"
#include "Registry.h"
#include "CritSec.h"
#include "Midi_Obj.hpp"
#include <math.h>

DWORD g_TotalModifiable =	DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON |
							DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE |
							DIEP_TYPESPECIFICPARAMS;

//#define ZEP_PRODUCT_ID			0x7F
#define ZEP_PRODUCT_ID			0x15

#define DOWNLOAD_OP_200			0x02
#define STORE_ACTION_200		0x00
#define PLAYSUPER_ACTION_200	0x01
#define PLAYSOLO_ACTION_200		0x02
#define AXIS_ANGLE_200			0x00
#define AXIS_X_200				0x01
#define AXIS_Y_200				0x02

// VFX Default items
#define DEFAULT_VFX_SAMPLEPERIOD 2000
#define DEFAULT_VFX_EFFECT_DIRECTION	0
#define DEFAULT_VFX_EFFECT_GAIN	10000
#define DEFAULT_VFX_EFFECT_DURATION 1000

// Max DIDistance = 10,000 so 10,000/100(percent) = 100
#define DIDISTANCE_TO_PERCENT	100

#define COEFFICIENT_SCALE_1XX	100
#define DURATION_SCALE_1XX		1000
#define GAIN_PERCENTAGE_SCALE	100
#define FREQUENCY_SCALE_1XX		1000000
#define TIME_SCALE_1XX			1000
#define ENVELOPE_TIME_TICKS_1XX	2

#define DURATION_SCALE_200		2000
#define ANGLE_SCALE_200			281.25
#define POSITIVE_PERCENT_SCALE	1.588
#define FRICTION_SCALE_200		157.5
#define GAIN_SCALE_200			78.7
#define PHASE_SCALE_200			2.197
#define WAVELET_SCALE_200		39.215
//#define WAVELET_DISTANCE_200	1215
#define WAVELET_DISTANCE_200	2440
//#define WAVELET_DISTANCE_SCALE_200 39.193
#define WAVELET_DISTANCE_SCALE_200 78.74
#define BEHAVIOUR_CENTER_SCALE_200	158
#define BEHAVIOUR_CENTER_200		63
#define MAX_TIME_200	32766000

// Mofidify index for version 200
#define INDEX_BE_DURATION_200		0
#define INDEX_DELAY_200				1
#define INDEX_DIRECTIONANGLE_200	2
#define INDEX_D1F1_200				(BYTE)3
#define INDEX_D2F2_200				4
#define INDEX_D3F3_200				5
#define INDEX_D4F4_200				6
#define INDEX_BE_BUTTONMAP_200		7
#define INDEX_BE_BUTTONREPEAT_200	8
#define INDEX_BE_GAIN_200			9
#define INDEX_BE_CENTER_200			10
#define INDEX_BE_REPEAT_200			11

// Friction Modify Indecies
#define INDEX_FE_DURATION_200		0
#define INDEX_FE_DELAY_200			1
#define INDEX_FE_DIRECTIONANGLE_200	2
#define INDEX_FE_COEEFICIENT_200	3
#define INDEX_FE_BUTTONMAP_200		4
#define INDEX_FE_BUTTONREPEAT_200	5
#define INDEX_FE_GAIN_200			6
#define INDEX_FE_REPEAT_200			7

// CustomForce Modify Indecies
#define INDEX_CF_DURATION_200		0
#define INDEX_CF_DELAY_200			1
#define INDEX_CF_DIRECTIONANGLE_200	2
#define INDEX_CF_GAIN_200			3
#define INDEX_CF_STARTPERCENT_200	4
#define INDEX_CF_ATTTACK_TIME_200	5
#define INDEX_CF_SUSTAINPERCENT_200 6
#define INDEX_CF_FADESTART_200		7
#define INDEX_CF_ENDPERCENT_200		8
#define INDEX_CF_OFFSET_200			9
#define INDEX_CF_FORCESAMPLE_200	10
#define INDEX_CF_SAMPLE_PERIOD_200	11
#define INDEX_CF_BUTTONMAP_200		12
#define INDEX_CF_BUTTONREPEAT_200	13
#define INDEX_CF_REPEAT_200			14

// Periodic Effect Modify Indecies
#define INDEX_PE_DURATION_200		0
#define INDEX_PE_DIRECTIONANGLE_200 2
#define INDEX_PE_GAIN_200			3
#define INDEX_PE_PHASE_200			4
#define INDEX_PE_STARTPERCENT_200	5
#define INDEX_PE_ATTTACK_TIME_200	6
#define INDEX_PE_SUSTAINPERCENT_200 7
#define INDEX_PE_FADESTART_200		8
#define INDEX_PE_ENDPERCENT_200		9
#define INDEX_PE_PERIOD_200			10
#define INDEX_PE_OFFSET_200			11
#define INDEX_PE_SAMPLE_PERIOD_200	12
#define INDEX_PE_BUTTONMAP_200		13
#define INDEX_PE_BUTTONREPEAT_200	14
#define INDEX_PE_REPEAT_200			15

// ConstantForce Effect Modify Indecies
#define INDEX_CE_DURATION_200		0
#define INDEX_CE_GAIN_200			3
#define INDEX_CE_STARTPERCENT_200	4
#define INDEX_CE_ATTTACK_TIME_200	5
#define INDEX_CE_SUSTAINPERCENT_200 6
#define INDEX_CE_FADESTART_200		7
#define INDEX_CE_ENDPERCENT_200		8
#define INDEX_CE_MAGNITUDE_200		9
#define INDEX_CE_BUTTONMAP_200		11
#define INDEX_CE_BUTTONREPEAT_200	12
#define INDEX_CE_REPEAT_200			13

// Default system param defines (for 1XX)
#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

BYTE g_TriggerMap1XX[] = { 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80 };
BYTE g_TriggerMap200[] = { 0x00, 0x01, 0x02, 0x04, 0x10, 0x20, 0x40, 0x80, 0x08, 0x08, 0x08 };

/******************* Envelope1XX class *******************/
Envelope1XX::Envelope1XX(DIENVELOPE* pDIEnvelope, DWORD baseLine, DWORD duration)
{
	// Zero out this monster
	::memset(this, 0, sizeof(Envelope1XX));

	if (pDIEnvelope == NULL) {
		m_SustainTime = duration;
		m_SustainPercent = 100;
		return;
	}

	// Attack/sustain/decay sum to duration
	m_AttackTime = pDIEnvelope->dwAttackTime/ENVELOPE_TIME_TICKS_1XX;
	if (duration != INFINITE) {	// Inifinite duration has only attack
		m_SustainTime = (duration- pDIEnvelope->dwFadeTime)/ENVELOPE_TIME_TICKS_1XX;
	}

	// What is the real maximum
	DWORD maxAmp = baseLine;
	if (maxAmp < pDIEnvelope->dwAttackLevel) {
		maxAmp = pDIEnvelope->dwAttackLevel;
	}
	if (maxAmp < pDIEnvelope->dwFadeLevel) {
		maxAmp = pDIEnvelope->dwFadeLevel;
	}

	maxAmp /= 100; // For percentage conversion
	if (maxAmp == 0) { 	// Avoid a nasty division error
		m_SustainPercent = 100;	// Sustain is full (others are 0)
	} else {
		m_StartPercent = pDIEnvelope->dwAttackLevel/maxAmp;
		m_SustainPercent = baseLine/maxAmp;
		m_EndPercent = pDIEnvelope->dwFadeLevel/maxAmp;
	}
}


/******************* Envelope200 class *******************/
Envelope200::Envelope200(DIENVELOPE* pDIEnvelope, DWORD sustain, DWORD duration, HRESULT& hr)
{
	// Zero out this monster
	::memset(this, 0, sizeof(Envelope200));
	m_FadeStart = WORD(duration/DURATION_SCALE_200);

	DWORD calc = sustain;		// -- Modifcation above, now done on gain

	// DI Doesn't specify an envelope
	if (pDIEnvelope == NULL) {
		m_SustainPercent = BYTE(calc/GAIN_SCALE_200);	// Base sustain of magnitude
		return;
	}

	// The sun of attack and fade must be less than MAX_TIME
	if ((pDIEnvelope->dwAttackTime + pDIEnvelope->dwFadeTime) > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		if (pDIEnvelope->dwAttackTime > MAX_TIME_200) {
			pDIEnvelope->dwAttackTime = MAX_TIME_200;
		}
		pDIEnvelope->dwFadeTime = MAX_TIME_200 - pDIEnvelope->dwAttackTime;
	}

	// Attack/sustain/decay sum to duration
	m_AttackTime = WORD(pDIEnvelope->dwAttackTime/DURATION_SCALE_200);
	if (duration != INFINITE) {	// Inifinite duration has only attack (fade-time == DURATION)
		m_FadeStart = WORD((duration - pDIEnvelope->dwFadeTime)/DURATION_SCALE_200);
		if (m_FadeStart < m_AttackTime) {	// We don't want to fade before the end of the attack!
			m_FadeStart = m_AttackTime;
		}
	}

	m_SustainPercent = BYTE(float(calc)/GAIN_SCALE_200);
	calc = pDIEnvelope->dwAttackLevel;
	if (calc > 10000) {
		calc = 10000;
		hr = DI_TRUNCATED;
	}
	m_StartPercent = BYTE(float(calc)/GAIN_SCALE_200);
	calc = (pDIEnvelope->dwFadeLevel);
	if (calc > 10000) {
		calc = 10000;
		hr = DI_TRUNCATED;
	}
	m_EndPercent = BYTE(float(calc)/GAIN_SCALE_200);
}


/******************* InternalEffect class ******************/
InternalEffect::InternalEffect() :
	m_EffectID(0),
	m_DeviceEffectID(0),
	m_Duration(0),
	m_Gain(0),
	m_TriggerPlayButton(0),
	m_AxisMask(0),
	m_EffectAngle(0),
	m_PercentX(0),
	m_PercentY(0),
	m_PercentAdjustment(0),
	m_AxesReversed(FALSE),
	m_IsPossiblyPlaying(FALSE)
{
}

InternalEffect::~InternalEffect()
{
}


// Static Creation Functions
InternalEffect* InternalEffect::CreateSpring()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_SPRING);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_SPRING_200);
	}
}

InternalEffect* InternalEffect::CreateDamper()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_DAMPER);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_DAMPER_200);
	}
}

InternalEffect* InternalEffect::CreateInertia()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_INERTIA);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_INERTIA_200);
	}
}

InternalEffect* InternalEffect::CreateFriction()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new FrictionEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new FrictionEffect200();
	}
}

InternalEffect* InternalEffect::CreateRTCSpring()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new RTCSpring1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new RTCSpring200();
	}
}

InternalEffect* InternalEffect::CreateSystemEffect()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new SystemEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return NULL;	// NYI
	}
}

InternalEffect* InternalEffect::CreateSine()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_SINE);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_SINE_200);
	}
}

InternalEffect* InternalEffect::CreateSquare()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_SQUAREHIGH);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_SQUARE_200);
	}
}

InternalEffect* InternalEffect::CreateTriangle()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_TRIANGLEUP);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_TRIANGLE_200);
	}
}

InternalEffect* InternalEffect::CreateSawtoothUp()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new SawtoothEffect200(TRUE);
	}
}

InternalEffect* InternalEffect::CreateSawtoothDown()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new SawtoothEffect200(FALSE);
	}
}

InternalEffect* InternalEffect::CreateCustomForce()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new CustomForceEffect200();
	}
}

InternalEffect* InternalEffect::CreateConstantForce()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_CONSTANT_FORCE);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new ConstantForceEffect200();
	}
}

InternalEffect* InternalEffect::CreateRamp()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_RAMPUP);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new RampEffect200();
	}
}


InternalEffect* InternalEffect::CreateWall()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new WallEffect200();
	}
}

/*
InternalEffect* InternalEffect::CreateDelay()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new DelayEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect1XX(ET_DELAY_200);
	}
}
*/

InternalEffect* InternalEffect::CreateFromVFX(const DIEFFECT& diOriginal, EFFECT effect, ENVELOPE envelope, BYTE* pEffectParms, DWORD paramSize, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;

	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	}

	// Fill in the DIEFFECT structure
	DIEFFECT diEffect;
	diEffect.dwSize = sizeof(DIEFFECT);
	diEffect.dwFlags = DIEFF_POLAR | DIEFF_OBJECTOFFSETS;

	// Only set from file, if default is asked for
	if (diOriginal.dwDuration == DEFAULT_VFX_EFFECT_DURATION) {
		diEffect.dwDuration = effect.m_Duration * 1000;	// Zero will work as infinite just fine
	} else {
		diEffect.dwDuration = diOriginal.dwDuration;
	}

	// If zero is sent use the one from the file else use the one sent
	if (diOriginal.dwSamplePeriod == 0) {
		diEffect.dwSamplePeriod = 1000000/effect.m_ForceOutputRate;
	} else {
		diEffect.dwSamplePeriod = diOriginal.dwSamplePeriod;
	}

	// Only set from file if default is sent
	if (diOriginal.dwGain == DEFAULT_VFX_EFFECT_GAIN) {
		diEffect.dwGain = effect.m_Gain * 100;
	} else {
		diEffect.dwGain = diOriginal.dwGain;
	}

	// Need to find which bit is set
	if (diOriginal.dwTriggerButton == DIEB_NOTRIGGER) {
		if (effect.m_ButtonPlayMask == 0) {
			diEffect.dwTriggerButton = DIEB_NOTRIGGER;
		} else {
			DWORD butt = effect.m_ButtonPlayMask;
			short int buttNum = 0;
			while ((butt & 1) == 0) {
				butt >>= 1;
				buttNum++;
				ASSUME(buttNum >= 32);
			}
			diEffect.dwTriggerButton = DIDFT_MAKEINSTANCE(buttNum);
		}
		diEffect.dwTriggerRepeatInterval = 0;
	} else {
		diEffect.dwTriggerButton = diOriginal.dwTriggerButton;
		diEffect.dwTriggerRepeatInterval = diOriginal.dwTriggerRepeatInterval;
	}

	diEffect.cAxes = 2;
	diEffect.rgdwAxes = new DWORD[2];
	if (diEffect.rgdwAxes == NULL)
	{
		goto do_dealloc;
	}
	diEffect.rgdwAxes[0] = DIJOFS_X;
	diEffect.rgdwAxes[1] = DIJOFS_Y;

	diEffect.rglDirection = new LONG[2];
	if (diEffect.rglDirection == NULL)
	{
		goto do_dealloc;
	}
	if (diOriginal.rglDirection[0] == DEFAULT_VFX_EFFECT_DIRECTION) {
		diEffect.rglDirection[0] = effect.m_DirectionAngle2D * 100;
	} else {
		diEffect.rglDirection[0] = diOriginal.rglDirection[0];
	}
	diEffect.rglDirection[1] = 0;

	// Envelope
	diEffect.lpEnvelope = new DIENVELOPE;
	if (diEffect.lpEnvelope == NULL)
	{
		goto do_dealloc;
	}
	if (diOriginal.lpEnvelope != NULL) {
		::memcpy(diEffect.lpEnvelope, diOriginal.lpEnvelope, sizeof(DIENVELOPE));
	} else {
		diEffect.lpEnvelope->dwSize = sizeof(DIENVELOPE);
		diEffect.lpEnvelope->dwAttackLevel = envelope.m_StartAmp * (diEffect.dwGain/100);
		diEffect.lpEnvelope->dwFadeLevel = envelope.m_EndAmp * (diEffect.dwGain/100);
		diEffect.dwGain = diEffect.dwGain/100 * envelope.m_SustainAmp;
		if (envelope.m_Type == TIME) { // time is in MSECs
			diEffect.lpEnvelope->dwAttackTime = envelope.m_Attack * 1000;
			diEffect.lpEnvelope->dwFadeTime = envelope.m_Decay * 1000;
		} else {	// Percentage of total time
			diEffect.lpEnvelope->dwAttackTime = envelope.m_Attack * (diEffect.dwDuration/100);
			diEffect.lpEnvelope->dwFadeTime = envelope.m_Decay * (diEffect.dwDuration/100);
		}
	}

	diEffect.cbTypeSpecificParams = 0;
	diEffect.lpvTypeSpecificParams = NULL;

	switch(effect.m_Type) {
		case EF_BEHAVIOR: {
			DICONDITION* pDICondition = new DICONDITION[2];
			if (pDICondition == NULL)
			{
				goto do_dealloc;
			}
			::memset(pDICondition, 0, sizeof(DICONDITION) * 2);
			diEffect.cbTypeSpecificParams = sizeof(DICONDITION)*2;
			diEffect.lpvTypeSpecificParams = pDICondition;

			switch (effect.m_SubType) {	// Switch for parameter filling
				case BE_SPRING_2D:
				case BE_DAMPER_2D:
				case BE_INERTIA_2D: {
					BE_SPRING_2D_PARAM* pParams = (BE_SPRING_2D_PARAM*)pEffectParms;
					pDICondition[1].lOffset = pParams->m_YAxisCenter * 100;
					pDICondition[1].lPositiveCoefficient = pParams->m_YKconstant * 100;
					pDICondition[1].lNegativeCoefficient = pDICondition[1].lPositiveCoefficient;
					pDICondition[1].dwPositiveSaturation = 10000;
					pDICondition[1].dwNegativeSaturation = 10000;
					// purposely fall through for first axis
				}
				case BE_SPRING:
				case BE_DAMPER:
				case BE_INERTIA: {
					BE_SPRING_PARAM* pParams = (BE_SPRING_PARAM*)pEffectParms;
					pDICondition[0].lOffset = pParams->m_AxisCenter * 100;
					pDICondition[0].lPositiveCoefficient = pParams->m_Kconstant * 100;
					pDICondition[0].lNegativeCoefficient = pDICondition[0].lPositiveCoefficient;
					pDICondition[0].dwPositiveSaturation = 10000;
					pDICondition[0].dwNegativeSaturation = 10000;
					break;
				}
				case BE_FRICTION_2D: {
					BE_FRICTION_2D_PARAM* pParams = (BE_FRICTION_2D_PARAM*)pEffectParms;
					pDICondition[1].lPositiveCoefficient = pParams->m_YFconstant * 100;
					pDICondition[1].lNegativeCoefficient = pDICondition[1].lPositiveCoefficient;
					pDICondition[1].dwPositiveSaturation = 10000;
					pDICondition[1].dwNegativeSaturation = 10000;
					// purposely fall through for first axis
				}
				case BE_FRICTION: {
					BE_FRICTION_PARAM* pParams = (BE_FRICTION_PARAM*)pEffectParms;
					pDICondition[0].lPositiveCoefficient = pParams->m_Fconstant * 100;
					pDICondition[0].lNegativeCoefficient = pDICondition[0].lPositiveCoefficient;
					pDICondition[0].dwPositiveSaturation = 10000;
					pDICondition[0].dwNegativeSaturation = 10000;
					break;
				}
				case BE_WALL: {	// This one is strangly simple
					delete pDICondition;
					diEffect.cbTypeSpecificParams = sizeof(BE_WALL_PARAM);
					diEffect.lpvTypeSpecificParams = new BE_WALL_PARAM;
					if (diEffect.lpvTypeSpecificParams != NULL) {
						::memcpy(diEffect.lpvTypeSpecificParams, pEffectParms, sizeof(BE_WALL_PARAM));
						// need to convert to DI values
						BE_WALL_PARAM* pWallParms = (BE_WALL_PARAM*)(diEffect.lpvTypeSpecificParams);
						pWallParms->m_WallConstant = pWallParms->m_WallConstant * 100;
						pWallParms->m_WallAngle = pWallParms->m_WallAngle * 100;
						pWallParms->m_WallDistance = pWallParms->m_WallDistance * 100;
					}
					break;
				}
			}
			switch (effect.m_SubType) {	// Switch for Creation
				case BE_SPRING:
				case BE_SPRING_2D: {
					pReturnEffect = CreateSpring();
					break;
				}
				case BE_DAMPER:
				case BE_DAMPER_2D: {
					pReturnEffect = CreateDamper();
					break;
				}
				case BE_INERTIA:
				case BE_INERTIA_2D: {
					pReturnEffect = CreateInertia();
					break;
				}
				case BE_FRICTION:
				case BE_FRICTION_2D: {
					pReturnEffect = CreateFriction();
					break;
				}
				case BE_WALL: {
					pReturnEffect = CreateWall();
					break;
				}
			}
			pDICondition = NULL;
			break;
		}
		case EF_USER_DEFINED: {
			UD_PARAM* pParams = (UD_PARAM*)pEffectParms;
			DICUSTOMFORCE* pUserDefined = new DICUSTOMFORCE;
			if (pUserDefined != NULL) {
				diEffect.cbTypeSpecificParams = sizeof(DICUSTOMFORCE);
				diEffect.lpvTypeSpecificParams = pUserDefined;
				pUserDefined->cChannels = 1;
				pUserDefined->dwSamplePeriod = diEffect.dwSamplePeriod;
				pUserDefined->cSamples = pParams->m_NumVectors;
				pUserDefined->rglForceData = pParams->m_pForceData;	// Don't copy the data here, just push the pointer
				for (UINT nextSample = 0; nextSample < pUserDefined->cSamples; nextSample++) {
					ASSUME(pUserDefined->rglForceData[nextSample] <= 100 && pUserDefined->rglForceData[nextSample] >= -100);		// Assume it is in the SWForce range (-100..100)
					pUserDefined->rglForceData[nextSample] *= 100;
				}

				pReturnEffect = CreateCustomForce();
			}
			
			pUserDefined = NULL;
			break;
		}
		case EF_SYNTHESIZED: {	// Fill in the periodic structure
			SE_PARAM* pParams = (SE_PARAM*)pEffectParms;
			if (effect.m_SubType == SE_CONSTANT_FORCE) {	// Special case
				DICONSTANTFORCE* pCForce= new DICONSTANTFORCE;
				if (pCForce != NULL) {
					diEffect.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
					diEffect.lpvTypeSpecificParams = pCForce;
					pCForce->lMagnitude = pParams->m_MaxAmp * 100;
					pCForce = NULL;
					pReturnEffect = CreateConstantForce();
				}
				break;
			}
			if (effect.m_SubType == SE_RAMPUP || effect.m_SubType == SE_RAMPDOWN) {	// Yet another special case
				DIRAMPFORCE* pRForce = new DIRAMPFORCE;
				if (pRForce != NULL) {
					diEffect.cbTypeSpecificParams = sizeof(DIRAMPFORCE);
					diEffect.lpvTypeSpecificParams = pRForce;
					if (effect.m_SubType == SE_RAMPUP) {
						pRForce->lStart = pParams->m_MinAmp  * 100;
						pRForce->lEnd = pParams->m_MaxAmp * 100;
					} else {	// RampDown (special case of a special case)
						pRForce->lStart = pParams->m_MaxAmp  * 100;
						pRForce->lEnd = pParams->m_MinAmp * 100;
					}
					pRForce = NULL;
					pReturnEffect = CreateRamp();
				}
				break;
			}


			if (pParams->m_SampleRate == 0) {
				pParams->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			}
			if (effect.m_ForceOutputRate == 0) {
				effect.m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;
			}

			DIPERIODIC* pPeriodic = new DIPERIODIC;
			if (pPeriodic == NULL) {
				break;
			}
			diEffect.cbTypeSpecificParams = sizeof(DIPERIODIC);
			diEffect.lpvTypeSpecificParams = pPeriodic;
			pPeriodic->dwMagnitude = (pParams->m_MaxAmp - pParams->m_MinAmp)/2 * 100;
			pPeriodic->lOffset = (pParams->m_MaxAmp + pParams->m_MinAmp)/2 * 100;
			pPeriodic->dwPhase = 0;
			if (pParams->m_Freq == 0) {	// Avoid division by 0
				pPeriodic->dwPeriod = 0;
			} else {
				pPeriodic->dwPeriod = 1000000 / pParams->m_Freq;
			}

			switch (effect.m_SubType) {
				case SE_SINE: {
					pReturnEffect = CreateSine();
					break;
				}
				case SE_COSINE: {
					pPeriodic->dwPhase = 9000;
					pReturnEffect = CreateSine();
					break;
				}
				case SE_SQUAREHIGH: {
					pReturnEffect = CreateSquare();
					break;
				}
				case SE_SQUARELOW: {
					pPeriodic->dwPhase = 18000;
					pReturnEffect = CreateSquare();
					break;
				}
				case SE_TRIANGLEUP: {
					pReturnEffect = CreateTriangle();
					break;
				}
				case SE_TRIANGLEDOWN: {
					pPeriodic->dwPhase = 18000;
					pReturnEffect = CreateTriangle();
					break;
				}

				case SE_SAWTOOTHUP: {
					pReturnEffect = CreateSawtoothUp();
					break;
				}
				case SE_SAWTOOTHDOWN: {
					pReturnEffect = CreateSawtoothDown();
					break;
				}
			}
			pPeriodic = NULL;
			break;
		}
		case EF_RTC_SPRING: {
			diEffect.cbTypeSpecificParams = sizeof(RTCSPRING_PARAM);
			diEffect.lpvTypeSpecificParams = new RTCSPRING_PARAM;
			if (diEffect.lpvTypeSpecificParams != NULL) {
				::memcpy(diEffect.lpvTypeSpecificParams, pEffectParms, sizeof(RTCSPRING_PARAM));
				pReturnEffect = CreateRTCSpring();
			}
			break;
		}
	}

	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr)) {
			delete pReturnEffect;
			pReturnEffect = NULL;
		}
	}

do_dealloc:
	// Deallocate allocated DIEFFECT stuff
	if (diEffect.lpvTypeSpecificParams != NULL) {
		delete diEffect.lpvTypeSpecificParams;
	}
	if (diEffect.rglDirection != NULL) {
		delete diEffect.rglDirection;
	}
	if (diEffect.rgdwAxes != NULL) {
		delete diEffect.rgdwAxes;
	}
	if (diEffect.lpEnvelope != NULL) {
		delete diEffect.lpEnvelope;
	}

	return pReturnEffect;
}

HRESULT InternalEffect::Create(const DIEFFECT& diEffect)
{
	// We don't support more than 2 axes, and 0 is probably an error
	if ((diEffect.cAxes > 2) || (diEffect.cAxes == 0)) {
		return SFERR_NO_SUPPORT;
	}

	HRESULT hr = SUCCESS;

	// Set up the axis mask
	m_AxisMask = 0;
	for (unsigned int axisIndex = 0; axisIndex < diEffect.cAxes; axisIndex++) {
		DWORD axisNumber = DIDFT_GETINSTANCE(diEffect.rgdwAxes[axisIndex]);
		m_AxisMask |= 1 << axisNumber;
	}
	m_AxesReversed = (DIDFT_GETINSTANCE(diEffect.rgdwAxes[0]) == 1);

	// Set the trigger play button
	if (diEffect.dwTriggerButton != DIEB_NOTRIGGER) {
		m_TriggerPlayButton = DIDFT_GETINSTANCE(diEffect.dwTriggerButton) + 1;
		if (m_TriggerPlayButton == 9) { // We don't support button 9 playback (start button?)
			return SFERR_NO_SUPPORT;
		}
		if (m_TriggerPlayButton > 10) {	// We don't support mapping above 10
			return SFERR_NO_SUPPORT;
		}
	} else {
		m_TriggerPlayButton = 0;
	}

	m_TriggerRepeat = diEffect.dwTriggerRepeatInterval;
	if (m_TriggerRepeat > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_TriggerRepeat = MAX_TIME_200;
	}

	// Check coordinate sytems and change to polar
	if (diEffect.dwFlags & DIEFF_SPHERICAL) {	// We don't support sperical (3 axis force)
		return SFERR_NO_SUPPORT;				// .. since got by axis check, programmer goofed up
	}
	if (diEffect.dwFlags & DIEFF_POLAR) {
		if (diEffect.cAxes != 2) { // Polar coordinate must have two axes of data (because DX says so)
			return SFERR_INVALID_PARAM;
		}
		m_EffectAngle = diEffect.rglDirection[0];	// in [0] even if reversed
		if (m_AxesReversed) {		// Indicates (-1, 0) as origin instead of (0, -1)
			m_EffectAngle += 27000;
		}
		m_EffectAngle %= 36000;
	} else if (diEffect.dwFlags & DIEFF_CARTESIAN) { // Convert to polar
		if (diEffect.cAxes == 1) {	// Fairly easy conversion
			if (X_AXIS & m_AxisMask) {
				m_EffectAngle = 9000;
			} else {
				m_EffectAngle = 0;
			}
		} else { // Multiple axis cartiesian
			int xDirection = diEffect.rglDirection[0];
			int yDirection = diEffect.rglDirection[1];
			if (m_AxesReversed == TRUE) {
				yDirection = xDirection;
				xDirection = diEffect.rglDirection[1];
			}
			double angle = atan2(double(yDirection), double(xDirection)) * 180.0/3.14159;
			// Switch it to a proper quadrant integer
			int nAngle = 90;
			if (angle >= 0.0) {
				nAngle -= int(angle + 0.5);
			} else {
				nAngle -= int(angle - 0.5);
			}
			if (nAngle < 0) {
				nAngle += 360;
			} else if (nAngle >= 360) {
				nAngle -= 360;
			}
			m_EffectAngle = nAngle * 100;
		}
	} else {	// What, is there some other format?
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;	// Untill someone says otherwise there was an error
	}

	// Find the percent for each axis (for axis mapping)
	double projectionAngle = double(m_EffectAngle)/18000.0 * 3.14159;	// Convert to radians
	// Sin^2(a) + Cos^2(a) = 1
	double xProj = ::sin(projectionAngle);	// DI has 0 degs at (1, 0) not (0, 1)
	double yProj = ::cos(projectionAngle);
	xProj *= xProj;
	yProj *= yProj;
	m_PercentX = DWORD(xProj * 100.0 + 0.05);
	m_PercentY = DWORD(yProj * 100.0 + 0.05);

	// Duration and gain
	m_Duration = diEffect.dwDuration;
	if (m_Duration == INFINITE) {
		m_Duration = 0;		// 0 represents infinite
	} else if (m_Duration > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_Duration = MAX_TIME_200;
	}
	m_Gain = diEffect.dwGain;
	if (m_Gain > 10000) {
		hr = DI_TRUNCATED;
		m_Gain = 10000;
	}

	// Sample period
	m_SamplePeriod = diEffect.dwSamplePeriod;
	if (m_SamplePeriod > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_SamplePeriod = MAX_TIME_200;
	} else if (m_SamplePeriod == 0) {	// Indicates a default should be used
		m_SamplePeriod = 2000;	// 500htz is the default (2000 micro-secs period)
	}

	return hr;
}

HRESULT InternalEffect::Modify(InternalEffect& diEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	return SFERR_NO_SUPPORT;
}


BYTE InternalEffect::ComputeChecksum(const DataPacket& packet, short int numFields)
{
	if (packet.m_pData == NULL) {
		ASSUME_NOT_REACHED();
		return 0;
	}

	BYTE checkSum = 0;
	for (short int index = 5; index < numFields; index++) {	// Skip header
		checkSum += packet.m_pData[index];
	}
	return ((-checkSum) & 0x7f);
}

void InternalEffect::FillSysExHeader(DataPacket& packet) const
{
	// SysEx Header
	packet.m_pData[0] = SYS_EX_CMD;							// SysEX CMD
	packet.m_pData[1] = 0;									// Escape to Manufacturer ID
	packet.m_pData[2] = MS_MANUFACTURER_ID & 0x7f;			// Manufacturer High Byte
	packet.m_pData[3] = (MS_MANUFACTURER_ID >> 8) & 0x7f;	// Manufacturer Low Byte (note shifted 8!)
}

void InternalEffect::FillHeader1XX(DataPacket& packet, BYTE effectType, BYTE effectID) const
{
	FillSysExHeader(packet);
	packet.m_pData[4] = JOLT_PRODUCT_ID;					// Product ID

	// What to do params
	packet.m_pData[5] = DNLOAD_DATA | DL_PLAY_STORE | X_AXIS | Y_AXIS;	// OpCode
	packet.m_pData[6] = effectType;		// Effect Type
	packet.m_pData[7] = effectID;		// Effect or NEW_EFFECT_ID

	// Effect parms
	int duration = m_Duration/DURATION_SCALE_1XX;
	packet.m_pData[8] = BYTE(duration & 0x7F);					// Duration Low MidiByte
	packet.m_pData[9] = BYTE(duration >> 7) & 0x7F;				// Duration High MidiByte
}

void InternalEffect::FillHeader200(DataPacket& packet, BYTE effectType, BYTE effectID) const
{
	FillSysExHeader(packet);
	packet.m_pData[4] = ZEP_PRODUCT_ID;					// Product ID

	// What to do params
//	packet.m_pData[5] = DOWNLOAD_OP_200 | STORE_ACTION_200 | X_AXIS_200 | Y_AXIS_200;		// OpCode
	packet.m_pData[5] = (DOWNLOAD_OP_200 << 4) | (STORE_ACTION_200 << 2) | AXIS_ANGLE_200;	// OpCode
	packet.m_pData[6] = effectType;		// Effect Type
	packet.m_pData[7] = effectID;		// Effect or NEW_EFFECT_ID

	// Effect parms
	unsigned short int duration = 0;
	if (m_Duration != 0) {
		duration = unsigned short(m_Duration/DURATION_SCALE_200);
		if (duration == 0) {
			duration = 1;		// We don't want to round down to 0 (infinite)
		}
	}
	packet.m_pData[8] = BYTE(duration & 0x7F);				// Duration Low MidiByte
	packet.m_pData[9] = BYTE(duration >> 7) & 0x7F;			// Duration High MidiByte
}

HRESULT InternalEffect::FillModifyPacket1XX(BYTE packetIndex, BYTE paramIndex, DWORD value) const
{
	DataPacket* setIndexPacket = g_pDataPackager->GetPacket(packetIndex);
	if ((setIndexPacket == NULL) || (!setIndexPacket->AllocateBytes(3))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	setIndexPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	setIndexPacket->m_pData[1] = SET_INDEX | BYTE(paramIndex << 2);
	setIndexPacket->m_pData[2] = m_DeviceEffectID & 0x7F;
	setIndexPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	setIndexPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	// Packet to set modify data[index] of current effect
	DataPacket* modifyParamPacket = g_pDataPackager->GetPacket(packetIndex+1);
	if ((modifyParamPacket == NULL) || (!modifyParamPacket->AllocateBytes(3))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	modifyParamPacket->m_pData[0] = MODIFY_CMD | DEFAULT_MIDI_CHANNEL;
	modifyParamPacket->m_pData[1] = BYTE(value & 0x7f);
	modifyParamPacket->m_pData[2] = BYTE(value >> 7) & 0x7f;
	modifyParamPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyParamPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT InternalEffect::FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, DWORD value) const
{
	BYTE low = BYTE(value & 0x7F);
	BYTE high = BYTE(value >> 7) & 0x7F;
	return FillModifyPacket200(packetIndex, paramIndex, low, high);
}

HRESULT InternalEffect::FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, BYTE low, BYTE high) const
{
	DataPacket* modifyPacket = g_pDataPackager->GetPacket(packetIndex);
	if ((modifyPacket == NULL) || (!modifyPacket->AllocateBytes(6))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	BYTE id = m_DeviceEffectID;
	if (id == 0) {
		id = m_EffectID;
	}
	modifyPacket->m_pData[0] = MODIFY_CMD_200;
	modifyPacket->m_pData[1] = 0;	// Temporary for checksum calc.
	modifyPacket->m_pData[2] = paramIndex & 0x3F;
	modifyPacket->m_pData[3] = id & 0x7F;
	modifyPacket->m_pData[4] = low & 0x7F;
	modifyPacket->m_pData[5] = high & 0x7F;

	// New checksum method just to be annoying
	BYTE checksum = 0;
	for (int i = 0; i < 6; i++) {
		checksum += modifyPacket->m_pData[i];
	}
	checksum = 0 - checksum;
	checksum &= 0xFF;
	modifyPacket->m_pData[1] = BYTE(checksum & 0x7F);
	modifyPacket->m_pData[2] |= BYTE(checksum >> 1) & 0x40;

	modifyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

BOOL InternalEffect::IsReallyPlaying(BOOL& multiCheckStop)
{
	if (multiCheckStop == TRUE) {
		return m_IsPossiblyPlaying;
	}
	multiCheckStop = TRUE;

	if (m_IsPossiblyPlaying == FALSE) {
		return FALSE;
	}

	// Do actual check
	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->GetEffectStatus(m_DeviceEffectID);
	if (hr != SUCCESS) {
		return TRUE;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr != SUCCESS) {
		return TRUE;
	}

	// Use result returned by GetAckNackData in Transmit
	DWORD dwIn = ackNack.dwEffectStatus;

	// Interpret result (cooked RUNNING_MASK_200 becomes SWDEV_STS_EFFECT_RUNNING)
	m_IsPossiblyPlaying = ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & SWDEV_STS_EFFECT_RUNNING));

	return m_IsPossiblyPlaying;
}

/******************* BehviouralEffect class ******************/
HRESULT BehaviouralEffect::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// What axis is where
	short int xIndex = 0;
	short int yIndex = 1;
	if (m_AxesReversed) {	// Reverse the index
		xIndex = 1;
		yIndex = 0;
	}

	if (diEffect.cAxes == 2) {
		if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)) {	// Angled condition
			m_AxisMask &= ~Y_AXIS;	// Pretend there is only one axis
			xIndex = 0;	// Doesn't matter if reversed
		} else if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION) * 2) { // Two axis effect does no axis mapping
			m_PercentX = 100;
			m_PercentY = 0;
		} else {
			return SFERR_INVALID_PARAM;
		}
	}

	// Fill the type specific (reverses array if needed)
	BYTE* pTypeSpecificArray = (BYTE*)m_ConditionData;
	BYTE* pDITypeSpecific = (BYTE*)(diEffect.lpvTypeSpecificParams);

	if ((m_AxisMask & X_AXIS) != 0) {
		::memcpy(pTypeSpecificArray, pDITypeSpecific + xIndex, sizeof(DICONDITION));
	} else {
		::memset(pTypeSpecificArray, 0, sizeof(DICONDITION));	// No X zero it out
	}
	if ((m_AxisMask & Y_AXIS) != 0) {
		::memcpy(pTypeSpecificArray + sizeof(DICONDITION), pDITypeSpecific + yIndex, sizeof(DICONDITION));
	} else {
		::memset(pTypeSpecificArray + sizeof(DICONDITION), 0, sizeof(DICONDITION));	// No Y zero it out
	}

	// Fix for Andretti, it thinks 0 is default
	if (m_ConditionData[0].dwPositiveSaturation == 0) {
		m_ConditionData[0].dwPositiveSaturation = 10000;
	}
	if (m_ConditionData[0].dwNegativeSaturation == 0) {
		m_ConditionData[0].dwNegativeSaturation = 10000;
	}

	// Check for overzealous numbers
	for (UINT i = 0; i < diEffect.cAxes; i++) {
		if (m_ConditionData[0].lOffset > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lOffset = 10000;
		} else if (m_ConditionData[0].lOffset < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lOffset = 10000;
		}
		if (m_ConditionData[0].lPositiveCoefficient > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lPositiveCoefficient = 10000;
		} else if (m_ConditionData[0].lPositiveCoefficient < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lPositiveCoefficient = -10000;
		}
		if (m_ConditionData[0].lNegativeCoefficient > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lNegativeCoefficient = 10000;
		} else if (m_ConditionData[0].lNegativeCoefficient < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lNegativeCoefficient = -10000;
		}
		if (m_ConditionData[0].dwPositiveSaturation > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].dwPositiveSaturation = 10000;
		}
		if (m_ConditionData[0].dwNegativeSaturation > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].dwNegativeSaturation = 10000;
		}
		if (m_ConditionData[0].lDeadBand > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lDeadBand = 10000;
		} else if (m_ConditionData[0].lDeadBand < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lDeadBand = -10000;
		}
	}
	
	return hr;
}

/******************* BehaviouralEffect1XX class ******************/
HRESULT BehaviouralEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte

	// Behavioural Specific Parms
	int twoByte = ((ConstantX()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[12]= twoByte & 0x7F;				// Spring/Damper/... Constant X Low
	packet.m_pData[13]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant X High
	twoByte = ((ConstantY()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[14]= twoByte & 0x7F;				// Spring/Damper/... Constant Y Low
	packet.m_pData[15]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant Y High
	twoByte = CenterX()/COEFFICIENT_SCALE_1XX;
	packet.m_pData[16]= twoByte & 0x7F;				// Spring/Damper/... Center X Low
	packet.m_pData[17]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Center X High
	twoByte = CenterY()/COEFFICIENT_SCALE_1XX;
	packet.m_pData[18]= twoByte & 0x7F;				// Spring/Damper/... Center Y Low
	packet.m_pData[19]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Center Y High
	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT BehaviouralEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	AdjustModifyParams(newEffect, modFlags);

	HRESULT hr = SUCCESS;
	BehaviouralEffect1XX* pEffect = (BehaviouralEffect1XX*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_DURATION, pEffect->m_Duration/DURATION_SCALE_1XX);
		nextPacket += 2;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_TRIGGERBUTTONMASK, g_TriggerMap1XX[pEffect->m_TriggerPlayButton]);
		nextPacket += 2;
	}

	BOOL gainChanged = modFlags & DIEP_GAIN;
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Find which ones
		if (ConstantX() != pEffect->ConstantX() || gainChanged) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT,
				((pEffect->ConstantX()/COEFFICIENT_SCALE_1XX) * pEffect->m_Gain) / GAIN_PERCENTAGE_SCALE);
			nextPacket += 2;
		}
		if (ConstantY() != pEffect->ConstantY() || gainChanged) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_Y_COEEFICIENT,
				((pEffect->ConstantY()/COEFFICIENT_SCALE_1XX) * pEffect->m_Gain) / GAIN_PERCENTAGE_SCALE);
			nextPacket += 2;
		}
		if (m_HasCenter == TRUE) {
			if (CenterX() != pEffect->CenterX()) {
				hr = FillModifyPacket1XX(nextPacket, INDEX_X_CENTER, pEffect->CenterX()/COEFFICIENT_SCALE_1XX);
				nextPacket += 2;
			}
			if (CenterY() != pEffect->CenterY()) {
				hr = FillModifyPacket1XX(nextPacket, INDEX_Y_CENTER, pEffect->CenterY()/COEFFICIENT_SCALE_1XX);
			}
		}
	}

	return hr;
}

void BehaviouralEffect1XX::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return;
	}

	BehaviouralEffect1XX* pEffect = (BehaviouralEffect1XX*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			numPackets += 2;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets += 2;
		}
	}

	int numTypeSpecificChanged = 0;
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		numTypeSpecificChanged = 4;
	} else {
		modFlags &= ~DIEP_GAIN;
	}

	// If type specific or gain
	if ((modFlags & DIEP_TYPESPECIFICPARAMS) || (numTypeSpecificChanged == 0)) { // Find which ones
		if (numTypeSpecificChanged == 0) {	// Kx, Ky not already taken care of by gain?
			if (ConstantX() != pEffect->ConstantX()) {
				numTypeSpecificChanged = 2;
			}
			if (ConstantY() != pEffect->ConstantY()) {
				numTypeSpecificChanged += 2;
			}
		}
		if ((m_HasCenter == TRUE) && (modFlags & DIEP_TYPESPECIFICPARAMS)) { // Don't check these if gain only
			if (CenterX() != pEffect->CenterX()) {
				numTypeSpecificChanged += 2;
			}
			if (CenterY() != pEffect->CenterY()) {
				numTypeSpecificChanged += 2;
			}

		}
	}
	if (numTypeSpecificChanged == 0) {
		modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
	} else {
		numPackets += (unsigned short)numTypeSpecificChanged;
	}

	if (numPackets == 0) {	// That was easy nothing changed
		return;
	}

	g_pDataPackager->AllocateDataPackets(numPackets);
}

/******************* RTCSpring1XX class ******************/
RTCSpring1XX::RTCSpring1XX() : BehaviouralEffect()
{
	m_EffectID = SYSTEM_RTCSPRING_ID;

	// Set defaults
	m_ConditionData[0].lPositiveCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lPositiveCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lOffset = DEFAULT_RTC_X0;
	m_ConditionData[1].lOffset = DEFAULT_RTC_Y0;
	m_ConditionData[0].dwPositiveSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwPositiveSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].lDeadBand = DEFAULT_RTC_XDBAND;
	m_ConditionData[1].lDeadBand = DEFAULT_RTC_YDBAND;
}

HRESULT RTCSpring1XX::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	if (diEffect.cbTypeSpecificParams != sizeof(DICONDITION) * 2) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Get the data
	DICONDITION* condition = (DICONDITION*)(diEffect.lpvTypeSpecificParams);
	m_ConditionData[0].lPositiveCoefficient = condition[0].lPositiveCoefficient;
	m_ConditionData[1].lPositiveCoefficient = condition[1].lPositiveCoefficient;
	m_ConditionData[0].lOffset = condition[0].lOffset;
	m_ConditionData[1].lOffset = condition[1].lOffset;
	m_ConditionData[0].dwPositiveSaturation = condition[0].dwPositiveSaturation;
	m_ConditionData[1].dwPositiveSaturation = condition[1].dwPositiveSaturation;
	m_ConditionData[0].lDeadBand = condition[0].lDeadBand;
	m_ConditionData[1].lDeadBand = condition[1].lDeadBand;

	return SUCCESS;
}

HRESULT RTCSpring1XX::FillCreatePacket(DataPacket& packet) const
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

HRESULT RTCSpring1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	g_pDataPackager->ClearPackets();

	RTCSpring1XX* pNewRTCSpring = (RTCSpring1XX*)(&newEffect);

	// Find number of packets needed
	unsigned short numPackets = 0;
	if (ConstantX() != pNewRTCSpring->ConstantX()) {
		numPackets += 2;
	}
	if (ConstantY() != pNewRTCSpring->ConstantY()) {
		numPackets += 2;
	}
	if (CenterX() != pNewRTCSpring->CenterX()) {
		numPackets += 2;
	}
	if (CenterY() != pNewRTCSpring->CenterY()) {
		numPackets += 2;
	}
	if (SaturationX() != pNewRTCSpring->SaturationX()) {
		numPackets += 2;
	}
	if (SaturationY() != pNewRTCSpring->SaturationY()) {
		numPackets += 2;
	}
	if (DeadBandX() != pNewRTCSpring->DeadBandX()) {
		numPackets += 2;
	}
	if (DeadBandY() != pNewRTCSpring->DeadBandY()) {
		numPackets += 2;
	}

	if (numPackets == 0) {
		return SUCCESS;
	}

	// Allocate a packets for sending modify command
	if (!g_pDataPackager->AllocateDataPackets(numPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill the packets
	BYTE nextPacket = 0;
	if (ConstantX() != pNewRTCSpring->ConstantX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_COEEFICIENT_X, pNewRTCSpring->ConstantX());
		nextPacket += 2;
	}
	if (ConstantY() != pNewRTCSpring->ConstantY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_COEEFICIENT_Y, pNewRTCSpring->ConstantY());
		nextPacket += 2;
	}
	if (CenterX() != pNewRTCSpring->CenterX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_CENTER_X, pNewRTCSpring->CenterX());
		nextPacket += 2;
	}
	if (CenterY() != pNewRTCSpring->CenterY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_CENTER_Y, pNewRTCSpring->CenterY());
		nextPacket += 2;
	}
	if (SaturationX() != pNewRTCSpring->SaturationX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_SATURATION_X, pNewRTCSpring->SaturationX());
		nextPacket += 2;
	}
	if (SaturationY() != pNewRTCSpring->SaturationY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_SATURATION_Y, pNewRTCSpring->SaturationY());
		nextPacket += 2;
	}
	if (DeadBandX() != pNewRTCSpring->DeadBandX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_DEADBAND_X, pNewRTCSpring->DeadBandX());
		nextPacket += 2;
	}
	if (DeadBandY() != pNewRTCSpring->DeadBandY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_DEADBAND_Y, pNewRTCSpring->DeadBandY());
	}
	
	return SUCCESS;
}

/******************* BehaviouralEffect200 class ******************/
BYTE BehaviouralEffect200::GetRepeatIndex() const
{
	return INDEX_BE_REPEAT_200;
}

void BehaviouralEffect200::ComputeDsAndFs()
{
	// Assume single axis for now (X) - Will have to add second axis mapping

	// Figure out distances
//	long int d2 = m_ConditionData[0].lOffset - m_ConditionData[0].lDeadBand;
//	long int d3 = m_ConditionData[0].lOffset + m_ConditionData[0].lDeadBand;
	long int d2 = - m_ConditionData[0].lDeadBand;
	long int d3 = m_ConditionData[0].lDeadBand;
	long int d1 = -10000;
	long int d4 = 10000;

	// Compute force at -100 percent position
	float negCoeff = float(m_ConditionData[0].lNegativeCoefficient)/float(10000.0);
	long int f100Neg = long int((10000 + d2) * negCoeff);
	// Check vs proper saturation
	if (negCoeff > 0) {
		if (unsigned long(f100Neg) > m_ConditionData[0].dwNegativeSaturation) {
			f100Neg = m_ConditionData[0].dwNegativeSaturation;
			d1 = long int (-1 * f100Neg/negCoeff) - d2;	// Refigure D1
		}
	} else if (negCoeff < 0) {
		if (unsigned long(-f100Neg) > m_ConditionData[0].dwNegativeSaturation) {
			f100Neg = -1 * m_ConditionData[0].dwNegativeSaturation;
			d1 = long int (-1 * f100Neg/negCoeff) - d2;	// Refigure D1
		}
	}
	// Compute Force include axis-mapping
	f100Neg = long int(f100Neg/100 * (m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100));
	m_Fs[0] = BYTE(float(f100Neg/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;

	// Compute force at +100 percent position
	float posCoeff = float(-m_ConditionData[0].lPositiveCoefficient)/float(10000.0);
	long int f100Pos = long int((10000 - d3) * posCoeff);
	// Check vs proper saturation
	if (posCoeff > 0) {
		if (unsigned long(f100Pos) > m_ConditionData[0].dwPositiveSaturation) {
			f100Pos = m_ConditionData[0].dwPositiveSaturation;
			d4 = long int (f100Pos/posCoeff) + d3;	// Refigure D4
		}
	} else if (posCoeff < 0) {
		if (unsigned long(-f100Pos) > m_ConditionData[0].dwPositiveSaturation) {
			f100Pos = -1 * m_ConditionData[0].dwPositiveSaturation;
			d4 = long int(f100Pos/posCoeff) + d3;	// Refigure D4
		}
	}
	// Compute Force include axis-mapping
	f100Pos = long int(f100Pos/100 * (m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100));
	m_Fs[3] = BYTE(float(f100Pos/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;


	// Convert to device percentages (0 to +126 --- +63 = 0 percent)
	m_Ds[0] = BYTE(float(d1/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[1] = BYTE(float(d2/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[2] = BYTE(float(d3/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[3] = BYTE(float(d4/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;

	if (m_TypeID == ET_SPRING_200) {	// Add proper offsets (squished by max percent)
		// Convert forces to device percentages (0 to +126 --- +63 = 0 percent)
		// m_Fs[0] - Done above
		LONG offset = LONG(float(float(g_ForceFeedbackDevice.GetSpringOffset())/10000.0) * float(f100Neg));
		m_Fs[1] = BYTE(float(offset/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		offset = LONG(float(float(g_ForceFeedbackDevice.GetSpringOffset())/10000.0) * float(f100Pos));
		m_Fs[2] = BYTE(float(offset/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		// m_Fs[3] - Done above
	} else {
		// Convert forces to device percentages (0 to +126 --- +63 = 0 percent)
		// m_Fs[0] - Done above
		m_Fs[1] = 63;	// 0
		m_Fs[2] = 63;	// 0
		// m_Fs[3] - Done above
	}
}

HRESULT BehaviouralEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = BehaviouralEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Compute behavioural params
	ComputeDsAndFs();
	return hr;
}

UINT BehaviouralEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) { // Gain
		retCount++;
	}
	if (m_ConditionData[0].lOffset != 0) {	// Center of behaviour
		retCount++;
	}

	return retCount;
}

HRESULT BehaviouralEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) { // Gain
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}
	if (m_ConditionData[0].lOffset != 0) { // Center of behaviour
		long int deviceUnits = m_ConditionData[0].lOffset/BEHAVIOUR_CENTER_SCALE_200 + BEHAVIOUR_CENTER_200;
		BYTE lowByte = BYTE(deviceUnits & 0x7F);
		BYTE highByte = BYTE(deviceUnits >> 7) & 0x7F;
		hr = FillModifyPacket200(nextPacket, INDEX_BE_CENTER_200, lowByte, highByte);
		nextPacket++;
	}

	return hr;
}

HRESULT BehaviouralEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(21)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	unsigned short effectAngle = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(effectAngle & 0x7F);		// Effect Angle

	// Computed in create
	packet.m_pData[11]= m_Ds[0];
	packet.m_pData[12]= m_Fs[0];
	packet.m_pData[13]= m_Ds[1];
	packet.m_pData[14]= m_Fs[1];
	packet.m_pData[15]= m_Ds[2];
	packet.m_pData[16]= m_Fs[2];
	packet.m_pData[17]= m_Ds[3];
	packet.m_pData[18]= m_Fs[3];

	// End this puppy
	packet.m_pData[19]= ComputeChecksum(packet, 19);	// Checksum
	packet.m_pData[20]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}


HRESULT BehaviouralEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	BehaviouralEffect200* pEffect = (BehaviouralEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_GAIN) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		for (int i = 0; i < 4; i++) {
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				hr = FillModifyPacket200(nextPacket, INDEX_D1F1_200 + i, pEffect->m_Ds[i], pEffect->m_Fs[i]);
				nextPacket++;
			}
		}
		if (m_ConditionData[0].lOffset != pEffect->m_ConditionData[0].lOffset) { // Center of behaviour
			long int deviceUnits = pEffect->m_ConditionData[0].lOffset/BEHAVIOUR_CENTER_SCALE_200 + BEHAVIOUR_CENTER_200;
			BYTE lowByte = BYTE(deviceUnits & 0x7F);
			BYTE highByte = BYTE(deviceUnits >> 7) & 0x7F;
			hr = FillModifyPacket200(nextPacket, INDEX_BE_CENTER_200, lowByte, highByte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}

	return hr;
}

HRESULT BehaviouralEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_DIRECTION;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/
	BehaviouralEffect200* pEffect = (BehaviouralEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;;

	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { // Find which ones (if any)
		int numTypeSpecificChanged = 0;
		for (int i = 0; i < 4; i++) {
			// Ds and Fs are changed togeather
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				numTypeSpecificChanged++;
			}
		}
		if (m_ConditionData[0].lOffset != pEffect->m_ConditionData[0].lOffset) { // Center of behaviour
			numTypeSpecificChanged++;
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {	// Was anything really changed
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* RTCSpring200 class ******************/
RTCSpring200::RTCSpring200() : BehaviouralEffect200(ET_SPRING_200)
{
	m_EffectID = ID_RTCSPRING_200;

	// Set defaults
	m_ConditionData[0].lPositiveCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lPositiveCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lNegativeCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lNegativeCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lOffset = DEFAULT_RTC_X0;
	m_ConditionData[1].lOffset = DEFAULT_RTC_Y0;
	m_ConditionData[0].dwPositiveSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwPositiveSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].dwNegativeSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwNegativeSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].lDeadBand = DEFAULT_RTC_XDBAND;
	m_ConditionData[1].lDeadBand = DEFAULT_RTC_YDBAND;
}

HRESULT RTCSpring200::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)*2) {
		::memcpy(m_ConditionData, diEffect.lpvTypeSpecificParams, sizeof(DICONDITION)*2);
	} else if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)) {
		::memcpy(m_ConditionData, diEffect.lpvTypeSpecificParams, sizeof(DICONDITION));
		::memset(m_ConditionData + 1, 0, sizeof(DICONDITION));
	} else if (diEffect.cbTypeSpecificParams == sizeof(RTCSPRING_PARAM)) {
		::memset(m_ConditionData, 0, sizeof(DICONDITION)*2);

		RTCSPRING_PARAM* pOldRTCParam = (RTCSPRING_PARAM*)(diEffect.lpvTypeSpecificParams);
		m_ConditionData[0].lPositiveCoefficient = pOldRTCParam->m_XKConstant;
		m_ConditionData[1].lPositiveCoefficient = pOldRTCParam->m_YKConstant;
		m_ConditionData[0].lNegativeCoefficient = pOldRTCParam->m_XKConstant;
		m_ConditionData[1].lNegativeCoefficient = pOldRTCParam->m_YKConstant;
		m_ConditionData[0].lOffset = pOldRTCParam->m_XAxisCenter;
		m_ConditionData[1].lOffset = pOldRTCParam->m_YAxisCenter;
		m_ConditionData[0].dwPositiveSaturation = DWORD(pOldRTCParam->m_XSaturation);
		m_ConditionData[1].dwPositiveSaturation = DWORD(pOldRTCParam->m_YSaturation);
		m_ConditionData[0].dwNegativeSaturation = DWORD(pOldRTCParam->m_XSaturation);
		m_ConditionData[1].dwNegativeSaturation = DWORD(pOldRTCParam->m_YSaturation);
		m_ConditionData[0].lDeadBand = pOldRTCParam->m_XDeadBand;
		m_ConditionData[1].lDeadBand = pOldRTCParam->m_YDeadBand;
	} else {
		return SFERR_INVALID_PARAM;
	}

	// Check parameters for truncation
	BOOL truncated = FALSE;
	if (m_ConditionData[0].lPositiveCoefficient > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lPositiveCoefficient = 10000;
	} else 	if (m_ConditionData[0].lPositiveCoefficient < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lPositiveCoefficient = -10000;
	}
	if (m_ConditionData[0].lNegativeCoefficient > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lNegativeCoefficient = 10000;
	} else 	if (m_ConditionData[0].lNegativeCoefficient < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lNegativeCoefficient = -10000;
	}
	if (m_ConditionData[0].lOffset > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lOffset = 10000;
	} else 	if (m_ConditionData[0].lOffset < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lOffset = -10000;
	}
	if (m_ConditionData[0].dwPositiveSaturation > 10000) {
		truncated = TRUE;
		m_ConditionData[0].dwPositiveSaturation  = 10000;
	}
	if (m_ConditionData[0].dwNegativeSaturation > 10000) {
		truncated = TRUE;
		m_ConditionData[0].dwNegativeSaturation = 10000;
	}
	if (m_ConditionData[0].lDeadBand > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lDeadBand = 10000;
	} else 	if (m_ConditionData[0].lDeadBand < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lDeadBand = -10000;
	}

	m_PercentX = 100;
	m_PercentY = 0;

	// Compute behavioural params
	ComputeDsAndFs();
	if (truncated == TRUE) {
		return DI_TRUNCATED;
	}
	return SUCCESS;
}

HRESULT RTCSpring200::FillCreatePacket(DataPacket& packet) const
{
	return SUCCESS;
}

UINT RTCSpring200::GetModifyOnlyNeeded() const
{
	return 3;	// One is added for create. There is no Create, so we return 1 less than needed
}

HRESULT RTCSpring200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	for (BYTE i = 0; i < 4; i++) {
		FillModifyPacket200(i, INDEX_D1F1_200 + i, m_Ds[i], m_Fs[i]);
	}

	return SUCCESS;
}


HRESULT RTCSpring200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	g_pDataPackager->AllocateDataPackets(4);
	RTCSpring200* pNewRTCSpring = (RTCSpring200*)(&newEffect);
	for (BYTE i = 0; i < 4; i++) {
		FillModifyPacket200(i, INDEX_D1F1_200 + i, pNewRTCSpring->m_Ds[i], pNewRTCSpring->m_Fs[i]);
	}

	return SUCCESS;
}


/************** FictionEffect1XX class **********************/
override HRESULT FrictionEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte

	// Friction Specific Parms
	int twoByte = ((ConstantX()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[12]= twoByte & 0x7F;				// Spring/Damper/... Constant X Low
	packet.m_pData[13]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant X High
	twoByte = ((ConstantY()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[14]= twoByte & 0x7F;				// Spring/Damper/... Constant Y Low
	packet.m_pData[15]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant Y High

	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

/******************* FrictionEffect200 class *********************/
BYTE FrictionEffect200::GetRepeatIndex() const
{
	return INDEX_FE_REPEAT_200;
}

UINT FrictionEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) {	// Gain
		retCount++;
	}

	return retCount;
}

HRESULT FrictionEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) {	// Gain
		hr = FillModifyPacket200(nextPacket, INDEX_FE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	return hr;
}

HRESULT FrictionEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(14)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	unsigned short effectAngle = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(effectAngle & 0x7F);		// Effect Angle

	// Computed in create
	packet.m_pData[11]= BYTE(float(ConstantX() + 10000)/FRICTION_SCALE_200) & 0x7F;

	// End this puppy
	packet.m_pData[12]= ComputeChecksum(packet, 12);	// Checksum
	packet.m_pData[13]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT FrictionEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();

	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	FrictionEffect200* pEffect = (FrictionEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	DWORD calc_byte;

	HRESULT hr = SUCCESS;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		calc_byte = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_FE_GAIN_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		calc_byte = DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (ConstantX() != pEffect->ConstantX()) {
			calc_byte = DWORD(float(pEffect->ConstantX() + 10000)/FRICTION_SCALE_200) & 0x7F;
			hr = FillModifyPacket200(nextPacket, INDEX_FE_COEEFICIENT_200, calc_byte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT FrictionEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_DIRECTION;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/

	FrictionEffect200* pEffect = (FrictionEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	BOOL playingChecked = FALSE;
	HRESULT hr = SUCCESS;

	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger reapeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { 	// Type specific change flagged
		// Computed in create
		if (ConstantX() == pEffect->ConstantX()) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing really changed
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* PeriodicEffect class *********************/
PeriodicEffect::PeriodicEffect() : InternalEffect(),
	m_pEnvelope(NULL)
{
	::memset(&m_PeriodicData, 0, sizeof(m_PeriodicData));
}

PeriodicEffect::~PeriodicEffect()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

HRESULT PeriodicEffect::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_PeriodicData)) {
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Fill the type specific
	::memcpy(&m_PeriodicData, diEffect.lpvTypeSpecificParams, sizeof(m_PeriodicData));
	if (m_PeriodicData.dwMagnitude > 10000) {
		m_PeriodicData.dwMagnitude = 10000;
		hr = DI_TRUNCATED;
	}
	if (m_PeriodicData.lOffset > 10000) {
		m_PeriodicData.lOffset = 10000;
		hr = DI_TRUNCATED;
	} else if (m_PeriodicData.lOffset < -10000) {
		m_PeriodicData.lOffset = -10000;
		hr = DI_TRUNCATED;
	}
	if (m_PeriodicData.dwPeriod > MAX_TIME_200) {
		m_PeriodicData.dwPeriod = MAX_TIME_200;
		hr = DI_TRUNCATED;
	}

	return hr;
}

/******************* PeriodicEffect1XX class ******************/
HRESULT PeriodicEffect1XX::Create(const DIEFFECT& diEffect)
{
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();	// DI is flaking
		return SFERR_INVALID_PARAM;
	}

	HRESULT hr;
	if (diEffect.cbTypeSpecificParams == sizeof(DICONSTANTFORCE)) {	// Special case Constant Force
		if (m_TypeID != ET_SE_CONSTANT_FORCE) {
			ASSUME_NOT_REACHED();	// DI is flaking
			return SFERR_INVALID_PARAM;
		}
		DIPERIODIC periodic;
		DICONSTANTFORCE* pConstantForce = (DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams);
		if (pConstantForce->lMagnitude < 0) {
			periodic.lOffset = -1;	// We use offset to indicate sign
			periodic.dwMagnitude = DWORD(0 - pConstantForce->lMagnitude);
		} else {
			periodic.lOffset = 1;
			periodic.dwMagnitude = DWORD(pConstantForce->lMagnitude);
		}
		periodic.dwPhase = 0;
		periodic.dwPeriod = 0;	// Conversion will make a freq of 1
		DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
		pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
		pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Constant Force Parms with periodic
		hr = PeriodicEffect::Create(diEffect);
		pDIEffect->cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
		pDIEffect->lpvTypeSpecificParams = pConstantForce;	// Return parms back
	} else if (diEffect.cbTypeSpecificParams == sizeof(DIRAMPFORCE)) {	// Special case RampForce
		if (m_TypeID != ET_SE_RAMPUP) {
			ASSUME_NOT_REACHED();	// DI is flaking
			return SFERR_INVALID_PARAM;
		}
		DIPERIODIC periodic;
		DIRAMPFORCE* pRampForce = (DIRAMPFORCE*)(diEffect.lpvTypeSpecificParams);
		if (pRampForce->lStart < pRampForce->lEnd) {
			m_TypeID = ET_SE_RAMPDOWN;
			periodic.dwMagnitude = DWORD(pRampForce->lEnd - pRampForce->lStart)/2;
		} else {
			periodic.dwMagnitude = DWORD(pRampForce->lStart - pRampForce->lEnd)/2;
		}
		periodic.lOffset = (pRampForce->lStart + pRampForce->lEnd)/2;
		periodic.dwPeriod = 0;	// Conversion will make a freq of 1
		DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
		pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
		pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Constant Force Parms with periodic
		hr = PeriodicEffect::Create(diEffect);
		pDIEffect->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
		pDIEffect->lpvTypeSpecificParams = pRampForce;	// Return parms back
	} else {
		hr = PeriodicEffect::Create(diEffect);
	}

	// How did creation go?
	if (hr != SUCCESS) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_pEnvelope = new Envelope1XX(diEffect.lpEnvelope, Offset(), m_Duration);

	// Is it closer to sine or cosine
	if (m_TypeID == ET_SE_SINE) {
		if (((Phase() >= 4500) && (Phase() < 13500)) || ((Phase() >= 22500) && (Phase() < 31500))) {
			m_TypeID = ET_SE_COSINE;
		}
	} else if ((Phase() >= 9000) && (Phase() < 27000)) {
		if (m_TypeID == SE_SQUAREHIGH) {
			m_TypeID = SE_SQUARELOW;
		} else if (m_TypeID == SE_TRIANGLEUP) {
			m_TypeID = SE_TRIANGLEDOWN;
		}
	}
	return SUCCESS;
}

void PeriodicEffect1XX::DIToJolt(DWORD mag, DWORD off, DWORD gain, DWORD& max, DWORD& min) const
{
	if (m_TypeID == ET_SE_CONSTANT_FORCE) {
		ASSUME(off == -1 || off == 1);	// Indicates sign for ConstantForce
		min = 0;
		max = off * (mag/GAIN_PERCENTAGE_SCALE) * gain;
	} else {
		DWORD half = ((mag/GAIN_PERCENTAGE_SCALE) * gain)/2;
		min = off - half;
		max = off + half;
	}
}

DWORD PeriodicEffect1XX::DIPeriodToJoltFreq(DWORD period)
{
	if (period == 0) {
		return 1;
	}
	DWORD freq = FREQUENCY_SCALE_1XX/period;
	if (freq == 0) {
		freq = 1;
	} else if (freq > 500) {
		freq = 500;
	}
	return freq;
}


HRESULT PeriodicEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(34)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	// Periodic Specific Parms (Freq, Max, Min)
	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte
	packet.m_pData[12] = BYTE(m_EffectAngle & 0x7F);			// DirectionAngle Low
	packet.m_pData[13] = BYTE(m_EffectAngle >> 7) & 0x7F;	// DirectionAngle High
	packet.m_pData[14] = 100;							// Gain (encoded in coeficents)
	packet.m_pData[15]= BYTE(500 & 0x7F);					// ForceOutput Rate LowByte
	packet.m_pData[16]= BYTE(500 >> 7) & 0x7F;			// ForceOutput Rate HighByte
	packet.m_pData[17]= 0x7F;						// Percent LowByte
	packet.m_pData[18]= 0;							// Percent HighByte

	// Envelope
//	Envelope1XX* pEnvelope = dynamic_cast<Envelope1XX*>(m_pEnvelope);
	Envelope1XX* pEnvelope = (Envelope1XX*)(m_pEnvelope);
	packet.m_pData[19] = BYTE(pEnvelope->m_StartPercent & 0x7F);		// Initial attack level
	packet.m_pData[20] = BYTE(pEnvelope->m_AttackTime& 0x7F);			// AttackTime Low
	packet.m_pData[21] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;		// AttackTime High
	packet.m_pData[22] = BYTE(pEnvelope->m_SustainPercent & 0x7F);		// Sustain level
	packet.m_pData[23] = BYTE(pEnvelope->m_SustainTime & 0x7F);			// SustainTime Low
	packet.m_pData[24] = BYTE(pEnvelope->m_SustainTime >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[25] = BYTE(pEnvelope->m_EndPercent & 0x7F);			// What to decay to
	// --  Duration of decay is ficugred from total duration

	DWORD freq = DIPeriodToJoltFreq(Period());
	packet.m_pData[26]= BYTE(freq & 0x7F);				// Frequency LowByte
	packet.m_pData[27]= BYTE(freq >> 7) & 0x7F;			// Frequency HighByte
	DWORD max, min;
	DIToJolt(Magnitude(), Offset(), m_Gain, max, min);
	min /= COEFFICIENT_SCALE_1XX;
	max /= COEFFICIENT_SCALE_1XX;
	packet.m_pData[28]= BYTE(max & 0x7F);			// Max LowByte
	packet.m_pData[29]= BYTE(max >> 7) & 0x7F;		// Max HighByte
	packet.m_pData[30]= BYTE(min & 0x7F);			// Min LowByte
	packet.m_pData[31]= BYTE(min >> 7) & 0x7F;		// Min HighByte

	packet.m_pData[32]= ComputeChecksum(packet, 32);	// Checksum

	// End of packet
	packet.m_pData[33]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT PeriodicEffect1XX::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	PeriodicEffect1XX* pEffect = (PeriodicEffect1XX*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			numPackets += 2;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets += 2;
		}
	}

	// Either gain or type specific changed
	if (modFlags & (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS)) {
		DWORD oldMax, oldMin, newMax, newMin;
		DIToJolt(Magnitude(), Offset(), m_Gain, oldMax, oldMin);
		DIToJolt(pEffect->Magnitude(), pEffect->Offset(), pEffect->m_Gain, newMax, newMin);

		int numTypeSpecificChanged = 0;
		// Max changed?
		if (oldMax != newMax) {
			numTypeSpecificChanged = 2;
		}
		// Min changed?
		if (oldMin != newMin) {
			numTypeSpecificChanged += 2;
		}
		if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Don't check these if gain only
			// Phase (1XX cannot change)
			if (Phase() != pEffect->Phase()) {
				return SFERR_NO_SUPPORT;
			}
			// Period
			if (Period() != pEffect->Period()) {
				numTypeSpecificChanged += 2;
			}
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~(DIEP_TYPESPECIFICPARAMS | DIEP_GAIN); // Nothing really changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return SUCCESS;
}

HRESULT PeriodicEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT hr = AdjustModifyParams(newEffect, modFlags);
	if (hr != SUCCESS) {
		return hr;
	}

	PeriodicEffect1XX* pEffect = (PeriodicEffect1XX*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_DURATION, pEffect->m_Duration/DURATION_SCALE_1XX);
		nextPacket += 2;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_TRIGGERBUTTONMASK, g_TriggerMap1XX[pEffect->m_TriggerPlayButton]);
		nextPacket += 2;
	}

	if (modFlags & (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS)) {
		DWORD oldMax, oldMin, newMax, newMin;
		DIToJolt(Magnitude(), Offset(), m_Gain, oldMax, oldMin);
		DIToJolt(pEffect->Magnitude(), pEffect->Offset(), pEffect->m_Gain, newMax, newMin);

		if (oldMax != newMax) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT, (newMax/COEFFICIENT_SCALE_1XX));
			nextPacket += 2;
		}
		if (oldMin != newMin) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT, (newMin/COEFFICIENT_SCALE_1XX));
			nextPacket += 2;
		}
		if (Period() != pEffect->Period()) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_CENTER, pEffect->Period()/COEFFICIENT_SCALE_1XX);
			nextPacket += 2;
		}
	}
	return hr;
}

/******************* PeriodicEffect200 class ******************/
BYTE PeriodicEffect200::GetRepeatIndex() const
{
	return INDEX_PE_REPEAT_200;
}

long int PeriodicEffect200::Phase() const
{
	long int phase = m_PeriodicData.dwPhase;
	if (m_EffectAngle <= 18000) {
		phase += 18000;
		phase %= 36000;
	}
	return phase;
}


HRESULT PeriodicEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = PeriodicEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	m_pEnvelope = new Envelope200(diEffect.lpEnvelope, Magnitude(), m_Duration, hr);

	return hr;
}

UINT PeriodicEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if ((m_SamplePeriod/DURATION_SCALE_200) != 1) {
		retCount++;
	}
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	return retCount;
}

HRESULT PeriodicEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;

	DWORD calc_byte = DWORD(m_SamplePeriod/DURATION_SCALE_200);
	if (calc_byte != 1) {	// Sample period
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	return hr;
}

HRESULT PeriodicEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(26)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain
	calc_byte = unsigned short(float(Phase())/PHASE_SCALE_200);
	packet.m_pData[12]= BYTE(calc_byte & 0x7F);			// Phase Low
	packet.m_pData[13]= BYTE(calc_byte >> 7) & 0x7F;	// Phase High

	// Envelope
	Envelope200* pEnvelope = (Envelope200*)(m_pEnvelope);
	packet.m_pData[14] = BYTE(pEnvelope->m_StartPercent & 0x7F);	// Initial attack level
	packet.m_pData[15] = BYTE(pEnvelope->m_AttackTime& 0x7F);		// AttackTime Low
	packet.m_pData[16] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;	// AttackTime High
	packet.m_pData[17] = BYTE(pEnvelope->m_SustainPercent & 0x7F);	// Sustain level
	packet.m_pData[18] = BYTE(pEnvelope->m_FadeStart & 0x7F);		// SustainTime Low
	packet.m_pData[19] = BYTE(pEnvelope->m_FadeStart >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[20] = BYTE(pEnvelope->m_EndPercent & 0x7F);		// What to decay to
	// --  Duration of decay is figured by the firmware from total duration

	calc_byte = unsigned short(Period()/DURATION_SCALE_200);
	if (calc_byte == 0) {
		calc_byte = 1;
	}
	packet.m_pData[21] = BYTE(calc_byte & 0x7F);		// Period Low MidiByte
	packet.m_pData[22] = BYTE(calc_byte >> 7) & 0x7F;	// Period High MidiByte

	// Convert offset to device percentage (0 to +126 --- +63 = 0 percent)
	calc_byte = unsigned short(float(Offset()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	packet.m_pData[23] = BYTE(calc_byte & 0x7F);		// Offset

	packet.m_pData[24]= ComputeChecksum(packet, 24);	// Checksum

	// End of packet
	packet.m_pData[25]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT PeriodicEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_SAMPLEPERIOD | DIEP_ENVELOPE | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	PeriodicEffect200* pEffect = (PeriodicEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			}
		}
	}

	if (modFlags & DIEP_DIRECTION) {
		modFlags |= (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS);
		if (m_EffectAngle != pEffect->m_EffectAngle) {
			numPackets++;
		} else {
			modFlags &= ~DIEP_DIRECTION;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Check type specific
		int numTypeSpecificChanged = 0;
		if (Phase() != pEffect->Phase()) {
			numTypeSpecificChanged++;
		}
		if (Period() != pEffect->Period()) {
			numTypeSpecificChanged++;
		}
		if (Offset() != pEffect->Offset()) {
			numTypeSpecificChanged++;
		}
		if (Magnitude() != pEffect->Magnitude()) {
			modFlags |= DIEP_ENVELOPE;	// This effects the envelope
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing really changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger reapeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

HRESULT PeriodicEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustReturned = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustReturned)) {
		return adjustReturned;
	}

	HRESULT hr = SUCCESS;
	PeriodicEffect200* pEffect = (PeriodicEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	DWORD calc_byte;

	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_DIRECTION) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_DIRECTIONANGLE_200, unsigned short(float(pEffect->m_EffectAngle)/ANGLE_SCALE_200));
		nextPacket++;
	}

	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		calc_byte = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_GAIN_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		calc_byte = DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (Phase() != pEffect->Phase()) {
			calc_byte = DWORD(float(pEffect->Phase())/PHASE_SCALE_200);
			hr = FillModifyPacket200(nextPacket, INDEX_PE_PHASE_200, calc_byte);
			nextPacket++;
		}
		if (Period() != pEffect->Period()) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_PERIOD_200, pEffect->Period()/DURATION_SCALE_200);
			nextPacket++;
		}
		if (Offset() != pEffect->Offset()) {
			calc_byte = DWORD(float(pEffect->Offset()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
			hr = FillModifyPacket200(nextPacket, INDEX_PE_OFFSET_200, calc_byte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustReturned;
	}
	return hr;
}

/******************* SawtoothEffect200 class ******************/
HRESULT SawtoothEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT retVal = PeriodicEffect200::Create(diEffect);

	if ((m_IsUp && (m_EffectAngle < 18000)) || (!m_IsUp && (m_EffectAngle > 18000))) {			// SawtoothUp use 0 degrees
		m_EffectAngle = 18000;
	} else {				// SawtoothDown use 180 degress
		m_EffectAngle = 0;
	}

	return retVal;
}

long int SawtoothEffect200::Phase() const
{
	return m_PeriodicData.dwPhase;
}

/******************* RampEffect200 class ******************/
HRESULT RampEffect200::Create(const DIEFFECT& diEffect)
{
	// Sanity checks
	if (diEffect.cbTypeSpecificParams != sizeof(DIRAMPFORCE)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Ramps cannot have infinite duration
	if (diEffect.dwDuration == INFINITE) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Create periodic structure and put in the correct values
	DIPERIODIC periodic;
	DIRAMPFORCE* pRampForce = (DIRAMPFORCE*)(diEffect.lpvTypeSpecificParams);
	periodic.dwPhase = 0;
	periodic.dwPeriod = diEffect.dwDuration;
	periodic.lOffset = -(pRampForce->lStart + pRampForce->lEnd)/2;
	if (pRampForce->lStart < pRampForce->lEnd) {	// What direction are we
		m_IsUp = TRUE;
		periodic.dwMagnitude = DWORD(pRampForce->lEnd - pRampForce->lStart)/2;
	} else {
		m_IsUp = FALSE;
		periodic.dwMagnitude = DWORD(pRampForce->lStart - pRampForce->lEnd)/2;
	}

	// Replace the periodic structure (ignorning constness), call sawtooth create, then put the old back
	DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
	pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
	pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Ramp Parms with periodic
	HRESULT retVal = SawtoothEffect200::Create(diEffect);
	pDIEffect->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
	pDIEffect->lpvTypeSpecificParams = pRampForce;	// Return parms back

	// We are done
	return retVal;
}

override HRESULT RampEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	if (modFlags & DIEP_DURATION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		RampEffect200* pEffect = (RampEffect200*)(&newEffect);
		if (m_IsUp != pEffect->m_IsUp) {
			modFlags |= DIEP_DIRECTION;
		}
	}

	return SawtoothEffect200::Modify(newEffect, modFlags);
}


/******************* ConstantForceEffect class ******************/
ConstantForceEffect::ConstantForceEffect() : InternalEffect(),
	m_pEnvelope(NULL)
{
}

ConstantForceEffect::~ConstantForceEffect()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

HRESULT ConstantForceEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_ConstantForceData, 0, sizeof(m_ConstantForceData));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_ConstantForceData)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	::memcpy(&m_ConstantForceData, diEffect.lpvTypeSpecificParams, sizeof(m_ConstantForceData));

	// Check the data for truncation
	if (m_ConstantForceData.lMagnitude > 10000) {
		m_ConstantForceData.lMagnitude = 10000;
		hr = DI_TRUNCATED;
	} else if (m_ConstantForceData.lMagnitude < -10000) {
		m_ConstantForceData.lMagnitude = -10000;
		hr = DI_TRUNCATED;
	}

	return hr;
}


/******************* ConstantForceEffect200 class ******************/
BYTE ConstantForceEffect200::GetRepeatIndex() const
{
	return INDEX_CE_REPEAT_200;
}

HRESULT ConstantForceEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = ConstantForceEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(ET_CONSTANTFORCE_200))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	if (m_ConstantForceData.lMagnitude < 0) {
		m_pEnvelope = new Envelope200(diEffect.lpEnvelope, -Magnitude(), m_Duration, hr);
		m_ConstantForceData.lMagnitude = -10000;
	} else {
		m_pEnvelope = new Envelope200(diEffect.lpEnvelope, Magnitude(), m_Duration, hr);
		m_ConstantForceData.lMagnitude = 10000;
	}

	if (m_EffectAngle <= 18000) {
		m_ConstantForceData.lMagnitude *= -1;
	}

	return hr;
}

UINT ConstantForceEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	return retCount;
}

HRESULT ConstantForceEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	return hr;
}

HRESULT ConstantForceEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_CONSTANTFORCE_200, NEW_EFFECT_ID);

	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain

	// Envelope
	Envelope200* pEnvelope = (Envelope200*)(m_pEnvelope);
	packet.m_pData[12] = BYTE(pEnvelope->m_StartPercent & 0x7F);	// Initial attack level
	packet.m_pData[13] = BYTE(pEnvelope->m_AttackTime& 0x7F);		// AttackTime Low
	packet.m_pData[14] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;	// AttackTime High
	packet.m_pData[15] = BYTE(pEnvelope->m_SustainPercent & 0x7F);	// Sustain level
	packet.m_pData[16] = BYTE(pEnvelope->m_FadeStart & 0x7F);		// SustainTime Low
	packet.m_pData[17] = BYTE(pEnvelope->m_FadeStart >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[18] = BYTE(pEnvelope->m_EndPercent & 0x7F);		// What to decay to
	// --  Duration of decay is figured by the firmware from total duration

/*	short directionHack = 1;
	if (m_EffectAngle <= 18000) {
		directionHack = -1;
	}
*/
	// Convert magnitude to device percentage (0 to +126 --- +63 = 0 percent)
//	calc_byte = unsigned short(float(directionHack * Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	calc_byte = unsigned short(float(Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	packet.m_pData[19] = BYTE(calc_byte & 0x7F);		// Offset

	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT ConstantForceEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	ConstantForceEffect200* pEffect = (ConstantForceEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		DWORD calc = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_CE_GAIN_200, calc);
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (Magnitude() != pEffect->Magnitude()) {
/*			short directionHack = 1;
			if (pEffect->m_EffectAngle <= 18000) {
				directionHack = -1;
			}
			DWORD calc = DWORD(float(directionHack * pEffect->Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
*/			DWORD calc = DWORD(float(pEffect->Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
			hr = FillModifyPacket200(nextPacket, INDEX_CE_MAGNITUDE_200, calc);
			nextPacket++;
		}
	}

	// Did adjust have anything bad to say?
	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT ConstantForceEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return S_FALSE;
	}

	BOOL playingChecked = FALSE;
	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_SAMPLEPERIOD | DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	ConstantForceEffect200* pEffect = (ConstantForceEffect200*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS);	// If angle is greater than 180 magnitude is inverted
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		if (Magnitude() == pEffect->Magnitude()) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing typespecific really changed
		} else {
			numPackets++;
		}
		modFlags |= DIEP_ENVELOPE;
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* class CustomForceEffect ***********************/
CustomForceEffect::CustomForceEffect() : InternalEffect()
{
	m_CustomForceData.rglForceData = NULL;
}

CustomForceEffect::~CustomForceEffect()
{
	if (m_CustomForceData.rglForceData != NULL) {
		delete[] (m_CustomForceData.rglForceData);
		m_CustomForceData.rglForceData = NULL;
	}
}

HRESULT CustomForceEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_CustomForceData, 0, sizeof(m_CustomForceData));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_CustomForceData)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	DICUSTOMFORCE* pDICustom = (DICUSTOMFORCE*)(diEffect.lpvTypeSpecificParams);
	if (pDICustom->cChannels == 0) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// We are a little different from every one else (instead of 0 beiing devcie default, it is custom sample period)
	BOOL useCustomForceSamplePeriod = (diEffect.dwSamplePeriod == 0);

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	m_CustomForceData.cChannels = pDICustom->cChannels;
	m_CustomForceData.dwSamplePeriod = pDICustom->dwSamplePeriod;
	if (m_CustomForceData.dwSamplePeriod > MAX_TIME_200) {
		m_CustomForceData.dwSamplePeriod = MAX_TIME_200;
		hr = DI_TRUNCATED;
	}
	if (useCustomForceSamplePeriod) {
		if (m_CustomForceData.dwSamplePeriod == 0) {	// These both can't be zero
			return SFERR_NO_SUPPORT;
		}
		m_SamplePeriod = m_CustomForceData.dwSamplePeriod;
	}
	m_CustomForceData.cSamples = pDICustom->cSamples;

	long int* pForceData = NULL;
	try { // They could probably ask for anything
		pForceData = new long int[m_CustomForceData.cSamples];
	} catch (...) {
		return SFERR_DRIVER_ERROR;
	}
	if (pForceData == NULL)
	{
		return SFERR_DRIVER_ERROR;
	}
	::memcpy(pForceData, pDICustom->rglForceData, sizeof(long int) * m_CustomForceData.cSamples);
	m_CustomForceData.rglForceData = pForceData;
	pForceData = NULL;

	return hr;
}

/******************* class CustomForceEffect200 ***********************/
CustomForceEffect200::CustomForceEffect200() : CustomForceEffect(),
	m_pEnvelope(NULL)
{
}

CustomForceEffect200::~CustomForceEffect200()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

BYTE CustomForceEffect200::GetRepeatIndex() const
{
	return INDEX_CF_REPEAT_200;
}

HRESULT CustomForceEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = CustomForceEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(ET_CUSTOMFORCE_200))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	m_pEnvelope = new Envelope200(diEffect.lpEnvelope, 10000, m_Duration, hr);	// Sustain Mag is 100 percent

	return hr;
}

UINT CustomForceEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	// Envelope parms
	ASSUME_NOT_NULL(m_pEnvelope);
	if (m_pEnvelope != NULL) {	// Already converted to device units
		if (m_pEnvelope->m_StartPercent != 127) {
			retCount++;
		}
		if (m_pEnvelope->m_AttackTime != 0) {
			retCount++;
		}
		if (m_pEnvelope->m_SustainPercent != 127) {
			retCount++;
		}
		if (m_pEnvelope->m_FadeStart != 0) {
			retCount++;
		}
		if (m_pEnvelope->m_EndPercent != 127) {
			retCount++;
		}
	}

	return retCount;
}

HRESULT CustomForceEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	// Envelope parms
	ASSUME_NOT_NULL(m_pEnvelope);
	if (m_pEnvelope != NULL) {	// Already converted to device units
		if (m_pEnvelope->m_StartPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_STARTPERCENT_200, m_pEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (m_pEnvelope->m_AttackTime != 0) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ATTTACK_TIME_200, m_pEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (m_pEnvelope->m_SustainPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_SUSTAINPERCENT_200, m_pEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (m_pEnvelope->m_FadeStart != 0) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_FADESTART_200, m_pEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (m_pEnvelope->m_EndPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ENDPERCENT_200, m_pEnvelope->m_EndPercent);
			nextPacket++;
		}
	}

	return hr;
}

HRESULT CustomForceEffect200::FillCreatePacket(DataPacket& packet) const
{
	if (m_CustomForceData.cChannels == 0) {
		ASSUME_NOT_REACHED();	// Already checked this
		return SFERR_INVALID_PARAM;
	}

	// Create waveform packet
	BYTE* pWaveForm = NULL;
	try {	// Who knows how much we are being asked to allocate
		pWaveForm = new BYTE[m_CustomForceData.cSamples / m_CustomForceData.cChannels * 2];	// This is the max possible
	} catch(...) {
		return SFERR_DRIVER_ERROR;
	}
	if (pWaveForm == NULL)
	{
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;

	// Fill wavelet packet
	if (m_CustomForceData.rglForceData[0] > 10000) {
		m_CustomForceData.rglForceData[0] = 10000;
		hr = DI_TRUNCATED;
	} else if (m_CustomForceData.rglForceData[0] < -10000) {
		m_CustomForceData.rglForceData[0] = -10000;
		hr = DI_TRUNCATED;
	}
	unsigned short wave_byte = unsigned short(float(m_CustomForceData.rglForceData[0] + 10000)/WAVELET_SCALE_200);
	pWaveForm[0] = BYTE(wave_byte & 0x3F);
	pWaveForm[1] = BYTE(wave_byte >> 6) & 0x07;
	UINT waveletCount = 2;
	UINT iPrev = 0;
	for (UINT i = (0 + m_CustomForceData.cChannels); i < m_CustomForceData.cSamples; i += m_CustomForceData.cChannels) {
		if (m_CustomForceData.rglForceData[i] > 10000) {
			m_CustomForceData.rglForceData[i] = 10000;
			hr = DI_TRUNCATED;
		} else if (m_CustomForceData.rglForceData[i] < -10000) {
			m_CustomForceData.rglForceData[i] = -10000;
			hr = DI_TRUNCATED;
		}
		LONG distance = m_CustomForceData.rglForceData[i] - m_CustomForceData.rglForceData[iPrev];
		if ((distance >= 0) && (distance <= WAVELET_DISTANCE_200) ||
				(distance < 0) && (-distance <= WAVELET_DISTANCE_200)) {	// Relative (single byte)
			wave_byte = unsigned short((float(distance + WAVELET_DISTANCE_200)/WAVELET_DISTANCE_SCALE_200) + 0.5f);
			ASSUME(wave_byte <= 62);
			pWaveForm[waveletCount++] = (BYTE(wave_byte) & 0x3F) | 0x40;
		} else { // Non relative (double byte)
			wave_byte = unsigned short(float(m_CustomForceData.rglForceData[i] + 10000)/WAVELET_SCALE_200);
			pWaveForm[waveletCount++] = BYTE(wave_byte & 0x3F);
			pWaveForm[waveletCount++] = BYTE(wave_byte >> 6) & 0x07;
		}
		iPrev = i;
	}


	// Packet to set modify data[index] of current effect
	UINT totalBytes = 19 + waveletCount;	// Header (10) + Fixed (7) + Footer(2) + waveBytes
	if (!packet.AllocateBytes(totalBytes)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_CUSTOMFORCE_200, NEW_EFFECT_ID);

//	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
//	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	if (m_EffectAngle <= 18000) {	// Custom for device units
		packet.m_pData[10]= BYTE(64);
	} else {
		packet.m_pData[10]= BYTE(0);
	}

	unsigned short calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain

	calc_byte = unsigned short(m_CustomForceData.dwSamplePeriod/DURATION_SCALE_200);
	packet.m_pData[12] = BYTE(calc_byte & 0x7F);			// Force Sample Interval Low
	packet.m_pData[13] = BYTE(calc_byte >> 7) & 0x7F;		// Force Sample Interval High

	calc_byte = unsigned short(m_SamplePeriod/DURATION_SCALE_200);
	packet.m_pData[14] = BYTE(calc_byte & 0x7F);			// Force Output Interval Low
	packet.m_pData[15] = BYTE(calc_byte >> 7) & 0x7F;		// Force Output Interval High

	packet.m_pData[16] = 63;			// Constant force offset (0 - DI Doesn't support)

	// Fill in the wavelet info (already converted to device units
	for (UINT nextWaveIndex = 0; nextWaveIndex < waveletCount; nextWaveIndex++) {
		packet.m_pData[17 + nextWaveIndex] = pWaveForm[nextWaveIndex];
	}

	packet.m_pData[totalBytes-2]= ComputeChecksum(packet, totalBytes-2);	// Checksum

	// End of packet
	packet.m_pData[totalBytes-1]= MIDI_EOX;						// End of SysEX packet

	// Clean up
	delete[] pWaveForm;	// can't modify it, no need to save it
	pWaveForm = NULL;

	return hr;
}

HRESULT CustomForceEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();

	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}
	HRESULT hr = SUCCESS;

	CustomForceEffect200* pEffect = (CustomForceEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		if (pEffect->m_EffectAngle > 18000) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_DIRECTIONANGLE_200, 0, 0);
		} else {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_DIRECTIONANGLE_200, BYTE(64), 0);
		}
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		DWORD calc = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_CF_GAIN_200, calc);
		nextPacket++;
	}
	if (modFlags & DIEP_SAMPLEPERIOD) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_SAMPLE_PERIOD_200, DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		hr = FillModifyPacket200(nextPacket, INDEX_CF_FORCESAMPLE_200, DWORD(pEffect->m_CustomForceData.dwSamplePeriod)/DURATION_SCALE_200);
		nextPacket++;
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT CustomForceEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE | DIEP_SAMPLEPERIOD | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	CustomForceEffect200* pEffect = (CustomForceEffect200*)(&newEffect);
	unsigned short numPackets = 0;
	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == FALSE) {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			} else {
				return DIERR_EFFECTPLAYING;
			}
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags &= ~DIEP_DIRECTION;
		if (m_EffectAngle != pEffect->m_EffectAngle) {
			modFlags |= DIEP_GAIN;
			if (int(m_EffectAngle / 18000) != int(pEffect->m_EffectAngle / 18000)) {
				modFlags |= DIEP_DIRECTION;
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		if (m_CustomForceData.dwSamplePeriod == pEffect->m_CustomForceData.dwSamplePeriod) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing typespecific really changed
		} else {
			numPackets ++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}


/******************* class WallEffect ***********************/
HRESULT WallEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_WallData, 0, sizeof(BE_WALL_PARAM));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(BE_WALL_PARAM)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	::memcpy(&m_WallData, diEffect.lpvTypeSpecificParams, sizeof(BE_WALL_PARAM));
	m_WallData.m_WallAngle %= 36000;	// No telling what we might have been sent

	if (m_WallData.m_WallDistance > 10000) {
		m_WallData.m_WallDistance = 10000;
		hr = DI_TRUNCATED;
	}
	if (m_WallData.m_WallConstant > 10000) {
		m_WallData.m_WallConstant = 10000;
		hr = DI_TRUNCATED;
	} else if (m_WallData.m_WallConstant < -10000) {
		m_WallData.m_WallConstant = -10000;
		hr = DI_TRUNCATED;
	}

	return hr;
}

/******************* class WallEffect200 ***********************/
BYTE WallEffect200::GetRepeatIndex() const
{
	return INDEX_BE_REPEAT_200;
}

HRESULT WallEffect200::Create(const DIEFFECT& diEffect)
{
	::memset(m_Ds, 0, 4);
	::memset(m_Fs, 0, 4);

	HRESULT hr = WallEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	ComputeDsAndFs();
	return hr;
}

void WallEffect200::ComputeDsAndFs()
{
	// Projection method - not so smart
	double xProjection = m_WallData.m_WallDistance;

	// With angles greater than 180 Wall flips across X axis
	BOOL wallInner = (m_WallData.m_WallType == WALL_INNER);
	if (m_WallData.m_WallAngle > 18000) {
		xProjection = -xProjection;
	} else if (xProjection == 0) {
		wallInner = !wallInner;
	}

	BYTE xProjectionScaled = BYTE((xProjection/double(DIDISTANCE_TO_PERCENT) + 100.0)/POSITIVE_PERCENT_SCALE) & 0x7F;
	if (((xProjection <= 0) && (wallInner)) || ((xProjection > 0) && (!wallInner))) {
		m_Fs[0] = BYTE(float(-m_WallData.m_WallConstant/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		m_Ds[0] = xProjectionScaled;
		m_Ds[2] = 127;	// Positive Max
	} else {
		m_Fs[0] = BYTE(float(m_WallData.m_WallConstant/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		m_Ds[0] = 0;	// Negative Max
		m_Ds[2] = xProjectionScaled;
	}

	// Simplistic mapping: if there is no mapping value is nothing for Y walls
	if (g_ForceFeedbackDevice.GetYMappingPercent(ET_WALL_200) == 0) {
		if (m_WallData.m_WallAngle == 0000 || m_WallData.m_WallAngle == 18000) { // Y axis walls
			m_Fs[0] = 63;	// 0
		}
	}

	m_Ds[1] = m_Ds[0];
	m_Ds[3] = m_Ds[2];
	m_Fs[1] = m_Fs[0];
	m_Fs[2] = m_Fs[0];
	m_Fs[3] = m_Fs[0];
}

UINT WallEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) { // Gain
		retCount++;
	}

	return retCount;
}

HRESULT WallEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) { // Gain
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	return hr;
}

HRESULT WallEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(21)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_WALL_200, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	packet.m_pData[10]= 0;		// Effect Angle is along positive x.

	// Computed in create
	packet.m_pData[11]= m_Ds[0];
	packet.m_pData[12]= m_Fs[0];
	packet.m_pData[13]= m_Ds[1];
	packet.m_pData[14]= m_Fs[1];
	packet.m_pData[15]= m_Ds[2];
	packet.m_pData[16]= m_Fs[2];
	packet.m_pData[17]= m_Ds[3];
	packet.m_pData[18]= m_Fs[3];

	// End this puppy
	packet.m_pData[19]= ComputeChecksum(packet, 19);	// Checksum
	packet.m_pData[20]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT WallEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	WallEffect200* pEffect = (WallEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, DWORD(float(pEffect->m_TriggerRepeat)/DURATION_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		for (int i = 0; i < 4; i++) {
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				hr = FillModifyPacket200(nextPacket, INDEX_D1F1_200 + i, pEffect->m_Ds[i], pEffect->m_Fs[i]);
				nextPacket++;
			}
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT WallEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/

	WallEffect200* pEffect = (WallEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;
	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == FALSE) {
				numPackets++;
			} else {
				return DIERR_EFFECTPLAYING;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
//	if (modFlags & DIEP_DIRECTION) {
//		modFlags |= DIEP_TYPESPECIFICPARAMS;
//	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { // Find which ones (if any)
		int numTypeSpecificChanged = 0;
		for (int i = 0; i < 4; i++) {
			// Ds and Fs are changed togeather
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				numTypeSpecificChanged++;
			}
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {	// That was easy nothing changed
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* class SystemEffect1XX ***********************/
SystemEffect1XX::SystemEffect1XX() : SystemEffect(),
	m_SystemStickData()
{
}

HRESULT SystemEffect1XX::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	if (diEffect.cbTypeSpecificParams != sizeof(SystemStickData1XX)) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Get the data from the DIEFFECT
	::memcpy(&m_SystemStickData, diEffect.lpvTypeSpecificParams, sizeof(SystemStickData1XX));

	return SUCCESS;
}

HRESULT SystemEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

HRESULT SystemEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	SystemEffect1XX* pNewSystemEffect = (SystemEffect1XX*)(&newEffect);

	// Find number of packets needed
	unsigned short numPackets = 28;	// Always need to send system commands when asked (have no idea what is on the stick

	// Allocate a packets for sending modify command
	if (!g_pDataPackager->AllocateDataPackets(numPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill the packets
	BYTE nextPacket = 0;
	FillModifyPacket1XX(nextPacket, INDEX0, pNewSystemEffect->m_SystemStickData.dwXYConst/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX1, pNewSystemEffect->m_SystemStickData.dwRotConst/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX2, pNewSystemEffect->m_SystemStickData.dwSldrConst);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX3, pNewSystemEffect->m_SystemStickData.dwAJRot);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX4, pNewSystemEffect->m_SystemStickData.dwAJRot);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX5, pNewSystemEffect->m_SystemStickData.dwAJSldr);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX6, pNewSystemEffect->m_SystemStickData.dwSprScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX7, pNewSystemEffect->m_SystemStickData.dwBmpScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX8, pNewSystemEffect->m_SystemStickData.dwDmpScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX9, pNewSystemEffect->m_SystemStickData.dwInertScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX10, pNewSystemEffect->m_SystemStickData.dwVelOffScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX11, pNewSystemEffect->m_SystemStickData.dwAccOffScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX12, pNewSystemEffect->m_SystemStickData.dwYMotBoost/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX13, pNewSystemEffect->m_SystemStickData.dwXMotSat);
	
	return SUCCESS;
}

/******************* class SystemStickData1XX ***********************/
SystemStickData1XX::SystemStickData1XX()
{
	dwXYConst		= DEF_XY_CONST;
	dwRotConst		= DEF_ROT_CONST;
	dwSldrConst		= DEF_SLDR_CONST;
	dwAJPos			= DEF_AJ_POS;
	dwAJRot			= DEF_AJ_ROT;
	dwAJSldr		= DEF_AJ_SLDR;
	dwSprScl		= DEF_SPR_SCL;
	dwBmpScl		= DEF_BMP_SCL;
	dwDmpScl		= DEF_DMP_SCL;
	dwInertScl		= DEF_INERT_SCL;
	dwVelOffScl		= DEF_VEL_OFFSET_SCL;
	dwAccOffScl		= DEF_ACC_OFFSET_SCL;
	dwYMotBoost		= DEF_Y_MOT_BOOST;
	dwXMotSat		= DEF_X_MOT_SATURATION;
	dwReserved		= 0;
	dwMasterGain	= 0;
}

#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"
void SystemStickData1XX::SetFromRegistry(DWORD dwDeviceID)
{
	// try to open the registry key
	HKEY hkey = joyOpenOEMForceFeedbackKey(dwDeviceID);
	if (hkey != NULL) {
		RegistryKey ffKey(hkey);
		ffKey.ShouldClose(TRUE);
		DWORD numBytes = sizeof(SystemStickData1XX);
		if (ffKey.QueryValue(REGSTR_VAL_JOYSTICK_PARAMS, (BYTE*)this, numBytes) == SUCCESS) {
			return;
		}
	}

	// We were either not able to open the key or get the value (Use defaults)
	dwXYConst		= DEF_XY_CONST;
	dwRotConst		= DEF_ROT_CONST;
	dwSldrConst		= DEF_SLDR_CONST;
	dwAJPos			= DEF_AJ_POS;
	dwAJRot			= DEF_AJ_ROT;
	dwAJSldr		= DEF_AJ_SLDR;
	dwSprScl		= DEF_SPR_SCL;
	dwBmpScl		= DEF_BMP_SCL;
	dwDmpScl		= DEF_DMP_SCL;
	dwInertScl		= DEF_INERT_SCL;
	dwVelOffScl		= DEF_VEL_OFFSET_SCL;
	dwAccOffScl		= DEF_ACC_OFFSET_SCL;
	dwYMotBoost		= DEF_Y_MOT_BOOST;
	dwXMotSat		= DEF_X_MOT_SATURATION;
	dwReserved		= 0;
	dwMasterGain	= 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffd_swff.cpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.CPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	FFD (SWForce HAL) API
    
    FUNCTIONS:		Function prototypes for Force Feedback Joystick interface
    				between the SWForce and the device

		FFD_GetDeviceState
		FFD_PutRawForce
		FFD_DownloadEffect
	  	FFD_DestroyEffect
	

		VFX functions:
			Download_VFX
			CreateEffectFromFile
			CreateEffectFromBuffer

	These functionality are not necessarily supported by all Force Feedback 
	devices.  For example, if a device does not support built-in synthesis 
	capability, then the entry point DownloadEffect, will return an error
	code ERROR_NO_SUPPORT.

	COMMENTS:
	This module of functions are encapsulated in SW_WHEEL.dll the DirectInput 
	DDI driver

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	21-Mar-97       MEA     original from SWForce code
			21-Mar-99		waltw	Removed unreferenced FFD_xxx functions
	              
****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "midi.hpp"
#include "hau_midi.hpp"
#include "math.h"
#include "FFD_SWFF.hpp"
#include "midi_obj.hpp"

#include "DPack.h"
#include "DTrans.h"
#include "FFDevice.h"
#include "CritSec.h"

static ACKNACK g_AckNack;

// Force Output range values
#define MAX_AMP	2047
#define MIN_AMP	-2048
#define FORCE_RANGE ((MAX_AMP - MIN_AMP)/2)

extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

static HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY);


// ----------------------------------------------------------------------------
// Function:    FFD_Download
//
// Purpose:     Downloads the specified Effect object UD/BE/SE to the FF device.
// Parameters:
//				IN OUT PDNHANDLE pDnloadD   - Ptr to DNHANDLE to store EffectID
//				IN PEFFECT 		 pEffect	- Ptr Common attributes for Effects
//				IN PENVELOPE	 pEnvelope	- Ptr to an ENVELOPE
// 				IN PVOID		 pTypeParam	- Ptr to a Type specific parameter
// 				IN ULONG		 ulAction	- Type of action desired
//
// Returns:
//		SUCCESS - if successful
//		SFERR_FFDEVICE_MEMORY - no more download RAM available
//		SFERR_INVALID_PARAM - Invalid parameters
//		SFERR_NO_SUPPORT - if function is unsupported.
// Algorithm:
//
// Comments:
//
//  ulAction: Type of action desired after downloading
//      PLAY_STORE   - stores in Device only
//      || the following options:
//      PLAY_STORE   - stores in Device only
//      || the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
//          PLAY_LOOP       - Loops for Count times, where count value is in
//                            HIWORD 
//          PLAY_FOREVER    - Play forever until told to stop: PLAY_LOOP with 0 
//							  value in HIWORD
// ----------------------------------------------------------------------------
HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DownloadEffect. DnloadID= %ld, Type=%ld, SubType=%ld\r\n",
   					*pDnloadID,
   					pEffect->m_Type, pEffect->m_SubType);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	return SFERR_DRIVER_ERROR;
#if 0
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

// If the Effect type is not a BE_DELAY or EF_ROM_EFFECT,
// make sure there is a pTypeParam
	if ((BE_DELAY != pEffect->m_SubType) && (EF_ROM_EFFECT != pEffect->m_Type))
	{
		assert(pTypeParam);
		if (NULL == pTypeParam) return (SFERR_INVALID_PARAM);
	}

	// Don't support PLAY_LOOP for this version
	if ((ulAction & PLAY_LOOP) || (ulAction & 0xffff0000))
		return (SFERR_NO_SUPPORT);

// REVIEW:  TO increase performance, we should do a parameter mod check
// For now, we'll assume all parameters are changed, for dwFlags
// otherwise, we should check for:
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Figure out the Common members
	BYTE bAxisMask = (BYTE) pEffect->m_AxisMask;
	ULONG ulDuration = pEffect->m_Duration;
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER)) 	ulDuration  = 0;

	// map button 10 to button 9
	if(pEffect->m_ButtonPlayMask == 0x0200)
		pEffect->m_ButtonPlayMask = 0x0100;
	else if(pEffect->m_ButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;

	DWORD dwFlags = DIEP_ALLPARAMS;
	SE_PARAM seParam = { sizeof(SE_PARAM)};

	PBE_SPRING_PARAM pBE_xxx1D;
	PBE_SPRING_2D_PARAM pBE_xxx2D;
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;

	// Decode the type of Download to use
	HRESULT hRet = SFERR_INVALID_PARAM;
	ULONG ulSubType = pEffect->m_SubType;
	switch (pEffect->m_Type)
	{
		case EF_BEHAVIOR:
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					pBE_xxx1D = (PBE_SPRING_PARAM) pTypeParam;
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pBE_xxx1D->m_Kconstant;
						BE_xxx.m_YConstant = 0;
						if (ulSubType != BE_FRICTION)
							BE_xxx.m_Param3 = pBE_xxx1D->m_AxisCenter;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pBE_xxx1D->m_Kconstant;
							BE_xxx.m_XConstant = 0;
							if (ulSubType != BE_FRICTION)
								BE_xxx.m_Param4 = pBE_xxx1D->m_AxisCenter;
							BE_xxx.m_Param3= 0;
						}
					}
					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damperfs
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					pBE_xxx2D = (PBE_SPRING_2D_PARAM) pTypeParam;
					BE_xxx.m_XConstant = pBE_xxx2D->m_XKconstant;
					if (ulSubType != BE_FRICTION_2D)
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_YKconstant;
						BE_xxx.m_Param3 = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param4 = pBE_xxx2D->m_YAxisCenter;
					}
					else
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param3 = 0;
						BE_xxx.m_Param4 = 0;
					}

					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					pBE_Wall = (PBE_WALL_PARAM) pTypeParam;
					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 90)
						|| (pBE_Wall->m_WallAngle == 180)
						|| (pBE_Wall->m_WallAngle == 270) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance;
						hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						hRet = SFERR_NO_SUPPORT;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
//					hRet = CMD_Download_NOP_DELAY(ulDuration, pEffect, (PDNHANDLE) pDnloadID);
					break;

				default:
					hRet = SFERR_NO_SUPPORT;
					break;
			}
			break;

		case EF_USER_DEFINED:
			break;

		case EF_ROM_EFFECT:
			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(pEffect))
			{
				hRet = SFERR_INVALID_OBJECT;
				break;
			}
			
			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;				// unused by ROM Effect
			seParam.m_SampleRate = pEffect->m_ForceOutputRate;
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;
			
			break;
			
		case EF_SYNTHESIZED:
			if (0 == ((PSE_PARAM)pTypeParam)->m_SampleRate)
				((PSE_PARAM)pTypeParam)->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			if (0 == pEffect->m_ForceOutputRate)
				pEffect->m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;

			break;

		default:
			hRet = SFERR_INVALID_PARAM;
	}
	
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DownloadEffect. DnloadID = %lx, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
#endif //0
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_DestroyEffect
// Purpose:    	Destroys the Effect from download RAM storage area.
// Parameters: 
//				IN EFHANDLE EffectID		// an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_ID
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//				The Device's Effect ID and memory is returned to free pool.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->DestroyEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	hr = g_pDataTransmitter->Transmit(g_AckNack);	// Send it off
	return hr;
}


// *** ---------------------------------------------------------------------***
// Function:   	FFD_VFXProcessEffect
// Purpose:    	Commands FF device to process downloaded Effects
//
// Parameters: 
//				IN OUT PDNHANDLE pDnloadID	// Storage for new Download ID
//				IN int 	nNumEffects			// Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	// Processing mode
//				IN PDNHANDLE pPListArray// Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pEFHandle:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  The first entry pEFHandle[0] will be
//		used to store the new Effect ID created for the CONCATENATE
//		and SUPERIMPOSE process choice.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_ProcessEffect, DnloadID=%ld\r\n",
					*pDnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	assert(pDnloadID && pPListArray);
	if ((NULL == pDnloadID) || (NULL == pPListArray)) return (SFERR_INVALID_PARAM);

	assert(nNumEffects > 0 && nNumEffects <= MAX_PLIST_EFFECT_SIZE);
	if ((nNumEffects > MAX_PLIST_EFFECT_SIZE) || (nNumEffects <= 0))
		return (SFERR_INVALID_PARAM);

	// map button 10 to button 9
	if(ulButtonPlayMask == 0x0200)
		ulButtonPlayMask = 0x0100;
	else if(ulButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;   

	return S_OK;
}


// *** ---------------------------------------------------------------------***
// Function:   	AngleToXY
// Purpose:    	Computes XY from Angle
// Parameters: 
//				IN LONG lDirectionAngle2D	- Angle in Degrees
//				IN LONG lForceValue			- Resultant Force
//				IN ULONG ulAxisMask			- Axis to Affect
//				IN OUT PLONG pX				- X-Axis store
//				IN OUT PLONG pY				- Y-Axis store
// Returns:    	pX, pY with valid angle components
//
// *** ---------------------------------------------------------------------***
HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY)
{
// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
// If X, Y, and Z-axis, then use 3D angle
// If axis is other than X,Y,Z then no support
	double Radian;

	switch (ulAxisMask)
	{
		case (X_AXIS|Y_AXIS):	// use 2D
			Radian = xDegrees2Radians(lDirectionAngle2D % 360);
#ifdef ORIENTATION_MODE1
			*pX = - (long) (lValueData * cos(Radian));
			*pY = (long) (lValueData * sin(Radian));
#else
			*pX = - (long) (lValueData * sin(Radian));
			*pY = (long) (lValueData * cos(Radian));
#endif
			break;

		case X_AXIS:
			*pX = lValueData;
			*pY = 0;
			break;

		case Y_AXIS:
			*pX = 0;
			*pY = lValueData;
			break;
		
		case (X_AXIS|Y_AXIS|Z_AXIS):	// use 3D
		default:
			return (SFERR_NO_SUPPORT);	
			break;
	}
	return SUCCESS;
}

//
// ---  VFX SUPPORT FUNCTIONS
//


// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromBuffer
// Purpose:    	Creates an Effect from a buffer
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				PVOID pBuffer					- Ptr to a buffer block 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwByteCount,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CImpIVFX::CreateEffectFromBuffer\n");
#endif
	// parameter checking
	if ( !(pBuffer && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	// variables used in this function
	#define ID_TABLE_SIZE	50
	MMRESULT mmresult;
	DWORD dwMaxID = 0;		// maximum id of effects entered into the following table
	DNHANDLE rgdwDnloadIDTable[ID_TABLE_SIZE];
	DNHANDLE dwCurrentDnloadID = 0;
	int nNextID = 0;
	HRESULT hResult = SUCCESS;
	DWORD dwBytesRead;
	DWORD dwBytesToRead;
	BYTE* pParam = NULL;
	BOOL bDone = FALSE;
	BOOL bSubEffects = FALSE;
	DWORD dwID;
	DWORD c;	// cleanup counter variable

	// debugging variables (to make sure we destroy all but one
	// created effect on success, and that we destory every
	// created effect on failure)...
#ifdef _DEBUG
	int nEffectsCreated = 0;
	int nEffectsDestroyed = 0;
	BOOL bFunctionSuccessful = FALSE;
#endif //_DEBUG

	// clear effect table (we check it during cleanup...  anything
	// that isn't NULL gets destroyed.)
	memset(rgdwDnloadIDTable,NULL,sizeof(rgdwDnloadIDTable));

	// open a RIFF memory file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= FOURCC_MEM;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= dwByteCount;
	mmioinfo.pchBuffer		= (char*)pBuffer;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[2]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;
	
	HMMIO hmmio;
	hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// descend into FORC RIFF
	MMCKINFO mmckinfoForceEffectRIFF;
	mmckinfoForceEffectRIFF.fccType = FCC_FORCE_EFFECT_RIFF;
	mmresult = mmioDescend(hmmio, &mmckinfoForceEffectRIFF, NULL, MMIO_FINDRIFF);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	//! handle loading of GUID chunk when its implemented/testable

	// descend into trak list
	MMCKINFO mmckinfoTrackLIST;
	mmckinfoTrackLIST.fccType = FCC_TRACK_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoTrackLIST, &mmckinfoForceEffectRIFF,
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// descend into the first efct list (there has to be at least one effect)
	MMCKINFO mmckinfoEffectLIST;
	mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	bDone = FALSE;
	do
	{
		// descend into id chunk
		MMCKINFO mmckinfoIDCHUNK;
		mmckinfoIDCHUNK.ckid = FCC_ID_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoIDCHUNK, &mmckinfoEffectLIST, 
							   MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the id
		//DWORD dwID;  moved to being function global so we can use it near the end
		dwBytesToRead = sizeof(DWORD);
		dwBytesRead = mmioRead(hmmio, (char*)&dwID, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}
		if(dwID >= ID_TABLE_SIZE)
		{
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			goto cleanup;
		}

		// ascend from id chunk
		mmresult = mmioAscend(hmmio, &mmckinfoIDCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// descend into data chunk
		MMCKINFO mmckinfoDataCHUNK;
		mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoDataCHUNK, &mmckinfoEffectLIST, 
								MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the effect structure
		EFFECT effect;
		dwBytesToRead = sizeof(EFFECT);
		dwBytesRead = mmioRead(hmmio, (char*)&effect, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// get the envelope structure
		ENVELOPE envelope;
		dwBytesToRead = sizeof(ENVELOPE);
		dwBytesRead = mmioRead(hmmio, (char*)&envelope, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// calculate the size of and allocate a param structure
		if(pParam != NULL)
		{
			delete [] pParam;
			pParam = NULL;
		}
		// find cur pos w/o changing it
		DWORD dwCurrentFilePos = mmioSeek(hmmio, 0, SEEK_CUR);
		if(dwCurrentFilePos == -1)
		{
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
			goto cleanup;
		}
		DWORD dwEndOfChunk = mmckinfoDataCHUNK.dwDataOffset
							 + mmckinfoDataCHUNK.cksize;
		dwBytesToRead = dwEndOfChunk - dwCurrentFilePos;
		pParam = new BYTE[dwBytesToRead];
		if(pParam == NULL)
		{
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			goto cleanup;
		}

		// get the param structure
		dwBytesRead = mmioRead(hmmio, (char*)pParam, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// ascend the data chunk
		mmresult = mmioAscend(hmmio, &mmckinfoDataCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// ascend from the efct list
		mmresult = mmioAscend(hmmio, &mmckinfoEffectLIST, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// reset subeffects flag
		bSubEffects = FALSE;

		// special fix-ups for user-defined
		if(effect.m_Type == EF_USER_DEFINED && 
				(effect.m_SubType == PL_CONCATENATE 
				|| effect.m_SubType == PL_SUPERIMPOSE
				|| effect.m_SubType == UD_WAVEFORM))
		{
			if(effect.m_SubType == UD_WAVEFORM)
			{
				// fix the pointer to the force data in the UD_PARAM
				BYTE* pForceData = pParam + sizeof(UD_PARAM); // - sizeof(LONG*);
				UD_PARAM* pUDParam =  (UD_PARAM*)pParam;
				pUDParam->m_pForceData = (LONG*)pForceData;

				// do a sanity check
				if(pUDParam->m_NumVectors > MAX_UD_PARAM_FORCE_DATA_COUNT)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}
			}
			else if(effect.m_SubType == PL_CONCATENATE 
									|| effect.m_SubType == PL_SUPERIMPOSE)
			{
				// fix the pointer to the PSWEFFECT list in the PL_PARAM
				BYTE* pProcessList = pParam + sizeof(PL_PARAM);
				PL_PARAM* pPLParam = (PL_PARAM*)pParam;
				pPLParam->m_pProcessList = (PPSWEFFECT)pProcessList;
				
				// do a sanity check
				if(pPLParam->m_NumEffects > MAX_PL_PARAM_NUM_EFFECTS)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}

				// make sure all entries in this process list are valid
				ULONG i;
				for (i = 0; i < pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];
					if(nThisID >= ID_TABLE_SIZE)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];
					if(dwThisDnloadID == 0)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}
				}
				
				// use the ID table to insert the download ID's
				for(i=0; i<pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];

					pPLParam->m_pProcessList[i] = (IDirectInputEffect*)dwThisDnloadID;

					// since this effect has been used in a process list,
					// and it will be destroyed after being used in CreateEffect,
					// null it's entry in the table so it doesn't get erroneously
					// redestroyed during cleanup of an error.
					rgdwDnloadIDTable[nThisID] = NULL;
				}

				// we have a process list with sub effects, so set the flag
				bSubEffects = TRUE;
			}
			else
			{
				// there are no other UD sub-types
				hResult = VFX_ERR_FILE_BAD_FORMAT;
				goto cleanup;
			}
		}

		// download the effect

		// create the effect
		//hResult = pISWForce->CreateEffect(&pISWEffect, &effect, 
		//				&envelope, pParam);


		if(effect.m_SubType != PL_CONCATENATE && effect.m_SubType != PL_SUPERIMPOSE)
		{
			EFFECT SmallEffect;
			SmallEffect.m_Bytes = sizeof(EFFECT);
			SmallEffect.m_Type = effect.m_Type;
			SmallEffect.m_SubType = effect.m_SubType;
			SmallEffect.m_AxisMask = effect.m_AxisMask;
			SmallEffect.m_DirectionAngle2D = effect.m_DirectionAngle2D;
			SmallEffect.m_DirectionAngle3D = effect.m_DirectionAngle3D;
			SmallEffect.m_Duration = effect.m_Duration;
			SmallEffect.m_ForceOutputRate = effect.m_ForceOutputRate;
			SmallEffect.m_Gain = effect.m_Gain;
			SmallEffect.m_ButtonPlayMask = effect.m_ButtonPlayMask;
			*pDnloadID = 0;

			hResult = FFD_DownloadEffect(pDnloadID, &SmallEffect, &envelope, pParam, ulAction);
		}
		else
		{
			ULONG ulButtonPlayMask = effect.m_ButtonPlayMask;
			int nNumEffects = ((PL_PARAM*)pParam)->m_NumEffects;
			ULONG ulProcessMode = effect.m_SubType;
			PDNHANDLE pPListArray = new DNHANDLE[ID_TABLE_SIZE];
			for(int i=0; i<nNumEffects; i++)
				pPListArray[i] = (DNHANDLE)(((PL_PARAM*)pParam)->m_pProcessList[i]);
			*pDnloadID = 0;

			hResult = FFD_VFXProcessEffect(ulButtonPlayMask, pDnloadID, nNumEffects,
				ulProcessMode,pPListArray);
		}

		// moved check for success below...

#ifdef _DEBUG
		if (!FAILED(hResult))
			nEffectsCreated++;
#endif //_DEBUG

		// if there were sub effects we need to destroy them, making
		// their ref counts become 1, so the entire effect can be destroyed
		// by destroying the root effect.
#if 0
		if (bSubEffects)
		{
			PL_PARAM* pPLParam = (PL_PARAM*)pParam;

			for (ULONG i = 0; i < pPLParam->m_NumEffects; i++)
			{
				ASSERT(pPLParam->m_pProcessList[i] != NULL);
				pISWForce->DestroyEffect(pPLParam->m_pProcessList[i]);
#ifdef _DEBUG
				nEffectsDestroyed++;
#endif //_DEBUG
			}
		}
#endif

		// now check for success of CreateEffect, because regardless of
		// whether or not it succeeded, we -must- have destroyed the subeffects
		// before continuing, or cleanup will not work properly...
		if (SUCCESS != hResult)
		{
			goto cleanup;
		}

		// put the id/DnloadID pair into the map
		rgdwDnloadIDTable[dwID] = *pDnloadID; //pISWEffect;
		
		// keep track of the highest ID in the effect table
		if (dwID > dwMaxID)
			dwMaxID = dwID;

		// try to descend the next efct
		mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
							   MMIO_FINDLIST);
		if(mmresult == MMIOERR_CHUNKNOTFOUND)
		{
			// we are at the end of the list
			bDone = TRUE;
		}
		else if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}
	}
	while(!bDone);

	// ascend from trak list
	mmresult = mmioAscend(hmmio, &mmckinfoTrackLIST, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// ascend from FORCE RIFF
	mmresult = mmioAscend(hmmio, &mmckinfoForceEffectRIFF, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// get the return value
	//*pDnloadID = dwCurrentDnloadID;

	// clear the final effect's entry in the table so we don't destroy it during cleanup
	rgdwDnloadIDTable[dwID] = 0;

	// at this point the entire table should be NULL... make sure of it
	for (c = 0; c <= dwMaxID; c++)
		;

#ifdef _DEBUG
	bFunctionSuccessful = TRUE;
#endif //_DEBUG

	cleanup:

	// destroy everything in the effect table that isn't NULL 
	for (c = 0; c <= dwMaxID; c++)
		if (NULL != rgdwDnloadIDTable[c])
		{
			FFD_DestroyEffect(rgdwDnloadIDTable[c]);
			rgdwDnloadIDTable[c] = 0;
#ifdef _DEBUG
			nEffectsDestroyed++;
#endif //_DEBUG
		}

#ifdef _DEBUG
	// make sure we destroy all but one created effect on success,
	// and that we destory -every- created effect on failure.
	if (bFunctionSuccessful)
	{
		;//ASSERT(nEffectsCreated - 1 == nEffectsDestroyed);
	}
	else
	{
		;//ASSERT(nEffectsCreated == nEffectsDestroyed);
	}
#endif //_DEBUG

	// close the memory RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pParam != NULL)
		delete [] pParam;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;

}

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult)
{
	HRESULT hResult;

	switch(mmresult)
	{
		case MMIOERR_FILENOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_OUTOFMEMORY:
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			break;
		case MMIOERR_CANNOTOPEN:
			hResult = VFX_ERR_FILE_CANNOT_OPEN;
			break;
		case MMIOERR_CANNOTCLOSE:
			hResult = VFX_ERR_FILE_CANNOT_CLOSE;
			break;
		case MMIOERR_CANNOTREAD:
			hResult = VFX_ERR_FILE_CANNOT_READ;
			break;
		case MMIOERR_CANNOTWRITE:
			hResult = VFX_ERR_FILE_CANNOT_WRITE;
			break;
		case MMIOERR_CANNOTSEEK:
			hResult = VFX_ERR_FILE_CANNOT_SEEK;
			break;
		case MMIOERR_CANNOTEXPAND:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_CHUNKNOTFOUND:
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			break;
		case MMIOERR_UNBUFFERED:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_PATHNOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_ACCESSDENIED:
			hResult = VFX_ERR_FILE_ACCESS_DENIED;
			break;
		case MMIOERR_SHARINGVIOLATION:
			hResult = VFX_ERR_FILE_SHARING_VIOLATION;
			break;
		case MMIOERR_NETWORKERROR:
			hResult = VFX_ERR_FILE_NETWORK_ERROR;
			break;
		case MMIOERR_TOOMANYOPENFILES:
			hResult = VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			break;
		case MMIOERR_INVALIDFILE:
			hResult = VFX_ERR_FILE_INVALID;
			break;
		default:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffdevice.cpp ===
//@doc
/******************************************************
**
** @module FFDEVICE.CPP | Implementation file for FFDevice class
**
** Description:
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
**			21-Mar-99	waltw	Added dwDeviceID to SetFirmwareVersion,
**								InitJoystickParams, StateChange, InitRTCSpring,
**								InitRTCSpring200
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#include "FFDevice.h"
#include "Midi_obj.hpp"
#include "DTrans.h"
#include "DPack.h"
#include "joyregst.hpp"
#include "CritSec.h"
#include <crt/io.h>			// For file routines
#include <FCNTL.h>		// File _open flags
#include <math.h>		// for sin and cos

extern CJoltMidi* g_pJoltMidi;

//
// --- VFX Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')
#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')
#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')
#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')
#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')

ForceFeedbackDevice g_ForceFeedbackDevice;

#include <errno.h>		// For open file errors
HRESULT LoadBufferFromFile(const char* fileName, PBYTE& pBufferBytes, ULONG& numFileBytes)
{
	if (pBufferBytes != NULL) {
		ASSUME_NOT_REACHED();
		numFileBytes = 0;
		return VFX_ERR_FILE_OUT_OF_MEMORY;
	}

	int fHandle = ::_open(fileName, _O_RDONLY | _O_BINARY);
	if (fHandle == -1) {
		numFileBytes = 0;
		switch (errno) {
			case EACCES : return VFX_ERR_FILE_ACCESS_DENIED;
			case EMFILE : return VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			case ENOENT : return VFX_ERR_FILE_NOT_FOUND;
		}
		return VFX_ERR_FILE_CANNOT_OPEN;		// Who knows what went wrong
	}
	
	HRESULT hr = S_OK;
	numFileBytes = ::_lseek(fHandle, 0, SEEK_END);
	if (numFileBytes == -1) {		// Seek failed
		hr = VFX_ERR_FILE_CANNOT_SEEK;
	} else if (numFileBytes == 0) {	// Empty file
		hr = VFX_ERR_FILE_BAD_FORMAT;
	} else {
		pBufferBytes = new BYTE[numFileBytes];
		if (pBufferBytes == NULL) {	// Could not allocate memory
			hr = VFX_ERR_FILE_OUT_OF_MEMORY;
		} else {
			if (::_lseek(fHandle, 0, SEEK_SET) == -1) {	// Failed seek to begining
				hr = VFX_ERR_FILE_CANNOT_SEEK;
			} else if (::_read(fHandle, pBufferBytes, numFileBytes) == -1) {	// Failed to read
				hr = VFX_ERR_FILE_CANNOT_READ;
			}
			if (hr != S_OK) {	// Things didn't go well
				delete[] pBufferBytes;
				pBufferBytes = NULL;
			}
		}
	}

	::_close(fHandle);
	return hr;
}

/******************************************************
**
** ForceFeedbackDevice::ForceFeedbackDevice()
**
** @mfunc Constructor.
**
******************************************************/
ForceFeedbackDevice::ForceFeedbackDevice() :
	m_FirmwareAckNackValues(0),
	m_FirmwareVersionMajor(0),
	m_FirmwareVersionMinor(0),
	m_DriverVersionMajor(0),
	m_DriverVersionMinor(0),
	m_SpringOffset(0),
	m_Mapping(0),
	m_DIStateFlags(0),
	m_RawForceX(0),
	m_RawForceY(0)
{
	m_OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&m_OSVersion);

	for (int index = 0; index < 14; index++) {
		m_PercentMappings[index] = 100;	// Default is 100 percent till I'm told otherwise
	}
	for (index = 0; index < MAX_EFFECT_IDS; index++) {
		m_EffectList[index] = NULL;
	}
	m_SystemEffect = NULL;

	::memset(&m_Version200State, 0, sizeof(m_Version200State));
	::memset(&m_LastStatusPacket, 0, sizeof(m_LastStatusPacket));	
}

/******************************************************
**
** ForceFeedbackDevice::~ForceFeedbackDevice()
**
** @mfunc Destructor.
**
******************************************************/
ForceFeedbackDevice::~ForceFeedbackDevice()
{
	BOOL lingerer = FALSE;

	// Destroy the RTCSpring and SystemEffect if still hanging aroung
	if (m_EffectList[0] != NULL) {
		delete m_EffectList[0];
		m_EffectList[0] = NULL;
	}
	if (m_SystemEffect != NULL) {
		delete m_SystemEffect;
		m_SystemEffect = NULL;
	}

	// Destroy any lingering effects (of which there should be none)
	for (int index = 0; index < MAX_EFFECT_IDS; index++) {
		if (m_EffectList[index] != NULL) {
			lingerer = TRUE;
			delete m_EffectList[index];
			m_EffectList[index] = NULL;
		}
	}

	ASSUME(lingerer == FALSE);	// Assuming programmer cleaned up thier own mess
}


/******************************************************
**
** ForceFeedbackDevice::DetectHardware()
**
** @mfunc DetectHardware.
**
******************************************************/
BOOL ForceFeedbackDevice::DetectHardware()
{
	if (NULL == g_pJoltMidi)
		return (FALSE);
	else
		return g_pJoltMidi->QueryForJolt();
}

/******************************************************
**
** ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
**
** @mfunc SetFirmwareVersion.
**
******************************************************/
void ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
{
	m_FirmwareVersionMajor = major;
	m_FirmwareVersionMinor = minor;

	if (g_pDataPackager != NULL) {
		delete g_pDataPackager;
		g_pDataPackager = NULL;
	}

	if (m_FirmwareVersionMajor == 1) {
		ASSUME_NOT_REACHED();	// Currently this code only supports wheel - this is a Jolt version
//		g_pDataPackager = new DataPackager100();
	} else {	// Till version number is locked down
		g_pDataPackager = new DataPackager200();
	}

	ASSUME_NOT_NULL(g_pDataPackager);

	m_FirmwareAckNackValues = GetAckNackMethodFromRegistry(dwDeviceID);
	m_SpringOffset = GetSpringOffsetFromRegistry(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
**
** @mfunc SetDriverVersion.
**
******************************************************/
void ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
{
	if ((major == 0xFFFFFFFF) && (minor == 0xFFFFFFFF)) {	// Check for version 1.0 driver version error
		m_DriverVersionMajor = 1;
		m_DriverVersionMinor = 0;
	} else {
		m_DriverVersionMajor = major;
		m_DriverVersionMinor = minor;
	}
}

/******************************************************
**
** ForceFeedbackDevice::GetYMappingPercent(UINT index)
**
** @mfunc GetYMappingPercent.
**
******************************************************/
short ForceFeedbackDevice::GetYMappingPercent(UINT index) const
{
	if (m_Mapping & Y_AXIS) {
		if (index < 14) {
			return m_PercentMappings[index];
		}
	}
	return 0;
}

/******************************************************
**
** ForceFeedbackDevice::GetEffect(DWORD effectID) const
**
** @mfunc GetEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::GetEffect(DWORD effectID) const
{
	if (effectID == SYSTEM_EFFECT_ID) { // SystemEffect not stored in array
		return m_SystemEffect;
	}

	if (effectID == SYSTEM_RTCSPRING_ALIAS_ID) { // Remapping of RTC spring
		return m_EffectList[0];
	}

	if (effectID == RAW_FORCE_ALIAS) {
		return NULL;
	}

	// Parameter check
	if (effectID >= MAX_EFFECT_IDS) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	return m_EffectList[effectID];
}

/******************************************************
**
** ForceFeedbackDevice::RemoveEffect(DWORD effectID) const
**
** @mfunc GetEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::RemoveEffect(DWORD effectID)
{
	// There really is no raw force effect
	if (effectID == RAW_FORCE_ALIAS) {
		return NULL;
	}

	// Cannot remove system effects
	if ((effectID == SYSTEM_EFFECT_ID) || (effectID == 0) || (effectID == SYSTEM_RTCSPRING_ALIAS_ID)) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	// Parameter check
	if (effectID >= MAX_EFFECT_IDS) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	InternalEffect* pEffect = m_EffectList[effectID];
	m_EffectList[effectID] = NULL;
	return pEffect;
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring(DWORD dwDeviceID)
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data packager
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data transmitter
	}

	if (GetFirmwareVersionMajor() == 1) {
		return InitRTCSpring1XX(dwDeviceID);
	}
	return InitRTCSpring200(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring1XX()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring1XX(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(SYSTEM_RTCSPRING_ID) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}

	// DIEFFECT structure to fill
	DICONDITION cond[2];
	DIEFFECT rtc;
	rtc.dwSize = sizeof(DIEFFECT);
	rtc.cbTypeSpecificParams = sizeof(DICONDITION) * 2;
	rtc.lpvTypeSpecificParams = cond;

	// The default RTCSpring (the one on the stick)
	RTCSpring1XX rtcSpring1XX;	// Def Parms filled by constructor

	// Default RTCSpring from the registry
	RTCSPRING_PARAM parms;
	GetSystemParams(dwDeviceID, (SYSTEM_PARAMS*)(&parms));
	cond[0].lPositiveCoefficient = parms.m_XKConstant;
	cond[1].lPositiveCoefficient = parms.m_YKConstant;
	cond[0].lOffset = parms.m_XAxisCenter;
	cond[1].lOffset = parms.m_YAxisCenter;
	cond[0].dwPositiveSaturation = parms.m_XSaturation;
	cond[1].dwPositiveSaturation = parms.m_YSaturation;
	cond[0].lDeadBand = parms.m_XDeadBand;
	cond[1].lDeadBand = parms.m_YDeadBand;

	// Allocate and create the RTCSpring
	InternalEffect* pNewRTCSpring = InternalEffect::CreateRTCSpring();
	if (pNewRTCSpring == NULL) {
		return SFERR_DRIVER_ERROR;
	}
	if (pNewRTCSpring->Create(rtc) != SUCCESS) {
		delete pNewRTCSpring;	// Could not create system RTC Spring
		return SFERR_DRIVER_ERROR;
	}

	// Replace the stick default with the registry default
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, &rtcSpring1XX);				// Temporary pointer needed (but we only store temporarily)
	g_pDataPackager->ModifyEffect(rtcSpring1XX, *pNewRTCSpring, 0);		// Package relative changes
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, pNewRTCSpring);				// Replace the old with the new

	pNewRTCSpring = NULL; // Forgotten, but not gone

	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring200()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring200(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(ID_RTCSPRING_200) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}

	// The temporary spring and the allocated one
	InternalEffect* pNewRTCSpring = NULL;

	// DIEFFECT structure to fill
	DICONDITION cond[2];
	DIEFFECT rtc;
	rtc.dwSize = sizeof(DIEFFECT);
	rtc.cbTypeSpecificParams = sizeof(DICONDITION) * 2;
	rtc.lpvTypeSpecificParams = cond;


	// The default RTCSpring (the one on the stick)
	RTCSpring200 rtcSpring200;	// Default values filled in by constructor

	// Default RTCSpring from the registry
	GetRTCSpringData(dwDeviceID, cond);

	// Allocate and create the RTCSpring
	pNewRTCSpring = InternalEffect::CreateRTCSpring();
	if (pNewRTCSpring == NULL) {
		return SFERR_DRIVER_ERROR;
	}
	HRESULT createResult = pNewRTCSpring->Create(rtc);
	if (FAILED(createResult)) {
		delete pNewRTCSpring;	// Could not create system RTC Spring
		return SFERR_DRIVER_ERROR;
	}

	// Replace the stick default with the registry default
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, &rtcSpring200);				// Temporary pointer needed (but we only store temporarily)
	g_pDataPackager->ModifyEffect(rtcSpring200, *pNewRTCSpring, 0);		// Package relative changes
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, pNewRTCSpring);				// Replace the old with the new

	pNewRTCSpring = NULL; // Forgotten, but not gone
	ACKNACK ackNack;
	HRESULT transmitResult = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (transmitResult != S_OK) {
		return transmitResult;
	}
	return createResult;
}

/******************************************************
**
** ForceFeedbackDevice::InitJoystickParams()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitJoystickParams(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(SYSTEM_EFFECT_ID) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data packager
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data transmitter
	}

	// Force Mapping
	m_Mapping = ::GetMapping(dwDeviceID);
	::GetMappingPercents(dwDeviceID, m_PercentMappings, 14);


	if (GetFirmwareVersionMajor() == 1) {
		// The default System Effect (the one on the stick)
		SystemEffect1XX systemEffect;

		// Default System Effect from the registry
		SystemStickData1XX sysData;
		sysData.SetFromRegistry(dwDeviceID);

		// Put the registry system values into a DIEFFECT
		DIEFFECT systemDIEffect;
		systemDIEffect.dwSize = sizeof(DIEFFECT);
		systemDIEffect.cbTypeSpecificParams = sizeof(SystemStickData1XX);
		systemDIEffect.lpvTypeSpecificParams = &sysData;

		// Get a system effect (and fill it with our local DIEffect information
		SystemEffect1XX* pSystemEffect = (SystemEffect1XX*)(InternalEffect::CreateSystemEffect());
		if (pSystemEffect == NULL) {
			return SFERR_DRIVER_ERROR;
		}
		if (pSystemEffect->Create(systemDIEffect) != SUCCESS) {
			delete pSystemEffect;	// Couldnot create SystemEffect
			return SFERR_DRIVER_ERROR;
		}

		// Replace the stick default with the registry default
		SetEffect(SYSTEM_EFFECT_ID, &systemEffect);						// Temporary pointer (but we only store temporarily)
		g_pDataPackager->ModifyEffect(systemEffect, *pSystemEffect, 0);	// Package relative changes
		SetEffect(SYSTEM_EFFECT_ID, pSystemEffect);						// Replace the old with the new
		pSystemEffect = NULL; // Forgotten, but not gone
		ACKNACK ackNack;
		return g_pDataTransmitter->Transmit(ackNack);	// Send it off
	}

	return SUCCESS;
}

/******************************************************
**
** ForceFeedbackDevice::StateChange(DWORD newStateFlags)
**
** @mfunc StateChange.
**
******************************************************/
void ForceFeedbackDevice::StateChange(DWORD dwDeviceID, DWORD newStateFlag)
{
	if (newStateFlag == DISFFC_RESET) {		// Stick is reset need to remove local copies of user commands
		// Remove all effect from our list
		for (int index = 2; index < MAX_EFFECT_IDS; index++) {
			if (m_EffectList[index] != NULL) {
				delete m_EffectList[index];
				m_EffectList[index] = NULL;
			}
		}

		// Remove individual axis raw effects
		m_RawForceX = 0;
		m_RawForceY = 0;

		// Look at the Y mapping, perhaps it changed
		m_Mapping = ::GetMapping(dwDeviceID);
		::GetMappingPercents(dwDeviceID, m_PercentMappings, 14);
	} else if (newStateFlag == DISFFC_STOPALL) {
		m_RawForceX = 0;
		m_RawForceY = 0;
	}

	m_DIStateFlags = newStateFlag;
}

/******************************************************
**
** ForceFeedbackDevice::CreateConditionEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateConditionEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateConditionEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;
	switch (minorType) {
		case BE_SPRING:
		case BE_SPRING_2D: {
			pReturnEffect = InternalEffect::CreateSpring();
			break;
		}
		case BE_DAMPER:
		case BE_DAMPER_2D: {
			pReturnEffect = InternalEffect::CreateDamper();
			break;
		}
		case BE_INERTIA:
		case BE_INERTIA_2D: {
			pReturnEffect = InternalEffect::CreateInertia();
			break;
		}
		case BE_FRICTION:
		case BE_FRICTION_2D: {
			pReturnEffect = InternalEffect::CreateFriction();
			break;
		}
		case BE_WALL: {
			pReturnEffect = InternalEffect::CreateWall();
			break;
		}
	}

	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr)) {
			delete pReturnEffect;
		}
	}
	return pReturnEffect;
}

/******************************************************
**
** ForceFeedbackDevice::CreateRTCSpringEffect(DWORD subType, const DIEFFECT& diEffect)
**
** @mfunc CreateRTCSpringEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateRTCSpringEffect(DWORD minorType, const DIEFFECT& diEffect)
{
	InternalEffect* pEffect = InternalEffect::CreateRTCSpring();
	if (pEffect != NULL) {
		if (pEffect->Create(diEffect) == SUCCESS) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateCustomForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateCustomForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateCustomForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateCustomForce();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (SUCCEEDED(hr)) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreatePeriodicEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreatePeriodicEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreatePeriodicEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;
	switch (minorType) {
		case SE_SINE: {
			pReturnEffect = InternalEffect::CreateSine();
			break;
		}
		case SE_SQUAREHIGH: {
			pReturnEffect = InternalEffect::CreateSquare();
			break;
		}
		case SE_TRIANGLEUP: {
			pReturnEffect = InternalEffect::CreateTriangle();
			break;
		}
		case SE_SAWTOOTHUP: {
			pReturnEffect = InternalEffect::CreateSawtoothUp();
			break;
		}
		case SE_SAWTOOTHDOWN: {
			pReturnEffect = InternalEffect::CreateSawtoothDown();
			break;
		}
		case SE_CONSTANT_FORCE: {
			return CreateConstantForceEffect(minorType, diEffect, hr);
		}
		case SE_RAMPUP: {
			return CreateRampForceEffect(minorType, diEffect, hr);
		}
	}
	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr) == FALSE) {
			return pReturnEffect;
		}
		delete pReturnEffect;
	}

	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateConstantForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateConstantForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateConstantForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateConstantForce();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (FAILED(hr) == FALSE) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateRampForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateRampForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateRampForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateRamp();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (SUCCEEDED(hr)) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::SendRawForce(const DIEFFECT& diEffect)
**
** @mfunc SendRawForce.
**
******************************************************/
HRESULT ForceFeedbackDevice::SendRawForce(const DIEFFECT& diEffect, BOOL paramCheck)
{
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(DICONSTANTFORCE)) {
		return SFERR_INVALID_PARAM;
	}

	// We don't support more than 2 axes, and 0 is probably an error
	if ((diEffect.cAxes > 2) || (diEffect.cAxes == 0)) {
		return SFERR_NO_SUPPORT;
	}

	// Set up the axis mask
	DWORD axisMask = 0;
	for (unsigned int axisIndex = 0; axisIndex < diEffect.cAxes; axisIndex++) {
		DWORD axisNumber = DIDFT_GETINSTANCE(diEffect.rgdwAxes[axisIndex]);
		axisMask |= 1 << axisNumber;
	}
	BOOL axesReversed = (DIDFT_GETINSTANCE(diEffect.rgdwAxes[0]) == 1);

	double angle = 0.0;
	// Check coordinate sytems and change to rectangular
	if (diEffect.dwFlags & DIEFF_SPHERICAL) {	// We don't support sperical (3 axis force)
		return SFERR_NO_SUPPORT;				// .. since got by axis check, programmer goofed up
	}
	if (diEffect.dwFlags & DIEFF_POLAR) {
		if (diEffect.cAxes != 2) { // Polar coordinate must have two axes of data (because DX says so)
			return SFERR_INVALID_PARAM;
		}
		DWORD effectAngle = diEffect.rglDirection[0];	// in [0] even if reversed
		if (axesReversed) {		// Indicates (-1, 0) as origin instead of (0, -1)
			effectAngle += 27000;
		}
		effectAngle %= 36000;

		angle = double(effectAngle)/18000 * 3.14159;	// Convert to radians
		m_RawForceX = 0;
		m_RawForceY = 0;
	} else if (diEffect.dwFlags & DIEFF_CARTESIAN) { // Convert to polar (so we can convert to cartesian)
		if (diEffect.cAxes == 1) {	// Fairly easy conversion
			if (X_AXIS & axisMask) {
				angle = 3.14159/2;		// PI/2
			} else {
				angle = 0.0;
			}
		} else { // Multiple axis cartiesian
			m_RawForceX = 0;
			m_RawForceY = 0;

			int xDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[0]);
			int yDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[1]);
			if (axesReversed == TRUE) {
				yDirection = xDirection;
				xDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[1]);
			}
			angle = atan2(double(yDirection), double(xDirection));
		}
	} else {	// What, is there some other format?
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;	// Untill someone says otherwise there was an error
	}

	// Sin^2(a) + Cos^2(a) = 1
	double xProj = ::sin(angle);	// DI has 0 degs at (1, 0) not (0, 1)
	double yProj = ::cos(angle);
	xProj *= xProj;
	yProj *= yProj;
	DWORD percentX = DWORD(xProj * 100.0 + 0.05);
	DWORD percentY = DWORD(yProj * 100.0 + 0.05);

	BOOL truncated = FALSE;
	if (percentX != 0) {
		m_RawForceX = LONG(percentX * (((DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams))->lMagnitude/100));
		if (m_RawForceX > 10000) {
			m_RawForceX  = 10000;
			truncated = TRUE;
		} else if (m_RawForceX < -10000) {
			m_RawForceX  = -10000;
			truncated = TRUE;
		}
	}
	if (percentY != 0) {
		m_RawForceY = LONG(percentY * (((DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams))->lMagnitude/100));
		if (m_RawForceY > 10000) {
			m_RawForceY = 10000;
			truncated = TRUE;
		} else if (m_RawForceY < -10000) {
			m_RawForceY = -10000;
			truncated = TRUE;
		}
	}
	long int mag = m_RawForceX + m_RawForceY * GetYMappingPercent(ET_RAWFORCE_200)/100;
	if (mag > 10000) {	// Check for overrun but don't return indication of truncation
		mag = 10000;
	} else if (mag < -10000) {
		mag = -10000;
	}
	if (angle > 3.14159) {	// PI
		mag *= -1;
	}
	HRESULT hr = g_pDataPackager->ForceOut(mag, X_AXIS);
	if ((hr != SUCCESS) || (paramCheck == TRUE)) {
		return hr;
	}

	ACKNACK ackNack;
	g_pDataTransmitter->Transmit(ackNack);

	if (truncated == TRUE) {
		return DI_TRUNCATED;
	}
	return SUCCESS;
}

/******************************************************
**
** ForceFeedbackDevice::CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateVFXEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr)
{
/*	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
*/
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return NULL;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(VFX_PARAM)) {
		return NULL;
	}

	VFX_PARAM* pVFXParms = (VFX_PARAM*)diEffect.lpvTypeSpecificParams;
	BYTE* pEffectBuffer = NULL;
	ULONG numBufferBytes = 0;
	if (pVFXParms->m_PointerType == VFX_FILENAME) {		// Create memory buffer from file
		hr = LoadBufferFromFile((const char*)(pVFXParms->m_pFileNameOrBuffer), pEffectBuffer, numBufferBytes);
	} else {
		pEffectBuffer = (BYTE*)(pVFXParms->m_pFileNameOrBuffer);
		numBufferBytes = pVFXParms->m_BufferSize;
	}

	if ((pEffectBuffer == NULL) || (numBufferBytes == 0)) {
		return NULL;
	}

	return CreateVFXEffectFromBuffer(diEffect, pEffectBuffer, numBufferBytes, hr);
}

/******************************************************
**
** ForceFeedbackDevice::CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr)
**
** @mfunc CreateVFXEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr)
{
	if ((pEffectBuffer == NULL) || (numBufferBytes == 0)) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	MMIOINFO mmioInfo;
	::memset(&mmioInfo, 0, sizeof(MMIOINFO));
	mmioInfo.fccIOProc = FOURCC_MEM;
	mmioInfo.cchBuffer = numBufferBytes;
	mmioInfo.pchBuffer = (char*)pEffectBuffer;

	HMMIO hmmio = ::mmioOpen(NULL, &mmioInfo, MMIO_READ);
	if (hmmio == NULL) {
		return NULL;
	}

	BYTE* pEffectParms = NULL;
	DWORD paramSize;
	EFFECT effect;		// SW EFFECT structure
	ENVELOPE envelope;	// SW ENVELOPE structure

	try {	// Try parsing the RIFF file
		MMRESULT mmResult;

		// Descend into FORC list
		MMCKINFO forceEffectRiffInfo;
		forceEffectRiffInfo.fccType = FCC_FORCE_EFFECT_RIFF;
		if ((mmResult = ::mmioDescend(hmmio, &forceEffectRiffInfo, NULL, MMIO_FINDRIFF)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into TRAK list
		MMCKINFO trakListInfo;
		trakListInfo.fccType = FCC_TRACK_LIST;
		if ((mmResult = ::mmioDescend(hmmio, &trakListInfo, &forceEffectRiffInfo, MMIO_FINDLIST)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into first EFCT list
		MMCKINFO effectListInfo;
		effectListInfo.fccType = FCC_EFFECT_LIST;
		if ((mmResult = ::mmioDescend(hmmio, &effectListInfo, &trakListInfo, MMIO_FINDLIST)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into the ID chunk (maybe someone has a clue what is in here)
		MMCKINFO idInfo;
		idInfo.ckid = FCC_ID_CHUNK;
		if ((mmResult = ::mmioDescend(hmmio, &idInfo, &effectListInfo, MMIO_FINDCHUNK)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}
		// Find the number of IDs in here (should indicate the number of effect)
		DWORD numEffects = idInfo.cksize/sizeof(DWORD);
		if (numEffects != 1) {
			throw SFERR_NO_SUPPORT;
		}
		// Read the ID chunk
		DWORD id;
		DWORD bytesRead = ::mmioRead(hmmio, (char*)&id, sizeof(DWORD));
		if (bytesRead != sizeof(DWORD)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Back out of the ID chunk
		if ((mmResult = ::mmioAscend(hmmio, &idInfo, 0)) != MMSYSERR_NOERROR) {
			throw HRESULT_FROM_WIN32(mmResult);
		}

		// Descend into the DATA chunk
		MMCKINFO dataInfo;
		dataInfo.ckid = FCC_DATA_CHUNK;
		if ((mmResult = ::mmioDescend(hmmio, &dataInfo, &effectListInfo, MMIO_FINDCHUNK)) != MMSYSERR_NOERROR) {
			throw HRESULT_FROM_WIN32(mmResult);
		}
		// Read the effect structure from this chunk
		bytesRead = ::mmioRead(hmmio, (char*)&effect, sizeof(EFFECT));
		if (bytesRead != sizeof(EFFECT)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Read the envelope structure from this chunk
		bytesRead = ::mmioRead(hmmio, (char*)&envelope, sizeof(ENVELOPE));
		if (bytesRead != sizeof(ENVELOPE)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Read the parameters in:
		//	-- Figure out the paramter size
		DWORD currentFilePos = ::mmioSeek(hmmio, 0, SEEK_CUR);
		if (currentFilePos == -1) {
			throw VFX_ERR_FILE_CANNOT_SEEK;
		}
		paramSize = dataInfo.dwDataOffset + dataInfo.cksize - currentFilePos;
		// -- Allocate space for the parameter
		pEffectParms = new BYTE[paramSize];
		if (pEffectParms == NULL) {
			throw VFX_ERR_FILE_OUT_OF_MEMORY;
		}
		// -- Do the actual reading
		bytesRead = ::mmioRead(hmmio, (char*)pEffectParms, paramSize);
		if (bytesRead != paramSize) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// -- The pointer must be fixed if this is User Defined
		if (effect.m_Type == EF_USER_DEFINED) {
			BYTE* pForceData = pEffectParms + sizeof(UD_PARAM);
			UD_PARAM* pUDParam = (UD_PARAM*)pEffectParms;
			pUDParam->m_pForceData = (LONG*)pForceData;
		}
	} catch (HRESULT thrownError) {
		hr = thrownError;
		::mmioClose(hmmio, 0);
		if (pEffectParms == NULL) {	// Did we get an effect?
			return NULL;
		}
	}

	::mmioClose(hmmio, 0);	// Close the file
	if (pEffectParms == NULL) {
		ASSUME_NOT_REACHED();	//Exception should have been thrown
		return NULL;
	}

	InternalEffect* pReturnEffect = InternalEffect::CreateFromVFX(diEffect, effect, envelope, pEffectParms, paramSize, hr);

	// Cleanup
	delete pEffectParms;
	pEffectParms = NULL;

	return pReturnEffect;
}

/******************************************************
**
** ForceFeedbackDevice::CreateEffect(DWORD& effectID, const DIEFFECT& diEffect)
**
** @mfunc CreateEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateEffect(DWORD effectType, const DIEFFECT& diEffect, DWORD& dnloadID, HRESULT& hr, BOOL paramCheck)
{
	WORD majorType = WORD((effectType >> 16) & 0x0000FFFF);
	WORD minorType = WORD(effectType & 0x0000FFFF);

	if (majorType == EF_RAW_FORCE) {
		hr = SendRawForce(diEffect, paramCheck);
		if (SUCCEEDED(hr)) {
			dnloadID = RAW_FORCE_ALIAS;
		}
		return NULL;
	}

	InternalEffect* pEffect = NULL;
	BOOL isNewEffect = (dnloadID == 0);
	if (isNewEffect) {
		dnloadID = g_ForceFeedbackDevice.GetNextCreationID();
		if (dnloadID == 0) {
			hr = SFERR_OUT_OF_FF_MEMORY;
			return NULL;
		}
	}

	hr = SUCCESS;

	switch (majorType) {
		case EF_BEHAVIOR: {
			pEffect = CreateConditionEffect(minorType, diEffect, hr);
			break;
		}
		case EF_USER_DEFINED: {
			pEffect = CreateCustomForceEffect(minorType, diEffect, hr);
			break;
		}
		case EF_SYNTHESIZED: {
			pEffect = CreatePeriodicEffect(minorType, diEffect, hr);
			break;
		}
		case EF_RTC_SPRING: {
			dnloadID = SYSTEM_RTCSPRING_ALIAS_ID;
			pEffect = CreateRTCSpringEffect(minorType, diEffect);
			break;
		}
		case EF_VFX_EFFECT: {	// Visual force VFX Effect!!! Danger Will Robinson!
			pEffect = CreateVFXEffect(diEffect, hr);
			break;
		}
	}
	if (((pEffect == NULL) || (paramCheck == TRUE)) && (isNewEffect == TRUE)) {
		dnloadID = 0;
	}

	if (pEffect != NULL) {
		if ((isNewEffect == TRUE) && (paramCheck == FALSE)) {
			g_ForceFeedbackDevice.SetEffect(BYTE(dnloadID), pEffect);
		}
	} else if (!FAILED(hr)) {
		hr = SFERR_DRIVER_ERROR;
	}
	return pEffect;
}

/******************************************************
**
** ForceFeedbackDevice::GetNextCreationID() const
**
** @mfunc GetNextCreationID.
**
******************************************************/
BYTE ForceFeedbackDevice::GetNextCreationID() const
{
	// Must search straight through (start at 2, 0 is spring, 1 is friction
	for (BYTE emptyID = 2; emptyID < MAX_EFFECT_IDS; emptyID++) {
		if (m_EffectList[emptyID] == NULL) {
			break;
		}
	}
	if (emptyID == MAX_EFFECT_IDS) {
		return 0;
	}
	return emptyID;
}

/******************************************************
**
** ForceFeedbackDevice::SetEffect(BYTE globalID, BYTE deviceID, InternalEffect* pEffect)
**
** @mfunc SetEffect.
**
******************************************************/
void ForceFeedbackDevice::SetEffect(BYTE globalID, InternalEffect* pEffect)
{
	if (pEffect == NULL) {
		ASSUME_NOT_REACHED();
		return;
	}

	if (globalID == SYSTEM_EFFECT_ID) {
		m_SystemEffect = pEffect;
	} else if (globalID == SYSTEM_RTCSPRING_ALIAS_ID) {
		m_EffectList[0] = pEffect;
		if (GetFirmwareVersionMajor() == 1) {
			pEffect->SetGlobalID(SYSTEM_RTCSPRING_ID);
			pEffect->SetDeviceID(SYSTEM_RTCSPRING_ID);
		} else {
			pEffect->SetGlobalID(ID_RTCSPRING_200);
			pEffect->SetDeviceID(ID_RTCSPRING_200);
		}
		return;
	} else if (globalID < MAX_EFFECT_IDS) {
		m_EffectList[globalID] = pEffect;
	} else {
		ASSUME_NOT_REACHED();	// Out of range
	}

	pEffect->SetGlobalID(globalID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDeviceIDFromStatusPacket(DWORD globalID)
**
** @mfunc SetDeviceIDFromStatusPacket.
**
******************************************************/
void ForceFeedbackDevice::SetDeviceIDFromStatusPacket(DWORD globalID)
{
	if (globalID == SYSTEM_EFFECT_ID) {
		return;
	}
	if (globalID == SYSTEM_RTCSPRING_ALIAS_ID) {
		return;
	}
	if (globalID < MAX_EFFECT_IDS) {
		InternalEffect* pEffect = m_EffectList[globalID];
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();		// There should be an effect here
			return;
		}
		pEffect->SetDeviceID(BYTE(m_LastStatusPacket.dwEffect));
#ifdef _DEBUG		// Check to see if they coincide
		if (pEffect->GetGlobalID() != pEffect->GetDeviceID()) {
			TCHAR buff[256];
			::wsprintf(buff, TEXT("SW_WHEEL.DLL: Global ID (%d) != Download ID (%d)\r\n"), pEffect->GetGlobalID(), pEffect->GetDeviceID());
			_RPT0(_CRT_WARN, buff);
		}
#endif _DEBUG
	} else {
		ASSUME_NOT_REACHED();	// Out of range
	}
}	


/******************************************************
**
** ForceFeedbackDevice::QueryStatus()
**
** @mfunc QueryStatus.
**
******************************************************/
HRESULT ForceFeedbackDevice::QueryStatus()
{
	CriticalLock cl;	// This is a critical section
	
	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS statusPacket = {sizeof(JOYCHANNELSTATUS)};
	
	HRESULT hRet = g_pDriverCommunicator->GetStatus(statusPacket);
	if (hRet == SUCCESS) {
		if (GetFirmwareVersionMajor() == 1) {
			// This is irrelevant till we support jolt
		} else {
			if (sizeof(statusPacket.dwDeviceStatus) == sizeof(m_Version200State)) {
				::memcpy(&m_Version200State, &(statusPacket.dwDeviceStatus), sizeof(statusPacket.dwDeviceStatus));
			} else {
				ASSUME_NOT_REACHED();
			}
		}
	}

	return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\dtrans.h ===
//@doc
/******************************************************
**
** @module DTRANS.H | Definition file for DataTransmitter
**
** Description:
**		The Data Transmitters allow virtualization of the
**	actual media used for transmission of data to the FF Device
**		DataTransmitter - Base class that defines the functionality
**		SerialDataTransmitter - Transmitter for Serial (via CreateFile)
**		BackdoorDataTransmitter - Base class for Ring0 Driver based direct port communication
**		SerialBackdoorDataTransmitter - Direct backdoor Serial Port Communication
**		MidiBackdoorDataTransmitter - Direct backdoor Midi Port Communication
**
** Classes:
**		DataTransmitter
**		SerialDataTransmitter : DataTransmitter
**		BackdoorDataTransmitter : DataTransmitter
**		SerialBackdoorDataTransmitter : BackdoorDataTransmitter
**		MidiBackdoorDataTransmitter : BackdoorDataTransmitter
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**			22-Mar-99	waltw	Added DWORD dwDeviceID param to Initialize
**								members of DataTransmitter and derived classes
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DTRANS_H__
#define	__DTRANS_H__

#include <dinput.h>
#include "midi.hpp"
#include "VxdIOCTL.hpp"

#ifndef override
#define override
#endif

//
// @class DataTransmitter class
//
class DataTransmitter
{
	//@access Constructor
	protected:
		//@cmember constructor
		DataTransmitter() : m_NackToggle(2) {};
	//@access Destructor
	public:
		//@cmember destructor
		virtual ~DataTransmitter() {};

	//@access Member functions
	public:
		HRESULT Transmit(ACKNACK& ackNack);

		virtual BOOL Initialize(DWORD dwDeviceID) { return FALSE; }
		void SetNextNack(SHORT nextNack) { m_NackToggle = nextNack; }
		BOOL NackToggle() const { return (m_NackToggle == 1); }

		virtual BOOL WaitTillSendFinished(DWORD timeOut) { return TRUE; }
		virtual HANDLE GetCOMMHandleHack() const { return NULL; }
		virtual void StopAutoClose() {}; // Temporary hack to avoid closing own handle (for backdoor serial)
		virtual ULONG GetSerialPortHack() { return 0; }
	protected:
		virtual BOOL Send(BYTE* data, UINT numBytes) const { return FALSE; }	// Outsiders call transmit!

	private:
		SHORT m_NackToggle;
};

//
// @class SerialDataTransmitter class
//
class SerialDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialDataTransmitter();
		//@cmember destructor
		override ~SerialDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;

		override  HANDLE GetCOMMHandleHack() const { return m_SerialPort; }
		override void StopAutoClose() { m_SerialPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return m_SerialPortIDHack; }
		//@access private data members
	private:
		HANDLE m_SerialPort;
		ULONG m_SerialPortIDHack;
};

//
// @class WinMMDataTransmitter class
//
class WinMMDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		WinMMDataTransmitter ();
		//@cmember destructor
		override ~WinMMDataTransmitter ();

		override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;
		override BOOL WaitTillSendFinished(DWORD timeOut);

		override  HANDLE GetCOMMHandleHack() const { return HANDLE(m_MidiOutHandle); }
		override void StopAutoClose() { m_MidiOutHandle = HMIDIOUT(INVALID_HANDLE_VALUE); }
		override ULONG GetSerialPortHack() { return ULONG(m_MidiOutHandle); }
		//@access private data members
	private:
		DWORD MakeShortMessage(BYTE* data, UINT numBytes) const;
		BOOL MakeLongMessageHeader(MIDIHDR& longHeader, BYTE* data, UINT numBytes) const;
		BOOL DestroyLongMessageHeader(MIDIHDR& longHeader) const;

		HANDLE m_EventMidiOutputFinished;
		HMIDIOUT m_MidiOutHandle;
};

//
// @class BackdoorDataTransmitter class
//
class BackdoorDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember destructor
		virtual override ~BackdoorDataTransmitter();

		virtual override BOOL Initialize(DWORD dwDeviceID);
		override BOOL Send(BYTE* data, UINT numBytes) const;

		override  HANDLE GetCOMMHandleHack() const { return m_DataPort; }
		override void StopAutoClose() { m_DataPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return ULONG(m_DataPort); }
		//@access private data members
	protected:
		//@cmember constructor - protected, cannot create instance of this class
		BackdoorDataTransmitter();

		HANDLE m_DataPort;
		BOOL m_OldBackdoor;
};

//
// @class SerialBackdoorDataTransmitter class
//
class SerialBackdoorDataTransmitter : public BackdoorDataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialBackdoorDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
};

//
// @class MidiBackdoorDataTransmitter class
//
class MidiBackdoorDataTransmitter : public BackdoorDataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		MidiBackdoorDataTransmitter();

		//@cmember destructor
		override ~MidiBackdoorDataTransmitter();

		override BOOL Initialize(DWORD dwDeviceID);
		BOOL InitializeSpecific(DWORD dwDeviceID, HANDLE specificHandle);
};

#if 0		// Fix pin later

typedef DWORD (WINAPI* KSCREATEPIN)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, HANDLE*);

//
// @class PinTransmitter class
//
class PinTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		PinTransmitter();
		//@cmember destructor
		override ~PinTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		//@access private data members
	private:
		BOOL CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin);
		BOOL OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize);
		void SetPinState(KSSTATE state);

		HANDLE m_UartFilter;
		HANDLE m_MidiPin;
		HANDLE m_MidiOutEvent;
};

#endif

extern DataTransmitter* g_pDataTransmitter;

#endif	__DTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\effect.h ===
//@doc
/******************************************************
**
** @module EFFECT.H | Definition file for InternalEffect structure
**
** Description:
**		The Data Packager allows virtualization of the
**	commands into the different firmware versions packet format
**		DataPackager - Base class that defines the functionality of all DataPackagers
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**
** Classes:
**		DataPackager
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**		DataPacket
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__EFFECT_H__
#define	__EFFECT_H__

#include "SW_Error.hpp"
#include "Hau_Midi.hpp"
#include "DX_Map.hpp"
#include "DPack.h" // For ASSUME Macros

#ifndef override
#define override
#endif

#define ET_CUSTOMFORCE_200 0x01
#define ET_SINE_200 0x02
#define ET_SQUARE_200 0x03
#define ET_TRIANGLE_200 0x04
#define ET_SAWTOOTH_200 0x05
#define ET_CONSTANTFORCE_200 0x06

#define ET_DELAY_200 0x08	// - Not defined

#define ET_SPRING_200 0x08
#define ET_DAMPER_200 0x09
#define ET_INERTIA_200 0x0A
#define ET_FRICTION_200 0x0B
#define ET_WALL_200 0x0C
#define ET_RAWFORCE_200 0x0D	// Needed for mapping

#define ID_RTCSPRING_200 1

class DataPacket;

class Envelope
{
	protected:	// Cannot create the generic envelope
		Envelope() {};
};

class Envelope1XX : public Envelope
{
	public:
		Envelope1XX(DIENVELOPE* pDIEnvelope, DWORD baseLine, DWORD duration);

		DWORD m_AttackTime;			// Time from attack to sustain
		DWORD m_SustainTime;		// Time from sustain to fade
		DWORD m_FadeTime;			// Time from fade to end
		DWORD m_StartPercent;		// Percentage of max that is start
		DWORD m_SustainPercent;		// Percentage of max that is sustained
		DWORD m_EndPercent;			// Percentage of max during fade
};

class Envelope200 : public Envelope
{
	public:
		Envelope200(DIENVELOPE* pDIEnvelope, DWORD sustain, DWORD duration, HRESULT& hr);

		WORD	m_AttackTime;		// Time from attack to sustain
		WORD	m_FadeStart;		// Time from start to fade (attack + sustain)
		BYTE	m_StartPercent;		// Percentage of max that is start
		BYTE	m_SustainPercent;	// Percentage of max that is sustained
		BYTE	m_EndPercent;		// Percentage of max at end of fade
};

//
// @class InternalEffect class
//
class InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		InternalEffect();
		virtual ~InternalEffect();

		// Ugly! but quick and simple
		static InternalEffect* CreateSpring();
		static InternalEffect* CreateDamper();
		static InternalEffect* CreateInertia();
		static InternalEffect* CreateFriction();

		static InternalEffect* CreateRTCSpring();
		static InternalEffect* CreateSystemEffect();

		static InternalEffect* CreateCustomForce();

		static InternalEffect* CreateSine();
		static InternalEffect* CreateSquare();
		static InternalEffect* CreateTriangle();
		static InternalEffect* CreateSawtoothUp();
		static InternalEffect* CreateSawtoothDown();

		static InternalEffect* CreateConstantForce();

		static InternalEffect* CreateRamp();

		static InternalEffect* CreateWall();
		static InternalEffect* CreateDelay() { return NULL; }

		static InternalEffect* CreateFromVFX(const DIEFFECT& diOringinal, EFFECT effect, ENVELOPE envelope, BYTE* pEffectParms, DWORD paramSize, HRESULT& hr);

		virtual HRESULT Create(const DIEFFECT& diEffect);
		virtual HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		virtual UINT GetModifyOnlyNeeded() const { return 0; }
		virtual HRESULT FillModifyOnlyParms() const { return SUCCESS; }
		virtual HRESULT FillCreatePacket(DataPacket& packet) const { return SFERR_NO_SUPPORT; }

		static BYTE ComputeChecksum(const DataPacket& packet, short int numFields);
		void FillSysExHeader(DataPacket& packet) const;
		void FillHeader1XX(DataPacket& packet, BYTE effectType, BYTE effectID) const;
		void FillHeader200(DataPacket& packet, BYTE effectType, BYTE effectID) const;

		BYTE GetGlobalID() const { return m_EffectID; }
		BYTE GetDeviceID() const { return m_DeviceEffectID; }
		void SetGlobalID(BYTE id) { m_EffectID = id; }
		void SetDeviceID(BYTE id) { m_DeviceEffectID = id; }

		// For special modfication of play reapeat
		HRESULT FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, DWORD value) const;
		virtual BYTE GetRepeatIndex() const { return 0xFF; }

		void SetPlaying(BOOL playState) { m_IsPossiblyPlaying = playState; }
		BOOL IsPossiblyPlaying() const { return m_IsPossiblyPlaying; }
		BOOL IsReallyPlaying(BOOL& multiCheckStop);
	protected:
		HRESULT FillModifyPacket1XX(BYTE packetIndex, BYTE paramIndex, DWORD value) const;
		HRESULT FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, BYTE low, BYTE high) const;

		BYTE m_EffectID;
		BYTE m_DeviceEffectID;
		DWORD m_Duration;
		DWORD m_Gain;
		DWORD m_SamplePeriod;
		DWORD m_TriggerPlayButton;
		DWORD m_TriggerRepeat;
		DWORD m_AxisMask;
		DWORD m_EffectAngle;
		DWORD m_PercentX;			// Percent force X
		DWORD m_PercentY;			// Percent force Y
		DWORD m_PercentAdjustment;	// Y-Force mapping combination of above
		BOOL m_AxesReversed;
		BOOL m_IsPossiblyPlaying;
};

// ********************** Behavioural Based Effects *****************************/

//
// @class BehaviouralEffect class
// Spring, Damper, Intertia, Friction, and Wall (till wall gets its own type)
//
class BehaviouralEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect() : InternalEffect() {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int ConstantX() const { return m_ConditionData[0].lPositiveCoefficient; }
		long int ConstantY() const { return m_ConditionData[1].lPositiveCoefficient; }
		long int CenterX() const { return m_ConditionData[0].lOffset; }
		long int CenterY() const { return m_ConditionData[1].lOffset; }

	protected:
		DICONDITION m_ConditionData[2];		// We are just dealing with two axis currently
		BYTE m_TypeID;
};

//
// @class BehaviouralEffect1XX class
// Spring, Damper, and Inertia
//
class BehaviouralEffect1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect1XX(BYTE typeID) : BehaviouralEffect() { m_TypeID = typeID; m_HasCenter = TRUE; }

		virtual override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;

		BOOL m_HasCenter;	// Friction has no center
};

//
// @class RTCSpring1XX class
//
class RTCSpring1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		RTCSpring1XX();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		long int SaturationX() const { return m_ConditionData[0].dwPositiveSaturation; }
		long int SaturationY() const { return m_ConditionData[1].dwPositiveSaturation; }
		long int DeadBandX() const { return m_ConditionData[0].lDeadBand; }
		long int DeadBandY() const { return m_ConditionData[1].lDeadBand; }
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};

//
// @class BehaviouralEffect200 class
// Spring, Damper, and Inertia
//
class BehaviouralEffect200 : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect200(BYTE typeID) : BehaviouralEffect() { m_TypeID = typeID; }

		override HRESULT Create(const DIEFFECT& diEffect);

		virtual override UINT GetModifyOnlyNeeded() const;
		virtual override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		// Distances and Forces spec'd for the firmware
		void ComputeDsAndFs();
		BYTE m_Ds[4];
		BYTE m_Fs[4];
};

//
// @class RTCSpring200 class
//
class RTCSpring200 : public BehaviouralEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		RTCSpring200();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;

		long int SaturationX() const { return m_ConditionData[0].dwPositiveSaturation; }
		long int SaturationY() const { return m_ConditionData[1].dwPositiveSaturation; }
		long int DeadBandX() const { return m_ConditionData[0].lDeadBand; }
		long int DeadBandY() const { return m_ConditionData[1].lDeadBand; }
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};

//
// @class FrictionEffect1XX class
//
class FrictionEffect1XX : public BehaviouralEffect1XX
{
	//@access Constructor
	public:
		//@cmember constructor
		FrictionEffect1XX() : BehaviouralEffect1XX(ET_BE_FRICTION) { m_HasCenter = FALSE; }

		override HRESULT FillCreatePacket(DataPacket& packet) const;
};


//
// @class FrictionEffect200 class
//
class FrictionEffect200 : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		FrictionEffect200() : BehaviouralEffect() { m_TypeID = ET_FRICTION_200; }

		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

/*
//
// @class WallEffect1XX class
//
class WallEffect1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect1XX() : BehaviouralEffect() {};

		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags) const;
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};
*/

// ********************* Periodic based Effects *****************************/

//
// @class PeriodicEffect class
// Sine, Square, Triangle
//
class PeriodicEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect();
		override ~PeriodicEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int Magnitude() const { return m_PeriodicData.dwMagnitude; }
		long int Offset() const { return m_PeriodicData.lOffset; }
		virtual long int Phase() const { return m_PeriodicData.dwPhase; }
		long int Period() const { return m_PeriodicData.dwPeriod; }
	protected:
		DIPERIODIC m_PeriodicData;		// We are just dealing with two axis currently
		Envelope* m_pEnvelope;
		BYTE m_TypeID;
};

//
// @class PeriodicEffect1XX class
//
class PeriodicEffect1XX : public PeriodicEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect1XX(BYTE typeID) : PeriodicEffect() { m_TypeID = typeID; }


		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		void DIToJolt(DWORD mag, DWORD off, DWORD gain, DWORD& max, DWORD& min) const;
		static DWORD DIPeriodToJoltFreq(DWORD period);

		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};


//
// @class PeriodicEffect200 class
//
class PeriodicEffect200 : public PeriodicEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect200(BYTE typeID) : PeriodicEffect() { m_TypeID = typeID; }


		virtual override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		virtual override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
		virtual override long int Phase() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

//
// @class SawtoothEffect200 class
//
class SawtoothEffect200 : public PeriodicEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		SawtoothEffect200(BOOL isUp) : PeriodicEffect200(ET_SAWTOOTH_200), m_IsUp(isUp) {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);
		override long int Phase() const;
	protected:
		BOOL m_IsUp;
};

//
// @class RampEffect200 class
//
class RampEffect200 : public SawtoothEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		RampEffect200() : SawtoothEffect200(TRUE) {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
};


// ************************ Miscellaneuous (CustomForce, RampForce, ConstantForce, SystemEffect) *********************//

//
// @class CustomForceEffect class
//
class CustomForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		CustomForceEffect();
		virtual override ~CustomForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

	protected:
		DICUSTOMFORCE m_CustomForceData;
};

//
// @class CustomForceEffect200 class
//
class CustomForceEffect200 : public CustomForceEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		CustomForceEffect200();
		~CustomForceEffect200();

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	private:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		Envelope200* m_pEnvelope;
};


/*
//
// @class RampForceEffect class
//
class RampForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		RampForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int StartForce() const { return m_RampForceData.lStart; }
		long int EndForce() const { return m_RampForceData.lEnd; }
	protected:
		DIRAMPFORCE m_RampForceData;
};
*/

//
// @class ConstantForceEffect class
//
class ConstantForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		ConstantForceEffect();
		override ~ConstantForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int Magnitude() const { return m_ConstantForceData.lMagnitude; }
	protected:
		DICONSTANTFORCE m_ConstantForceData;
		Envelope* m_pEnvelope;
};

//
// @class ConstantForceEffect200 class
//
class ConstantForceEffect200 : public ConstantForceEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		ConstantForceEffect200() : ConstantForceEffect() {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

//
// @class WallEffect class
//
class WallEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect() : InternalEffect() {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);
	protected:
		BE_WALL_PARAM m_WallData;
};

//
// @class WallEffect200 class
//
class WallEffect200 : public WallEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect200() : WallEffect() {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	private:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		// Distances and Forces spec'd for the firmware
		void ComputeDsAndFs();
		BYTE m_Ds[4];
		BYTE m_Fs[4];
};

//
// @class SystemEffect class
//
class SystemEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		SystemEffect() {};
};

class SystemStickData1XX
{
	public:
		SystemStickData1XX();

		void SetFromRegistry(DWORD dwDeviceID);

		DWORD dwXYConst;
		DWORD dwRotConst;
		DWORD dwSldrConst;
		DWORD dwAJPos;
		DWORD dwAJRot;
		DWORD dwAJSldr;
		DWORD dwSprScl;
		DWORD dwBmpScl;
		DWORD dwDmpScl;
		DWORD dwInertScl;
		DWORD dwVelOffScl;
		DWORD dwAccOffScl;
		DWORD dwYMotBoost;
		DWORD dwXMotSat;
		DWORD dwReserved;
		DWORD dwMasterGain;
};

class SystemEffect1XX : public SystemEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		SystemEffect1XX();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		SystemStickData1XX m_SystemStickData;
};

#endif	__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffdevice.h ===
//@doc
/******************************************************
**
** @module FFDEVICE.H | Definition file for FFDevice class
**
** Description:
**		This is the generic FF device. Independant of
**	Firmawate and how data reaches the device
**	This first implementation uses the old CJoltMidi to
**	minimize new code.
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__FFDEVICE_H__
#define	__FFDEVICE_H__

#include <dinput.h>
#include "vxdioctl.hpp"		// Joychannel status def
#include "Effect.h"
#include "Hau_Midi.hpp" // For definition of MAX_EFFECT_IDS

#define RAW_FORCE_ALIAS 0xFF

// Currently there is some extra stuff in here, that should be part of other objects

struct DEVICESTATE200	// sizeof DWORD
{
#pragma pack(1)
	unsigned short m_ErrorStatus : 3;
	unsigned short m_HardwareReset : 1;
	unsigned short m_Uncalibrated : 1;
	unsigned short m_HostDisable : 1;
	unsigned short m_HostPause : 1;
	unsigned short m_UserDisable : 1;
	unsigned short m_RS232Mode : 1;
	unsigned short m_BandwidthExceeded : 1;
	unsigned short m_HostReset : 1;
	unsigned short m_NoPedals : 1;
	unsigned short m_Fluff : 4;
	unsigned short m_Fluff2 : 16;
#pragma pack()
};


//
// @class ForceFeedbackDevice class
//
class ForceFeedbackDevice
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		ForceFeedbackDevice();
		//@cmember destructor
		~ForceFeedbackDevice();

		BOOL DetectHardware();

		// Effect related functions
		InternalEffect* GetEffect(DWORD effectID) const;
		InternalEffect* RemoveEffect(DWORD effectID);
		InternalEffect* CreateEffect(DWORD effectType, const DIEFFECT& diEffect, DWORD& dnloadID, HRESULT& hr, BOOL paramCheck);
		void SetEffect(BYTE globalID, InternalEffect* pEffect);
		BYTE GetNextCreationID() const;

		HRESULT InitRTCSpring(DWORD dwDeviceID);
		HRESULT InitJoystickParams(DWORD dwDeviceID);

		void StateChange(DWORD dwDeviceID, DWORD newStateFlags);	// Called after new state sent to the stick
		DWORD GetDIState() const { return m_DIStateFlags; }

		// OS Version functions
		DWORD GetPlatform() const { return m_OSVersion.dwPlatformId; }
		DWORD GetPlatformMajorVersion() const { return m_OSVersion.dwMajorVersion; }
		DWORD GetPlatformMinorVersion() const { return m_OSVersion.dwMinorVersion; }
		DWORD GetOSBuildNumber() const { return m_OSVersion.dwBuildNumber; }
		BOOL IsOSNT5() const { return ((m_OSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) && (m_OSVersion.dwMajorVersion == 5)); }

		// Firmware version functions
		void SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor);
		DWORD GetFirmwareVersionMajor() const { return m_FirmwareVersionMajor; }
		DWORD GetFirmwareVersionMinor() const { return m_FirmwareVersionMinor; }

		USHORT GetAckNackMethod(USHORT methodIndex) const { return USHORT((m_FirmwareAckNackValues >> methodIndex) & 0x00000003); }
		short GetYMappingPercent(UINT index) const;
		DWORD GetSpringOffset() const { return m_SpringOffset; }

		// Driver version functions
		DWORD GetDriverVersionMajor() const { return m_DriverVersionMajor; }
		DWORD GetDriverVersionMinor() const { return m_DriverVersionMinor; }
		void SetDriverVersion(DWORD major, DWORD minor);

		// Status update and retreival
		HRESULT QueryStatus();
		DEVICESTATE200 GetState200() const { return m_Version200State; }
		SWDEVICESTATE GetState1XX() const { return m_Version1XXState; }

		// If we were supporting jolt switch off firmware version
		BOOL IsHardwareReset() const { return (m_Version200State.m_HardwareReset != 0); }
		BOOL IsSerial() const { return (m_Version200State.m_RS232Mode != 0); }
		BOOL IsHostReset() const { return (m_Version200State.m_HostReset != 0); }
		BOOL IsShutdown() const { return IsHostReset(); }
		BOOL IsHostPause() const { return (m_Version200State.m_HostPause != 0); }
		BOOL IsUserDisable() const { return (m_Version200State.m_UserDisable != 0); }
		BOOL IsHostDisable() const { return (m_Version200State.m_HostDisable != 0); }
		unsigned short ErrorStatus() const { return m_Version200State.m_ErrorStatus; } 

		// Status packet ptr
		JOYCHANNELSTATUS* GetLastStatusPacket() { return &m_LastStatusPacket; }
		void SetDeviceIDFromStatusPacket(DWORD globalID);

		//@access private data members
	private:
		HRESULT InitRTCSpring1XX(DWORD dwDeviceID);
		HRESULT InitRTCSpring200(DWORD dwDeviceID);

		InternalEffect* CreateConditionEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateCustomForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreatePeriodicEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateConstantForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateRampForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateRTCSpringEffect(DWORD minorType, const DIEFFECT& diEffect);
		InternalEffect* CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr);

		HRESULT SendRawForce(const DIEFFECT& diEffect, BOOL paramCheck);

		InternalEffect* m_EffectList[MAX_EFFECT_IDS];
		InternalEffect* m_SystemEffect;

		// Device state
		SWDEVICESTATE	m_Version1XXState;
		DEVICESTATE200	m_Version200State;
		DWORD m_DIStateFlags;
		JOYCHANNELSTATUS m_LastStatusPacket;

		// Version crap
		OSVERSIONINFO m_OSVersion;
		DWORD m_FirmwareVersionMajor;
		DWORD m_FirmwareVersionMinor;
		DWORD m_FirmwareAckNackValues;
		DWORD m_DriverVersionMajor;
		DWORD m_DriverVersionMinor;

		DWORD m_SpringOffset;
		DWORD m_Mapping;
		long int m_RawForceX;
		long int m_RawForceY;
		short m_PercentMappings[14];
};


extern ForceFeedbackDevice g_ForceFeedbackDevice;

#endif	__FFDEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffeature.h ===
#ifndef __ForceFeatures_h__
#define __ForceFeatures_h__

#define MSGAME_FEATURE_GETID		2
#define MSGAME_FEATURE_GETSTATUS	3
#define MSGAME_FEATURE_GETACKNAK	4
#define MSGAME_FEATURE_GETNAKACK	5
#define MSGAME_FEATURE_GETSYNC		6
#define MSGAME_FEATURE_DORESET		7

/*
#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08
*/		

typedef struct
{
	ULONG	cBytes;
	ULONG	dwProductID;
	ULONG	dwFWVersion;
} PRODUCT_ID;

typedef	struct
{
	ULONG	cBytes;
	LONG		dwXVel;
	LONG		dwYVel;
	LONG		dwXAccel;
	LONG		dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
} JOYCHANNELSTATUS;

//
//	HID prepends exactly, one byte so we need to
//	be careful about packing
//
#pragma pack(push, OLD_CONTEXT_1)
#pragma pack(1)
typedef struct
{
	BYTE		bReportId;
	PRODUCT_ID	ProductId;
} PRODUCT_ID_REPORT;
typedef struct
{
	BYTE				bReportId;
	JOYCHANNELSTATUS	JoyChannelStatus;
} JOYCHANNELSTATUS_REPORT;

typedef struct
{
	BYTE	bReportId;
	ULONG	uLong;
} ULONG_REPORT;
#pragma pack(pop, OLD_CONTEXT_1)
//
//	End packing of 1
//


class CForceFeatures
{
	public:
		CForceFeatures();
		~CForceFeatures();

		HRESULT Initialize(UINT uJoystickId, HINSTANCE hinstModule);
		ULONG GetVersion(){ return (4 << 16 | 0 ); } //returns version 4.0
		HRESULT GetId(PRODUCT_ID_REPORT& rProductId);
		HRESULT GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus);
		HRESULT GetAckNak(ULONG_REPORT& rulAckNak);
		HRESULT GetNakAck(ULONG_REPORT& rulNakAck);
		HRESULT GetSync(ULONG_REPORT& rulGameport);
		HRESULT DoReset();
	private:
		HANDLE	m_hDevice;
		UINT m_uiMaxFeatureLength;
};

#endif // __ForceFeatures_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffd_swff.hpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header to define FFD (Swforce) Force Feedback Driver API
    
    FUNCTIONS:		


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	22-Jan-96       MEA     original
	1.1		21-Mar-97		MEA		from SWForce
			21-Mar-99		waltw	Removed unreferenced FFD_xxx functions,
									CreateEffectFromFile
		        
****************************************************************************/
#ifndef FFD_SWFF_SEEN
#define FFD_SWFF_SEEN
#include "DX_Map.hpp"
#include "hau_midi.hpp"

#define	TWOPI	(3.14159265358979323846 * 2)
#define	PI		(3.14159265358979323846)
#define	PI2		(1.57079632679489661923)
#define	PI4		(0.78539816339744830966)
#define RADIAN 	(57.29577951)

#define xDegrees2Radians(rAngle) 		((rAngle) * PI / 180.0)
#define xRadians2Degrees(rAngle) 		((rAngle) * 180.0 / PI)

//
// --- Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')


#define MAX_UD_PARAM_FORCE_DATA_COUNT	1000
#define MAX_PL_PARAM_NUM_EFFECTS		50


//---------------------------------------------------------------------------
// Function prototype declarations
//---------------------------------------------------------------------------
#ifdef _cplusplus
extern "C" {
#endif

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwFileSize,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags);

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult);

HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lForceValue,
	IN ULONG ulAxisMask,
	IN OUT PSHORT pX,
	IN OUT PSHORT pY);

HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction);

HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE EffectID);

HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

#ifdef _cplusplus
}
#endif


#endif // of ifndef FFD_SWFF_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi.hpp ===
/****************************************************************************

    MODULE:     	MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
        
****************************************************************************/
#ifndef _MIDI_SEEN
#define _MIDI_SEEN

#define MMNODRV
#define MMNOSOUND
#define MMNOWAVE
// #define MMNOMIDI  // we need the MIDI definitions
#define MMNOAUX
#define MMNOTIMER
#define MMNOJOY
#define MMNOMMIO
#define MMNOMCI
#include <winuser.h>
#include <mmsystem.h>

//////////////////////////////////////////////////////////////////////////////
//
// manifest constants and macros for MIDI message protocol
//
//////////////////////////////////////////////////////////////////////////////

// MIDI Status Bytes for Channel Voice Messages
#define MIDI_NOTE_OFF           0x80
#define MIDI_NOTE_ON            0x90
#define MIDI_POLY_PRESSURE      0xA0
#define MIDI_CONTROL_CHANGE     0xB0
#define MIDI_PROGRAM_CHANGE     0xC0
#define MIDI_CHANNEL_PRESSURE   0xD0
#define MIDI_AFTERTOUCH         0xD0  // synonym for channel pressure
#define MIDI_PITCH_WHEEL        0xE0

// MIDI Status Bytes for System Common Messages
#define MIDI_SYSEX              0xF0  // beginning of system exclusive message
#define MIDI_MTC_QTR_FRAME      0xF1
#define MIDI_SONG_POSITION_PTR  0xF2
#define MIDI_SONG_SELECT        0xF3
#define MIDI_TUNE_REQUEST       0xF6
#define MIDI_EOX                0xF7  // marks end of system exclusive message

// MIDI Status Bytes for System Real-Time Messages
#define MIDI_TIMING_CLOCK       0xF8
#define MIDI_START              0xFA
#define MIDI_CONTINUE           0xFB
#define MIDI_STOP               0xFC
#define MIDI_ACTIVE_SENSING     0xFE
#define MIDI_SYSTEM_RESET       0xFF

// control numbers for MIDI_CONTROL_CHANGE (MIDI status byte 0xB0)
// note: not a complete list
#define MIDI_MOD_WHEEL              0x01
#define MIDI_BREATH_CONTROL         0x02
#define MIDI_FOOT_CONTROL           0x04
#define MIDI_PORTAMENTO_TIME        0x05
#define MIDI_DATA_ENTRY_SLIDER      0x06
#define MIDI_VOLUME                 0x07
#define MIDI_BALANCE                0x08
#define MIDI_PAN                    0x0A
#define MIDI_EXPRESSION             0x0B
#define MIDI_GENERAL_PURPOSE_1      0x10   
#define MIDI_GENERAL_PURPOSE_2      0x11
#define MIDI_GENERAL_PURPOSE_3      0x12
#define MIDI_GENERAL_PURPOSE_4      0x13
#define MIDI_SUSTAIN                0x40
#define MIDI_PORTAMENTO             0x41
#define MIDI_SOSTENUTO              0x42
#define MIDI_SOFT                   0x43
#define MIDI_HOLD_2                 0x45
#define MIDI_GENERAL_PURPOSE_5      0x50
#define MIDI_GENERAL_PURPOSE_6      0x51
#define MIDI_GENERAL_PURPOSE_7      0x52
#define MIDI_GENERAL_PURPOSE_8      0x53
#define MIDI_EXTERNAL_EFFECTS_DEPTH 0x5B
#define MIDI_TREMELO_DEPTH          0x5C
#define MIDI_CHORUS_DEPTH           0x5D
#define MIDI_CELESTE_DEPTH          0x5E
#define MIDI_PHASER_DEPTH           0x5F
#define MIDI_DATA_INCREMENT         0x60
#define MIDI_DATA_DECREMENT         0x61
#define MIDI_NONREG_PARAM_NUM_MSB   0x62
#define MIDI_NONREG_PARAM_NUM_LSB   0x63
#define MIDI_REG_PARAM_NUM_MSB      0x64
#define MIDI_REG_PARAM_NUM_LSB      0x65
#define MIDI_RESET_ALL_CONTROLLERS  0x79
#define MIDI_LOCAL_CONTROL          0x7A
#define MIDI_ALL_NOTES_OFF          0x7B
#define MIDI_OMNI_MODE_OFF          0x7C
#define MIDI_OMNI_MODE_ON           0x7D
#define MIDI_MONO_MODE_ON           0x7E
#define MIDI_POLY_MODE_ON           0x7F      

// macro to pack a MIDI short message                                                
#define MAKEMIDISHORTMSG(cStatus, cChannel, cData1, cData2)            \
    cStatus | cChannel | (((UINT)cData1) << 8) | (((DWORD)cData2) << 16)
    
// macros to unpack a MIDI short message    
#define MIDI_STATUS(dwMsg)  ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0xF0 : LOBYTE(LOWORD(dwMsg)))
#define MIDI_CHANNEL(dwMsg) ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0x0F : 0)
#define MIDI_DATA1(dwMsg)   (HIBYTE(LOWORD(dwMsg)))
#define MIDI_DATA2(dwMsg)   (LOBYTE(HIWORD(dwMsg))) 

//////////////////////////////////////////////////////////////////////////////
//
// declarations for MIDI wrapper functions
//
//////////////////////////////////////////////////////////////////////////////

#define MIDI_IN      0x0001  // specifies MIDI input device
#define MIDI_OUT     0x0002  // specifies MIDI output device
#define NO_MIDI      0xFF00  // MIDI device unavaible or not selected 

#define MIDI_OPEN    0x0001  // uActivateMode parameter for MidiActivate
#define MIDI_CLOSE   0x0010  // uActivateMode parameter for MidiActivate
#define MIDI_ABANDON 0x0011  // uActivateMode parameter for MidiActivate
#define MIDI_BUSY    0xFF01  // possible MidiActivate return value

#define MIDI_ERRMSG_SIZE 128 // for MidiShowError string buffer

typedef struct _MIDIINFO     // MIDI device information block
{                           
    UINT uDeviceType;        // either MIDI_IN, MIDI_OUT or NO_MIDI
    UINT uDeviceID;          // ID of device chosen by user or NO_MIDI 
    union
    { 
        HMIDIIN  hMidiIn;    // input device handle used if MIDI_IN device
        HMIDIOUT hMidiOut;   // output device handle used if MIDI_OUT device
    };
    MIDIHDR MidiHdr;         // required for system exclusive   
    BOOL fAlwaysKeepOpen;    // access level requested by application
    UINT uDeviceStatus;      // current status of device
} MIDIINFO, *LPMIDIINFO;

// defines for MIDIINFO uDeviceStatus member
#define MIDI_DEVICE_IDLE        0x0000  // device is not in use
#define MIDI_DEVICE_BUSY        0x0001  // device is busy
#define MIDI_DEVICE_ABANDONED   0x0002  // device was reset while busy

    
BOOL MidiInit(LPMIDIINFO, LPMIDIINFO);
MMRESULT MidiGetDeviceName(UINT, UINT, LPWORD, LPWORD, LPSTR);
UINT MidiActivateDevice(LPMIDIINFO, UINT);
UINT MidiSendShortMsg(LPMIDIINFO, BYTE, BYTE, BYTE, BYTE); 
UINT MidiSendLongMsg(LPMIDIINFO, BOOL);
UINT MidiRecord(LPMIDIINFO, BOOL);
BOOL MidiExit(LPMIDIINFO, LPMIDIINFO);

#endif // of ifdef _MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\hau_midi.hpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for HAU_MIDI.CPP


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
			21-Mar-99		waltw	Removed unreferenced ModifyEnvelopeParams,
									ModifyEffectParams, MapEnvelope, CMD_ModifyParamByIndex,
									CMD_Download_RTCSpring

****************************************************************************/
#ifndef _HAU_MIDI_SEEN
#define _HAU_MIDI_SEEN
#include "DX_MAP.hpp"

#define MAX_EFFECT_IDS				32
#define	NEW_EFFECT_ID				0x7f
#define SYSTEM_EFFECT_ID			0x7f
#define SYSTEM_RTCSPRING_ID			0
#define SYSTEM_FRICTIONCANCEL_ID	1
#define SYSTEM_RTCSPRING_ALIAS_ID	0x7e	// Due to internal ID=0 means create new

#define MAX_MIDI_CHANNEL		16
#define DEFAULT_MIDI_CHANNEL	5
#define DEFAULT_MIDI_PORTIO		0x330

#define COMM_WINMM					0x01
#define COMM_MIDI_BACKDOOR			0x02
#define COMM_SERIAL_BACKDOOR		0x03
#define COMM_SERIAL_FILE			0x04
#define MASK_OVERRIDE_MIDI_PATH		0x80000000
#define MASK_SERIAL_BACKDOOR		0x40000000
#define COMM_SERIAL1			1			// COMM Port 1
#define MIN_COMMSERIAL			1
#define MAX_COMMSERIAL			4

#define DEFAULT_JOLT_FORCE_RATE	100
#define DEFAULT_PERCENT			10000

#define MAX_SYS_EX_BUFFER_SIZE	1024		// Maximum Primary buffer size
#define DIFFERENCE_THRESHOLD	32			// Threshold to using absolute data
#define DIFFERENCE_BIT			0x40		// Bit to set for Difference data
#define MAX_MIDI_WAVEFORM_PACKET_SIZE	(256-20)	// Midi SYS_EX packet size
#define MAX_MIDI_WAVEFORM_DATA_SIZE	100		// Midi SYS_EX Data sample window size
#define	MAX_PLIST_EFFECT_SIZE	8			// 8 effects in a PList
#define MAX_PLIST_EFFECT		8			// 8 PLists allowed

#define MAX_INDEX				15
#define MAX_SIZE_SNAME			64								

#define MS_MANUFACTURER_ID		0x0a01
#define JOLT_PRODUCT_ID			0x01         // REVIEW: Is this correct?

#define DRIVER_ERROR_NO_MIDI_INPUT	0x100	// No open Midi input device
#define DRIVER_ERROR_MIDI_OUTPUT	0x101	// Error outputing to Midi output


//
// --- RTC Spring defaults
//
#define	DEFAULT_RTC_KX		80
#define	DEFAULT_RTC_KY		80
#define	DEFAULT_RTC_X0		0
#define	DEFAULT_RTC_Y0		0
#define	DEFAULT_RTC_XSAT	96
#define	DEFAULT_RTC_YSAT	96
#define	DEFAULT_RTC_XDBAND	16
#define	DEFAULT_RTC_YDBAND	16

//
// --- Effect status code from Device
//
#define SWDEV_STS_EFFECT_STOPPED	0x01
#define SWDEV_STS_EFFECT_RUNNING	0x02

//
// --- Bitmasks for Device Status
//
#define BANDWIDTH_MASK			0x200		// Bandwidth bit
#define COMM_MODE_MASK			0x100		// 0 = MIDI, 1 = Serial
#define AC_FAULT_MASK			0x80		// 1= AC brick fault
#define HOTS_MASK				0x20		// Hands on Throttle Sensor
#define RESET_MASK				0x10		// 1 = Power On Reset detected
#define SHUTDOWN_MASK			0x08		// 0 = normal Shutdown, else 1 = Soft Reset

#define MINIMUM_BANDWIDTH		1
#define MAXIMUM_BANDWIDTH		100			// in %

//
// --- ERROR CODES from Device
//
#define DEV_ERR_SUCCESS			0x00	// Success
#define DEV_ERR_INVALID_ID		0x01	// Effect ID is invalid or not found
#define DEV_ERR_INVALID_PARAM	0x02	// Invalid parameter in data structure
#define DEV_ERR_CHECKSUM		0x03	// Invalid checksum
#define DEV_ERR_TYPE_FULL		0x04	// No more room for specified Effect
#define DEV_ERR_UNKNOWN_CMD		0x05	// Unrecognized command
#define DEV_ERR_PLAYLIST_FULL	0x06	// Play List is full, cannot play any
										// more effects
#define DEV_ERR_PROCESS_LIST_FULL 0x07	// Process List is full


//
// --- MIDI Command codes
//
#define MODIFY_CMD			0xA0
#define EFFECT_CMD	        0xB0
#define SYSTEM_CMD	        0xC0
#define STATUS_CMD			0xD0
#define RESPONSE_CMD	    0xE0		// Device to Host
#define SYS_EX_CMD			0xF0
#define ASSIGN_CMD	        0xF0
#define DNLOAD_CMD	        0xF0
#define UPLOAD_CMD	        0xF0
#define PROCESS_CMD	        0xF0
#define MIDI_EOX			0xF7

//
// --- Second byte sub-commands
//
// --- MIDI_CMD_EFFECT second byte sub-command
#define	NO_OVERRIDE         	0x00
#define DESTINATION_X			0x01
#define DESTINATION_Y			0x02
#define DESTINATION_XY			0x03
#define	PUT_FORCE_X				0x01
#define	PUT_FORCE_Y				0x02
#define	PUT_FORCE_XY			0x03
#define PLAY_EFFECT_SOLO		0x00
#define DESTROY_EFFECT			0x10	
#define	PLAY_EFFECT_SUPERIMPOSE	0x20
#define	STOP_EFFECT				0x30
#define SET_INDEX				0x40


// --- MIDI_CMD_SYSTEM second byte sub-command
#define SWDEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
#define SWDEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
#define SWDEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
#define SWDEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
#define SWDEV_PAUSE		5L		// All Effects are "Paused"
#define SWDEV_STOP_ALL	6L		// Stops all Effects.
#define SWDEV_KILL_MIDI	7L		// Kills (tri-states) MIDI

// Remap for dinput modes
#define DEV_RESET       SWDEV_SHUTDOWN
#define DEV_FORCE_ON    SWDEV_FORCE_ON
#define DEV_FORCE_OFF   SWDEV_FORCE_OFF
#define DEV_CONTINUE    SWDEV_CONTINUE
#define DEV_PAUSE       SWDEV_PAUSE
#define DEV_STOP_ALL    SWDEV_STOP_ALL

//
// --- ACK and NACK 2nd byte from RESPONSE_CMD
//
#define ACK                 0x00
#define NACK                0x7f
#define ACKNACK_TIMEOUT		50			// 50*1msec timeout = 50msecs
#define ACKNACK_EFFECT_STATUS_TIMEOUT 1	// 1ms Timeout
#define MAX_RETRY_COUNT		10			// Retry count for comm NACKS
//#define MAX_GET_STATUS_PACKET_RETRY_COUNT 30
#define MAX_GET_STATUS_PACKET_RETRY_COUNT 10
#define SHORT_MSG_TIMEOUT	1
#define LONG_MSG_TIMEOUT	2
#define POWER_ON_MSG		0x007F00E5UL
#define RESPONSE_NACK		0x007FE0UL	// Example for MIDI channel 0.
#define RESPONSE_ACK		0x0000E0UL	// " "

// timing delays, in mS
/*
#define DEFAULT_SHORT_MSG_DELAY				1
#define DEFAULT_LONG_MSG_DELAY				1
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	1
#define DEFAULT_SHUTDOWN_DELAY				10
#define DEFAULT_HWRESET_DELAY				20		
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	1
#define DEFAULT_GET_EFFECT_STATUS_DELAY		1
#define DEFAULT_GET_DATA_PACKET_DELAY		1
#define DEFAULT_GET_STATUS_PACKET_DELAY		0
#define DEFAULT_GET_ID_PACKET_DELAY			1
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY			0
#define DEFAULT_FORCE_OUT_DELAY				1
#define DEFAULT_DESTROY_EFFECT_DELAY		1
#define DEFAULT_FORCE_OUT_MOD				1
*/
// Changes of above for Zep
#define DEFAULT_SHORT_MSG_DELAY	0
#define DEFAULT_LONG_MSG_DELAY	0
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	0
#define DEFAULT_SHUTDOWN_DELAY	0
#define DEFAULT_HWRESET_DELAY 0
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	0
#define DEFAULT_GET_EFFECT_STATUS_DELAY		0
#define DEFAULT_GET_DATA_PACKET_DELAY		0
#define DEFAULT_GET_STATUS_PACKET_DELAY		0
#define DEFAULT_GET_ID_PACKET_DELAY			0
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY		0
#define DEFAULT_FORCE_OUT_DELAY		0
#define DEFAULT_DESTROY_EFFECT_DELAY	0
#define DEFAULT_FORCE_OUT_MOD	0

typedef struct _DELAY_PARAMS
{
	DWORD	dwBytes;
	DWORD	dwDigitalOverdrivePrechargeCmdDelay;
	DWORD	dwShutdownDelay;
	DWORD	dwHWResetDelay;
	DWORD	dwPostSetDeviceStateDelay;
	DWORD	dwGetEffectStatusDelay;
	DWORD	dwGetDataPacketDelay;
	DWORD	dwGetStatusPacketDelay;
	DWORD	dwGetIDPacketDelay;
	DWORD	dwGetStatusGateDataDelay;
	DWORD	dwSetIndexDelay;
	DWORD	dwModifyParamDelay;
	DWORD	dwForceOutDelay;
	DWORD	dwShortMsgDelay;
	DWORD	dwLongMsgDelay;
	DWORD	dwDestroyEffectDelay;
	DWORD	dwForceOutMod;
} DELAY_PARAMS, *PDELAY_PARAMS;

void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams);

//
// --- Format of Download command
//     Bytes in SYS EX body (starting from Byte 5 to (n-1)
//
// Byte     Contents
// -----    ---------
//  0       bOpCode			- see detail on OPCODE below
//  1       bSubType		- e.g. ET_UD_WAVEFORM, etc.
//	2		bEffectID		- Effect ID, 0x7f = Create New
//  3       bDurationL		- Low 7 bits duration in 2ms ticks, 0=Forever
//  4       bDurationH		- High 7 bits

//  5       bAngleL			- Low 7 bits Direction Angle
//  7	    bAngleH			- High 2 bits Direction Angle
//	8		bGain			- 7 bits Gain 1 - 100%
//	9		bButtonPlayL	- Low 7 bits button mask
//	10		bButtonPlayH	- High 2 bits button mask
//	11		bForceOutRateL	- Low 7 bits, 1 to 500 Hz
//	12		bForceOutRateH	- High 2 bits
//	13		bLoopCountL		- Low 7 bits Loop Count, Normally 1
//  14      bLoopCountH		- High 7 bits Loop count
//  		
//
//  The next block is optional and starts at Byte 15
//	15		bAttack			- %tage
//	16		bSustain;		- %tage
//  17 		bDecay;			- %tage
//
//  Otherwise, Type specific Parameters start at either Byte 15 or 18
//	18		Type specific parameter bytes here
//	
//
//  ...
//  n       7 bits Checksum of bytes 0 to n
//
//
//
// --- MIDI_CMD_ASSIGN, MIDI_CMD_DNLOAD, MIDI_CMD_PROCESS
//     second byte sub-command
// Opcode is defined as follows:
// 7  6  5  4  3  2  1  0
// -  -  -  -  -  -  -  -
// 0  c  c  c  a  a  d  d
//
// where:
//    c  c  c
//    -  -  -
//    0  0  0	- EXTEND_ESCAPE
//	  0  0  1	- MIDI_ASSIGN
//	  0  1  0	- DNLOAD_DATA
//	  0  1  1	- UPLOAD_DATA
//	  1  0  0	- PROCESS_DATA
//	  1  0  1	- reserved
//	  1  1  0	- reserved
//	  1  1  1	- reserved
//
// and:
//             a  a
//             -  -
//             0  0 - DL_PLAY_STORE only after download
//             0  1 - DL_PLAY_SUPERIMPOSE right after download
//             1  0 - DL_PLAY_SOLO right after download
//			   1  1 - reserved
// and:
//		             d  d
//					 -  -
//					 0  0	- reserved
//					 0  1	- X-Axis
//					 1  0	- Y-Axis
//					 1  1	- X and Y-Axis
//

#define EXTEND_ESCAPE		0x00
#define MIDI_ASSIGN			0x10
#define DNLOAD_DATA			0x20
#define UPLOAD_DATA			0x30
#define PROCESS_DATA		0x40
#define GET_FORCE_EFFECT_VALUE	0x50

// --- Download sub-commands
//
#define DL_PLAY_STORE       0x00
#define DL_PLAY_SUPERIMPOSE 0x04
#define DL_PLAY_SOLO        0x08

//
// --- Process List sub-commands
//
#define PLIST_CONCATENATE      0x01 //0x11	// Temp. s/b 0x01
#define PLIST_SUPERIMPOSE      0x02 //0x12 // Temp. s/b 0x02


//
// --- Special UD_EFFECT parameters
//
#define UD_DIFFERENCE_DATA  0x40


//
// --- Bitmap Indexes into Parameter storage array
//
#define	INDEX0_MASK	 0x00000001L
#define INDEX1_MASK	 0x00000002L
#define INDEX2_MASK	 0x00000004L
#define INDEX3_MASK	 0x00000008L
#define INDEX4_MASK	 0x00000010L
#define INDEX5_MASK	 0x00000020L
#define	INDEX6_MASK	 0x00000040L
#define INDEX7_MASK	 0x00000080L
#define INDEX8_MASK	 0x00000100L
#define INDEX9_MASK	 0x00000200L
#define INDEX10_MASK 0x00000400L
#define INDEX11_MASK 0x00000800L
#define INDEX12_MASK 0x00001000L
#define INDEX13_MASK 0x00002000L
#define INDEX14_MASK 0x00004000L
#define INDEX15_MASK 0x00008000L

#define INDEX_DURATION 0
#define INDEX_TRIGGERBUTTONMASK 1
#define INDEX_X_COEEFICIENT 2
#define INDEX_Y_COEEFICIENT 3
#define INDEX_X_CENTER 4
#define INDEX_Y_CENTER 5

// Indexes for 1XX RTCSpring Parms
#define INDEX_RTC_COEEFICIENT_X (BYTE)0
#define INDEX_RTC_COEEFICIENT_Y (BYTE)1
#define INDEX_RTC_CENTER_X		(BYTE)2
#define INDEX_RTC_CENTER_Y		(BYTE)3
#define INDEX_RTC_SATURATION_X	(BYTE)4
#define INDEX_RTC_SATURATION_Y	(BYTE)5
#define INDEX_RTC_DEADBAND_X	(BYTE)6
#define INDEX_RTC_DEADBAND_Y	(BYTE)7

#define	INDEX0	(BYTE)0
#define INDEX1	(BYTE)1
#define INDEX2	(BYTE)2
#define INDEX3	(BYTE)3
#define INDEX4	(BYTE)4
#define INDEX5	(BYTE)5
#define	INDEX6	(BYTE)6
#define INDEX7	(BYTE)7
#define INDEX8	(BYTE)8
#define INDEX9	(BYTE)9
#define INDEX10 (BYTE)10
#define INDEX11 (BYTE)11
#define INDEX12 (BYTE)12
#define INDEX13 (BYTE)13
#define INDEX14 (BYTE)14
#define INDEX15 (BYTE)15

	
//
// --- Effect types
//

#define ET_UD_WAVEFORM      	1   // User Defined Waveform

#define ET_SE_SINE				2	// Sinusoidal
#define ET_SE_COSINE			3	// Cosine
#define ET_SE_SQUARELOW			4	// Square starting Low	
#define ET_SE_SQUAREHIGH		5	// Square starting High	
#define ET_SE_RAMPUP        	6   // Ramp UP			
#define ET_SE_RAMPDOWN      	7   // Ramp Down		
#define	ET_SE_TRIANGLEUP    	8	// Triangle rising	
#define ET_SE_TRIANGLEDOWN		9	// Triangle falling
#define ET_SE_SAWTOOTHUP		10	// Sawtooth rising
#define ET_SE_SAWTOOTHDOWN		11	// Sawtooth falling

#define ET_BE_DELAY				12  // NOP delay
#define ET_BE_SPRING        	13  // Springs
#define ET_BE_DAMPER        	14  // Dampers
#define ET_BE_INERTIA       	15  // Gravity
#define ET_BE_FRICTION      	16  // Friction
#define ET_BE_WALL 				17 	// Wall (bumper)
#define ET_SE_CONSTANT_FORCE	18	// Constant Force

#define ET_PL_CONCATENATE		19	// Concatenate process list
#define ET_PL_SUPERIMPOSE		20	// Superimpose process list

// ROM Effect IDS
#define ET_RE_ROMID1			32
#define ET_RE_ROMID2			33
#define ET_RE_ROMID3			34
#define ET_RE_ROMID4			35
#define ET_RE_ROMID5			36
#define ET_RE_ROMID6			37
#define ET_RE_ROMID7			38
#define ET_RE_ROMID8			39
#define ET_RE_ROMID9			40
#define ET_RE_ROMID10			41
#define ET_RE_ROMID11			42
#define ET_RE_ROMID12			43
#define ET_RE_ROMID13			44
#define ET_RE_ROMID14			45
#define ET_RE_ROMID15			46
#define ET_RE_ROMID16			47
#define ET_RE_ROMID17			48
#define ET_RE_ROMID18			49
#define ET_RE_ROMID19			50
#define ET_RE_ROMID20			51
#define ET_RE_ROMID21			52
#define ET_RE_ROMID22			53
#define ET_RE_ROMID23			54
#define ET_RE_ROMID24			55
#define ET_RE_ROMID25			56
#define ET_RE_ROMID26			57
#define ET_RE_ROMID27			58
#define ET_RE_ROMID28			59
#define ET_RE_ROMID29			60
#define ET_RE_ROMID30			61
#define ET_RE_ROMID31			62
#define ET_RE_ROMID32			63
#define ET_RE_ROMID33			64
#define ET_RE_ROMID34			65
#define ET_RE_ROMID35			66
#define ET_RE_ROMID36			67
#define ET_RE_ROMID37			68

 								
// more to be defined....		

//
// Effect IDs as defined in Jolt device
//
#define	EFFECT_ID_RTC_SPRING		0	// Built-in Return To Center Virtual Spring
#define	EFFECT_ID_FRICTIONCANCEL	1	// Friction cancellation


//
// --- Process List Structure
//
typedef struct _PLIST {
	ULONG	ulNumEffects;
	ULONG	ulProcessMode;	// PLIST_SUPERIMPOSE or PLIST_CONCATENATE
	PDNHANDLE pEffectArray;	// Effect ID[0} . . .
	ULONG	ulAction;
	ULONG	ulDuration;
} PLIST, *PPLIST;

//
// --- Behavioral Effects Structure
//
typedef struct _BE_XXX {
	LONG	m_XConstant;	//(KX/BX/MX/FX/Wall type)	
	LONG	m_YConstant;	//(KY/BY/MY/FY/KWall)
	LONG	m_Param3;		//(CX/VX/AX/Wall angle)
	LONG	m_Param4;		//(CY/VYO/AY/Wall distance)
} BE_XXX, *PBE_XXX;

//
// --- SysEx Messages
//
typedef struct _SYS_EX_HDR {
	BYTE		m_bSysExCmd;	// SysEx Fx command
	BYTE		m_bEscManufID;	// Escape to long Manufac. ID, s/b 0
	BYTE		m_bManufIDL;	// Low byte
	BYTE		m_bManufIDH;	// High byte
	BYTE		m_bProdID;		// Product ID
} SYS_EX_HDR, *PSYS_EX_HDR;

// --- Common Effect parameters
typedef struct _MIDI_EFFECT {
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bAngleL;		// Low 7 bits Direction Angle
	BYTE		bAngleH;		// High 2 bits Direction Angle
	BYTE		bGain;			// 7 bits Gain 1 - 100%
	BYTE		bForceOutRateL;	// Low 7 bits, 1 to 500 Hz
	BYTE		bForceOutRateH;	// High 2 bits
	BYTE		bPercentL;		// Low 7 bits Percent of waveform 1 to 10000
	BYTE		bPercentH;		// High 7 bits Loop Count
} MIDI_EFFECT, *PMIDI_EFFECT;

// --- Envelope
typedef struct MIDI_ENVELOPE {
	BYTE		bAttackLevel;	// Initial Attack amplitude 0 to +127
	BYTE		bSustainL;		// time to Sustain in 2ms ticks
	BYTE		bSustainH;		//
	BYTE		bSustainLevel;	// Amplitude level to sustain
	BYTE		bDecayL;		// time to Decay in 2ms ticks
	BYTE		bDecayH;
	BYTE		bDecayLevel;	// Amplitude level to decay
} MIDI_ENVELOPE, *PMIDI_ENVELOPE;

// --- Midi Assign
typedef struct _MIDI_ASSIGN_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: MIDI_ASSIGN
	BYTE		bChannel;		// Midi channel 1-16
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_ASSIGN_SYS_EX, *PMIDI_ASSIGN_SYS_EX;

// --- Get Effect Force Value at a tick sample time
typedef struct _MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX  {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: GET_EFFECT_FORCE_VALUE
	BYTE		bEffectID;		// Effect ID
	BYTE		bSampleTimeL;	// Low 7 bits in 2ms ticks
	BYTE		bSampleTimeH;	// High 7 bits in 2ms ticks
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX, *PMIDI_GET_EFFECT_FORCE_VALUE_SYS_EX;


// --- Note: For the following, if bEffectID = 0x7f, then New, else Modify
// --- Download Data - Synthesized Waveform
typedef struct _SE_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// ex: ET_SE_SINE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
// SE Parameters
	BYTE		bFreqL;			// Low 7 bits Frequency 1-2048Hz
	BYTE		bFreqH;			// High 4 bits	
	BYTE		bMaxAmpL;		// Low 7 bits Maximum Amplitude	+/- 100%
	BYTE		bMaxAmpH;		// High 1 bit
	BYTE		bMinAmpL;		// Low 7 bits Minimum Amplitude	+/- 100%
	BYTE		bMinAmpH;		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} SE_WAVEFORM_SYS_EX, *PSE_WAVEFORM_SYS_EX;

// --- Download Data - NOP Delay
typedef struct _NOP_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID, 0x7F = Create NEw
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bChecksum;
	BYTE		bEOX;
} NOP_SYS_EX, *PNOP_SYS_EX;

// --- Download Data - Behavioral SysEx
typedef struct _BEHAVIORAL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_SPRING
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_XXX Parameters
	BYTE		bXConstantL;	// Low 7 bits K	(in +/- 100%) X-Axis
	BYTE		bXConstantH;	// High 1 bit K
	BYTE		bYConstantL;	// Low 7 bits K	(in +/- 100%) Y-Axis
	BYTE		bYConstantH;	// High 1 bit K
	BYTE		bParam3L;   	// Low 7 bits Axis center (in +/- 100%)	X-Axis
	BYTE		bParam3H;  		// High 1 bit
	BYTE		bParam4L;   	// Low 7 bits Axis center (in +/- 100%)	Y-Axis
	BYTE		bParam4H;  		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} BEHAVIORAL_SYS_EX, *PBEHAVIORAL_SYS_EX;


// --- Download Data - Friction SysEx
typedef struct _FRICTION_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_FRICTION Parameters
	BYTE		bXFConstantL;	// Low 7 bits F	(in +/- 100%) X-Axis
	BYTE		bXFConstantH;	// High 1 bit F
	BYTE		bYFConstantL;	// Low 7 bits F	(in +/- 100%) Y-Axis
	BYTE		bYFConstantH;	// High 1 bit F
	BYTE		bChecksum;
	BYTE		bEOX;
} FRICTION_SYS_EX, *PFRICTION_SYS_EX;


// --- Download Data - WALL SysEx
#define INNER_WALL				0	// Wall face to center
#define	OUTER_WALL				1	// Wall face away from center

typedef struct _WALL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: e.g. EF_BE_WALL
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_SPRING Parameters
	BYTE		bWallType;		// INNER_WALL or OUTER_WALL
	BYTE		bWallConstantL;	// Low 7 bits: Similar to Spring Constant.
								//   Value is from +/- 100%.
	BYTE		bWallConstantH;	// High 1 bit
	BYTE		bWallAngleL;	// Low 7 bits: 0 to 359 degrees
								//   For simple vertical and horizontal walls,
								//   this value should be set to 0, 90,  180, 270
	BYTE		bWallAngleH;	// Low 2 bit
	BYTE		bWallDistance;  // 7 bits: Distance from Center of stick 0 to 100
	BYTE		bChecksum;
	BYTE		bEOX;
} WALL_SYS_EX, *PWALL_SYS_EX;

// --- Download Data - User Defined Waveform SysEx
typedef struct _UD_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
//	BYTE		bWaveformArray;	// Force Data . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} UD_WAVEFORM_SYS_EX, *PUD_WAVEFORM_SYS_EX;
#define UD_WAVEFORM_START_OFFSET (sizeof(UD_WAVEFORM_SYS_EX))


// --- Download Data - Process List SysEx
typedef struct _PROCESS_LIST_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bEffectArrayID;	// Effect ID[0] . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} PROCESS_LIST_SYS_EX, *PPROCESS_LIST_SYS_EX;
#define PROCESS_LIST_EFFECT_START_OFFSET (sizeof(PROCESS_LIST_SYS_EX))


//
// --- Function Prototypes
//
BOOL DetectMidiDevice(
	IN OUT UINT *pDeviceOutID);

HRESULT CMD_SetIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID);

HRESULT CMD_ModifyParam(
	IN WORD wNewParam);

HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFX_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

class CMidiSynthesized;


#endif // of ifdef _HAU_MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffeature.cpp ===
//	@doc
/**********************************************************************
*
*	@module	ForceFeatures.cpp	|
*
*	Implements CForceFeatures to use msgame's HID features.
*
*	History
*	----------------------------------------------------------
*	Mitchell Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ForceFeatures	|
*	CForceFeatures opens a handle to msgame in the context of
*	a particular device on construction.
*	The public members expose the feature interface for msgame.
*
*	Will work with NT5 as is.  For Win98 we need a different
*	scheme for getting HID path.  DI promises to fix somehow.
**********************************************************************///

#include <windows.h>
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dinputd.h>
extern "C" {
	#include <hidsdi.h>
}
#include "FFeature.h"

/***********************************************************************************
**
**	CForceFeatures::CForceFeatures(UINT uJoystickId)
**
**	@mfunc	C'tor gets Hid Path from Joystick and opens path to driver
**
**	@rdesc	None since this is c'tor.  However at the end of this routine
**			m_hDevice will contain a handle for the driver on success, or
**			will contain NULL on failure.  All routines will check the
**			value of m_hDevice before proceeding.
**
*************************************************************************************/
CForceFeatures::CForceFeatures() :
	m_hDevice(NULL)
{
}


/***********************************************************************************
**
**	CForceFeatures::~CForceFeatures()
**
**	@mfunc	D'tor closes handle to driver, if it was open
**
*************************************************************************************/
CForceFeatures::~CForceFeatures()
{
	if(m_hDevice)
	{
		CloseHandle(m_hDevice);
	}
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::Initialize(UINT uJoystickId, HINSTANCE hinstModule)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::Initialize
(
	UINT uJoystickId,		//@parm Joystick Id as used by winmm
	HINSTANCE hinstModule	//@parm Instance of the DLL for Creating DirectInput
)
{
	if (m_hDevice != NULL) {
		return S_OK;	// No need to reinitialize
	}

	HRESULT hr;
	
	//**
	//** Get HidPath
	//**  
	//**

	//
	//	Get IDirectInput interface	
	//
	IDirectInput *pDirectInput = NULL;
	IDirectInputJoyConfig *pDirectInputJoyConfig = NULL; 
	hr = DirectInputCreate(
			hinstModule,
			DIRECTINPUT_VERSION,
			&pDirectInput,
			NULL
			);
	if( FAILED(hr) ) return hr;

	//
	//	Get IDirectInputJoyConfig
	//
	hr=pDirectInput->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID *)&pDirectInputJoyConfig);
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}
	
	//
	//	GetConfig for JoyId
	//
	DIJOYCONFIG DiJoyConfig;
	DiJoyConfig.dwSize=sizeof(DIJOYCONFIG);
	hr = pDirectInputJoyConfig->GetConfig(
									uJoystickId,
									&DiJoyConfig,
									DIJC_GUIDINSTANCE
									);
	//
	//	Done with pDirectInputJoyConfig
	//
	pDirectInputJoyConfig->Release();
	pDirectInputJoyConfig = NULL;
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}

	//
	//  Get IDirectInputDevice interface
	//
	IDirectInputDevice *pDirectInputDevice;
	hr = pDirectInput->CreateDevice(DiJoyConfig.guidInstance, &pDirectInputDevice, NULL);
	//
	//	Done pDirectInput
	//
	pDirectInput->Release();
	pDirectInput = NULL;
	if( FAILED(hr) ) return hr;
	
	//
	//	Get HidPath
	//
	DIPROPGUIDANDPATH DiPropGuidAndPath;
	DiPropGuidAndPath.diph.dwSize = sizeof(DIPROPGUIDANDPATH);
	DiPropGuidAndPath.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	DiPropGuidAndPath.diph.dwObj = 0;
	DiPropGuidAndPath.diph.dwHow = DIPH_DEVICE;
	hr=pDirectInputDevice->GetProperty( DIPROP_GUIDANDPATH, &DiPropGuidAndPath.diph);

	//
	//	Done with pDirectInputDevice
	//
	pDirectInputDevice->Release();
	pDirectInputDevice = NULL;
	if( FAILED(hr) ) return hr;

	//**
	//**	Open Path to Driver
	//**
	m_hDevice = CreateFileW(
		DiPropGuidAndPath.wszPath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		m_hDevice = NULL;
	}
	if (m_hDevice == NULL)
	{
		DWORD err = ::GetLastError();
		return E_FAIL;
	}

	PHIDP_PREPARSED_DATA pHidPreparsedData;
	if (HidD_GetPreparsedData(m_hDevice, &pHidPreparsedData) == FALSE)
	{
		::CloseHandle(m_hDevice);
		m_hDevice = NULL;
		return E_FAIL;
	}
	HIDP_CAPS hidpCaps;
	HidP_GetCaps(pHidPreparsedData, &hidpCaps);
	m_uiMaxFeatureLength = hidpCaps.FeatureReportByteLength;
	HidD_FreePreparsedData(pHidPreparsedData);
	
	//
	//	On success, m_hDevice now contains a handle to the device
	//
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetId(PRODUCT_ID_REPORT& rProductId)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetId
(
	PRODUCT_ID_REPORT& rProductId	// @parm Reference to PRODUCT_ID_REPORT to get from driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}

	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rProductId.bReportId = MSGAME_FEATURE_GETID;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rProductId), m_uiMaxFeatureLength);

//	 -- HIDPI.H
//	 HIDP_GetData(Report Type, Data, Lenght, Preparse Data, Report, ReportLength);

	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}


/***********************************************************************************
**
**	HRESULT CForceFeatures::GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus)
**
**	@mfunc	Get the JoyChannel Status from msgame's MSGAME_FEATURE_GETSTATUS
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetStatus
(
	JOYCHANNELSTATUS_REPORT& rJoyChannelStatus	// @parm Reference to JOYCHANNELSTATUS_REPORT to be filled by driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rJoyChannelStatus.bReportId = MSGAME_FEATURE_GETSTATUS;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rJoyChannelStatus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
		DWORD err = GetLastError();
		return HRESULT_FROM_WIN32(err);
//	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulAckNak)
**
**	@mfunc	Returns an AckNak by using msgame's GetAckNak Featue
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetAckNak
(
	ULONG_REPORT& rulAckNak	// @parm REFERENCE to ULONG_REPORT to be filled by driver with AckNak
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulAckNak.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulAckNak), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetNackAck(ULONG_REPORT& rulNakAck)
**
**	@mfunc	Returns an AckNak by using msgame's MSGAME_FEATURE_NAKACK
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetNakAck(
	ULONG_REPORT& rulNakAck	// @parm REFERENCE to ULONG_REPORT to be filled by driver with NakAck
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulNakAck.bReportId = MSGAME_FEATURE_GETNAKACK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulNakAck), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
/***********************************************************************************
**
**	HRESULT CForceFeatures::GetSync(ULONG_REPORT& rulGameport)
**
**	@mfunc	Get Sync information from MSGAME's MSGAME_FEATURE_GETSYNC
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetSync
(
	ULONG_REPORT& rulGameport	// @parm REFERENCE to ULONG_REPORT to be filled by driver with Gameport
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulGameport.bReportId = MSGAME_FEATURE_GETSYNC;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulGameport), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return HRESULT_FROM_WIN32(GetLastError());
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::DoReset()
**
**	@mfunc	Does Reset via MSGAME's MSGAME_FEATURE_DORESET
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::DoReset()
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	ULONG_REPORT ulBogus;
	ulBogus.bReportId = MSGAME_FEATURE_DORESET;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&ulBogus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_obj.hpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.HPP
	Tab Settings:	5 9

    PURPOSE:    	Header to define SWFF MIDI device objects
    
    FUNCTIONS:
        		Classes with members and methods are kept in this header file

	Version Date        Author  Comments
	0.1		10-Sep-96	MEA     original
	1.1		17-Mar-97	MEA		DX-FF mode
			21-Mar-99	waltw	Removed unreferenced UpdateJoystickParams,
								GetJoystickParams
			16-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
								and pass down food chain

****************************************************************************/
#ifndef MIDI_OBJ_SEEN
#define MIDI_OBJ_SEEN
 
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "dinput.h"
#include "vxdioctl.hpp"
#include "ffeature.h"
#include "sw_error.hpp"

#define MAX_SCALE	1.27				// 1 to 100 = 1 to 127
#define TICKRATE	2					// 2 ms per tick divisor

#define SWFF_SHAREDMEM_FILE		"SWFF_SharedMemFile"
#define SWFF_MIDIEVENT			"SWFFMidiEvent\0"
#define SWFF_SHAREDMEM_MUTEX	"SWFFSharedMemMutex\0"
#define SWFF_JOLTOUTPUTDATA_MUTEX	"SWFFJoltOutputDataMutex\0"
#define SIZE_SHARED_MEMORY 1024			// 1024 bytes
#define MUTEX_TIMEOUT	10000			// 10 seconds timeout

// spring
#define DEF_SCALE_KX	100
#define DEF_SCALE_KY	100

// damper
#define DEF_SCALE_BX	100
#define DEF_SCALE_BY	100

// inertia
#define DEF_SCALE_MX	80
#define DEF_SCALE_MY	80

// friction
#define DEF_SCALE_FX	100
#define DEF_SCALE_FY	100

// wall
#define DEF_SCALE_W		100

typedef struct _FIRMWARE_PARAMS
{
	DWORD dwScaleKx;
	DWORD dwScaleKy;
	DWORD dwScaleBx;
	DWORD dwScaleBy;
	DWORD dwScaleMx;
	DWORD dwScaleMy;
	DWORD dwScaleFx;
	DWORD dwScaleFy;
	DWORD dwScaleW;
} FIRMWARE_PARAMS, *PFIRMWARE_PARAMS;
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams);

typedef struct _SYSTEM_PARAMS
{
	RTCSPRING_PARAM RTCSpringParam;
} SYSTEM_PARAMS, *PSYSTEM_PARAMS;
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams);


#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

typedef struct _JOYSTICK_PARAMS
{
	DWORD dwXYConst;
	DWORD dwRotConst;
	DWORD dwSldrConst;
	DWORD dwAJPos;
	DWORD dwAJRot;
	DWORD dwAJSldr;
	DWORD dwSprScl;
	DWORD dwBmpScl;
	DWORD dwDmpScl;
	DWORD dwInertScl;
	DWORD dwVelOffScl;
	DWORD dwAccOffScl;
	DWORD dwYMotBoost;
	DWORD dwXMotSat;
	DWORD dwReserved;
	DWORD dwMasterGain;
} JOYSTICK_PARAMS, *PJOYSTICK_PARAMS;



// Shared Memory data structure
typedef struct _SHARED_MEMORY {
	char	m_cWaterMark[MAX_SIZE_SNAME];
	ULONG	m_RefCnt;
	HANDLE	m_hMidiOut;
	MIDIINFO m_MidiOutInfo;
} SHARED_MEMORY, *PSHARED_MEMORY;


// Effect Types conversion structure
typedef struct _EFFECT_TYPE {
	ULONG	ulHostSubType;
	BYTE	bDeviceSubType;
} EFFECT_TYPE, *PEFFECT_TYPE;

//
// --- ROM Effects default parameters structure
//
typedef struct _ROM_FX_PARAM {
	ULONG	m_ROM_Id;
	ULONG	m_ForceOutputRate;
	ULONG	m_Gain;
	ULONG	m_Duration;
} ROM_FX_PARAM, *PROM_FX_PARAM;


// Structure to pass instance data from the application
//   to the low-level callback function. (Output done notification)
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    HMIDIOUT            hMapper;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

class CJoltMidi;
//	--- MIDI Effect base class
class CMidiEffect : public SYS_EX_HDR
{
 protected:
	BYTE	m_OpCode;				// Sub-command opcode: e.g. DNLOAD_DATA
	BYTE	m_SubType;				// Effect SubType: e.g. BE_SPRING
	BYTE	m_bEffectID;			// 0x7F = Create New, else valid Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
	BYTE	m_bAxisMask;
	BYTE	m_bPlayMode;			// DL_PLAY_SUPERIMPOSE || DL_PLAY_SOLO
    LPSTR	m_pBuffer;				// Ptr to a Midi SYS_EX Buffer
	int		m_MidiBufferSize;		// Size of SYS_EX buffer
	int		m_LoopCount;			// Loop Count for the playback
	LONG	m_Duration;				// Atomic Effect Duration (for 1 cycle)
	ENVELOPE	m_Envelope;			// Atomic Envelope (no loop count)
	EFFECT	m_OriginalEffectParam;	// the effect param when the effect was created

 public:
	// Constructor/Destructor
	CMidiEffect(ULONG ulButtonPlayMask);
	CMidiEffect(PEFFECT pEffect, PENVELOPE pEnvelope);
	virtual ~CMidiEffect(void);

	// Methods
	ULONG	SubTypeOf(void);
	BYTE	EffectIDOf(void) { return m_bEffectID; }
	ULONG	DurationOf(void) { return m_Duration * TICKRATE; }
	BYTE	AxisMaskOf(void) { return m_bAxisMask; }
	ULONG	DirectionAngle2DOf(void) 
			{ return(Effect.bAngleL+((USHORT)Effect.bAngleH<<7));}
	BYTE	GainOf(void) { return Effect.bGain; }
	ULONG	ButtonPlayMaskOf(void) 
			{ return(Effect.bButtonPlayL+((USHORT)Effect.bButtonPlayH<<7));}
	ULONG	ForceOutRateOf(void) 
			{ return (Effect.bForceOutRateL+((USHORT)Effect.bForceOutRateH<<7));}
	ULONG	PlayModeOf(void) { 
					if (DL_PLAY_SOLO == m_bPlayMode)
						return PLAY_SOLO;
					else 
						return PLAY_SUPERIMPOSE; }

	int		MidiBufferSizeOf(void) { return m_MidiBufferSize; }
    LPSTR	LockedBufferPtrOf(void) { return m_pBuffer; }
	int		LoopCountOf(void) { return m_LoopCount; }

	PEFFECT OriginalEffectParamOf() { return &m_OriginalEffectParam; }
	ENVELOPE * EnvelopePtrOf() { return &m_Envelope; }

	void	SetSubType(ULONG ulArg);
	void	SetEffectID(BYTE bArg) { m_bEffectID = bArg; }
	void	SetDuration(ULONG ulArg);
	void	SetAxisMask(BYTE bArg) { m_bAxisMask = bArg; }
	void	SetDirectionAngle(ULONG ulArg) 
			{ Effect.bAngleL = (BYTE) ulArg & 0x7f;
			  Effect.bAngleH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetGain(BYTE bArg) { Effect.bGain = (BYTE) (bArg * MAX_SCALE); }
	void	SetButtonPlaymask(ULONG ulArg)
			{ Effect.bButtonPlayL = (BYTE) ulArg & 0x7f;
			  Effect.bButtonPlayH = (BYTE) ((ulArg >> 7) & 0x03);}
	void	SetForceOutRate(ULONG ulArg) 
			{ Effect.bForceOutRateL = (BYTE) ulArg & 0x7f;
			  Effect.bForceOutRateH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetMidiBufferSize(int nArg) { m_MidiBufferSize = nArg; }
	void	SetMidiBufferPtr(LPSTR pArg) { m_pBuffer = pArg; }
	
	void	SetPlayMode(ULONG ulArg) { 
					if (PLAY_SOLO == ulArg) 
						m_bPlayMode = DL_PLAY_SOLO;
					else
						m_bPlayMode = DL_PLAY_SUPERIMPOSE; }

	void	SetLoopCount(ULONG ulAction) 
					{ m_LoopCount = ((ulAction >> 16) & 0xffff); }
	void	SetTotalDuration(void);
	void	SetEnvelope(PENVELOPE pArg) 
				{ m_Envelope.m_Type = pArg->m_Type;
				  m_Envelope.m_Attack = pArg->m_Attack;
				  m_Envelope.m_Sustain = pArg->m_Sustain;
				  m_Envelope.m_Decay = pArg->m_Decay;
				  m_Envelope.m_StartAmp = pArg->m_StartAmp;
				  m_Envelope.m_SustainAmp = pArg->m_SustainAmp;
				  m_Envelope.m_EndAmp = pArg->m_EndAmp; }
	void	ComputeEnvelope(void);
	BYTE  	ComputeChecksum(PBYTE pArg, int nBufferSize); 
	virtual PBYTE GenerateSysExPacket(void) = 0;
	HRESULT SendPacket(PDNHANDLE pDnloadID, int nPacketSize); 

	virtual HRESULT DestroyEffect();
};

//	--- MIDI Behavioral Effect derived class
class CMidiBehavioral : public CMidiEffect
{
 protected:
	BE_XXX	m_BE_XXXParam;	// Behavioral Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiBehavioral(void);

	// Methods
	LONG	XConstantOf(void) { return m_BE_XXXParam.m_XConstant; }
	LONG	YConstantOf(void) { return m_BE_XXXParam.m_YConstant; }
	LONG	Param3Of(void) { return m_BE_XXXParam.m_Param3; }
	LONG	Param4Of(void) { return m_BE_XXXParam.m_Param4; }

	void	SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX);
	void	SetXConstant(LONG lArg) { m_BE_XXXParam.m_XConstant = lArg; }
	void	SetYConstant(LONG lArg) { m_BE_XXXParam.m_YConstant = lArg; }
	void	SetParam3(LONG lArg) { m_BE_XXXParam.m_Param3 = lArg; }
	void	SetParam4(LONG lArg) { m_BE_XXXParam.m_Param4 = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Friction Effect derived class
class CMidiFriction : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiFriction(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Wall Effect derived class
class CMidiWall : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiWall(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI RTC Spring Effect derived class
class CMidiRTCSpring : public CMidiEffect
{
 protected:
	RTCSPRING_PARAM	m_RTCSPRINGParam;	// RTCSpring Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring);
	virtual ~CMidiRTCSpring(void);

	// Methods
	LONG	XKConstantOf(void) { return m_RTCSPRINGParam.m_XKConstant; }
	LONG	YKConstantOf(void) { return m_RTCSPRINGParam.m_YKConstant; }
	LONG	XAxisCenterOf(void) { return m_RTCSPRINGParam.m_XAxisCenter; }
	LONG	YAxisCenterOf(void) { return m_RTCSPRINGParam.m_YAxisCenter; }
	LONG	XSaturationOf(void) { return m_RTCSPRINGParam.m_XSaturation; }
	LONG	YSaturationOf(void) { return m_RTCSPRINGParam.m_YSaturation; }
	LONG	XDeadBandOf(void) { return m_RTCSPRINGParam.m_XDeadBand; }
	LONG	YDeadBandOf(void) { return m_RTCSPRINGParam.m_YDeadBand; }
	void	SetEffectParams(PRTCSPRING_PARAM pRTCSpring);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Delay Effect derived class
class CMidiDelay : public CMidiEffect
{
 protected:
 public:
	// Constructor/Destructor
	CMidiDelay(PEFFECT pEffect);
	virtual ~CMidiDelay(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Synthesized Effect derived class
class CMidiSynthesized : public CMidiEffect
{
 protected:
	ULONG	m_Freq;			// Frequency
	LONG	m_MaxAmp;		// Maximum Amplitude
	LONG	m_MinAmp;		// Minimum Amplitude
 public:
	// Constructor/Destructor
	CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope, PSE_PARAM pParam);
	virtual ~CMidiSynthesized(void);

	// Methods
	ULONG	FreqOf(void)   { return m_Freq; }
	LONG	MaxAmpOf(void) { return m_MaxAmp; }
	LONG	MinAmpOf(void) { return m_MinAmp; }

	void	SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam, ULONG ulMode);
	void	SetFreq(ULONG ulArg) { m_Freq = ulArg; }
	void	SetMaxAmp(LONG lArg) { m_MaxAmp = lArg; }
	void	SetMinAmp(LONG lArg) { m_MinAmp = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI UD_Waveform Effect derived class
class CMidiUD_Waveform : public CMidiEffect
{
 protected:
	EFFECT  m_Effect;
	int		m_NumberOfVectors;// Size of the Array
	PBYTE	m_pArrayData;	// Pointer to an scaled (+/-127) array of forces
	PBYTE	m_pRawData;		// Pointer to unscaled array of forces

 public:
	// Constructor/Destructor
	CMidiUD_Waveform(PEFFECT pEffect);
	CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray);
	virtual ~CMidiUD_Waveform(void);

	// Methods
	PEFFECT EffectPtrOf() { return (PEFFECT) &m_Effect.m_Bytes; }
	int		NumberOfVectorsOf(void) { return m_NumberOfVectors; }
	PBYTE	ArrayDataPtrOf(void) { return m_pArrayData; }
	int		CompressWaveform(PBYTE pSrcArray, PBYTE pDestArray, int nSrcSize, ULONG *pNewRate);
	void	SetEffectParams(PEFFECT pEffect);
	int		SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate);
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- Jolt Device base class
class CJoltMidi
{
 protected:
	LOCAL_PRODUCT_ID m_ProductID;			// Device information
	FIRMWARE_PARAMS	m_FirmwareParams;	// Behavioral effect fudge factors
	DELAY_PARAMS	m_DelayParams;		// Timing parameters

	// Power Cycle Restore Thread variables
#if 0
	DWORD   m_dwThreadID;
	HANDLE  m_hDataEvent;
	HANDLE  m_hDataThread;
	DWORD	m_dwThreadSignal;
	DWORD	m_dwThreadStatus;	        // TRUE = thread is alive, else FALSE
#endif
	ULONG			m_COMMInterface;	// COMM_WINMM || COMM_MIDI_BACKDOOR || COMM_SERIAL_BACKDOOR || COMM_SERIAL_FILE
	ULONG			m_COMMPort;			// e.g. 330, 3F8, or 0 for winmm
	HANDLE			m_hVxD;				// Handle to VxD for IOCTL interface
	HANDLE  		m_hMidiOutputEvent;	// Handle to Midi Output Event
	BYTE			m_MidiChannel;		// Midi Channel
	SWFF_ERROR  	m_Error;		 	// System Error codes
	MIDIINFO 		m_MidiOutInfo;		// Midi output Info structure
	BOOL			m_ShutdownSent;		// TRUE = Last command sent was Shutdown
	DIAG_COUNTER	m_DiagCounter;		// For debugging, Diagnostics counter

	SWDEVICESTATE	m_DeviceState;
	HANDLE			m_hPrimaryBuffer;	// Handle to locked memory
	LPBYTE			m_pPrimaryBuffer;	// Pointer to the Primary buffer memory
	PROM_FX_PARAM	m_pRomFxTable;		// Default settings for ROM Effects
	HANDLE	m_hSharedMemoryFile;		// Handle to a memory mapped file
	PSHARED_MEMORY	m_pSharedMemory;	// Pointer to a Shared Memory structure
	HANDLE			m_hSWFFDataMutex;	// Local copy of Mutex handle

 public:
	// Constructor/Destructor
	CJoltMidi(void);
	~CJoltMidi(void);

	// Methods
	HANDLE SWFFDataMutexHandleOf() { return m_hSWFFDataMutex; }
	HRESULT Initialize(DWORD dwDeviceID);
#if 0
	DWORD  ThreadIDOf(void) { return m_dwThreadID; }
	HANDLE DataEventOf(void) {return m_hDataEvent; }
	HANDLE DataThreadOf(void) {return m_hDataThread; }
	DWORD  ThreadSignalOf(void) { return m_dwThreadSignal; }
	DWORD  ThreadStatusOf(void) { return m_dwThreadStatus; }
#endif

	HANDLE	MidiOutputEventHandleOf(void) { return m_hMidiOutputEvent; }
	HMIDIOUT MidiOutHandleOf(void) { return HMIDIOUT(m_pSharedMemory->m_hMidiOut); }
	UINT GetSharedMemoryReferenceCount() { return (m_pSharedMemory != NULL) ? m_pSharedMemory->m_RefCnt : 0; }
	BYTE	MidiChannelOf(void) { return m_MidiChannel; }
	void	CJoltGetLastError(SWFF_ERROR* pError)
							{ pError->HCode = m_Error.HCode;
							  pError->ulDriverCode = m_Error.ulDriverCode; }
	MIDIINFO *MidiOutInfoOf(void) { return &m_MidiOutInfo; }
	BOOL	ShutdownSentOf(void) { return m_ShutdownSent; }
	PDIAG_COUNTER DiagCounterPtrOf() { return &m_DiagCounter; }
	PBYTE	PrimaryBufferPtrOf() { return m_pPrimaryBuffer; }

	LOCAL_PRODUCT_ID* ProductIDPtrOf() { return &m_ProductID; }
	PFIRMWARE_PARAMS FirmwareParamsPtrOf() {return &m_FirmwareParams; }
	PDELAY_PARAMS DelayParamsPtrOf() {return &m_DelayParams; }
	ULONG	COMMInterfaceOf() { return m_COMMInterface; }
	ULONG	COMMPortOf() { return m_COMMPort; }

#if 0
	void 	SetThreadIDOf(DWORD dwArg) { m_dwThreadID = dwArg; }
	void 	SetDataEvent(HANDLE hArg) { m_hDataEvent = hArg; }
	void 	SetDataThread(HANDLE hArg) { m_hDataThread = hArg; }
	void 	SetThreadSignal(DWORD dwArg) { m_dwThreadSignal = dwArg; }
	void 	SetThreadStatus(DWORD dwArg) { m_dwThreadStatus = dwArg; }
	BOOL	LockJoltOutputData(void);
	void	UnlockJoltOutputData(void);
#endif

	BOOL	LockSharedMemory(void);
	void	UnlockSharedMemory(void);

	void	SetSWFFDataMutexHandle(HANDLE hArg) { m_hSWFFDataMutex = hArg;}
	void 	SetMidiOutHandle(HMIDIOUT hArg) { LockSharedMemory();
											  m_pSharedMemory->m_hMidiOut = hArg;
											  UnlockSharedMemory();}
	void	SetMidiChannel(BYTE nArg) { m_MidiChannel = nArg; }
	void	SetShutdownSent(BOOL bArg) { m_ShutdownSent = bArg; }
	void	ClearDiagCounters(void) { m_DiagCounter.m_NACKCounter = 0;
									  m_DiagCounter.m_LongMsgCounter = 0; 
									  m_DiagCounter.m_ShortMsgCounter = 0;
									  m_DiagCounter.m_RetryCounter = 0; }
	void	BumpNACKCounter(void) { m_DiagCounter.m_NACKCounter++; }
	void	BumpLongMsgCounter(void) { m_DiagCounter.m_LongMsgCounter++; }
	void	BumpShortMsgCounter(void) { m_DiagCounter.m_ShortMsgCounter++; }
	void	BumpRetryCounter(void) { m_DiagCounter.m_RetryCounter++; }

	HRESULT	LogError(HRESULT hSystemError, HRESULT DriverError);

	SWDEVICESTATE GetSWDeviceStateNoUpdate() const { return m_DeviceState; } 

	void	UpdateDeviceMode(ULONG ulMode);
	HRESULT GetJoltID(LOCAL_PRODUCT_ID* pProductID);

	// Midi management
	BOOL	DetectMidiDevice(DWORD dwDeviceID, ULONG *pCOMMPort);

	HRESULT MidiSendShortMsg(BYTE cStatus, BYTE cData1,BYTE cData2);
	HRESULT MidiSendLongMsg(void);
	
	// Response from Jolt management
	HRESULT GetAckNackData(int nTimeWait, PACKNACK pAckNack, USHORT ackMethod);
	BOOL	QueryForJolt(void);

	// Digital OverDrive interface
	HRESULT	InitDigitalOverDrive(DWORD dwDeviceID);
	HANDLE	VxDHandleOf(void) { return m_hVxD; }

	// ROM Effects
	HRESULT SetupROM_Fx(PEFFECT pEffect);

	// Thread
//	HRESULT PowerCycleThreadCreate(void);
};

#endif    // of ifndef MIDI_OBJ_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_obj.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.CPP
	Tab stops 5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for SWFF MIDI device object

    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -----------------------------------------
	0.1			10-Sep-96	MEA     original
	1.1			20-May-97	MEA		Added Mutex and Thread safe code
				17-Jun-97	MEA		Fixed bug Midi Handle lost if 1st process
									terminated.
				21-Mar-99	waltw	Removed unreferenced UpdateJoystickParams,
									GetJoystickParams
				21-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
									and pass down food chain
				21-Mar-99	waltw	Added dwDeviceID param to DetectMidiDevice,
									InitDigitalOverDrive,

****************************************************************************/
#include <assert.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mmsystem.h>
#include "SW_Error.hpp"
#include "midi_obj.hpp"
#include "vxdioctl.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "DPack.h"
#include "CritSec.h"

#include "DTrans.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
extern void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;

/****************************************************************************

   Declaration of variables

****************************************************************************/


/****************************************************************************

   Macros etc

****************************************************************************/

#ifdef _DEBUG
extern char g_cMsg[160];
void DebugOut(LPCTSTR szDebug)
{
	g_CriticalSection.Enter();
	_RPT0(_CRT_WARN, szDebug);
	g_CriticalSection.Leave();

#ifdef _LOG_DEBUG
#pragma message("Compiling with Debug Log to SW_WHEEL.txt")
	FILE *pf = fopen("SW_WHEEL.txt", "a");
	if (pf != NULL)
	{
		fputs(szDebug, pf);
		fclose(pf);
	}
#endif // _LOG_DEBUG
}
#else !_DEBUG
#define DebugOut(x)
#endif // _DEBUG


// ****************************************************************************
// *** --- Member functions for base CJoltMidi
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::CJoltMidi
// Purpose:		Constructor(s)/Destructor for CJoltMidi Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CJoltMidi::CJoltMidi(void)
{
	CriticalLock cl;

	static char cWaterMark[MAX_SIZE_SNAME] = {"SWFF_SHAREDMEMORY MEA"};
	BOOL bAlreadyMapped = FALSE;
#ifdef _DEBUG
	DebugOut("SWFF_PRO(DX):CJoltMidi::CJoltMidi\n");
#endif
	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

// Create an in-memory memory-mapped file
	m_hSharedMemoryFile = CreateFileMapping((HANDLE) 0xFFFFFFFF,
							NULL, PAGE_READWRITE, 0, SIZE_SHARED_MEMORY,
    							__TEXT(SWFF_SHAREDMEM_FILE));

	if (m_hSharedMemoryFile == NULL)
	{
#ifdef _DEBUG
	    DebugOut("SW_WHEEL(DX):ERROR! Failed to create Memory mapped file\n");
#endif
	}
	else
	{
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	    {
			bAlreadyMapped = TRUE;
	    }
		// File mapping created successfully.
		// Map a view of the file into the address space.
		m_pSharedMemory = (PSHARED_MEMORY) MapViewOfFile(m_hSharedMemoryFile,
			              FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
		if ((BYTE *) m_pSharedMemory == NULL)
		{
#ifdef _DEBUG
		    DebugOut("SW_WHEEL(DX):ERROR! Failed to Map view of shared memory\n");
#endif
		}

// ***** Shared Memory Access *****
		LockSharedMemory();
		if (!bAlreadyMapped)
		{
			// Set watermark and initialize, Bump Ref Count
			memcpy(&m_pSharedMemory->m_cWaterMark[0], &cWaterMark[0], MAX_SIZE_SNAME);
			m_pSharedMemory->m_RefCnt = 0;
		}
		m_pSharedMemory->m_RefCnt++;
	}
#ifdef _DEBUG
		wsprintf(g_cMsg, "SW_WHEEL(DX): Shared Memory:%lx, m_RefCnt:%d\n",m_pSharedMemory,
				m_pSharedMemory->m_RefCnt);
		DebugOut(g_cMsg);
#endif
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****

}

// --- Destructor
CJoltMidi::~CJoltMidi()
{
	CriticalLock cl;

	DebugOut("SW_WHEEL(DX):CJoltMidi::~CJoltMidi()\n");
	// Normal CJoltMidi Destructor

// Free the Primary SYS_EX locked memory
	if (m_hPrimaryBuffer) {
	    GlobalUnlock(m_hPrimaryBuffer);
    	GlobalFree(m_hPrimaryBuffer);
	}

// ***** Shared Memory Access *****
	LockSharedMemory();
	// Decrement Ref Count and clean up if equal to zero.
	m_pSharedMemory->m_RefCnt--;
#ifdef _DEBUG
	wsprintf(g_cMsg,"CJoltMidi::~CJoltMidi. RefCnt = %d\n",m_pSharedMemory->m_RefCnt);
	DebugOut(g_cMsg);
#endif

	if (0 == m_pSharedMemory->m_RefCnt)	
	{
		if ((g_pDataTransmitter != NULL) && (g_pDataPackager != NULL)) {
			// Tri-state Midi lines
			if (g_pDataPackager->SendForceFeedbackCommand(SWDEV_KILL_MIDI) == SUCCESS) {
				ACKNACK ackNack;
				g_pDataTransmitter->Transmit(ackNack);	// Send it off
			}
		}
	}

	// Kill Data Packager
	delete g_pDataPackager;
	g_pDataPackager = NULL;

	// Kill Data Transmitter
	delete g_pDataTransmitter;
	g_pDataTransmitter = NULL;

	// This gets closed in UnlockSharedMemory call below. 22-Mar-99 waltw
//	if (m_hSWFFDataMutex) CloseHandle(m_hSWFFDataMutex);

	// Release the Midi Output Event handles
	if (m_hMidiOutputEvent)	 {
		CloseHandle (m_hMidiOutputEvent);
		m_hMidiOutputEvent = NULL;
	}

// ***** End of Shared Memory Access *****

	// Release Memory Mapped file handles
	if (m_hSharedMemoryFile != NULL) {
		UnmapViewOfFile((LPCVOID) m_pSharedMemory);
		CloseHandle(m_hSharedMemoryFile);
	}

	// Release Mutex handle after releasing Mem Mapped file
	UnlockSharedMemory();

	// Close VxD handles
	if (g_pDriverCommunicator != NULL)
	{
		delete g_pDriverCommunicator;
		g_pDriverCommunicator = NULL;
	}

	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::Initialize
// Purpose:		Initializer
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::Initialize(DWORD dwDeviceID)
{
	CriticalLock cl;

	HRESULT hRet = SUCCESS;

	// initialize the MIDI output information block
	m_MidiOutInfo.uDeviceType     = MIDI_OUT;
	m_MidiOutInfo.hMidiOut        = NULL;
    m_MidiOutInfo.fAlwaysKeepOpen = TRUE;
    m_MidiOutInfo.uDeviceStatus   = MIDI_DEVICE_IDLE;
	m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;
	m_MidiOutInfo.MidiHdr.dwUser = 0;
	m_MidiOutInfo.MidiHdr.dwOffset = 0;
	m_MidiOutInfo.MidiHdr.dwFlags = 0;
	
    // Allocate and lock global memory for SysEx messages
    m_hPrimaryBuffer = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, MAX_SYS_EX_BUFFER_SIZE);
	assert(m_hPrimaryBuffer);
	if (m_hPrimaryBuffer == NULL)
	{
		return E_OUTOFMEMORY;
	}

    m_pPrimaryBuffer = (LPBYTE) GlobalLock(m_hPrimaryBuffer);
	assert(m_pPrimaryBuffer);
    if(NULL == m_pPrimaryBuffer)
	{
	   	GlobalFree(m_hPrimaryBuffer);
		return (SFERR_DRIVER_ERROR);
	}

	// Initialize the IOCTL interface to VjoyD mini-driver
	hRet = InitDigitalOverDrive(dwDeviceID);
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Digital OverDrive\n");
		return (hRet);
	}
	else
		DebugOut("InitDigitalOverDrive - Success\n");

	// Create a Callback Event
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (NULL == hEvent)
	{
		// Create an Event for notification when Midi Output has completed
		m_hMidiOutputEvent = CreateEvent(NULL,  // No security
                          TRUE,			// Manual reset
                          FALSE,		// Initial event is non-signaled
                          SWFF_MIDIEVENT );		// Named
		assert(m_hMidiOutputEvent);
	}
	else
		m_hMidiOutputEvent = hEvent;

	// This function is only called after g_pJoltMidi created
	assert(g_pJoltMidi);
	
	PDELAY_PARAMS pDelayParams = g_pJoltMidi->DelayParamsPtrOf();
	GetDelayParams(dwDeviceID, pDelayParams);

	// Reset HW first
	g_pDriverCommunicator->ResetDevice();
	Sleep(DelayParamsPtrOf()->dwHWResetDelay);

	// Set MIDI channel to default then Detect a Midi Device
	if (!DetectMidiDevice(dwDeviceID, &m_COMMPort)) {		// Port address
		DebugOut("Warning! No Midi Device detected\n");
		return (SFERR_DRIVER_ERROR);
	} else {
#ifdef _DEBUG
		wsprintf(g_cMsg,"DetectMidiDevice returned: DeviceID=%d, COMMInterface=%x, COMMPort=%x\n",
			m_MidiOutInfo.uDeviceID, m_COMMInterface, m_COMMPort);
		DebugOut(g_cMsg);
#endif
	}

	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	// Set the status byte properly
	ULONG portByte = 0;
	g_pDriverCommunicator->GetPortByte(portByte);	// don't care about success, always fails on old driver
	if (portByte & STATUS_GATE_200) {
		g_pDataTransmitter->SetNextNack(1);
	} else {
		g_pDataTransmitter->SetNextNack(0);
	}

	// Send Initialization packet(s) to Jolt
	hRet = g_pDataPackager->SetMidiChannel(DEFAULT_MIDI_CHANNEL);
	if (hRet == SUCCESS) {
		ACKNACK ackNack;
		hRet = g_pDataTransmitter->Transmit(ackNack);
	}
	if (hRet != SUCCESS) {
		DebugOut("Warning! Could not Initialize Jolt\n");
		return (hRet);
	} else {
		DebugOut("JOLT SetMidiChannel - Success\n");
	}

	// At this point, we have a valid MIDI path...
	// Continue by setting up the ROM Effects default table entries
							 // ID  , OutputRate, Gain, Duration
	static	ROM_FX_PARAM RomFxTable [] = {{ RE_ROMID1 , 100, 100, 12289 }, // Random Noise
								  { RE_ROMID2 , 100, 100,  2625 }, // AircraftCarrierTakeOff
								  { RE_ROMID3 , 100,  50,   166 }, // BasketballDribble
								  { RE_ROMID4 , 100,  14, 10000 }, // CarEngineIdling
								  { RE_ROMID5 , 100,  30,  1000 }, // Chainsaw
								  { RE_ROMID6 , 100, 100,  1000 }, // ChainsawingThings
								  { RE_ROMID7 , 100,  40, 10000 }, // DieselEngineIdling
								  { RE_ROMID8 , 100, 100,   348 }, // Jump
								  { RE_ROMID9 , 100, 100,   250 }, // Land
								  { RE_ROMID10, 200, 100,  1000 }, // MachineGun
								  { RE_ROMID11, 100, 100,    83 }, // Punched
								  { RE_ROMID12, 100, 100,  1000 }, // RocketLauncher
								  { RE_ROMID13, 100,  98,   500 }, // SecretDoor
								  { RE_ROMID14, 100,  66,    25 }, // SwitchClick
								  { RE_ROMID15, 100,  75,   500 }, // WindGust
								  { RE_ROMID16, 100, 100,  2500 }, // WindShear
								  { RE_ROMID17, 100, 100,    50 }, // Pistol
								  { RE_ROMID18, 100, 100,   295 }, // Shotgun
								  { RE_ROMID19, 500,  95,  1000 }, // Laser1
								  { RE_ROMID20, 500,  96,  1000 }, // Laser2
								  { RE_ROMID21, 500, 100,  1000 }, // Laser3
								  { RE_ROMID22, 500, 100,  1000 }, // Laser4
								  { RE_ROMID23, 500, 100,  1000 }, // Laser5
								  { RE_ROMID24, 500,  70,  1000 }, // Laser6
								  { RE_ROMID25, 100, 100,    25 }, // OutOfAmmo
								  { RE_ROMID26, 100,  71,  1000 }, // LigntningGun
								  { RE_ROMID27, 100, 100,   250 }, // Missile
								  { RE_ROMID28, 100, 100,  1000 }, // GatlingGun
								  { RE_ROMID29, 500,  97,   250 }, // ShortPlasma
								  { RE_ROMID30, 500, 100,   500 }, // PlasmaCannon1
								  { RE_ROMID31, 500,  99,   625 }, // PlasmaCannon2
								  { RE_ROMID32, 100, 100,   440 }}; // Cannon
//								  { RE_ROMID33, 100,  68,  1000 }, // FlameThrower
//								  { RE_ROMID34, 100, 100,    75 }, // BoltActionRifle
//								  { RE_ROMID35, 500, 100,   300 }, // Crossbow
//								  { RE_ROMID36, 100, 100,  1000 }, // Sine
//								  { RE_ROMID37, 100, 100,  1000 }}; // Cosine
	m_pRomFxTable = &RomFxTable[0];

// ***** Shared Memory Access *****
	LockSharedMemory();
	LONG lRefCnt = m_pSharedMemory->m_RefCnt;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		
	// Initialize the RTC_Spring object
	g_ForceFeedbackDevice.InitRTCSpring(dwDeviceID);

	// initialize the joystick params
	g_ForceFeedbackDevice.InitJoystickParams(dwDeviceID);

	// initialize the firmware params fudge factors (for the first time)
	// in the case of the FFD interface, this will be the only time they
	// are initialized, which may cause a problem because joystick is assumed
	// to be ID1
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	GetFirmwareParams(dwDeviceID, pFirmwareParams);

	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::LockSharedMemory
// Purpose:     Creates a Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     TRUE if Mutex available else FALSE

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::LockSharedMemory(void)
{
	DWORD dwRet;
	{
		CriticalLock cl;

	// Create the SWFF mutex
		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, SWFF_SHAREDMEM_MUTEX);
		if (NULL == hMutex)
		{
			// Doesn't exist yet, so create it
			hMutex = CreateMutex(NULL, TRUE, SWFF_SHAREDMEM_MUTEX);
			if (NULL == hMutex)
			{
	#ifdef _DEBUG
				DebugOut("Error! Could not create SWFFDataMutex\n");
	#endif
				m_hSWFFDataMutex = NULL;
				return (FALSE);
			}
		}
		// SUCCESS
		m_hSWFFDataMutex = hMutex;
		dwRet = WaitForSingleObject(m_hSWFFDataMutex, MUTEX_TIMEOUT);
	}	// End of Critical Section

	if (WAIT_OBJECT_0 == dwRet)
		return (TRUE);
	else
	{
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"CJoltMidi::LockSharedMemory() error return: %lx\n", dwRet);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif		
		return (FALSE);
	}
}


// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::UnlockSharedMemory
// Purpose:     Releases Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     none

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
void CJoltMidi::UnlockSharedMemory(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	if (NULL != m_hSWFFDataMutex)
	{
		ReleaseMutex(m_hSWFFDataMutex);
		CloseHandle(m_hSWFFDataMutex);
		m_hSWFFDataMutex=NULL;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetAckNackData
// Purpose:		Waits for a Response ACK
//
// Parameters:	int nTImeWait		- Time to wait in 1 ms increment, 0=no wait
//				PACKNACK pAckNack	- Pointer to ACKNACK structure
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetAckNackData(
	IN int nTimeWait,
	IN OUT PACKNACK pAckNack,
	IN USHORT usRegIndex)
{
	CriticalLock cl;

	assert(pAckNack);
// Use IOCTL from VxD to get AckNack data
// Wait for Event to be set
	if (nTimeWait && m_hMidiOutputEvent)
	{
		DWORD dwRet = WaitForSingleObject(m_hMidiOutputEvent, nTimeWait);
		//		:
#ifdef _DEBUG
		wsprintf(g_cMsg,"WaitForSingleObject %lx returned %lx, nTimeWait=%ld\n", m_hMidiOutputEvent, dwRet, nTimeWait);
		DebugOut(g_cMsg);
#endif
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);
	}

	HRESULT hRet = g_pDriverCommunicator->GetAckNack(*pAckNack, usRegIndex);

	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::InitDigitalOverDrive
// Purpose:		Initialize the VxD interface
//
// Parameters:	none
//
// Returns:		SUCCESS or Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT	CJoltMidi::InitDigitalOverDrive(DWORD dwDeviceID)
{
	if (g_pDriverCommunicator != NULL)
	{	// Attempt to reinit
		ASSUME_NOT_REACHED();
		return S_OK;
	}

//
// --- THIS IS A CRITICAL SECTION
//
	HRESULT hRet = SUCCESS;
	DWORD driverMajor = 0xFFFFFFFF;
	DWORD driverMinor = 0xFFFFFFFF;

	CriticalLock cl;
	// This fork works on NT5 only (VxD stuff removed)
	assert(g_ForceFeedbackDevice.IsOSNT5() == TRUE);
	{
		g_pDriverCommunicator = new HIDFeatureCommunicator;
		if (g_pDriverCommunicator == NULL)
		{
			return DIERR_OUTOFMEMORY;
		}
		if (((HIDFeatureCommunicator*)g_pDriverCommunicator)->Initialize(dwDeviceID) == FALSE)
		{	// Could not load the driver
			hRet = SFERR_DRIVER_ERROR;
		}
	}

	if (FAILED(hRet))
	{
		return hRet;
	}

	// Loaded driver, get the version
	g_pDriverCommunicator->GetDriverVersion(driverMajor, driverMinor);

	g_ForceFeedbackDevice.SetDriverVersion(driverMajor, driverMinor);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::UpdateDeviceMode
// Purpose:		Sets JOLT Device Mode
//
// Parameters:	ULONG ulMode
//
// Returns:		none
//				
// Algorithm:
// This is the SideWinder State structure
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
void CJoltMidi::UpdateDeviceMode(ULONG ulMode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	switch (ulMode)
	{
		case SWDEV_FORCE_ON:			// REVIEW
		case SWDEV_FORCE_OFF:
			m_DeviceState.m_ForceState = ulMode;
			break;

		case SWDEV_SHUTDOWN:
			m_DeviceState.m_ForceState = ulMode;
			m_DeviceState.m_EffectState = 0;
			break;

		case SWDEV_STOP_ALL:
		case SWDEV_CONTINUE:
		case SWDEV_PAUSE:
			m_DeviceState.m_EffectState = ulMode;
			break;

		default:
			break;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltID
// Purpose:		Returns JOLT ProductID
//
// Parameters:	LOCAL_PRODUCT_ID* pProductID	- Pointer to a PRODUCT_ID structure
//
// Returns:		none
//				
// Algorithm:	
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltID(LOCAL_PRODUCT_ID* pProductID)
{
	HRESULT hRet;
	assert(pProductID->cBytes = sizeof(LOCAL_PRODUCT_ID));
	if (pProductID->cBytes != sizeof(LOCAL_PRODUCT_ID)) return (SFERR_INVALID_STRUCT_SIZE);

//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		if (SUCCESS == (hRet = g_pDriverCommunicator->GetID(*pProductID))) break;
	}
	if (SUCCESS == hRet)
	{
		memcpy(&m_ProductID, pProductID, sizeof(LOCAL_PRODUCT_ID));
	}
	else
		DebugOut("GetJoltID: Warning! GetIDPacket - Fail\n");

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::LogError
// Purpose:		Logs Error codes
//
// Parameters:	HRESULT SystemError		- System Error code
//				HRESULT DriverError		- Driver Error code
//
// Returns:		SWFORCE Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
typedef struct _DRIVERERROR {
	ULONG	ulDriverCode;
	LONG	lSystemCode;
} DRIVERERROR, *PDRIVERERROR;

HRESULT	CJoltMidi::LogError(
	IN HRESULT SystemError,
	IN HRESULT DriverError)
{
// REVIEW: map MM error codes to our SWForce codes

	DRIVERERROR DriverErrorCodes[] = {
		{DEV_ERR_INVALID_ID        , SWDEV_ERR_INVALID_ID},
		{DEV_ERR_INVALID_PARAM     , SWDEV_ERR_INVALID_PARAM},
		{DEV_ERR_CHECKSUM          , SWDEV_ERR_CHECKSUM},
		{DEV_ERR_TYPE_FULL         , SWDEV_ERR_TYPE_FULL},
		{DEV_ERR_UNKNOWN_CMD       , SWDEV_ERR_UNKNOWN_CMD},
		{DEV_ERR_PLAYLIST_FULL     , SWDEV_ERR_PLAYLIST_FULL},
		{DEV_ERR_PROCESS_LIST_FULL , SWDEV_ERR_PROCESSLIST_FULL} };

	int nDriverErrorCodes = sizeof(DriverErrorCodes)/(sizeof(DRIVERERROR));
	for (int i=0; i<nDriverErrorCodes; i++)
	{
		if (DriverError == (LONG) DriverErrorCodes[i].ulDriverCode)
		{
			SystemError = DriverErrorCodes[i].lSystemCode;
			break;
		}
	}
	// Store in Jolt object
	m_Error.HCode = SystemError;
	m_Error.ulDriverCode = DriverError;

#ifdef _DEBUG
	wsprintf(g_cMsg,"LogError: SystemError=%.8lx, DriverError=%.8lx\n",
			 SystemError, DriverError);
	DebugOut(g_cMsg);
#endif
	return SystemError;
}

//
// ----------------------------------------------------------------------------
// Function: 	SetupROM_Fx
// Purpose:		Sets up parameters for ROM Effects
// Parameters:  PEFFECT pEffect
//				
//
// Returns:		pEffect is updated with new ROM parameters
//				OutputRate
//				Gain
//				Duration
//	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::SetupROM_Fx(
	IN OUT PEFFECT pEffect)
{
	assert(pEffect);
	if (NULL == pEffect) return (SFERR_INVALID_PARAM);
							
	ULONG ulSubType = pEffect->m_SubType;
	BOOL bFound = FALSE;
	for (int i=0; i< MAX_ROM_EFFECTS; i++)
	{
		if (ulSubType == m_pRomFxTable[i].m_ROM_Id)
		{
			bFound = TRUE;
			break;
		}
	}
	if (!bFound) return (SFERR_INVALID_OBJECT);
	// Found, so fill in the default parameters, use Default if Gain=1, Duration=-1, OutputRate=-1
	BOOL bDefaultDuration = (ULONG)-1 == pEffect->m_Duration;
	if (1 == pEffect->m_Gain) pEffect->m_Gain = m_pRomFxTable[i].m_Gain;
	if (bDefaultDuration) pEffect->m_Duration = m_pRomFxTable[i].m_Duration;
	if ((ULONG)-1 == pEffect->m_ForceOutputRate)
	{
		pEffect->m_ForceOutputRate = m_pRomFxTable[i].m_ForceOutputRate;
	}
	else if(bDefaultDuration && pEffect->m_ForceOutputRate != 0)
	{
		// scale the duration to correspond to the output rate
		pEffect->m_Duration = pEffect->m_Duration*m_pRomFxTable[i].m_ForceOutputRate/pEffect->m_ForceOutputRate;
	}
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	DetectMidiDevice
// Purpose:    	Determines Midi Output Device ID
// Parameters:
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//				else FALSE
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::DetectMidiDevice(
	IN	DWORD dwDeviceID,
	OUT ULONG *pCOMMPort)
{
	CriticalLock cl;

	// Set defaults
	*pCOMMPort      = NULL;

	// Turn on tristated Jolt MIDI lines by call GetIDPacket()
	LOCAL_PRODUCT_ID ProductID = {sizeof(LOCAL_PRODUCT_ID)};
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);	
	if (SUCCESS != GetJoltID(&ProductID))
	{
		DebugOut("DetectMidiDevice: Warning! GetIDPacket - Fail\n");
		return (FALSE);
	}

#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: ProductID=%.8lx, FWVersion=%d.%.2ld\n",
		&szDeviceName,	
		m_ProductID.dwProductID,
		m_ProductID.dwFWMajVersion,
		m_ProductID.dwFWMinVersion);
	DebugOut(g_cMsg);
#endif
	// Set the device firmware version from GetID
	g_ForceFeedbackDevice.SetFirmwareVersion(dwDeviceID, m_ProductID.dwFWMajVersion, m_ProductID.dwFWMinVersion);

	// Get Device status prior to starting detection
	BOOL statusPacketFailed = (g_ForceFeedbackDevice.QueryStatus() != SUCCESS);
/*	if (statusPacketFailed == FALSE) {		--- GetID does not clear soft reset bit
		if (g_ForceFeedbackDevice.IsHardwareReset()) {	// Make sure HW Reset Detect bit is cleared after GetID
    		DebugOut("DetectMidiDevice: Error! Jolt ResetDetect bit not cleared after GetID\n");
			return (FALSE);
		}
	}
*/

	// See if Serial Dongle connected, otherwise must be MIDI device
    DebugOut("SW_WHEEL:Trying Auto HW Detection: MIDI Serial Port Device...\n");

	// Get Registry values, If high bit of COMMInterface is set, then force override (should add)
	DWORD commInterface;
	if (SUCCESS != joyGetForceFeedbackCOMMInterface(dwDeviceID, &commInterface, pCOMMPort)) {
		DebugOut("DetectMidiDevice: Registry key(s) missing! Bailing Out...\n");
		return (FALSE);
	}
#ifdef _DEBUG
	wsprintf(g_cMsg, "DetectMidiDevice: Registry.COMMInterface=%lx, Registry.COMMPort=%lx\n",
			commInterface, *pCOMMPort);
	DebugOut(g_cMsg);
#endif												

	ULONG regInterface = commInterface;

	// Delete any data transmitter (unless this is called multiple times - shouldn't happen)
	if (g_pDataTransmitter != NULL) {
		DebugOut("Unexpected multiple DetectMidiDevice() calls\r\n");
		delete g_pDataTransmitter;
		g_pDataTransmitter = NULL;
	}

	// Was a serial dongle detected, or did we fail to get status
	if (g_ForceFeedbackDevice.IsSerial() || statusPacketFailed) {	// Use serial (regardless what registry says!)
		DebugOut("DetectMidiDevice: Serial Port interface detected. Or Status Packet failed\n");

		// Set to backdoor serial method by default
		m_COMMInterface = COMM_SERIAL_BACKDOOR;

		// Should we try backdoor first (old firmware, or reg says so)
		if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)
		 || (regInterface & MASK_SERIAL_BACKDOOR)) {
			g_pDataTransmitter = new SerialBackdoorDataTransmitter;
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		// Backdoor not warrented or didn't work - front door
		if (g_pDataTransmitter == NULL) {
			g_pDataTransmitter = new SerialDataTransmitter();			
			m_COMMInterface = COMM_SERIAL_FILE;
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {	// Failed Front Door! (yech)
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		if ((statusPacketFailed == FALSE) || (g_pDataTransmitter != NULL)) {
			return (g_pDataTransmitter != NULL);
		}
	}	// End of Serial Port Auto HW selection

	// No Serial HW dongle detected, try midi-backdoor and WinMM
	DebugOut("Trying Midi (Serial No Go or No Dongle)\n");

	ULONG ulPort = *pCOMMPort;	// Set in the registry (assumed valid if override is set
	if ( !(regInterface & MASK_OVERRIDE_MIDI_PATH) ) {	// Use Automatic detection
		DebugOut("DetectMidiDevice: Auto Detection. Trying Backdoor\n");

		// Back Door
		g_pDataTransmitter = new MidiBackdoorDataTransmitter();

		if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
			delete g_pDataTransmitter;
			g_pDataTransmitter = NULL;
		}

		if (g_pDataTransmitter == NULL) {	// Try Front Door
			DebugOut("DetectMidiDevice: trying WINMM...\n");
			g_pDataTransmitter = new WinMMDataTransmitter();
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		return (g_pDataTransmitter != NULL);
	}

	// Over-ride since high bit is set
	commInterface &= ~(MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR);	// Mask out high bit (and second bit)
	switch (commInterface) {
		case COMM_WINMM: {
			g_pDataTransmitter = new WinMMDataTransmitter();
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			break;
		}
			
		case COMM_MIDI_BACKDOOR: {
			// Back Door
			g_pDataTransmitter = new MidiBackdoorDataTransmitter();
			if (!((MidiBackdoorDataTransmitter*)g_pDataTransmitter)->InitializeSpecific(dwDeviceID, HANDLE(ulPort))) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			break;
		}

		case COMM_SERIAL_BACKDOOR: {	// mlc - This will never work if no dongle detected
			DebugOut("Cannot force Serial Backdoor if no serial dongle is connected\r\n");
			break;
		}
	}

	if (g_pDataTransmitter == NULL) {
		DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values\n");
	}

	return (g_pDataTransmitter != NULL);
}

// *** ---------------------------------------------------------------------***
// Function:   	QueryForJolt
// Purpose:    	Sends Shutdown and Queries for Shutdown status bit
// Parameters: 	none
// Returns:    	BOOL TRUE if Jolt found, else FALSE
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::QueryForJolt(void)
{
	HRESULT hRet;

	// Sanity check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}

	// Send Shutdown command then detect if Shutdown was detected
	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		// Send a ShutDown, then check for response
		if (g_pDataPackager->SendForceFeedbackCommand(DISFFC_RESET) != SUCCESS) {
			ASSUME_NOT_REACHED();	// Could not package?
			return FALSE;
		}
		// Get rid of unneeded delay here
		DataPacket* packet = g_pDataPackager->GetPacket(0);
		if (packet != NULL) {
			packet->m_AckNackDelay = 0;
		}
		ACKNACK ackNack;
		
		if (g_pDataTransmitter->Transmit(ackNack) != SUCCESS)	{ // Send it off
			ASSUME_NOT_REACHED();	// Inable to transmit?
			return FALSE;
		}

		Sleep(DelayParamsPtrOf()->dwShutdownDelay);	// 10 ms

		hRet = g_ForceFeedbackDevice.QueryStatus();
		if (hRet == SUCCESS) {
			break;
		}
	}

	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);		

	// Clear the Previous state and turn on tri-state buffers
	LOCAL_PRODUCT_ID ProductID = {sizeof(LOCAL_PRODUCT_ID)};
	hRet = GetJoltID(&ProductID);
	if (hRet != SUCCESS) {
    	DebugOut("QueryForJolt: Driver Error. Get Jolt Status/ID\n");
		return (FALSE);
	}

	return g_ForceFeedbackDevice.IsHostReset();
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendShortMsg
// Purpose:    	Send status, channel and data.
// Parameters:
//				BYTE cStatus	-  MIDI status byte for this message
//				BYTE cData1		-  MIDI data byte for this message
//				BYTE cData2		-  2nd MIDI data byte for this message (may be 0)
// Returns:    	HRESULT
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendShortMsg(
    IN BYTE cStatus,
    IN BYTE cData1,
    IN BYTE cData2)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	g_CriticalSection.Enter();

	// For diagnostics, record the attempts at this message
	BumpShortMsgCounter();

    HRESULT retVal = SFERR_DRIVER_ERROR;
	if (g_pDataTransmitter != NULL) {
		BYTE data[3];
		data[0] = cStatus;
		data[1] = cData1;
		data[2] = cData2;
		int numBytes = 3;
		DWORD cmd = cStatus & 0xF0;
		if ((cmd == 0xC0 ) || (cmd == 0xD0)) {
			numBytes = 2;
		}
		if (g_pDataTransmitter->Send(data, numBytes)) {
			retVal = SUCCESS;
		}
	}

	g_CriticalSection.Leave();
	return retVal;
*/
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendLongMsg
// Purpose:    	Send system exclusive message or series of short messages.
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendLongMsg(void)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	g_CriticalSection.Enter();

// For diagnostics, record the attempts at this message
	BumpLongMsgCounter();

    HRESULT retVal = SFERR_DRIVER_ERROR;
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send((PBYTE)m_MidiOutInfo.MidiHdr.lpData, m_MidiOutInfo.MidiHdr.dwBufferLength)) {
			retVal = SUCCESS;
		}
	}

	::Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwLongMsgDelay);

	g_CriticalSection.Leave();
	return retVal;
*/
}

// ****************************************************************************
// *** --- Helper functions for CJoltMidi
//
// ****************************************************************************
//
#define REGSTR_VAL_FIRMWARE_PARAMS	"FirmwareParams"
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(FIRMWARE_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_FIRMWARE_PARAMS,
							  NULL, NULL,
							  (PBYTE)pFirmwareParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pFirmwareParams->dwScaleKx = DEF_SCALE_KX;
		pFirmwareParams->dwScaleKy = DEF_SCALE_KY;
		pFirmwareParams->dwScaleBx = DEF_SCALE_BX;
		pFirmwareParams->dwScaleBy = DEF_SCALE_BY;
		pFirmwareParams->dwScaleMx = DEF_SCALE_MX;
		pFirmwareParams->dwScaleMy = DEF_SCALE_MY;
		pFirmwareParams->dwScaleFx = DEF_SCALE_FX;
		pFirmwareParams->dwScaleFy = DEF_SCALE_FY;
		pFirmwareParams->dwScaleW  = DEF_SCALE_W;
	}
}

#define REGSTR_VAL_SYSTEM_PARAMS	"SystemParams"
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(SYSTEM_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_SYSTEM_PARAMS,
							  NULL, NULL,
							  (PBYTE)pSystemParams,
							  &dwcb);

		// scale them
		pSystemParams->RTCSpringParam.m_XKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_YKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_XAxisCenter /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YAxisCenter = -pSystemParams->RTCSpringParam.m_YAxisCenter/SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XDeadBand	/= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YDeadBand	/= SCALE_POSITION;



		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pSystemParams->RTCSpringParam.m_Bytes		= sizeof(RTCSPRING_PARAM);
		pSystemParams->RTCSpringParam.m_XKConstant	= DEFAULT_RTC_KX;
		pSystemParams->RTCSpringParam.m_YKConstant	= DEFAULT_RTC_KY;
		pSystemParams->RTCSpringParam.m_XAxisCenter = DEFAULT_RTC_X0;
		pSystemParams->RTCSpringParam.m_YAxisCenter = DEFAULT_RTC_Y0;
		pSystemParams->RTCSpringParam.m_XSaturation = DEFAULT_RTC_XSAT;
		pSystemParams->RTCSpringParam.m_YSaturation = DEFAULT_RTC_YSAT;
		pSystemParams->RTCSpringParam.m_XDeadBand	= DEFAULT_RTC_XDBAND;
		pSystemParams->RTCSpringParam.m_YDeadBand	= DEFAULT_RTC_YDBAND;
	}
}

#define REGSTR_VAL_DELAY_PARAMS	"TimingParams"
void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(DELAY_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_DELAY_PARAMS,
							  NULL, NULL,
							  (PBYTE)pDelayParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pDelayParams->dwBytes								= sizeof(DELAY_PARAMS);
		pDelayParams->dwDigitalOverdrivePrechargeCmdDelay	= DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY;
		pDelayParams->dwShutdownDelay						= DEFAULT_SHUTDOWN_DELAY;
		pDelayParams->dwHWResetDelay						= DEFAULT_HWRESET_DELAY;
		pDelayParams->dwPostSetDeviceStateDelay				= DEFAULT_POST_SET_DEVICE_STATE_DELAY;
		pDelayParams->dwGetEffectStatusDelay				= DEFAULT_GET_EFFECT_STATUS_DELAY;
		pDelayParams->dwGetDataPacketDelay					= DEFAULT_GET_DATA_PACKET_DELAY;
		pDelayParams->dwGetStatusPacketDelay				= DEFAULT_GET_STATUS_PACKET_DELAY;
		pDelayParams->dwGetIDPacketDelay					= DEFAULT_GET_ID_PACKET_DELAY;
		pDelayParams->dwGetStatusGateDataDelay				= DEFAULT_GET_STATUS_GATE_DATA_DELAY;
		pDelayParams->dwSetIndexDelay						= DEFAULT_SET_INDEX_DELAY;
		pDelayParams->dwModifyParamDelay					= DEFAULT_MODIFY_PARAM_DELAY;
		pDelayParams->dwForceOutDelay						= DEFAULT_FORCE_OUT_DELAY;
		pDelayParams->dwShortMsgDelay						= DEFAULT_SHORT_MSG_DELAY;
		pDelayParams->dwLongMsgDelay						= DEFAULT_LONG_MSG_DELAY;
		pDelayParams->dwDestroyEffectDelay					= DEFAULT_DESTROY_EFFECT_DELAY;
		pDelayParams->dwForceOutMod							= DEFAULT_FORCE_OUT_MOD;

		// write the defaults to the registry
		hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
		if(hKey)
		{
			// Modify Registry Values
			RegSetValueEx ( hKey, REGSTR_VAL_DELAY_PARAMS, 0, REG_BINARY, (const unsigned char *)pDelayParams, sizeof(DELAY_PARAMS) );

			// Close Key
			RegCloseKey(hKey);
		}

	}
	if(pDelayParams->dwForceOutMod == 0)
		pDelayParams->dwForceOutMod = 1;
}

//#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"

// ****************************************************************************
// *** --- Member functions for base class CMidiEffect
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(IN ULONG ulButtonPlayMask)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	Effect.bDurationL	= 1;				// in 2ms increments
	Effect.bDurationH	= 0;				// in 2ms increments
	Effect.bAngleL		= 0;				// 0 to 359 degrees
	Effect.bAngleH		= 0;
	Effect.bGain		= (BYTE) 100;		// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL= DEFAULT_JOLT_FORCE_RATE;	// 1 to 500 Hz
	Effect.bForceOutRateH=0;
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default
}


// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_OpCode    		= DNLOAD_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:DNLOAD_DATA
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	SetDuration(pEffect->m_Duration);
	Effect.bDurationL	= (BYTE)  (m_Duration & 0x7f);					// in 2ms increments
	Effect.bDurationH	= (BYTE) ((m_Duration >> 7 ) & 0x7f);			// in 2ms increments
	Effect.bAngleL		= (BYTE)  (pEffect->m_DirectionAngle2D & 0x7f);	// 0 to 359 degrees
	Effect.bAngleH		= (BYTE) ((pEffect->m_DirectionAngle2D >> 7 ) & 0x7f);
	Effect.bGain		= (BYTE)  (pEffect->m_Gain & 0x7f);				// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE)  (pEffect->m_ButtonPlayMask & 0x7f);
	Effect.bButtonPlayH = (BYTE) ((pEffect->m_ButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL=(BYTE)  (pEffect->m_ForceOutputRate & 0x7f);	// 1 to 500 Hz
	Effect.bForceOutRateH=(BYTE) ((pEffect->m_ForceOutputRate >> 7 ) & 0x03);
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default

	// Set Envelope members
	if (pEnvelope)
	{
		m_Envelope.m_Type = pEnvelope->m_Type;
		m_Envelope.m_Attack = pEnvelope->m_Attack;
		m_Envelope.m_Sustain = pEnvelope->m_Sustain;
		m_Envelope.m_Decay = pEnvelope->m_Decay;
		m_Envelope.m_StartAmp = (ULONG) (pEnvelope->m_StartAmp);
		m_Envelope.m_SustainAmp = (ULONG) (pEnvelope->m_SustainAmp);
		m_Envelope.m_EndAmp = (ULONG) (pEnvelope->m_EndAmp);
	}

	// save the original effect params
	m_OriginalEffectParam = *pEffect;
}

// --- Destructor
CMidiEffect::~CMidiEffect()
{
	memset(this, 0, sizeof(CMidiEffect));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetDuration
// Purpose:		Sets the Duration member
// Parameters:	ULONG ulArg	- the duration
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetDuration(ULONG ulArg)
{
	if (ulArg != 0)
	{
		ulArg = (ULONG) ( (float) ulArg/TICKRATE);
		if (ulArg <= 0) ulArg = 1;
	}
	m_Duration = ulArg;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetTotalDuration
// Purpose:		Modifies the Effect.bDurationL/H parameter for Loop Counts
// Parameters:	none
//
// Returns:		Effect.bDurationL/H is filled with total duration
// Algorithm:
//	Notes: Percentage is 1 to 10000
//	Total Duration = ((Percentage of waveform)/10000) * Duration * Loop Count
//	Example: Loop count of 1, the Percentage of waveform =10000,
//			 Total Duration = (10000/10000) * 1 * Duration
//
// ----------------------------------------------------------------------------
void CMidiEffect::SetTotalDuration(void)
{
	ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);
	ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
	Effect.bDurationL = (BYTE) ulTotalDuration & 0x7f;
	Effect.bDurationH = (BYTE) (ulTotalDuration >> 7) & 0x7f;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeEnvelope
// Purpose:		Computes the Envelope for the Effect, Loopcount in consideration
// Parameters:	none
// Returns:		none
// Algorithm:
//For our standard PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline
// m_EndAmp = m_StartAmp;
// where: baseline = (Effect.m_MaxAmp + Effect.m_MinAmp)/2;
// ----------------------------------------------------------------------------
void CMidiEffect::ComputeEnvelope(void)
{
	ULONG ulTimeToSustain;
	ULONG ulTimeToDecay;

	//REVIEW: TIME vs PERCENTAGE option
	if (PERCENTAGE == m_Envelope.m_Type)
	{
		ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);		
		ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
		ulTimeToSustain = (ULONG) ((m_Envelope.m_Attack * ulTotalDuration) /100.);
		ulTimeToDecay   = (ULONG) ((m_Envelope.m_Attack + m_Envelope.m_Sustain)
								 * ulTotalDuration /100.);
	}
	else	// TIME option envelope
	{
		ulTimeToSustain = (ULONG) (m_Envelope.m_Attack);
		ulTimeToDecay   = (ULONG) (m_Envelope.m_Attack + m_Envelope.m_Sustain);
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

	}
		Envelope.bAttackLevel  = (BYTE) (m_Envelope.m_StartAmp & 0x7f);
		Envelope.bSustainLevel = (BYTE) (m_Envelope.m_SustainAmp & 0x7f);
		Envelope.bDecayLevel   = (BYTE) (m_Envelope.m_EndAmp & 0x7f);

		Envelope.bSustainL = (BYTE) (ulTimeToSustain & 0x7f);
		Envelope.bSustainH = (BYTE) ((ulTimeToSustain >> 7) & 0x7f);
		Envelope.bDecayL   = (BYTE) (ulTimeToDecay & 0x7f);
		Envelope.bDecayH   = (BYTE) ((ulTimeToDecay >> 7) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Returns the SubType for the Effect
// Parameters:	none
// Returns:		ULONG - DirectEffect style SubType
// Algorithm:
// ----------------------------------------------------------------------------
ULONG CMidiEffect::SubTypeOf(void)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (m_SubType == EffectTypes[i].bDeviceSubType)
			return EffectTypes[i].ulHostSubType;
	}
	return (NULL);		
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Sets the SubType for the Effect
// Parameters:	ULONG - DirectEffect style SubType
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetSubType(ULONG ulSubType)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (ulSubType == EffectTypes[i].ulHostSubType)
		{
			m_SubType = EffectTypes[i].bDeviceSubType;
			return;
		}
	}
	m_SubType = NULL;	
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeChecksum
// Purpose:		Computes current checksum in the m_pBuffer
// Parameters:	none
// Returns:		Midi packet block is checksummed
// Algorithm:
// ----------------------------------------------------------------------------
BYTE CMidiEffect::ComputeChecksum(PBYTE pBuffer, int nBufferSize)
{
	assert(pBuffer);
	int nStart = sizeof(SYS_EX_HDR);
	PBYTE pBytePacket = pBuffer;
	pBytePacket += nStart;
	BYTE nSum = 0;
	// Checksum only the bytes in the "Body" and s/b 7 bit checksum.
	for (int i=nStart;i < (nBufferSize-2);i++)
	{
		nSum += *pBytePacket;
		pBytePacket++;
	}
	return ((-nSum) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SendPacket
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::SendPacket(PDNHANDLE pDnloadID, int nPacketSize)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::DestroyEffect
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::DestroyEffect()
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiBehavioral
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::CMidiBehavioral
// Purpose:		Constructor(s)/Destructor for CMidiBehavioral Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiBehavioral::CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope,
				PBE_XXX pBE_XXX):CMidiEffect(pEffect, NULL)
{
	SetSubType(pEffect->m_SubType);
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
	m_MidiBufferSize = sizeof(BEHAVIORAL_SYS_EX);
}

// --- Destructor
CMidiBehavioral::~CMidiBehavioral()
{
	memset(this, 0, sizeof(CMidiBehavioral));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiBehavioral::SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for BE_XXX
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiBehavioral::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PBEHAVIORAL_SYS_EX pBuf = (PBEHAVIORAL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Behavioral params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXConstantL  	= (BYTE)  XConstant & 0x7f;
	pBuf->bXConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYConstantL  	= (BYTE)  YConstant & 0x7f;
	pBuf->bYConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;

	LONG Param3 		= (LONG) (Param3Of()  * MAX_SCALE);
	LONG Param4 		= (LONG) (Param4Of()  * MAX_SCALE);
	pBuf->bParam3L  	= (BYTE)  Param3 & 0x7f;
	pBuf->bParam3H 		= (BYTE) (Param3 >> 7 ) & 0x01;
	pBuf->bParam4L  	= (BYTE)  Param4 & 0x7f;
	pBuf->bParam4H 		= (BYTE) (Param4 >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;

	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(BEHAVIORAL_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiFriction
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::CMidiFriction
// Purpose:		Constructor(s)/Destructor for CMidiFriction Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiFriction::CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(FRICTION_SYS_EX);
}

// --- Destructor
CMidiFriction::~CMidiFriction()
{
	memset(this, 0, sizeof(CMidiFriction));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiFriction::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PFRICTION_SYS_EX pBuf = (PFRICTION_SYS_EX) pSysExBuffer;

	SetTotalDuration();	// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_FRICTION params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXFConstantL  = (BYTE)  XConstant & 0x7f;
	pBuf->bXFConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYFConstantL  = (BYTE)  YConstant & 0x7f;
	pBuf->bYFConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;
	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(FRICTION_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiWall
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::CMidiWall
// Purpose:		Constructor(s)/Destructor for CMidiWall Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiWall::CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(WALL_SYS_EX);
}

// --- Destructor
CMidiWall::~CMidiWall()
{
	memset(this, 0, sizeof(CMidiWall));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiWall::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PWALL_SYS_EX pBuf = (PWALL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL		= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH		= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_WALL params
	LONG WallType 			= (LONG) (XConstantOf());
	LONG WallConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	LONG WallAngle			= (LONG)  Param3Of();
	LONG WallDistance		= (LONG) (Param4Of() * MAX_SCALE);

	pBuf->bWallType  		= (BYTE) (WallType & 0x01);
	pBuf->bWallConstantL  	= (BYTE) (WallConstant & 0x7f);
	pBuf->bWallConstantH	= (BYTE) ((WallConstant >> 7 ) & 0x01); //+/-100
	pBuf->bWallAngleL  		= (BYTE) (WallAngle & 0x7f);			// 0 to 359
	pBuf->bWallAngleH	 	= (BYTE) ((WallAngle >> 7 ) & 0x03);
	pBuf->bWallDistance		= (BYTE) (WallDistance & 0x7f);
	pBuf->bEffectID 		=  m_bEffectID;

	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
	  									sizeof(WALL_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiRTCSpring
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::CMidiRTCSpring
// Purpose:		Constructor(s)/Destructor for CMidiRTCSpring Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiRTCSpring::CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring):CMidiEffect(NULL)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// --- Destructor
CMidiRTCSpring::~CMidiRTCSpring()
{
	memset(this, 0, sizeof(CMidiRTCSpring));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::SetEffectParams
// Purpose:		Sets parameters
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiRTCSpring::SetEffectParams(PRTCSPRING_PARAM pRTCSpring)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::GenerateSysExPacket
// Purpose:		virtual
// Parameters:	none
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiRTCSpring::GenerateSysExPacket(void)
{
	return (NULL);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiDelay
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::CMidiDelay
// Purpose:		Constructor(s)/Destructor for CMidiDelay Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiDelay::CMidiDelay(PEFFECT pEffect) : CMidiEffect(pEffect, NULL)
{
	m_SubType   = ET_BE_DELAY;		// BE Effect Type: BE_DELAY
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS | PLAY_SUPERIMPOSE;
	m_MidiBufferSize = sizeof(NOP_SYS_EX);
}

// --- Destructor
CMidiDelay::~CMidiDelay()
{
	memset(this, 0, sizeof(CMidiDelay));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiDelay::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PNOP_SYS_EX pBuf = (PNOP_SYS_EX) pSysExBuffer;

	pBuf->bEffectID		=  m_bEffectID;
	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bChecksum		= ComputeChecksum((PBYTE) pSysExBuffer,
					 				sizeof(NOP_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiSynthesized
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::CMidiSynthesized
// Purpose:		Constructor(s)/Destructor for CMidiSynthesized Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiSynthesized::CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope,
						PSE_PARAM pParam ) : CMidiEffect(pEffect, pEnvelope)
{
	SetSubType(pEffect->m_SubType);				// SE Effect Type
//	Effect.bForceOutRateL= (BYTE) pParam->m_SampleRate & 0x7f;	// 1 to 500 Hz
//	Effect.bForceOutRateH= (BYTE) ((pParam->m_SampleRate >> 7) & 0x3);
	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);

	m_Freq		= pParam->m_Freq;				// Frequency
	m_MaxAmp	= pParam->m_MaxAmp;				// Maximum Amplitude
	// Special case a SE_CONSTANT_FORCE
	if (SE_CONSTANT_FORCE == pEffect->m_SubType)
		m_MinAmp = 0;
	else
		m_MinAmp = pParam->m_MinAmp;			// Minimum Amplitude

	m_MidiBufferSize = sizeof(SE_WAVEFORM_SYS_EX);
}

// --- Destructor
CMidiSynthesized::~CMidiSynthesized()
{
	memset(this, 0, sizeof(CMidiSynthesized));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiSynthesized::SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam,
									   ULONG ulAction)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	//Set the loop count from HIWORD of ulAction
	m_LoopCount = (ulAction >> 16) & 0xffff;
	if (0 == m_LoopCount) m_LoopCount++;

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for SE_xxx
	m_Freq	 = pParam->m_Freq;
	m_MaxAmp = pParam->m_MaxAmp;
	m_MinAmp = pParam->m_MinAmp;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiSynthesized::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);

	// Compute total with Loop count parameter, Note: Envelope parameters are
	// adjusted according to the Loop Count parameter, if affected.
	SetTotalDuration();
	ComputeEnvelope();

	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID + MIDI_EFFECT
	//			+ MIDI_ENVELOPE
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR)+3+sizeof(MIDI_EFFECT)+
				sizeof(MIDI_ENVELOPE)) );

	PSE_WAVEFORM_SYS_EX pBuf = (PSE_WAVEFORM_SYS_EX) pSysExBuffer;
	
	// Scale the gain, and Envelope amplitudes
	pBuf->Effect.bGain = (BYTE) (pBuf->Effect.bGain * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bAttackLevel  = (BYTE) (pBuf->Envelope.bAttackLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bSustainLevel = (BYTE) (pBuf->Envelope.bSustainLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bDecayLevel   = (BYTE) (pBuf->Envelope.bDecayLevel * MAX_SCALE) & 0x7f;

	// Copy the SE specific parameters
	LONG MaxAmp = (LONG) (m_MaxAmp * MAX_SCALE);
	LONG MinAmp = (LONG) (m_MinAmp * MAX_SCALE);
	pBuf->bFreqL   	= (BYTE)  (m_Freq & 0x7f);
	pBuf->bFreqH   	= (BYTE) ((m_Freq >> 7 ) & 0x03); 	// 1 to 500
	pBuf->bMaxAmpL 	= (BYTE)  (MaxAmp & 0x7f);
	pBuf->bMaxAmpH 	= (BYTE) ((MaxAmp >> 7 ) &0x01); 	// +127 to -128

	pBuf->bMinAmpL 	= (BYTE)  (MinAmp & 0x7f);
	pBuf->bMinAmpH 	= (BYTE) ((MinAmp >> 7 ) & 0x01);

	pBuf->bChecksum	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(SE_WAVEFORM_SYS_EX));
	pBuf->bEOX	   	= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CUD_Waveform
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CUD_Waveform::CUD_Waveform
// Purpose:		Constructor(s)/Destructor for CUD_Waveform Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiUD_Waveform::CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray) : CMidiEffect(pEffect, NULL),
	m_pRawData(NULL)
{
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS;// Sub-command opcode: DNLOAD_DATA
	m_SubType   = ET_UD_WAVEFORM;	// Effect Type: UD_WAVEFORM

	assert(pArray);
	// Create the buffer to hold the waveform data, compress it,
	// then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	// Set a fixed maximum size
	DWORD nSize = MAX_MIDI_WAVEFORM_DATA_SIZE + 2;
	m_pArrayData = new BYTE[nSize];
//	m_pRawData = new BYTE [nSize*2];
	assert(m_pArrayData);

	ULONG NewForceRate;
	m_MidiBufferSize = SetTypeParams(ulNumVectors, pArray, &NewForceRate);

	// Copy structures to object
	memcpy(&m_Effect.m_Bytes, pEffect, sizeof(EFFECT));
	SetForceOutRate(NewForceRate);
	m_Effect.m_Gain = m_Effect.m_Gain & 0x7f;
	m_Effect.m_Duration = (ULONG) ((float) (m_Effect.m_Duration / TICKRATE));
	m_Duration = m_Effect.m_Duration;
}

// --- Destructor
CMidiUD_Waveform::~CMidiUD_Waveform()
{
	if (m_pArrayData) delete [] m_pArrayData;
	memset(this, 0, sizeof(CMidiUD_Waveform));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetEffectParams
// Purpose:		Sets the Effect specific parameters
// Parameters:	PEFFECT pEffect
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiUD_Waveform::SetEffectParams(PEFFECT pEffect)
{	
	// Set the MIDI_EFFECT parameters
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);	
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetTypeParams
// Purpose:		Sets the type specific parameters
// Parameters:	int nSize		- size of the array
//				PLONG pArray - Pointer to an ARRAY of force values
//				
// Returns:		MidiBuffer size for the packet
// Algorithm:
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate)
{	
	// Compress the buffer data then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	m_pRawData = new BYTE [nSize*2];
	if (m_pRawData == NULL)
	{
		return 0;
	}

	// Convert to -128 to +127
	for (int i=0; i<nSize; i++)
	{
		m_pRawData[i] = (BYTE) ((LONG) (pArray[i] * MAX_SCALE));		
	}

	m_NumberOfVectors = CompressWaveform(&m_pRawData[0], m_pArrayData, nSize, pNewRate);
	assert(m_NumberOfVectors <= (MAX_MIDI_WAVEFORM_DATA_SIZE));
	if (m_pRawData)
	{
		delete [] m_pRawData;
		m_pRawData = 0;
	}
	if (0 == m_NumberOfVectors)		// No room!
		return (0);
	m_MidiBufferSize = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX) + 2);
	return (m_MidiBufferSize);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::CompressWaveform
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	PBYTE pSrcArray		- Source Array pointer
//				PBYTE pDestArray 	- Dest. Array Pointer
//				int nSize			- Size in Bytes of the Source Array
//
// Returns:		int 	- Size of the compressed Array (in bytes)
// Algorithm:
// To "compress" we need to fit the entire waveform into 98 points (there is a
// FW bug that limits us to 100 points only, and we need at least two samples
// for the starting Absolute mode point.
// 1.  Determine how many points over 98.
//     nSrcSize:    Total sample size
//     nMaxSamples: Maximum samples to squeeze into = 98
//	   nOver:		nSrcSize - nMaxSamples
//	   nSkipSample:	# of points to keep before skipping one
//					= nSrcSize/nOver
//	   while ( Sample is less than nSrcSize, bump index)
//	   {
//		  if ( (index % nSkipSample) == 0)	// no remainder
//		  {
//			index++							// bump to skip the next sample
//		  }
//		  Compress the data
//	   }
//
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::CompressWaveform(
	IN PBYTE pSrcArray,
	IN OUT PBYTE pDestArray,
	IN int nSrcSize,
	OUT ULONG *pNewForceRate)
{
	assert(pSrcArray && pDestArray);
	LONG nDifference;

	// 8 bits (-128 to +127) Starting Absolute Data Value
	pDestArray[0] = pSrcArray[0] & 0x3f;
	pDestArray[1] = (pSrcArray[0] >> 6) & 0x03;

//	int nMaxSamples = MAX_MIDI_WAVEFORM_DATA_SIZE;

	int nSkipSample, nSrcIndex, nDestIndex;
	int nAbsolute = 0;
	int nRelative = 0;
	//
	// Start with Finest Resolution, then reduce until # of Samples <= nMaxSamples
	//
	nSkipSample = nSrcSize;
	while (TRUE)
	{
		nSrcIndex = 0;				// 1st sample already accounted for
		nDestIndex = 2;
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"nSkipSample=%d\n",nSkipSample);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		while (nSrcIndex < nSrcSize)
		{
			nSrcIndex++;
			if (0 == (nSrcIndex % nSkipSample))
			{
				nSrcIndex++;			// Skip next one
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-2]);
			}
			else
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-1]);

			// make sure we do not write outside of array bounds
			if(nDestIndex > MAX_MIDI_WAVEFORM_DATA_SIZE) break;

			if (abs(nDifference) < DIFFERENCE_THRESHOLD)
			{
				pDestArray[nDestIndex] = (BYTE)((nDifference & 0x3f) | DIFFERENCE_BIT);
				nDestIndex++;
				nRelative++;
			}
			else	// Switch to Absolute Data (8 bits)
			{
				pDestArray[nDestIndex] 	 = pSrcArray[nSrcIndex] & 0x3f;
				pDestArray[nDestIndex+1] = (pSrcArray[nSrcIndex] >> 6) & 0x3;
				nDestIndex = nDestIndex+2;
				nAbsolute++;
			}
		}
		if (nDestIndex <= MAX_MIDI_WAVEFORM_DATA_SIZE) break;
		// Reduce the resolution
		if (nSkipSample < 8)
			nSkipSample--;
		else
			nSkipSample = nSkipSample/2;
		if (1 == nSkipSample) return (0);	// Sorry charlie, no room!
		nAbsolute = 0;
		nRelative = 0;
	}

	// Done
	ULONG ulOriginalForceRate = ForceOutRateOf();
//	*pNewForceRate = (ulOriginalForceRate - (ULONG) (ulOriginalForceRate * ((float) nSkipSample / (float) nSrcSize)))/nSkipSample;
	*pNewForceRate = (ULONG) ((1.0f - (1.0f/nSkipSample)) * ulOriginalForceRate);


#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "CompressWaveform: nSrcSize=%d, nSkipSample=%d, NewForceRate=%d\n",
			nSrcSize, nSkipSample, *pNewForceRate);
	DebugOut(g_cMsg);
	wsprintf(g_cMsg,"\nTotal Absolute Data:%d, Relative Data:%d", nAbsolute, nRelative);
	DebugOut(g_cMsg);
	g_CriticalSection.Leave();
#endif


#ifdef _SHOWCOMPRESS
#pragma message("Compiling with SHOWCOMPRESS")
	g_CriticalSection.Enter();
	DebugOut("CMidiUD_Waveform::CompressWaveform(..) \npSrcArray Dump (Decimal)\n");
	for (int i=0; i<nSrcSize; i++)
	{
		wsprintf(g_cMsg," %0.4ld",((char) pSrcArray[i]));
		DebugOut(g_cMsg);
	}
	DebugOut("\npDestArray Dump (HEX)\n");

	for (i=0; i<nDestIndex; i++)
	{
		wsprintf(g_cMsg," %0.4x",pDestArray[i]);
		DebugOut(g_cMsg);
	}
	g_CriticalSection.Leave();
#endif
	return (nDestIndex);
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiUD_Waveform::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PUD_WAVEFORM_SYS_EX pBuf = (PUD_WAVEFORM_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->Effect.bDurationL     = (BYTE) (m_Duration & 0x7f);
	pBuf->Effect.bDurationH     = (BYTE) (m_Duration >> 7) & 0x7f;		
	pBuf->Effect.bAngleL	    =  Effect.bAngleL & 0x7f;	
	pBuf->Effect.bAngleH	    =  Effect.bAngleH & 0x7f;			
	pBuf->Effect.bGain		    = (BYTE) (Effect.bGain * MAX_SCALE) & 0x7f;	
	pBuf->Effect.bButtonPlayL   =  Effect.bButtonPlayL  & 0x7f;		
	pBuf->Effect.bButtonPlayH   =  Effect.bButtonPlayH  & 0x7f;	
	pBuf->Effect.bForceOutRateL =  Effect.bForceOutRateL & 0x7f;		
	pBuf->Effect.bForceOutRateH =  Effect.bForceOutRateH & 0x7f;
	pBuf->Effect.bPercentL	    =  Effect.bPercentL & 0x7f;
	pBuf->Effect.bPercentH	    =  Effect.bPercentH & 0x7f;

	// Fill in the Array Data
	PBYTE pArray = ((PBYTE) pBuf) + UD_WAVEFORM_START_OFFSET;
	memcpy(pArray, m_pArrayData, m_NumberOfVectors);	// Already scaled!

	pBuf->bEffectID	=  m_bEffectID;
	int nArraySize  = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX));
	pSysExBuffer[nArraySize] = 0;
	pSysExBuffer[nArraySize+1] = 0;
	pSysExBuffer[nArraySize] = ComputeChecksum((PBYTE) pSysExBuffer, (nArraySize+2));
	pSysExBuffer[nArraySize+1]= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\joyregst.cpp ===
/****************************************************************************

    MODULE:     	joyregst.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for VJOYD Registry entries
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	0.1			20-Jun-96	MEA     original
				21-Mar-99	waltw	Removed unreferenced joyGetOEMProductName,
									joyGetOEMForceFeedbackDriverDLLName,
									GetRing0DriverName

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <stdio.h>
#include <TCHAR.h>
#include "joyregst.hpp"
#include "sw_error.hpp"
#include "Registry.h"
#include "FFDevice.h"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//#define ACKNACK_1_16_DEFAULT 0x0000949A
#define ACKNACK_1_16_DEFAULT 0x0000955A
#define ACKNACK_1_20_DEFAULT 0x0000955A
#define ACKNACK_2_00_DEFAULT 0x0000955A

// Default RTC Spring values
#define RTC_DEF_OFFSET 0
#define RTC_DEF_POS_K 10000
#define RTC_DEF_NEG_K 10000
#define RTC_DEF_POS_SAT 10000
#define RTC_DEF_NEG_SAT 10000
#define RTC_DEF_DEADBAND 0



MMRESULT joyGetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN OUT ULONG *pCOMMInterface,
			IN OUT ULONG *pCOMMPort)
{

	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	DWORD dataSize = sizeof(DWORD);
	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.QueryValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(pCOMMInterface), dataSize);
	MMRESULT lr = oemFFKey.QueryValue(REGSTR_VAL_COMM_PORT, (BYTE*)(pCOMMPort), dataSize);

	return lr;
}

MMRESULT joySetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN ULONG ulCOMMInterface,
			IN ULONG ulCOMMPort)
{
	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.SetValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(&ulCOMMInterface), sizeof(DWORD), REG_DWORD);
	MMRESULT lr = oemFFKey.SetValue(REGSTR_VAL_COMM_PORT, (BYTE*)(&ulCOMMPort), sizeof(DWORD), REG_DWORD);

	return lr;
}


HKEY joyOpenOEMForceFeedbackKey(UINT id)
{
	JOYCAPS JoyCaps;
	TCHAR szKey[256];
	TCHAR szValue[256];
	UCHAR szOEMKey[256];

	HKEY hKey;
	DWORD dwcb;
	LONG lr;

// Note: JOYSTICKID1-16 is zero-based, Registry entries for VJOYD is 1-based.
	id++;		
	if (id > joyGetNumDevs() ) return 0;

// open .. MediaResources\CurentJoystickSettings
	joyGetDevCaps((id-1), &JoyCaps, sizeof(JoyCaps));
//
#ifdef _NOJOY
	strcpy(JoyCaps.szRegKey,"msjstick.drv<0004>");
#endif
//
//
	sprintf(szKey,
			"%s\\%s\\%s",
			REGSTR_PATH_JOYCONFIG,
			JoyCaps.szRegKey,
			REGSTR_KEY_JOYCURR);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) return 0;

// Get OEM Key name
	dwcb = sizeof(szOEMKey);
 	sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
	lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &szOEMKey, (LPDWORD) &dwcb);
	RegCloseKey(hKey);
	if (lr != ERROR_SUCCESS) return 0;

// open OEM\name\OEMForceFeedback	from ...MediaProperties
	sprintf(szKey, "%s\\%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey, 
			REGSTR_OEMFORCEFEEDBACK);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) 
		return 0;
	else
		return hKey;
}


/******************************************************
**
** GetRTCSpringData(UINT id, DICONDITION diCondition[2])
**
** @funct GetRTCSpringData.
**
******************************************************/
MMRESULT GetRTCSpringData(UINT id, DICONDITION diCondition[2])
{
	::memset(diCondition, 0, sizeof(DICONDITION) * 2);

	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}
	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD diCondSize = sizeof(DICONDITION);
	HRESULT queryResult = ffRegKey.QueryValue(REGSTR_VAL_RTCSPRING_X, (BYTE*)diCondition, diCondSize);
	if (queryResult != ERROR_SUCCESS) {			// Must at least have RTC-X
		diCondition[0].lOffset = RTC_DEF_OFFSET;
		diCondition[0].lPositiveCoefficient = RTC_DEF_POS_K;
		diCondition[0].lNegativeCoefficient = RTC_DEF_NEG_K;
		diCondition[0].dwPositiveSaturation = RTC_DEF_POS_SAT;
		diCondition[0].dwNegativeSaturation = RTC_DEF_NEG_SAT;
		diCondition[0].lDeadBand = RTC_DEF_DEADBAND;
		ffRegKey.SetValue(REGSTR_VAL_RTCSPRING_X, (BYTE*)diCondition, sizeof(DICONDITION), REG_BINARY);
	}
	diCondSize = sizeof(DICONDITION);
	ffRegKey.QueryValue(REGSTR_VAL_RTCSPRING_Y, (BYTE*)(diCondition+1), diCondSize);
	// If there is no Y, then there is no Y, live with it (zep doesn't need y)

	return ERROR_SUCCESS;
}

/******************************************************
**
** GetMapping(UINT id)
**
** @funct GetMapping.
**
******************************************************/
DWORD GetMapping(UINT id)
{
	DWORD retVal = 0;
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return retVal;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD dataSize = DWORD(sizeof(DWORD));
	if (ffRegKey.QueryValue(REGSTR_VAL_MAPPING, (BYTE*)&retVal, dataSize) != ERROR_SUCCESS) {
		retVal = 0;
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() > 1) {	// Don't add key for old devices
			ffRegKey.SetValue(REGSTR_VAL_MAPPING, (BYTE*)&retVal, sizeof(DWORD), REG_DWORD);
		}
	}
	return retVal;
}

/******************************************************
**
** GetMappingPercents(UINT id, short mapPercents[], UINT numPercents)
**
** @funct GetMappingPercents.
**
******************************************************/
MMRESULT GetMappingPercents(UINT id, short mapPercents[], UINT numPercents)
{
	DWORD retVal = 0;
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return retVal;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD dataSize = DWORD(sizeof(short) * numPercents);
	return ffRegKey.QueryValue(REGSTR_VAL_MAPPERCENTS, (BYTE*)mapPercents, dataSize);
}

/******************************************************
**
** GetAckNackMethodFromRegistry(UINT id)
**
** @mfunct GetAckNackMethodFromRegistry.
**
******************************************************/
DWORD GetAckNackMethodFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD ackNackInfo = 0;
	TCHAR firmwareString[32] = "";
	::wsprintf(firmwareString, TEXT("%d.%d-AckNack"), g_ForceFeedbackDevice.GetFirmwareVersionMajor(), g_ForceFeedbackDevice.GetFirmwareVersionMinor());
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(firmwareString, (BYTE*)&ackNackInfo, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
			if (g_ForceFeedbackDevice.GetFirmwareVersionMinor() < 20) {
				ackNackInfo = ACKNACK_1_16_DEFAULT;
			} else {	// 1.20 and greater
				ackNackInfo = ACKNACK_1_20_DEFAULT;
			}
		} else {	// Firmware greater than 1.0
			ackNackInfo = ACKNACK_2_00_DEFAULT;	// Use the latest I know of
		}
		ffRegKey.SetValue(firmwareString, (BYTE*)&ackNackInfo, sizeof(DWORD), REG_DWORD);
	}

	return ackNackInfo;
}

/******************************************************
**
** GetSpringOffsetFromRegistry(UINT id)
**
** @mfunct GetSpringOffsetFromRegistry.
**
******************************************************/
DWORD GetSpringOffsetFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD offset = 2500;
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(REGSTR_VAL_SPRING_OFFSET, (BYTE*)&offset, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		offset = 2500;
		ffRegKey.SetValue(REGSTR_VAL_SPRING_OFFSET, (BYTE*)&offset, sizeof(DWORD), REG_DWORD);
	}

	return offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\joyregst.hpp ===
/****************************************************************************

    MODULE:     	joyregst.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for VJOYD Registry functions
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original
			21-Mar-99		waltw	Removed unreferenced joyGetOEMProductName,
									joyGetOEMForceFeedbackDriverDLLName,
									GetRing0DriverName

****************************************************************************/
#ifndef joyregst_SEEN
#define joyregst_SEEN

#include <dinput.h>

#define REGSTR_OEMFORCEFEEDBACK 		        "OEMForceFeedback"
#define REGSTR_VAL_SFORCE_DRIVERDLL		        "Driver DLL"
#define REGSTR_VAL_SFORCE_PRODUCTNAME		    "ProductName"
#define REGSTR_VAL_SFORCE_MANUFACTURERNAME	    "Manufacturer"
#define REGSTR_VAL_SFORCE_PRODUCTVERSION	    "ProductVersion"
#define REGSTR_VAL_SFORCE_DEVICEDRIVERVERSION	"DeviceDriverVersion"
#define REGSTR_VAL_SFORCE_DEVICEFIRMWAREVERSION "DeviceFirmwareVersion"
#define REGSTR_VAL_SFORCE_INTERFACE		        "Interface"
#define REGSTR_VAL_SFORCE_MAXSAMPLERATE	        "MaxSampleRate"
#define REGSTR_VAL_SFORCE_MAXMEMORY		        "MaxMemory"
#define REGSTR_VAL_SFORCE_NUMBEROFSENSORS       "NumberOfSensors"
#define REGSTR_VAL_SFORCE_NUMBEROFAXES          "NumberOfAxes"
#define REGSTR_VAL_SFORCE_EFFECTSCAPS		    "EffectsCaps"
#define REGSTR_VAL_SFORCE_EXTRAINFO		        "ExtraInfo"
#define REGSTR_VAL_COMM_INTERFACE		        "COMMInterface"
#define REGSTR_VAL_COMM_PORT		        	"COMMPort"
#define REGSTR_VAL_RING0_DRIVER					"RING0 Driver"
#define REGSTR_VAL_RTCSPRING_X					"RTCSpringX"
#define REGSTR_VAL_RTCSPRING_Y					"RTCSpringY"
#define REGSTR_VAL_MAPPING						"Mapping"
#define REGSTR_VAL_MAPPERCENTS					"Mapping Percents"
#define REGSTR_VAL_SPRING_OFFSET				"Spring Offset"

HKEY		joyOpenOEMForceFeedbackKey(UINT id);
MMRESULT	joyGetForceFeedbackCOMMInterface(UINT id, ULONG* ulArg1, ULONG* ulArg2);
MMRESULT	joySetForceFeedbackCOMMInterface(UINT id, ULONG ulCOMMInterface, ULONG ulCOMMPort);
MMRESULT	GetRTCSpringData(UINT id, DICONDITION diCondition[2]);
DWORD		GetMapping(UINT id);
UINT		GetMappingPercents(UINT id, short mapPercents[], UINT numPercents);
DWORD		GetAckNackMethodFromRegistry(UINT id);
DWORD		GetSpringOffsetFromRegistry(UINT id);


#define REGBITS_DESTROYEFFECT	14
#define REGBITS_PLAYEFFECT		12
#define REGBITS_STOPEFFECT		10
#define REGBITS_SETINDEX		8
#define REGBITS_MODIFYPARAM		6
#define REGBITS_SETDEVICESTATE	4
#define REGBITS_DOWNLOADEFFECT	2
#define REGBITS_DEVICEINIT		0

#define ACKNACK_NOTHING			0x00
#define ACKNACK_BUTTONSTATUS	0x01
#define ACKNACK_STATUSPACKET	0x02

#endif // of if joyregst_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\hau_midi.cpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for Jolt Midi device command Protocol
    
    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			02-Apr-96	MEA   	Original
				19-Sep-96	MEA		Removed ES1.0 specific code
				05-Dec-96	MEA		Removed ALLACK debug switch
	1.1			17-Mar-97	MEA		DX-FF mode
				14-Apr-97	MEA		Added support for RTC spring
				21-Mar-99	waltw	Removed unreferenced ModifyEnvelopeParams,
									ModifyEffectParams, MapEnvelope, CMD_ModifyParamByIndex,
									CMD_Download_RTCSpring

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "midi_obj.hpp"
#include "dx_map.hpp"
#include "sw_objec.hpp"
#include "ffd_swff.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/

/****************************************************************************

   Declaration of variables

****************************************************************************/
//
// Globals specific to hau_midi
//
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//
// --- EFFECT_CMDs
//

// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetIndex
// Purpose:    	Sets the autoincrementing Index for MODIFY_CMD
// Parameters: 
//				IN int nIndex			- Index value 0 - 15
//				IN DNHANDLE DnloadID	- Effect ID in stick
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= SET_INDEX+index	 	0   1   i   i   i   i   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParam
// Purpose:    	Modifies an Effect parameter
// Parameters: 
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= MODIFY_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Low 7 bits data	 	0   v   v   v   v   v   v   v
//  Byte 2	= High 7 bits data		0   v   v   v   v   v   v   v
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParam( 
	IN WORD wNewParam)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	HRESULT hRet;
	BYTE cByte1, cByte2;
	cByte1 = wNewParam & 0x7f;
	cByte2 = (BYTE) ((wNewParam >> 7) & 0x7f);
	hRet = g_pJoltMidi->MidiSendShortMsg(MODIFY_CMD, cByte1, cByte2);
	
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: ModifyParam used to not require an ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM));
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
*/
}



//
// --- SYSTEM_CMDs
//

//
// --- System Exclusive Commands
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cfact.hpp ===
/****************************************************************************

    MODULE:     	SW_CFACT.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definitions, classes, and prototypes for a DLL that
    				provides Effect objects to any other object user.

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce	
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SW_CFACT_SEEN
#define _SW_CFACT_SEEN


//Get the object definitions
#include "SW_objec.hpp"

void ObjectDestroyed(void);

//SW_CFACT.CPP
//This class factory object creates DirectInputEffectDriver objects.

class CDirectInputEffectDriverClassFactory : public IClassFactory
{
 protected:
 	ULONG           m_cRef;

 public:
    CDirectInputEffectDriverClassFactory(void);
    ~CDirectInputEffectDriverClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                             , PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDirectInputEffectDriverClassFactory *PCDirectInputEffectDriverClassFactory;

#endif //_SW_CFACT_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swff_pro.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\swd_guid.cpp ===
/****************************************************************************

    MODULE:         SWD_GUID.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPODE:    	Instantiate GUIDS
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce

****************************************************************************/
#ifdef   WIN32
#define  INITGUIDS
#include <objbase.h>
#else
#include <memory.h>
#include <string.h>
#include <compobj.h>
#endif
#include <initguid.h>
#include "dinput.h"
#include "dinputd.h"
#include "SWD_Guid.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\swd_guid.hpp ===
/****************************************************************************

    MODULE:     	SWD_GUID.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:            CLSIDs and IIDs defined for DirectInputForce

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan
		MLD		Michael L. Day

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
	2.0			29-Jun-98	MLD		Added Saitek Modification

****************************************************************************/
#ifndef _SWD_GUID_SEEN
#define _SWD_GUID_SEEN

#ifdef INITGUIDS
#include <initguid.h>
#endif //INITGUIDS


/*
 * GUIDs
 *
 */

#ifdef SAITEK

//
// --- Saitek Force Feedback Device Driver Interface
//
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* {0A98BE81-0F6D-11d2-BCE0-0000F8757F9F} */
	0xa98be81,
	0xf6d,
	0x11d2,
	0xbc, 0xe0, 0x0, 0x0, 0xf8, 0x75, 0x7f, 0x9f
);


// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{0A98BE81-0F6D-11d2-BCE0-0000F8757F9F}")
#define DRIVER_OBJECT_NAME TEXT("Saitek Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Saitek Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Saitek Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

#else // #ifdef SAITEK

//
// --- SideWinder Force Feedback Device Driver Interface
//
// --- Old one
//DEFINE_GUID(CLSID_DirectInputEffectDriver, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* 0d33e080-da1f-11d1-9483-00c04fc2aa8f */
    0x0d33e080,
    0xda1f,
    0x11d1,
    0x94, 0x83, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0x8f
);


// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{0d33e080-da1f-11d1-9483-00c04fc2aa8f}")
#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

#endif // #ifdef SAITEK

//
// --- Effect GUIDs
//
DEFINE_GUID(GUID_Wall, /* e84cd1a1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ProcessList, /* e84cd1a2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// Built in ROM Effects
DEFINE_GUID(GUID_RandomNoise, /* e84cd1a3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_AircraftCarrierTakeOff, /* e84cd1a4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_BasketballDribble, /* e84cd1a5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_CarEngineIdle, /* e84cd1a6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawIdle, /* e84cd1a7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawInAction, /* e84cd1a8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_DieselEngineIdle, /* e84cd1a9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Jump, /* e84cd1aa-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1aa,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Land, /* e84cd1ab-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ab,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_MachineGun, /* e84cd1ac-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ac,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Punched, /* e84cd1ad-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ad,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_RocketLaunch, /* e84cd1ae-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ae,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SecretDoor, /* e84cd1af-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1af,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SwitchClick, /* e84cd1b0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindGust, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindShear, /* e84cd1b2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Pistol, /* e84cd1b3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Shotgun, /* e84cd1b4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser1, /* e84cd1b5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser2, /* e84cd1b6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser3, /* e84cd1b7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser4, /* e84cd1b8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser5, /* e84cd1b9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser6, /* e84cd1ba-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ba,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_OutOfAmmo, /* e84cd1bb-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bb,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_LightningGun, /* e84cd1bc-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bc,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Missile, /* e84cd1bd-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bd,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_GatlingGun, /* e84cd1be-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1be,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ShortPlasma, /* e84cd1bf-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bf,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon1, /* e84cd1c0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon2, /* e84cd1c1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Cannon, /* e84cd1c2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RawForce, /* e84cd1c6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_VFXEffect, /* e84cd1c7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RTCSpring, /* e84cd1c8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

//
// --- UNUSED but reserved for future GUIDs
//


#endif //_SWD_GUID_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_out.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OUT.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Uses a low-level callback function to get timestamped 
    				MIDI output. The callback function sets an Event to indicate
    				to wake up a blocked object.
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			10-Jan-97	MEA     original

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <crtdbg.h>
#include "midi_obj.hpp"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// Prototypes
void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);



// ----------------------------------------------------------------------------
// Function: 	midiOutputHandler
// Purpose:		
// Parameters:	hMidiIn - Handle for the associated output device.
//				wMsg - One of the MIM_***** messages.
//				dwInstance - Points to CALLBACKINSTANCEDATA structure.
//				dwParam1 - MIDI data.
//				dwParam2 - Timestamp (in milliseconds)
//
// Returns:		none
// Algorithm:
// Comments:
//		Low-level callback function to handle MIDI output.
//      Installed by midiOutOpen().  The Output handler checks for MM_MOM_DONE
//		message and wakes up the thread waiting for completion of MIDI SysEx 
//		output.  Note: Normal Short messages don't get notification!!!
//      This function is accessed at interrupt time, so it should be as 
//      fast and efficient as possible.  You can't make any
//      Windows calls here, except PostMessage().  The only Multimedia
//      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
// ----------------------------------------------------------------------------
void CALLBACK midiOutputHandler(
	IN HMIDIOUT hMidiOut, 
	IN UINT wMsg, 
	IN DWORD dwInstance, 
	IN DWORD dwParam1, 
	IN DWORD dwParam2)
{
	CJoltMidi *pJoltMidi = (CJoltMidi *) dwInstance;
	assert(pJoltMidi);
	BOOL bRet;
    
	switch(wMsg)
    {
        case MOM_OPEN:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: MOM_OPEN.\n");
#endif
            break;

        case MM_MOM_DONE:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: MM_MOM_DONE\n");
#endif
			// Notify task waiting on this object to trigger
			bRet = SetEvent(pJoltMidi->MidiOutputEventHandleOf());
			assert(bRet);
            break;

        default:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: default case.\n");
#endif
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_error.hpp ===
/****************************************************************************

    MODULE:     	SW_Error.HPP
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for Error Codes
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original

****************************************************************************/
#ifndef SW_Error_SEEN
#define SW_Error_SEEN

#include <winerror.h>
#include <windows.h>
#include <mmsystem.h>

typedef struct _SWFF_ERROR {
	HRESULT	HCode;			// HRESULT code
	ULONG	ulDriverCode;	// Error code from device driver
} SWFF_ERROR, *PSWFF_ERROR;

//---------------------------------------------------------------------------
// Error Status Codes
//---------------------------------------------------------------------------
/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */

// SWForce Errors
#define MAKE_FF_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_FF_E( err )  (MAKE_FF_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_FF_S( warn ) (MAKE_FF_SCODE( 0, FACILITY_ITF, warn ))

#define DINPUT_DRIVER_ERR_BASE	0x500

#define SUCCESS					0x00										// successful
#define SFERR_INVALID_OBJECT		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 1)	// Invalid object ID
#define SFERR_INVALID_PARAM			DIERR_INVALIDPARAM						// Invalid parameters
#define SFERR_NO_SUPPORT			DIERR_UNSUPPORTED						// Function not supported
#define SFERR_INVALID_DEVICE		DIERR_DEVICENOTREG						// Device not found
#define	SFERR_FFDEVICE_MEMORY		DIERR_DEVICEFULL						// Out of download RAM
#define SFERR_END_OF_LIST			MAKE_FF_S(DINPUT_DRIVER_ERR_BASE + 6)	// End of the list
#define SFERR_DEVICE_NACK			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 7)	// Device NACK received
#define SFERR_INVALID_STRUCT_SIZE 	DIERR_INVALIDPARAM						// Invalid structure passed
#define SFERR_EFFECT_NOT_IN_DEVICE 	DIERR_NOTDOWNLOADED					// Effect was not downloaded, so
																			// cannot unload.
#define SFERR_RAW_OUT_DATAEVENT_CREATION 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 10)	// Could not create Event
#define SFERR_RAW_OUT_THREAD_CREATION 		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 11)	// Could not create a thread
#define SFERR_EFFECT_STATUS_BUSY DIERR_EFFECTPLAYING								// Device busy playing Effect
#define SFERR_OUT_OF_FF_MEMORY		DIERR_OUTOFMEMORY								// FF system has run out of memory
																					//  cannot create new Effect
#define SFERR_SYSTEM_INIT			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 14)	// Could not create SWForce
#define SFERR_DRIVER_ERROR      	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 15)  // Driver error detected
#define SFERR_NON_FF_DEVICE     	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 16)  // This is a non-FF device, driver not found
#define SFERR_INVALID_HAL_OBJECT 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 17)	// HAL cannot emulate this object
#define SFERR_INVALID_MEMBER_VALUE 	DIERR_INVALIDPARAM						// Data structure has invalid member value

// VFX_ error codes
#define VFX_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 100
#define VFX_ERR_FILE_NOT_FOUND				HRESULT_FROM_WIN32(MMIOERR_FILENOTFOUND)
#define VFX_ERR_FILE_OUT_OF_MEMORY			DIERR_OUTOFMEMORY
#define VFX_ERR_FILE_CANNOT_OPEN			HRESULT_FROM_WIN32(MMIOERR_CANNOTOPEN)
#define VFX_ERR_FILE_CANNOT_CLOSE			HRESULT_FROM_WIN32(MMIOERR_CANNOTCLOSE)
#define VFX_ERR_FILE_CANNOT_READ			HRESULT_FROM_WIN32(MMIOERR_CANNOTREAD)
#define VFX_ERR_FILE_CANNOT_WRITE			HRESULT_FROM_WIN32(MMIOERR_CANNOTWRITE)
#define VFX_ERR_FILE_CANNOT_SEEK			HRESULT_FROM_WIN32(MMIOERR_CANNOTSEEK)
#define VFX_ERR_FILE_UNKNOWN_ERROR			MAKE_FF_E(VFX_ERR_BASE + 8)
#define VFX_ERR_FILE_BAD_FORMAT				MAKE_FF_E(VFX_ERR_BASE + 9)
#define VFX_ERR_FILE_ACCESS_DENIED			HRESULT_FROM_WIN32(MMIOERR_ACCESSDENIED)
#define VFX_ERR_FILE_SHARING_VIOLATION		HRESULT_FROM_WIN32(MMIOERR_SHARINGVIOLATION)
#define VFX_ERR_FILE_NETWORK_ERROR			HRESULT_FROM_WIN32(MMIOERR_NETWORKERROR)
#define VFX_ERR_FILE_TOO_MANY_OPEN_FILES	HRESULT_FROM_WIN32(MMIOERR_TOOMANYOPENFILES)
#define VFX_ERR_FILE_INVALID				HRESULT_FROM_WIN32(MMIOERR_INVALIDFILE)
#define VFX_ERR_FILE_END_OF_FILE			MAKE_FF_E(VFX_ERR_BASE + 15)

// SideWinder Driver Error codes
#define SWDEV_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 200
#define SWDEV_ERR_INVALID_ID				MAKE_FF_E(SWDEV_ERR_BASE + 1)  // Invalid Download ID
#define SWDEV_ERR_INVALID_PARAM				MAKE_FF_E(SWDEV_ERR_BASE + 2)  // Invalid Download Parameter
#define SWDEV_ERR_CHECKSUM					MAKE_FF_E(SWDEV_ERR_BASE + 3)  // Invalid Checksum in COMM Packet
#define SWDEV_ERR_TYPE_FULL					MAKE_FF_E(SWDEV_ERR_BASE + 4)  // No More RAM space for Effect Type
#define SWDEV_ERR_UNKNOWN_CMD				MAKE_FF_E(SWDEV_ERR_BASE + 5)  // Unrecognized Device command
#define SWDEV_ERR_PLAYLIST_FULL				MAKE_FF_E(SWDEV_ERR_BASE + 6)  // Play List is full, cannot play any more Effects
#define SWDEV_ERR_PROCESSLIST_FULL			MAKE_FF_E(SWDEV_ERR_BASE + 7)  // Process List is full, cannot download 


#endif // of ifndef SW_Error_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cimpi.cpp ===
/****************************************************************************

    MODULE:     	SW_CImpI.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IDEffect Implementation.
    
    Function(s):
					CImpIDirectInputEffectDriver::DeviceID
					CImpIDirectInputEffectDriver::GetVersions
    			    CImpIDirectInputEffectDriver::Escape
				    CImpIDirectInputEffectDriver::SetGain
    			    CImpIDirectInputEffectDriver::SendForceFeedbackCommand
    			    CImpIDirectInputEffectDriver::GetForceFeedbackState
    			    CImpIDirectInputEffectDriver::DownloadEffect
    			    CImpIDirectInputEffectDriver::DestroyEffect
    			    CImpIDirectInputEffectDriver::StartEffect
    			    CImpIDirectInputEffectDriver::StopEffect
    			    CImpIDirectInputEffectDriver::GetEffectStatus

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
  	1.0    	06-Feb-97   MEA     original, Based on SWForce
			23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
			23-Mar-97	MEA/DS	Added VFX support
			16-Mar-99	waltw	GetFirmwareParams, GetSystemParams,
								CMD_Download_RTCSpring, GetDelayParams,
								GetJoystickParams, & UpdateJoystickParams
								calls removed from DeviceID since they are
								called from g_pJoltMidi->Initialize.
			23-Mar-99	waltw	GetEffectStatus now uses data returned by
								Transmit instead of obsolete GetStatusGateData

****************************************************************************/
#include <windows.h>
#include <math.h>
#include <assert.h>
#include "dinput.h"
#include "dinputd.h"
#include "SW_objec.hpp"
#include "hau_midi.hpp"
#include "ffd_swff.hpp"
#include "FFDevice.h"
#include "DPack.h"
#include "DTrans.h"
#include <ntverp.h>
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
	extern char g_cMsg[160];
	extern TCHAR szDeviceName[MAX_SIZE_SNAME];
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

extern CJoltMidi *g_pJoltMidi;

// To convert a nack error code to a DIError code
HRESULT g_NackToError[] = 
{
	SFERR_DRIVER_ERROR,		//	DEV_ERR_SUCCESS_200 - but it NACKd!
	SWDEV_ERR_INVALID_ID,		//	DEV_ERR_INVALID_ID_200
	SWDEV_ERR_INVALID_PARAM,		//	DEV_ERR_BAD_PARAM_200
	SWDEV_ERR_CHECKSUM,		//	DEV_ERR_BAD_CHECKSUM_200
	SFERR_DRIVER_ERROR,		//	DEV_ERR_BAD_INDEX_200
	SWDEV_ERR_UNKNOWN_CMD,		//	DEV_ERR_UNKNOWN_CMD_200
	SWDEV_ERR_PLAYLIST_FULL,		//	DEV_ERR_PLAY_FULL_200
	DIERR_DEVICEFULL,		//	DEV_ERR_MEM_FULL_200
	MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)		//	DEV_ERR_BANDWIDTH_FULL_200
};

// ****************************************************************************
// *** --- Member functions for base class CImpIDirectInputEffectDriver Interface
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CImpIDirectInputEffectDriver Object
// Parameters:  PCDirectInputEffectDriver pObj	- Ptr to the outer object
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver(PCDirectInputEffectDriver pObj)
{
    m_cRef=0;
    m_pObj=pObj;
	m_pJoltMidi = NULL;		// The Jolt Device object 
    return;
}

CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver(void)
{
	DebugOut("CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver()\n");

	// Destroy the CEffect object we created and release any interfaces
	if (g_pJoltMidi) 
	{
		delete g_pJoltMidi;
		g_pJoltMidi = NULL;
	}

	// No critical section here because g_CriticalSection already destroyed
	DebugOut("CImpIDirectInputEffectDriver::~CimpIDEffect()\n");
}

// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::QueryInterface
//				CImpIDirectInputEffectDriver::AddRef
//				CImpIDirectInputEffectDriver::Release
//
// Purpose:		IUnknown members that delegate to m_pObj
// Parameters:  
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
STDMETHODIMP CImpIDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
    return m_pObj->QueryInterface(riid, ppv);
}

DWORD CImpIDirectInputEffectDriver::AddRef(void)
{
//
//  We maintain an "interface reference count" for debugging
//  purposes, because the client of an object should match
//  AddRef and Release calls through each interface pointer.
//  
    ++m_cRef;
    return m_pObj->AddRef();
}

DWORD CImpIDirectInputEffectDriver::Release(void)
{
//	m_cRef is again only for debugging.  It doesn't affect
//	CSWEffect although the call to m_pObj->Release does.
	--m_cRef;
    return m_pObj->Release();
}


// ----------------------------------------------------------------------------
// Function:    DeviceID
//
// Purpose:     
// Parameters:  DWORD dwExternalID		-The joystick ID number being us
//				DWORD fBegin			-Nonzero if access to the device is beginning; Zero if ending
//				DWORD dwInternalID		-Internal joystick id
//				LPVOID lpReserved		-Reserved for future use (HID)
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DeviceID(
	IN DWORD dwDirectInputVersion,
    IN DWORD dwExternalID,
    IN DWORD fBegin,
    IN DWORD dwInternalID,
	LPVOID lpReserved)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::DeviceID(%lu, %lu, %lu, %lu, %lx)\n", dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, lpReserved);
	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	if (g_pDataPackager) {
		g_pDataPackager->SetDirectInputVersion(dwDirectInputVersion);
	}
	assert(NULL == g_pJoltMidi);
	
	// Create and Initialize our CJoltMidi object
#ifdef _DEBUG
	OutputDebugString("Creating and Initializing CJoltMidi object\n");
#endif
	g_pJoltMidi = new CJoltMidi();
	if (NULL == g_pJoltMidi)
	{
		return (E_OUTOFMEMORY);
	}
	else
	{
		return g_pJoltMidi->Initialize(dwExternalID);
	}
}


// ----------------------------------------------------------------------------
// Function:    GetVersions
//
// Purpose:     
// Parameters:  LPDIDRIVERVERSIONS pvers -Pointer to structure which receives version info
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetVersions(
	IN OUT LPDIDRIVERVERSIONS pvers)
{
	if (g_pJoltMidi == NULL) {
		return E_FAIL;
	}

	LOCAL_PRODUCT_ID* pProductID = g_pJoltMidi->ProductIDPtrOf();
	if (pProductID == NULL) {
		return E_FAIL;
	}

	pvers->dwFirmwareRevision = (pProductID->dwFWMajVersion << 8) | (pProductID->dwFWMinVersion);
	pvers->dwHardwareRevision = pProductID->dwProductID;

	// Get version from ntverp.h (was FULLVersion from version.h)
	pvers->dwFFDriverVersion = VER_PRODUCTVERSION_DW;

#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::GetVersions(%lu, %lu, %lu)\n", pvers->dwFirmwareRevision, pvers->dwHardwareRevision, pvers->dwFFDriverVersion);
	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function:    Escape
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				LPDIEFFESCAPE pEsc	- Pointer to a DIFEFESCAPE struct
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::Escape(
    IN DWORD dwDeviceID,
	IN DWORD dwEffectID,
	IN OUT LPDIEFFESCAPE pEsc )
{
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->Escape(dwEffectID, pEsc);
	if (hr != SUCCESS) {
		return hr;
	}

	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}


// ----------------------------------------------------------------------------
// Function:    SetGain
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwGain		- Device gain
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SetGain(
    IN DWORD dwDeviceID,
    IN DWORD dwGain)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SetGain: %s Gain=%ld\r\n", &szDeviceName, dwGain);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	BOOL truncation = (dwGain > 10000);
	if (truncation) {
		dwGain = 10000;
	}
	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->SetGain(dwGain);
	if (FAILED(hr)) {
		return hr;
	}

	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if ((hr == SUCCESS) && (truncation)) {
		return DI_TRUNCATED;
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    SendForceFeedbackCommand
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwState		- Command to set Device state
//
//
// Returns:		SUCCESS or Error code
//
// Need to map the following DX to Jolt
// DS_FORCE_SHUTDOWN   0x00000001	// Actuators (Motors) are enabled.
// DS_FORCE_ON         0x00000002	// Actuators (Motors) are disabled.
// DS_FORCE_OFF        0x00000003	// All Effects are "Paused"
// DS_CONTINUE         0x00000004	// All "Paused" Effects are continued
// DS_PAUSE            0x00000005	// All Effects are stopped.
// DS_STOP_ALL         0x00000006	// All Effects destroyed,Motors disabled
//
//	Jolt Device ulMode:
//	SWDEV_SHUTDOWN 		1L			// All Effects destroyed, Motors disabled
//	SWDEV_FORCE_ON 		2L			// Motors enabled.  "Un-Mute"
//	SWDEV_FORCE_OFF		3L			// Motors disabled.	"Mute"
//	SWDEV_CONTINUE 		4L			// All "Paused" Effects are allow to continue
//	SWDEV_PAUSE	   		5L			// All Effects are "Paused"
//	SWDEV_STOP_ALL 		6L			// Stops all Effects.  
//   	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SendForceFeedbackCommand(
    IN DWORD dwDeviceID,
    IN DWORD dwState)
{
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->SendForceFeedbackCommand(dwState);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SUCCESS) {
		g_ForceFeedbackDevice.StateChange(dwDeviceID, dwState);
		g_pJoltMidi->UpdateDeviceMode(dwState);
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    GetForceFeedbackState
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				LPDIDEVICESTATE pDeviceState	- Pointer to a DIDEVICESTATE struct
//
// Returns:		SUCCESS or Error code and state updated in pDeviceState
//
// Member: dwState
//		DS_FORCE_SHUTDOWN   	0x00000001
//		DS_FORCE_ON         	0x00000002
//		DS_FORCE_OFF        	0x00000003
//		DS_CONTINUE         	0x00000004
//		DS_PAUSE            	0x00000005
//		DS_STOP_ALL         	0x00000006
//
// Member: dwSwitches
//		DSW_ACTUATORSON         0x00000001
//		DSW_ACTUATORSOFF        0x00000002
//		DSW_POWERON             0x00000004
//		DSW_POWEROFF            0x00000008
//		DSW_SAFETYSWITCHON      0x00000010
//		DSW_SAFETYSWITCHOFF     0x00000020
//		DSW_USERFFSWITCHON      0x00000040
//		DSW_USERFFSWTTCHOFF     0x00000080
//
// Algorithm:
// This is the DI Device State structure
//typedef struct DIDEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
// This is the SideWinder State structure (copy kept in CJoltMidi object)
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetForceFeedbackState(
    IN DWORD dwDeviceID,
    IN LPDIDEVICESTATE pDeviceState)
{
	// Driver sanity Check;
	if (g_pJoltMidi == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	// User sanity check
	if (pDeviceState == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (pDeviceState->dwSize != sizeof(DIDEVICESTATE)) {
		ASSUME_NOT_REACHED();	// Has structure changed?
		return SFERR_INVALID_PARAM;
	}

	// Fix 1.20 state bug (needs to be changed for jolt support)
	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 20)) {
		if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
			return SFERR_DRIVER_ERROR;
		}
		HRESULT hr;

		if ((g_pJoltMidi->GetSWDeviceStateNoUpdate().m_ForceState == SWDEV_FORCE_OFF)) {	// Echo state back to fix 1.20 bug
			hr = g_pDataPackager->SendForceFeedbackCommand(SWDEV_FORCE_OFF);
		} else {
			hr = g_pDataPackager->SendForceFeedbackCommand(SWDEV_FORCE_ON);
		}

		if (hr != SUCCESS) {
			return hr;
		}
		ACKNACK ackNack;
		g_pDataTransmitter->Transmit(ackNack);	// Send it off

	}

	pDeviceState->dwState = 0;

	// Ask the device for state
   	HRESULT hRet = g_ForceFeedbackDevice.QueryStatus();
	if (hRet != SUCCESS) {
		return hRet;
	}

	// Set flags from the device
	if (g_ForceFeedbackDevice.IsUserDisable()) {
		pDeviceState->dwState = DIGFFS_SAFETYSWITCHOFF;
	} else {
		pDeviceState->dwState = DIGFFS_SAFETYSWITCHON;
	}
	if (g_ForceFeedbackDevice.IsHostDisable()) {
		pDeviceState->dwState |= DIGFFS_ACTUATORSOFF;
	} else {
		pDeviceState->dwState |= DIGFFS_ACTUATORSON;
	}
	if (g_ForceFeedbackDevice.IsHostPause()) {
		pDeviceState->dwState |= DIGFFS_PAUSED;
	}

	// All effects been stopped from host?
	if (g_ForceFeedbackDevice.GetDIState() == DIGFFS_STOPPED) {
		pDeviceState->dwState |= DIGFFS_STOPPED;
	}

	// Have any effects been created?
	BOOL bEmpty = TRUE;
	for (int i=2; i < MAX_EFFECT_IDS; i++) {
		if (g_ForceFeedbackDevice.GetEffect(i) != NULL) {
			bEmpty = FALSE;
			break;
		}
	}	
	if(bEmpty) {
		pDeviceState->dwState |= DIGFFS_EMPTY;
	}

	// NYI Firmware
/*	if (m_DeviceState.m_ACBrickFault)
		pDeviceState->dwState |= DIGFFS_POWEROFF;
	else
		pDeviceState->dwState |= DIGFFS_POWERON;
*/
	pDeviceState->dwState |= DIGFFS_POWERON;	// Always on in Zep (and Zep is on or we wouldn't be here)

	pDeviceState->dwLoad = 0;

	return hRet;
}


// ----------------------------------------------------------------------------
// Function:    DownloadEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				DWORD dwInternalEffectType	- Internal Effect Type
//				IN OUT LPDWORD pDnloadID	- Pointer to a DWORD for DnloadID
//				IN LPCDIEFFECT pEffect		- Pointer to a DIEFFECT structure
//				IN DWORD dwFlags			- for parameters that changed
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// The following dwFlags may be sent by the kernel
//
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Jolt has two options for downloading - Full SysEx or Modify Parameter
// Pass the dwFlags to each CMD_xxx function and let the MIDI function
// determine whether to use SysEx or Modify Parameter.
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DownloadEffect(
    IN DWORD dwDeviceID,
    IN DWORD dwInternalEffectType,
    IN OUT LPDWORD pDnloadID,
    IN LPCDIEFFECT pEffect,
	IN DWORD dwFlags)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s 3Effect. DnloadID= %ld, Type=%lx, dwFlags= %lx\r\n",
   					&szDeviceName[0], *pDnloadID, dwInternalEffectType, dwFlags);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	// Quick sanity check
	if ((pEffect == NULL) || (pDnloadID == NULL)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Are we setup properly
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SFERR_DRIVER_ERROR;
	HRESULT createResult = SUCCESS;
	BOOL downLoad = (dwFlags & DIEP_NODOWNLOAD) == 0;
	BOOL createdAttempted = FALSE;

	InternalEffect* pLocalEffect = NULL;
	if (*pDnloadID != 0) {		// 0 Indicates create new
		pLocalEffect = g_ForceFeedbackDevice.GetEffect(*pDnloadID);
	}
	if (pLocalEffect == NULL) {	// New effect create it (or Raw Force)
		createdAttempted = TRUE;
		BOOL wasZero = (*pDnloadID == 0);
		pLocalEffect = g_ForceFeedbackDevice.CreateEffect(dwInternalEffectType, *pEffect, *pDnloadID, createResult, (downLoad == FALSE));

		if (FAILED(createResult)) {
			return createResult;
		}
		if (pLocalEffect == NULL) {
			if ((*pDnloadID == RAW_FORCE_ALIAS) && (wasZero == FALSE)) {
				if ((dwFlags & (DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERREPEATINTERVAL | DIEP_TRIGGERBUTTON | DIEP_ENVELOPE)) != 0) {
					return S_FALSE;
				}
			}
			return createResult;
		}

		hr = g_pDataPackager->CreateEffect(*pLocalEffect, dwFlags);
		if (!downLoad) {
			delete pLocalEffect;
			pLocalEffect = NULL;
		}
	} else { // Effect Exists, modify it
		InternalEffect* pDIEffect = g_ForceFeedbackDevice.CreateEffect(dwInternalEffectType, *pEffect, *pDnloadID, createResult, (downLoad == FALSE)); // Create new
		if ((pDIEffect == NULL) || (FAILED(createResult))) {
			return createResult;
		}

		hr = g_pDataPackager->ModifyEffect(*pLocalEffect, *pDIEffect, dwFlags);	// Package relative changes
		if (FAILED(hr)) {
			delete pDIEffect;
			return hr;
		}

		if (downLoad) {
			g_ForceFeedbackDevice.SetEffect(BYTE(*pDnloadID), pDIEffect);		// Replace the old with the new
			pDIEffect->SetDeviceID(pLocalEffect->GetDeviceID());	// Update device IDs
			delete pLocalEffect;	// Delete the old
		} else {
			delete pDIEffect;
		}
	}

	if ((FAILED(hr)) || (downLoad == FALSE)) {
		return hr;
	}
	HRESULT  modProblems = hr;

	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SFERR_DEVICE_NACK) {
		if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
			return g_NackToError[ackNack.dwErrorCode];
		} else {
			return SFERR_DRIVER_ERROR;
		}
	}
	if (FAILED(hr)) {
		return hr;
	}
	if (createdAttempted == TRUE) {
		g_ForceFeedbackDevice.SetDeviceIDFromStatusPacket(*pDnloadID);
	}

	// Check for start flag
	if (dwFlags & DIEP_START) {
		// Create a command/data packet - send it of to the stick
		HRESULT hr = g_pDataPackager->StartEffect(*pDnloadID, 0, 1);
		if (hr != SUCCESS) {
			return hr;
		}
		hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
		if (hr == SFERR_DEVICE_NACK) {
			if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
				return g_NackToError[ackNack.dwErrorCode];
			} else {
				return SFERR_DRIVER_ERROR;
			}
		}
		pLocalEffect->SetPlaying(TRUE);
		return hr;
	}

	if (createResult != SUCCESS) {	// Truncation and whatnot
		return createResult;
	}
	return modProblems;	// Wow we got this far!
}

// ----------------------------------------------------------------------------
// Function:    DestroyEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to destroy
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DestroyEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DestroyEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->DestroyEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

// ----------------------------------------------------------------------------
// Function:    StartEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Start
//				DWORD dwMode		- Playback mode
//				DWORD dwCount		- Loop count
//
//
// Returns:		SUCCESS or Error code
//
//  dwMode: Playback mode is available with the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StartEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    IN DWORD dwMode,
    IN DWORD dwCount)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StartEffect. DnloadID:%ld, Mode:%lx, Count:%lx\r\n",
   			  &szDeviceName[0], DnloadID, dwMode, dwCount);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT packageResult = g_pDataPackager->StartEffect(DnloadID, dwMode, dwCount);
	if (FAILED(packageResult)) {
		return packageResult;
	}

	ACKNACK ackNack;
	HRESULT hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SFERR_DEVICE_NACK) {
		if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
			return g_NackToError[ackNack.dwErrorCode];
		} else {
			return SFERR_DRIVER_ERROR;
		}
	}

	InternalEffect* pEffect = g_ForceFeedbackDevice.GetEffect(DnloadID);
	if (pEffect != NULL) {
		pEffect->SetPlaying(TRUE);
	}

	if (hr == SUCCESS) {
		return packageResult;
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    StopEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Stop
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StopEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StopEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->StopEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

// ----------------------------------------------------------------------------
// Function:    GetEffectStatus
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	-	 Device ID
//				DWORD DnloadID			- Download ID to get Status
//				LPDWORD pdwStatusCode	- Pointer to a DWORD for Status
//
//
// Returns:		SUCCESS or Error code
//				Status Code: DEV_STS_EFFECT_STOPPED
//							 DEV_STS_EFFECT_RUNNING
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetEffectStatus(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    OUT LPDWORD pdwStatusCode)
{
	HRESULT hRet = SUCCESS;
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "GetEffectStatus, DnloadID=%d\r\n", DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	ASSUME_NOT_NULL(pdwStatusCode);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL) || (pdwStatusCode == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->GetEffectStatus(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr != SUCCESS) {
		return hr;
	}

	// Use result returned by GetAckNackData in Transmit
	DWORD dwIn = ackNack.dwEffectStatus;

	// Interpret result (cooked RUNNING_MASK_200 becomes SWDEV_STS_EFFECT_RUNNING)
	if ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & SWDEV_STS_EFFECT_RUNNING)) {
		*pdwStatusCode = DIEGES_PLAYING;
	} else {
		*pdwStatusCode = NULL; // Stopped;
	}
	g_ForceFeedbackDevice.GetEffect(DnloadID)->SetPlaying(*pdwStatusCode == DIEGES_PLAYING);
	return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		if (rkey.m_pReferenceCount != NULL)
		{
			*(rkey.m_pReferenceCount) = 1;
		}
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	if (m_pReferenceCount != NULL)
	{
		++(*m_pReferenceCount);
	}
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		if (rhs.m_pReferenceCount == NULL)
		{
			return *this;
		}
			*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cfact.cpp ===
/****************************************************************************

    MODULE:     	SW_CFact.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Class Object structured in a DLL server.
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#include "SW_CFact.hpp"
#include "SWD_Guid.hpp"

// Needed for auto registration
#include "Registry.h"
#include "CritSec.h"
#include "olectl.h"	// Self Reg errors

// Define CriticalSection object for everyone
CriticalSection g_CriticalSection;

//
// Global Data
//
ULONG       g_cObj=0;	//Count number of objects and number of locks.
ULONG       g_cLock=0;
HINSTANCE	g_MyInstance = NULL;

//
// External Functions
//

//
// Internal Function Prototypes
//


//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif

#define BUFSIZE 80


/*
 * LibMain(32)
 *
 * Purpose:
 *  Entry point provides the proper structure for each environment.
 */

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	switch (ulReason)
    {
		case DLL_PROCESS_ATTACH: {
            //
            // DLL is attaching to the address space of the current process.
            //
            g_MyInstance = hInstance;
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "SW_WHEEL.DLL: DLL_PROCESS_ATTACH\r\n");
#endif
           	return (TRUE);
		}
		case DLL_THREAD_ATTACH:
     	//
     	// A new thread is being created in the current process.
     	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.DLL: DLL_THREAD_ATTACH\r\n");
#endif
	   		break;

       	case DLL_THREAD_DETACH:
     	//
     	// A thread is exiting cleanly.
     	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.dll: DLL_THREAD_DETACH\r\n");
#endif
     		break;

		case DLL_PROCESS_DETACH:
    	//
    	// The calling process is detaching the DLL from its address space.
    	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.dll: DLL_PROCESS_DETACH\r\n");
#endif
			break;
	}
   return(TRUE);
}

// ----------------------------------------------------------------------------
// Function: 	DllGetClassObject
//
// Purpose:		Provides an IClassFactory for a given CLSID that this DLL is
//				registered to support.  This DLL is placed under the CLSID
//				in the registration database as the InProcServer.
//
// Parameters:  REFCLSID clsID	- REFCLSID that identifies the class factory
//                				  desired.  Since this parameter is passed this
//                				  DLL can handle any number of objects simply
//                				  by returning different class factories here
//                				  for different CLSIDs.
//
//				REFIID riid     - REFIID specifying the interface the caller 
//				                  wants on the class object, usually 
//								  IID_ClassFactory.
//
//				PPVOID ppv      - PPVOID in which to return the interface ptr.
//
// Returns:		HRESULT         NOERROR on success, otherwise an error code.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT             hr;
    CDirectInputEffectDriverClassFactory *pObj;

#ifdef _DEBUG
    _RPT0(_CRT_WARN, "SW_WHEEL.dll: DllGetClassObject()\r\n");
#endif                 
    if (CLSID_DirectInputEffectDriver !=rclsid) return ResultFromScode(E_FAIL);

    pObj=new CDirectInputEffectDriverClassFactory();

    if (NULL==pObj) return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))	delete pObj;
    return hr;
}


// ----------------------------------------------------------------------------
// Function: 	DllCanUnloadNow
//
// Purpose:		Answers if the DLL can be freed, that is, if there are no
//				references to anything this DLL provides.
//				
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //Our answer is whether there are any object or locks
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


// ----------------------------------------------------------------------------
// Function: 	ObjectDestroyed
//
// Purpose:		Function for the DirectInputEffectDriver object to call when it gets destroyed.
//				Since we're in a DLL we only track the number of objects here,
//				letting DllCanUnloadNow take care of the rest.
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
void ObjectDestroyed(void)
{
    g_cObj--;
    return;
}

// ----------------------------------------------------------------------------
// Function: 	DllRegisterServer
//
// Purpose:		Auto-magically puts default entries into registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	// Register CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_DirectInputEffectDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR fileName[MAX_PATH];
			DWORD nameSize = ::GetModuleFileName(g_MyInstance, fileName, MAX_PATH);
			if (nameSize > 0) {
				fileName[nameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)fileName, sizeof(fileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
		// NotInsertable ""
		RegistryKey notInsertableKey = driverKey.OpenCreateSubkey(TEXT("NotInsertable"));
		if (notInsertableKey != c_InvalidKey) {
			notInsertableKey.SetValue(NULL, (BYTE*)TEXT(""), sizeof(TEXT(""))/sizeof(TCHAR), REG_SZ);
		}
		// ProgID "Sidewinder ForceFeedback blah blah2.0"
		RegistryKey progIDKey = driverKey.OpenCreateSubkey(TEXT("ProgID"));
		if (progIDKey != c_InvalidKey) {
			progIDKey.SetValue(NULL, (BYTE*)PROGID_NAME, sizeof(PROGID_NAME)/sizeof(TCHAR), REG_SZ);
		}
		// VersionIndpendentProgID "Sidewinder ForceFeedback blah blah"
		RegistryKey progIDVersionlessKey = driverKey.OpenCreateSubkey(TEXT("VersionIndpendentProgID"));
		if (progIDVersionlessKey != c_InvalidKey) {
			progIDVersionlessKey.SetValue(NULL, (BYTE*)PROGID_NOVERSION_NAME, sizeof(PROGID_NOVERSION_NAME)/sizeof(TCHAR), REG_SZ);
		}
	} else {
		return SELFREG_E_CLASS;
	}

	// Made it here valid driver key
	return S_OK;
}

// ----------------------------------------------------------------------------
// Function: 	DllUnregisterServer
//
// Purpose:		Auto-magically removed default entries from registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_DirectInputEffectDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			driverKey.RemoveSubkey(TEXT("NotInsertable"));
			driverKey.RemoveSubkey(TEXT("ProgID"));
			driverKey.RemoveSubkey(TEXT("VersionIndpendentProgID"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_DirectInputEffectDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}


/*
 * CVIObjectClassFactory::CVIObjectClassFactory
 * CVIObjectClassFactory::~CVIObjectClassFactory
 *
 * Constructor Parameters:
 *  None
 */

CDirectInputEffectDriverClassFactory::CDirectInputEffectDriverClassFactory(void)
{
    m_cRef=0L;
    return;
}

CDirectInputEffectDriverClassFactory::~CDirectInputEffectDriverClassFactory(void)
{
    return;
}




/*
 * CDirectInputEffectDriverClassFactory::QueryInterface
 * CDirectInputEffectDriverClassFactory::AddRef
 * CDirectInputEffectDriverClassFactory::Release
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    	return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::Release(void)
{
    if (0L!=--m_cRef) return m_cRef;
    delete this;
    return 0L;
}

/*
 * CDirectInputEffectDriverClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a DirectInputEffectDriver object returning an interface pointer.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired
 *                  interface pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
 *                  if we cannot support the requested interface.
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, 
    REFIID riid, PPVOID ppvObj)
{
    PCDirectInputEffectDriver       pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    pObj=new CDirectInputEffectDriver(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj) return hr;

    if (pObj->Init()) hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))	
    	delete pObj;
    else
        g_cObj++;
    return hr;
}


/*
 * CDirectInputEffectDriverClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the DLL.  If the
 *  lock count goes to zero and there are no objects, the DLL
 *  is allowed to unload.  See DllCanUnloadNow.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */
STDMETHODIMP CDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
        g_cLock--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_globs.cpp ===
/****************************************************************************

    MODULE:     	SW_GLOBS.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	SW_WHEEL Global Variables
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.1    		15-May-97   MEA     original
				21-Mar-99	waltw	Removed unreferenced globals & updated szDeviceName

****************************************************************************/
#include <windows.h>
#include "midi_obj.hpp"

//
// Globals
//

#ifdef _DEBUG
char g_cMsg[160];
TCHAR szDeviceName[MAX_SIZE_SNAME] = {"Microsoft SideWinder Force Feedback Pro"};
#endif

// 
// *** Global on per process space only
//
CJoltMidi *g_pJoltMidi = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_objec.hpp ===
/****************************************************************************

    MODULE:     	SW_Objec.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definition of the CDirectInputEffectDriver class that uses interface
					implementations to provide IDirectInputEffectDriver
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
				26-Feb-97	MEA		Added SetGain
				21-Mar-99	waltw	Removed unreferenced CreateDirectInputEffectDriver

****************************************************************************/
#ifndef _SW_OBJEC_SEEN
#define _SW_OBJEC_SEEN

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include "dinput.h"
#include "dinputd.h"
#include "midi_obj.hpp"
#include "dx_map.hpp"


//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                 {\
                delete p;\
                p=NULL;\
                }\
            }

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

/*
 * The object we want to provide in OLE supports the IUnknown,
 * IDirectInputEffectDriver interfaces.
 *
 * The C++ class, CDirectInputEffectDriver, implements these interfaces with
 * "interface implementations" where the C++ class itself inherits
 * from and implements IUnknown members and then contains
 * other C++ classes that each separately inherit from the other
 * interfaces.  The other classes are the "interface implementations."
 */


/*
 * In this technique you'll generally need forward references
 * like this for use in declaring the object class.
 */
class CImpIDirectInputEffectDriver;
typedef CImpIDirectInputEffectDriver *PCImpIDirectInputEffectDriver;

//The C++ class that manages the actual object.
class CDirectInputEffectDriver : public IUnknown
{
    /*
     * Usually interface implementations will need back pointers
     * to the object itself since this object usually manages
     * the important data members.  In that case, make the
     * interface implementation classes friends of the object.
     */

    friend CImpIDirectInputEffectDriver;

 protected:
 	ULONG           m_cRef;         //Object reference count
    LPUNKNOWN       m_pUnkOuter;    //Controlling unknown

    PFNDESTROYED    m_pfnDestroy;   //To call on closure

    /*
     * I use "m_pImpI" as a prefix to differentiate interface
     * implementations for this object from other interface
     * pointer variables I might hold to other objects, which
     * would be prefixed with "m_pI".
     */
    PCImpIDirectInputEffectDriver  m_pImpIDirectInputEffectDriver;

 public:
     CDirectInputEffectDriver(LPUNKNOWN, PFNDESTROYED);
     ~CDirectInputEffectDriver(void);

     BOOL Init(void);

     //IUnknown members
     STDMETHODIMP         QueryInterface(REFIID, PPVOID);
     STDMETHODIMP_(DWORD) AddRef(void);
     STDMETHODIMP_(DWORD) Release(void);
};


typedef CDirectInputEffectDriver *PCDirectInputEffectDriver;


/*
 * Interface implementation classes are C++ classes that
 * each singly inherit from an interface.  Their IUnknown
 * members delegate calls to CDirectInputEffectDriver's IUnknown members--
 * since IUnknown members affect the entire *object*, and
 * since these interfaces are not the object itself, we must
 * delegate to implement the correct behavior.
 */

class CImpIDirectInputEffectDriver : public IDirectInputEffectDriver
{
 private:
	DWORD		m_cRef;         //For debugging
	PCDirectInputEffectDriver	m_pObj;	//Back pointer for delegation

	// SideWinder Force Feedback Device
	CJoltMidi *m_pJoltMidi;

 public:
    CImpIDirectInputEffectDriver(PCDirectInputEffectDriver);
    ~CImpIDirectInputEffectDriver(void);

	 // CEffect access methods
	 CJoltMidi *CJoltMidiPtrOf() { return m_pJoltMidi; }
	 void SetJoltMidiPtr(CJoltMidi* pJoltMidi) { m_pJoltMidi = pJoltMidi; }

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(DWORD) AddRef(void);
    STDMETHODIMP_(DWORD) Release(void);

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID);
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS);
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE);
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD);
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD);
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE);
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD);
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD);
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD);
};

#endif _SW_OBJEC_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\version.h ===
/*******************************************************************************
**
**       MODULE: VERSION.H
**
**  DESCRIPTION: Contains version numbers for Vger Project
**
**
**       AUTHOR: Manolito Adan
**
**
**      CREATED: 30-Sep-96
**		REVISED: 23-Dec-96
**				 15-Mar-99	waltw	Now get info from ntverp.h & common.ver in
**									NT build tree
**
**
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T    C O R P   1 9 8 1 - 1 9 9 4.
**
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_objec.cpp ===
/****************************************************************************

    MODULE:     	SW_OBJEC.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IUnknown Method(s) for DirectInputEffectDriver Class objects
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
				21-Mar-99	waltw	Removed unreferenced CreateDirectInputEffectDriver
				21-Mar-99	waltw	Moved CJoltMidi initialization from
									CDirectInputEffectDriver::Init to
									CImpIDirectInputEffectDriver::DeviceID

****************************************************************************/
#include "SW_objec.hpp"
#include <crtdbg.h>

//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif
extern HANDLE g_hSWFFDataMutex;


// ****************************************************************************
// *** --- Member functions for base class CDirectInputEffectDriver
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::CDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CDirectInputEffectDriver Object
// Parameters:  LPUNKNOWN 		pUnkOuter	 - Ptr to a controlling unknown.
//				PFNDESTROYED	pfnDestroy   - Call when object is destroyed.
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CDirectInputEffectDriver::CDirectInputEffectDriver(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::CDirectInputEffectDriver()\r\n");
#endif

    m_cRef=0;

    m_pImpIDirectInputEffectDriver=NULL;
    m_pUnkOuter=pUnkOuter;
    m_pfnDestroy=pfnDestroy;
    return;
}

CDirectInputEffectDriver::~CDirectInputEffectDriver(void)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::~CDirectInputEffectDriver()\r\n");
#endif

//Delete the interface implementations created in Init
    DeleteInterfaceImp(m_pImpIDirectInputEffectDriver);
    return;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::Init
// Purpose:		Instantiates the interface implementations for this object.
// Parameters:  none
//				
// Returns:		BOOL	- TRUE if initialization succeeds, FALSE otherwise.
// Algorithm:
//
// Note:
//		Creating the interfaces means creating instances of
//		the interface implementation classes.  The constructor
//		parameters is a pointer to CDirectInputEffectDriver that has the
//		IUnknown functions to which the interface implementations
//		delegate.
//
// ----------------------------------------------------------------------------
BOOL CDirectInputEffectDriver::Init(void)
{
#ifdef _DEBUG
	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::Init\n");
#endif

    m_pImpIDirectInputEffectDriver=new CImpIDirectInputEffectDriver(this);
    if (NULL==m_pImpIDirectInputEffectDriver)
		return FALSE;

	return (TRUE);
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::QueryInterface
// Purpose:		Manages the interfaces for this object which supports the
//				IUnknown, and IDirectInputEffectDriver interfaces.
//
// Parameters:  REFIID riid		- REFIID of the interface to return.
//				PPVOID ppv      - PPVOID in which to store the pointer.
//
//				
// Returns:		HRESULT         NOERROR on success, E_NOINTERFACE if the
//				                interface is not supported.
//
// Algorithm:
//
// Note:
//		IUnknown comes from CDirectInputEffectDriver.  Note that here and in
//		the lines below we do not need to explicitly typecast
//		the object pointers into interface pointers because
//		the vtables are identical.  If we had additional virtual
//		member functions in the object, we would have to cast
//		in order to set the right vtable.  This is demonstrated
//		in the multiple-inheritance version, CObject3.
//
// ----------------------------------------------------------------------------
STDMETHODIMP CDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
	//Always NULL the out-parameters
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    //Other interfaces come from interface implementations
    if (IID_IDirectInputEffectDriver==riid)
        *ppv=m_pImpIDirectInputEffectDriver;

    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::AddRef and CDirectInputEffectDriver::Release
// Purpose:		Reference counting members.  When Release sees a zero count
//				the object destroys itself.
//
// Parameters:  none
//				
// Returns:		DWORD	m_cRef value
//
// Algorithm:
//
// Note:
//
// ----------------------------------------------------------------------------
DWORD CDirectInputEffectDriver::AddRef(void)
{
	return ++m_cRef;
}

DWORD CDirectInputEffectDriver::Release(void)
{
    if (0!=--m_cRef) return m_cRef;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\vxdioctl.hpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.HPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header file for VXDIOCTL.CPP
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL	
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				21-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				23-Mar-99	waltw	Nuked GetStatusGateData (old Jolt code)

****************************************************************************/
#ifndef __VXDIOCTL_HPP__
#define __VXDIOCTL_HPP__

#include <windows.h>
#include "FFeature.h"

#ifndef override
#define override
#endif

//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

//--------------------- Host converted Channel ID Structure -----------------
struct LOCAL_PRODUCT_ID {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
};

// Bitmasks for Response Status - 1.xx (we don't support version 1 - informational only)
//#define STATUS_GATE_1XX			0x08
//#define RUNNING_MASK_1XX			0x04
//#define ACKNACK_MASK_1XX			0x02
//#define SCLK_MASK_1XX				0x01

// Bitmasks for Response Status - Version 2
#define STATUS_GATE_200				0x80
#define RUNNING_MASK_200			0x40
#define ACKNACK_MASK_200			0x20
#define SCLK_MASK_200				0x10

// Bitmasks for Get Status packet dwDeviceStatus member
#define ERROR_STATUS_MASK			0x07	// only bits 0-2 valid
#define BANDWIDTH_OVERFLOW_200		0x0200

// Error code from device (plus own)
#define DEV_ERR_SUCCESS_200			0x00	// Success
#define DEV_ERR_INVALID_ID_200		0x01	// Effect ID is invalid or not found
#define DEV_ERR_BAD_PARAM_200		0x02	// Invalid parameter in data structure
#define DEV_ERR_BAD_CHECKSUM_200	0x03	// Invalid checksum
#define DEV_ERR_BAD_INDEX_200		0x04	// Invalid index sent (modify)
#define DEV_ERR_UNKNOWN_CMD_200		0x05	// Unrecognized command
#define DEV_ERR_PLAY_FULL_200		0x06	// Play List is full, cannot play anymore
#define DEV_ERR_MEM_FULL_200		0x07	// Out of memory
#define DEV_ERR_BANDWIDTH_FULL_200	0x08	// used to signal bandwidth error


/************************************************************************
**
**	@class DriverCommunicator |
**		This is the interface for driver communications
**
*************************************************************************/
class DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DriverCommunicator() {};
		//@cmember destructor
		virtual ~DriverCommunicator() {};

		virtual HRESULT ResetDevice() { return E_NOTIMPL; }
		virtual HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor) { return E_NOTIMPL; }
		virtual HRESULT GetPortByte(ULONG& portByte) { return E_NOTIMPL; }
		virtual HRESULT GetID(LOCAL_PRODUCT_ID& rProductID) { return E_NOTIMPL; }
		virtual HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus) { return E_NOTIMPL; }
		virtual HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex) { return E_NOTIMPL; }
		virtual HRESULT SetBackdoorPort(ULONG ulPortAddress) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoor(BYTE* pMidiData, DWORD dwNumBytes) { return E_NOTIMPL; }
};

/************************************************************************
**
**	@class HIDFeatureCommunicator |
**		Communicates with the HID driver via HID Features (NT5)
**
*************************************************************************/
class HIDFeatureCommunicator :
	public DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		HIDFeatureCommunicator();
		//@cmember destructor
		override ~HIDFeatureCommunicator();

		BOOL Initialize(UINT uJoystickId);
		override HRESULT ResetDevice();
		override HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor);
		override HRESULT GetID(LOCAL_PRODUCT_ID& rProductID);
		override HRESULT GetPortByte(ULONG& portByte);
		override HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus);
		override HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex);
	//@access Private Data Members
	private:
		CForceFeatures m_ForceFeature;
};


extern DriverCommunicator* g_pDriverCommunicator;


#endif __VXDIOCTL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\devices.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    devices.c

Abstract: Control Panel Applet for OLE POS Devices 

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/


#include "pos.h"
#include <initguid.h>
#include <usbioctl.h>


BOOL InitializeDevicesDlg(HWND hwndDlg, BOOL bFirstTime)
{
    RECT rc;
    HWND hwndListCtrl;
    DEV_BROADCAST_DEVICEINTERFACE notificationFilter;

    /* 
     *  Register to receive device notifications from the PnP manager.
     */
    notificationFilter.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    notificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    notificationFilter.dbcc_classguid  = GUID_CLASS_USB_DEVICE;

    ghNotify = RegisterDeviceNotification(hwndDlg, (LPVOID)&notificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE);

    /* 
     *  Split the List Control [report view] into 3/4 for the NAME and 1/4 for the PORT. 
     */
    hwndListCtrl = GetDlgItem(hwndDlg,IDC_DEVICES_LIST);

    if(bFirstTime) {
        GetClientRect(hwndListCtrl, &rc);

        rc.right >>= 2;
        InsertColumn(hwndListCtrl, NAME_COLUMN, IDS_DEVICES_LIST_NAME, (INT)(rc.right*3));   
        InsertColumn(hwndListCtrl, PORT_COLUMN, IDS_DEVICES_LIST_PORT, (INT)(rc.right+2));   

        MoveOK(GetParent(hwndDlg));
    }
    else
        ListView_DeleteAllItems(hwndListCtrl);

    /*
     *  Create an Image List and add installed devices to the List View Control.
     */
    gDeviceCount = 0;
    if(!InitializeImageList(hwndListCtrl) || !FillListViewItems(hwndListCtrl)) {
        DestroyWindow(hwndListCtrl);
        return FALSE; 
    }

    return TRUE;
}


BOOL CALLBACK DevicesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fProcessed = TRUE; 

    switch(uMsg) {

        case WM_INITDIALOG:
            InitializeDevicesDlg(hwndDlg, TRUE);
            break;

        case WM_HELP:           // F1
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, POS_HELP_FILE, HELP_WM_HELP, (DWORD_PTR)gaPosHelpIds);
            break;

        case WM_CONTEXTMENU:    // Right Mouse Click
            WinHelp((HWND)wParam, POS_HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR)gaPosHelpIds);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_DEVICES_REFRESH:
                    InitializeDevicesDlg(hwndDlg, FALSE);
                    break;

                case IDC_DEVICES_TSHOOT:
                    LaunchTroubleShooter();
                    break;
            }
            ListView_SetItemState(GetDlgItem(hwndDlg,IDC_DEVICES_LIST), gDeviceCount-1, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            break;

        case WM_DEVICECHANGE:
            switch((UINT)wParam) {
                case DBT_DEVICEARRIVAL:

                case DBT_DEVICEREMOVECOMPLETE:
                    InitializeDevicesDlg(hwndDlg, FALSE);
            }
            break;

        case WM_CLOSE:

        case WM_DESTROY:
            if(ghNotify) {
                UnregisterDeviceNotification(ghNotify);
                ghNotify = NULL;            
            }
            break;

        default:
            fProcessed = FALSE;
            break;

    }
    return fProcessed;
}


VOID InsertColumn(HWND hwndListCtrl, INT iCol, UINT uMsg, INT iWidth)
{
    LVCOLUMN lvcol;

    lvcol.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvcol.fmt      = LVCFMT_LEFT;
    lvcol.cx       = iWidth;
    lvcol.iSubItem = iCol;
    lvcol.pszText  = (LPTSTR)_alloca(BUFFER_SIZE);

    LoadString(ghInstance, uMsg, lvcol.pszText, BUFFER_SIZE);

    ListView_InsertColumn(hwndListCtrl, iCol, &lvcol); 
}


BOOL InitializeImageList(HWND hwndListCtrl)
{
    HICON hiconItem;
    HIMAGELIST himlSmall;

    /*
     *  Create the Image List for Report View.
     */
    himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                                 GetSystemMetrics(SM_CYSMICON), TRUE, 1, 1); 

    /*
     *  Add an icon to the Image List. 
     */
    hiconItem = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_POS)); 
    ImageList_AddIcon(himlSmall, hiconItem); 
    DeleteObject(hiconItem); 

    /*
     *  Link the Image List to the List View Control. 
     */
    ListView_SetImageList(hwndListCtrl, himlSmall, LVSIL_SMALL); 
    return TRUE; 
}


BOOL FillListViewItems(HWND hwndListCtrl)
{
    HKEY hKey;
    LONG Error;
    LPTSTR pszName, pszPort;
    DWORD dwType, dwSize;
    INT localCount = 0;

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SERIALCOMM,
                         0,
                         KEY_READ,
                         &hKey);

    if(Error != ERROR_SUCCESS)
        return FALSE;    

    pszName = _alloca(MAX_PATH);
    pszPort = _alloca(MAX_PATH);

    while(TRUE) {
        dwType = dwSize = MAX_PATH * sizeof(TCHAR);

        Error = RegEnumValue(hKey,
                             localCount++,
                             pszName,
                             &dwType,
                             NULL,
                             NULL,
                             (LPBYTE)pszPort,
                             &dwSize);

        if(Error != ERROR_SUCCESS) {
            /*
             *  We break out of this loop is when there are no more items.
             *  This is just an extra check in case we fail by some other way.
             */
            if(Error != ERROR_NO_MORE_ITEMS)
                DisplayErrorMessage();
            break;
        }

        if(QueryPrettyName(pszName, pszPort))
            AddItem(hwndListCtrl, gDeviceCount++, pszName, pszPort);  
    }

    RegCloseKey(hKey);
    ListView_SetItemState(hwndListCtrl, gDeviceCount-1, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    return TRUE;
}


BOOL AddItem(HWND hwndListCtrl, INT iItem, LPTSTR pszName, LPTSTR pszPort)
{
    LVITEM lvi;

    lvi.mask      = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE; 
    lvi.state     = 0;
    lvi.stateMask = 0;
    lvi.iImage    = 0;

    lvi.pszText   = pszName;

    lvi.iItem     = iItem;
    lvi.iSubItem  = NAME_COLUMN;

    ListView_InsertItem(hwndListCtrl, &lvi);
    ListView_SetItemText(hwndListCtrl, iItem, PORT_COLUMN, pszPort);

    return TRUE;
}


VOID DisplayErrorMessage()
{
    LPVOID lpMsgBuf;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER 
                | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  GetLastError(),
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPTSTR) &lpMsgBuf,
                  0,
                  NULL);

    MessageBox(NULL, (LPTSTR)lpMsgBuf, TEXT("Error"), MB_OK | MB_ICONINFORMATION);

    LocalFree(lpMsgBuf);
}


BOOL QueryPrettyName(LPTSTR pszName, LPTSTR pszPort)
{
    HANDLE comFile;
    DWORD dwSize;
    BOOL fProcessed;
    TCHAR portBuffer[BUFFER_SIZE];

    /*
     *  Ports beyond COM9 need an explicit [\\.\] in front of them.
     */
    wsprintf(portBuffer, TEXT("\\\\.\\%s"), pszPort);

    comFile = CreateFile(portBuffer, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    /*
     *  Making sure that we are going to query the right device.
     */
    if (comFile == INVALID_HANDLE_VALUE || wcsncmp(pszName, TEXT("\\Device\\POS"), 11))
        return FALSE;

    fProcessed = DeviceIoControl(comFile, 
                                 IOCTL_SERIAL_QUERY_DEVICE_NAME,
                                 NULL,
                                 0,
                                 (LPVOID)pszName,
                                 MAX_PATH,
                                 &dwSize,
                                 NULL);
    CloseHandle(comFile);
    return fProcessed;
}


VOID MoveOK(HWND hwndParent)
{
    HWND hwndButton = GetDlgItem(hwndParent, IDCANCEL);

    if(hwndButton) {
        RECT rc;

        GetWindowRect(hwndButton, &rc);
        DestroyWindow(hwndButton);

        MapWindowPoints(NULL, hwndParent, (LPPOINT)&rc, 2);

        hwndButton = GetDlgItem(hwndParent, IDOK);
        SetWindowPos(hwndButton, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }
}


VOID LaunchTroubleShooter()
{
    TCHAR lpszCmd[MAX_PATH];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    if(LoadString(ghInstance, IDS_TSHOOT_CMD, lpszCmd, MAX_PATH)) {

        ZeroMemory(&si, sizeof(STARTUPINFO));

        si.cb          = sizeof(STARTUPINFO);
        si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;
        si.wShowWindow = SW_NORMAL;

        if (CreateProcess(NULL, lpszCmd, NULL, NULL, FALSE, 0, 0, NULL, &si, &pi)) {
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\vxdioctl.cpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.CPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for communicating with VJoyD min-driver specific
    				to Jolt Midi device
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				17-Jun-97	MEA		Added MAX_RETRY_COUNT on IOCTLs
				21-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				21-Mar-99	waltw	Nuked unused IsHandleValid
				23-Mar-99	waltw	Nuked GetStatusGateData (old Jolt code)

****************************************************************************/

#include "vxdioctl.hpp"
//#include <crtdbg.h>			// For RPT macros
#include <WINIOCTL.H>		// For IOCTL definitions (CTL_CODE)
#include "FFDevice.h"		// For g_ForceFeedbackDevice
#include "sw_error.hpp"		// For Sidewinder HRESULT Error codes
#include "hau_midi.hpp"		// For MAX_RETRY_COUNT and others
#include "midi_obj.hpp"		// Global Jolt midi object and definition
#include "JoyRegst.hpp"		// The differnt types of ACK_NACK
#include "DTrans.h"			// For global Data Transmitter

DriverCommunicator* g_pDriverCommunicator = NULL;
extern DataTransmitter* g_pDataTransmitter;
extern HINSTANCE g_MyInstance;
extern CJoltMidi* g_pJoltMidi;

// Bitmasks for FW Version 
#define FW_MAJOR_VERSION			0xFF00		// wheel
#define FW_MINOR_VERSION			0x00FF		// wheel
//#define FW_MAJOR_VERSION			0x40		// Bit 6	Jolt
//#define FW_MINOR_VERSION			0x3F		// Bit 5-0	Jolt
#define FW_PRODUCT_ID				0xff

/********************************** HIDFeatureCommunicator class ***********************************/

/****************************************
**
**	HIDFeatureCommunicator::HIDFeatureCommunicator()
**
**	@mfunc Constructor for VxD Communications path
**
*****************************************/
HIDFeatureCommunicator::HIDFeatureCommunicator() :
	DriverCommunicator(),
	m_ForceFeature()
{
}

/****************************************
**
**	HIDFeatureCommunicator::~HIDFeatureCommunicator()
**
**	@mfunc Destructor for VxD communications path
**
*****************************************/
HIDFeatureCommunicator::~HIDFeatureCommunicator()
{
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::Initialize(UINT uJoystickId)
**
**	@mfunc Opens the driver for communications via IOCTLs
**
**	@rdesc TRUE if driver opened, FALSE otherwise
**
*****************************************/
BOOL HIDFeatureCommunicator::Initialize
(
	UINT uJoystickId //@parm Joystick ID to use
)
{
	if (g_ForceFeedbackDevice.IsOSNT5() == FALSE)
	{	// Only allowable on NT5
		return FALSE;
	}

	return (SUCCEEDED(m_ForceFeature.Initialize(uJoystickId, g_MyInstance)));
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::ResetDevice()
**
**	@mfunc Sends the driver a device reset IOCTL
**
**	@rdesc S_OK if IOCTL suceeds, 
**
*****************************************/
HRESULT HIDFeatureCommunicator::ResetDevice()
{
	return m_ForceFeature.DoReset();
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor)
**
**	@mfunc IOCTLs a version request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetDriverVersion
(
	DWORD& rdwMajor,	//@parm reference to returned major part of version
	DWORD& rdwMinor		//@parm reference to returned minor part of version
)
{
	ULONG ulVersion = m_ForceFeature.GetVersion();
	rdwMajor = (ulVersion >> 16) & 0x0000FFFF;
	rdwMinor = ulVersion & 0x0000FFFF;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetID(LOCAL_PRODUCT_ID& rProductID)
**
**	@mfunc IOCTLs a product id request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetID
(
	LOCAL_PRODUCT_ID& rProductID	//@parm reference to local product id structure for return value
)
{
	if (rProductID.cBytes != sizeof LOCAL_PRODUCT_ID)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Create report packet and request
	PRODUCT_ID_REPORT productIDReport;
	productIDReport.ProductId.cBytes = sizeof PRODUCT_ID;
	HRESULT hr = m_ForceFeature.GetId(productIDReport);
	if (FAILED(hr))
	{	// There was a problem
		return hr;
	}

	// Decode to local packet
	rProductID.dwProductID = productIDReport.ProductId.dwProductID & FW_PRODUCT_ID;
	rProductID.dwFWMajVersion = 1;
	if (productIDReport.ProductId.dwFWVersion & FW_MAJOR_VERSION)
	{
		rProductID.dwFWMajVersion++;
	}
	rProductID.dwFWMinVersion = productIDReport.ProductId.dwFWVersion & FW_MINOR_VERSION;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetPortByte(ULONG& portByte)
**
**	@mfunc IOCTLs a request for the port byte
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetPortByte
(
	ULONG& portByte	//@parm reference to byte return value for port data
)
{
	ULONG_REPORT report;
	HRESULT hr = m_ForceFeature.GetSync(report);
	portByte = report.uLong;
	return hr;
}


/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatus(JOYCHANNELSTATUS& rChannelStatus)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatus
(
	JOYCHANNELSTATUS& rChannelStatus	//@parm reference to status packet for result
)
{
	if (rChannelStatus.cBytes != sizeof JOYCHANNELSTATUS)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create report packet and perform request
	JOYCHANNELSTATUS_REPORT statusReport;
	statusReport.JoyChannelStatus.cBytes = sizeof JOYCHANNELSTATUS;

	HRESULT hr = S_OK;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		hr = m_ForceFeature.GetStatus(statusReport);

		if (FAILED(hr))
		{	// There was a problem
			if (i > 5)
			{
				Sleep(1);
			}
		}
		else
		{
			break;
		}
	}

	if (SUCCEEDED(hr))
	{	// Get the data from report packet
		::memcpy(g_ForceFeedbackDevice.GetLastStatusPacket(), &(statusReport.JoyChannelStatus), sizeof(JOYCHANNELSTATUS));
		::memcpy(&rChannelStatus, &(statusReport.JoyChannelStatus), sizeof JOYCHANNELSTATUS);
	}
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetAckNack
(
	ACKNACK& rAckNack,	//@parm Structure for return of acking
	USHORT usRegIndex	//@parm Index to what type of ack/nack to do
)
{
	if (rAckNack.cBytes != sizeof ACKNACK)
	{	// Invalid structure size
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Determine how to get the result
	switch (g_ForceFeedbackDevice.GetAckNackMethod(usRegIndex))
	{
		case ACKNACK_NOTHING:
		{	// This one is real easy - do nothing
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		case ACKNACK_BUTTONSTATUS:
		{	// Look at the button status (status gate)
			ULONG_REPORT report;
			report.uLong = 0L;
			HRESULT hr = S_OK;
			if (g_pDataTransmitter && g_pDataTransmitter->NackToggle())
			{
				hr = m_ForceFeature.GetNakAck(report);
			}
			else
			{
				hr = m_ForceFeature.GetAckNak(report);
			}
			if (FAILED(hr))
			{	// There was a problem
				return hr;
			}
#if 0
			// NT5 driver doesn't touch report.uLong on failure (returns above)
			if (report.uLong & ACKNACK_MASK_200)
			{ // NACK error, so get Error code
				rAckNack.dwAckNack = NACK;
				JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
				if (FAILED(hr = GetStatus(statusPacket)))
				{	// Failed to get status error
					return hr;
				}
				rAckNack.dwErrorCode = (statusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return S_OK;
			}
#endif
			// ACK success
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;

			if (report.uLong & RUNNING_MASK_200)
			{	// Current driver and effect running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			}
			else
			{	// Effect not running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return S_OK;
		}
		case ACKNACK_STATUSPACKET:
		{	// Use the Status Packet Error code field to determine ACK or NACK and Get Error code
			JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
 
			HRESULT hr = GetStatus(statusPacket);
			if (FAILED(hr))
			{	// Failed (retried inside GetStatus)
				return SFERR_DRIVER_ERROR;
			}
			rAckNack.dwErrorCode = statusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
			rAckNack.dwAckNack = (rAckNack.dwErrorCode) ? NACK : ACK;
			return S_OK;
		}
		default:
		{	// Someone put garbage in the registry (do nothing)
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    main.c

Abstract: Control Panel Applet for OLE POS Devices

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/


#include "pos.h"


BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG uReason, LPVOID lpvReserved)
{
    switch(uReason) {

        case DLL_PROCESS_ATTACH: {
            ghInstance = hinstDLL;
            DisableThreadLibraryCalls((HMODULE)hinstDLL);
            break;
        }

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

    }
    return TRUE;   
}


LONG APIENTRY CPlApplet(HWND hwndCPl, UINT uMsg, LONG lParam1, LONG lParam2)
{
    LPCPLINFO lpCPlInfo; 
    
    switch(uMsg) {

        case CPL_INIT:
            return TRUE;

        case CPL_GETCOUNT:
            return 1;

        case CPL_INQUIRE: {
            lpCPlInfo = (LPCPLINFO)lParam2; 
            lpCPlInfo->lData  = 0; 
            lpCPlInfo->idIcon = IDI_POS;
            lpCPlInfo->idName = IDS_POS_NAME;
            lpCPlInfo->idInfo = IDS_POS_INFO;
            break; 
        }
        
        case CPL_DBLCLK: {
            OpenPOSPropertySheet(hwndCPl);
            break;
        }

        case CPL_STOP:
            break;

        case CPL_EXIT:
            break;

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pos.rc
//
#define IDS_POS_NAME                    1
#define IDS_POS_INFO                    2
#define IDS_DEVICES_LIST_NAME           3
#define IDS_DEVICES_LIST_PORT           4
#define IDS_TSHOOT_CMD                  5
#define IDD_CPANEL_DEVICES              101
#define IDI_POS                         102
#define IDC_DEVICES_LIST                1000
#define IDC_DEVICES_REFRESH             1001
#define IDC_DEVICES_TSHOOT              1002
#define IDC_DEVICES_INFO                1003
#define IDC_DEVICES_ICON                1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\pos.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pos.c

Abstract: Control Panel Applet for OLE POS Devices 

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/


#include "pos.h"


VOID OpenPOSPropertySheet(HWND hwndCPl)
{
    static HANDLE hMutex;
    HPROPSHEETPAGE rPages[MAX_CPL_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;

    hMutex = CreateMutex(NULL, TRUE, MUTEX_NAME);
    if(GetLastError() == ERROR_ALREADY_EXISTS)
        return;

    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hwndParent = hwndCPl;
    psh.hInstance  = ghInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_POS_NAME);
    psh.pszIcon    = MAKEINTRESOURCE(IDI_POS);
    psh.nPages     = 0;
    psh.nStartPage = 0;
    psh.phpage     = rPages;

    /*
     *  The Devices Tab
     */
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CPANEL_DEVICES);
    psp.pfnDlgProc  = (DLGPROC)DevicesDlgProc;
    psp.lParam      = 0;

    psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
    if(psh.phpage[psh.nPages])
        psh.nPages++;

    PropertySheet(&psh);  // BUGBUG <- What do we do if this fails ??

    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\poshlp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    poshlp.h

Abstract: Control Panel Applet for OLE POS Devices 

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/

#ifndef __POSHLP_H__
#define __POSHLP_H__

/*
 *  Help ID definitions
 */
#define IDH_DEVICES_LIST        2000
#define IDH_DEVICES_REFRESH     2001
#define IDH_DEVICES_TSHOOT      2002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\poshlp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    poshlp.c

Abstract: Control Panel Applet for OLE POS Devices 

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/


#include "pos.h"
#include "poshlp.h"


/*
 *  Context Specific Help IDs
 */
const DWORD gaPosHelpIds[] =
{
    IDC_DEVICES_LIST,       IDH_DEVICES_LIST,
    IDC_DEVICES_REFRESH,    IDH_DEVICES_REFRESH,
    IDC_DEVICES_TSHOOT,     IDH_DEVICES_TSHOOT,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\cpl\pos.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pos.h

Abstract: Control Panel Applet for OLE POS Devices 

Author:

    Karan Mehra [t-karanm]

Environment:

    Win32 mode

Revision History:


--*/

#ifndef __POS_H__
#define __POS_H__

#include <windows.h>
#include <commctrl.h>
#include <cpl.h>
#include <dbt.h>
#include <malloc.h>
#include <stdio.h>
#include <string.h>
#include "resource.h"

/*
 *  Definitions
 */
#define MUTEX_NAME      TEXT("$$$MS_PointOfSale_Cpl$$$")
#define NAME_COLUMN     0
#define PORT_COLUMN     1
#define MAX_CPL_PAGES   1
#define BUFFER_SIZE     64
#define SERIALCOMM      TEXT("Hardware\\DeviceMap\\SerialComm")
#define POS_HELP_FILE   TEXT("pos.hlp")

#define IOCTL_INDEX     0x0800
#define IOCTL_SERIAL_QUERY_DEVICE_NAME  CTL_CODE(FILE_DEVICE_SERIAL_PORT, IOCTL_INDEX + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

/*
 *  Global Variables
 */
HINSTANCE          ghInstance;
INT                gDeviceCount;
HDEVNOTIFY         ghNotify;
extern CONST DWORD gaPosHelpIds[];

/*
 *  Function Prototypes
 */
BOOL WINAPI     DllMain(HINSTANCE hinstDLL, ULONG uReason, LPVOID lpvReserved);
LONG APIENTRY   CPlApplet(HWND hwndCPl, UINT uMsg, LONG lParam1, LONG lParam2);
VOID            OpenPOSPropertySheet(HWND hwndCPl);
BOOL CALLBACK   DevicesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL            InitializeDevicesDlg(HWND hwndDlg, BOOL bFirstTime);
VOID            InsertColumn(HWND hwndListCtrl, INT iCol, UINT uMsg, INT iWidth);
BOOL            InitializeImageList(HWND hwndListCtrl);
BOOL            FillListViewItems(HWND hwndListCtrl);
BOOL            AddItem(HWND hwndListCtrl, INT iItem, LPTSTR pszName, LPTSTR pszPort);
VOID            DisplayErrorMessage();
BOOL            QueryPrettyName(LPTSTR pszName, LPTSTR pszPort);
VOID            MoveOK(HWND hParentWnd);
VOID            LaunchTroubleShooter();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\coindisp.cpp ===
/*
 *  COINDISP.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSCoinDispenser)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSCoinDispenser)




STDMETHODIMP_(LONG) COPOSCoinDispenser::DispenseChange(LONG Amount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSCoinDispenser::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\cashchgr.cpp ===
/*
 *  CASHCHGR.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSCashChanger)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSCashChanger)


STDMETHODIMP_(LONG) COPOSCashChanger::DispenseCash(BSTR CashCounts)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSCashChanger::DispenseChange(LONG Amount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSCashChanger::ReadCashCounts(BSTR* pCashCounts, BOOL* pDiscrepancy)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSCashChanger::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\bumpbar.cpp ===
/*
 *  BUMPBAR.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"



/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSBumpBar)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSBumpBar)



STDMETHODIMP_(LONG) COPOSBumpBar::BumpBarSound(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSBumpBar::SetKeyTranslation(LONG Units, LONG ScanCode, LONG LogicalKey)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\cashdrwr.cpp ===
/*
 *  CASHDRWR.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSCashDrawer)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSCashDrawer)



STDMETHODIMP_(LONG) COPOSCashDrawer::OpenDrawer()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSCashDrawer::WaitForDrawerClose(LONG BeepTimeout, LONG BeepFrequency, LONG BeepDuration, LONG BeepDelay)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSCashDrawer::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\inc\opos.h ===
/*
 *  OPOS.H
 *
 *
 *
 */


// BUGBUG !!! need to make all GUIDs genuine !!!

/*
 *  These GUIDs identify the HID OPOS server and it's interface
 *
 */
DEFINE_GUID( GUID_HID_OPOS_SERVER, 0x4AFA3D51L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC0, 0x06, 0x28, 0x60 );
DEFINE_OLEGUID( IID_HID_OPOS_SERVER, 0x000000a1, 0, 0); // BUGBUG


/*
 *  These GUIDs identify the generic OPOS control and it's interface.
 *
 */
DEFINE_OLEGUID( IID_OPOS_GENERIC_CONTROL, 0x000000a2, 0, 0); // BUGBUG
 


/*
 *  Interface declaration for HID OPOS Server
 */
DECLARE_INTERFACE_(IOPOSService, IClassFactory)
{

    /*
     *  IUnknown methods
     */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) = 0;
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;

    /*
     *  IClassFactory methods
     */
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj) = 0; 
    STDMETHOD(LockServer)(int lock) = 0; 

    /*
     *  IOPOSService methods 
     */
    STDMETHOD_(LONG, CheckHealth)(LONG Level) = 0;
    STDMETHOD_(LONG, Claim)(LONG Timeout) = 0;
    STDMETHOD_(LONG, ClearInput)() = 0;
    STDMETHOD_(LONG, ClearOutput)() = 0;
    STDMETHOD_(LONG, Close)() = 0;
    STDMETHOD_(LONG, COFreezeEvents)(BOOL Freeze) = 0;
    STDMETHOD_(LONG, DirectIO)(LONG Command, LONG* pData, BSTR* pString) = 0;
    STDMETHOD_(LONG, OpenService)(BSTR DeviceClass, BSTR DeviceName, LPDISPATCH pDispatch) = 0;
    // STDMETHOD_(LONG, Release)() = 0;  // BUGBUG - override IUnknown ?

    STDMETHOD_(LONG, GetPropertyNumber)(LONG PropIndex) = 0;
    STDMETHOD_(BSTR, GetPropertyString)(LONG PropIndex) = 0;
    STDMETHOD_(void, SetPropertyNumber)(LONG PropIndex, LONG Number) = 0;
    STDMETHOD_(void, SetPropertyString)(LONG PropIndex, BSTR String) = 0;

    // BUGBUG -  + Get/Set type methods
    // BUGBUG -  + events

};

/*
 *  Interface declaration for generic HID OPOS Control
 */
DECLARE_INTERFACE_(IOPOSControl, IClassFactory)
{

    /*
     *  IUnknown methods
     */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) = 0;
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;

    /*
     *  IClassFactory methods
     */
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj) = 0; 
    STDMETHOD(LockServer)(int lock) = 0; 

    /*
     *  IOPOSControl methods 
     */
    STDMETHOD_(LONG, Open)(BSTR DeviceName) = 0; 
    STDMETHOD_(LONG, Close)() = 0;       

    STDMETHOD_(LONG, CheckHealth)(LONG Level) = 0;
    STDMETHOD_(LONG, Claim)(LONG Timeout) = 0;
    STDMETHOD_(LONG, ClearInput)() = 0;
    STDMETHOD_(LONG, ClearOutput)() = 0;
    STDMETHOD_(LONG, DirectIO)(LONG Command, LONG* pData, BSTR* pString) = 0;
    // STDMETHOD_(LONG, Release)() = 0;    // BUGBUG overrides IUnknown ?

    STDMETHOD_(void, SOData)(LONG Status) = 0;
    STDMETHOD_(void, SODirectIO)(LONG EventNumber, LONG* pData, BSTR* pString) = 0;
    STDMETHOD_(void, DirectIOEvent)(LONG EventNumber, LONG* pData, BSTR* pString) = 0;
    STDMETHOD_(void, SOError)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
    // BUGBUG - moved to sub-ifaces STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
    STDMETHOD_(void, SOOutputComplete)(LONG OutputID) = 0;
    STDMETHOD_(void, OutputCompleteEvent)(LONG OutputID) = 0;
    STDMETHOD_(void, SOStatusUpdate)(LONG Data) = 0;
    // BUGBUG - moved to sub-ifaces STDMETHOD_(void, StatusUpdateEvent)(LONG Data) = 0;
    STDMETHOD_(LONG, SOProcessID)() = 0;
};


/*
 *  Interface declaration for specific control classes.
 *  Each inherits from the generic control interface class.
 */
DECLARE_INTERFACE_(IOPOSBumpBar, IOPOSControl)
{
    STDMETHOD_(LONG, BumpBarSound)(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait) = 0;
    STDMETHOD_(LONG, SetKeyTranslation)(LONG Units, LONG ScanCode, LONG LogicalKey) = 0;
};
DECLARE_INTERFACE_(IOPOSCashChanger, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, DispenseCash)(BSTR CashCounts) = 0;
    STDMETHOD_(LONG, DispenseChange)(LONG Amount) = 0;
    STDMETHOD_(LONG, ReadCashCounts)(BSTR* pCashCounts, BOOL* pDiscrepancy) = 0;

    // events
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
};
DECLARE_INTERFACE_(IOPOSCashDrawer, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, OpenDrawer)() = 0;
    STDMETHOD_(LONG, WaitForDrawerClose)(LONG BeepTimeout, LONG BeepFrequency, LONG BeepDuration, LONG BeepDelay) = 0;

    // events
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
};
DECLARE_INTERFACE_(IOPOSCoinDispenser, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, DispenseChange)(LONG Amount) = 0;

    // events
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
};
DECLARE_INTERFACE_(IOPOSFiscalPrinter, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginFiscalDocument)(LONG DocumentAmount) = 0;
    STDMETHOD_(LONG, BeginFiscalReceipt)(BOOL PrintHeader) = 0;
    STDMETHOD_(LONG, BeginFixedOutput)(LONG Station, LONG DocumentType) = 0;
    STDMETHOD_(LONG, BeginInsertion)(LONG Timeout) = 0;
    STDMETHOD_(LONG, BeginItemList)(LONG VatID) = 0;
    STDMETHOD_(LONG, BeginNonFiscal)() = 0;
    STDMETHOD_(LONG, BeginRemoval)(LONG Timeout) = 0;
    STDMETHOD_(LONG, BeginTraining)() = 0;
    STDMETHOD_(LONG, ClearError)() = 0;
    STDMETHOD_(LONG, EndFiscalDocument)() = 0;
    STDMETHOD_(LONG, EndFiscalReceipt)(BOOL PrintHeader) = 0;
    STDMETHOD_(LONG, EndFixedOutput)() = 0;
    STDMETHOD_(LONG, EndInsertion)() = 0;
    STDMETHOD_(LONG, EndItemList)() = 0;
    STDMETHOD_(LONG, EndNonFiscal)() = 0;
    STDMETHOD_(LONG, EndRemoval)() = 0;
    STDMETHOD_(LONG, EndTraining)() = 0;
    STDMETHOD_(LONG, GetData)(LONG DataItem, LONG* OptArgs, BSTR* Data) = 0;
    STDMETHOD_(LONG, GetDate)(BSTR* Date) = 0;
    STDMETHOD_(LONG, GetTotalizer)(LONG VatID, LONG OptArgs, BSTR* Data) = 0;
    STDMETHOD_(LONG, GetVatEntry)(LONG VatID, LONG OptArgs, LONG* VatRate) = 0;
    STDMETHOD_(LONG, PrintDuplicateReceipt)() = 0;
    STDMETHOD_(LONG, PrintFiscalDocumentLine)(BSTR DocumentLine) = 0;
    STDMETHOD_(LONG, PrintFixedOutput)(LONG DocumentType, LONG LineNumber, BSTR Data) = 0;
    STDMETHOD_(LONG, PrintNormal)(LONG Station, BSTR Data) = 0;
    STDMETHOD_(LONG, PrintPeriodicTotalsReport)(BSTR Date1, BSTR Date2) = 0;
    STDMETHOD_(LONG, PrintPowerLossReport)() = 0;
    STDMETHOD_(LONG, PrintRecItem)(BSTR Description, CURRENCY Price, LONG Quantity, LONG VatInfo, CURRENCY OptUnitPrice, BSTR UnitName) = 0;
    STDMETHOD_(LONG, PrintRecItemAdjustment)(LONG AdjustmentType, BSTR Description, CURRENCY Amount, LONG VatInfo) = 0;
    STDMETHOD_(LONG, PrintRecMessage)(BSTR Message) = 0;
    STDMETHOD_(LONG, PrintRecNotPaid)(BSTR Description, CURRENCY Amount) = 0;
    STDMETHOD_(LONG, PrintRecRefund)(BSTR Description, CURRENCY Amount, LONG VatInfo) = 0;
    STDMETHOD_(LONG, PrintRecSubtotal)(CURRENCY Amount) = 0;
    STDMETHOD_(LONG, PrintRecSubtotalAdjustment)(LONG AdjustmentType, BSTR Description, CURRENCY Amount) = 0;
    STDMETHOD_(LONG, PrintRecTotal)(CURRENCY Total, CURRENCY Payment, BSTR Description) = 0;
    STDMETHOD_(LONG, PrintRecVoid)(BSTR Description) = 0;
    STDMETHOD_(LONG, PrintRecVoidItem)(BSTR Description, CURRENCY Amount, LONG Quantity, LONG AdjustmentType, CURRENCY Adjustment, LONG VatInfo) = 0;
    STDMETHOD_(LONG, PrintReport)(LONG ReportType, BSTR StartNum, BSTR EndNum) = 0;
    STDMETHOD_(LONG, PrintXReport)() = 0;
    STDMETHOD_(LONG, PrintZReport)() = 0;
    STDMETHOD_(LONG, ResetPrinter)() = 0;
    STDMETHOD_(LONG, SetDate)(BSTR Date) = 0;
    STDMETHOD_(LONG, SetHeaderLine)(LONG LineNumber, BSTR Text, BOOL DoubleWidth) = 0;
    STDMETHOD_(LONG, SetPOSID)(BSTR POSID, BSTR CashierID) = 0;
    STDMETHOD_(LONG, SetStoreFiscalID)(BSTR ID) = 0;
    STDMETHOD_(LONG, SetTrailerLine)(LONG LineNumber, BSTR Text, BOOL DoubleWidth) = 0;
    STDMETHOD_(LONG, SetVatTable)() = 0;
    STDMETHOD_(LONG, SetVatValue)(LONG VatID, BSTR VatValue) = 0;
    STDMETHOD_(LONG, VerifyItem)(BSTR ItemName, LONG VatID) = 0;

    // events
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
    STDMETHOD_(void, StatusUpdateEvent)(LONG Data) = 0;
};
DECLARE_INTERFACE_(IOPOSHardTotals, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginTrans)() = 0;
    STDMETHOD_(LONG, ClaimFile)(LONG HTotalsFile, LONG Timeout) = 0;
    STDMETHOD_(LONG, CommitTrans)() = 0;
    STDMETHOD_(LONG, Create)(BSTR FileName, LONG* pHTotalsFile, LONG Size, BOOL ErrorDetection) = 0;
    STDMETHOD_(LONG, Delete)(BSTR FileName) = 0;
    STDMETHOD_(LONG, Find)(BSTR FileName, LONG* pHTotalsFile, LONG* pSize) = 0;
    STDMETHOD_(LONG, FindByIndex)(LONG Index, BSTR* pFileName) = 0;
    STDMETHOD_(LONG, Read)(LONG HTotalsFile, BSTR* pData, LONG Offset, LONG Count) = 0;
    STDMETHOD_(LONG, RecalculateValidationData)(LONG HTotalsFile) = 0;
    STDMETHOD_(LONG, ReleaseFile)(LONG HTotalsFile) = 0;
    STDMETHOD_(LONG, Rename)(LONG HTotalsFile, BSTR FileName) = 0;
    STDMETHOD_(LONG, Rollback)() = 0;
    STDMETHOD_(LONG, SetAll)(LONG HTotalsFile, LONG Value) = 0;
    STDMETHOD_(LONG, ValidateData)(LONG HTotalsFile) = 0;
    STDMETHOD_(LONG, Write)(LONG HTotalsFile, BSTR Data, LONG Offset, LONG Count) = 0;
};
DECLARE_INTERFACE_(IOPOSKeyLock, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, WaitForKeylockChange)(LONG KeyPosition, LONG Timeout) = 0;

    // events
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
};
DECLARE_INTERFACE_(IOPOSLineDisplay, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, ClearDescriptors)() = 0;
    STDMETHOD_(LONG, ClearText)() = 0;
    // BUGBUG conflict ???   STDMETHOD_(LONG, CreateWindow)(LONG ViewportRow, LONG ViewportColumn, LONG ViewportHeight, LONG ViewportWidth, LONG WindowHeight, LONG WindowWidth) = 0;
    STDMETHOD_(LONG, DestroyWindow)() = 0;
    STDMETHOD_(LONG, DisplayText)(BSTR Data, LONG Attribute) = 0;
    STDMETHOD_(LONG, DisplayTextAt)(LONG Row, LONG Column, BSTR Data, LONG Attribute) = 0;
    STDMETHOD_(LONG, RefreshWindow)(LONG Window) = 0;
    STDMETHOD_(LONG, ScrollText)(LONG Direction, LONG Units) = 0;
    STDMETHOD_(LONG, SetDescriptor)(LONG Descriptor, LONG Attribute) = 0;
};
DECLARE_INTERFACE_(IOPOSMICR, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginInsertion)(LONG Timeout) = 0;
    STDMETHOD_(LONG, BeginRemoval)(LONG Timeout) = 0;
    STDMETHOD_(LONG, EndInsertion)() = 0;
    STDMETHOD_(LONG, EndRemoval)() = 0;

    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSMSR, IOPOSControl)
{
    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSPinPad, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginEFTTransaction)(BSTR PINPadSystem, LONG TransactionHost) = 0;
    STDMETHOD_(LONG, ComputeMAC)(BSTR InMsg, BSTR* pOutMsg) = 0;
    STDMETHOD_(LONG, EnablePINEntry)() = 0;
    STDMETHOD_(LONG, EndEFTTransaction)(LONG CompletionCode) = 0;
    STDMETHOD_(LONG, UpdateKey)(LONG KeyNum, BSTR Key) = 0;
    STDMETHOD_(BOOL, VerifyMAC)(BSTR Message) = 0;

    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSKeyboard, IOPOSControl)
{
    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSPrinter, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginInsertion)(LONG Timeout) = 0;
    STDMETHOD_(LONG, BeginRemoval)(LONG Timeout) = 0;
    STDMETHOD_(LONG, CutPaper)(LONG Percentage) = 0;
    STDMETHOD_(LONG, EndInsertion)() = 0;
    STDMETHOD_(LONG, EndRemoval)() = 0;
    STDMETHOD_(LONG, PrintBarCode)(LONG Station, BSTR Data, LONG Symbology, LONG Height, LONG Width, LONG Alignment, LONG TextPosition) = 0;
    STDMETHOD_(LONG, PrintBitmap)(LONG Station, BSTR FileName, LONG Width, LONG Alignment) = 0;
    STDMETHOD_(LONG, PrintImmediate)(LONG Station, BSTR Data) = 0;
    STDMETHOD_(LONG, PrintNormal)(LONG Station, BSTR Data) = 0;
    STDMETHOD_(LONG, PrintTwoNormal)(LONG Stations, BSTR Data1, BSTR Data2) = 0;
    STDMETHOD_(LONG, RotatePrint)(LONG Station, LONG Rotation) = 0;
    STDMETHOD_(LONG, SetBitmap)(LONG BitmapNumber, LONG Station, BSTR FileName, LONG Width, LONG Alignment) = 0;
    STDMETHOD_(LONG, SetLogo)(LONG Location, BSTR Data) = 0;
    STDMETHOD_(LONG, TransactionPrint)(LONG Station, LONG Control) = 0;
    STDMETHOD_(LONG, ValidateData)(LONG Station, BSTR Data) = 0;

    // events
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
};
DECLARE_INTERFACE_(IOPOSRemoteOrderDisplay, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, ClearVideo)(LONG Units, LONG Attribute) = 0;
    STDMETHOD_(LONG, ClearVideoRegion)(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute) = 0;
    STDMETHOD_(LONG, ControlClock)(LONG Units, LONG Function, LONG ClockId, LONG Hour, LONG Min, LONG Sec, LONG Row, LONG Column, LONG Attribute, LONG Mode) = 0;
    STDMETHOD_(LONG, ControlCursor)(LONG Units, LONG Function) = 0;
    STDMETHOD_(LONG, CopyVideoRegion)(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG TargetRow, LONG TargetColumn) = 0;
    STDMETHOD_(LONG, DisplayData)(LONG Units, LONG Row, LONG Column, LONG Attribute, BSTR Data) = 0;
    STDMETHOD_(LONG, DrawBox)(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute, LONG BorderType) = 0;
    STDMETHOD_(LONG, FreeVideoRegion)(LONG Units, LONG BufferId) = 0;
    STDMETHOD_(LONG, ResetVideo)(LONG Units) = 0; 
    STDMETHOD_(LONG, RestoreVideoRegion)(LONG Units, LONG TargetRow, LONG TargetColumn, LONG BufferId) = 0;
    STDMETHOD_(LONG, SaveVideoRegion)(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG BufferId) = 0;
    STDMETHOD_(LONG, SelectChararacterSet)(LONG Units, LONG CharacterSet) = 0;
    STDMETHOD_(LONG, SetCursor)(LONG Units, LONG Row, LONG Column) = 0;
    STDMETHOD_(LONG, TransactionDisplay)(LONG Units, LONG Function) = 0;
    STDMETHOD_(LONG, UpdateVideoRegionAttribute)(LONG Units, LONG Function, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute) = 0;
    STDMETHOD_(LONG, VideoSound)(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait) = 0;

    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    // BUGBUG - override ?  STDMETHOD_(void, OutputCompleteEvent)(LONG OutputID) = 0;
    STDMETHOD_(void, StatusUpdateEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSScale, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, DisplayText)(BSTR Data) = 0;
    STDMETHOD_(LONG, ReadWeight)(LONG* pWeightData, LONG Timeout) = 0;
    STDMETHOD_(LONG, ZeroScale)() = 0;

    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
    
};
DECLARE_INTERFACE_(IOPOSScanner, IOPOSControl)
{
    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSSignatureCapture, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, BeginCapture)(BSTR FormName) = 0;
    STDMETHOD_(LONG, EndCapture)() = 0;

    // events
    STDMETHOD_(void, DataEvent)(LONG Status) = 0;
    STDMETHOD_(void, ErrorEvent)(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse) = 0;
};
DECLARE_INTERFACE_(IOPOSToneIndicator, IOPOSControl)
{
    // methods
    STDMETHOD_(LONG, Sound)(LONG NumberOfCycles, LONG InterSoundWait) = 0;
    STDMETHOD_(LONG, SoundImmediate)() = 0;
};





/*
 *  OPOS status values
 */
#define OPOS_SUCCESS        0
#define OPOS_E_CLOSED       101
#define OPOS_E_CLAIMED      102
#define OPOS_E_NOTCLAIMED   103
#define OPOS_E_NOSERVICE	104
#define OPOS_E_DISABLED     105
#define OPOS_E_ILLEGAL	    106
#define OPOS_E_NOHARDWARE   107
#define OPOS_E_OFFLINE      108
#define OPOS_E_NOEXIST	    109
#define OPOS_E_EXISTS       110
#define OPOS_E_FAILURE      111
#define OPOS_E_TIMEOUT      112    
#define OPOS_E_BUSY         113
#define OPOS_E_EXTENDED     114

#define OPOSERREXT  200


/*
 *  OPOS state values
 */
#define OPOS_S_CLOSED   1
#define OPOS_S_IDLE     2
#define OPOS_S_BUSY     3
#define OPOS_S_ERROR    4



/*
 * OPOS "BinaryConversion" Property Constants
 */
#define OPOS_BC_NONE        0
#define OPOS_BC_NIBBLE      1
#define OPOS_BC_DECIMAL     2


/*
 *  "CheckHealth" Method: "Level" Parameter Constants
 */
#define OPOS_CH_INTERNAL        1
#define OPOS_CH_EXTERNAL        2
#define OPOS_CH_INTERACTIVE     3


/*
 *  OPOS "CapPowerReporting", "PowerState", "PowerNotify" Property
 */
#define OPOS_PR_NONE            0
#define OPOS_PR_STANDARD        1
#define OPOS_PR_ADVANCED        2

#define OPOS_PN_DISABLED        0
#define OPOS_PN_ENABLED         1

#define OPOS_PS_UNKNOWN         2000
#define OPOS_PS_ONLINE          2001
#define OPOS_PS_OFF             2002
#define OPOS_PS_OFFLINE         2003
#define OPOS_PS_OFF_OFFLINE     2004


/*
 *  "ErrorEvent" Event: "ErrorLocus" Parameter Constants
 */
#define OPOS_EL_OUTPUT          1
#define OPOS_EL_INPUT           2
#define OPOS_EL_INPUT_DATA      3


/*
 *  "ErrorEvent" Event: "ErrorResponse" Constants
 */
#define OPOS_ER_RETRY           11
#define OPOS_ER_CLEAR           12
#define OPOS_ER_CONTINUEINPUT   13


/*
 *  "StatusUpdateEvent" Event: Common "Status" Constants
 */
#define OPOS_SUE_POWER_ONLINE       2001
#define OPOS_SUE_POWER_OFF          2002
#define OPOS_SUE_POWER_OFFLINE      2003
#define OPOS_SUE_POWER_OFF_OFFLINE  2004


/*
 *  General Constants
 */

#define OPOS_FOREVER        -1



/*
 **********************************************************************
 *
 *      BUMP BAR header section
 *
 **********************************************************************
 */
#define BB_UID_1            (1 << 0)
#define BB_UID_2            (1 << 1)
#define BB_UID_3            (1 << 2)
#define BB_UID_4            (1 << 3)
#define BB_UID_5            (1 << 4)
#define BB_UID_6            (1 << 5)
#define BB_UID_7            (1 << 6)
#define BB_UID_8            (1 << 7)
#define BB_UID_9            (1 << 8)
#define BB_UID_10           (1 << 9)
#define BB_UID_11           (1 << 10)
#define BB_UID_12           (1 << 11)
#define BB_UID_13           (1 << 12)
#define BB_UID_14           (1 << 13)
#define BB_UID_15           (1 << 14)
#define BB_UID_16           (1 << 15)
#define BB_UID_17           (1 << 16)
#define BB_UID_18           (1 << 17)
#define BB_UID_19           (1 << 18)
#define BB_UID_20           (1 << 19)
#define BB_UID_21           (1 << 20)
#define BB_UID_22           (1 << 21)
#define BB_UID_23           (1 << 22)
#define BB_UID_24           (1 << 23)
#define BB_UID_25           (1 << 24)
#define BB_UID_26           (1 << 25)
#define BB_UID_27           (1 << 26)
#define BB_UID_28           (1 << 27)
#define BB_UID_29           (1 << 28)
#define BB_UID_30           (1 << 29)
#define BB_UID_31           (1 << 30)
#define BB_UID_32           (1 << 31)


/*
 *  "DataEvent" Event: "Status" Parameter Constants
 */
#define BB_DE_KEY               0x01



/*
 **********************************************************************
 *
 *      CASH DRAWER header section
 *
 **********************************************************************
 */

#define CASH_SUE_DRAWERCLOSED   0
#define CASH_SUE_DRAWEROPEN     1



/*
 **********************************************************************
 *
 *      CASH CHANGER header section
 *
 **********************************************************************
 */

#define CHAN_STATUS_OK          0   // DeviceStatus, FullStatus

#define CHAN_STATUS_EMPTY       11  // DeviceStatus, StatusUpdateEvent
#define CHAN_STATUS_NEAREMPTY   12  // DeviceStatus, StatusUpdateEvent
#define CHAN_STATUS_EMPTYOK     13  // StatusUpdateEvent

#define CHAN_STATUS_FULL        21  // FullStatus, StatusUpdateEvent
#define CHAN_STATUS_NEARFULL    22  // FullStatus, StatusUpdateEvent
#define CHAN_STATUS_FULLOK      23  // StatusUpdateEvent

#define CHAN_STATUS_JAM         31  // DeviceStatus, StatusUpdateEvent
#define CHAN_STATUS_JAMOK       32  // StatusUpdateEvent

#define CHAN_STATUS_ASYNC       91  // StatusUpdateEvent


/*
 *  "ResultCodeExtended" Property Constants for Cash Changer
 */
#define OPOS_ECHAN_OVERDISPENSE     (1 + OPOSERREXT)


/*
 **********************************************************************
 *
 *      COIN DISPENSER header section
 *
 **********************************************************************
 */

#define COIN_STATUS_OK          1
#define COIN_STATUS_EMPTY       2
#define COIN_STATUS_NEAREMPTY   3
#define COIN_STATUS_JAM         4



/*
 **********************************************************************
 *
 *      LINE DISPLAY header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "CapBlink" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_CB_NOBLINK      0
#define DISP_CB_BLINKALL     1
#define DISP_CB_BLINKEACH    2


/////////////////////////////////////////////////////////////////////
// "CapCharacterSet" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_CCS_NUMERIC        0
#define DISP_CCS_ALPHA          1
#define DISP_CCS_ASCII        998
#define DISP_CCS_KANA          10
#define DISP_CCS_KANJI         11


/////////////////////////////////////////////////////////////////////
// "CharacterSet" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_CS_ASCII         998
#define DISP_CS_WINDOWS       999


/////////////////////////////////////////////////////////////////////
// "MarqueeType" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_MT_NONE          0
#define DISP_MT_UP            1
#define DISP_MT_DOWN          2
#define DISP_MT_LEFT          3
#define DISP_MT_RIGHT         4
#define DISP_MT_INIT          5


/////////////////////////////////////////////////////////////////////
// "MarqueeFormat" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_MF_WALK          0
#define DISP_MF_PLACE         1


/////////////////////////////////////////////////////////////////////
// "DisplayText" Method: "Attribute" Property Constants
// "DisplayTextAt" Method: "Attribute" Property Constants
/////////////////////////////////////////////////////////////////////

#define DISP_DT_NORMAL        0
#define DISP_DT_BLINK         1


/////////////////////////////////////////////////////////////////////
// "ScrollText" Method: "Direction" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define DISP_ST_UP            1
#define DISP_ST_DOWN          2
#define DISP_ST_LEFT          3
#define DISP_ST_RIGHT         4


/////////////////////////////////////////////////////////////////////
// "SetDescriptor" Method: "Attribute" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define DISP_SD_OFF           0
#define DISP_SD_ON            1
#define DISP_SD_BLINK         2



/*
 **********************************************************************
 *
 *      FISCAL PRINTER header section
 *
 **********************************************************************
 */

#define FPTR_S_JOURNAL                    1
#define FPTR_S_RECEIPT                    2
#define FPTR_S_SLIP                       4

#define FPTR_S_JOURNAL_RECEIPT  (FPTR_S_JOURNAL | FPTR_S_RECEIPT)


/////////////////////////////////////////////////////////////////////
// "CountryCode" Property Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_CC_BRAZIL                     1
#define FPTR_CC_GREECE                     2
#define FPTR_CC_HUNGARY                    3
#define FPTR_CC_ITALY                      4
#define FPTR_CC_POLAND                     5
#define FPTR_CC_TURKEY                     6


/////////////////////////////////////////////////////////////////////
// "ErrorLevel" Property Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_EL_NONE                       1
#define FPTR_EL_RECOVERABLE                2
#define FPTR_EL_FATAL                      3
#define FPTR_EL_BLOCKED                    4


/////////////////////////////////////////////////////////////////////
// "ErrorState", "PrinterState" Property Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_PS_MONITOR                    1
#define FPTR_PS_FISCAL_RECEIPT             2
#define FPTR_PS_FISCAL_RECEIPT_TOTAL       3
#define FPTR_PS_FISCAL_RECEIPT_ENDING      4
#define FPTR_PS_FISCAL_DOCUMENT            5
#define FPTR_PS_FIXED_OUTPUT               6
#define FPTR_PS_ITEM_LIST                  7
#define FPTR_PS_LOCKED                     8
#define FPTR_PS_NONFISCAL                  9
#define FPTR_PS_REPORT                    10


/////////////////////////////////////////////////////////////////////
// "SlipSelection" Property Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_SS_FULL_LENGTH                1
#define FPTR_SS_VALIDATION                 2


/////////////////////////////////////////////////////////////////////
// "GetData" Method Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_GD_CURRENT_TOTAL              1
#define FPTR_GD_DAILY_TOTAL                2
#define FPTR_GD_RECEIPT_NUMBER             3
#define FPTR_GD_REFUND                     4
#define FPTR_GD_NOT_PAID                   5
#define FPTR_GD_MID_VOID                   6
#define FPTR_GD_Z_REPORT                   7
#define FPTR_GD_GRANDT_TOTAL               8
#define FPTR_GD_PRINTER_ID                 9
#define FPTR_GD_FIRMWARE                  10
#define FPTR_GD_RESTART                   11


/////////////////////////////////////////////////////////////////////
// "AdjustmentType" arguments in diverse methods
/////////////////////////////////////////////////////////////////////

#define FPTR_AT_AMOUNT_DISCOUNT            1
#define FPTR_AT_AMOUNT_SURCHARGE           2
#define FPTR_AT_PERCENTAGE_DISCOUNT        3
#define FPTR_AT_PERCENTAGE_SURCHARGE       4


/////////////////////////////////////////////////////////////////////
// "ReportType" argument in "PrintReport" method
/////////////////////////////////////////////////////////////////////

#define FPTR_RT_ORDINAL                    1
#define FPTR_RT_DATE                       2


/////////////////////////////////////////////////////////////////////
// "StatusUpdateEvent" Event: "Data" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define FPTR_SUE_COVER_OPEN                11
#define FPTR_SUE_COVER_OK                  12

#define FPTR_SUE_JRN_EMPTY                 21
#define FPTR_SUE_JRN_NEAREMPTY             22
#define FPTR_SUE_JRN_PAPEROK               23

#define FPTR_SUE_REC_EMPTY                 24
#define FPTR_SUE_REC_NEAREMPTY             25
#define FPTR_SUE_REC_PAPEROK               26

#define FPTR_SUE_SLP_EMPTY                 27
#define FPTR_SUE_SLP_NEAREMPTY             28
#define FPTR_SUE_SLP_PAPEROK               29

#define FPTR_SUE_IDLE                    1001


/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for Fiscal Printer
/////////////////////////////////////////////////////////////////////

#define OPOS_EFPTR_COVER_OPEN                   (1 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_JRN_EMPTY                    (2 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_REC_EMPTY                    (3 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_SLP_EMPTY                    (4 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_SLP_FORM                     (5 + OPOSERREXT) // EndRemoval
#define OPOS_EFPTR_MISSING_DEVICES              (6 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_WRONG_STATE                  (7 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_TECHNICAL_ASSISTANCE         (8 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_CLOCK_ERROR                  (9 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_FISCAL_MEMORY_FULL           (10 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_FISCAL_MEMORY_DISCONNECTED   (11 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_FISCAL_TOTALS_ERROR          (12 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_ITEM_QUANTITY            (13 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_ITEM_AMOUNT              (14 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_ITEM_DESCRIPTION         (15 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_RECEIPT_TOTAL_OVERFLOW       (16 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_VAT                      (17 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_PRICE                    (18 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_BAD_DATE                     (19 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_NEGATIVE_TOTAL               (20 + OPOSERREXT) // (Several)
#define OPOS_EFPTR_WORD_NOT_ALLOWED             (21 + OPOSERREXT) // (Several)



/*
 **********************************************************************
 *
 *      POS KEYBOARD header section
 *
 **********************************************************************
 */


#define KBD_ET_DOWN             1
#define KBD_ET_DOWN_UP          2


/////////////////////////////////////////////////////////////////////
// "POSKeyEventType" Property Constants
/////////////////////////////////////////////////////////////////////

#define KBD_KET_KEYDOWN         1
#define KBD_KET_KEYUP           2


/*
 **********************************************************************
 *
 *      KEYLOCK header section
 *
 **********************************************************************
 */

#define LOCK_KP_ANY           0    // WaitForKeylockChange Only
#define LOCK_KP_LOCK          1
#define LOCK_KP_NORM          2
#define LOCK_KP_SUPR          3


/*
 **********************************************************************
 *
 *      MICR header section
 *
 **********************************************************************
 */

#define MICR_CT_PERSONAL       1
#define MICR_CT_BUSINESS       2
#define MICR_CT_UNKNOWN       99


/////////////////////////////////////////////////////////////////////
// "CountryCode" Property Constants
/////////////////////////////////////////////////////////////////////

#define MICR_CC_USA            1
#define MICR_CC_CANADA         2
#define MICR_CC_MEXICO         3
#define MICR_CC_UNKNOWN       99


/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for MICR
/////////////////////////////////////////////////////////////////////

#define OPOS_EMICR_NOCHECK    (1 + OPOSERREXT) // EndInsertion
#define OPOS_EMICR_CHECK      (2 + OPOSERREXT) // EndRemoval


/*
 **********************************************************************
 *
 *      MSR header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "TracksToRead" Property Constants
/////////////////////////////////////////////////////////////////////

#define MSR_TR_1              1
#define MSR_TR_2              2
#define MSR_TR_3              4

#define MSR_TR_1_2            (MSR_TR_1 | MSR_TR_2)
#define MSR_TR_1_3            (MSR_TR_1 | MSR_TR_3)
#define MSR_TR_2_3            (MSR_TR_2 | MSR_TR_3)

#define MSR_TR_1_2_3          (MSR_TR_1 | MSR_TR_2 | MSR_TR_3)


/////////////////////////////////////////////////////////////////////
// "ErrorReportingType" Property Constants
/////////////////////////////////////////////////////////////////////

#define MSR_ERT_CARD          0
#define MSR_ERT_TRACK         1


/////////////////////////////////////////////////////////////////////
// "ErrorEvent" Event: "ResultCodeExtended" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define OPOS_EMSR_START       (1 + OPOSERREXT)
#define OPOS_EMSR_END         (2 + OPOSERREXT)
#define OPOS_EMSR_PARITY      (3 + OPOSERREXT)
#define OPOS_EMSR_LRC         (4 + OPOSERREXT)


/*
 **********************************************************************
 *
 *      PIN PAD header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "CapDisplay" Property Constants
/////////////////////////////////////////////////////////////////////

#define PPAD_DISP_UNRESTRICTED           1
#define PPAD_DISP_PINRESTRICTED          2
#define PPAD_DISP_RESTRICTED_LIST        3
#define PPAD_DISP_RESTRICTED_ORDER       4


/////////////////////////////////////////////////////////////////////
// "AvailablePromptsList" and "Prompt" Property Constants
/////////////////////////////////////////////////////////////////////

#define PPAD_MSG_ENTERPIN                1
#define PPAD_MSG_PLEASEWAIT              2
#define PPAD_MSG_ENTERVALIDPIN           3
#define PPAD_MSG_RETRIESEXCEEDED         4
#define PPAD_MSG_APPROVED                5
#define PPAD_MSG_DECLINED                6
#define PPAD_MSG_CANCELED                7
#define PPAD_MSG_AMOUNTOK                8
#define PPAD_MSG_NOTREADY                9
#define PPAD_MSG_IDLE                    10
#define PPAD_MSG_SLIDE_CARD              11
#define PPAD_MSG_INSERTCARD              12
#define PPAD_MSG_SELECTCARDTYPE          13


/////////////////////////////////////////////////////////////////////
// "CapLanguage" Property Constants
/////////////////////////////////////////////////////////////////////

#define PPAD_LANG_NONE                   1
#define PPAD_LANG_ONE                    2
#define PPAD_LANG_PINRESTRICTED          3
#define PPAD_LANG_UNRESTRICTED           4

/////////////////////////////////////////////////////////////////////
// "TransactionType" Property Constants
/////////////////////////////////////////////////////////////////////

#define PPAD_TRANS_DEBIT                 1
#define PPAD_TRANS_CREDIT                2
#define PPAD_TRANS_INQ                   3
#define PPAD_TRANS_RECONCILE             4
#define PPAD_TRANS_ADMIN                 5
                                        
/////////////////////////////////////////////////////////////////////
// "EndEFTTransaction" Method Completion Code Constants
/////////////////////////////////////////////////////////////////////

#define PPAD_EFT_NORMAL                  1
#define PPAD_EFT_ABNORMAL                2


/////////////////////////////////////////////////////////////////////
// "DataEvent" Event Status Constants
/////////////////////////////////////////////////////////////////////
#define PPAD_SUCCESS                     1
#define PPAD_CANCEL                      2


/*
 **********************************************************************
 *
 *      POS PRINTER header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// Printer Station Constants
/////////////////////////////////////////////////////////////////////

#define PTR_S_JOURNAL         1
#define PTR_S_RECEIPT         2
#define PTR_S_SLIP            4

#define PTR_S_JOURNAL_RECEIPT    (PTR_S_JOURNAL | PTR_S_RECEIPT )
#define PTR_S_JOURNAL_SLIP       (PTR_S_JOURNAL | PTR_S_SLIP    )
#define PTR_S_RECEIPT_SLIP       (PTR_S_RECEIPT | PTR_S_SLIP    )

#define PTR_TWO_RECEIPT_JOURNAL  (0x8000 + PTR_S_JOURNAL_RECEIPT )
#define PTR_TWO_SLIP_JOURNAL     (0x8000 + PTR_S_JOURNAL_SLIP    )
#define PTR_TWO_SLIP_RECEIPT     (0x8000 + PTR_S_RECEIPT_SLIP    )


/////////////////////////////////////////////////////////////////////
// "CapCharacterSet" Property Constants
/////////////////////////////////////////////////////////////////////

#define PTR_CCS_ALPHA           1
#define PTR_CCS_ASCII         998
#define PTR_CCS_KANA           10
#define PTR_CCS_KANJI          11


/////////////////////////////////////////////////////////////////////
// "CharacterSet" Property Constants
/////////////////////////////////////////////////////////////////////

#define PTR_CS_ASCII          998
#define PTR_CS_WINDOWS        999


/////////////////////////////////////////////////////////////////////
// "ErrorLevel" Property Constants
/////////////////////////////////////////////////////////////////////

#define PTR_EL_NONE           1
#define PTR_EL_RECOVERABLE    2
#define PTR_EL_FATAL          3


/////////////////////////////////////////////////////////////////////
// "MapMode" Property Constants
/////////////////////////////////////////////////////////////////////

#define PTR_MM_DOTS           1
#define PTR_MM_TWIPS          2
#define PTR_MM_ENGLISH        3
#define PTR_MM_METRIC         4


/////////////////////////////////////////////////////////////////////
// "CutPaper" Method Constant
/////////////////////////////////////////////////////////////////////

#define PTR_CP_FULLCUT       100


/////////////////////////////////////////////////////////////////////
// "PrintBarCode" Method Constants:
/////////////////////////////////////////////////////////////////////

//   "Alignment" Parameter
//     Either the distance from the left-most print column to the start
//     of the bar code, or one of the following:

#define PTR_BC_LEFT          -1
#define PTR_BC_CENTER        -2
#define PTR_BC_RIGHT         -3

//   "TextPosition" Parameter

#define PTR_BC_TEXT_NONE      -11
#define PTR_BC_TEXT_ABOVE     -12
#define PTR_BC_TEXT_BELOW     -13

//   "Symbology" Parameter:

//     One dimensional symbologies
#define PTR_BCS_UPCA         101  // Digits
#define PTR_BCS_UPCE         102  // Digits
#define PTR_BCS_JAN8         103  // = EAN 8
#define PTR_BCS_EAN8         103  // = JAN 8 (added in 1.2)
#define PTR_BCS_JAN13        104  // = EAN 13
#define PTR_BCS_EAN13        104  // = JAN 13 (added in 1.2)
#define PTR_BCS_TF           105  // (Discrete 2 of 5) Digits
#define PTR_BCS_ITF          106  // (Interleaved 2 of 5) Digits
#define PTR_BCS_Codabar      107  // Digits, -, $, :, /, ., +;
                                        //   4 start/stop characters
                                        //   (a, b, c, d)
#define PTR_BCS_Code39       108  // Alpha, Digits, Space, -, .,
                                        //   $, /, +, %; start/stop (*)
                                        // Also has Full ASCII feature
#define PTR_BCS_Code93       109  // Same characters as Code 39
#define PTR_BCS_Code128      110  // 128 data characters
//        (The following were added in Release 1.2)
#define PTR_BCS_UPCA_S       111  // UPC-A with supplemental
                                        //   barcode
#define PTR_BCS_UPCE_S       112  // UPC-E with supplemental
                                        //   barcode
#define PTR_BCS_UPCD1        113  // UPC-D1
#define PTR_BCS_UPCD2        114  // UPC-D2
#define PTR_BCS_UPCD3        115  // UPC-D3
#define PTR_BCS_UPCD4        116  // UPC-D4
#define PTR_BCS_UPCD5        117  // UPC-D5
#define PTR_BCS_EAN8_S       118  // EAN 8 with supplemental
                                        //   barcode
#define PTR_BCS_EAN13_S      119  // EAN 13 with supplemental
                                        //   barcode
#define PTR_BCS_EAN128       120  // EAN 128
#define PTR_BCS_OCRA         121  // OCR "A"
#define PTR_BCS_OCRB         122  // OCR "B"


//     Two dimensional symbologies
#define PTR_BCS_PDF417       201
#define PTR_BCS_MAXICODE     202

//     Start of Printer-Specific bar code symbologies
#define PTR_BCS_OTHER        501


/////////////////////////////////////////////////////////////////////
// "PrintBitmap" Method Constants:
/////////////////////////////////////////////////////////////////////

//   "Width" Parameter
//     Either bitmap width or:

#define PTR_BM_ASIS          -11  // One pixel per printer dot

//   "Alignment" Parameter
//     Either the distance from the left-most print column to the start
//     of the bitmap, or one of the following:

#define PTR_BM_LEFT          -1
#define PTR_BM_CENTER        -2
#define PTR_BM_RIGHT         -3


/////////////////////////////////////////////////////////////////////
// "RotatePrint" Method: "Rotation" Parameter Constants
// "RotateSpecial" Property Constants
/////////////////////////////////////////////////////////////////////

#define PTR_RP_NORMAL        0x0001
#define PTR_RP_RIGHT90       0x0101
#define PTR_RP_LEFT90        0x0102
#define PTR_RP_ROTATE180     0x0103


/////////////////////////////////////////////////////////////////////
// "SetLogo" Method: "Location" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define PTR_L_TOP            1
#define PTR_L_BOTTOM         2


/////////////////////////////////////////////////////////////////////
// "TransactionPrint" Method: "Control" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define PTR_TP_TRANSACTION    11
#define PTR_TP_NORMAL         12


/////////////////////////////////////////////////////////////////////
// "StatusUpdateEvent" Event: "Data" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define PTR_SUE_COVER_OPEN      11
#define PTR_SUE_COVER_OK        12

#define PTR_SUE_JRN_EMPTY       21
#define PTR_SUE_JRN_NEAREMPTY   22
#define PTR_SUE_JRN_PAPEROK     23

#define PTR_SUE_REC_EMPTY       24
#define PTR_SUE_REC_NEAREMPTY   25
#define PTR_SUE_REC_PAPEROK     26

#define PTR_SUE_SLP_EMPTY       27
#define PTR_SUE_SLP_NEAREMPTY   28
#define PTR_SUE_SLP_PAPEROK     29

#define PTR_SUE_IDLE          1001
                             
/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for Printer
/////////////////////////////////////////////////////////////////////

#define OPOS_EPTR_COVER_OPEN  (1 + OPOSERREXT) // (Several)
#define OPOS_EPTR_JRN_EMPTY   (2 + OPOSERREXT) // (Several)
#define OPOS_EPTR_REC_EMPTY   (3 + OPOSERREXT) // (Several)
#define OPOS_EPTR_SLP_EMPTY   (4 + OPOSERREXT) // (Several)
#define OPOS_EPTR_SLP_FORM    (5 + OPOSERREXT) // EndRemoval
#define OPOS_EPTR_TOOBIG      (6 + OPOSERREXT) // PrintBitmap
#define OPOS_EPTR_BADFORMAT   (7 + OPOSERREXT) // PrintBitmap



/*
 **********************************************************************
 *
 *      REMOTE ORDER DISPLAY header section
 *
 **********************************************************************
 */

#define ROD_UID_1        (1 << 0)
#define ROD_UID_2        (1 << 1)
#define ROD_UID_3        (1 << 2)
#define ROD_UID_4        (1 << 3)
#define ROD_UID_5        (1 << 4)
#define ROD_UID_6        (1 << 5)
#define ROD_UID_7        (1 << 6)
#define ROD_UID_8        (1 << 7)
#define ROD_UID_9        (1 << 8)
#define ROD_UID_10       (1 << 9)
#define ROD_UID_11       (1 << 10)
#define ROD_UID_12       (1 << 11)
#define ROD_UID_13       (1 << 12)
#define ROD_UID_14       (1 << 13)
#define ROD_UID_15       (1 << 14)
#define ROD_UID_16       (1 << 15)
#define ROD_UID_17       (1 << 16)
#define ROD_UID_18       (1 << 17)
#define ROD_UID_19       (1 << 18)
#define ROD_UID_20       (1 << 19)
#define ROD_UID_21       (1 << 20)
#define ROD_UID_22       (1 << 21)
#define ROD_UID_23       (1 << 22)
#define ROD_UID_24       (1 << 23)
#define ROD_UID_25       (1 << 24)
#define ROD_UID_26       (1 << 25)
#define ROD_UID_27       (1 << 26)
#define ROD_UID_28       (1 << 27)
#define ROD_UID_29       (1 << 28)
#define ROD_UID_30       (1 << 29)
#define ROD_UID_31       (1 << 30)
#define ROD_UID_32       (1 << 31)


/////////////////////////////////////////////////////////////////////
// Broadcast Methods: "Attribute" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_ATTR_BLINK        0x80

#define ROD_ATTR_BG_BLACK     0x00
#define ROD_ATTR_BG_BLUE      0x10
#define ROD_ATTR_BG_GREEN     0x20
#define ROD_ATTR_BG_CYAN      0x30
#define ROD_ATTR_BG_RED       0x40
#define ROD_ATTR_BG_MAGENTA   0x50
#define ROD_ATTR_BG_BROWN     0x60
#define ROD_ATTR_BG_GRAY      0x70

#define ROD_ATTR_INTENSITY    0x08

#define ROD_ATTR_FG_BLACK     0x00
#define ROD_ATTR_FG_BLUE      0x01
#define ROD_ATTR_FG_GREEN     0x02
#define ROD_ATTR_FG_CYAN      0x03
#define ROD_ATTR_FG_RED       0x04
#define ROD_ATTR_FG_MAGENTA   0x05
#define ROD_ATTR_FG_BROWN     0x06
#define ROD_ATTR_FG_GRAY      0x07


/////////////////////////////////////////////////////////////////////
// "DrawBox" Method: "BorderType" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_BDR_SINGLE        1
#define ROD_BDR_DOUBLE        2
#define ROD_BDR_SOLID         3


/////////////////////////////////////////////////////////////////////
// "ControlClock" Method: "Function" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_CLK_START         1
#define ROD_CLK_PAUSE         2
#define ROD_CLK_RESUME        3
#define ROD_CLK_MOVE          4
#define ROD_CLK_STOP          5


/////////////////////////////////////////////////////////////////////
// "ControlCursor" Method: "Function" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_CRS_LINE          1
#define ROD_CRS_LINE_BLINK    2
#define ROD_CRS_BLOCK         3
#define ROD_CRS_BLOCK_BLINK   4
#define ROD_CRS_OFF           5


/////////////////////////////////////////////////////////////////////
// "SelectChararacterSet" Method: "CharacterSet" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_CS_ASCII          998
#define ROD_CS_WINDOWS        999


/////////////////////////////////////////////////////////////////////
// "TransactionDisplay" Method: "Function" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_TD_TRANSACTION    11
#define ROD_TD_NORMAL         12


/////////////////////////////////////////////////////////////////////
// "UpdateVideoRegionAttribute" Method: "Function" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_UA_SET            1
#define ROD_UA_INTENSITY_ON   2
#define ROD_UA_INTENSITY_OFF  3
#define ROD_UA_REVERSE_ON     4
#define ROD_UA_REVERSE_OFF    5
#define ROD_UA_BLINK_ON       6
#define ROD_UA_BLINK_OFF      7


/////////////////////////////////////////////////////////////////////
// "EventTypes" Property and "DataEvent" Event: "Status" Parameter Constants
/////////////////////////////////////////////////////////////////////

#define ROD_DE_TOUCH_UP       0x01
#define ROD_DE_TOUCH_DOWN     0x02
#define ROD_DE_TOUCH_MOVE     0x04


/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for Remote Order Display
/////////////////////////////////////////////////////////////////////

#define OPOS_EROD_BADCLK      (1 + OPOSERREXT) // ControlClock
#define OPOS_EROD_NOCLOCKS    (2 + OPOSERREXT) // ControlClock
#define OPOS_EROD_NOREGION    (3 + OPOSERREXT) // RestoreVideo
                                                  //   Region
#define OPOS_EROD_NOBUFFERS   (4 + OPOSERREXT) // SaveVideoRegion
#define OPOS_EROD_NOROOM      (5 + OPOSERREXT) // SaveVideoRegion



/*
 **********************************************************************
 *
 *      SCALE DISPLAY header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "WeightUnit" Property Constants
/////////////////////////////////////////////////////////////////////

#define SCAL_WU_GRAM          1
#define SCAL_WU_KILOGRAM      2
#define SCAL_WU_OUNCE         3
#define SCAL_WU_POUND         4


/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for Scale
/////////////////////////////////////////////////////////////////////

#define OPOS_ESCAL_OVERWEIGHT (1 + OPOSERREXT) // ReadWeight


/*
 **********************************************************************
 *
 *      BAR CODE SCANNER header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "ScanDataType" Property Constants
/////////////////////////////////////////////////////////////////////

// One dimensional symbologies
#define SCAN_SDT_UPCA         101  // Digits
#define SCAN_SDT_UPCE         102  // Digits
#define SCAN_SDT_JAN8         103  // = EAN 8
#define SCAN_SDT_EAN8         103  // = JAN 8 (added in 1.2)
#define SCAN_SDT_JAN13        104  // = EAN 13
#define SCAN_SDT_EAN13        104  // = JAN 13 (added in 1.2)
#define SCAN_SDT_TF           105  // (Discrete 2 of 5) Digits
#define SCAN_SDT_ITF          106  // (Interleaved 2 of 5) Digits
#define SCAN_SDT_Codabar      107  // Digits, -, $, :, /, ., +;
                                        //   4 start/stop characters
                                        //   (a, b, c, d)
#define SCAN_SDT_Code39       108  // Alpha, Digits, Space, -, .,
                                        //   $, /, +, %; start/stop (*)
                                        // Also has Full ASCII feature
#define SCAN_SDT_Code93       109  // Same characters as Code 39
#define SCAN_SDT_Code128      110  // 128 data characters

#define SCAN_SDT_UPCA_S       111  // UPC-A with supplemental
                                        //   barcode
#define SCAN_SDT_UPCE_S       112  // UPC-E with supplemental
                                        //   barcode
#define SCAN_SDT_UPCD1        113  // UPC-D1
#define SCAN_SDT_UPCD2        114  // UPC-D2
#define SCAN_SDT_UPCD3        115  // UPC-D3
#define SCAN_SDT_UPCD4        116  // UPC-D4
#define SCAN_SDT_UPCD5        117  // UPC-D5
#define SCAN_SDT_EAN8_S       118  // EAN 8 with supplemental
                                        //   barcode
#define SCAN_SDT_EAN13_S      119  // EAN 13 with supplemental
                                        //   barcode
#define SCAN_SDT_EAN128       120  // EAN 128
#define SCAN_SDT_OCRA         121  // OCR "A"
#define SCAN_SDT_OCRB         122  // OCR "B"

// Two dimensional symbologies
#define SCAN_SDT_PDF417       201
#define SCAN_SDT_MAXICODE     202

// Special cases
#define SCAN_SDT_OTHER        501  // Start of Scanner-Specific bar
                                        //   code symbologies
#define SCAN_SDT_UNKNOWN        0  // Cannot determine the barcode
                                        //   symbology.


/*
 **********************************************************************
 *
 *      SIGNATURE CAPTURE header section
 *
 **********************************************************************
 */

    // (no definitions in this version)



/*
 **********************************************************************
 *
 *      TONE INDICATOR header section
 *
 **********************************************************************
 */

/////////////////////////////////////////////////////////////////////
// "ResultCodeExtended" Property Constants for Hard Totals
/////////////////////////////////////////////////////////////////////

#define OPOS_ETOT_NOROOM        (1 + OPOSERREXT) // Create, Write
#define OPOS_ETOT_VALIDATION    (2 + OPOSERREXT) // Read, Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\inc\opos_hid.h ===
/*++

Copyright (c) 1998      Microsoft Corporation

Module Name:

        OPOS_HID.H

Abstract:

   Public Definitions of HID USAGES for Point Of Sale devices.

Environment:

    Kernel & user mode

Revision History:

    Oct-1998 : created by Ervin Peretz

--*/

typedef USHORT USAGE, *PUSAGE;


/*
 *  Usage Pages
 */
#define HID_USAGE_PAGE_BAR_CODE_SCANNER ((USAGE) 0x8C)




/*
 *  Usages for:         Bar Code Scanner (0x8C)
 */
#define HID_USAGE_BAR_CODE_BADGE_READER                         ((USAGE) 0x01)
#define HID_USAGE_BAR_CODE_SCANNER                              ((USAGE) 0x02)
#define HID_USAGE_BAR_CODE_DUMB_SCANNER                         ((USAGE) 0x03)
#define HID_USAGE_BAR_CODE_CORDLESS_SCANNER_BASE                ((USAGE) 0x04)
#define HID_USAGE_BAR_CODE_SCANNER_CRADLE                       ((USAGE) 0x05)
#define HID_USAGE_BAR_CODE_ATTRIBUTE_REPORT                     ((USAGE) 0x10)
#define HID_USAGE_BAR_CODE_SETTINGS_REPORT                      ((USAGE) 0x11)
#define HID_USAGE_BAR_CODE_SCANNED_DATA_REPORT                  ((USAGE) 0x12)
#define HID_USAGE_BAR_CODE_RAW_SCANNED_DATA_REPORT              ((USAGE) 0x13)
#define HID_USAGE_BAR_CODE_TRIGGER_REPORT                       ((USAGE) 0x14)
#define HID_USAGE_BAR_CODE_STATUS_REPORT                        ((USAGE) 0x15)
#define HID_USAGE_BAR_CODE_UPC_EAN_CONTROL_REPORT               ((USAGE) 0x16)
#define HID_USAGE_BAR_CODE_OTHER_1D_CONTROL_REPORT              ((USAGE) 0x17)
#define HID_USAGE_BAR_CODE_2D_CONTROL_REPORT                    ((USAGE) 0x18)
#define HID_USAGE_BAR_CODE_AIMING_POINTER_MODE                  ((USAGE) 0x20)
#define HID_USAGE_BAR_CODE_PRESENT_SENSOR                       ((USAGE) 0x21)
#define HID_USAGE_BAR_CODE_CLASS_1A_LASER                       ((USAGE) 0x22)
#define HID_USAGE_BAR_CODE_CLASS_2A_LASER                       ((USAGE) 0x23)
#define HID_USAGE_BAR_CODE_HEATER_PRESENT                       ((USAGE) 0x24)
#define HID_USAGE_BAR_CODE_CONTACT_SCANNER                      ((USAGE) 0x25)
#define HID_USAGE_BAR_CODE_ELEC_ARTICLE_SURV                    ((USAGE) 0x26)
#define HID_USAGE_BAR_CODE_ERROR_INDIC_LED                      ((USAGE) 0x27)
#define HID_USAGE_BAR_CODE_FIXED_BEEPER                         ((USAGE) 0x28)
#define HID_USAGE_BAR_CODE_GOOD_DECODE_INDIC_LED                ((USAGE) 0x29)
#define HID_USAGE_BAR_CODE_HANDS_FREE_SCANNING                  ((USAGE) 0x2A)
#define HID_USAGE_BAR_CODE_INTRINSICALLY_SAFE                   ((USAGE) 0x2B)
#define HID_USAGE_BAR_CODE_KLASSE_EINS_LASER                    ((USAGE) 0x2C)
#define HID_USAGE_BAR_CODE_LONG_RANGE_SCANNER                   ((USAGE) 0x2D)
#define HID_USAGE_BAR_CODE_MIRROR_SPEED_CONTROL                 ((USAGE) 0x2E)
#define HID_USAGE_BAR_CODE_NOTONFILE_LED                        ((USAGE) 0x2F)
#define HID_USAGE_BAR_CODE_PROGRAMMABLE_BEEPER                  ((USAGE) 0x30)
#define HID_USAGE_BAR_CODE_TRIGGERLESS                          ((USAGE) 0x31)
#define HID_USAGE_BAR_CODE_WAND                                 ((USAGE) 0x32)
#define HID_USAGE_BAR_CODE_WATER_RESISTANT                      ((USAGE) 0x33)
#define HID_USAGE_BAR_CODE_MULTIRANGE_SCANNER                   ((USAGE) 0x34)
#define HID_USAGE_BAR_CODE_PROXIMITY_SENSOR                     ((USAGE) 0x35)
#define HID_USAGE_BAR_CODE_FRAGMENT_DECODING                    ((USAGE) 0x3D)
#define HID_USAGE_BAR_CODE_SCANNER_READ_CONFIDENCE              ((USAGE) 0x3E)
#define HID_USAGE_BAR_CODE_ACTIVE_TIME                          ((USAGE) 0x45)
#define HID_USAGE_BAR_CODE_AIMING_LASER_PATTERN                 ((USAGE) 0x46)
#define HID_USAGE_BAR_CODE_PRESENT                              ((USAGE) 0x47)
#define HID_USAGE_BAR_CODE_BEEPER_STATE                         ((USAGE) 0x48)
#define HID_USAGE_BAR_CODE_LASER_ON_TIME                        ((USAGE) 0x49)
#define HID_USAGE_BAR_CODE_LASER_STATE                          ((USAGE) 0x4A)
#define HID_USAGE_BAR_CODE_LOCKOUT_TIME                         ((USAGE) 0x4B)
#define HID_USAGE_BAR_CODE_MOTOR_STATE                          ((USAGE) 0x4C)
#define HID_USAGE_BAR_CODE_MOTOR_TIMEOUT                        ((USAGE) 0x4D)
#define HID_USAGE_BAR_CODE_POWER_ON_RESET_SCANNER               ((USAGE) 0x4E)
#define HID_USAGE_BAR_CODE_PREVENT_BARCODE_READ                 ((USAGE) 0x4F)
#define HID_USAGE_BAR_CODE_INITIATE_BARCODE_READ                ((USAGE) 0x50)
#define HID_USAGE_BAR_CODE_TRIGGER_STATE                        ((USAGE) 0x51)
#define HID_USAGE_BAR_CODE_BLINKING_LASER_ON                    ((USAGE) 0x52)
#define HID_USAGE_BAR_CODE_CONTINUOUS_LASER_ON                  ((USAGE) 0x53)
#define HID_USAGE_BAR_CODE_LASER_ON_WHILE_TRIGGER_PULLED        ((USAGE) 0x54)
#define HID_USAGE_BAR_CODE_LASER_ON_AFTER_TRIGGER_RELEASE       ((USAGE) 0x55)
#define HID_USAGE_BAR_CODE_COMMIT_PARAMS_TO_NVM                 ((USAGE) 0x5D)
#define HID_USAGE_BAR_CODE_PARAM_SCANNING                       ((USAGE) 0x5E)
#define HID_USAGE_BAR_CODE_PARAMS_CHANGED                       ((USAGE) 0x5F)
#define HID_USAGE_BAR_CODE_SET_PARAM_DEFAULT_VALUES             ((USAGE) 0x60)
#define HID_USAGE_BAR_CODE_SCANNER_IN_CRADLE                    ((USAGE) 0x65)
#define HID_USAGE_BAR_CODE_SCANNER_IN_RANGE                     ((USAGE) 0x66)
#define HID_USAGE_BAR_CODE_AIM_DURATION                         ((USAGE) 0x6A)
#define HID_USAGE_BAR_CODE_GOOD_READ_LAMP_DURATION              ((USAGE) 0x6B)
#define HID_USAGE_BAR_CODE_GOOD_READ_LAMP_INTENSITY             ((USAGE) 0x6C)
#define HID_USAGE_BAR_CODE_GOOD_READ_LED                        ((USAGE) 0x6D)
#define HID_USAGE_BAR_CODE_GOOD_READ_TONE_FREQUENCY             ((USAGE) 0x6E)
#define HID_USAGE_BAR_CODE_GOOD_READ_TONE_LENGTH                ((USAGE) 0x6F)
#define HID_USAGE_BAR_CODE_GOOD_READ_TONE_VOLUME                ((USAGE) 0x70)
#define HID_USAGE_BAR_CODE_NO_READ_MESSAGE                      ((USAGE) 0x72)
#define HID_USAGE_BAR_CODE_NOT_ON_FILE_VOLUME                   ((USAGE) 0x73)
#define HID_USAGE_BAR_CODE_POWERUP_BEEP                         ((USAGE) 0x74)
#define HID_USAGE_BAR_CODE_SOUND_ERROR_BEEP                     ((USAGE) 0x75)
#define HID_USAGE_BAR_CODE_SOUND_GOOD_READ_BEEP                 ((USAGE) 0x76)
#define HID_USAGE_BAR_CODE_SOUND_NOT_ON_FILE_BEEP               ((USAGE) 0x77)
#define HID_USAGE_BAR_CODE_AFTER_DECODE                         ((USAGE) 0x78)
#define HID_USAGE_BAR_CODE_BEEP_OR_LAMP_AFTER_XMIT              ((USAGE) 0x79)
#define HID_USAGE_BAR_CODE_NO_BEEP_OR_LAMP                      ((USAGE) 0x7A)
#define HID_USAGE_BAR_CODE_BOOKLAND_EAN                         ((USAGE) 0x81)
#define HID_USAGE_BAR_CODE_CONVERT_EAN_8_TO_13                  ((USAGE) 0x82)
#define HID_USAGE_BAR_CODE_CONVERT_UPC_A_TO_EAN13               ((USAGE) 0x83)
#define HID_USAGE_BAR_CODE_CONVERT_UPC_E_TO_A                   ((USAGE) 0x84)
#define HID_USAGE_BAR_CODE_EAN13                                ((USAGE) 0x85)
#define HID_USAGE_BAR_CODE_EAN8                                 ((USAGE) 0x86)
#define HID_USAGE_BAR_CODE_EAN99_128_MANDATORY                  ((USAGE) 0x87)
#define HID_USAGE_BAR_CODE_EAN99_P5_128_OPTIONAL                ((USAGE) 0x88)
#define HID_USAGE_BAR_CODE_ENABLE_EAN_TWO_LABEL                 ((USAGE) 0x89)
#define HID_USAGE_BAR_CODE_UPC_EAN                              ((USAGE) 0x8A)
#define HID_USAGE_BAR_CODE_UPC_EAN_COUPON_CODE                  ((USAGE) 0x8B)
#define HID_USAGE_BAR_CODE_UPC_EAN_PERIODICALS                  ((USAGE) 0x8C)
#define HID_USAGE_BAR_CODE_UPC_A                                ((USAGE) 0x8D)
#define HID_USAGE_BAR_CODE_UPC_A_WITH_128_MANDATORY             ((USAGE) 0x8E)
#define HID_USAGE_BAR_CODE_UPC_A_WITH_128_OPTIONAL              ((USAGE) 0x8F)
#define HID_USAGE_BAR_CODE_UPC_A_WITH_P5_OPTIONAL               ((USAGE) 0x90)
#define HID_USAGE_BAR_CODE_UPC_E                                ((USAGE) 0x91)
#define HID_USAGE_BAR_CODE_UPC_E1                               ((USAGE) 0x92)
#define HID_USAGE_BAR_CODE_AUTO_DISCRIMINATE_PLUS_2_PERIODICALS ((USAGE) 0x9A)
#define HID_USAGE_BAR_CODE_AUTO_DECODE_PLUS_2_PERIODICALS       ((USAGE) 0x9B)
#define HID_USAGE_BAR_CODE_IGNORE_PLUS_2_PERIODICALS            ((USAGE) 0x9C)
#define HID_USAGE_BAR_CODE_AUTO_DISCRIMINATE_PLUS_5_PERIODICALS ((USAGE) 0x9D)
#define HID_USAGE_BAR_CODE_AUTO_DECODE_PLUS_5_PERIODICALS       ((USAGE) 0x9E)
#define HID_USAGE_BAR_CODE_IGNORE_PLUS_5_PERIODICALS            ((USAGE) 0x9F)
#define HID_USAGE_BAR_CODE_DISABLE_PRICE_CHECK                  ((USAGE) 0xA0)
#define HID_USAGE_BAR_CODE_ENABLE_4_DIGIT_PRICE_CHECK           ((USAGE) 0xA1)
#define HID_USAGE_BAR_CODE_ENABLE_5_DIGIT_PRICE_CHECK           ((USAGE) 0xA2)
#define HID_USAGE_BAR_CODE_ENABLE_EURO_4_DIGIT_PRICE_CHECK      ((USAGE) 0xA3)
#define HID_USAGE_BAR_CODE_ENABLE_EURO_5_DIGIT_PRICE_CHECK      ((USAGE) 0xA4)
#define HID_USAGE_BAR_CODE_DISABLE_TWO_LABEL                    ((USAGE) 0xA5)
#define HID_USAGE_BAR_CODE_TWO_LABEL_WITH_EAN_13_2_AND_EAN_8_1  ((USAGE) 0xA6)
#define HID_USAGE_BAR_CODE_TWO_LABEL_WITH_EAN_13_1_AND_EAN_8_1  ((USAGE) 0xA7)
#define HID_USAGE_BAR_CODE_TWO_LABEL_WITH_EAN_13_2_FLAG_DIGITS  ((USAGE) 0xA8)
#define HID_USAGE_BAR_CODE_VERIFY_CODABAR_CHECK_DIGIT           ((USAGE) 0xB0)
#define HID_USAGE_BAR_CODE_XMIT_CODE_39_CHECK_DIGIT             ((USAGE) 0xB1)
#define HID_USAGE_BAR_CODE_VERIFY_CODE39_CHECK_DIGIT            ((USAGE) 0xB2)
#define HID_USAGE_BAR_CODE_CODABAR                              ((USAGE) 0xB3)
#define HID_USAGE_BAR_CODE_CODE_128                             ((USAGE) 0xB4)
#define HID_USAGE_BAR_CODE_CODE_128_AIM_PREFIX                  ((USAGE) 0xB5)
#define HID_USAGE_BAR_CODE_CODE_128_MIN_ELEMENTS                ((USAGE) 0xB6)
#define HID_USAGE_BAR_CODE_CODE_39                              ((USAGE) 0xB7)
#define HID_USAGE_BAR_CODE_CODE_93                              ((USAGE) 0xB8)
#define HID_USAGE_BAR_CODE_FULL_ASCII_CONVERSION                ((USAGE) 0xB9)
#define HID_USAGE_BAR_CODE_INTERLEAVED_2_OF_5                   ((USAGE) 0xBA)
#define HID_USAGE_BAR_CODE_ITALIAN_PHARMACY_CODE                ((USAGE) 0xBB)
#define HID_USAGE_BAR_CODE_MSI_PLESSEY                          ((USAGE) 0xBC)
#define HID_USAGE_BAR_CODE_STANDARD_2_OF_5_1ATA                 ((USAGE) 0xBD)
#define HID_USAGE_BAR_CODE_STANDARD_2_OF_5                      ((USAGE) 0xBE)
#define HID_USAGE_BAR_CODE_XMIT_CODABAR_CHECK_DIGIT             ((USAGE) 0xBF)
#define HID_USAGE_BAR_CODE_XMIT_I2_OF_5_DIGIT_CHECK             ((USAGE) 0xC0)
#define HID_USAGE_BAR_CODE_XMIT_MSI_PLESSEY_CHECK_DIGIT         ((USAGE) 0xC1)
#define HID_USAGE_BAR_CODE_XMIT_S2_OF_5_CHECK_DIGIT             ((USAGE) 0xC2)
#define HID_USAGE_BAR_CODE_XMIT_START_STOP                      ((USAGE) 0xC3)
#define HID_USAGE_BAR_CODE_TRIOPTIC                             ((USAGE) 0xC4)
#define HID_USAGE_BAR_CODE_UCC_EAN_128                          ((USAGE) 0xC5)
#define HID_USAGE_BAR_CODE_DISABLE_INTERLEAVED_2_OF_5_CHECK_DIGIT       ((USAGE) 0xC6)
#define HID_USAGE_BAR_CODE_ENABLE_INTERLEAVED_2_OF_5_OPCC_CHECK_DIGIT   ((USAGE) 0xC7)
#define HID_USAGE_BAR_CODE_ENABLE_INTERLEAVED_2_OF_5_USS_CHECK_DIGIT    ((USAGE) 0xC8)
#define HID_USAGE_BAR_CODE_DISABLE_STANDARD_2_OF_5_CHECK_DIGIT          ((USAGE) 0xC9)
#define HID_USAGE_BAR_CODE_DISABLE_STANDARD_2_OF_5_OPCC_CHECK_DIGIT     ((USAGE) 0xCA)
#define HID_USAGE_BAR_CODE_ENABLE_STANDARD_2_OF_5_USS_CHECK_DIGIT       ((USAGE) 0xCB)
#define HID_USAGE_BAR_CODE_DISABLE_MSI_PLESSEY_CHECK_DIGIT              ((USAGE) 0xCC)
#define HID_USAGE_BAR_CODE_ENABLE_ONE_MSI_PLESSEY_CHECK_DIGIT           ((USAGE) 0xCD)
#define HID_USAGE_BAR_CODE_ENABLE_TWO_MSI_PLESSEY_CHECK_DIGITS          ((USAGE) 0xCE)
#define HID_USAGE_BAR_CODE_AZTEC_CODE                                   ((USAGE) 0xD3)
#define HID_USAGE_BAR_CODE_BC412                                        ((USAGE) 0xD4)
#define HID_USAGE_BAR_CODE_CHANNEL_CODE                                 ((USAGE) 0xD5)
#define HID_USAGE_BAR_CODE_CODE_16                                      ((USAGE) 0xD6)
#define HID_USAGE_BAR_CODE_CODE_32                                      ((USAGE) 0xD7)
#define HID_USAGE_BAR_CODE_CODE_49                                      ((USAGE) 0xD8)
#define HID_USAGE_BAR_CODE_CODE_ONE                                     ((USAGE) 0xD9)
#define HID_USAGE_BAR_CODE_COLOR_CODE                                   ((USAGE) 0xDA)
#define HID_USAGE_BAR_CODE_DATA_MATRIX                                  ((USAGE) 0xDB)
#define HID_USAGE_BAR_CODE_MAXICODE                                     ((USAGE) 0xDC)
#define HID_USAGE_BAR_CODE_MICRO_PDF                                    ((USAGE) 0xDD)
#define HID_USAGE_BAR_CODE_PDF_417                                      ((USAGE) 0xDE)
#define HID_USAGE_BAR_CODE_POSICODE                                     ((USAGE) 0xDF)
#define HID_USAGE_BAR_CODE_QR_CODE                                      ((USAGE) 0xE0)
#define HID_USAGE_BAR_CODE_SUPERCODE                                    ((USAGE) 0xE1)
#define HID_USAGE_BAR_CODE_ULTRACODE                                    ((USAGE) 0xE2)
#define HID_USAGE_BAR_CODE_USD_5_SLUG_CODE                              ((USAGE) 0xE3)
#define HID_USAGE_BAR_CODE_VERICODE                                     ((USAGE) 0xE4)
#define HID_USAGE_BAR_CODE_AIM_IDENTIFIER_1                             ((USAGE) 0xEB)
#define HID_USAGE_BAR_CODE_AIM_IDENTIFIER_2                             ((USAGE) 0xEC)
#define HID_USAGE_BAR_CODE_AIM_IDENTIFIER_3                             ((USAGE) 0xED)
#define HID_USAGE_BAR_CODE_DECODED_DATA                                 ((USAGE) 0xEE)
#define HID_USAGE_BAR_CODE_DECODE_DATA_CONTINUED                        ((USAGE) 0xEF)
#define HID_USAGE_BAR_CODE_BAR_SPACE_DATA                               ((USAGE) 0xF0)
#define HID_USAGE_BAR_CODE_SCANNER_DATA_ACCURACY                        ((USAGE) 0xF1)
#define HID_USAGE_BAR_CODE_INVERTED_BAR_CODE                            ((USAGE) 0xF2)
#define HID_USAGE_BAR_CODE_NORMAL_BAR_CODE                              ((USAGE) 0xF3)
#define HID_USAGE_BAR_CODE_MIN_LENGTH_TO_DECODE                         ((USAGE) 0xF6)
#define HID_USAGE_BAR_CODE_MAX_LENGTH_TO_DECODE                         ((USAGE) 0xF7)
#define HID_USAGE_BAR_CODE_FIRST_DISCRETE_LENGTH_TO_DECODE              ((USAGE) 0xF8)
#define HID_USAGE_BAR_CODE_SECOND_DISCRETE_LENGTH_TO_DECODE             ((USAGE) 0xF9)
#define HID_USAGE_BAR_CODE_READ_ANY_LENGTH                              ((USAGE) 0xFA)
#define HID_USAGE_BAR_CODE_CHECK_LENGTH_IN_RANGE                        ((USAGE) 0xFB)
#define HID_USAGE_BAR_CODE_CHECK_FOR_DISCRETE_LENGTHS                   ((USAGE) 0xFC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\iunknown.cpp ===
/*
 *  IUNKNOWN.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


STDMETHODIMP_(ULONG) COPOSControl::AddRef(void)
{
    return ++m_refCount;
}

STDMETHODIMP_(ULONG) COPOSControl::Release(void)
{
    ULONG result;   // need sepate variable in case we free

    if (--m_refCount == 0){
        delete this;
        result = 0;
    }
    else {
        result = m_refCount;
    }

    return result;
}


STDMETHODIMP COPOSControl::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT result;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_OPOS_GENERIC_CONTROL) ||
        IsEqualIID(riid, IID_IClassFactory)){

        *ppvObj = this;
        this->AddRef();
        result = NOERROR;

        // BUGBUG REMOVE
        if (IsEqualIID(riid, IID_IUnknown)) Report("QueryInterface Got IID_IUnknown", 0);
        else if (IsEqualIID(riid, IID_OPOS_GENERIC_CONTROL)) Report("QueryInterface Got IID_OPOS_GENERIC_CONTROL", 0);
        else if (IsEqualIID(riid, IID_IClassFactory)) Report("QueryInterface Got IID_IClassFactory", 0);
        else ASSERT(0);
    }
    else {
        result = ResultFromScode(E_NOINTERFACE);
        Report("QueryInterface FAILED", (DWORD)result);
    }

    return result; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\hardtotl.cpp ===
/*
 *  HARDTOTL.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSHardTotals)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSHardTotals)



STDMETHODIMP_(LONG) COPOSHardTotals::BeginTrans()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::ClaimFile(LONG HTotalsFile, LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::CommitTrans()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Create(BSTR FileName, LONG* pHTotalsFile, LONG Size, BOOL ErrorDetection)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Delete(BSTR FileName)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Find(BSTR FileName, LONG* pHTotalsFile, LONG* pSize)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::FindByIndex(LONG Index, BSTR* pFileName)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Read(LONG HTotalsFile, BSTR* pData, LONG Offset, LONG Count)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::RecalculateValidationData(LONG HTotalsFile)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::ReleaseFile(LONG HTotalsFile)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Rename(LONG HTotalsFile, BSTR FileName)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Rollback()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::SetAll(LONG HTotalsFile, LONG Value)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::ValidateData(LONG HTotalsFile)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSHardTotals::Write(LONG HTotalsFile, BSTR Data, LONG Offset, LONG Count)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\fiscprnt.cpp ===
/*
 *  FISCPRNT.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSFiscalPrinter)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSFiscalPrinter)



STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginFiscalDocument(LONG DocumentAmount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}


STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginFiscalReceipt(BOOL PrintHeader)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginFixedOutput(LONG Station, LONG DocumentType)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginInsertion(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginItemList(LONG VatID)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginNonFiscal()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginRemoval(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::BeginTraining()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::ClearError()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndFiscalDocument()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndFiscalReceipt(BOOL PrintHeader)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndFixedOutput()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndInsertion()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndItemList()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndNonFiscal()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndRemoval()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::EndTraining()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::GetData(LONG DataItem, LONG* OptArgs, BSTR* Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::GetDate(BSTR* Date)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::GetTotalizer(LONG VatID, LONG OptArgs, BSTR* Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::GetVatEntry(LONG VatID, LONG OptArgs, LONG* VatRate)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintDuplicateReceipt()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintFiscalDocumentLine(BSTR DocumentLine)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintFixedOutput(LONG DocumentType, LONG LineNumber, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintNormal(LONG Station, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintPeriodicTotalsReport(BSTR Date1, BSTR Date2)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintPowerLossReport()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecItem(BSTR Description, CURRENCY Price, LONG Quantity, LONG VatInfo, CURRENCY OptUnitPrice, BSTR UnitName)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecItemAdjustment(LONG AdjustmentType, BSTR Description, CURRENCY Amount, LONG VatInfo)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecMessage(BSTR Message)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecNotPaid(BSTR Description, CURRENCY Amount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecRefund(BSTR Description, CURRENCY Amount, LONG VatInfo)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecSubtotal(CURRENCY Amount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecSubtotalAdjustment(LONG AdjustmentType, BSTR Description, CURRENCY Amount)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecTotal(CURRENCY Total, CURRENCY Payment, BSTR Description)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecVoid(BSTR Description)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintRecVoidItem(BSTR Description, CURRENCY Amount, LONG Quantity, LONG AdjustmentType, CURRENCY Adjustment, LONG VatInfo)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintReport(LONG ReportType, BSTR StartNum, BSTR EndNum)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintXReport()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::PrintZReport()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::ResetPrinter()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetDate(BSTR Date)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetHeaderLine(LONG LineNumber, BSTR Text, BOOL DoubleWidth)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetPOSID(BSTR POSID, BSTR CashierID)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetStoreFiscalID(BSTR ID)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetTrailerLine(LONG LineNumber, BSTR Text, BOOL DoubleWidth)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetVatTable()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::SetVatValue(LONG VatID, BSTR VatValue)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSFiscalPrinter::VerifyItem(BSTR ItemName, LONG VatID)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}


STDMETHODIMP_(void) COPOSFiscalPrinter::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}


STDMETHODIMP_(void) COPOSFiscalPrinter::StatusUpdateEvent(LONG Data)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\debug.cpp ===
/*
 *  DEBUG.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


VOID Report(LPSTR szMsg, DWORD num)
{
    char msg[MAX_PATH];

    wsprintf((LPSTR)msg, "%s (%xh=%d).", szMsg, num, num);
	MessageBox((HWND)NULL, (LPSTR)msg, (LPCSTR)"OPOSCTRL", MB_OK|MB_ICONEXCLAMATION);
}

LPSTR DbgHresultStr(DWORD hres)
{
    LPSTR str = "???";

    switch (hres){
        #define MAKECASE(res) case res: str = #res; break;

        MAKECASE(S_OK);
        MAKECASE(E_FAIL);
        MAKECASE(REGDB_E_CLASSNOTREG);
        MAKECASE(E_NOINTERFACE);
        MAKECASE(REGDB_E_READREGDB);
        MAKECASE(CO_E_DLLNOTFOUND);
        MAKECASE(CO_E_APPNOTFOUND);
        MAKECASE(E_ACCESSDENIED);
        MAKECASE(CO_E_ERRORINDLL);
        MAKECASE(CO_E_APPDIDNTREG);
    }

    return str;
}


VOID ReportHresultErr(LPSTR szMsg, DWORD hres)
{
    char msg[MAX_PATH];

    wsprintf((LPSTR)msg, "%s %s (%xh=%d).", szMsg, DbgHresultStr(hres), hres, hres);
	MessageBox((HWND)NULL, (LPSTR)msg, (LPCSTR)"OPOSCTRL", MB_OK|MB_ICONEXCLAMATION);
}


// BUGBUG REMOVE
IOPOSControl *TestNewControl()
{
    IOPOSControl *oposControlInterface;
    COPOSControl *oposControl = new COPOSControl;

    if (oposControl){
        oposControlInterface = (IOPOSControl *)oposControl;
        oposControlInterface->AddRef();
    }
    else {
        oposControlInterface = NULL;
    }
    
    return oposControlInterface;
}


// BUGBUG REMOVE
void Test()
{
    HINSTANCE libHandle;

    libHandle = LoadLibrary("oposserv.dll");
    if ((ULONG)libHandle >= (ULONG)HINSTANCE_ERROR){
        FARPROC entry = GetProcAddress(libHandle, "Test");

        if (entry){
            #pragma warning(disable:4087)
            // (*entry)();
            OpenServer();
            #pragma warning(default:4087)
        }
        else {
            Report("Couln't get Service's Test() entry.", 0);
        }

        FreeLibrary(libHandle);   
    }
    else {
        Report("Couldn't load Service lib.", 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\keylock.cpp ===
/*
 *  KEYLOCK.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSKeyLock)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSKeyLock)



STDMETHODIMP_(LONG) COPOSKeyLock::WaitForKeylockChange(LONG KeyPosition, LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSKeyLock::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\iclsfact.cpp ===
/*
 *  ICLSFACT.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


STDMETHODIMP COPOSControl::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT result;

    Report("CreateInstance", 0);

    if (pUnkOuter){
        result = CLASS_E_NOAGGREGATION;
    }
    else {
        COPOSControl *oposControl = new COPOSControl;
        if (oposControl){

            /*
             *  Get the requested interface on this object.
             *  This also does an AddRef.
             */
            result = oposControl->QueryInterface(riid, ppvObj);
        }
        else {
            result = E_OUTOFMEMORY;
        }
    }

    Report("CreateInstance", (DWORD)result);

    ASSERT(result == S_OK);
    return result;
}

STDMETHODIMP COPOSControl::LockServer(int lock)
{
    if (lock){
        m_serverLockCount++;
    }
    else {
        m_serverLockCount--;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\keybrd.cpp ===
/*
 *  KEYBRD.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSKeyboard)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSKeyboard)



STDMETHODIMP_(void) COPOSKeyboard::DataEvent(LONG Status)
{
    // BUGBUG REMOVE
}

STDMETHODIMP_(void) COPOSKeyboard::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG REMOVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\main.cpp ===
/*
 *  MAIN.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


struct controlType controlTypes[] = 
{
    {   CONTROL_BUMP_BAR,                   "BumpBar"               },
    {   CONTROL_CASH_CHANGER,               "CashChanger"           },
    {   CONTROL_CASH_DRAWER,                "CashDrawer"            },
    {   CONTROL_COIN_DISPENSER,             "CoinDispenser"         },
    {   CONTROL_FISCAL_PRINTER,             "FiscalPrinter"         },
    {   CONTROL_HARD_TOTALS,                "HardTotals"            },
    {   CONTROL_KEYLOCK,                    "Keylock"               },
    {   CONTROL_LINE_DISPLAY,               "LineDisplay"           },
    {   CONTROL_MICR,                       "MICR"                  },   
    {   CONTROL_MSR,                        "MSR"                   },  
    {   CONTROL_PIN_PAD,                    "PINPad"                },
    {   CONTROL_POS_KEYBOARD,               "POSKeyboard"           },
    {   CONTROL_POS_PRINTER,                "POSPrinter"            },
    {   CONTROL_REMOTE_ORDER_DISPLAY,       "RemoteOrderDisplay"    },
    {   CONTROL_SCALE,                      "Scale"                 },
    {   CONTROL_SCANNER,                    "Scanner"               },
    {   CONTROL_SIGNATURE_CAPTURE,          "SignatureCapture"      },
    {   CONTROL_TONE_INDICATOR,             "ToneIndicator"         },

    {   CONTROL_LAST,                       ""                      }
    
};


/*
 ************************************************************
 *  DllMain
 ************************************************************
 *
 *
 */
STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    BOOLEAN result;

    switch (dwReason){
        
        case DLL_PROCESS_ATTACH:
            Report("DllMain: DLL_PROCESS_ATTACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            Report("DllMain: DLL_PROCESS_DETACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        case DLL_THREAD_ATTACH:
            Report("DllMain: DLL_THREAD_ATTACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        case DLL_THREAD_DETACH:
            Report("DllMain: DLL_THREAD_DETACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        default: 
            Report("DllMain", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

    }

    return result;
}


void OpenServer()
{
    HRESULT hres;

    hres = OleInitialize(NULL);

    if ((hres == S_OK) || (hres == S_FALSE)){
        IOPOSService *iOposService = NULL;

        Report("Ole is initialized, calling CoCreateInstance", (DWORD)hres);

        /*
         *  Create an instance of the OPOS server object
         *  and get a pointer to it's server interface.
         *  CoCreateInstance is simply a wrapper for
         *  CoGetClassObject + CreateInstance on that object.
         */
        hres = CoCreateInstance(   
                            GUID_HID_OPOS_SERVER,
                            NULL, 
                            CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER,
                            IID_HID_OPOS_SERVER, 
                            (PVOID *)&iOposService); 
        if (hres == S_OK){

            Report("CoCreateInstance got server's interface", (DWORD)iOposService);

            // xxx
        }
        else {
            ReportHresultErr("CoCreateInstance failed", (DWORD)hres);
        }

    }
    else {
        Report("OleInitialize failed", (DWORD)hres);
    }
}



// BUGBUG - this runs contrary to the spec (supposed to be a method)
/*
 *
 *
 */
IOPOSControl *OpenControl(PCHAR DeviceName)
{
    IOPOSControl *iOposControl;
    int i;

    for (i = 0; controlTypes[i].type != CONTROL_LAST; i++){
        if (!lstrcmpi((LPSTR)DeviceName, controlTypes[i].deviceName)){
            break;
        }
    }

    switch (controlTypes[i].type){
        case CONTROL_BUMP_BAR:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSBumpBar; 
            break;
        case CONTROL_CASH_CHANGER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSCashChanger; 
            break;
        case CONTROL_CASH_DRAWER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSCashDrawer; 
            break;
        case CONTROL_COIN_DISPENSER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSCoinDispenser; 
            break;
        case CONTROL_FISCAL_PRINTER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSFiscalPrinter; 
            break;
        case CONTROL_HARD_TOTALS:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSHardTotals; 
            break;
        case CONTROL_KEYLOCK:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSKeyLock; 
            break;
        case CONTROL_LINE_DISPLAY:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSLineDisplay; 
            break;
        case CONTROL_MICR:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSMICR; 
            break;
        case CONTROL_MSR:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSMSR; 
            break;
        case CONTROL_PIN_PAD:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSPinPad; 
            break;
        case CONTROL_POS_KEYBOARD:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSKeyboard; 
            break;
        case CONTROL_POS_PRINTER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSPrinter; 
            break;
        case CONTROL_REMOTE_ORDER_DISPLAY:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSRemoteOrderDisplay; 
            break;
        case CONTROL_SCALE:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSScale; 
            break;
        case CONTROL_SCANNER:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSScanner; 
            break;
        case CONTROL_SIGNATURE_CAPTURE:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSSignatureCapture; 
            break;
        case CONTROL_TONE_INDICATOR:
            iOposControl = (IOPOSControl *)(COPOSControl *)new COPOSToneIndicator; 
            break;

        case CONTROL_LAST:
        default:
            iOposControl = NULL;
            break;
    }

    if (iOposControl){
        iOposControl->AddRef();
    }
    else {
        Report("Open failed", controlTypes[i].type);
    }

    return iOposControl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\micr.cpp ===
/*
 *  MICR.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSMICR)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSMICR)



STDMETHODIMP_(LONG) COPOSMICR::BeginInsertion(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSMICR::BeginRemoval(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSMICR::EndInsertion()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSMICR::EndRemoval()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSMICR::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSMICR::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\linedisp.cpp ===
/*
 *  LINEDISP.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSLineDisplay)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSLineDisplay)




STDMETHODIMP_(LONG) COPOSLineDisplay::ClearDescriptors()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::ClearText()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

// BUGBUG conflict ???   STDMETHODIMP_(LONG) COPOSLineDisplay::CreateWindow(LONG ViewportRow, LONG ViewportColumn, LONG ViewportHeight, LONG ViewportWidth, LONG WindowHeight, LONG WindowWidth)

STDMETHODIMP_(LONG) COPOSLineDisplay::DestroyWindow()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::DisplayText(BSTR Data, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::DisplayTextAt(LONG Row, LONG Column, BSTR Data, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::RefreshWindow(LONG Window)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::ScrollText(LONG Direction, LONG Units)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSLineDisplay::SetDescriptor(LONG Descriptor, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\oposctrl.cpp ===
/*
 *  OPOSCTRL.CPP
 *
 *
 *
 *
 *
 *
 */
#include <windows.h>

#define INITGUID
#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"





COPOSControl::COPOSControl()
{
    m_refCount = 0;
    m_serverLockCount = 0;

    /*
     *  According to the spec, 
     *  these are the only properties which require initialization.
     */
    State = OPOS_S_CLOSED;
    ResultCode = OPOS_E_CLOSED;
    ControlObjectDescription = "BUGBUG - CO description";	// Control Object dependent string.
    ControlObjectVersion = 1;  // BUGBUG	Control Object dependent number.

}

COPOSControl::~COPOSControl()
{
    ASSERT(m_refCount == 0);
    ASSERT(m_serverLockCount == 0);
}


STDMETHODIMP_(LONG) COPOSControl::Open(BSTR DeviceName) 
{
    Claimed = TRUE;
    DeviceEnabled = TRUE;
    DataEventEnabled = TRUE;
    FreezeEvents = TRUE;

    // BUGBUG FINISH
    return 0;
}

STDMETHODIMP_(LONG) COPOSControl::Close()
{
    Claimed = FALSE;
    DeviceEnabled = FALSE;
    DataEventEnabled = FALSE;
    FreezeEvents = FALSE;

    // BUGBUG FINISH
    return 0;
}

STDMETHODIMP_(LONG) COPOSControl::CheckHealth(LONG Level)
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}

STDMETHODIMP_(LONG) COPOSControl::Claim(LONG Timeout)
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}

STDMETHODIMP_(LONG) COPOSControl::ClearInput()
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}

STDMETHODIMP_(LONG) COPOSControl::ClearOutput()
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}

STDMETHODIMP_(LONG) COPOSControl::DirectIO(LONG Command, LONG* pData, BSTR* pString)
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}

#if 0
    // BUGBUG overrides IUnknown ?
STDMETHODIMP_(LONG) COPOSControl::Release()
{
    // BUGBUG FINISH
    return 0;
}
#endif

STDMETHODIMP_(void) COPOSControl::SOData(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSControl::SODirectIO(LONG EventNumber, LONG* pData, BSTR* pString)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSControl::DirectIOEvent(LONG EventNumber, LONG* pData, BSTR* pString)
{
    // BUGBUG FINISH

}

STDMETHODIMP_(void) COPOSControl::SOError(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH

}

STDMETHODIMP_(void) COPOSControl::SOOutputComplete(LONG OutputID)
{
    // BUGBUG FINISH

}

STDMETHODIMP_(void) COPOSControl::OutputCompleteEvent(LONG OutputID)
{
    // BUGBUG FINISH

}

STDMETHODIMP_(void) COPOSControl::SOStatusUpdate(LONG Data)
{
    // BUGBUG FINISH

}

STDMETHODIMP_(LONG) COPOSControl::SOProcessID()
{
    LONG result;

    if (DeviceEnabled){

        // BUGBUG FINISH
        result = OPOS_E_NOSERVICE;

    }
    else {
        result = OPOS_E_CLOSED;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\msr.cpp ===
/*
 *  MSR.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSMSR)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSMSR)




STDMETHODIMP_(void) COPOSMSR::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSMSR::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\pinpad.cpp ===
/*
 *  PINPAD.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSPinPad)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSPinPad)




STDMETHODIMP_(LONG) COPOSPinPad::BeginEFTTransaction(BSTR PINPadSystem, LONG TransactionHost)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPinPad::ComputeMAC(BSTR InMsg, BSTR* pOutMsg)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPinPad::EnablePINEntry()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPinPad::EndEFTTransaction(LONG CompletionCode)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPinPad::UpdateKey(LONG KeyNum, BSTR Key)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(BOOL) COPOSPinPad::VerifyMAC(BSTR Message)
{
    BOOL result = FALSE;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSPinPad::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSPinPad::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\printer.cpp ===
/*
 *  PRINTER.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSPrinter)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSPrinter)



STDMETHODIMP_(LONG) COPOSPrinter::BeginInsertion(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::BeginRemoval(LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::CutPaper(LONG Percentage)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::EndInsertion()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::EndRemoval()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::PrintBarCode(LONG Station, BSTR Data, LONG Symbology, LONG Height, LONG Width, LONG Alignment, LONG TextPosition)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::PrintBitmap(LONG Station, BSTR FileName, LONG Width, LONG Alignment)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::PrintImmediate(LONG Station, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::PrintNormal(LONG Station, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::PrintTwoNormal(LONG Stations, BSTR Data1, BSTR Data2)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::RotatePrint(LONG Station, LONG Rotation)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::SetBitmap(LONG BitmapNumber, LONG Station, BSTR FileName, LONG Width, LONG Alignment)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::SetLogo(LONG Location, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::TransactionPrint(LONG Station, LONG Control)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSPrinter::ValidateData(LONG Station, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSPrinter::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSPrinter::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\oposctrl.h ===
/*
 *  OPOSCTRL.H
 *
 *
 *
 *
 *
 *
 */

/*
 *  Generic OPOS control class.
 *  Implements common methods for all OPOS controls.
 *  Control classes for specific OPOS controls inherit from this.
 */
class COPOSControl : public IOPOSControl
{
    protected:
        DWORD m_refCount;
        DWORD m_serverLockCount;

        /*
         *  Control properties
         *  (from Chapter 1 of OPOS APG spec)   
         *
         *  BUGBUG - are these to be kept in the registry ?
         *
         */
        BOOL    AutoDisable;
        LONG    BinaryConversion;
        LONG    CapPowerReporting;
        PCHAR   CheckHealthText;
        BOOL    Claimed;
        LONG    DataCount;
        BOOL    DataEventEnabled;
        BOOL    DeviceEnabled;
        BOOL    FreezeEvents;
        LONG    OutputID;
        LONG    PowerNotify;
        LONG    PowerState;
        LONG    ResultCode;
        LONG    ResultCodeExtended;
        LONG    State;
        PCHAR   ControlObjectDescription;
        LONG    ControlObjectVersion;
        PCHAR   ServiceObjectDescription;
        LONG    ServiceObjectVersion;
        PCHAR   DeviceDescription;
        PCHAR   DeviceName;


    public:
        COPOSControl();
        ~COPOSControl();

        /*
         *  IUnknown methods
         */
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        /*
         *  IClassFactory methods
         */
        STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj); 
        STDMETHODIMP LockServer(int lock); 

        /*
         *  IOPOSControl methods
         */ 
        STDMETHODIMP_(LONG) Open(BSTR DeviceName); 
        STDMETHODIMP_(LONG) Close();   

        STDMETHODIMP_(LONG) CheckHealth(LONG Level);
        STDMETHODIMP_(LONG) Claim(LONG Timeout);
        STDMETHODIMP_(LONG) ClearInput();
        STDMETHODIMP_(LONG) ClearOutput();
        STDMETHODIMP_(LONG) DirectIO(LONG Command, LONG* pData, BSTR* pString);
        // STDMETHODIMP_(LONG) Release();  // BUGBUG overrides IUnknown ?

        STDMETHODIMP_(void) SOData(LONG Status);
        STDMETHODIMP_(void) SODirectIO(LONG EventNumber, LONG* pData, BSTR* pString);
        STDMETHODIMP_(void) DirectIOEvent(LONG EventNumber, LONG* pData, BSTR* pString);
        STDMETHODIMP_(void) SOError(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
        // BUGBUG - moved to sub-ifaces  STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
        STDMETHODIMP_(void) SOOutputComplete(LONG OutputID);
        STDMETHODIMP_(void) OutputCompleteEvent(LONG OutputID);
        STDMETHODIMP_(void) SOStatusUpdate(LONG Data);
        // BUGBUG - moved to sub-ifaces  STDMETHODIMP_(void) StatusUpdateEvent(LONG Data);
        STDMETHODIMP_(LONG) SOProcessID();
};

/*
 *  This macro will define a set of interfaces for each
 *  specific control type to define function headers
 *  for the generic control's methods.
 */
#define DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES() \
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); \
    STDMETHODIMP_(ULONG) AddRef(void); \
    STDMETHODIMP_(ULONG) Release(void); \
    \
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj); \
    STDMETHODIMP LockServer(int lock); \
    \
    STDMETHODIMP_(LONG) Open(BSTR DeviceName); \
    STDMETHODIMP_(LONG) Close(); \
    STDMETHODIMP_(LONG) CheckHealth(LONG Level); \
    STDMETHODIMP_(LONG) Claim(LONG Timeout); \
    STDMETHODIMP_(LONG) ClearInput(); \
    STDMETHODIMP_(LONG) ClearOutput(); \
    STDMETHODIMP_(LONG) DirectIO(LONG Command, LONG* pData, BSTR* pString); \
    STDMETHODIMP_(void) SOData(LONG Status); \
    STDMETHODIMP_(void) SODirectIO(LONG EventNumber, LONG* pData, BSTR* pString); \
    STDMETHODIMP_(void) DirectIOEvent(LONG EventNumber, LONG* pData, BSTR* pString); \
    STDMETHODIMP_(void) SOError(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse); \
    STDMETHODIMP_(void) SOOutputComplete(LONG OutputID); \
    STDMETHODIMP_(void) OutputCompleteEvent(LONG OutputID); \
    STDMETHODIMP_(void) SOStatusUpdate(LONG Data); \
    STDMETHODIMP_(LONG) SOProcessID(); 


/*
 *  This macro will define a set of wrapper functions for each
 *  control type which relay generic control method calls
 *  to the generic control object contained in each specific
 *  control instance.
 *
 *  For example, when a bumpBar instance gets called with
 *  ClearInput(), we relay this to m_genericControl->ClearInput().
 *
 */
#define DEFINE_GENERIC_CONTROL_FUNCTIONS(specificControl) \
    STDMETHODIMP specificControl::QueryInterface(REFIID riid, LPVOID FAR* ppvObj){ return m_genericControl->QueryInterface(riid, ppvObj); } \
    STDMETHODIMP_(ULONG) specificControl::AddRef(void){ return m_genericControl->AddRef(); } \
    STDMETHODIMP_(ULONG) specificControl::Release(void){ return m_genericControl->Release(); } \
    \
    STDMETHODIMP specificControl::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj){ return m_genericControl->CreateInstance(pUnkOuter, riid, ppvObj); } \
    STDMETHODIMP specificControl::LockServer(int lock){ return m_genericControl->LockServer(lock); } \
    \
    STDMETHODIMP_(LONG) specificControl::Open(BSTR DeviceName){ return m_genericControl->Open(DeviceName); } \
    STDMETHODIMP_(LONG) specificControl::Close(){ return m_genericControl->Close(); } \
    STDMETHODIMP_(LONG) specificControl::CheckHealth(LONG Level){ return m_genericControl->CheckHealth(Level); } \
    STDMETHODIMP_(LONG) specificControl::Claim(LONG Timeout){ return m_genericControl->Claim(Timeout); } \
    STDMETHODIMP_(LONG) specificControl::ClearInput(){ return m_genericControl->ClearInput(); } \
    STDMETHODIMP_(LONG) specificControl::ClearOutput(){ return m_genericControl->ClearOutput(); } \
    STDMETHODIMP_(LONG) specificControl::DirectIO(LONG Command, LONG* pData, BSTR* pString){ return m_genericControl->DirectIO(Command, pData, pString); } \
    STDMETHODIMP_(void) specificControl::SOData(LONG Status){ m_genericControl->SOData(Status); } \
    STDMETHODIMP_(void) specificControl::SODirectIO(LONG EventNumber, LONG* pData, BSTR* pString){ m_genericControl->SODirectIO(EventNumber, pData, pString); } \
    STDMETHODIMP_(void) specificControl::DirectIOEvent(LONG EventNumber, LONG* pData, BSTR* pString){ m_genericControl->DirectIOEvent(EventNumber, pData, pString); } \
    STDMETHODIMP_(void) specificControl::SOError(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse){ m_genericControl->SOError(ResultCode, ResultCodeExtended, ErrorLocus, pErrorResponse); } \
    STDMETHODIMP_(void) specificControl::SOOutputComplete(LONG OutputID){ m_genericControl->SOOutputComplete(OutputID); } \
    STDMETHODIMP_(void) specificControl::OutputCompleteEvent(LONG OutputID){ m_genericControl->OutputCompleteEvent(OutputID); } \
    STDMETHODIMP_(void) specificControl::SOStatusUpdate(LONG Data){ m_genericControl->SOStatusUpdate(Data); } \
    STDMETHODIMP_(LONG) specificControl::SOProcessID(){ return m_genericControl->SOProcessID(); } 

/*
 *  This macro will define default constructor and deconstructor
 *  for each specific control class which just allocates
 *  and frees the m_genericControl member.
 */
#define DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(specificControl) \
    specificControl::specificControl(){ \
        m_genericControl = new COPOSControl; \
        if (m_genericControl) m_genericControl->AddRef(); \
    } \
    specificControl::~specificControl(){ \
        m_genericControl->Release(); \
        m_genericControl = NULL; \
    }




/*
 *  Implementing class for specific control classes.
 *  Each inherits from it's specific interface.
 */
class COPOSBumpBar : public IOPOSBumpBar 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BumpBarSound(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait);
    STDMETHODIMP_(LONG) SetKeyTranslation(LONG Units, LONG ScanCode, LONG LogicalKey);
};
class COPOSCashChanger : public IOPOSCashChanger 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) DispenseCash(BSTR CashCounts);
    STDMETHODIMP_(LONG) DispenseChange(LONG Amount);
    STDMETHODIMP_(LONG) ReadCashCounts(BSTR* pCashCounts, BOOL* pDiscrepancy);

    // events
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
};
class COPOSCashDrawer : public IOPOSCashDrawer 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) OpenDrawer();
    STDMETHODIMP_(LONG) WaitForDrawerClose(LONG BeepTimeout, LONG BeepFrequency, LONG BeepDuration, LONG BeepDelay);

    // events
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
};
class COPOSCoinDispenser : public IOPOSCoinDispenser 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) DispenseChange(LONG Amount);

    // events
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
};
class COPOSFiscalPrinter : public IOPOSFiscalPrinter 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginFiscalDocument(LONG DocumentAmount);
    STDMETHODIMP_(LONG) BeginFiscalReceipt(BOOL PrintHeader);
    STDMETHODIMP_(LONG) BeginFixedOutput(LONG Station, LONG DocumentType);
    STDMETHODIMP_(LONG) BeginInsertion(LONG Timeout);
    STDMETHODIMP_(LONG) BeginItemList(LONG VatID);
    STDMETHODIMP_(LONG) BeginNonFiscal();
    STDMETHODIMP_(LONG) BeginRemoval(LONG Timeout);
    STDMETHODIMP_(LONG) BeginTraining();
    STDMETHODIMP_(LONG) ClearError();
    STDMETHODIMP_(LONG) EndFiscalDocument();
    STDMETHODIMP_(LONG) EndFiscalReceipt(BOOL PrintHeader);
    STDMETHODIMP_(LONG) EndFixedOutput();
    STDMETHODIMP_(LONG) EndInsertion();
    STDMETHODIMP_(LONG) EndItemList();
    STDMETHODIMP_(LONG) EndNonFiscal();
    STDMETHODIMP_(LONG) EndRemoval();
    STDMETHODIMP_(LONG) EndTraining();
    STDMETHODIMP_(LONG) GetData(LONG DataItem, LONG* OptArgs, BSTR* Data);
    STDMETHODIMP_(LONG) GetDate(BSTR* Date);
    STDMETHODIMP_(LONG) GetTotalizer(LONG VatID, LONG OptArgs, BSTR* Data);
    STDMETHODIMP_(LONG) GetVatEntry(LONG VatID, LONG OptArgs, LONG* VatRate);
    STDMETHODIMP_(LONG) PrintDuplicateReceipt();
    STDMETHODIMP_(LONG) PrintFiscalDocumentLine(BSTR DocumentLine);
    STDMETHODIMP_(LONG) PrintFixedOutput(LONG DocumentType, LONG LineNumber, BSTR Data);
    STDMETHODIMP_(LONG) PrintNormal(LONG Station, BSTR Data);
    STDMETHODIMP_(LONG) PrintPeriodicTotalsReport(BSTR Date1, BSTR Date2);
    STDMETHODIMP_(LONG) PrintPowerLossReport();
    STDMETHODIMP_(LONG) PrintRecItem(BSTR Description, CURRENCY Price, LONG Quantity, LONG VatInfo, CURRENCY OptUnitPrice, BSTR UnitName);
    STDMETHODIMP_(LONG) PrintRecItemAdjustment(LONG AdjustmentType, BSTR Description, CURRENCY Amount, LONG VatInfo);
    STDMETHODIMP_(LONG) PrintRecMessage(BSTR Message);
    STDMETHODIMP_(LONG) PrintRecNotPaid(BSTR Description, CURRENCY Amount);
    STDMETHODIMP_(LONG) PrintRecRefund(BSTR Description, CURRENCY Amount, LONG VatInfo);
    STDMETHODIMP_(LONG) PrintRecSubtotal(CURRENCY Amount);
    STDMETHODIMP_(LONG) PrintRecSubtotalAdjustment(LONG AdjustmentType, BSTR Description, CURRENCY Amount);
    STDMETHODIMP_(LONG) PrintRecTotal(CURRENCY Total, CURRENCY Payment, BSTR Description);
    STDMETHODIMP_(LONG) PrintRecVoid(BSTR Description);
    STDMETHODIMP_(LONG) PrintRecVoidItem(BSTR Description, CURRENCY Amount, LONG Quantity, LONG AdjustmentType, CURRENCY Adjustment, LONG VatInfo);
    STDMETHODIMP_(LONG) PrintReport(LONG ReportType, BSTR StartNum, BSTR EndNum);
    STDMETHODIMP_(LONG) PrintXReport();
    STDMETHODIMP_(LONG) PrintZReport();
    STDMETHODIMP_(LONG) ResetPrinter();
    STDMETHODIMP_(LONG) SetDate(BSTR Date);
    STDMETHODIMP_(LONG) SetHeaderLine(LONG LineNumber, BSTR Text, BOOL DoubleWidth);
    STDMETHODIMP_(LONG) SetPOSID(BSTR POSID, BSTR CashierID);
    STDMETHODIMP_(LONG) SetStoreFiscalID(BSTR ID);
    STDMETHODIMP_(LONG) SetTrailerLine(LONG LineNumber, BSTR Text, BOOL DoubleWidth);
    STDMETHODIMP_(LONG) SetVatTable();
    STDMETHODIMP_(LONG) SetVatValue(LONG VatID, BSTR VatValue);
    STDMETHODIMP_(LONG) VerifyItem(BSTR ItemName, LONG VatID);

    // events
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Data);
};
class COPOSHardTotals : public IOPOSHardTotals 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginTrans();
    STDMETHODIMP_(LONG) ClaimFile(LONG HTotalsFile, LONG Timeout);
    STDMETHODIMP_(LONG) CommitTrans();
    STDMETHODIMP_(LONG) Create(BSTR FileName, LONG* pHTotalsFile, LONG Size, BOOL ErrorDetection);
    STDMETHODIMP_(LONG) Delete(BSTR FileName);
    STDMETHODIMP_(LONG) Find(BSTR FileName, LONG* pHTotalsFile, LONG* pSize);
    STDMETHODIMP_(LONG) FindByIndex(LONG Index, BSTR* pFileName);
    STDMETHODIMP_(LONG) Read(LONG HTotalsFile, BSTR* pData, LONG Offset, LONG Count);
    STDMETHODIMP_(LONG) RecalculateValidationData(LONG HTotalsFile);
    STDMETHODIMP_(LONG) ReleaseFile(LONG HTotalsFile);
    STDMETHODIMP_(LONG) Rename(LONG HTotalsFile, BSTR FileName);
    STDMETHODIMP_(LONG) Rollback();
    STDMETHODIMP_(LONG) SetAll(LONG HTotalsFile, LONG Value);
    STDMETHODIMP_(LONG) ValidateData(LONG HTotalsFile);
    STDMETHODIMP_(LONG) Write(LONG HTotalsFile, BSTR Data, LONG Offset, LONG Count);
};
class COPOSKeyLock : public IOPOSKeyLock 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) WaitForKeylockChange(LONG KeyPosition, LONG Timeout);

    // events
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
};
class COPOSLineDisplay : public IOPOSLineDisplay 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) ClearDescriptors();
    STDMETHODIMP_(LONG) ClearText();
    // BUGBUG conflict ???   STDMETHODIMP_(LONG) CreateWindow(LONG ViewportRow, LONG ViewportColumn, LONG ViewportHeight, LONG ViewportWidth, LONG WindowHeight, LONG WindowWidth);
    STDMETHODIMP_(LONG) DestroyWindow();
    STDMETHODIMP_(LONG) DisplayText(BSTR Data, LONG Attribute);
    STDMETHODIMP_(LONG) DisplayTextAt(LONG Row, LONG Column, BSTR Data, LONG Attribute);
    STDMETHODIMP_(LONG) RefreshWindow(LONG Window);
    STDMETHODIMP_(LONG) ScrollText(LONG Direction, LONG Units);
    STDMETHODIMP_(LONG) SetDescriptor(LONG Descriptor, LONG Attribute);
};
class COPOSMICR : public IOPOSMICR 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginInsertion(LONG Timeout);
    STDMETHODIMP_(LONG) BeginRemoval(LONG Timeout);
    STDMETHODIMP_(LONG) EndInsertion();
    STDMETHODIMP_(LONG) EndRemoval();

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSMSR : public IOPOSMSR 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSPinPad : public IOPOSPinPad 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginEFTTransaction(BSTR PINPadSystem, LONG TransactionHost);
    STDMETHODIMP_(LONG) ComputeMAC(BSTR InMsg, BSTR* pOutMsg);
    STDMETHODIMP_(LONG) EnablePINEntry();
    STDMETHODIMP_(LONG) EndEFTTransaction(LONG CompletionCode);
    STDMETHODIMP_(LONG) UpdateKey(LONG KeyNum, BSTR Key);
    STDMETHODIMP_(BOOL) VerifyMAC(BSTR Message);

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSKeyboard : public IOPOSKeyboard 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSPrinter : public IOPOSPrinter 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginInsertion(LONG Timeout);
    STDMETHODIMP_(LONG) BeginRemoval(LONG Timeout);
    STDMETHODIMP_(LONG) CutPaper(LONG Percentage);
    STDMETHODIMP_(LONG) EndInsertion();
    STDMETHODIMP_(LONG) EndRemoval();
    STDMETHODIMP_(LONG) PrintBarCode(LONG Station, BSTR Data, LONG Symbology, LONG Height, LONG Width, LONG Alignment, LONG TextPosition);
    STDMETHODIMP_(LONG) PrintBitmap(LONG Station, BSTR FileName, LONG Width, LONG Alignment);
    STDMETHODIMP_(LONG) PrintImmediate(LONG Station, BSTR Data);
    STDMETHODIMP_(LONG) PrintNormal(LONG Station, BSTR Data);
    STDMETHODIMP_(LONG) PrintTwoNormal(LONG Stations, BSTR Data1, BSTR Data2);
    STDMETHODIMP_(LONG) RotatePrint(LONG Station, LONG Rotation);
    STDMETHODIMP_(LONG) SetBitmap(LONG BitmapNumber, LONG Station, BSTR FileName, LONG Width, LONG Alignment);
    STDMETHODIMP_(LONG) SetLogo(LONG Location, BSTR Data);
    STDMETHODIMP_(LONG) TransactionPrint(LONG Station, LONG Control);
    STDMETHODIMP_(LONG) ValidateData(LONG Station, BSTR Data);

    // events
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
};
class COPOSRemoteOrderDisplay : public IOPOSRemoteOrderDisplay 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) ClearVideo(LONG Units, LONG Attribute);
    STDMETHODIMP_(LONG) ClearVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute);
    STDMETHODIMP_(LONG) ControlClock(LONG Units, LONG Function, LONG ClockId, LONG Hour, LONG Min, LONG Sec, LONG Row, LONG Column, LONG Attribute, LONG Mode);
    STDMETHODIMP_(LONG) ControlCursor(LONG Units, LONG Function);
    STDMETHODIMP_(LONG) CopyVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG TargetRow, LONG TargetColumn);
    STDMETHODIMP_(LONG) DisplayData(LONG Units, LONG Row, LONG Column, LONG Attribute, BSTR Data);
    STDMETHODIMP_(LONG) DrawBox(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute, LONG BorderType);
    STDMETHODIMP_(LONG) FreeVideoRegion(LONG Units, LONG BufferId);
    STDMETHODIMP_(LONG) ResetVideo(LONG Units); 
    STDMETHODIMP_(LONG) RestoreVideoRegion(LONG Units, LONG TargetRow, LONG TargetColumn, LONG BufferId);
    STDMETHODIMP_(LONG) SaveVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG BufferId);
    STDMETHODIMP_(LONG) SelectChararacterSet(LONG Units, LONG CharacterSet);
    STDMETHODIMP_(LONG) SetCursor(LONG Units, LONG Row, LONG Column);
    STDMETHODIMP_(LONG) TransactionDisplay(LONG Units, LONG Function);
    STDMETHODIMP_(LONG) UpdateVideoRegionAttribute(LONG Units, LONG Function, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute);
    STDMETHODIMP_(LONG) VideoSound(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait);

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    // BUGBUG - override ?  STDMETHODIMP_(void) OutputCompleteEvent(LONG OutputID);
    STDMETHODIMP_(void) StatusUpdateEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSScale : public IOPOSScale 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) DisplayText(BSTR Data);
    STDMETHODIMP_(LONG) ReadWeight(LONG* pWeightData, LONG Timeout);
    STDMETHODIMP_(LONG) ZeroScale();

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
    
};
class COPOSScanner : public IOPOSScanner 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSSignatureCapture : public IOPOSSignatureCapture 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) BeginCapture(BSTR FormName);
    STDMETHODIMP_(LONG) EndCapture();

    // events
    STDMETHODIMP_(void) DataEvent(LONG Status);
    STDMETHODIMP_(void) ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse);
};
class COPOSToneIndicator : public IOPOSToneIndicator 
{
    protected:
        COPOSControl *m_genericControl;

    public:
    // methods
    DEFINE_GENERIC_CONTROL_FUNCTION_PROTOTYPES()
    STDMETHODIMP_(LONG) Sound(LONG NumberOfCycles, LONG InterSoundWait);
    STDMETHODIMP_(LONG) SoundImmediate();
};






#define ASSERT(fact)    if (!(fact)){ \
                            Report("Assertion '" #fact "' failed in file " __FILE__ " line ", __LINE__); \
                        }



enum controlClass {
    CONTROL_BUMP_BAR,
    CONTROL_CASH_CHANGER,
    CONTROL_CASH_DRAWER,
    CONTROL_COIN_DISPENSER,
    CONTROL_FISCAL_PRINTER,
    CONTROL_HARD_TOTALS,
    CONTROL_KEYLOCK,
    CONTROL_LINE_DISPLAY,
    CONTROL_MICR,       // MAGNETIC INK CHARACTER RECOGNITION READER
    CONTROL_MSR,        // MAGNETIC STRIPE READER
    CONTROL_PIN_PAD,
    CONTROL_POS_KEYBOARD,
    CONTROL_POS_PRINTER,
    CONTROL_REMOTE_ORDER_DISPLAY,
    CONTROL_SCALE,
    CONTROL_SCANNER,    // (BAR CODE READER)
    CONTROL_SIGNATURE_CAPTURE,
    CONTROL_TONE_INDICATOR,

    CONTROL_LAST    // marker, must be last
};

struct controlType {
    enum controlClass type;
    PCHAR deviceName; // BUGBUG ? BSTR deviceName;
};

/*
 *  Function prototypes
 */
void OpenServer();

VOID Report(LPSTR szMsg, DWORD num);
LPSTR DbgHresultStr(DWORD hres);
VOID ReportHresultErr(LPSTR szMsg, DWORD hres);
void Test(); // BUGBUG REMOVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\scanner.cpp ===
/*
 *  SCANNER.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSScanner)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSScanner)



STDMETHODIMP_(void) COPOSScanner::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSScanner::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\scale.cpp ===
/*
 *  SCALE.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSScale)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSScale)



STDMETHODIMP_(LONG) COPOSScale::DisplayText(BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSScale::ReadWeight(LONG* pWeightData, LONG Timeout)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSScale::ZeroScale()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSScale::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSScale::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\sigcap.cpp ===
/*
 *  SIGCAP.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSSignatureCapture)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSSignatureCapture)



STDMETHODIMP_(LONG) COPOSSignatureCapture::BeginCapture(BSTR FormName)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSSignatureCapture::EndCapture()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSSignatureCapture::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSSignatureCapture::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\tone.cpp ===
/*
 *  TONE.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"



/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSToneIndicator)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSToneIndicator)




STDMETHODIMP_(LONG) COPOSToneIndicator::Sound(LONG NumberOfCycles, LONG InterSoundWait)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSToneIndicator::SoundImmediate()
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposctrl\remote.cpp ===
/*
 *  REMOTE.CPP
 *
 *  
 *
 *
 *
 *
 */
#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposctrl.h"


/*
 *  Define constructor/deconstructor.
 */
DEFINE_DEFAULT_CONTROL_CONSTRUCTOR(COPOSRemoteOrderDisplay)

/*
 *  Define local methods to relay all generic control
 *  method calls to the m_genericControl member.
 */
DEFINE_GENERIC_CONTROL_FUNCTIONS(COPOSRemoteOrderDisplay)



STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::ClearVideo(LONG Units, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::ClearVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::ControlClock(LONG Units, LONG Function, LONG ClockId, LONG Hour, LONG Min, LONG Sec, LONG Row, LONG Column, LONG Attribute, LONG Mode)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::ControlCursor(LONG Units, LONG Function)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::CopyVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG TargetRow, LONG TargetColumn)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::DisplayData(LONG Units, LONG Row, LONG Column, LONG Attribute, BSTR Data)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::DrawBox(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute, LONG BorderType)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::FreeVideoRegion(LONG Units, LONG BufferId)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::ResetVideo(LONG Units) 
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::RestoreVideoRegion(LONG Units, LONG TargetRow, LONG TargetColumn, LONG BufferId)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::SaveVideoRegion(LONG Units, LONG Row, LONG Column, LONG Height, LONG Width, LONG BufferId)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::SelectChararacterSet(LONG Units, LONG CharacterSet)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::SetCursor(LONG Units, LONG Row, LONG Column)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::TransactionDisplay(LONG Units, LONG Function)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::UpdateVideoRegionAttribute(LONG Units, LONG Function, LONG Row, LONG Column, LONG Height, LONG Width, LONG Attribute)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(LONG) COPOSRemoteOrderDisplay::VideoSound(LONG Units, LONG Frequency, LONG Duration, LONG NumberOfCycles, LONG InterSoundWait)
{
    LONG result = 0;

    // BUGBUG FINISH
    return result;
}

STDMETHODIMP_(void) COPOSRemoteOrderDisplay::DataEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSRemoteOrderDisplay::StatusUpdateEvent(LONG Status)
{
    // BUGBUG FINISH
}

STDMETHODIMP_(void) COPOSRemoteOrderDisplay::ErrorEvent(LONG ResultCode, LONG ResultCodeExtended, LONG ErrorLocus, LONG* pErrorResponse)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\debug.cpp ===
/*
 *  DEBUG.CPP
 *
 *
 *
 *
 *
 *
 */

#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>
#include <setupapi.h>


#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposserv.h"


VOID Report(LPSTR szMsg, DWORD num)
{
    char msg[MAX_PATH];

    wsprintf((LPSTR)msg, "%s (%xh=%d).", szMsg, num, num);
	MessageBox((HWND)NULL, (LPSTR)msg, (LPCSTR)"OPOSSERV", MB_OK|MB_ICONEXCLAMATION);
}



void Test()
{
    HDEVINFO hDevInfo;

    Report("Test()", 0);

    hDevInfo = SetupDiGetClassDevs(    
                    (LPGUID)&GUID_CLASS_INPUT,  // BUGBUG change to POS
                    NULL, 
                    NULL, 
                    DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    if (hDevInfo == INVALID_HANDLE_VALUE){
        Report("SetupDiGetClassDevs failed", (DWORD)GetLastError());
    }
    else {
        SP_DEVICE_INTERFACE_DATA deviceData;
        BOOLEAN enumOk;
        DWORD memberIndex = 0;

        deviceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        do {
            enumOk = SetupDiEnumDeviceInterfaces(
                hDevInfo,
                NULL,
                (LPGUID)&GUID_CLASS_INPUT,
                memberIndex,
                &deviceData
                );
            if (enumOk){
                CHAR detailBuf[MAX_PATH+1+sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA)] = "";
                PSP_DEVICE_INTERFACE_DETAIL_DATA detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)&detailBuf;
                BOOLEAN getDetailOk;
                DWORD requiredSize;

                Report("SetupDiEnumDeviceInterfaces succeeded", 0);

                detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                getDetailOk = SetupDiGetDeviceInterfaceDetail(
                        hDevInfo,
                        &deviceData,
                        detailData,
                        sizeof(detailBuf),
                        &requiredSize,
                        NULL
                        );
                if (getDetailOk){
                    HANDLE hFile;

                    Report(detailData->DevicePath, 0);

                    hFile = CreateFile(
                                detailData->DevicePath,
                                GENERIC_READ | GENERIC_WRITE, // | SYNCHRONIZE | FILE_READ_ATTRIBUTES, 
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,   // BUGBUG ? LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_OVERLAPPED,
                                0);
                    if (hFile == INVALID_HANDLE_VALUE){
                        Report("CreateFile failed", (DWORD)GetLastError());
                    }
                    else {
                        BOOL readOk;
                        PCHAR alignedReadPtr;
                        DWORD bytesRead = 0;
                        // OVERLAPPED overlapped;

                        Report("CreateFile succeeded", 0);
        
                        #define BUF_SIZE 100000
                        alignedReadPtr = (PCHAR)VirtualAlloc(NULL, BUF_SIZE, MEM_COMMIT, PAGE_READWRITE);

                        if (alignedReadPtr){
                            Report("Aligned read ptr is ", (DWORD)alignedReadPtr);

                            do {
                                // RtlZeroMemory(&overlapped, sizeof(OVERLAPPED));
                                RtlZeroMemory(alignedReadPtr, BUF_SIZE);

                                readOk = ReadFile(  
                                            hFile,
                                            alignedReadPtr,
                                            0x18,  // BUGBUG 
                                            &bytesRead,
                                            NULL  //  &overlapped
                                            );

                                if (readOk){
                                    Report("ReadFile succeeded", bytesRead);
                                }
                                else {
                                    DWORD err = (DWORD)GetLastError();
                                    switch (err){
                                        case ERROR_INVALID_FUNCTION:
                                            Report("ReadFile: ERROR_INVALID_FUNCTION", err);
                                            break;
                                        case ERROR_ACCESS_DENIED:
                                            Report("ReadFile: ERROR_ACCESS_DENIED", err);
                                            break;
                                        case ERROR_INSUFFICIENT_BUFFER:
                                            Report("ReadFile: ERROR_INSUFFICIENT_BUFFER", err);
                                            break;
                                        case ERROR_IO_PENDING:
                                            Report("ReadFile: ERROR_IO_PENDING", err);
                                            break;
                                        default:
                                            Report("ReadFile failed", err);
                                            break;
                                    }
                                    Report("ReadFile: bytesRead = ", bytesRead);

                                }
                            } while (readOk);

                            VirtualFree(alignedReadPtr, 0, MEM_RELEASE);
                        }
                        else {
                            Report("Memory alloc failed", (DWORD)GetLastError);
                        }
                        CloseHandle(hFile);
                    }



                }
                else {
                    Report("SetupDiGetDeviceInterfaceDetail failed", (DWORD)GetLastError());
                }



                // BUGBUG - just look at the first one for now
                break;
            }
            else {
                DWORD err = GetLastError();

                switch (err){
                    case ERROR_NO_MORE_ITEMS:
                        Report("SetupDiEnumDeviceInterfaces: ERROR_NO_MORE_ITEMS", err);
                        break;
                    default:
                        Report("SetupDiEnumDeviceInterfaces failed", err);
                        break;
                }
            }
            memberIndex++;
        }
        while (enumOk);

    }

    Report("Test() done", 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\iclsfact.cpp ===
/*
 *  CLSFACT.CPP
 *
 *
 *
 *
 *
 *
 */

#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposserv.h"


STDMETHODIMP COPOSService::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT result;

    Report("CreateInstance", 0);

    if (pUnkOuter){
        result = CLASS_E_NOAGGREGATION;
    }
    else {
        COPOSService *oposService = new COPOSService;
        if (oposService){

            /*
             *  Get the requested interface on this object.
             *  This also does an AddRef.
             */
            result = oposService->QueryInterface(riid, ppvObj);
        }
        else {
            result = E_OUTOFMEMORY;
        }
    }

    Report("CreateInstance", (DWORD)result);

    ASSERT(result == S_OK);
    return result;
}

STDMETHODIMP COPOSService::LockServer(int lock)
{
    if (lock){
        m_serverLockCount++;
    }
    else {
        m_serverLockCount--;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\oposserv.cpp ===
/*
 *  OPOSSERV.CPP
 *
 *
 *
 *
 *
 *
 */

#include <windows.h>

#define INITGUID
#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposserv.h"



COPOSService::COPOSService()
{
    m_refCount = 0;
    m_serverLockCount = 0;
}

COPOSService::~COPOSService()
{
    ASSERT(m_refCount == 0);
    ASSERT(m_serverLockCount == 0);
}






/*
 ************************************************************
 *  COPOSService::OpenService
 ************************************************************
 *
 *  Parameters:
 *  ----------
 *
 *  DeviceClass	
 *      Contains the requested device class.  
 *      Examples are "CashDrawer" and "POSPrinter."
 *
 *  DeviceName	
 *      Contains the Device Name to be managed by this Service Object.
 *      The relationship between the device name and physical devices 
 *      is determined by entries within the operating system registry; 
 *      a setup or configuration utility maintains these entries.
 *      (See the "Application Programmer's Guide" appendix "OPOS Registry Usage.")
 *
 *  pDispatch
 *      Points to the Control Object's dispatch interface, 
 *      which contains the event request methods
 *
 */
LONG COPOSService::OpenService(BSTR DeviceClass, BSTR DeviceName, LPDISPATCH pDispatch)
{
    // BUGBUG FINISH
    return 0;
}


LONG COPOSService::CheckHealth(LONG Level)
{
    // BUGBUG FINISH
    return 0;
}

        
LONG COPOSService::Claim(LONG Timeout)
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::ClearInput()
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::ClearOutput()
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::Close()
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::COFreezeEvents(BOOL Freeze)
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::DirectIO(LONG Command, LONG* pData, BSTR* pString)
{
    // BUGBUG FINISH
    return 0;
}

LONG COPOSService::GetPropertyNumber(LONG PropIndex)
{
    // BUGBUG FINISH
    return 0;
}

BSTR COPOSService::GetPropertyString(LONG PropIndex)
{
    // BUGBUG FINISH
    return NULL;
}

void COPOSService::SetPropertyNumber(LONG PropIndex, LONG Number)
{
    // BUGBUG FINISH
}

void COPOSService::SetPropertyString(LONG PropIndex, BSTR String)
{
    // BUGBUG FINISH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\iunknown.cpp ===
/*
 *  IUNKNOWN.CPP
 *
 *
 *
 *
 *
 *
 */

#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposserv.h"


STDMETHODIMP_(ULONG) COPOSService::AddRef()
{
    return ++m_refCount;
}

STDMETHODIMP_(ULONG) COPOSService::Release()
{
    ULONG result;   // need sepate variable in case we free

    if (--m_refCount == 0){
        delete this;
        result = 0;
    }
    else {
        result = m_refCount;
    }

    return result;
}

STDMETHODIMP COPOSService::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT result;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_HID_OPOS_SERVER) ||
        IsEqualIID(riid, IID_IClassFactory)){

        *ppvObj = this;
        this->AddRef();
        result = NOERROR;

        // BUGBUG REMOVE
        if (IsEqualIID(riid, IID_IUnknown)) Report("QueryInterface Got IID_IUnknown", 0);
        else if (IsEqualIID(riid, IID_HID_OPOS_SERVER)) Report("QueryInterface Got IID_HID_OPOS_SERVER", 0);
        else if (IsEqualIID(riid, IID_IClassFactory)) Report("QueryInterface Got IID_IClassFactory", 0);
        else ASSERT(0);
    }
    else {
        result = ResultFromScode(E_NOINTERFACE);
        Report("QueryInterface FAILED", (DWORD)result);
    }

    return result; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\main.cpp ===
/*
 *  MAIN.CPP
 *
 *
 *
 *
 *
 *
 */

#include <windows.h>

#include <hidclass.h>
#include <hidsdi.h>

#include <ole2.h>
#include <ole2ver.h>

#include "..\inc\opos.h"
#include "oposserv.h"


COPOSService *g_oposService = NULL;
DWORD g_classObjId = 0;

/*
 ************************************************************
 *  DllMain
 ************************************************************
 *
 *   
 */
STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static BOOLEAN serverInitialized = FALSE;
    BOOLEAN result;

    switch (dwReason){
        
        case DLL_PROCESS_ATTACH:
            Report("DllMain: DLL_PROCESS_ATTACH", dwReason); // BUGBUG REMOVE
            ASSERT(!serverInitialized);
            result = serverInitialized = InitServer();
            ASSERT(result);
            break;

        case DLL_PROCESS_DETACH:
            Report("DllMain: DLL_PROCESS_DETACH", dwReason); // BUGBUG REMOVE
            ASSERT(serverInitialized);
            ShutdownServer();
            serverInitialized = FALSE;
            result = TRUE;
            break;

        case DLL_THREAD_ATTACH:
            Report("DllMain: DLL_THREAD_ATTACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        case DLL_THREAD_DETACH:
            Report("DllMain: DLL_THREAD_DETACH", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

        default: 
            Report("DllMain", dwReason); // BUGBUG REMOVE
            result = TRUE;
            break;

    }

    return result;
}



/*
 ************************************************************
 *  InitServer
 ************************************************************
 *
 *  Register the server GUID with the OLE library,
 *  making it possible for POS control objects
 *  to open server instances.
 *
 */
BOOLEAN InitServer()
{
    BOOLEAN result = FALSE;
    HRESULT hres;

    hres = OleInitialize(NULL);
    if ((hres == S_OK) || (hres == S_FALSE)){

        Report("Ole is initialized", (DWORD)hres);

        g_oposService = new COPOSService;
        if (g_oposService){
            hres = CoRegisterClassObject(
                        GUID_HID_OPOS_SERVER,
                        (IUnknown *)g_oposService,
                        CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER,
                        REGCLS_MULTIPLEUSE , // BUGBUG ? REGCLS_SINGLEUSE,
                        &g_classObjId);
            if ((hres == S_OK) || (hres == CO_E_OBJISREG)){
                Report("Registered Server", (DWORD)hres);

                result = TRUE;
            }
            else {
                Report("CoRegisterClassObject failed", (DWORD)hres);
            }

            if (!result){
                delete g_oposService;
            }

        }
        else {
            Report("Couldn't create COPOSService instance", 0); 
        }
    }
    else {
        Report("OleInitialize failed", (DWORD)hres);
    }

    return result;
}


/*
 ************************************************************
 *  ShutdownServer
 ************************************************************
 *
 *
 */
void ShutdownServer()
{
    Report("ShutdownServer", 0);

    CoRevokeClassObject(g_classObjId);

    if (g_oposService){
        delete g_oposService;
        g_oposService = NULL;
    }

    OleUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\oposserv\oposserv.h ===
/*
 *  OPOSSERV.H
 *
 *
 *
 *
 *
 *
 */


class COPOSService : public IOPOSService
{
    private:
        DWORD m_refCount;
        DWORD m_serverLockCount;

    public:
        COPOSService();
        ~COPOSService();

        /*
         *  IUnknown methods
         */
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        /*
         *  IClassFactory methods
         */
        STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj); 
        STDMETHODIMP LockServer(int lock); 

        /*
         *  IOPOSService methods
         */
        STDMETHODIMP_(LONG) CheckHealth(LONG Level);
        STDMETHODIMP_(LONG) Claim(LONG Timeout);
        STDMETHODIMP_(LONG) ClearInput() ;
        STDMETHODIMP_(LONG) ClearOutput();
        STDMETHODIMP_(LONG) Close();
        STDMETHODIMP_(LONG) COFreezeEvents(BOOL Freeze);
        STDMETHODIMP_(LONG) DirectIO(LONG Command, LONG* pData, BSTR* pString);
        STDMETHODIMP_(LONG) OpenService(BSTR DeviceClass, BSTR DeviceName, LPDISPATCH pDispatch);
        // STDMETHODIMP_(LONG) Release();  // BUGBUG - override IUnknown ?

        STDMETHODIMP_(LONG) GetPropertyNumber(LONG PropIndex);
        STDMETHODIMP_(BSTR) GetPropertyString(LONG PropIndex);
        STDMETHODIMP_(void) SetPropertyNumber(LONG PropIndex, LONG Number);
        STDMETHODIMP_(void) SetPropertyString(LONG PropIndex, BSTR String);

        // BUGBUG -  + Get/Set type methods
        // BUGBUG -  + events

};



#define ASSERT(fact)    if (!(fact)){ \
                            Report("Assertion '" #fact "' failed in file " __FILE__ " line ", __LINE__); \
                        }


/*
 *  Function prototypes
 */
VOID Report(LPSTR szMsg, DWORD num);
BOOLEAN InitServer();
void ShutdownServer();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\comport.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    comport.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


NTSTATUS CreateSymbolicLink(POSPDOEXT *pdoExt)
{
	NTSTATUS status;
	PWCHAR comPortName;
	static WCHAR comNamePrefix[] = L"\\DosDevices\\COM";
	WCHAR buf[sizeof(comNamePrefix)/sizeof(WCHAR) + 4];
	LONG numLen = MyLog(10, pdoExt->comPortNumber)+1;

	ASSERT((numLen > 0) && (numLen <= 4));

	RtlCopyMemory(buf, comNamePrefix, sizeof(comNamePrefix));

	NumToDecString(	buf+sizeof(comNamePrefix)/sizeof(WCHAR)-1, 
					(USHORT)pdoExt->comPortNumber, 
					(USHORT)numLen);
	buf[sizeof(comNamePrefix)/sizeof(WCHAR) - 1 + numLen] = UNICODE_NULL;

	comPortName = MemDup(buf, sizeof(buf));
	if (comPortName){
		RtlInitUnicodeString(&pdoExt->symbolicLinkName, comPortName);

		status = IoCreateSymbolicLink(&pdoExt->symbolicLinkName, &pdoExt->pdoName);
		if (NT_SUCCESS(status)){
			UNICODE_STRING comPortSuffix;

			/*
			 *  Create the '\Device\POS_x = COMx' entry under HKLM\DEVICEMAP\SERIALCOMM
			 */
			RtlInitUnicodeString(&comPortSuffix, pdoExt->symbolicLinkName.Buffer+(sizeof(L"\\DosDevices\\")-sizeof(WCHAR))/sizeof(WCHAR));
			status = RtlWriteRegistryValue(	RTL_REGISTRY_DEVICEMAP, 
                                            L"SERIALCOMM",
                                            pdoExt->pdoName.Buffer, 
                                            REG_SZ,
                                            comPortSuffix.Buffer,
                                            comPortSuffix.Length + sizeof(WCHAR));
            if (NT_SUCCESS(status)){
                if (isWin9x){
                    NTSTATUS tmpStatus;

                    /*
                     *  Delete the temporary 'COMx=COMx' holder value we created earlier.
                     */
                    tmpStatus = RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                                        L"SERIALCOMM",
                                                        comPortSuffix.Buffer);
                }
            }
            else {
                DBGERR(("CreateSymbolicLink: RtlWriteRegistryValue failed with status %xh.", status));
            }

		}
        else {
            DBGERR(("IoCreateSymbolicLink failed with status %xh.", status));
        }
	}
	else {
        ASSERT(comPortName);
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	return status;
}


NTSTATUS DestroySymbolicLink(POSPDOEXT *pdoExt)
{
	NTSTATUS status;

    /*
     *  Delete the symbolic link.
     *  pdoExt->pdoName.Buffer, which was allocated at pdo creation time,
     *  will get deleted when we delete the pdo.
     */
	ASSERT(pdoExt->symbolicLinkName.Buffer);
	IoDeleteSymbolicLink(&pdoExt->symbolicLinkName);

	status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, 
					L"SERIALCOMM",
					pdoExt->pdoName.Buffer);

	FREEPOOL(pdoExt->symbolicLinkName.Buffer);

	return status;
}


NTSTATUS OpenComPort(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

	// BUGBUG FINISH - security, permissions, etc.

	DBGVERBOSE(("OpenComPort: shareAccess=%xh, desiredAccess=%xh, options=%xh.", 
							(ULONG)irpSp->Parameters.Create.ShareAccess, 
							(ULONG)irpSp->Parameters.Create.SecurityContext->DesiredAccess, 
							(ULONG)irpSp->Parameters.Create.Options));

	if (irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE){
        /*
         *  Attempt to open this device as a directory
         */
		DBGWARN(("OpenComPort: STATUS_NOT_A_DIRECTORY"));
	        status = STATUS_NOT_A_DIRECTORY;
	}
	else {
		FILEEXT *fileExt = ALLOCPOOL(NonPagedPool, sizeof(FILEEXT));
		if (fileExt){
			KIRQL oldIrql;

			KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

			if (IsListEmpty(&pdoExt->fileExtensionList)){

				ASSERT(irpSp->FileObject->FsContext == NULL);
				irpSp->FileObject->FsContext = fileExt;	// BUGBUG ?

				fileExt->signature = ESCPOS_TAG;
				fileExt->fileObject = irpSp->FileObject;
				InsertTailList(&pdoExt->fileExtensionList, &fileExt->listEntry);
				status = STATUS_SUCCESS;
			}
			else {
				/*
				 *  Only allow one open for now
				 */
				DBGWARN(("OpenComPort: failing repeat open"));
				FREEPOOL(fileExt);
				status = STATUS_SHARING_VIOLATION;
			}

			KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
		}
		else {
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}

	irp->IoStatus.Information = 0;

	return status;
}


NTSTATUS CloseComPort(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	KIRQL oldIrql;
	FILEEXT *callerFileExt, *myFileExt;
	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

	ASSERT(irpSp->FileObject);
	ASSERT(irpSp->FileObject->FsContext);
	callerFileExt = (FILEEXT *)irpSp->FileObject->FsContext;
	ASSERT(callerFileExt->signature == ESCPOS_TAG);

	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
	
	if (IsListEmpty(&pdoExt->fileExtensionList)){
		status = STATUS_DEVICE_DATA_ERROR;
	}
	else {
		PLIST_ENTRY listEntry;
			
		// BUGBUG - assume only one open for now
		listEntry = RemoveHeadList(&pdoExt->fileExtensionList);
		myFileExt = CONTAINING_RECORD(listEntry, FILEEXT, listEntry);
		ASSERT(myFileExt->signature == ESCPOS_TAG);
		if (myFileExt == callerFileExt){
			status = STATUS_SUCCESS;
		}
		else {
			/*
			 *  We only allow one open, so this should have been the one
			 */
			ASSERT(myFileExt == callerFileExt);
			InsertHeadList(&pdoExt->fileExtensionList, &myFileExt->listEntry);
			status = STATUS_DEVICE_DATA_ERROR;
		}
	}

	KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

	/*
	 *  Wait until we've dropped the spinlock to call outside the driver to free memory.
	 */
	if (NT_SUCCESS(status)){
		irpSp->FileObject->FsContext = NULL;
		FREEPOOL(myFileExt);
	}
	else {
		DBGERR(("CloseComPort: failing with status %xh.", status));
	}

	irp->IoStatus.Information = 0;

	return status;
}



PWCHAR CreateChildPdoName(PARENTFDOEXT *parentFdoExt, ULONG portNumber)
{
	static WCHAR pdoNamePrefix[] = L"\\Device\\POS_";
	WCHAR buf[sizeof(pdoNamePrefix)/sizeof(WCHAR)+4] = { 0 };
	PWCHAR result;
	ULONG numLen = MyLog(10, portNumber)+1;

	ASSERT((numLen > 0) && (numLen <= 4));

	RtlCopyMemory(buf, pdoNamePrefix, sizeof(pdoNamePrefix));
	NumToDecString(buf+sizeof(pdoNamePrefix)/sizeof(WCHAR)-1, (USHORT)portNumber, (USHORT)numLen);

	result = MemDup(buf, sizeof(buf));

	return result;
}


NTSTATUS CreateCOMPdo(	PARENTFDOEXT *parentFdoExt,
                        ULONG comInterfaceIndex,
                        ENDPOINTINFO *inputEndpointInfo, 
                        ENDPOINTINFO *outputEndpointInfo,
                        ENDPOINTINFO *statusEndpointInfo)
{
    NTSTATUS status;
    LONG comPortNumber;

    comPortNumber = GetComPort(parentFdoExt, comInterfaceIndex);
    if (comPortNumber == -1){
        status = STATUS_DEVICE_DATA_ERROR;
    }
    else {
        PWCHAR deviceName = CreateChildPdoName(parentFdoExt, comPortNumber);
        if (deviceName){
            PDEVICE_OBJECT pdo;
            UNICODE_STRING uPdoName;

            RtlInitUnicodeString(&uPdoName, deviceName);

            status = IoCreateDevice(parentFdoExt->driverObj, 
                                    sizeof(DEVEXT),
                                    &uPdoName,  // name for this device
                                    FILE_DEVICE_SERIAL_PORT, 
                                    0,			// device characteristics
                                    FALSE,		// exclusive - BUGBUG ?
                                    &pdo);		// our device object

            if (NT_SUCCESS(status)){
                DEVEXT *devExt = (DEVEXT *)pdo->DeviceExtension;
                POSPDOEXT *pdoExt;
                KIRQL oldIrql;

                RtlZeroMemory(devExt, sizeof(DEVEXT));

                devExt->signature = DEVICE_EXTENSION_SIGNATURE;
                devExt->isPdo = TRUE;

                pdoExt = &devExt->pdoExt;

                pdoExt->state = STATE_INITIALIZED;
                pdoExt->pdo = pdo;
                pdoExt->parentFdoExt = parentFdoExt;
                pdoExt->comPortNumber = comPortNumber;

                /*
                 *  Initializing variables and endpointinfo for Serial Emulation
                 */
                if (parentFdoExt->posFlag & SERIAL_EMULATION) {
                    InitializeSerEmulVariables(pdoExt);
                    pdoExt->statusEndpointInfo = *statusEndpointInfo;
                    DBGVERBOSE(("CreateCOMPdo: EndpointInfo & Variables for Serial Emulation initialized"));
                }

                RtlInitUnicodeString(&pdoExt->pdoName, deviceName);

                InitializeListHead(&pdoExt->fileExtensionList);
                InitializeListHead(&pdoExt->pendingReadIrpsList);
                InitializeListHead(&pdoExt->pendingWriteIrpsList);
                InitializeListHead(&pdoExt->completedReadPacketsList);

                KeInitializeSpinLock(&pdoExt->devExtSpinLock);

                ExInitializeWorkItem(&pdoExt->writeWorkItem, WorkItemCallback_Write, pdoExt);
                ExInitializeWorkItem(&pdoExt->readWorkItem, WorkItemCallback_Read, pdoExt);

                pdoExt->totalQueuedReadDataLength = 0;

                /*
                 *  Copy contents of endpointInfo structures. To incorporate 
                 *  the ODD_ENDPOINT feature we have to make the checks below.
                 */
                if (inputEndpointInfo){
                    pdoExt->inputEndpointInfo = *inputEndpointInfo;
                }

                if (outputEndpointInfo){
                    pdoExt->outputEndpointInfo = *outputEndpointInfo;
                }

                pdo->StackSize = parentFdoExt->functionDevObj->StackSize+1;

                /*
                 *  Insert child PDO in parent's device relations array.
                 */
                KeAcquireSpinLock(&parentFdoExt->devExtSpinLock, &oldIrql);
                parentFdoExt->deviceRelations->Objects[parentFdoExt->deviceRelations->Count++] = pdo;
                KeReleaseSpinLock(&parentFdoExt->devExtSpinLock, oldIrql);

                ASSERT(!(pdo->Flags & DO_POWER_PAGABLE)); 
                pdo->Flags |= DO_POWER_PAGABLE;

                DBGVERBOSE(("CreateCOMPdo: created pdo %ph, pdoExt = %ph.", pdo, pdoExt));
            }
            else {
                DBGERR(("CreateCOMPdo: IoCreateDevice failed with status %xh.", status));
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(status)){
	        ReleaseCOMPort(comPortNumber);
        }
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


NTSTATUS CleanupIO(POSPDOEXT *pdoExt, PIRP irp)
{
	// BUGBUG FINISH
	irp->IoStatus.Information = 0;
	return STATUS_SUCCESS;
}

NTSTATUS QueryInfo(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION irpSp;

	irpSp = IoGetCurrentIrpStackLocation(irp);

	switch (irpSp->Parameters.QueryFile.FileInformationClass){

		case FileBasicInformation:
			DBGVERBOSE(("  QueryInfo: FileBasicInformation"));
			{
				PFILE_BASIC_INFORMATION basicInfoBuf = irp->AssociatedIrp.SystemBuffer;
				ASSERT(basicInfoBuf);
				RtlCopyMemory(basicInfoBuf, &pdoExt->fileBasicInfo, sizeof(FILE_BASIC_INFORMATION));
				irp->IoStatus.Information = sizeof(FILE_BASIC_INFORMATION);
				status = STATUS_SUCCESS;
			}
			break;

		case FileStandardInformation:
			DBGVERBOSE(("  QueryInfo: FileStandardInformation"));
			{
				PFILE_STANDARD_INFORMATION stdInfoBuf = irp->AssociatedIrp.SystemBuffer;
				ASSERT(stdInfoBuf);
				stdInfoBuf->AllocationSize.QuadPart = 0;
				stdInfoBuf->EndOfFile = stdInfoBuf->AllocationSize;
				stdInfoBuf->NumberOfLinks = 0;
				stdInfoBuf->DeletePending = FALSE;
				stdInfoBuf->Directory = FALSE;
				irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
				status = STATUS_SUCCESS;
			}
			break;

		case FilePositionInformation:
			DBGVERBOSE(("  QueryInfo: FilePositionInformation"));
			/*
			 *  Always return position 0
			 */
			((PFILE_POSITION_INFORMATION)irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset.QuadPart = 0;
			irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
			status = STATUS_SUCCESS;
			break;

		case FileEndOfFileInformation:
			DBGWARN(("  QueryInfo: FileEndOfFileInformation"));
			irp->IoStatus.Information = 0;
			status = STATUS_INVALID_PARAMETER;
			break;

		default:
			DBGWARN(("  QueryInfo: ??? (%xh)", (ULONG)irpSp->Parameters.QueryFile.FileInformationClass));
			irp->IoStatus.Information = 0;
			status = STATUS_INVALID_PARAMETER;
			break;

	}


	return status;
}

NTSTATUS SetInfo(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION irpSp;

	irpSp = IoGetCurrentIrpStackLocation(irp);

	switch (irpSp->Parameters.SetFile.FileInformationClass){

		case FileBasicInformation:
			DBGVERBOSE(("  SetInfo: FileBasicInformation"));
			{
				PFILE_BASIC_INFORMATION basicInfoBuf = irp->AssociatedIrp.SystemBuffer;
				ASSERT(basicInfoBuf);
				RtlCopyMemory(&pdoExt->fileBasicInfo, basicInfoBuf, sizeof(FILE_BASIC_INFORMATION));
				irp->IoStatus.Information = sizeof(FILE_BASIC_INFORMATION);
				status = STATUS_SUCCESS;
			}
			break;

		case FileEndOfFileInformation:
			DBGVERBOSE(("  SetInfo: FileEndOfFileInformation"));
			irp->IoStatus.Information = 0;
			status = STATUS_SUCCESS;
			break;

		#define FileAllocationInformation 19  // BUGBUG - defined in ntioapi.h
		case FileAllocationInformation:
			DBGVERBOSE(("  SetInfo: FileAllocationInformation"));
			irp->IoStatus.Information = 0;
			status = STATUS_SUCCESS;
			break;

		default:
			DBGWARN(("  SetInfo: ??? (%xh)", (ULONG)irpSp->Parameters.SetFile.FileInformationClass));
			irp->IoStatus.Information = 0;
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	return status;
}



NTSTATUS FlushBuffers(POSPDOEXT *pdoExt)
{
    LIST_ENTRY irpsToCompleteList;
    PLIST_ENTRY listEntry;
    PIRP irp;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_SUCCESS;

    DBGVERBOSE(("FlushBuffers"));

    /*
     *  This is so we don't loop forever if they get re-queued on the same thread.
     */
    InitializeListHead(&irpsToCompleteList);

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    /*
     *  Flush all pending Read and Wait Irps (if serial emulation feature is ON)
     */
    while (irp = DequeueReadIrp(pdoExt, TRUE)){
        InsertTailList(&irpsToCompleteList, &irp->Tail.Overlay.ListEntry);
    }

    if (pdoExt->parentFdoExt->posFlag & SERIAL_EMULATION) {
        while (irp = DequeueWaitIrp(pdoExt)){
            InsertTailList(&irpsToCompleteList, &irp->Tail.Overlay.ListEntry);
        }
    }

    /*
     *  Empty out the queued readPackets.  
     *  It's ok to free locked memory with the spinlock held.
     */
    while (!IsListEmpty(&pdoExt->completedReadPacketsList)){
        READPACKET *readPacket;

	    listEntry = RemoveHeadList(&pdoExt->completedReadPacketsList);
	    ASSERT(listEntry);
	    readPacket = CONTAINING_RECORD(listEntry, READPACKET, listEntry);
        FreeReadPacket(readPacket);
    }

    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToCompleteList)) {
        listEntry = RemoveHeadList(&irpsToCompleteList);
        ASSERT(listEntry);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}



NTSTATUS InternalIoctl(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION irpSp;

	irpSp = IoGetCurrentIrpStackLocation(irp);

	switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

		// BUGBUG FINISH

		default:
			DBGVERBOSE(("InternalIoctl: ??? (%xh)", (ULONG)irpSp->Parameters.DeviceIoControl.IoControlCode));
			status = irp->IoStatus.Status;
			break;
	}

	return status;
}



LONG GetComPort(PARENTFDOEXT *parentFdoExt, ULONG comInterfaceIndex)
/*++

Routine Description:

    Get the serial COM port index for a serial interface we're about to create.
    If this is not the first plug-in, it should be sitting in the registry.
    If this is the first plug-in, call GetFreeComPortNumber to reserve a new
    static COM port for this device and store it in our software key.

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/
{
    LONG comNumber = -1;
    NTSTATUS status;
    HANDLE hRegDevice;

    status = IoOpenDeviceRegistryKey(   parentFdoExt->physicalDevObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;
        WCHAR interfaceKeyName[] = L"COMPortForInterfaceXXXX";

        NumToHexString( interfaceKeyName+sizeof(interfaceKeyName)/sizeof(WCHAR)-1-4, 
                        (USHORT)comInterfaceIndex, 
                        4);

        RtlInitUnicodeString(&keyName, interfaceKeyName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = ALLOCPOOL(PagedPool, keyValueTotalSize);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &keyName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                comNumber = (LONG)*((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DBGVERBOSE(("GetComPort: read comport #%xh for interface %xh from registry.", (ULONG)comNumber, comInterfaceIndex));
            }
            else {

                /*
                 *  No COM port number recorded in registry.
                 *  Allocate a new static COM port from the COM name arbiter
                 *  and record it in our software key for the next PnP.
                 */
                comNumber = GetFreeComPortNumber();
                if (comNumber == -1){
                    DBGERR(("GetComPort: GetFreeComPortNumber failed"));
                }
                else {
                    status = ZwSetValueKey( hRegDevice,
                                            &keyName,
                                            0,
                                            REG_DWORD,
                                            &comNumber,
                                            sizeof(ULONG));
                    if (!NT_SUCCESS(status)){
                        DBGERR(("GetComPort: ZwSetValueKey failed with status %xh.", status));
                    }
                }
            }

            FREEPOOL(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGERR(("GetComPort: IoOpenDeviceRegistryKey failed with %xh.", status));
    }


    return comNumber;
}




LONG GetFreeComPortNumber()
/*++

Routine Description:

    Find the index of the next unused serial COM port name in the system
    (e.g. COM3, COM4, etc).

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/

{
	LONG comNumber = -1;


    if (isWin9x){
        /*
         *  Windows 98
         *      Find the first unused name under Hardware\DeviceMap\SerialComm.
         *
         *
         *      BUGBUG:
         *          This algorithm does not find all the COM ports reserved
         *          by modems.  May want to port tomgreen's AllocateCommPort
         *          function from \faulty\Wdm10\usb\driver\ccport\utils.c
         */
	    HANDLE hKey;
	    UNICODE_STRING keyName;
	    NTSTATUS status;
	    OBJECT_ATTRIBUTES objectAttributes;

	    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm");
	    InitializeObjectAttributes( &objectAttributes,
								    &keyName,
								    OBJ_CASE_INSENSITIVE,
								    NULL,				
								    (PSECURITY_DESCRIPTOR)NULL);

	    status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
	    if (NT_SUCCESS(status)){
            #define MAX_COMPORT_NAME_LEN (sizeof("COMxxxx")-1)
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+(MAX_COMPORT_NAME_LEN+1)*sizeof(WCHAR)+sizeof(ULONG)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG i, actualLen;
            ULONG keyIndex = 0;

            /*
             *  This bitmask represents the used COM ports.
             *  Bit i set indicates com port i+1 is reserved.
             *  Initialize with COM1 and COM2 reserved.
             *
             *  BUGBUG - only works for up to 32 ports.
             */
            ULONG comNameMask = 3;

            do {
                status = ZwEnumerateValueKey(
                            hKey,
                            keyIndex++,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen); 
                if (NT_SUCCESS(status)){
                    if (keyValueInfo->Type == REG_SZ){
                        PWCHAR valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                        if (!WStrNCmpI(valuePtr, L"COM", 3)){
                            /*
                             *  valuePtr+3 points the index portion of the COMx string,
                             *  but we can't call LAtoD on it because it is
                             *  NOT NULL-TERMINATED.
                             *  So copy the index into our own buffer, 
                             *  null-terminate that, 
                             *  and call LAtoD to get the numerical index.
                             */
                            WCHAR comPortIndexString[4+1];
                            ULONG thisComNumber;
                            for (i = 0; (i < 4) && (i < keyValueInfo->DataLength/sizeof(WCHAR)); i++){
                                comPortIndexString[i] = valuePtr[3+i];
                            }
                            comPortIndexString[i] = UNICODE_NULL;

                            thisComNumber = LAtoD(comPortIndexString);
                            if (thisComNumber == 0){
                                ASSERT(thisComNumber != 0);
                            }
                            else if (thisComNumber <= sizeof(ULONG)*8){
                                comNameMask |= 1 << (thisComNumber-1);
                            }
                            else {
                                ASSERT(thisComNumber <= sizeof(ULONG)*8);
                            }
                        }
                    }
                }
            } while (NT_SUCCESS(status));

            /*
             *  First clear bit in comNameMask represents the first available COM name.
             */
            for (i = 0; i < sizeof(ULONG)*8; i++){
                if (!(comNameMask & (1 << i))){
                    WCHAR comName[] = L"COMxxxx";
                    ULONG comNumLen;

                    /*
                     *  Save the COM port number that we're returning.
                     */
                    comNumber = i+1;
                    DBGVERBOSE(("GetFreeComPortNumber: got free COM port #%xh.", comNumber));

                    /*
                     *  Write a temporary COMx=COMx holder value to the SERIALCOMM key
                     *  so that no other PDOs get this COM port number.
                     *  This value will get overwritten by <symbolicLinkName=COMx> when the pdo is started.
                     */
                    comNumLen = MyLog(10, comNumber)+1;
                    ASSERT(comNumLen <= 4);
                    NumToDecString(comName+3, (USHORT)comNumber, (USHORT)comNumLen);
                    comName[3+comNumLen] = UNICODE_NULL;
			        status = RtlWriteRegistryValue(	RTL_REGISTRY_DEVICEMAP, 
											        L"SERIALCOMM",
											        comName, 
											        REG_SZ,
											        comName,
											        (3 + comNumLen + 1) * sizeof(WCHAR));
                    ASSERT(NT_SUCCESS(status));

                    break;
                }
            }


        }
        else {
            DBGERR(("GetFreeComPortNumber: ZwOpenKey failed with status %xh", status));
        }

    }
    else {
    
        /*
         *  Windows NT.  
         *      Use the COM Name Arbiter bitmap.
         */

	    HANDLE hKey;
	    OBJECT_ATTRIBUTES objectAttributes;
	    UNICODE_STRING keyName;
	    NTSTATUS status;


	    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
	    InitializeObjectAttributes( &objectAttributes,
								    &keyName,
								    OBJ_CASE_INSENSITIVE,
								    NULL,				
								    (PSECURITY_DESCRIPTOR)NULL);

	    status = ZwOpenKey(	&hKey,
						    KEY_QUERY_VALUE | KEY_SET_VALUE,
						    &objectAttributes);
	    if (NT_SUCCESS(status)){
		    UNICODE_STRING valueName;
		    PVOID rawData;
		    ULONG dataSize;

		    RtlInitUnicodeString(&valueName, L"ComDB");

		    ASSERT(hKey);

		    dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

		    /*
		     *  Allocate one extra byte in case we have to add a byte to ComDB
		     */
		    rawData = ALLOCPOOL(NonPagedPool, dataSize+1);

		    if (rawData){
			    status = ZwQueryValueKey(	hKey, 
										    &valueName, 
										    KeyValuePartialInformation,
										    rawData,
										    dataSize,
										    &dataSize);
			    if (status == STATUS_BUFFER_OVERFLOW){
				    FREEPOOL(rawData);
				    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

				    /*
				     *  Allocate one extra byte in case we have to add a byte to ComDB
				     */
				    rawData = ALLOCPOOL(NonPagedPool, dataSize+1);
				    if (rawData){
					    status = ZwQueryValueKey(	hKey, 
												    &valueName, 
												    KeyValuePartialInformation,
												    rawData,
												    dataSize,
												    &dataSize);
				    }
			    }

			    if (NT_SUCCESS(status)){
				    PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;
				    ULONG b, i;
				    BOOLEAN done = FALSE;

				    ASSERT(dataSize >= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
				    
				    ASSERT(keyPartialInfo->Type == REG_BINARY);

				    /*
				     *  The ComDB value is just a bit mask where bit n set indicates
				     *  that COM port # n+1 is taken.
				     *  Get the index of the first unset bit; starting with bit 2 (COM3).
				     */
				    for (b = 0; (b < dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done; b++){
				    
					    for (i = (b == 0) ? 2 : 0; (i < 8) && !done; i++){
						    if (keyPartialInfo->Data[b] & (1 << i)){
							    /*
							     *  This COM port (#8*b+i+1) is taken, go to the next one.
							     */
						    }
						    else {
							    /*
							     *  Found a free COM port.  
							     *  Write the value back with the new bit set.
							     *  Only write back the number of bytes we read earlier.
							     *  Only use this COM port if the write succeeds.
							     *
							     *  Note:	careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
							     *			struct.  Its real size is 0x0D bytes, 
							     *			but the compiler aligns it to 0x10 bytes.
							     *			So use FIELD_OFFSET, not sizeof, to determine
							     *			how many bytes to write.
							     */
							    keyPartialInfo->Data[b] |= (1 << i);
							    status = ZwSetValueKey(	hKey, 
													    &valueName,
													    0,
													    REG_BINARY,
													    (PVOID)keyPartialInfo->Data, 
													    dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
							    if (NT_SUCCESS(status)){
								    comNumber = 8*b + i + 1;
								    DBGVERBOSE(("GetFreeComPortNumber: got free COM port #%xh.", comNumber));
							    }
							    else {
								    DBGERR(("GetFreeComPortNumber: ZwSetValueKey failed with %xh.", status));
							    }

							    done = TRUE;
						    }
					    }
				    }

				    if ((b == dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done){
					    /*
					     *  No more available bits in ComDB, so add a byte.
					     */
					    ASSERT(comNumber == -1);
					    ASSERT(b > 0);
					    DBGWARN(("ComDB overflow -- adding new byte"));

					    keyPartialInfo->Data[b] = 1;
					    dataSize++;

					    status = ZwSetValueKey(	hKey, 
											    &valueName,
											    0,
											    REG_BINARY,
											    (PVOID)keyPartialInfo->Data, 
											    dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
					    if (NT_SUCCESS(status)){
						    comNumber = 8*b + 1;
						    DBGVERBOSE(("GetFreeComPortNumber: got free COM port #%xh.", comNumber));
					    }
					    else {
						    DBGERR(("GetFreeComPortNumber: ZwSetValueKey #2 failed with %xh.", status));
					    }
				    }

				    ASSERT(comNumber != -1);
			    }
			    else {
				    DBGERR(("GetFreeComPortNumber: ZwQueryValueKey failed with %xh.", status));
			    }

			    /*
			     *  Check that we didn't fail the second allocation before freeing this buffer.
			     */
			    if (rawData){
				    FREEPOOL(rawData);
			    }
		    }
		    else {
			    status = STATUS_INSUFFICIENT_RESOURCES;
		    }

		    status = ZwClose(hKey);
		    ASSERT(NT_SUCCESS(status));
	    }
	    else {
		    DBGERR(("GetFreeComPortNumber: ZwOpenKey failed with %xh.", status));
	    }

    }

    ASSERT(comNumber != -1);
	return comNumber;
}



VOID ReleaseCOMPort(LONG comPortNumber)
{

    if (isWin9x){
        /*
         *  We punt on this for Win9x.  
         *  That's ok since the SERIALCOMM keys are dynamically-generated at each boot,
         *  so if start fails a COM port number will just be unavailable until the next boot.
         */
        DBGWARN(("ReleaseCOMPort: not implemented for Win9x")); // BUGBUG
    }
    else {

        HANDLE hKey = NULL;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING keyName;
        NTSTATUS status;

        ASSERT(comPortNumber > 0);

        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
        InitializeObjectAttributes( &objectAttributes,
							        &keyName,
							        OBJ_CASE_INSENSITIVE,
							        NULL,				
							        (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
        if (NT_SUCCESS(status)){
	        UNICODE_STRING valueName;
	        PVOID rawData;
	        ULONG dataSize;

	        RtlInitUnicodeString(&valueName, L"ComDB");

	        ASSERT(hKey);

	        dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
	        rawData = ALLOCPOOL(NonPagedPool, dataSize);

	        if (rawData){
		        status = ZwQueryValueKey(	hKey, 
									        &valueName, 
									        KeyValuePartialInformation,
									        rawData,
									        dataSize,
									        &dataSize);
		        if (status == STATUS_BUFFER_OVERFLOW){
			        FREEPOOL(rawData);
			        ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

			        rawData = ALLOCPOOL(NonPagedPool, dataSize);
			        if (rawData){
				        status = ZwQueryValueKey(	hKey, 
											        &valueName, 
											        KeyValuePartialInformation,
											        rawData,
											        dataSize,
											        &dataSize);
			        }
		        }

		        if (NT_SUCCESS(status)){
			        PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;

			        ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

			        ASSERT(keyPartialInfo->Type == REG_BINARY);

			        /*
			         *  The ComDB value is just a bit mask where bit n set indicates
			         *  that COM port # n+1 is taken.
			         *  Get the index of the first unset bit; starting with bit 2 (COM3).
			         *
			         *  Note:	careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
			         *			struct.  Its real size is 0x0D bytes, 
			         *			but the compiler aligns it to 0x10 bytes.
			         *			So use FIELD_OFFSET, not sizeof, to determine
			         *			how many bytes to write.
			         */
			        ASSERT(comPortNumber >= 3);
			        if ((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8)){
				        ASSERT(keyPartialInfo->Data[(comPortNumber-1)/8] & (1 << ((comPortNumber-1) & 7)));
				        keyPartialInfo->Data[(comPortNumber-1)/8] &= ~(1 << ((comPortNumber-1) & 7));
				        status = ZwSetValueKey(	hKey, 
										        &valueName,
										        0,
										        REG_BINARY,
										        (PVOID)keyPartialInfo->Data, 
										        dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
				        if (NT_SUCCESS(status)){
					        DBGVERBOSE(("ReleaseCOMPort: released COM port # %xh.", comPortNumber));
				        }
				        else {
					        DBGERR(("ReleaseCOMPort: ZwSetValueKey failed with %xh.", status));
				        }
			        }
			        else {
				        ASSERT((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8));
			        }
		        }
		        else {
			        DBGERR(("ReleaseCOMPort: ZwQueryValueKey failed with %xh.", status));
		        }

		        /*
		         *  Check that we didn't fail the second allocation before freeing this buffer.
		         */
		        if (rawData){
			        FREEPOOL(rawData);
		        }
	        }
	        else {
		        status = STATUS_INSUFFICIENT_RESOURCES;
	        }

	        status = ZwClose(hKey);
	        ASSERT(NT_SUCCESS(status));
        }
        else {
	        DBGERR(("ReleaseCOMPort: ZwOpenKey failed with %xh.", status));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\debug.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"

#if DBG
    BOOLEAN dbgTrapOnWarn = FALSE; 
    BOOLEAN dbgVerbose = FALSE;


    VOID DbgLogIrpMajor(ULONG irpPtr, ULONG majorFunc, ULONG isPdo, ULONG isComplete, ULONG status)
    {

        if (dbgVerbose){
            char *funcName;

            switch (majorFunc){
                #undef MAKE_CASE
                #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

                MAKE_CASE(IRP_MJ_CREATE)
                MAKE_CASE(IRP_MJ_CREATE_NAMED_PIPE)
                MAKE_CASE(IRP_MJ_CLOSE)
                MAKE_CASE(IRP_MJ_READ)
                MAKE_CASE(IRP_MJ_WRITE)
                MAKE_CASE(IRP_MJ_QUERY_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_INFORMATION)
                MAKE_CASE(IRP_MJ_QUERY_EA)
                MAKE_CASE(IRP_MJ_SET_EA)
                MAKE_CASE(IRP_MJ_FLUSH_BUFFERS)
                MAKE_CASE(IRP_MJ_QUERY_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_DIRECTORY_CONTROL)
                MAKE_CASE(IRP_MJ_FILE_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_INTERNAL_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_SHUTDOWN)
                MAKE_CASE(IRP_MJ_LOCK_CONTROL)
                MAKE_CASE(IRP_MJ_CLEANUP)
                MAKE_CASE(IRP_MJ_CREATE_MAILSLOT)
                MAKE_CASE(IRP_MJ_QUERY_SECURITY)
                MAKE_CASE(IRP_MJ_SET_SECURITY)
                MAKE_CASE(IRP_MJ_POWER)
                MAKE_CASE(IRP_MJ_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CHANGE)
                MAKE_CASE(IRP_MJ_QUERY_QUOTA)
                MAKE_CASE(IRP_MJ_SET_QUOTA)
                MAKE_CASE(IRP_MJ_PNP)

                default: funcName = "????";    break;
            }

            if (isComplete){
                DBGOUT(("< %s for %s status=%xh %s (irp=%xh)",
                       funcName,
					   (PUCHAR)(isPdo ? "pdo" : "fdo"),
                       status,
                       NT_SUCCESS(status) ? "" : "<** ERROR **>",
                       irpPtr));
            }
            else {
                DBGOUT(("> %s for %s (irp=%xh)", 
							funcName, 
						   (PUCHAR)(isPdo ? "pdo" : "fdo"),
							irpPtr));
            }
        }

    }




    VOID DbgLogPnpIrp(ULONG irpPtr, ULONG minorFunc, ULONG isPdo, ULONG isComplete, ULONG status)
    {
        if (dbgVerbose){
			char *funcName;
			ULONG funcShortName;

			switch (minorFunc){
				#undef MAKE_CASE
				#define MAKE_CASE(fnc) case fnc: funcName = #fnc; funcShortName = *(ULONG *)(funcName+7); break;

				MAKE_CASE(IRP_MN_START_DEVICE)
				MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
				MAKE_CASE(IRP_MN_REMOVE_DEVICE)
				MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
				MAKE_CASE(IRP_MN_STOP_DEVICE)
				MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
				MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
				MAKE_CASE(IRP_MN_QUERY_DEVICE_RELATIONS)
				MAKE_CASE(IRP_MN_QUERY_INTERFACE)
				MAKE_CASE(IRP_MN_QUERY_CAPABILITIES)
				MAKE_CASE(IRP_MN_QUERY_RESOURCES)
				MAKE_CASE(IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
				MAKE_CASE(IRP_MN_QUERY_DEVICE_TEXT)
				MAKE_CASE(IRP_MN_READ_CONFIG)
				MAKE_CASE(IRP_MN_WRITE_CONFIG)
				MAKE_CASE(IRP_MN_EJECT)
				MAKE_CASE(IRP_MN_SET_LOCK)
				MAKE_CASE(IRP_MN_QUERY_ID)
				MAKE_CASE(IRP_MN_QUERY_PNP_DEVICE_STATE)
				MAKE_CASE(IRP_MN_QUERY_BUS_INFORMATION)
				MAKE_CASE(IRP_MN_DEVICE_USAGE_NOTIFICATION)
				MAKE_CASE(IRP_MN_SURPRISE_REMOVAL)

				default: funcName = "????"; funcShortName = (ULONG)'\?\?\?\?'; break;
			}

            if (isComplete){
                DBGOUT((" < %s for %s status=%xh (irp=%xh)", 
                        funcName, 
    				    (PUCHAR)(isPdo ? "pdo" : "fdo"),
	                    status,
                        irpPtr));
            }
            else {
                DBGOUT((" > %s for %s (irp=%xh)", 
                        funcName, 
 					    (PUCHAR)(isPdo ? "pdo" : "fdo"),
                        irpPtr));
            }
        }

    }


	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len)
	{
		if (dbgVerbose){
			ULONG i, j;
			DbgPrint("%c%s (len %xh @ %p): \r\n", DBG_LEADCHAR, msg, len, buf);
			
			for (i = 0; i < len; i += 16){
				DbgPrint("%c    ", DBG_LEADCHAR);
				for (j = 0; j < 16; j++){
					if (i+j < len){
						DbgPrint("%02x ", (ULONG)buf[i+j]);
					}
					else {
						DbgPrint("   ");
					}
				}
				DbgPrint("  ");
				for (j = 0; j < 16; j++){
					if (i+j < len){
						UCHAR ch = buf[i+j];
						if ((ch < ' ') || (ch > '~')){
							ch = '.';
						}
						DbgPrint("%c", ch);
					}
					else {
						DbgPrint(" ");
					}
				}
				DbgPrint("\r\n");
			}
		}
	}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#define BAD_POINTER ((PVOID)0xDEADDEAD)
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))

#if DBG

    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgSkipSecurity;

    #define DBG_LEADCHAR (UCHAR)((isWin9x) ? ' ' : '\'' )

    #define TRAP(msg)                                       \
        {                                                   \
            DbgPrint("%cPOSUSB> Code coverage trap: '%s' file %s, line %d \n",  DBG_LEADCHAR, (msg), __FILE__, __LINE__ ); \
            DbgBreakPoint();                                \
        }

    #undef ASSERT
    #define ASSERT(fact)                                    \
        if (!(fact)){                                       \
            DbgPrint("%cPOSUSB> Assertion '%s' failed: file %s, line %d \n",  DBG_LEADCHAR, #fact, __FILE__, __LINE__ ); \
            DbgBreakPoint();                                \
        }

    #define DBGWARN(args_in_parens)                         \
        {                                                   \
            DbgPrint("%cPOSUSB> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR);             \
            DbgPrint args_in_parens;                        \
            DbgPrint("\n");                                 \
            if (dbgTrapOnWarn){                             \
                DbgBreakPoint();                            \
            }                                               \
        }
    #define DBGERR(args_in_parens)                          \
        {                                                   \
            DbgPrint("%cPOSUSB> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR);             \
            DbgPrint args_in_parens;                        \
            DbgPrint("\n");                                 \
            DbgBreakPoint();                                \
        }
    #define DBGOUT(args_in_parens)                          \
        {                                                   \
            DbgPrint("%cPOSUSB> ", DBG_LEADCHAR);           \
            DbgPrint args_in_parens;                        \
            DbgPrint("\n");                                 \
        }
    #define DBGVERBOSE(args_in_parens)                      \
        if (dbgVerbose){                                    \
            DbgPrint("%cPOSUSB> ", DBG_LEADCHAR);           \
            DbgPrint args_in_parens;                        \
            DbgPrint("\n");                                 \
        }


    VOID DbgLogIrpMajor(ULONG irpPtr, ULONG majorFunc, ULONG isPdo, ULONG isComplete, ULONG status);
    VOID DbgLogPnpIrp(ULONG irpPtr, ULONG minorFunc, ULONG isPdo, ULONG isComplete, ULONG status);
	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len);

    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isPdo, isComplete, status) \
                DbgLogIrpMajor((ULONG)(irp), (ULONG)(majorFunc), (ULONG)isPdo, (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isPdo, isComplete, status) \
                DbgLogPnpIrp((ULONG)(irp), (ULONG)(minorFunc), (ULONG)isPdo, (ULONG)(isComplete), (ULONG)(status));
	#define DBGSHOWBYTES(msg, buf, len) DbgShowBytes(msg, buf, len)
#else
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens)                               
    #define TRAP(msg)         

    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isPdo, isComplete, status) 
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isPdo, isComplete, status) 
	#define DBGSHOWBYTES(msg, buf, len)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\dispatch.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dispatch.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"



NTSTATUS Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    DEVEXT *devExt;
    PIO_STACK_LOCATION irpSp;
    ULONG majorFunc, minorFunc;
	BOOLEAN isPdo;
    NTSTATUS status;
	PARENTFDOEXT *parentFdoExt;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;
	isPdo = devExt->isPdo;

	if (isPdo){
		parentFdoExt = devExt->pdoExt.parentFdoExt;
	}
	else {
		parentFdoExt = &devExt->parentFdoExt;
	}

    DBG_LOG_IRP_MAJOR(irp, majorFunc, isPdo, FALSE, -1);

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(parentFdoExt);
    }

    if (isPdo){
	    POSPDOEXT *pdoExt = &devExt->pdoExt;
			

        switch (majorFunc){

            case IRP_MJ_PNP:
	            status = PDO_PnP(pdoExt, irp);
	            break;

            case IRP_MJ_CREATE:
	            status = OpenComPort(pdoExt, irp);
	            break;

            case IRP_MJ_CLOSE:
	            status = CloseComPort(pdoExt, irp);
	            break;

            case IRP_MJ_READ:
	            status = ReadComPort(pdoExt, irp);
	            break;

            case IRP_MJ_WRITE:
	            status = WriteComPort(pdoExt, irp);
	            break;

            case IRP_MJ_CLEANUP:
	            status = CleanupIO(pdoExt, irp);
	            break;

            case IRP_MJ_QUERY_INFORMATION:
	            status = QueryInfo(pdoExt, irp);
	            break;

            case IRP_MJ_SET_INFORMATION:
	            status = SetInfo(pdoExt, irp);
	            break;

            case IRP_MJ_FLUSH_BUFFERS:
	            status = FlushBuffers(pdoExt);
	            break;

            case IRP_MJ_DEVICE_CONTROL:
	            status = Ioctl(pdoExt, irp);
	            break;

            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
	            status = InternalIoctl(pdoExt, irp);
	            break;

            case IRP_MJ_POWER:             
                PoStartNextPowerIrp(irp);
                status = STATUS_SUCCESS;
                break;

            default:
	            /*
	             *  For unsupported IRPs, we fail them with the default status.
	             */
	            status = irp->IoStatus.Status;
	            break;
        }

        if (status != STATUS_PENDING){
	        irp->IoStatus.Status = status;
	        IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
    }
    else {

        if ((majorFunc != IRP_MJ_PNP) &&
	        (majorFunc != IRP_MJ_CLOSE) &&
	        ((parentFdoExt->state == STATE_REMOVING) ||
	         (parentFdoExt->state == STATE_REMOVED))){

	        /*
	         *  While the device is being removed, 
	         *  we only pass down the PNP and CLOSE IRPs.
	         *  We fail all other IRPs.
	         */
	        status = irp->IoStatus.Status = STATUS_DELETE_PENDING;
	        IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
        else {
            BOOLEAN passIrpDown = FALSE;

            switch (majorFunc){

                case IRP_MJ_PNP:
	                status = FDO_PnP(parentFdoExt, irp);
	                break;

                case IRP_MJ_POWER:
	                status = FDO_Power(parentFdoExt, irp);
	                break;

                default:
	                /*
	                 *  For unsupported IRPs, we simply send the IRP
	                 *  down the driver stack.
	                 */
	                passIrpDown = TRUE;
	                break;
            }

            if (passIrpDown){
	            IoCopyCurrentIrpStackLocationToNext(irp);
	            status = IoCallDriver(parentFdoExt->physicalDevObj, irp);
            }
        }
	}

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(parentFdoExt);
    }

    DBG_LOG_IRP_MAJOR(irp, majorFunc, isPdo, TRUE, status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\emulser.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    waitmask.c

Abstract: POS (serial) interface for USB Point-of-Sale devices

Author:

    Karan Mehra [t-karanm]

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


NTSTATUS QuerySpecialFeature(PARENTFDOEXT *parentFdoExt)
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hRegDevice;
    parentFdoExt->posFlag = 0;

    status = IoOpenDeviceRegistryKey(parentFdoExt->physicalDevObj, 
                                     PLUGPLAY_REGKEY_DRIVER, 
                                     KEY_READ, 
                                     &hRegDevice);
    if (NT_SUCCESS(status)) {

        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength, value;
        WCHAR oddKeyName[]  = L"OddEndpointFlag";

        #if STATUS_ENDPOINT

        WCHAR serialKeyName[] = L"SerialEmulationFlag";
        RtlInitUnicodeString(&keyName, serialKeyName); 

        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) + keyName.Length*sizeof(WCHAR) + sizeof(ULONG);

        keyValueInfo = ALLOCPOOL(PagedPool, keyValueTotalSize);
        if (keyValueInfo) {
            status = ZwQueryValueKey(hRegDevice,
                                     &keyName,
                                     KeyValueFullInformation,
                                     keyValueInfo,
                                     keyValueTotalSize,
                                     &actualLength); 
            if (NT_SUCCESS(status)) {

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));

                value = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                if (value == 1)
                    parentFdoExt->posFlag |= SERIAL_EMULATION;
            }
            else
                DBGVERBOSE(("QuerySpecialFeature: Flag not found. ZwQueryValueKey failed with %xh.", status));

            FREEPOOL(keyValueInfo);
        }
        else 
            ASSERT(keyValueInfo);

        #endif

        RtlInitUnicodeString(&keyName, oddKeyName); 

        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) + keyName.Length*sizeof(WCHAR) + sizeof(ULONG);

        keyValueInfo = ALLOCPOOL(PagedPool, keyValueTotalSize);
        if (keyValueInfo) {
            status = ZwQueryValueKey(hRegDevice,
                                     &keyName,
                                     KeyValueFullInformation,
                                     keyValueInfo,
                                     keyValueTotalSize,
                                     &actualLength); 
            if (NT_SUCCESS(status)) {

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));

                value = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                if (value == 1)
                    parentFdoExt->posFlag |= ODD_ENDPOINT;
            }
            else
                DBGVERBOSE(("QuerySpecialFeature: Flag not found. ZwQueryValueKey failed with %xh.", status));

            FREEPOOL(keyValueInfo);
        }
        else 
            ASSERT(keyValueInfo);

        ZwClose(hRegDevice);

        /*
         *  We do not wish to permit the Serial Emulation and 
         *  Odd Endpoint features together on the same device.
         */
        if((parentFdoExt->posFlag & SERIAL_EMULATION) && (parentFdoExt->posFlag & ODD_ENDPOINT)) {
            DBGVERBOSE(("More than one special feature NOT supported on the same device."));
            status = STATUS_INVALID_PARAMETER;
        }

    }
    else 
        DBGERR(("QuerySpecialFeature: IoOpenDeviceRegistryKey failed with %xh.", status));

    DBGVERBOSE(("QuerySpecialFeature: posFlag is now: %xh.", parentFdoExt->posFlag));
    return status;
}


VOID InitializeSerEmulVariables(POSPDOEXT *pdoExt)
{
    InitializeListHead(&pdoExt->pendingWaitIrpsList);
    pdoExt->baudRate = SERIAL_BAUD_115200;
    pdoExt->waitMask = 0;
    pdoExt->supportedBauds = SERIAL_BAUD_300   | SERIAL_BAUD_600   | SERIAL_BAUD_1200 
                           | SERIAL_BAUD_2400  | SERIAL_BAUD_4800  | SERIAL_BAUD_9600  
                           | SERIAL_BAUD_19200 | SERIAL_BAUD_38400 | SERIAL_BAUD_57600 
                           | SERIAL_BAUD_115200;
    pdoExt->currentMask = 0;
    pdoExt->fakeRxSize = 100;
    pdoExt->fakeLineControl.WordLength = 8;
    pdoExt->fakeLineControl.Parity     = NO_PARITY;
    pdoExt->fakeLineControl.StopBits   = STOP_BITS_2;
    pdoExt->fakeModemStatus = SERIAL_MSR_DCD | SERIAL_MSR_RI
                            | SERIAL_MSR_DSR | SERIAL_MSR_CTS;
}


NTSTATUS StatusPipe(POSPDOEXT *pdoExt, USBD_PIPE_HANDLE pipeHandle)
{
    NTSTATUS status;

    #if STATUS_ENDPOINT
    UsbBuildInterruptOrBulkTransferRequest(&pdoExt->statusUrb,
                                           (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                           pipeHandle,
                                           (PVOID) &pdoExt->statusPacket,
                                           NULL,
                                           sizeof(pdoExt->statusPacket),
                                           USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN,
                                           NULL);
    #else
    UsbBuildGetDescriptorRequest(&pdoExt->statusUrb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID) &pdoExt->dummyPacket,
                                 NULL,
                                 sizeof(pdoExt->dummyPacket),
                                 NULL);
    #endif

    IncrementPendingActionCount(pdoExt->parentFdoExt);
    status = SubmitUrb(pdoExt->parentFdoExt->topDevObj, 
                       &pdoExt->statusUrb, 
                       FALSE, 
                       StatusPipeCompletion, 
                       pdoExt);
    return status;
}


NTSTATUS StatusPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    NTSTATUS status = irp->IoStatus.Status;
    POSPDOEXT *pdoExt = (POSPDOEXT *)context;

    if(NT_SUCCESS(status)) {
        UpdateMask(pdoExt);
        StatusPipe(pdoExt, pdoExt->statusEndpointInfo.pipeHandle);
        #if STATUS_ENDPOINT
        DBGVERBOSE(("Mask Updated and URB sent down to retrieve Status Packet"));
        #endif
    }

    IoFreeIrp(irp);
    DecrementPendingActionCount(pdoExt->parentFdoExt);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID UpdateMask(POSPDOEXT *pdoExt)
{
    KIRQL oldIrql;
    PIRP irp;
    ULONG mask;

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    /*
     *  Modify the emulated variables based on statusPacket
     */
    #if STATUS_ENDPOINT
    /*
     *  Fill in the values of DCTS, DDSR, TERI, DDCD by EX-ORing the current
     *  modem bits CTS, DSR, RI and DCD with those at the STATUS Endpoint.
     */
    pdoExt->fakeModemStatus = (pdoExt->fakeModemStatus & ~MSR_DELTA_MASK) | (((pdoExt->fakeModemStatus ^ pdoExt->statusPacket) & MSR_GLOBAL_MSK) >> MSR_DELTA_SHFT);

    /*
     *  Replace the bits for CTS, DSR, RI and DCD with those at the STATUS Endpoint.
     */
    pdoExt->fakeModemStatus = (pdoExt->fakeModemStatus & ~MSR_GLOBAL_MSK) | (pdoExt->statusPacket & MSR_GLOBAL_MSK);

    if(pdoExt->statusPacket & EMULSER_OE)  
        pdoExt->fakeLineStatus |= SERIAL_LSR_OE;

    if(pdoExt->statusPacket & EMULSER_PE)  
        pdoExt->fakeLineStatus |= SERIAL_LSR_PE;

    if(pdoExt->statusPacket & EMULSER_FE)  
        pdoExt->fakeLineStatus |= SERIAL_LSR_FE;

    if(pdoExt->statusPacket & EMULSER_BI)  
        pdoExt->fakeLineStatus |= SERIAL_LSR_BI;

    if(pdoExt->statusPacket & EMULSER_DTR)
        pdoExt->fakeDTRRTS |= SERIAL_DTR_STATE;

    if(pdoExt->statusPacket & EMULSER_RTS)
        pdoExt->fakeDTRRTS |= SERIAL_RTS_STATE;
    #endif

    if(pdoExt->waitMask) {
        if((pdoExt->waitMask & SERIAL_EV_CTS)  && (pdoExt->fakeModemStatus & SERIAL_MSR_DCTS)) 
            pdoExt->currentMask |= SERIAL_EV_CTS;

        if((pdoExt->waitMask & SERIAL_EV_DSR)  && (pdoExt->fakeModemStatus & SERIAL_MSR_DDSR))
            pdoExt->currentMask |= SERIAL_EV_DSR;

        if((pdoExt->waitMask & SERIAL_EV_RING) && (pdoExt->fakeModemStatus & SERIAL_MSR_TERI))
            pdoExt->currentMask |= SERIAL_EV_RING;

        if((pdoExt->waitMask & SERIAL_EV_RLSD) && (pdoExt->fakeModemStatus & SERIAL_MSR_DDCD))
            pdoExt->currentMask |= SERIAL_EV_RLSD;

        if((pdoExt->waitMask & SERIAL_EV_ERR)  && (pdoExt->fakeLineStatus  & (SERIAL_LSR_OE 
                                                                            | SERIAL_LSR_PE | SERIAL_LSR_FE))) 
            pdoExt->currentMask |= SERIAL_EV_ERR;

        if((pdoExt->waitMask & SERIAL_EV_BREAK) && (pdoExt->fakeLineStatus & SERIAL_LSR_BI))
            pdoExt->currentMask |= SERIAL_EV_BREAK;

        /*
         *  These are required to be filled by the read and write pipes.
         *  Currently, we return TRUE always.
         */
        if(pdoExt->waitMask & SERIAL_EV_RXCHAR)
            pdoExt->currentMask |= SERIAL_EV_RXCHAR;

        if(pdoExt->waitMask & SERIAL_EV_RXFLAG)
            pdoExt->currentMask |= SERIAL_EV_RXFLAG;

        if(pdoExt->waitMask & SERIAL_EV_TXEMPTY)
            pdoExt->currentMask |= SERIAL_EV_TXEMPTY;
    }
    mask = pdoExt->currentMask;
    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    if(mask) {
        CompletePendingWaitIrps(pdoExt, mask);
        KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);	
        pdoExt->currentMask = 0;
        KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
    }
}


VOID CompletePendingWaitIrps(POSPDOEXT *pdoExt, ULONG mask)
{
    PIRP irp;

    while((irp = DequeueWaitIrp(pdoExt))) {
        irp->IoStatus.Information = sizeof(ULONG);
        irp->IoStatus.Status = STATUS_SUCCESS;
        *(PULONG)irp->AssociatedIrp.SystemBuffer = mask;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


NTSTATUS EnqueueWaitIrp(POSPDOEXT *pdoExt, PIRP irp)
{
    PDRIVER_CANCEL  oldCancelRoutine;	
    NTSTATUS status = STATUS_PENDING;
    KIRQL oldIrql;

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    if(IsListEmpty(&pdoExt->pendingWaitIrpsList)) 
    {
        InsertTailList(&pdoExt->pendingWaitIrpsList, &irp->Tail.Overlay.ListEntry);
        IoMarkIrpPending(irp);

        oldCancelRoutine = IoSetCancelRoutine(irp, WaitMaskCancelRoutine);
        ASSERT(!oldCancelRoutine);

        if (irp->Cancel) {
            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine) {
                RemoveEntryList(&irp->Tail.Overlay.ListEntry);
                status = irp->IoStatus.Status = STATUS_CANCELLED;
            }
        }
    }
    else
        status = irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    if (status != STATUS_PENDING)
        IoCompleteRequest(irp, IO_NO_INCREMENT);

    return status;
}


PIRP DequeueWaitIrp(POSPDOEXT *pdoExt)
{
    PDRIVER_CANCEL oldCancelRoutine;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;	
    PIRP nextIrp = NULL;

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    while (!nextIrp && !IsListEmpty(&pdoExt->pendingWaitIrpsList)) {
        listEntry = RemoveHeadList(&pdoExt->pendingWaitIrpsList);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        oldCancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        if(oldCancelRoutine) {
            ASSERT(oldCancelRoutine == WaitMaskCancelRoutine);
        }
        else {
            ASSERT(nextIrp->Cancel);
            InitializeListHead(&nextIrp->Tail.Overlay.ListEntry);
            nextIrp = NULL;
        }
    }

    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
    return nextIrp;
}


VOID WaitMaskCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp)
{
    DEVEXT *devExt;
    POSPDOEXT *pdoExt;
    KIRQL oldIrql;

    devExt = devObj->DeviceExtension;
    pdoExt = &devExt->pdoExt;

    IoReleaseCancelSpinLock(irp->CancelIrql);

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
    RemoveEntryList(&irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\escpos.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    escpos.h

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include "ntddser.h"

/*
 *  Serial Status Emulation has been disabled for the time being.
 */
#define STATUS_ENDPOINT     0

/*
 *  Bit mask for the posFlag.
 */
#define SERIAL_EMULATION    0x0001
#define ODD_ENDPOINT        0x0002

/*
 *  Bit mask for the STATUS Endpoint on the USB.
 */
#define EMULSER_OE          0x0001
#define EMULSER_PE          0x0002
#define EMULSER_FE          0x0004
#define EMULSER_BI          0x0008
#define EMULSER_CTS         0x0010
#define EMULSER_DSR         0x0020
#define EMULSER_RI          0x0040
#define EMULSER_DCD         0x0080
#define EMULSER_DTR         0x0100
#define EMULSER_RTS         0x0200

/*
 *  Emulation of the bit mask on the MODEM STATUS REGISTER.
 */
#define SERIAL_MSR_DCTS     0x0001
#define SERIAL_MSR_DDSR     0x0002
#define SERIAL_MSR_TERI     0x0004
#define SERIAL_MSR_DDCD     0x0008
#define SERIAL_MSR_CTS      0x0010
#define SERIAL_MSR_DSR      0x0020
#define SERIAL_MSR_RI       0x0040
#define SERIAL_MSR_DCD      0x0080

/*
 *  These masks are used for smooth transition of the STATUS bits
 *  from the Endpoint to the Emulated Variables.
 */
#define MSR_DELTA_MASK      0x000F
#define MSR_GLOBAL_MSK      0x00F0
#define MSR_DELTA_SHFT      4

/*
 *  Emulation of the bit mask on the LINE STATUS REGISTER.
 */
#define SERIAL_LSR_DR       0x0001
#define SERIAL_LSR_OE       0x0002
#define SERIAL_LSR_PE       0x0004
#define SERIAL_LSR_FE       0x0008
#define SERIAL_LSR_BI       0x0010
#define SERIAL_LSR_THRE     0x0020
#define SERIAL_LSR_TEMT     0x0040
#define SERIAL_LSR_FIFOERR  0x0080

/*
 *  IOCTL CODE for applications to be able to get the device's pretty name.
 */
#define IOCTL_INDEX                     0x0800
#define IOCTL_SERIAL_QUERY_DEVICE_NAME  CTL_CODE(FILE_DEVICE_SERIAL_PORT, IOCTL_INDEX + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_QUERY_DEVICE_ATTR  CTL_CODE(FILE_DEVICE_SERIAL_PORT, IOCTL_INDEX + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define MAX_BUFFER                      256

/*
 *  Run on prototype Epson printer ?  // BUGBUG REMOVE
 */
#define EPSON_PRINTER  0		


/*
 *  BUGBUG
 * 
 *  Is it ok to return a partial read buffer, or should we wait
 *  until the caller's buffer is completely full ?
 */
#define PARTIAL_READ_BUFFERS_OK 1


/*
 *  This is the default interface class value for interfaces of no defined class.
 */
#define USB_INTERFACE_CLASS_VENDOR 0x0ff 

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

#define DEVICE_EXTENSION_SIGNATURE 'PcsE'


typedef struct endpointInfo {
	USBD_PIPE_HANDLE pipeHandle;
	ULONG pipeLen;
	BOOLEAN endpointIsBusy;
} ENDPOINTINFO;

typedef struct PARENT_FDO_EXTENSION {

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    PDRIVER_OBJECT driverObj;

    /*
     *  Flag to notify that some special feature needs to be implemented.
     */
    ULONG posFlag;

    /*
     *  The device object that this driver created.
     */
    PDEVICE_OBJECT functionDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

    USB_DEVICE_DESCRIPTOR deviceDesc;
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;

    USBD_CONFIGURATION_HANDLE configHandle;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    KSPIN_LOCK	devExtSpinLock;

    PDEVICE_RELATIONS deviceRelations;

} PARENTFDOEXT;


/*
 *  Device extension for a PDO created by this driver.
 *  A POS PDO represents a single COM (serial) port interface
 *  which consists of a single input/output endpoint pair on the USB device.
 */
typedef struct POS_PDO_EXTENSION {
    enum deviceState state;
    PDEVICE_OBJECT pdo;
    PARENTFDOEXT *parentFdoExt;
    LONG comPortNumber;
    UNICODE_STRING pdoName;
    UNICODE_STRING symbolicLinkName;
    LIST_ENTRY fileExtensionList;

    ENDPOINTINFO inputEndpointInfo;
    ENDPOINTINFO outputEndpointInfo;

    LIST_ENTRY pendingReadIrpsList;
    LIST_ENTRY pendingWriteIrpsList;
    LIST_ENTRY completedReadPacketsList;

    ULONG totalQueuedReadDataLength;

    WORK_QUEUE_ITEM writeWorkItem;
    WORK_QUEUE_ITEM readWorkItem;

    FILE_BASIC_INFORMATION fileBasicInfo;

    KSPIN_LOCK devExtSpinLock;

    ULONG                   supportedBauds;         // emulation of baud rates for the device
    ULONG                   baudRate;               // emulation of current baud rate
    ULONG                   fakeDTRRTS;             // emulation of DTR and RTS lines
    ULONG                   fakeRxSize;             // emulation of read buffer size
    SERIAL_TIMEOUTS         fakeTimeouts;           // emulation of timeout controls
    SERIAL_CHARS            specialChars;           // emulation of special characters
    SERIALPERF_STATS        fakePerfStats;          // emulation of performance stats
    SERIAL_LINE_CONTROL     fakeLineControl;        // emulation of the line control register
    USHORT                  fakeLineStatus;         // emulation of line status register
    USHORT                  fakeModemStatus;        // emulation of modem status register

    LIST_ENTRY              pendingWaitIrpsList;    // queue of WAIT_ON_MASK irps
    ULONG                   waitMask;               // mask of events to be waited upon
    ULONG                   currentMask;            // mask of events that have occured

    #if !STATUS_ENDPOINT
    USB_DEVICE_DESCRIPTOR   dummyPacket;            // we simply get the desciptor for now
    #endif

    USHORT                  statusPacket;           // buffer to read the status endpoint
    URB	                    statusUrb;              // urb to read the status endpoint
    ENDPOINTINFO            statusEndpointInfo;     // stores info about the status endpoint

} POSPDOEXT;

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

	BOOLEAN isPdo;

	union {
		PARENTFDOEXT parentFdoExt;
		POSPDOEXT pdoExt;
	};

} DEVEXT;


typedef struct fileExtension {
	ULONG signature;
	PFILE_OBJECT fileObject;
	LIST_ENTRY listEntry;
} FILEEXT;


typedef struct readPacket {
		
		#define READPACKET_SIG 'tPdR'
		ULONG signature;

		PUCHAR data;
		ULONG length;
		ULONG offset;	// offset of first byte not yet returned to client
		PVOID context;
		PURB urb;

		LIST_ENTRY listEntry;

} READPACKET;


#define NO_STATUS 0x80000000

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) > (b)) ? (a) : (b))

/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 */
#define ESCPOS_TAG (ULONG)'UsoP'
#define ALLOCPOOL(pooltype, size)   ExAllocatePoolWithTag(pooltype, size, ESCPOS_TAG)
#define FREEPOOL(ptr)               ExFreePool(ptr) 



/*
 *  Function prototypes
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    FDO_PnP(PARENTFDOEXT *parentFdoExt, PIRP irp);
NTSTATUS    FDO_Power(PARENTFDOEXT *parentFdoExt, PIRP irp);
NTSTATUS    FDO_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(PARENTFDOEXT *parentFdoExt);
NTSTATUS    CallNextDriverSync(PARENTFDOEXT *parentFdoExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(PARENTFDOEXT *parentFdoExt);
VOID        DecrementPendingActionCount(PARENTFDOEXT *parentFdoExt);
NTSTATUS    InitUSB(PARENTFDOEXT *parentFdoExt);
NTSTATUS    GetConfigDescriptor(PARENTFDOEXT *parentFdoExt);
NTSTATUS    GetDeviceDescriptor(PARENTFDOEXT *parentFdoExt);
NTSTATUS    SubmitUrb(PDEVICE_OBJECT pdo, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS    OpenComPort(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    CloseComPort(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    WriteComPort(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    ReadComPort(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    CreateSymbolicLink(POSPDOEXT *pdoExt);
NTSTATUS    DestroySymbolicLink(POSPDOEXT *pdoExt);
PWCHAR      CreateChildPdoName(PARENTFDOEXT *parentFdoExt, ULONG portNumber);
NTSTATUS    CreateCOMPdo(PARENTFDOEXT *parentFdoExt, ULONG comInterfaceIndex, ENDPOINTINFO *inputEndpointInfo, ENDPOINTINFO *outputEndpointInfo, ENDPOINTINFO *statusEndpointInfo);
PDEVICE_RELATIONS CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations);
NTSTATUS    QueryDeviceRelations(PARENTFDOEXT *parentFdoExt, PIRP irp);
PVOID       MemDup(PVOID dataPtr, ULONG length);
NTSTATUS    PDO_PnP(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    QueryPdoID(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    ReadPipe(PARENTFDOEXT *parentFdoExt, USBD_PIPE_HANDLE pipeHandle, READPACKET *readPacket, BOOLEAN synchronous);
NTSTATUS    ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    WritePipe(PARENTFDOEXT *parentFdoExt, USBD_PIPE_HANDLE pipeHandle, PUCHAR data, ULONG dataLen);
NTSTATUS    SelectConfiguration(PARENTFDOEXT *parentFdoExt);
NTSTATUS    CleanupIO(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    QueryInfo(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    SetInfo(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    FlushBuffers(POSPDOEXT *pdoExt);
NTSTATUS    Ioctl(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    InternalIoctl(POSPDOEXT *pdoExt, PIRP irp);
NTSTATUS    SubstituteOneBusName(PWCHAR hwId);
NTSTATUS    SubstituteBusNames(PWCHAR busNames);
ULONG       WStrLen(PWCHAR str);
LONG        WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n);
VOID        WorkItemCallback_Write(PVOID context);
VOID        WorkItemCallback_Read(PVOID context);
VOID        WriteCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    EnqueueReadIrp(POSPDOEXT *pdoExt, PIRP irp, BOOLEAN enqueueAtFront, BOOLEAN lockHeld);
PIRP        DequeueReadIrp(POSPDOEXT *pdoExt, BOOLEAN lockHeld);
VOID        ReadCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp);
VOID        IssueReadForClient(POSPDOEXT *pdoExt);
VOID        SatisfyPendingReads(POSPDOEXT *pdoExt);
READPACKET* AllocReadPacket(PVOID data, ULONG dataLen, PVOID context);
VOID        FreeReadPacket(READPACKET *readPacket);
LONG        GetComPort(PARENTFDOEXT *parentFdoExt, ULONG comInterfaceIndex);
LONG        GetFreeComPortNumber();
VOID        ReleaseCOMPort(LONG comPortNumber);
void        NumToHexString(PWCHAR String, USHORT Number, USHORT stringLen);
void        NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen);
ULONG       LAtoX(PWCHAR wHexString);
ULONG       LAtoD(PWCHAR string);
LONG        MyLog(ULONG base, ULONG num);
NTSTATUS    CreatePdoForEachEndpointPair(PARENTFDOEXT *parentFdoExt);
NTSTATUS    TryWrite(POSPDOEXT *pdoExt, PIRP irp);
BOOLEAN     IsWin9x();
PVOID       PosMmGetSystemAddressForMdlSafe(PMDL MdlAddress);
VOID        DeleteChildPdo(POSPDOEXT *pdoExt);

/*
 *  Function prototypes for Serial Emulation.
 */
NTSTATUS    QuerySpecialFeature(PARENTFDOEXT *parentFdoExt);
VOID        InitializeSerEmulVariables(POSPDOEXT *pdoExt);
NTSTATUS    EnqueueWaitIrp(POSPDOEXT *pdoExt, PIRP irp);
VOID        WaitMaskCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp);
PIRP        DequeueWaitIrp(POSPDOEXT *pdoExt);
VOID        UpdateMask(POSPDOEXT *pdoExt);
VOID        CompletePendingWaitIrps(POSPDOEXT *pdoExt, ULONG mask);
NTSTATUS    StatusPipe(POSPDOEXT *pdoExt, USBD_PIPE_HANDLE pipeHandle);
NTSTATUS    StatusPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    QueryDeviceName(POSPDOEXT *pdoExt, PIRP irp);

/*
 *  Externs
 */
extern BOOLEAN isWin9x;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\escpos.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, AddDevice)
        #pragma alloc_text(PAGE, DriverUnload)
#endif


BOOLEAN isWin9x = FALSE;

NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGVERBOSE(("DriverEntry")); 

    isWin9x = IsWin9x();

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = AddDevice;
    DriverObject->DriverUnload = DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
	PDEVICE_OBJECT functionDevObj = NULL;

    PAGED_CODE();

    DBGVERBOSE(("AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

	status = IoCreateDevice(    driverObj, 
								sizeof(DEVEXT),
								NULL,							// name for this device
								FILE_DEVICE_SERIAL_PORT, 
								0,								// device characteristics
								TRUE,							// exclusive
								&functionDevObj);				// our device object

	if (NT_SUCCESS(status)){
		DEVEXT *devExt;
		PARENTFDOEXT *parentFdoExt;

		ASSERT(functionDevObj);

		/*
		 *  Initialize device extension for new device object
		 */
		devExt = (DEVEXT *)functionDevObj->DeviceExtension;
		RtlZeroMemory(devExt, sizeof(DEVEXT));

		devExt->signature = DEVICE_EXTENSION_SIGNATURE;
		devExt->isPdo = FALSE;

		parentFdoExt = &devExt->parentFdoExt;

		parentFdoExt->state = STATE_INITIALIZED;
		parentFdoExt->functionDevObj = functionDevObj;
		parentFdoExt->physicalDevObj = physicalDevObj;
		parentFdoExt->driverObj = driverObj;
		parentFdoExt->pendingActionCount = 0;

		KeInitializeEvent(&parentFdoExt->removeEvent, NotificationEvent, FALSE);

		KeInitializeSpinLock(&parentFdoExt->devExtSpinLock);

		/*
		 *  Clear the initializing bit from the new device object's flags.
		 */
		functionDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

		/*
		 *  The DO_POWER_PAGABLE bit of a device object
		 *  indicates to the kernel that the power-handling
		 *  code of the corresponding driver is pageable, and
		 *  so must be called at IRQL 0.
		 *  As a filter driver, we do not want to change the power
		 *  behavior of the driver stack in any way; therefore,
		 *  we copy this bit from the lower device object.
		 */
		ASSERT(!(functionDevObj->Flags & DO_POWER_PAGABLE)); 
		functionDevObj->Flags |= (physicalDevObj->Flags & DO_POWER_PAGABLE);

		/*
		 *  Attach the new device object to the top of the device stack.
		 */
		parentFdoExt->topDevObj = IoAttachDeviceToDeviceStack(functionDevObj, physicalDevObj);

		ASSERT(parentFdoExt->topDevObj);
		DBGVERBOSE(("created fdo %ph attached to %ph.", functionDevObj, parentFdoExt->topDevObj));

	} 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    DBGVERBOSE(("DriverUnload")); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\ioctl.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: POS (serial) interface for USB Point-of-Sale devices

Author:

    Karan Mehra [t-karanm]

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"



NTSTATUS Ioctl(POSPDOEXT *pdoExt, PIRP irp)
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;

    irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation(irp);

    /* 
     *  Private Ioctls for applications to be able to get the device's pretty name and attributes.
     */
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

        case IOCTL_SERIAL_QUERY_DEVICE_NAME:
            return QueryDeviceName(pdoExt, irp);

        case IOCTL_SERIAL_QUERY_DEVICE_ATTR: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
                return STATUS_BUFFER_TOO_SMALL; 

            irp->IoStatus.Information = sizeof(ULONG);

            KeAcquireSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, &oldIrql);
            *(PULONG)irp->AssociatedIrp.SystemBuffer = pdoExt->parentFdoExt->posFlag;
            KeReleaseSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, oldIrql);
            return status;
        }
    }
    /* 
     *  The following Ioctl calls are ONLY for Serial Emulation.
     */
    if(!(pdoExt->parentFdoExt->posFlag & SERIAL_EMULATION)) {
        DBGVERBOSE(("Serial Emulation NOT supported by this device - Ioctl Rejected."));
        return STATUS_NOT_SUPPORTED;
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

        case IOCTL_SERIAL_GET_STATS: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PSERIALPERF_STATS)irp->AssociatedIrp.SystemBuffer = pdoExt->fakePerfStats;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_CLEAR_STATS: {

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            RtlZeroMemory(&pdoExt->fakePerfStats, sizeof(SERIALPERF_STATS));
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_PROPERTIES: {

            PSERIAL_COMMPROP properties = (PSERIAL_COMMPROP)irp->AssociatedIrp.SystemBuffer;

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }
		
            irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            irp->IoStatus.Status = STATUS_SUCCESS;

            RtlZeroMemory(properties, sizeof(SERIAL_COMMPROP)); 

            properties->PacketLength   = sizeof(SERIAL_COMMPROP);
            properties->PacketVersion  = 2;
            properties->ServiceMask    = SERIAL_SP_SERIALCOMM;
            properties->MaxTxQueue     = 0;
            properties->MaxRxQueue     = 0;

            properties->MaxBaud        = SERIAL_BAUD_115200;
            properties->SettableBaud   = pdoExt->supportedBauds;
            properties->ProvSubType    = SERIAL_SP_MODEM;

            properties->ProvCapabilities = SERIAL_PCF_DTRDSR        | SERIAL_PCF_RTSCTS
              	                         | SERIAL_PCF_SPECIALCHARS  | SERIAL_PCF_PARITY_CHECK
                                         | SERIAL_PCF_TOTALTIMEOUTS | SERIAL_PCF_INTTIMEOUTS;

            properties->SettableParams = SERIAL_SP_PARITY       | SERIAL_SP_BAUD        | SERIAL_SP_DATABITS
                                       | SERIAL_SP_STOPBITS     | SERIAL_SP_HANDSHAKING | SERIAL_SP_PARITY_CHECK 
                                       | SERIAL_SP_CARRIER_DETECT;

            properties->SettableData  = SERIAL_DATABITS_5 | SERIAL_DATABITS_6
                                      | SERIAL_DATABITS_7 | SERIAL_DATABITS_8;

            properties->SettableStopParity = SERIAL_STOPBITS_10 | SERIAL_STOPBITS_15 | SERIAL_STOPBITS_20 
                                           | SERIAL_PARITY_NONE | SERIAL_PARITY_ODD  | SERIAL_PARITY_EVEN 
                                           | SERIAL_PARITY_MARK | SERIAL_PARITY_SPACE;

            properties->CurrentTxQueue = 0;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            properties->CurrentRxQueue = pdoExt->fakeRxSize;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_MODEMSTATUS: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(ULONG);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PULONG)irp->AssociatedIrp.SystemBuffer = pdoExt->fakeModemStatus;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }
 
        case IOCTL_SERIAL_GET_COMMSTATUS: {

            PSERIAL_STATUS commStatus = (PSERIAL_STATUS)irp->AssociatedIrp.SystemBuffer;

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(SERIAL_STATUS);
            irp->IoStatus.Status = STATUS_SUCCESS;

            commStatus->Errors            = 0;
            commStatus->HoldReasons       = 0;
            commStatus->AmountInInQueue   = 100;
            commStatus->AmountInOutQueue  = 0;
            commStatus->EofReceived       = FALSE;
            commStatus->WaitForImmediate  = 0;
            break;
        }

        case IOCTL_SERIAL_RESET_DEVICE: {

            break;								
        }
	    
        case IOCTL_SERIAL_GET_BAUD_RATE: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            ((PSERIAL_BAUD_RATE)irp->AssociatedIrp.SystemBuffer)->BaudRate = pdoExt->baudRate;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_BAUD_RATE: {

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->baudRate = ((PSERIAL_BAUD_RATE)irp->AssociatedIrp.SystemBuffer)->BaudRate;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_LINE_CONTROL: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PSERIAL_LINE_CONTROL)irp->AssociatedIrp.SystemBuffer = pdoExt->fakeLineControl;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_LINE_CONTROL: {

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }
	    
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeLineControl = *(PSERIAL_LINE_CONTROL)irp->AssociatedIrp.SystemBuffer;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_TIMEOUTS: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PSERIAL_TIMEOUTS)irp->AssociatedIrp.SystemBuffer = pdoExt->fakeTimeouts;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_TIMEOUTS: {

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeTimeouts = *(PSERIAL_TIMEOUTS)irp->AssociatedIrp.SystemBuffer;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_DTR: {

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeDTRRTS |= SERIAL_DTR_STATE;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_CLR_DTR: {

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeDTRRTS &= ~SERIAL_DTR_STATE;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_RTS: {

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeDTRRTS |= SERIAL_RTS_STATE;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_CLR_RTS: {

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->fakeDTRRTS &= ~SERIAL_RTS_STATE;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_DTRRTS: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            irp->IoStatus.Information = sizeof(ULONG);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PULONG)irp->AssociatedIrp.SystemBuffer = pdoExt->fakeDTRRTS;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_GET_WAIT_MASK: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(ULONG);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PULONG)irp->AssociatedIrp.SystemBuffer = pdoExt->waitMask;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_WAIT_MASK: {

            ULONG mask = *(PULONG)irp->AssociatedIrp.SystemBuffer;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            if (mask & ~(SERIAL_EV_RXCHAR | SERIAL_EV_RXFLAG | SERIAL_EV_TXEMPTY  | SERIAL_EV_CTS
                       | SERIAL_EV_DSR    | SERIAL_EV_RLSD   | SERIAL_EV_BREAK    | SERIAL_EV_ERR
                       | SERIAL_EV_RING   | SERIAL_EV_PERR   | SERIAL_EV_RX80FULL | SERIAL_EV_EVENT1
                       | SERIAL_EV_EVENT2)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            CompletePendingWaitIrps(pdoExt, 0);

            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->waitMask = mask;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_WAIT_ON_MASK: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            if(pdoExt->currentMask || !pdoExt->waitMask) {
                irp->IoStatus.Information = sizeof(ULONG);
                irp->IoStatus.Status = STATUS_SUCCESS;

                *(PULONG)irp->AssociatedIrp.SystemBuffer = pdoExt->currentMask;
                pdoExt->currentMask = 0;
                KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
                return status;
            }
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

            status = EnqueueWaitIrp(pdoExt, irp);
            break;
        }

        case IOCTL_SERIAL_GET_CHARS: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Information = sizeof(SERIAL_CHARS);
            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            *(PSERIAL_CHARS)irp->AssociatedIrp.SystemBuffer = pdoExt->specialChars;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        case IOCTL_SERIAL_SET_CHARS: {

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) {
                status = STATUS_BUFFER_TOO_SMALL; 
                break;
            }

            irp->IoStatus.Status = STATUS_SUCCESS;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->specialChars = *(PSERIAL_CHARS)irp->AssociatedIrp.SystemBuffer;
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);
            break;
        }

        default:
            DBGVERBOSE(("Ioctl: ??? (%xh)", (ULONG)irpSp->Parameters.DeviceIoControl.IoControlCode));
            status = irp->IoStatus.Status;
            break;
    }

    return status;
}


NTSTATUS QueryDeviceName(POSPDOEXT *pdoExt, PIRP irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    HANDLE hRegDevice;

    irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation(irp);

    status = IoOpenDeviceRegistryKey(pdoExt->parentFdoExt->physicalDevObj, 
                                     PLUGPLAY_REGKEY_DRIVER, 
                                     KEY_READ, 
                                     &hRegDevice);
    if (NT_SUCCESS(status)) {

        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;
        PWCHAR valueData;

        WCHAR deviceKeyName[] = L"DriverDesc";
        RtlInitUnicodeString(&keyName, deviceKeyName); 

        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) + (keyName.Length + MAX_BUFFER)*sizeof(WCHAR);

        keyValueInfo = ALLOCPOOL(PagedPool, keyValueTotalSize);
        if (keyValueInfo) {
            status = ZwQueryValueKey(hRegDevice,
                                     &keyName,
                                     KeyValueFullInformation,
                                     keyValueInfo,
                                     keyValueTotalSize,
                                     &actualLength); 
            if (NT_SUCCESS(status)) {
                ASSERT(keyValueInfo->Type == REG_SZ);

                valueData = (PWCHAR)((PCHAR)keyValueInfo + keyValueInfo->DataOffset);

                DBGVERBOSE(("Device Name is of Length: %xh.", keyValueInfo->DataLength));               

                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < keyValueInfo->DataLength)
                    status = STATUS_BUFFER_TOO_SMALL; 
                else {
                    irp->IoStatus.Information = keyValueInfo->DataLength;
                    wcscpy((PWCHAR)irp->AssociatedIrp.SystemBuffer, valueData);
                }
            }
            else
                DBGVERBOSE(("QueryDeviceName: Device Name not found. ZwQueryValueKey failed with %xh.", status));

            FREEPOOL(keyValueInfo);
        }
        else 
            ASSERT(keyValueInfo);

        ZwClose(hRegDevice);
    }
    else 
        DBGERR(("QueryDeviceName: IoOpenDeviceRegistryKey failed with %xh.", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\pnp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, FDO_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS FDO_PnP(PARENTFDOEXT *parentFdoExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    parentFdoExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;
	ULONG minorFunction;
    enum deviceState prevState;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

	/*
	 *  Get this field into a stack var so we can touch it after the IRP's completed.
	 */
	minorFunction = (ULONG)(irpSp->MinorFunction);

	DBG_LOG_PNP_IRP(irp, minorFunction, FALSE, FALSE, -1);

    switch (minorFunction){

        case IRP_MN_START_DEVICE:

            prevState = parentFdoExt->state;
            parentFdoExt->state = STATE_STARTING;

            /*
             *  First, send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(parentFdoExt, irp);

            if (NT_SUCCESS(status) && (prevState != STATE_STOPPED)){
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(parentFdoExt);
                if (NT_SUCCESS(status)){

                    status = InitUSB(parentFdoExt);
                    if (NT_SUCCESS(status)){
                        /*
                         *  Check whether any special feature needs to be implemented.
                         */
                        DBGVERBOSE(("FDO_PnP: Poking registry for posFlag..."));
                        status = QuerySpecialFeature(parentFdoExt);
                        
                        if (NT_SUCCESS(status)){
                            status = CreatePdoForEachEndpointPair(parentFdoExt);
                            if (NT_SUCCESS(status)){
	                            IoInvalidateDeviceRelations(parentFdoExt->physicalDevObj, BusRelations);
                            }
                        }
                    }
                }
            }

            if (NT_SUCCESS(status)){
                parentFdoExt->state = STATE_STARTED;
            }
            else {
                parentFdoExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            break;

        case IRP_MN_STOP_DEVICE:
            if (parentFdoExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (parentFdoExt->state == STATE_STARTED){
                    parentFdoExt->state = STATE_STOPPED;
                }
            }
            break;
      
        case IRP_MN_QUERY_REMOVE_DEVICE:
            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SURPRISE_REMOVAL:

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            parentFdoExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            parentFdoExt->state = STATE_REMOVED;


            /*
             *  Send the REMOVE IRP down the stack asynchronously.
             *  Do not synchronize sending down the REMOVE_DEVICE
             *  IRP, because the REMOVE_DEVICE IRP must be sent
             *  down and completed all the way back up to the sender
             *  before we continue.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = IoCallDriver(parentFdoExt->physicalDevObj, irp);
            justReturnStatus = TRUE;

            DBGVERBOSE(("REMOVE_DEVICE - waiting for %d irps to complete...", parentFdoExt->pendingActionCount));  

            /*
             *  We must for all outstanding IO to complete before
             *  completing the REMOVE_DEVICE IRP.
             *
             *  First do an extra decrement on the pendingActionCount.
             *  This will cause pendingActionCount to eventually
             *  go to -1 once all asynchronous actions on this
             *  device object are complete.
             *  Then wait on the event that gets set when the
             *  pendingActionCount actually reaches -1.
             */
            DecrementPendingActionCount(parentFdoExt);
            KeWaitForSingleObject(  &parentFdoExt->removeEvent,
                                    Executive,      // wait reason
                                    KernelMode,
                                    FALSE,          // not alertable
                                    NULL );         // no timeout

            DBGVERBOSE(("REMOVE_DEVICE - ... DONE waiting. ")); 

            /*
             *  Detach our device object from the lower device object stack.
             */
            IoDetachDevice(parentFdoExt->topDevObj);

            /*
             *  Delete all child PDOs.
             */
			if (ISPTR(parentFdoExt->deviceRelations)){
                ULONG i;
				
                DBGVERBOSE(("Parent deleting %xh child PDOs on REMOVE_DEVICE", parentFdoExt->deviceRelations->Count));
                for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
                    PDEVICE_OBJECT childPdo = parentFdoExt->deviceRelations->Objects[i];
                    DEVEXT *devExt = childPdo->DeviceExtension;
                    POSPDOEXT *pdoExt;

                    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);
                    ASSERT(devExt->isPdo);
                    pdoExt = &devExt->pdoExt;
                    DeleteChildPdo(pdoExt);
                }
				FREEPOOL(parentFdoExt->deviceRelations);
                parentFdoExt->deviceRelations = BAD_POINTER;
			}

            if (ISPTR(parentFdoExt->interfaceInfo)){
                FREEPOOL(parentFdoExt->interfaceInfo);
            }

            if (ISPTR(parentFdoExt->configDesc)){
                FREEPOOL(parentFdoExt->configDesc);
            }

            /*
             *  Delete our device object.
             *  This will also delete the associated device extension.
             */
            IoDeleteDevice(parentFdoExt->functionDevObj);

            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
		    if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations){
				status = QueryDeviceRelations(parentFdoExt, irp);
				if (NT_SUCCESS(status)){
					/*
					 *  Although we may have satisfied this IRP, 
					 *  we still pass it down the stack.
					 *  But change the default status to success.
					 */
					irp->IoStatus.Status = status;
				}
				else {
					completeIrpHere = TRUE;
				}
			}
			break;

        case IRP_MN_QUERY_CAPABILITIES:
            /*
             *  Return the USB PDO's capabilities, but add the SurpriseRemovalOK bit.
             */
            ASSERT(irpSp->Parameters.DeviceCapabilities.Capabilities);
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(parentFdoExt, irp);
            if (NT_SUCCESS(status)){
	            irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
			break;

        default:
            break;

    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack asynchronously.
         */
    }
    else if (completeIrpHere){
		ASSERT(status != NO_STATUS);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(parentFdoExt->physicalDevObj, irp);
    }

	DBG_LOG_PNP_IRP(irp, minorFunction, FALSE, TRUE, status);

    return status;
}





NTSTATUS GetDeviceCapabilities(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    parentFdoExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(parentFdoExt->physicalDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        RtlZeroMemory(  &parentFdoExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &parentFdoExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(parentFdoExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


NTSTATUS QueryDeviceRelations(PARENTFDOEXT *parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations){
		DBGVERBOSE(("QueryDeviceRelations(BusRelations) for parent"));

        /*
         *  NTKERN expects a new pointer each time it calls QUERY_DEVICE_RELATIONS;
         *  it then FREES THE POINTER.
         *  So we have to return a new pointer each time, whether or not we actually
         *  created our copy of the device relations for this call.
         */
        irp->IoStatus.Information = (ULONG)CopyDeviceRelations(parentFdoExt->deviceRelations);
        if (irp->IoStatus.Information){
            ULONG i;

            /*  
             *  The kernel dereferences each device object
             *  in the device relations list after each call.
             *  So for each call, add an extra reference.
             */
            for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
                ObReferenceObject(parentFdoExt->deviceRelations->Objects[i]);
                parentFdoExt->deviceRelations->Objects[i]->Flags &= ~DO_DEVICE_INITIALIZING;
            }

            DBGVERBOSE(("Returned %d child PDOs", parentFdoExt->deviceRelations->Count));
            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(NT_SUCCESS(status));
    }
    else {
		ASSERT(irpSp->Parameters.QueryDeviceRelations.Type == BusRelations);
        status = irp->IoStatus.Status;
    }

    return status;
}



NTSTATUS PDO_PnP(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(irp);
	
	DBG_LOG_PNP_IRP(irp, irpSp->MinorFunction, TRUE, FALSE, -1);

	switch (irpSp->MinorFunction){

		case IRP_MN_START_DEVICE:
			status = CreateSymbolicLink(pdoExt);
			if (NT_SUCCESS(status)){
				pdoExt->state = STATE_STARTED;
                /*
                 *  Initializing URB to read the status endpoint for Serial Emulation. 
                 */
                if(pdoExt->parentFdoExt->posFlag & SERIAL_EMULATION) {
                    StatusPipe(pdoExt, pdoExt->statusEndpointInfo.pipeHandle);
                    DBGVERBOSE(("PDO_PnP: URB to read Status Endpoint initialized"));
                }
			}
			else {
				pdoExt->state = STATE_START_FAILED;
			}
			break;

        case IRP_MN_QUERY_STOP_DEVICE:
			status = STATUS_SUCCESS;
			break;

        case IRP_MN_STOP_DEVICE:
			pdoExt->state = STATE_STOPPED;
			status = STATUS_SUCCESS;
			break;

        case IRP_MN_SURPRISE_REMOVAL:
			status = FlushBuffers(pdoExt);
			break;

        case IRP_MN_REMOVE_DEVICE:
			{
                ULONG oldState = pdoExt->state;
                KIRQL oldIrql;
                BOOLEAN foundPdo = FALSE;
                ULONG i;


				pdoExt->state = STATE_REMOVED;

				if ((oldState == STATE_STARTED) || (oldState == STATE_STOPPED)){
					DestroySymbolicLink(pdoExt);
				}
				else {
					DBGWARN(("previous state is %xh during pdo REMOVE_DEVICE", oldState));
				}


				/*
				 *  See if this child PDO is still in the parent's device relations array.
				 */
				KeAcquireSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, &oldIrql);
				for (i = 0; i < pdoExt->parentFdoExt->deviceRelations->Count; i++){
					if (pdoExt->parentFdoExt->deviceRelations->Objects[i] == pdoExt->pdo){
						foundPdo = TRUE;
					}
				}
				KeReleaseSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, oldIrql);

                FlushBuffers(pdoExt);

                if (foundPdo){
                    /*
                     *  If we are still in the parent's deviceRelations, then don't
                     *  free the pdo or pdoName.Buffer .  We may get another START
                     *  on this same PDO.
                     */
                }
                else {

                    /*
                     *  This shouldn't happen.
                     */
                    ASSERT(foundPdo);

                    /*
                     *  We've recorded this COM port statically in our software key,
                     *  so don't free it in the COM name arbiter.
                     */
                    // ReleaseCOMPort(pdoExt->comPortNumber);

                    DeleteChildPdo(pdoExt);
                }

                status = STATUS_SUCCESS;
			}

			break;

		case IRP_MN_QUERY_ID:
			status = QueryPdoID(pdoExt, irp);
			break;

		case IRP_MN_QUERY_CAPABILITIES:
			ASSERT(irpSp->Parameters.DeviceCapabilities.Capabilities);
			RtlCopyMemory(	irpSp->Parameters.DeviceCapabilities.Capabilities, 
							&pdoExt->parentFdoExt->deviceCapabilities, 
							sizeof(DEVICE_CAPABILITIES));

			/*
			 *  Set the 'Raw' capability so that the child PDO gets started immediately,
			 *  without anyone having to do an open on it first.
			 */
			irpSp->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE;

			irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;

			status = STATUS_SUCCESS;
			break;

		case IRP_MN_QUERY_PNP_DEVICE_STATE:
			status = CallNextDriverSync(pdoExt->parentFdoExt, irp);
			break;

		case IRP_MN_QUERY_DEVICE_RELATIONS:
			if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){
				/*
				 *  Return a reference to this PDO
				 */
				PDEVICE_RELATIONS devRel = ALLOCPOOL(PagedPool, sizeof(DEVICE_RELATIONS));
				if (devRel){
					/*
					 *  Add a reference to the PDO, since CONFIGMG will free it.
					 */
					ObReferenceObject(pdoExt->pdo);
					devRel->Objects[0] = pdoExt->pdo;
					devRel->Count = 1;
					irp->IoStatus.Information = (ULONG_PTR)devRel;
					status = STATUS_SUCCESS;
				}
				else {
					status = STATUS_INSUFFICIENT_RESOURCES;
				}
			}
			else {
				/*
				 *  Fail this Irp by returning the default
				 *  status (typically STATUS_NOT_SUPPORTED).
				 */
				DBGVERBOSE(("PDO_PnP: not handling QueryDeviceRelations type %xh.", (ULONG)irpSp->Parameters.QueryDeviceRelations.Type));
				status = irp->IoStatus.Status;
			}
			break;

		default:
			/*
			 *  Fail the IRP with the default status
			 */
			status = irp->IoStatus.Status;
			break;
	}

	DBG_LOG_PNP_IRP(irp, irpSp->MinorFunction, TRUE, TRUE, status);

	return status;
}


NTSTATUS SubstituteOneBusName(PWCHAR hwId)
{
    NTSTATUS status;
    ULONG len = WStrLen(hwId);

	if ((len > 4) && !WStrNCmpI(hwId, L"USB\\", 4)){

		hwId[0] = L'P';
		hwId[1] = L'O';
		hwId[2] = L'S';

        status = STATUS_SUCCESS;
	}
	else {
		DBGERR(("SubstituteOneBusName: badly formed name at %ph.", hwId));
		status = STATUS_UNSUCCESSFUL;
	}

    return status;
}

/*
 *  SubstituteBusNames
 *
 *		busNames is a multi-string of PnP ids.
 *  Subsitute 'POS\' for 'USB\' in each one.
 */
NTSTATUS SubstituteBusNames(PWCHAR busNames)
{
	NTSTATUS status = STATUS_SUCCESS;

	while (*busNames && (status == STATUS_SUCCESS)){
		ULONG len = WStrLen(busNames);
        status = SubstituteOneBusName(busNames);
		busNames += (len+1);
	}

	ASSERT(NT_SUCCESS(status));
	return status;
}

NTSTATUS QueryPdoID(POSPDOEXT *pdoExt, PIRP irp)
{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

	DBGVERBOSE(("   QueryPdoId: idType = %xh ", irpSp->Parameters.QueryId.IdType));

    switch (irpSp->Parameters.QueryId.IdType){

        case BusQueryHardwareIDs:

            /*
             *  Return a multi-string containing the PnP ID for the POS serial interface.
             *  Must terminate multi-string with a double unicode null.
             */
            (PWCHAR)irp->IoStatus.Information = 
                    MemDup(L"POS\\POS_SERIAL_INTERFACE\0", sizeof(L"POS\\POS_SERIAL_INTERFACE\0"));
            if (irp->IoStatus.Information){
                status = STATUS_SUCCESS;
            }
            else {
                ASSERT(irp->IoStatus.Information);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
           break;

        case BusQueryDeviceID:
            /*
             *  Return the PnP ID for the POS serial interface.
             */
            (PWCHAR)irp->IoStatus.Information = 
                    MemDup(L"POS\\POS_SERIAL_INTERFACE", sizeof(L"POS\\POS_SERIAL_INTERFACE"));
            if (irp->IoStatus.Information){
                status = STATUS_SUCCESS;
            }
            else {
                ASSERT(irp->IoStatus.Information);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            break;

        case BusQueryInstanceID:

            /*
             *  Produce an instance-id for this function-PDO.
             *
             *  Note: NTKERN frees the returned pointer, so we must provide a fresh pointer.
             */
            {
                PWSTR instanceId = MemDup(L"0000", sizeof(L"0000"));
                if (instanceId){
    				KIRQL oldIrql;
                    ULONG i;

                    /*
                     *  Find this collection-PDO in the device-relations array
                     *  and make the id be the PDO's index within that array.
                     */
				    KeAcquireSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, &oldIrql);
                    for (i = 0; i < pdoExt->parentFdoExt->deviceRelations->Count; i++){
                        if (pdoExt->parentFdoExt->deviceRelations->Objects[i] == pdoExt->pdo){
                            break;
                        }
                    }
                    if (i < pdoExt->parentFdoExt->deviceRelations->Count){
                        NumToDecString(instanceId, (USHORT)i, 4);
                        irp->IoStatus.Information = (ULONG)instanceId;
                        status = STATUS_SUCCESS;
                    }
                    else {
                        ASSERT(i < pdoExt->parentFdoExt->deviceRelations->Count);
                        status = STATUS_DEVICE_DATA_ERROR;
                    }
    				KeReleaseSpinLock(&pdoExt->parentFdoExt->devExtSpinLock, oldIrql);

                    if (!NT_SUCCESS(status)){
                        FREEPOOL(instanceId);
                    }

                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryCompatibleIDs:   
            /*
             *  Return multi-string of compatible IDs.
             */
            (PWCHAR)irp->IoStatus.Information = MemDup(L"\0\0", sizeof(L"\0\0"));
            if (irp->IoStatus.Information) {
                status = STATUS_SUCCESS;
            } 
            else {
                ASSERT(irp->IoStatus.Information);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            break;

        default:
			/*
			 *  Do not return STATUS_NOT_SUPPORTED;
			 *  keep the default status 
			 *  (this allows filter drivers to work).
			 */
            status = irp->IoStatus.Status;
            break;
    }

    return status;
}


VOID DeleteChildPdo(POSPDOEXT *pdoExt)
{
    ASSERT(pdoExt->pdoName.Buffer);
    FREEPOOL(pdoExt->pdoName.Buffer);
    IoDeleteDevice(pdoExt->pdo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\read.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    read.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"




NTSTATUS ReadComPort(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION currentIrpSp;

    /* 
     *  In order to support ODD ENDPOINTs, we check
     *  whether this COM port has a read endpoint or not.
     */
    if(!pdoExt->inputEndpointInfo.pipeHandle) {
        DBGVERBOSE(("This PORT does not have an IN endpoint - Read request Rejected."));
        return STATUS_NOT_SUPPORTED;
    }

	DBGVERBOSE(("ReadComPort"));

	currentIrpSp = IoGetCurrentIrpStackLocation(irp);

	ASSERT(currentIrpSp->Parameters.Read.Length);
	ASSERT(!irp->MdlAddress);

	/*
	 *  Because this device object uses buffering method METHOD_NEITHER,
	 *  the read buffer is irp->UserBuffer, which is potentially an application
	 *  read buffer.  If the read completes on a different thread than this calling
	 *  thread, then the completion routine will not have the read buffer addressed
	 *  correctly.
	 *  Therefore, we have to map the UserBuffer using an MDL.
	 */
	irp->MdlAddress = MmCreateMdl(NULL, irp->UserBuffer, currentIrpSp->Parameters.Read.Length);

	if (irp->MdlAddress){
		status = STATUS_SUCCESS;
		
		__try {
			/*
			 *  We're writing the read data to the buffer, so probe for WriteAccess.
			 */
			MmProbeAndLockPages(irp->MdlAddress, UserMode, IoWriteAccess);
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {
			status = GetExceptionCode();
			DBGERR(("MmProbeAndLockPages triggered exception status %xh.", status));
		}

		if (NT_SUCCESS(status)){

            status = EnqueueReadIrp(pdoExt, irp, FALSE, FALSE);

			if (status == STATUS_PENDING){
            	BOOLEAN doReadNow;
            	KIRQL oldIrql;

                /*
                 *  Atomically test-and-set the endpointIsBusy flag.
                 *  If the endpoint was not busy, issue a read after dropping the lock.
                 */
            	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
				if (pdoExt->inputEndpointInfo.endpointIsBusy){
                    doReadNow = FALSE;
                }
                else {
					pdoExt->inputEndpointInfo.endpointIsBusy = TRUE;
					doReadNow = TRUE;
				}
    			KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

			    if (doReadNow){
				    IssueReadForClient(pdoExt);
			    }
			}


		}
	}
	else {
		DBGERR(("MmCreateMdl failed"));
		status = STATUS_DATA_ERROR;
	}

	return status;
}


VOID SatisfyPendingReads(POSPDOEXT *pdoExt)
{
	LIST_ENTRY irpsToCompleteList, readPacketsToFree;
    PLIST_ENTRY listEntry;
	PIRP irp;
	READPACKET *readPacket;
    KIRQL oldIrql;

	DBGVERBOSE(("SatisfyPendingReads"));

	/*
	 *  Accumulate the complete-ready IRPs on a private queue before completing.
	 *  This is so we don't loop forever if they get re-queued on the same thread.
	 */
	InitializeListHead(&irpsToCompleteList);
	InitializeListHead(&readPacketsToFree);

    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

	while (irp = DequeueReadIrp(pdoExt, TRUE)){

		PIO_STACK_LOCATION currentIrpSp = IoGetCurrentIrpStackLocation(irp);
		BOOLEAN canSatisfyOneIrp;

		/*
		 *  Do we have enough bytes to satisfy this IRP ?
		 */
		#if PARTIAL_READ_BUFFERS_OK
			canSatisfyOneIrp = (pdoExt->totalQueuedReadDataLength > 0);
		#else
			canSatisfyOneIrp = (pdoExt->totalQueuedReadDataLength >= currentIrpSp->Parameters.Read.Length);
		#endif

		if (canSatisfyOneIrp){

			ULONG userBufferOffset = 0;
			BOOLEAN satisfiedThisIrp = FALSE;
			PUCHAR mappedUserBuffer;

			ASSERT(irp->MdlAddress);
			ASSERT(!IsListEmpty(&pdoExt->completedReadPacketsList));

			/*
			 *  We may be completing this IRP on a different thread than the calling thread.
			 *  So we cannot dereference UserBuffer directly.
			 *  Use the MDL we created at call time instead.
			 */
			mappedUserBuffer = PosMmGetSystemAddressForMdlSafe(irp->MdlAddress);

			if (mappedUserBuffer){

				while (!IsListEmpty(&pdoExt->completedReadPacketsList) &&
					   (userBufferOffset < currentIrpSp->Parameters.Read.Length)){

					ULONG bytesToCopy;
					BOOLEAN thisIrpFull;

					listEntry = RemoveHeadList(&pdoExt->completedReadPacketsList);
					ASSERT(listEntry);
					readPacket = CONTAINING_RECORD(listEntry, READPACKET, listEntry);
					ASSERT(readPacket->signature == READPACKET_SIG);

					bytesToCopy = MIN(currentIrpSp->Parameters.Read.Length-userBufferOffset,
									  readPacket->length-readPacket->offset);
					ASSERT(bytesToCopy <= pdoExt->totalQueuedReadDataLength);

					DBGVERBOSE(("SatisfyPendingReads: transferring %xh bytes to read irp", bytesToCopy));

					/*
					 *  Since we may be completing this IRP on a different thread than
					 *  the one we got it on, we cannot write into the UserBuffer.
					 *  We have to write into the MDL we allocated when we queued this IRP.
					 */
					RtlCopyMemory(mappedUserBuffer+userBufferOffset,
								  readPacket->data+readPacket->offset,
								  bytesToCopy);

					userBufferOffset += bytesToCopy;
					readPacket->offset += bytesToCopy;
					pdoExt->totalQueuedReadDataLength -= bytesToCopy;

					ASSERT(userBufferOffset <= currentIrpSp->Parameters.Read.Length);
					ASSERT(readPacket->offset <= readPacket->length);

					#if PARTIAL_READ_BUFFERS_OK
						thisIrpFull = (userBufferOffset > 0);
					#else
						thisIrpFull = (userBufferOffset >= currentIrpSp->Parameters.Read.Length);
					#endif

					if (thisIrpFull){
						/*
						 *  We've satisfied this IRP.
						 *  Break out of the inner loop so we get a new IRP.
						 *  Put the readPacket back in its queue in case there
						 *  are more bytes left in it.
						 */
						irp->IoStatus.Information = userBufferOffset;
						irp->IoStatus.Status = STATUS_SUCCESS;
						InsertTailList(&irpsToCompleteList, &irp->Tail.Overlay.ListEntry);
						InsertHeadList(&pdoExt->completedReadPacketsList, &readPacket->listEntry);
						satisfiedThisIrp = TRUE;
						break;
					}
					else if (readPacket->offset == readPacket->length){
						/*
						 *  We've depleted this readPacket buffer.
						 */
                        InsertTailList(&readPacketsToFree, &readPacket->listEntry);
						ASSERT(!IsListEmpty(&pdoExt->completedReadPacketsList));
					}
					else {
						DBGERR(("SatisfyPendingReads - data error"));
						break;
					}

				}

				ASSERT(satisfiedThisIrp);
			}
			else {
				DBGERR(("PosMmGetSystemAddressForMdlSafe failed"));
				irp->IoStatus.Information = 0;
				irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
				InsertTailList(&irpsToCompleteList, &irp->Tail.Overlay.ListEntry);
			}
		}
		else {
			/*
			 *  We can't satisfy this IRP, so put it back at the head of the list.
			 */
            NTSTATUS status;
			DBGVERBOSE(("SatisfyPendingReads: not enough bytes to satisfy irp (%xh/%xh)", pdoExt->totalQueuedReadDataLength, currentIrpSp->Parameters.Read.Length));
            status = EnqueueReadIrp(pdoExt, irp, TRUE, TRUE);
            if (status == STATUS_CANCELLED){
                /*
                 *  The IRP was cancelled and the cancel routine was not called,
                 *  so complete the IRP here.
                 */
				irp->IoStatus.Information = 0;
                irp->IoStatus.Status = status;
    			InsertTailList(&irpsToCompleteList, &irp->Tail.Overlay.ListEntry);
            }

			break;
		}

	}

    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);



	while (!IsListEmpty(&irpsToCompleteList)){
		listEntry = RemoveHeadList(&irpsToCompleteList);
		ASSERT(listEntry);
		irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
		DBGVERBOSE(("SatisfyPendingReads: completing irp with %xh bytes.", irp->IoStatus.Information));

		/*
		 *  Free the MDL we created for the UserBuffer
		 */
		ASSERT(irp->MdlAddress);
		MmUnlockPages(irp->MdlAddress);
		FREEPOOL(irp->MdlAddress);
		irp->MdlAddress = NULL;

		IoCompleteRequest(irp, IO_NO_INCREMENT);
	}

	while (!IsListEmpty(&readPacketsToFree)){
		listEntry = RemoveHeadList(&readPacketsToFree);
		ASSERT(listEntry);
		readPacket = CONTAINING_RECORD(listEntry, READPACKET, listEntry);
        FreeReadPacket(readPacket);
	}


}


/*
 *  IssueReadForClient
 *
 *		Must be called with exclusive access on the input endpoint held.
 */
VOID IssueReadForClient(POSPDOEXT *pdoExt)
{
	PUCHAR readBuf;
	ULONG readLen;

	DBGVERBOSE(("IssueReadForClient"));

	/*
	 *  We always read the full pipe size.
	 *  
	 *  BUGBUG - pipe info needs to be moved to pdoExt.
	 */
	readLen = pdoExt->inputEndpointInfo.pipeLen;

	readBuf = ALLOCPOOL(NonPagedPool, readLen);
	if (readBuf){
		READPACKET *readPacket;

		RtlZeroMemory(readBuf, readLen);

		readPacket = AllocReadPacket(readBuf, readLen, pdoExt);
		if (readPacket){
			ReadPipe(pdoExt->parentFdoExt, pdoExt->inputEndpointInfo.pipeHandle, readPacket, FALSE);
		}
		else {
			FREEPOOL(readBuf);
			FlushBuffers(pdoExt);
		}
	}
	else {
		ASSERT(readBuf);
		FlushBuffers(pdoExt);
	}

}


VOID WorkItemCallback_Read(PVOID context)
{
	POSPDOEXT *pdoExt = context;
	KIRQL oldIrql;
	BOOLEAN issueReadNow = FALSE;

	DBGVERBOSE(("WorkItemCallback_Read"));

	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

	if (IsListEmpty(&pdoExt->pendingReadIrpsList)){
		DBGERR(("WorkItemCallback_Read: list is empty ?!"));
	}
	else {
		if (pdoExt->inputEndpointInfo.endpointIsBusy){
			DBGWARN(("WorkItemCallback_Read: endpoint is busy"));
		}
		else {
			pdoExt->inputEndpointInfo.endpointIsBusy = TRUE;
			issueReadNow = TRUE;
		}
	}

	KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

	if (issueReadNow){
		IssueReadForClient(pdoExt);
	}

}



NTSTATUS EnqueueReadIrp(POSPDOEXT *pdoExt, PIRP irp, BOOLEAN enqueueAtFront, BOOLEAN lockHeld)
{
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS status = STATUS_PENDING;
    KIRQL oldIrql;

    if (!lockHeld) KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    /*
     *  Enqueue the IRP 
     */
    if (enqueueAtFront){
        InsertHeadList(&pdoExt->pendingReadIrpsList, &irp->Tail.Overlay.ListEntry);
    }
    else {
        InsertTailList(&pdoExt->pendingReadIrpsList, &irp->Tail.Overlay.ListEntry);
    }

    /*
     *  Apply the IoMarkIrpPending macro to indicate that the
     *  irp may complete on a different thread.
     *  The kernel will see this flag set when we complete the IRP and get the IRP
     *  back on the right thread if there was a synchronous client.
     */
    IoMarkIrpPending(irp);

    /*
     *  Must set the cancel routine before checking the cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(irp, ReadCancelRoutine);
    ASSERT(!oldCancelRoutine);

    if (irp->Cancel){
        /*
         *  This IRP was cancelled.  
         *  We need to coordinate with the cancel routine to complete this irp.
         */
        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was not called, so dequeue the IRP and return
             *  error so the dispatch routine completes the IRP.
             */
            ASSERT(oldCancelRoutine == ReadCancelRoutine);
            RemoveEntryList(&irp->Tail.Overlay.ListEntry);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  Cancel routine was called and it will complete the IRP
             *  as soon as we drop the spinlock.  So don't touch this IRP.
             *  Return PENDING so dispatch routine won't complete the IRP.
             */
        }
    }

    if (!lockHeld) KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    return status;
}


PIRP DequeueReadIrp(POSPDOEXT *pdoExt, BOOLEAN lockHeld)
{
    PIRP nextIrp = NULL;
    KIRQL oldIrql;

    if (!lockHeld) KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    while (!nextIrp && !IsListEmpty(&pdoExt->pendingReadIrpsList)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&pdoExt->pendingReadIrpsList);

        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        /*
         *  IoCancelIrp() could have just been called on this IRP.
         *  What we're interested in is not whether IoCancelIrp() was called (nextIrp->Cancel flag set),
         *  but whether IoCancelIrp() called (or is about to call) our cancel routine.
         *  To check that, check the result of the test-and-set macro IoSetCancelRoutine.
         */
        if (oldCancelRoutine){
            /*
             *  Cancel routine not called for this IRP.  Return this IRP.
             */
            ASSERT(oldCancelRoutine == ReadCancelRoutine);
        }
        else {
            /*
             *  This IRP was just cancelled and the cancel routine was (or will be) called.
             *  The cancel routine will complete this IRP as soon as we drop the spinlock.
             *  So don't do anything with the IRP.
             *  Also, the cancel routine will try to dequeue the IRP, 
             *  so make the IRP's listEntry point to itself.
             */
            ASSERT(nextIrp->Cancel);
            InitializeListHead(&nextIrp->Tail.Overlay.ListEntry);
            nextIrp = NULL;
        }
    }

    if (!lockHeld) KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    return nextIrp;
}


VOID ReadCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp)
{
	DEVEXT *devExt;
	POSPDOEXT *pdoExt;
	KIRQL oldIrql;

	DBGWARN(("ReadCancelRoutine: devObj=%ph, irp=%ph.", devObj, irp));

	devExt = devObj->DeviceExtension;
	ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);
	ASSERT(devExt->isPdo);
	pdoExt = &devExt->pdoExt;

	IoReleaseCancelSpinLock(irp->CancelIrql);

	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

	RemoveEntryList(&irp->Tail.Overlay.ListEntry);

	KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}


READPACKET *AllocReadPacket(PVOID data, ULONG dataLen, PVOID context)
{
	READPACKET *readPacket;

	readPacket = ALLOCPOOL(NonPagedPool, sizeof(READPACKET));
	if (readPacket){
		readPacket->signature = READPACKET_SIG;
		readPacket->data = data;
		readPacket->length = dataLen;
		readPacket->offset = 0;
		readPacket->context = context;
		readPacket->urb = BAD_POINTER;
		readPacket->listEntry.Flink = readPacket->listEntry.Blink = BAD_POINTER;
	}
	else {
		ASSERT(readPacket);
	}

	return readPacket;
}

VOID FreeReadPacket(READPACKET *readPacket)
{
    DBGVERBOSE(("Freeing readPacket..."));
    ASSERT(readPacket->signature == READPACKET_SIG);
    FREEPOOL(readPacket->data);
    FREEPOOL(readPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\power.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    power.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


NTSTATUS FDO_Power(PARENTFDOEXT *parentFdoExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

    Note: We may or may not have set the DO_POWER_PAGABLE bit
          for the filter device object in AddDevice().
          Therefore, we don't know whether or not this function
          can be called at DISPATCH_LEVEL; so the power-handling
          code must be locked.

Arguments:

    parentFdoExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

			DBGVERBOSE(("IRP_MN_SET_POWER"));

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (parentFdoExt->state == STATE_STARTED){
                                parentFdoExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

		default:
		    DBGVERBOSE(("Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 
			break;
    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IoCopyCurrentIrpStackLocationToNext(irp);
    IncrementPendingActionCount(parentFdoExt);
    IoSetCompletionRoutine( irp, 
                            FDO_PowerComplete, 
                            (PVOID)parentFdoExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(parentFdoExt->physicalDevObj, irp);

    return status;
}


NTSTATUS FDO_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by FDO_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    PARENTFDOEXT *parentFdoExt = (PARENTFDOEXT *)context;

    ASSERT(parentFdoExt);
    
    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (parentFdoExt->state == STATE_SUSPENDED){
                                    parentFdoExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }

    /*
     *  Decrement the pendingActionCount, which we incremented in FDO_Power.
     */
    DecrementPendingActionCount(parentFdoExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
#endif




BOOLEAN IsWin9x()
/*++

Routine Description:

    Determine whether or not we are running on Win9x (vs. NT).
    
Arguments:


Return Value:

    TRUE iff we're running on Win9x.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    HANDLE hKey;
    NTSTATUS status;
    BOOLEAN result;

    /*
     *  Try to open the COM Name Arbiter, which exists only on NT.
     */
	RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
	InitializeObjectAttributes( &objectAttributes,
                                &keyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,				
                                (PSECURITY_DESCRIPTOR)NULL);

    status = ZwOpenKey(&hKey, KEY_QUERY_VALUE, &objectAttributes);
    if (NT_SUCCESS(status)){
        status = ZwClose(hKey);
        ASSERT(NT_SUCCESS(status));
        DBGVERBOSE(("This is Windows NT."));
        result = FALSE;
    }
    else {
        DBGVERBOSE(("This is Win9x."));
        result = TRUE;
    }

    return result;
}



/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)ALLOCPOOL(NonPagedPool, length); // BUGBUG allow paged
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }

    ASSERT(newPtr);
    return newPtr;
}


NTSTATUS CallNextDriverSync(PARENTFDOEXT *parentFdoExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

	IncrementPendingActionCount(parentFdoExt);
    status = CallDriverSync(parentFdoExt->physicalDevObj, irp);
    DecrementPendingActionCount(parentFdoExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(parentFdoExt->pendingActionCount >= 0);
    InterlockedIncrement(&parentFdoExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(parentFdoExt->pendingActionCount >= 0);
    InterlockedDecrement(&parentFdoExt->pendingActionCount);    

    if (parentFdoExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((parentFdoExt->state == STATE_REMOVING) || 
               (parentFdoExt->state == STATE_REMOVED));
        KeSetEvent(&parentFdoExt->removeEvent, 0, FALSE);
    }
}


/*
 ********************************************************************************
 *  CopyDeviceRelations
 ********************************************************************************
 *
 *
 */
PDEVICE_RELATIONS CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations)
{
    PDEVICE_RELATIONS newDeviceRelations;

    PAGED_CODE();

    if (deviceRelations){
        ULONG size = sizeof(DEVICE_RELATIONS) + (deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        newDeviceRelations = MemDup(deviceRelations, size);
    }
    else {
        newDeviceRelations = NULL;
    }

    return newDeviceRelations;
}


/*
 ********************************************************************************
 *  PosMmGetSystemAddressForMdlSafe
 ********************************************************************************
 *
 *
 */
PVOID PosMmGetSystemAddressForMdlSafe(PMDL MdlAddress)
{ 
    PVOID pBuffer = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if(MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        pBuffer = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (~MDL_MAPPING_CAN_FAIL); 
    } 
    else
        ASSERT(MdlAddress != NULL);

    return pBuffer;
}


/*
 ********************************************************************************
 *  WStrLen
 ********************************************************************************
 *
 */
ULONG WStrLen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL){
        result++;
    }

    return result;
}



LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n)
{
    ULONG result;

    while (n && *s1 && *s2 && ((*s1|0x20) == (*s2|0x20))){
        s1++, s2++;
        n--;
    }

    if (n){
        result = ((*s1|0x20) > (*s2|0x20)) ? 1 : ((*s1|0x20) < (*s2|0x20)) ? -1 : 0;
    }
    else {
        result = 0;
    }

    return result;
}


LONG MyLog(ULONG base, ULONG num)
{
	LONG result;
	ASSERT(num);

	for (result = -1; num; result++){
		num /= base;
	}

	return result;
}


void NumToHexString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789ABCDEF";
    LONG         i      = 0;

    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number & 0x0F];
        Number >>= 4;
    }
}


void NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789";
    LONG         i      = 0;

    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number % 10];
        Number /= 10;
    }
}


ULONG LAtoX(PWCHAR wHexString)
/*++

Routine Description:

      Convert a hex string (without the '0x' prefix) to a ULONG.

Arguments:

    wHexString - null-terminated wide-char hex string 
                 (with no "0x" prefix)

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; wHexString[i]; i++){
        if ((wHexString[i] >= L'0') && (wHexString[i] <= L'9')){
            result *= 0x10;
            result += (wHexString[i] - L'0');
        }
        else if ((wHexString[i] >= L'a') && (wHexString[i] <= L'f')){
            result *= 0x10;
            result += (wHexString[i] - L'a' + 0x0a);
        }
        else if ((wHexString[i] >= L'A') && (wHexString[i] <= L'F')){
            result *= 0x10;
            result += (wHexString[i] - L'A' + 0x0a);
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}


ULONG LAtoD(PWCHAR string)
/*++

Routine Description:

      Convert a decimal string (without the '0x' prefix) to a ULONG.

Arguments:

    string - null-terminated wide-char decimal-digit string 
                

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; string[i]; i++){
        if ((string[i] >= L'0') && (string[i] <= L'9')){
            result *= 10;
            result += (string[i] - L'0');
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\usb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"


NTSTATUS InitUSB(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

    Intialize USB-related data

Arguments:

    parentFdoExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
	NTSTATUS status;

	status = GetDeviceDescriptor(parentFdoExt);
	if (NT_SUCCESS(status)){
		status = GetConfigDescriptor(parentFdoExt);
		if (NT_SUCCESS(status)){
			status = SelectConfiguration(parentFdoExt);
		}
	}

	return status;
}




NTSTATUS GetConfigDescriptor(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

    Function retrieves the configuration descriptor from the device

Arguments:

    parentFdoExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    URB urb = { 0 };
    USB_CONFIGURATION_DESCRIPTOR configDescBase = { 0 };
    NTSTATUS status;

    PAGED_CODE();

    /*
     *  Get the first part of the configuration descriptor.
     *  It will tell us the size of the full configuration descriptor, 
     *  including all the following interface descriptors, etc.
     */

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&configDescBase,
                                 NULL,
                                 sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                 NULL);

    status = SubmitUrb(parentFdoExt->topDevObj, &urb, TRUE, NULL, NULL);

    if (NT_SUCCESS(status)) {

        ULONG configDescLen = configDescBase.wTotalLength;
 
        /*
         *  Now allocate the right-sized buffer for the full configuration descriptor.
         */
        ASSERT(configDescLen < 0x1000);
        parentFdoExt->configDesc = ALLOCPOOL(NonPagedPool, configDescLen);
        if (parentFdoExt->configDesc) {

            RtlZeroMemory(parentFdoExt->configDesc, configDescLen);

            UsbBuildGetDescriptorRequest(&urb,
                                         (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         parentFdoExt->configDesc,
                                         NULL,
                                         configDescLen,
                                         NULL);

            status = SubmitUrb(parentFdoExt->topDevObj, &urb, TRUE, NULL, NULL);

            if (NT_SUCCESS(status)) {
                DBGVERBOSE(("Got config desc @ %ph, len=%xh.", parentFdoExt->configDesc, urb.UrbControlDescriptorRequest.TransferBufferLength));
                ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == configDescLen);
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



NTSTATUS GetDeviceDescriptor(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

    Function retrieves the device descriptor from the device

Arguments:

    parentFdoExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    URB urb;
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(&parentFdoExt->deviceDesc, sizeof(parentFdoExt->deviceDesc));

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&parentFdoExt->deviceDesc,
                                 NULL,
                                 sizeof(parentFdoExt->deviceDesc),
                                 NULL);

    status = SubmitUrb(parentFdoExt->topDevObj, &urb, TRUE, NULL, NULL);

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("Got device desc @ %ph, len=%xh (should be %xh).", (PVOID)&parentFdoExt->deviceDesc, urb.UrbControlDescriptorRequest.TransferBufferLength, sizeof(parentFdoExt->deviceDesc)));
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}





NTSTATUS ReadPipe(	PARENTFDOEXT *parentFdoExt, 
			USBD_PIPE_HANDLE pipeHandle, 
			READPACKET *readPacket,
			BOOLEAN synchronous
			)
{
    PURB urb;
    NTSTATUS status;

    ASSERT(pipeHandle);
    DBGVERBOSE(("ReadPipe: dataLen=%xh, sync=%xh", readPacket->length, (ULONG)synchronous));

    urb = ALLOCPOOL(NonPagedPool, sizeof(URB));
    if (urb){
        RtlZeroMemory(urb, sizeof(URB));

        urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
        urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
        urb->UrbBulkOrInterruptTransfer.PipeHandle = pipeHandle;
        urb->UrbBulkOrInterruptTransfer.TransferBufferLength = readPacket->length;
        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
        urb->UrbBulkOrInterruptTransfer.TransferBuffer = readPacket->data;
        urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
        urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

        if (synchronous){
            /*
             *  Synchronous read.
             */
            status = SubmitUrb(parentFdoExt->topDevObj, urb, TRUE, NULL, 0);
            readPacket->length = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            FREEPOOL(urb);
        }
        else {
            /*
             *  Asynchronous read.
             *  Completion routine will free URB.
             */
            IncrementPendingActionCount(parentFdoExt);
            readPacket->urb = urb;
            status = SubmitUrb(	parentFdoExt->topDevObj, 
					            urb, 
					            FALSE,					// asynchronous
					            ReadPipeCompletion,		// completion routine
					            readPacket				// completion context
					            );
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}



NTSTATUS ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    READPACKET *readPacket = (READPACKET *)context;
    NTSTATUS status = irp->IoStatus.Status;
    POSPDOEXT *pdoExt;
    KIRQL oldIrql;

    ASSERT(readPacket->signature == READPACKET_SIG);
    pdoExt = readPacket->context;


    /*
     *  Set the readPacket's length to the actual length returned by the device.
     */
    ASSERT(readPacket->urb->UrbBulkOrInterruptTransfer.TransferBufferLength <= readPacket->length);
    readPacket->length = readPacket->urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    DBGVERBOSE(("ReadPipeCompletion: irp=%ph, status=%xh, data=%ph, len=%xh, context=%ph.", irp, status, readPacket->data, readPacket->length, readPacket->context)); 

    FREEPOOL(readPacket->urb);
    readPacket->urb = BAD_POINTER;

    if (NT_SUCCESS(status)){

	    DBGSHOWBYTES("READ PIPE result", readPacket->data, readPacket->length);

	    if (pdoExt){

		    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

		    ASSERT(pdoExt->inputEndpointInfo.endpointIsBusy);
		    pdoExt->inputEndpointInfo.endpointIsBusy = FALSE;

		    /*
		     *  Queue this completed readPacket
		     */
		    ASSERT(readPacket->offset == 0);

		    /*
		     *  Do NOT queue empty readPackets.
		     */
            if(readPacket->length == 0)
                FreeReadPacket(readPacket);
            else {
                InsertTailList(&pdoExt->completedReadPacketsList, &readPacket->listEntry);
                pdoExt->totalQueuedReadDataLength += readPacket->length;
            }

		    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

		    /*
		     *  Now try to satisfy pending read IRPs with the completed readPacket data.
		     */
		    SatisfyPendingReads(pdoExt);
	    }
	    else {
		    DBGVERBOSE(("Just debug testing -- not processing read result"));
		    FreeReadPacket(readPacket);
	    }
    }
    else {
	    FreeReadPacket(readPacket);
    }


    /*
     *  If there are more read IRPs pending, issue another read.
     */
    if (pdoExt){
	    BOOLEAN scheduleAnotherRead;

	    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
	    scheduleAnotherRead = !IsListEmpty(&pdoExt->pendingReadIrpsList);
	    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

	    if (scheduleAnotherRead){
		    DBGVERBOSE(("ReadPipeCompletion: scheduling read workItem"));
		    ExQueueWorkItem(&pdoExt->readWorkItem, DelayedWorkQueue);
	    }
    }


    /*
     *  This IRP was allocated by SubmitUrb().  Free it here.
     *  Return STATUS_MORE_PROCESSING_REQUIRED so the kernel does not
     *  continue processing this IRP.
     */
    IoFreeIrp(irp);
    DecrementPendingActionCount(pdoExt->parentFdoExt);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS WritePipe(PARENTFDOEXT *parentFdoExt, USBD_PIPE_HANDLE pipeHandle, PUCHAR data, ULONG dataLen)
{
	URB urb;
	NTSTATUS status;

    ASSERT(pipeHandle);
	DBGSHOWBYTES("WritePipe bytes:", data, dataLen);

    urb.UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb.UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb.UrbBulkOrInterruptTransfer.PipeHandle = pipeHandle;
    urb.UrbBulkOrInterruptTransfer.TransferBufferLength = dataLen;
    urb.UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    urb.UrbBulkOrInterruptTransfer.TransferBuffer = data;
    urb.UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_OUT;
    urb.UrbBulkOrInterruptTransfer.UrbLink = NULL;

	status = SubmitUrb(parentFdoExt->topDevObj, &urb, TRUE, NULL, NULL);

	return status;
}


NTSTATUS SubmitUrb( PDEVICE_OBJECT pdo, 
                    PURB urb, 
                    BOOLEAN synchronous, 
                    PVOID completionRoutine,
                    PVOID completionContext)
/*++

Routine Description:

    Send the URB to the USB device.
	If synchronous is TRUE, ignore the completion info and synchonize the IRP;
    otherwise, don't synchronize and set the provided completion routine for the IRP.

Arguments:

    
Return Value:

    NT status code

--*/
{
    PIRP irp;
    NTSTATUS status;


	/*
	 *  Allocate the IRP to send the buffer down the USB stack.
	 *
	 *  Don't use IoBuildDeviceIoControlRequest (because it queues
	 *  the IRP on the current thread's irp list and may
	 *  cause the calling process to hang if the IopCompleteRequest APC
	 *  does not fire and dequeue the IRP).
	 */
	irp = IoAllocateIrp(pdo->StackSize, FALSE);

    if (irp){
        PIO_STACK_LOCATION nextSp;

        #if STATUS_ENDPOINT
		DBGVERBOSE(("SubmitUrb: submitting URB %ph on IRP %ph (sync=%d)", urb, irp, synchronous));
        #endif

        nextSp = IoGetNextIrpStackLocation(irp);
		nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
		nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

		/*
		 *  Attach the URB to this IRP.
		 */
        nextSp->Parameters.Others.Argument1 = urb;

        if (synchronous){

            status = CallDriverSync(pdo, irp);

			IoFreeIrp(irp);
        }
        else {
            /*
             *  Caller's completion routine will free the irp 
             *  when it completes.
             */
            ASSERT(completionRoutine);
            ASSERT(completionContext);
            IoSetCompletionRoutine( irp, 
                                    completionRoutine, 
                                    completionContext,
                                    TRUE, TRUE, TRUE);
            status = IoCallDriver(pdo, irp);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}




NTSTATUS SelectConfiguration(PARENTFDOEXT *parentFdoExt)
{
	USBD_INTERFACE_LIST_ENTRY interfaceList[2];
	NTSTATUS status;
	
	/*
	 *  We only look at vendor-class interfaces
	 */
	// BUGBUG - limited to one interface
	interfaceList[0].InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                parentFdoExt->configDesc,
                parentFdoExt->configDesc,
                -1,
                -1,
                USB_INTERFACE_CLASS_VENDOR,
                -1,
                -1);

	if (interfaceList[0].InterfaceDescriptor){
		PURB urb;

		interfaceList[1].InterfaceDescriptor = NULL;	

		urb = USBD_CreateConfigurationRequestEx(parentFdoExt->configDesc, &interfaceList[0]);
		if (urb){

			status = SubmitUrb(parentFdoExt->topDevObj, urb, TRUE, NULL, NULL);

            if (NT_SUCCESS(status)){
				PUSBD_INTERFACE_INFORMATION interfaceInfo;

				parentFdoExt->configHandle = urb->UrbSelectConfiguration.ConfigurationHandle;

				interfaceInfo = &urb->UrbSelectConfiguration.Interface;
				parentFdoExt->interfaceInfo = MemDup(interfaceInfo, interfaceInfo->Length);
				if (parentFdoExt->interfaceInfo){
                    DBGVERBOSE(("SelectConfiguration: got interfaceInfo @ %ph.", parentFdoExt->interfaceInfo));
				}
				else {
					status = STATUS_INSUFFICIENT_RESOURCES;
				}
			}
			else {
				DBGERR(("SelectConfiguration: URB failed w/ %xh.", status));
			}

			FREEPOOL(urb);
		}
		else {
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	else {
		status = STATUS_DEVICE_DATA_ERROR;
	}


	return status;
}



NTSTATUS CreatePdoForEachEndpointPair(PARENTFDOEXT *parentFdoExt)
/*++

Routine Description:

    Walk the USB endpoints.
	For each input/output endpoint pair, create one PDO
	which will be exposed as a COM (serial) port interface.

	BUGBUG - right now, this only looks at the first interface 
			 (on the default confuguration)

Arguments:

    parentFdoExt - device extension for the targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    ULONG maxPossiblePDOs, deviceRelationsSize;

    maxPossiblePDOs = (parentFdoExt->interfaceInfo->NumberOfPipes/2);
    deviceRelationsSize = sizeof(DEVICE_RELATIONS) + maxPossiblePDOs*sizeof(PDEVICE_OBJECT);
    parentFdoExt->deviceRelations = ALLOCPOOL(NonPagedPool, deviceRelationsSize);

    if (parentFdoExt->deviceRelations){
        ULONG inputPipeIndex = 0, outputPipeIndex = 0, statusPipeIndex = 0, comInterfaceIndex = 0;

        RtlZeroMemory(parentFdoExt->deviceRelations, deviceRelationsSize);

        status = STATUS_NO_MATCH;

        while (TRUE){
            UCHAR endPtAddr;
            USBD_PIPE_TYPE pipeType;

            #if STATUS_ENDPOINT
            /*
             *  In the case of Serial Emulation, the protocol is that all DATA endpoints
             *  will be of type BULK and all STATUS endpoints will be of type INTERRUPT.
             */
            if(parentFdoExt->posFlag & SERIAL_EMULATION) {
                while(inputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) {
                    endPtAddr = parentFdoExt->interfaceInfo->Pipes[inputPipeIndex].EndpointAddress;
                    pipeType = parentFdoExt->interfaceInfo->Pipes[inputPipeIndex].PipeType;
                    if((pipeType == UsbdPipeTypeBulk) && (endPtAddr & USB_ENDPOINT_DIRECTION_MASK)) 
                        break;
                    inputPipeIndex++;
                }
                while(outputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) {
                endPtAddr = parentFdoExt->interfaceInfo->Pipes[outputPipeIndex].EndpointAddress;
                    pipeType = parentFdoExt->interfaceInfo->Pipes[outputPipeIndex].PipeType;
                    if((pipeType == UsbdPipeTypeBulk) && !(endPtAddr & USB_ENDPOINT_DIRECTION_MASK))
	                    break;
                    outputPipeIndex++;
                }
                while(statusPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) {
                    endPtAddr = parentFdoExt->interfaceInfo->Pipes[statusPipeIndex].EndpointAddress;
                    pipeType = parentFdoExt->interfaceInfo->Pipes[statusPipeIndex].PipeType;
                    if((pipeType == UsbdPipeTypeInterrupt) && (endPtAddr & USB_ENDPOINT_DIRECTION_MASK))
                        break;
                    statusPipeIndex++;
	            }
                if(!(statusPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes))
                    break;
            }
            else {
            #endif
                /*
                 *  No Serial Emulation required. Find only DATA endpoints
                 *  which can be of either type in this case.
                 */
                while(inputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) {
                    endPtAddr = parentFdoExt->interfaceInfo->Pipes[inputPipeIndex].EndpointAddress;
                    pipeType = parentFdoExt->interfaceInfo->Pipes[inputPipeIndex].PipeType;
                    if((pipeType == UsbdPipeTypeInterrupt) || (pipeType == UsbdPipeTypeBulk)) {
                        if(endPtAddr & USB_ENDPOINT_DIRECTION_MASK) {
	                        break;
                        }
                    }
                    inputPipeIndex++;
                }
                while(outputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) {
                    endPtAddr = parentFdoExt->interfaceInfo->Pipes[outputPipeIndex].EndpointAddress;
                    pipeType = parentFdoExt->interfaceInfo->Pipes[outputPipeIndex].PipeType;
                    if((pipeType == UsbdPipeTypeInterrupt) || (pipeType == UsbdPipeTypeBulk)) {
                        if(!(endPtAddr & USB_ENDPOINT_DIRECTION_MASK)) {
	                        break;
                        }
                    }
                    outputPipeIndex++;
                }
            #if STATUS_ENDPOINT
            }
            #endif

            if ((inputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes) &&
	            (outputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes)){

                /*
                 *  We've found a pair (in/out) of endpoints.
                 *  Create a PDO to represent a COM (serial) port interface on these endpoints.
                 */
                PUSBD_PIPE_INFORMATION inputPipeInfo = &parentFdoExt->interfaceInfo->Pipes[inputPipeIndex];
                PUSBD_PIPE_INFORMATION outputPipeInfo = &parentFdoExt->interfaceInfo->Pipes[outputPipeIndex];
                ENDPOINTINFO inputEndpointInfo, outputEndpointInfo, statusEndpointInfo;
                #if EPSON_PRINTER
                /*
                 *  On the EPSON printer, we want to talk to the endpoints size 0x40,
                 *  not the other pair with length 8.
                 */
                if ((inputPipeInfo->MaximumPacketSize == 8) && (outputPipeInfo->MaximumPacketSize == 8)){
                    inputPipeIndex++, outputPipeIndex++;
                    continue;
                }
                #endif

                inputEndpointInfo.pipeHandle = inputPipeInfo->PipeHandle;
                inputEndpointInfo.pipeLen = inputPipeInfo->MaximumPacketSize;
                inputEndpointInfo.endpointIsBusy = FALSE;

                outputEndpointInfo.pipeHandle = outputPipeInfo->PipeHandle;
                outputEndpointInfo.pipeLen = outputPipeInfo->MaximumPacketSize;
                outputEndpointInfo.endpointIsBusy = FALSE;

                #if STATUS_ENDPOINT
                if(parentFdoExt->posFlag & SERIAL_EMULATION) {
                    PUSBD_PIPE_INFORMATION statusPipeInfo = &parentFdoExt->interfaceInfo->Pipes[statusPipeIndex];
                    statusEndpointInfo.pipeHandle = statusPipeInfo->PipeHandle;
                    statusEndpointInfo.pipeLen = statusPipeInfo->MaximumPacketSize;
                    statusEndpointInfo.endpointIsBusy = FALSE;
                }
                #endif

                status = CreateCOMPdo(parentFdoExt, comInterfaceIndex++, &inputEndpointInfo, &outputEndpointInfo, &statusEndpointInfo);
                if (NT_SUCCESS(status)){
                    DBGVERBOSE(("CreatePdoForEachEndpointPair: created COMPdo with in/out len %xh/%xh.", inputEndpointInfo.pipeLen, outputEndpointInfo.pipeLen));
                    inputPipeIndex++, outputPipeIndex++, statusPipeIndex++; 
                }
                else {
                    DBGERR(("CreatePdoForEachEndpointPair: CreateCOMPdo failed with %xh.", status));
                    break;
                }
            }
            else {
                if((parentFdoExt->posFlag & ODD_ENDPOINT) && 
                   ((inputPipeIndex + outputPipeIndex) < (2 * parentFdoExt->interfaceInfo->NumberOfPipes))) {

                    /*
                     *  We've found an odd endpoint.
                     *  Create a PDO to represent a COM (serial) port interface on this endpoint.
                     */
                    PUSBD_PIPE_INFORMATION oddPipeInfo = &parentFdoExt->interfaceInfo->Pipes[MIN(inputPipeIndex, outputPipeIndex)];
                    ENDPOINTINFO oddEndpointInfo;

                    oddEndpointInfo.pipeHandle = oddPipeInfo->PipeHandle;
                    oddEndpointInfo.pipeLen = oddPipeInfo->MaximumPacketSize;
                    oddEndpointInfo.endpointIsBusy = FALSE;

                    if(inputPipeIndex < parentFdoExt->interfaceInfo->NumberOfPipes)
                        status = CreateCOMPdo(parentFdoExt, comInterfaceIndex++, &oddEndpointInfo, NULL, NULL);
                    else
                        status = CreateCOMPdo(parentFdoExt, comInterfaceIndex++, NULL, &oddEndpointInfo, NULL);

                    if (NT_SUCCESS(status)){
                        DBGVERBOSE(("CreatePdoForEachEndpointPair: created <odd> COMPdo with len %xh.", oddEndpointInfo.pipeLen));
                    }
                    else {
                        DBGERR(("CreatePdoForEachEndpointPair: CreateCOMPdo failed with %xh.", status));
                        break;
                    }
                }
                break;
            }
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\hicomprn\hicomprn.c ===
/*
 *  HICOMPRN.C
 *
 *      Test printing to high COM ports (  > COM9  )
 *      for which you have to designate the full filename:
 *      '\DosDevices\COMxx' instead of just 'COMx'.
 *
 *
 *
 */


#include <stdio.h>

int main(int argc, char *argv[])
{
 char *partialFileName;
 char *string;
 char fullFileName[40];
 int bytesWritten;

 FILE *comFile;

 if (argc != 3){
        printf("\n USAGE: hicomprn <basicfilename> <string>.\n");
        return 0;
 }

 partialFileName = argv[1];
 string = argv[2];

 sprintf(fullFileName, "\\\\.\\%s", partialFileName);
 printf("\n attempting write to '%s'.\n", fullFileName);

 _asm int 3 // BUGBUG REMOVE

 comFile = fopen(fullFileName, "r+");
 if (comFile){
        bytesWritten = fwrite(string, sizeof(char), strlen(string), comFile);
        fflush(comFile);
        printf("\n wrote %d bytes\n", bytesWritten);
        fclose(comFile);
 }
 else {
        printf("\n fopen failed\n");

 }

 return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\cutpaper\cutpaper.c ===
/*
 *      CUTPAPER.C
 *
 *
 *		Testing Printer
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

#define MAX_BUFFER                      256


void main(int argc,char *argv[])
{
    HANDLE comFile;
    char *myPort, fullFileNameBuf[40];
    ULONG posFlag;
    DWORD dwSize;

    if (argc != 2) {
        printf("\n USAGE: cutpaper <fileName> - Testing Printer\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    sprintf(fullFileNameBuf, "\\\\.\\%s", myPort);
    myPort = fullFileNameBuf;

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != INVALID_HANDLE_VALUE) {

        char cmds[] = "\x1b""a""\x01"                   // Center-Justification
                      "\n\nYOUR RECEIPT\n\n"
                      "\n1098.32"
                      "\n0022.23"
                      "\n-------"
                      "\n1120.55"
                      "\n-------\n\n"
                      "\n\nTHANK YOU\n\n"
                      "\n\nHAVE A GOOD DAY\n\n"
                      "\x1d""V""\x42\x50"               //  Cut-Paper
                      ;

        printf("\nPrinting receipt...\n");

        if (!WriteFile(comFile, 
                       (LPVOID)cmds,
                       (sizeof(cmds)-1),
                       &dwSize,
                       NULL)) 
            printf("Unable to print receipt: %d\n",GetLastError());

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\ioctl\testcomm\testcomm.c ===
/*
 *      TESTCOMM.C
 *
 *
 *		Testing Ioctl Calls
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

void main(int argc,char *argv[])
{
    HANDLE comFile;
    DCB myDcb;
    DWORD myBaud;
    char *myPort;
    int bits, parity, size;

    if (argc != 2) {
        printf("\n USAGE: testcomm <fileName> - Testing CommState\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != INVALID_HANDLE_VALUE) {

        printf("\nGetting CommState...\n");
        if (!GetCommState(comFile, &myDcb)) {
            printf("Unable to GetCommState: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        printf("Current Baud Rate: %d\n", myDcb.BaudRate);
        printf("Current Byte Size: %d\n", myDcb.ByteSize);
        printf("Current Parity   : %d\n", myDcb.Parity);
        printf("Current StopBits : %d\n", myDcb.StopBits);

        printf("\nEnter Baud Rate: ");
        scanf("%u",&myDcb.BaudRate);

        printf("Enter Byte Size (5-8): ");
        scanf("%d",&size);
        myDcb.ByteSize = (BYTE)size;

        printf("Enter Parity type (0-4): ");
        scanf("%d",&parity);
        myDcb.Parity = (BYTE)parity;

        printf("Enter number of Stop Bits (0,1,2): ");
        scanf("%d",&bits);
        myDcb.StopBits = (BYTE)bits;

        printf("\nSetting CommState...\n");			
        if (!SetCommState(comFile, &myDcb)) {
            printf("Unable to SetCommState: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        printf("\nRetrieving New CommState...\n");
        if (!GetCommState(comFile, &myDcb)) {
            printf("Unable to GetCommState: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        printf("New Baud Rate: %d\n", myDcb.BaudRate);
        printf("New Byte Size: %d\n", myDcb.ByteSize);
        printf("New Parity   : %d\n", myDcb.Parity);
        printf("New StopBits : %d\n", myDcb.StopBits); 

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\posusb\write.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    write.c

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "escpos.h"
#include "debug.h"




NTSTATUS WriteComPort(POSPDOEXT *pdoExt, PIRP irp)
{
	NTSTATUS status;
	PIO_STACK_LOCATION currentIrpSp;

    /* 
     *  In order to support ODD ENDPOINTs, we check
     *  whether this COM port has a write endpoint or not.
     */
    if(!pdoExt->outputEndpointInfo.pipeHandle) {
        DBGVERBOSE(("This PORT does not have an OUT endpoint - Write request Rejected."));
        return STATUS_NOT_SUPPORTED;
    }

	currentIrpSp = IoGetCurrentIrpStackLocation(irp);

	/*
	 *  Because this pdo's buffering method is METHOD_NEITHER,
	 *  the buffer pointer is irp->UserBuffer, which may be an application address.
	 *  Since we may not be able to send this buffer synchronously on this thread,
	 *  we have to allocate an MDL for it.
	 */
	ASSERT(!irp->MdlAddress);
	ASSERT(currentIrpSp->Parameters.Write.Length);
	irp->MdlAddress = MmCreateMdl(NULL, irp->UserBuffer, currentIrpSp->Parameters.Write.Length);
	if (irp->MdlAddress){
		status = STATUS_SUCCESS;
		__try {
			/*
			 *  We're reading the write data from the buffer, so probe for ReadAccess.
			 */
			MmProbeAndLockPages(irp->MdlAddress, UserMode, IoReadAccess);
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {
			status = GetExceptionCode();
			DBGERR(("MmProbeAndLockPages triggered exception status %xh.", status));
		}
		if (NT_SUCCESS(status)){
			status = TryWrite(pdoExt, irp);
		}
	}
	else {
		DBGERR(("MmCreateMdl failed"));
		status = STATUS_DATA_ERROR;
	}

	return status;
}


NTSTATUS TryWrite(POSPDOEXT *pdoExt, PIRP irp)
{
    NTSTATUS status = STATUS_PENDING;
    BOOLEAN isBusy;
    KIRQL oldIrql;
    BOOLEAN irpWasCancelled = FALSE;


    KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

    if (pdoExt->outputEndpointInfo.endpointIsBusy){
        /*
         *  Another thread is writing to this endpoint now.
         *  Queue the IRP.
         */
        PDRIVER_CANCEL oldCancelRoutine;

        DBGWARN(("WriteComPort:  endpoint is busy so queuing irp"));
        oldCancelRoutine = IoSetCancelRoutine(irp, WriteCancelRoutine);
        ASSERT(!oldCancelRoutine);
        if (irp->Cancel){
            DBGWARN(("WriteComPort: irp %ph was cancelled.", irp));
            irpWasCancelled = TRUE;
            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine){
                /*
                 *  Cancel routine was not called, so complete the IRP here.
                 */
                ASSERT(oldCancelRoutine == ReadCancelRoutine);
                status = STATUS_CANCELLED;
            }
            else {
                /*
                 *  Cancel routine was called and it will complete the IRP
                 *  as soon as we drop the spinlock.  So don't touch this IRP.
                 *  Return PENDING so dispatch routine won't complete the IRP.
                 */
                status = STATUS_PENDING;
            }
        }
        else {
            InsertTailList(&pdoExt->pendingWriteIrpsList, &irp->Tail.Overlay.ListEntry);
        }
        isBusy = TRUE;
    }
    else {
        pdoExt->outputEndpointInfo.endpointIsBusy = TRUE;
        isBusy = FALSE;
    }

    KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);


    if (!isBusy){

        PUCHAR mappedUserBuffer;
        ULONG dataLen;
        ULONG dataWritten = 0;
        PIO_STACK_LOCATION currentIrpSp;
        BOOLEAN callWriteWorkItem = FALSE;

        currentIrpSp = IoGetCurrentIrpStackLocation(irp);

        status = STATUS_SUCCESS;  // in case dataLen = 0

        /*
         *  This function is called from the dispatch routine and also
         *  from a workItem callback.  So we may not be on the calling thread.
         *  Therefore, we cannot use irp->UserBuffer because it may not be
         *  mapped in this context.  Use the MDL we created at call time instead.
         */
        mappedUserBuffer = PosMmGetSystemAddressForMdlSafe(irp->MdlAddress);

        if(mappedUserBuffer) {
            dataLen = currentIrpSp->Parameters.Write.Length;

            while (dataLen){
                ULONG len = MIN(dataLen, pdoExt->outputEndpointInfo.pipeLen);

                DBGVERBOSE(("Writing %xh bytes to pipe.", len));
                status = WritePipe( pdoExt->parentFdoExt, 
                                    pdoExt->outputEndpointInfo.pipeHandle, 
                                    mappedUserBuffer, 
                                    len);
                if (NT_SUCCESS(status)){
                    dataLen -= len;
                    dataWritten += len;
                    mappedUserBuffer += len;
                }
                else {
                    DBGERR(("Write failed with status %xh.", status));
                    break;
                }
            }

            /*
             *  Free the MDL we created for the UserBuffer
             */
            ASSERT(irp->MdlAddress);
            MmUnlockPages(irp->MdlAddress);
            FREEPOOL(irp->MdlAddress);
            irp->MdlAddress = NULL;

            irp->IoStatus.Information = dataWritten;

            KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
            pdoExt->outputEndpointInfo.endpointIsBusy = FALSE;
            if (!IsListEmpty(&pdoExt->pendingWriteIrpsList)){
	            callWriteWorkItem = TRUE;;
            }
            KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

            /*
             *  If there are some writes waiting, schedule a workItem to process them.
             */
            if (callWriteWorkItem){
                ExQueueWorkItem(&pdoExt->writeWorkItem, DelayedWorkQueue);
            }
        }
        else {
            /*
             *  Return STATUS_UNSUCCESSFUL and free the MDL we created for the UserBuffer.
             */
            DBGERR(("PosMmGetSystemAddressForMdlSafe failed"));
            irp->IoStatus.Information = 0;
            status = STATUS_UNSUCCESSFUL;

            ASSERT(irp->MdlAddress);
            MmUnlockPages(irp->MdlAddress);
            FREEPOOL(irp->MdlAddress);
            irp->MdlAddress = NULL;
        }
    }

    return status;
}


VOID WorkItemCallback_Write(PVOID context)
{
	POSPDOEXT *pdoExt = (POSPDOEXT *)context;
	KIRQL oldIrql;
	PIRP irp = NULL;

	DBGVERBOSE(("WorkItemCallback_Write:  pdoExt=%ph ", pdoExt));

	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);

	if (IsListEmpty(&pdoExt->pendingWriteIrpsList)){
		DBGERR(("WorkItemCallback_Write: list is empty ?!"));
	}
	else {
		while (!irp && !IsListEmpty(&pdoExt->pendingWriteIrpsList)){

			PDRIVER_CANCEL cancelRoutine;
			PLIST_ENTRY listEntry = RemoveHeadList(&pdoExt->pendingWriteIrpsList);

			ASSERT(listEntry);
			irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
			cancelRoutine = IoSetCancelRoutine(irp, NULL);

			if (cancelRoutine){
				ASSERT(cancelRoutine == WriteCancelRoutine);
			}
			else {
				/*
				 *  This IRP was cancelled and the cancel routine was called.
				 *  The cancel routine will complete this IRP as soon as we drop
				 *  the spinlock, so don't touch the IRP.
				 */
				ASSERT(irp->Cancel);
				DBGWARN(("WorkItemCallback_Write: irp was cancelled"));
				irp = NULL;
			}
		}
	}

	KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

	if (irp){
		NTSTATUS status = TryWrite(pdoExt, irp);
		if (status != STATUS_PENDING){

			/*
			 *  Set the SL_PENDING in the IRP 
			 *  to indicate that the IRP is completing on a different thread.
			 */
			IoMarkIrpPending(irp);

			irp->IoStatus.Status = status;
			IoCompleteRequest(irp, IO_NO_INCREMENT);
		}
	}
}


VOID WriteCancelRoutine(PDEVICE_OBJECT devObj, PIRP irp)
{
	DEVEXT *devExt;
	POSPDOEXT *pdoExt;
	KIRQL oldIrql;

	DBGWARN(("WriteCancelRoutine: devObj=%ph, irp=%ph.", devObj, irp));

	devExt = devObj->DeviceExtension;
	ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);
	ASSERT(devExt->isPdo);
	pdoExt = &devExt->pdoExt;

	KeAcquireSpinLock(&pdoExt->devExtSpinLock, &oldIrql);
	RemoveEntryList(&irp->Tail.Overlay.ListEntry);
	KeReleaseSpinLock(&pdoExt->devExtSpinLock, oldIrql);

	IoReleaseCancelSpinLock(irp->CancelIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\ioctl\testmodem\testmodem.c ===
/*
 *      TESTTIME.C
 *
 *
 *		Testing Ioctl Calls
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

void main(int argc,char *argv[])
{
    HANDLE comFile;
    DWORD modemStat;
    COMMTIMEOUTS timeouts;
    DWORD myBaud;
    char *myPort;

    if (argc != 2) {
        printf("\n USAGE: testmodem <fileName> - Testing Modem Status\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != ((HANDLE)-1)) {

	    printf("\nGetting Modem Status...\n");
	    if (!GetCommModemStatus(comFile, &modemStat)) {
            printf("Unable to get Modem Status: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
	    }
	    else {
            if (modemStat & MS_CTS_ON) 
	            printf("CTS is ON\n");
            if (modemStat & MS_DSR_ON) 
	            printf("DSR is ON\n");
            if (modemStat & MS_RING_ON) 
	            printf("RING is ON\n");
            if (modemStat & MS_RLSD_ON) 
	            printf("RLSD is ON\n");
            if (modemStat & ~(MS_CTS_ON  |
                              MS_DSR_ON  |
                              MS_RING_ON |
                              MS_RLSD_ON)) 
                printf("Unknown Modem Status: %x\n",modemStat);
	    }
        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\ioctl\testmask\testmask.c ===
/*
 *      TESTMASK.C
 *
 *
 *		Testing Ioctl Calls
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

void main(int argc,char *argv[])
{
    HANDLE comFile;
    ULONG mask;
    char *myPort;

    if(argc != 2) {
	    printf("\n USAGE: testmask <fileName> - Testing Wait Masks\n");
	    return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(comFile != ((HANDLE)-1)) {

        // Reading Current COMM MASK
        printf("\nReading Comm Mask...\n");
        if(GetCommMask(comFile, &mask))
            printf("Current Comm Mask: %d\n", mask);
        else {
            printf("Error getting Comm Mask: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        printf("\nEnter New Comm Mask...\n");
        printf("8. EV_CTS 16.EV_DSR 32.EV_RLSD 64.EV_BREAK 128.EV_ERR 256.EV_RING ? ");
        scanf ("%u",&mask);

        // Setting New COMM MASK
        printf("\nSetting New Comm Mask...\n");
        if (SetCommMask(comFile, mask))	{
            printf("\nReading New Comm Mask...\n");
            if (GetCommMask(comFile, &mask))
                printf("Current Comm Mask: %d\n", mask);
            else 
                printf("Error getting Comm Mask: %d\n",GetLastError());
        }
        else {
            printf("Error setting Comm Mask: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        // Waiting on COMM MASK
        printf("\nWaiting on Comm Mask...\n");
        if(WaitCommEvent(comFile, &mask, NULL))
            printf("Mask of the events that occured: %d\n", mask);
        else 
            printf("Error waiting on Comm Mask: %d\n", GetLastError());

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\ioctl\testioctl\testioctl.c ===
/*
 *      TESTIOCTL.C
 *
 *
 *		Testing Ioctl Calls
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

#define IOCTL_INDEX                     0x0800
#define IOCTL_SERIAL_QUERY_DEVICE_NAME  CTL_CODE(FILE_DEVICE_SERIAL_PORT, IOCTL_INDEX + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_QUERY_DEVICE_ATTR  CTL_CODE(FILE_DEVICE_SERIAL_PORT, IOCTL_INDEX + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define MAX_BUFFER                      256


void main(int argc,char *argv[])
{
    HANDLE comFile;
    char *myPort, fullFileNameBuf[40];
    LPTSTR pBuffer;
    ULONG posFlag;
    DWORD dwSize;
    int i;

    if (argc != 2) {
        printf("\n USAGE: testioctl <fileName> - Testing Ioctl\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    sprintf(fullFileNameBuf, "\\\\.\\%s", myPort);
    myPort = fullFileNameBuf;

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != INVALID_HANDLE_VALUE) {

        printf("\nGetting device's Pretty Name...\n");

        pBuffer = _alloca(MAX_BUFFER);

        if (!DeviceIoControl(comFile, 
                             IOCTL_SERIAL_QUERY_DEVICE_NAME,
                             NULL,
                             0,
                             (LPVOID)pBuffer,
                             MAX_BUFFER,
                             &dwSize,
                             NULL)) 
            printf("Unable to get name: %d\n",GetLastError());
        else
            printf("\nPretty Name: %ws\n", pBuffer);   

        if (!DeviceIoControl(comFile, 
                             IOCTL_SERIAL_QUERY_DEVICE_ATTR,
                             NULL,
                             0,
                             &posFlag,
                             sizeof(ULONG),
                             &dwSize,
                             NULL)) 
            printf("Unable to get attr: %d\n",GetLastError());
        else 
            printf("\nDevice Attribute: %xh\n\n", posFlag);   

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\testmicr\testmicr.c ===
/*
 *      TESTMICR.C
 *
 *
 *		Testing MICR
 *              
 *
 */

#include <stdio.h>
#include <windows.h>

#define MAX_BUFFER                      256

void main(int argc,char *argv[])
{
    HANDLE comFile;
    char *myPort, fullFileNameBuf[40];
    DWORD dwSize;
    int i;

    if (argc != 2) {
        printf("\n USAGE: testioctl <fileName>\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    sprintf(fullFileNameBuf, "\\\\.\\%s", myPort);
    myPort = fullFileNameBuf;

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != INVALID_HANDLE_VALUE) {

        char cmds[] = "\x10\x04\x08"            // init
                      "\x1c""a0"                // read MICR
                      "\x1c""a1"                // load check
                      "\x1c""a2"                // eject check
                      "\x1c""b"                 // return check read result
                      ;

        char pBuffer[0x200];

        printf("\nSending command string...\n");

        if (!WriteFile(comFile, 
                       (LPVOID)cmds,
                       (sizeof(cmds)-1),
                       &dwSize,
                       NULL)) {
            printf("Unable to send command string: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        }

        printf("\nReading CHEQUE number...\n");

        if (!ReadFile(comFile, 
                      (LPVOID)pBuffer,
                      31,
                      &dwSize,
                      NULL)) 
            printf("Unable to get CHEQUE number: %d\n",GetLastError());

        else {

            printf("\n\n Your CHEQUE number is: ");
            for (i = 0; (i < dwSize) && (i < 31); i++){
                char ch = pBuffer[i];
                if ((ch < ' ') || (ch > '~')) {
                    printf("<%02x>", (int)ch);
                }
                printf("%c", ch);
            }
            printf("\n\n");            

        }

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n", myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\ioctl\testprop\testprop.c ===
/*
 *      TESTPROP.C
 *
 *
 *		Testing Ioctl Calls
 *              
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define SERIAL_DTR_STATE         ((ULONG)0x00000001)
#define SERIAL_RTS_STATE         ((ULONG)0x00000002)
#define IOCTL_SERIAL_GET_DTRRTS         CTL_CODE(FILE_DEVICE_SERIAL_PORT,30,METHOD_BUFFERED,FILE_ANY_ACCESS)

void main(int argc,char *argv[])
{
    HANDLE comFile;
    COMMPROP mp;
    DWORD myBaud;
    ULONG mask;
    ULONG retSize;
    char *myPort;

    if (argc != 2) {
        printf("\n USAGE: testprop <fileName> - Testing Properties\n");
        return;
    }

    myPort = argv[1];
    printf("Opening %s port...\n", myPort);

    comFile = CreateFile(myPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
					     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (comFile != ((HANDLE)-1)) {

        printf("\nVerifying %s port properties...\n", myPort);
        if (!GetCommProperties(comFile, &mp)) {
            printf("Unable to retrieve properties. Error Code: %d\n",GetLastError());
            CloseHandle(comFile);
            return;
        } 

        if (mp.wPacketLength != sizeof(COMMPROP)) 
            printf("Packet length is not sizeof(COMMPROP))\n\n",sizeof(COMMPROP));
        else
            printf("Packet length match\n");

        printf("PacketVersion: %d\n",mp.wPacketVersion);

        if (mp.dwServiceMask != SP_SERIALCOMM) 
            printf("Bad Service mask: %x\n",mp.dwServiceMask);
        else
            printf("Service Mask match\n");

        printf("MaxTxQueue: %d\n",mp.dwMaxTxQueue);
        printf("MaxRxQueue: %d\n",mp.dwMaxRxQueue);

        if(mp.dwMaxBaud != BAUD_115200)
            printf("Max Baud Rate unstable: %x\n",mp.dwMaxBaud);
        else
            printf("Max Baud Rate match\n");

        if (mp.dwProvSubType != PST_MODEM) 
            printf("Bad Subtype: %x\n",mp.dwProvSubType);
        else
            printf("Subtype match\n");

        if (mp.dwProvCapabilities != (PCF_DTRDSR        | PCF_RTSCTS
							        | PCF_SPECIALCHARS	| PCF_PARITY_CHECK
							        | PCF_TOTALTIMEOUTS | PCF_INTTIMEOUTS)) 
            printf("Bad Capabilities: %x\n",mp.dwProvCapabilities);
        else
            printf("Capabilities match\n");

        if (mp.dwSettableParams != (SP_PARITY       | SP_BAUD        | SP_DATABITS
						          | SP_STOPBITS     | SP_HANDSHAKING | SP_PARITY_CHECK 
						          | SP_RLSD)) 
            printf("Bad Settable Parameters: %x\n",mp.dwSettableParams);
        else
            printf("Settable Parameters match\n");

        myBaud = BAUD_300   | BAUD_600   | BAUD_1200 
	           | BAUD_2400  | BAUD_4800  | BAUD_9600  
	           | BAUD_19200 | BAUD_38400 | BAUD_57600 
	           | BAUD_115200;

        if (myBaud != mp.dwSettableBaud) 
            printf("Bad Settable Baud Rate: %x\n",mp.dwSettableBaud);
        else
            printf("Settable Baud Rate match\n");

        if (mp.wSettableData != (DATABITS_5 | DATABITS_6 
					           | DATABITS_7 | DATABITS_8)) 
            printf("Bad Settable Data Bits: %x\n",mp.wSettableData);
        else
            printf("Settable Data Bits match\n");

        if (mp.wSettableStopParity != (STOPBITS_10 | STOPBITS_15 | STOPBITS_20 
                                     | PARITY_NONE | PARITY_ODD  | PARITY_EVEN 
                                     | PARITY_MARK | PARITY_SPACE)) 
	        printf("Bad Settable Stop/Parity: %x\n",mp.wSettableStopParity);
        else
	        printf("Settable Stop/Parity match\n");

        printf("Current TX queue: %d\n",mp.dwCurrentTxQueue);
        printf("Current RX queue: %d\n",mp.dwCurrentRxQueue);

        printf("\nVerifying DTR and RTS signals...\n");
        if (!EscapeCommFunction(comFile, CLRDTR)) 
            printf("Unable to clear DTR\n");
        else
            printf("DTR cleared successfully\n");

        if (!EscapeCommFunction(comFile, CLRRTS)) 
            printf("Unable to clear RTS\n");
        else
            printf("RTS cleared successfully\n");

        if (!DeviceIoControl(comFile, IOCTL_SERIAL_GET_DTRRTS, NULL, 0, &mask, sizeof(mask), &retSize, NULL)) {
            printf("Unable to call the iocontrol\n");
            CloseHandle(comFile);
            return;
        }

        printf("\nVerifying clearing of bits...\n");
        if (mask & (SERIAL_DTR_STATE | SERIAL_RTS_STATE)) 
            printf("One of the bits is still set: %x\n",mask);
        else
            printf("Bits cleared successfully\n");

        CloseHandle(comFile);
    } 
    else 
        printf("Unable to open %s port. Error Code: %d\n",myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\testcshdrw\testcshdrw.c ===
/*
 *  TESTCSHDRW.C
 *
 *	
 *		Test Cash-Drawer 
 *		
 *		Uses serial COM interface exposed by posusb.sys driver
 *
 */


#include <stdio.h>
#include <windows.h>

void main(int argc, char *argv[])
{
    FILE *comFile;
    char *myPort, ch;
    char fullFileNameBuf[40];

    if (argc != 2) {
        printf("\n USAGE: testcshdrw <fileName> - Testing Cash Drawer\n");
        return;
    }

    myPort = argv[1];
    sprintf(fullFileNameBuf, "\\\\.\\%s", myPort);
    myPort = fullFileNameBuf;

    printf("Opening %s port...\n", myPort);
    comFile = fopen(myPort, "r+");

    if (comFile){

        printf("\nPort opened successfully\n");
        printf("\nAttempting to read from device...\n");

        if (!(ch = fgetc(comFile))) 
            printf("Unable to read: %d\n",GetLastError());
        else
            printf("Byte read: %xh. \n\n", ch);

        fclose(comFile);

    }
    else 
        printf("Unable to open %s port. Error Code: %d\n", myPort, GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\hidmini\hid.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    hid.c

Abstract: Human Input Device (HID) minidriver that creates an example
		device.

--*/
#include <WDM.H>
#include <USBDI.H>

#include <HIDPORT.H>
#include <HIDMINI.H>

//
//  Our descriptors.  Normally you'd have to get these from the hardware, if it
//  was truly a HID device, or you'll have to build your own for non HID devices.
//

//
//  The report descriptor completely lays out what read and write packets will look like
//  and indicates what the semantics are for each field.
//

HID_REPORT_DESCRIPTOR           MyReportDescriptor[] = {
        0x05,   0x01,       // Usage Page (Generic Desktop),
        0x09,   0x06,       // Usage (Keyboard),
        0xA1,   0x01,       // Collection (Application),
        0x05,   0x07,       //  Usage Page (Key Codes);
        0x19,   0xE0,       //  Usage Minimum (224),
        0x29,   0xE7,       //  Usage Maximum (231),
        0x15,   0x00,       //  Logical Minimum (0),
        0x25,   0x01,       //  Logical Maximum (1),
        0x75,   0x01,       //  Report Size (1),
        0x95,   0x08,       //  Report Count (8),
        0x81,   0x02,       //  Input (Data, Variable, Absolute),;Modifier byte
        0x95,   0x01,       //  Report Count (1),
        0x75,   0x08,       //  Report Size (8),
        0x81,   0x01,       //  Input (Constant),                       ;Reserved byte
        0x95,   0x05,       //  Report Count (5),
        0x75,   0x01,       //  Report Size (1),
        0x05,   0x08,       //  Usage Page (Page# for LEDs),
        0x19,   0x01,       //  Usage Minimum (1),
        0x29,   0x05,       //  Usage Maximum (5),
        0x91,   0x02,       //  Output (Data, Variable, Absolute),      ;LED report
        0x95,   0x01,       //  Report Count (1),
        0x75,   0x03,       //  Report Size (3),
        0x91,   0x01,       //  Output (Constant),                      ;LED report padding
        0x95,   0x06,       //  Report Count (6),
        0x75,   0x08,       //  Report Size (8),
        0x15,   0x00,       //  Logical Minimum (0),
        0x25,   0x65,       //  Logical Maximum(101),
        0x05,   0x07,       //  Usage Page (Key Codes),
        0x19,   0x00,       //  Usage Minimum (0),
        0x29,   0x65,       //  Usage Maximum (101),
        0x81,   0x00,       //  Input (Data, Array),                    ;Key arrays (6 bytes)
        0xC0                // End Collection
};


//
//  The HID descriptor has some basic device info and tells how long the report
//  descriptor is.
//

USB_HID_DESCRIPTOR              MyHidDescriptor = {
        0x09,   // length of HID descriptor
        0x21,   // descriptor type == HID
        0x0100, // hid spec release
        0x00,   // country code == Not Specified
        0x01,   // number of HID class descriptors
        0x22,   // report descriptor type
        sizeof(MyReportDescriptor)  // total length of report descriptor
};

//
//  This buffer has all of the strings that we define.
//

UCHAR AStringDescriptor[] = {
        4,          // length of this string
        3,          // type == STRING
        0x09, 0x00, // language code == ENGLISH
        
        44,     3,
        'M',0,  'i',0,  'c',0,  'r',0,  'o',0,  's',0,  'o',0,  'f',0,  
        't',0,  ' ',0,  'C',0,  'o',0,  'r',0,  'p',0,  'o',0,  'r',0,  
        'a',0,  't',0,  'i',0,  'o',0,  'n',0,  

        46,     3,
        'S',0,  'y',0,  's',0,  't',0,  'e',0,  'm',0,  ' ',0,  'C',0,  
        'o',0,  'n',0,  't',0,  'r',0,  'o',0,  'l',0,  ' ',0,  'B',0,  
        'u',0,  't',0,  't',0,  'o',0,  'n',0,  's',0,  

        32,     3,
        'L',0,  'e',0,  'g',0,  'a',0,  'c',0,  'y',0,  ' ',0,  'K',0,  
        'e',0,  'y',0,  'b',0,  'o',0,  'a',0,  'r',0,  'd',0,  
};

//
//  String descriptors are 

PUSB_STRING_DESCRIPTOR          MyStringDescriptor = (PUSB_STRING_DESCRIPTOR) AStringDescriptor;

//
//  No designator descriptors.
//

PUSB_PHYSICAL_DESCRIPTOR        MyPhysicalDescriptor = NULL;

//
//  IO lists
//

KSPIN_LOCK  HidMini_IrpReadLock;
KSPIN_LOCK  HidMini_IrpWriteLock;
LIST_ENTRY  HidMini_ReadIrpHead;
LIST_ENTRY  HidMini_WriteIrpHead;

BOOLEAN IsRunning = FALSE;

LONG ReadsCompleting = 0;

NTSTATUS HidMiniGetHIDDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Finds the HID descriptor and copies it into the buffer provided by the Irp.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - Pointer to Interrupt Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;
    ULONG  bytesToCopy;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetHIDDescriptor Entry\n"));

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    // Copy device descriptor to HIDCLASS buffer
    //

    DBGPrint(("'HIDMINI.SYS: HIDCLASS Buffer = 0x%x, Buffer length = 0x%x\n", Irp->UserBuffer, IrpStack->Parameters.DeviceIoControl.OutputBufferLength));

    //
    // Copy MIN (OutputBufferLength, DeviceExtension->HidDescriptor->bLength)
    //

    bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (bytesToCopy > DeviceExtension->HidDescriptor.bLength) {
        bytesToCopy = DeviceExtension->HidDescriptor.bLength;
    }

    DBGPrint(("'HIDMINI.SYS: Copying %d bytes to HIDCLASS buffer\n", bytesToCopy));

    RtlCopyMemory((PUCHAR) Irp->UserBuffer, (PUCHAR) &DeviceExtension->HidDescriptor, bytesToCopy);

    //
    // Report how many bytes were copied
    //
    Irp->IoStatus.Information = bytesToCopy;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetHIDDescriptor Exit = 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS HidMiniGetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Finds the Report descriptor and copies it into the buffer provided by the Irp.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - Pointer to Interrupt Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;
    ULONG  bytesToCopy;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetReportDescriptor Entry\n"));

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    // Copy device descriptor to HIDCLASS buffer
    //

    DBGPrint(("'HIDMINI.SYS: HIDCLASS Buffer = 0x%x, Buffer length = 0x%x\n", Irp->UserBuffer, IrpStack->Parameters.DeviceIoControl.OutputBufferLength));

    //
    // Copy MIN (OutputBufferLength, DeviceExtension->HidDescriptor->bLength)
    //

    bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (bytesToCopy > DeviceExtension->HidDescriptor.wReportLength) {
        bytesToCopy = DeviceExtension->HidDescriptor.wReportLength;
    }

    DBGPrint(("'HIDMINI.SYS: Copying %d bytes to HIDCLASS buffer\n", bytesToCopy));

    RtlCopyMemory((PUCHAR) Irp->UserBuffer, (PUCHAR) DeviceExtension->ReportDescriptor, bytesToCopy);

    //
    // Report how many bytes were copied
    //
    Irp->IoStatus.Information = bytesToCopy;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetReportDescriptor Exit = 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS HidMiniGetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Fill in the given struct _HID_DEVICE_ATTRIBUTES

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PHID_DEVICE_ATTRIBUTES deviceAttributes;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetDeviceAttributes Entry\n"));

    //
    // Get a pointer to the current location in the Irp
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    deviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

    ASSERT (sizeof (HID_DEVICE_ATTRIBUTES) ==
            irpStack->Parameters.DeviceIoControl.OutputBufferLength);


    //
    // Report how many bytes were copied
    //
    Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

    deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);
    deviceAttributes->VendorID = HIDMINI_VID;
    deviceAttributes->ProductID = HIDMINI_PID;
    deviceAttributes->VersionNumber = HIDMINI_VERSION;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetAttributes Exit = 0x%x\n", ntStatus));

    return ntStatus;
}

VOID HidMiniIncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

    Increments the number of outstanding requests on the DeviceObject with this extension.

Arguments:

    DeviceExtension - the mini driver extension area of the device that is being made busy.

Return Value:

    VOID.

--*/
{
    DeviceExtension->NumPendingRequests++;
    DBGPrint(("'HIDMINI.SYS: Bumping requests on device extension 0x%08x up to %d\n",
              DeviceExtension,
              DeviceExtension->NumPendingRequests));
}



VOID HidMiniDecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

    Decrements the number of outstanding requests on the DeviceObject with this extension.
    If we get to zero outstanding IOs, set the device's all requests complete event.

Arguments:

    DeviceExtension - the mini driver extension area of the device that is being made busy.

Return Value:

    VOID.

--*/
{
    ASSERT( DeviceExtension->NumPendingRequests > 0 );
    DeviceExtension->NumPendingRequests--;

    DBGPrint(("'HIDMINI.SYS: Bumping requests on device extension 0x%08x down to %d\n",
              DeviceExtension,
              DeviceExtension->NumPendingRequests));

    if( DeviceExtension->NumPendingRequests == 0 &&
        DeviceExtension->DeviceState != DEVICE_STATE_RUNNING ){

        //
        // The device state is stopping, and the last outstanding request
        // has just completed.
        //

        DBGPrint(("'HIDMINI.SYS: last request completed, signalling event\n"));
        KeSetEvent( &DeviceExtension->AllRequestsCompleteEvent,
                    0, FALSE );
    }
}




NTSTATUS HidMiniReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Process a read HID packet request.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - Pointer to Interrupt Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID ReportBuffer;
    ULONG ReportTotalSize;
    PNODE Node;

    DBGPrint(("'HIDMINI.SYS: HidMiniReadReport Enter\n"));

    DBGPrint(("'HIDMINI.SYS: DeviceObject = 0x%x\n", DeviceObject));

    //
    // Get a pointer to the device extension.
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = 0x%x\n", DeviceExtension));

    //
    // Get Stack location
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    //  Get the buffer and its size, make sure they're valid.
    //
    
    ReportBuffer = Irp->UserBuffer;
    ReportTotalSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    DBGPrint(("'HIDMINI.SYS: ReportBuffer = 0x%x, ReportTotalSize = 0x%x\n", ReportBuffer, ReportTotalSize));

    if (IsRunning) {
        if (ReportTotalSize && ReportBuffer){
            Node = (PNODE)ExAllocatePool(NonPagedPool, sizeof(NODE));
            if (Node) {

                //
                //  Increase the count of outstanding IOs, mark the Irp pending.
                //
                HidMiniIncrementPendingRequestCount(DeviceExtension);
                IoMarkIrpPending(Irp);

                //
                //  Hook the Irp onto the pending IO list
                //
                Node->Irp = Irp;
                ExInterlockedInsertTailList(&HidMini_ReadIrpHead, &Node->List, &HidMini_IrpReadLock);
                ntStatus = STATUS_PENDING;

            } else {
                ntStatus = STATUS_NO_MEMORY;
            }
        } else {
        
            //
            // No buffer, or buffer of zero size
            //
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    } else {
        //
        //  We're shutting down
        //
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    DBGPrint(("'HIDMINI.SYS: HidMiniReadReport Exit = 0x%x\n", ntStatus));

    return ntStatus;
}

NTSTATUS HidMiniReadCompletion(PVOID Context)
/*++

Routine Description:

    HID read packet completion routine.

Arguments:

Return Value:

   STATUS_SUCCESS, STATUS_UNSUCCESSFUL.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG bytesRead;
    PDEVICE_EXTENSION deviceExtension;
    PNODE IrpNode;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;

    //
    //  ReadBuffer is a list of keyboard reports that can be transmitted as a
    //  result for a read request.
    //

    static int ReadIndex = 0;
    static int Rest = 0;
    
    static UCHAR *ReadBuffer[] = {
        "\x02\x00\x0D\0\0\0\0\0",   // J
        "\x00\x00\x04\0\0\0\0\0",   // a
        "\x00\x00\x06\0\0\0\0\0",   // c
        "\x00\x00\x0E\0\0\0\0\0",   // k
        "\x00\x00\x07\0\0\0\0\0",   // d
        "\x00\x00\x04\0\0\0\0\0",   // a
        "\x00\x00\x1A\0\0\0\0\0",   // w
        "\x00\x00\x16\0\0\0\0\0",   // s
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x0F\0\0\0\0\0",   // l
        "\x00\x00\x12\0\0\0\0\0",   // o
        "\x00\x00\x19\0\0\0\0\0",   // v
        "\x00\x00\x08\0\0\0\0\0",   // e
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x10\0\0\0\0\0",   // m
        "\x00\x00\x1C\0\0\0\0\0",   // y
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x05\0\0\0\0\0",   // b
        "\x00\x00\x0C\0\0\0\0\0",   // i
        "\x00\x00\x0A\0\0\0\0\0",   // g
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x16\0\0\0\0\0",   // s
        "\x00\x00\x13\0\0\0\0\0",   // p
        "\x00\x00\x0B\0\0\0\0\0",   // h
        "\x00\x00\x1C\0\0\0\0\0",   // y
        "\x00\x00\x11\0\0\0\0\0",   // n
        "\x00\x00\x1B\0\0\0\0\0",   // x
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x12\0\0\0\0\0",   // o
        "\x00\x00\x09\0\0\0\0\0",   // f
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x14\0\0\0\0\0",   // q
        "\x00\x00\x18\0\0\0\0\0",   // u
        "\x00\x00\x04\0\0\0\0\0",   // a
        "\x00\x00\x15\0\0\0\0\0",   // r
        "\x00\x00\x17\0\0\0\0\0",   // t
        "\x00\x00\x1D\0\0\0\0\0",   // z
        "\x00\x00\x37\0\0\0\0\0",   // .
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        "\x00\x00\x2C\0\0\0\0\0",   // <space>
        NULL,
    };

    DBGPrint(("'HIDMINI.SYS: HidMiniReadCompletion Enter\n"));

    //
    //  Free workitem that started us, check to see if we're already completing reads
    //

    ExFreePool((PWORK_QUEUE_ITEM)Context);

    ASSERT(ReadsCompleting > 0);
    if (InterlockedDecrement(&ReadsCompleting)) {
        return STATUS_SUCCESS;
    }
    
    //
    //  Loop around completing Irps.  When we run out, break 
    //  out of the loop.
    //
    while (IsRunning) {

        //
        //  Make sure we don't overrun our list of replies.  If we get to the end of it, 
        //  we'll exit this loop early and let the IRPs queue up again.
        //
        if (!ReadBuffer[ReadIndex]) {
            ReadIndex = 0;
        }
        
        //
        //  Any Irps to complete?
        //
        IrpNode = (PNODE)ExInterlockedRemoveHeadList(&HidMini_ReadIrpHead, &HidMini_IrpReadLock);
        
        if (IrpNode) {

            //
            //  Find all the pieces
            //
            Irp = IrpNode->Irp;

            IrpStack = IoGetCurrentIrpStackLocation(Irp);

            DeviceObject = IrpStack->DeviceObject;
            
            deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

            HidMiniDecrementPendingRequestCount( deviceExtension );

            //
            // Get the bytes read and store in the status block
            //

            bytesRead = 8;

            if (bytesRead > IrpStack->Parameters.DeviceIoControl.OutputBufferLength) {
                bytesRead = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            }

            if (Rest) {
                RtlCopyMemory((PUCHAR) Irp->UserBuffer, "\x00\x00\0\0\0\0\0\0", bytesRead);
            } else {
                RtlCopyMemory((PUCHAR) Irp->UserBuffer, (PUCHAR)ReadBuffer[ReadIndex++], bytesRead);
            }

            Rest ^= 1;

            Irp->IoStatus.Information = bytesRead;
            
            Irp->IoStatus.Status = STATUS_SUCCESS;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            DBGPrint(("'HIDMINI.SYS: Read report DeviceObject (%x) completed, %d bytes!\n",
                                   DeviceObject, bytesRead ));

            //
            //  Free up the Node
            //
            ExFreePool(IrpNode);

            if (!Rest) {
                break;
            }

        } else {

            //
            //  No Irps
            //
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS HidMiniWriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Process a write HID packet request.  This is also how we start up the read 
    completion process.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - Pointer to Interrupt Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    PNODE Node;
    PWORK_QUEUE_ITEM StartCompletingReads;

    DBGPrint(("'HIDMINI.SYS: HidMiniWriteReport Enter\n"));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (IsRunning) {

        Node = (PNODE)ExAllocatePool(NonPagedPool, sizeof(NODE));
        StartCompletingReads = (PWORK_QUEUE_ITEM)
                    ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));

        if (Node && StartCompletingReads) {

            //
            //  Queue up a work item to start completing reads.
            //

            ASSERT(ReadsCompleting >= 0);
            InterlockedIncrement(&ReadsCompleting);
            
            ExInitializeWorkItem(StartCompletingReads, 
                                HidMiniReadCompletion, 
                                (PVOID)StartCompletingReads);
            ExQueueWorkItem(StartCompletingReads, DelayedWorkQueue);
            
            //
            //  Increase the count of outstanding IOs, mark the Irp pending.
            //
            HidMiniIncrementPendingRequestCount(DeviceExtension);
            IoMarkIrpPending(Irp);

            //
            //  Hook the Irp onto the pending IO list
            //
            Node->Irp = Irp;
            ExInterlockedInsertTailList(&HidMini_WriteIrpHead, &Node->List, &HidMini_IrpWriteLock);
            ntStatus = STATUS_PENDING;

            //
            //  Give the write completion code a kick
            //
            HidMiniWriteCompletion();

        } else {
            ntStatus = STATUS_NO_MEMORY;
        }
    } else {
        //
        //  We're shutting down
        //
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }
    DBGPrint(("'HIDMINI.SYS: HidMiniWriteReport Exit = 0x%x\n", ntStatus));

    return ntStatus;
}

NTSTATUS HidMiniWriteCompletion(VOID)
/*++

Routine Description:

    Complete processing a write HID packet request.

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION deviceExtension;
    PNODE IrpNode;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;

    //
    //  Loop around completing Irps.  When we run out, break 
    //  out of the loop.
    //
    while (IsRunning) {

        //
        //  Any Irps to complete?
        //
        IrpNode = (PNODE)ExInterlockedRemoveHeadList(&HidMini_WriteIrpHead, &HidMini_IrpWriteLock);
        
        if (IrpNode) {

            //
            //  Find all the pieces
            //
            Irp = IrpNode->Irp;
            IrpStack = IoGetCurrentIrpStackLocation(Irp);
            DeviceObject = IrpStack->DeviceObject;
            deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

            //
            //  Do something here...
            //

            //
            //  Finish off the IRP
            //
            HidMiniDecrementPendingRequestCount( deviceExtension );
            Irp->IoStatus.Status = STATUS_SUCCESS;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            DBGPrint(("'HIDMINI.SYS: Write report DeviceObject (%x) completed\n", DeviceObject));

            //
            //  Free up the Node
            //
            ExFreePool(IrpNode);

        } else {

            //
            //  No Irps
            //
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS HidMiniGetStringDescriptor( IN PDEVICE_OBJECT DeviceObject, 
                                      IN PIRP Irp)
/*++

Routine Description:

    Get the device string descriptor, if any.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - Pointer to Interrupt Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    ULONG  bytesToCopy;

    DBGPrint(("'HIDMINI.SYS: HidMiniGetStringDescriptor Enter\n"));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    //  Get the buffer size to write into
    //
    bytesToCopy = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    //  Make sure we have a buffer and it has some space
    //
    if (Irp->UserBuffer && bytesToCopy){

        //
        //  Adjust the size to the amount we have to write
        //
        
        if (bytesToCopy > sizeof(AStringDescriptor)) {
            bytesToCopy = sizeof(AStringDescriptor);
        }

        DBGPrint(("'HIDMINI.SYS: Copying %d bytes to STRING buffer\n", bytesToCopy));

        RtlCopyMemory((PUCHAR) Irp->UserBuffer, (PUCHAR) DeviceExtension->StringDescriptor, bytesToCopy);

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = bytesToCopy;
        
    } else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPrint(("'HIDMINI.SYS: HidMiniGetStringDescriptor Exit = 0x%x\n", ntStatus));

    return ntStatus;
}

NTSTATUS HidMiniOpenCollection(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)

/*++

Routine Description:

    Called when a HIDCLASS client opens this collection

Arguments:

   DeviceObject - Pointer to class device object.

   IrpStack     - Pointer to Interrupt Request Packet.


Return Value:

   STATUS_SUCCESS, STATUS_PENDING.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBGPrint(("'HIDMINI.SYS: HidMiniOpenCollection Enter\n"));

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPrint(("'HIDMINI.SYS: HidMiniOpenCollection Exit = 0x%x\n", ntStatus));

    return ntStatus;
}




NTSTATUS HidMiniCloseCollection(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)

/*++

Routine Description:

    Called when a HIDCLASS client closes this collection

Arguments:

   DeviceObject - Pointer to class device object.

   IrpStack     - Pointer to Interrupt Request Packet.


Return Value:

   STATUS_SUCCESS, STATUS_PENDING.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBGPrint(("'HIDMINI.SYS: HidMiniCloseCollection Enter\n"));

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPrint(("'HIDMINI.SYS: HidMiniCloseCollection Exit = 0x%x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\opos\test\winprn1\winprn1.c ===
#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>



void PutMsg(LPSTR msg)
{
    // MessageBox(NULL, msg, "WinPrn1 (POS test) message", MB_OK);
}
 

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE prevInst, LPSTR cmdLine, int showCmd)
{
    HANDLE hFile;
    char fileName[40] = "\\\\.\\????";
    char data[40];
    int dataLen, i, j;

    PutMsg(cmdLine);    // BUGBUG REMOVE

    for (i = 0; cmdLine[i] && !isspace(cmdLine[i]); i++){
        fileName[4+i] = cmdLine[i];
    }
    fileName[4+i] = '\0';

    PutMsg((LPSTR)fileName);    // BUGBUG REMOVE

    while (isspace(cmdLine[i])){
        i++;
    }

    for (j = 0; cmdLine[i] && !isspace(cmdLine[i]); i++, j++){
        data[j] = cmdLine[i];
    }
    data[j] = '\n';
    data[j+1] = '\0';
    dataLen = j+1;

    PutMsg((LPSTR)data);    // BUGBUG REMOVE

    hFile = CreateFile( (LPSTR)fileName, 
                        GENERIC_WRITE, 
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, 
                        (HANDLE)0);
    if (hFile == INVALID_HANDLE_VALUE){
        PutMsg("CreateFile failed");
    }
    else {
        BOOL success;
        DWORD bytesWritten;

        success = WriteFile(    hFile, 
                                (LPSTR)data, 
                                dataLen, 
                                &bytesWritten, 
                                NULL); 
        if (success){
            if (bytesWritten == dataLen){
                PutMsg("Write succeeded");
            }
            else {
                PutMsg("bytesWritten != dataLen");
            }
        }
        else {
            PutMsg("WriteFile failed");
        }

        CloseHandle(hFile);
    }


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\hidmini\hidmini.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    hidmini.c

Abstract: Human Input Device (HID) minidriver that creates an example
		device.

--*/
#include <WDM.H>
#include <USBDI.H>

#include <HIDPORT.H>
#include <HIDMINI.H>


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION HidMinidriverRegistration;

    DBGPrint(("'HIDMINI.SYS: DriverEntry Enter\n"));

    DBGPrint(("'HIDMINI.SYS: DriverObject (%lx)\n", DriverObject));

    //
    // Create dispatch points
    //
    // All of the other dispatch routines are handled by HIDCLASS, except for 
    // IRP_MJ_POWER, which isn't implemented yet.
    //

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HidMiniIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HidMiniPnP;
    DriverObject->DriverExtension->AddDevice                    = HidMiniAddDevice;
    DriverObject->DriverUnload                                  = HidMiniUnload;

    //
    // Register Sample layer with HIDCLASS.SYS module
    //

    HidMinidriverRegistration.Revision              = HID_REVISION;
    HidMinidriverRegistration.DriverObject          = DriverObject;
    HidMinidriverRegistration.RegistryPath          = registryPath;
    HidMinidriverRegistration.DeviceExtensionSize   = sizeof(DEVICE_EXTENSION);

    //  HIDMINI does not need to be polled.
    HidMinidriverRegistration.DevicesArePolled      = FALSE;

    DBGPrint(("'HIDMINI.SYS: DeviceExtensionSize = %x\n", HidMinidriverRegistration.DeviceExtensionSize));

    DBGPrint(("'HIDMINI.SYS: Registering with HIDCLASS.SYS\n"));

    //
    // After registering with HIDCLASS, it takes over control of the device, and sends
    // things our way if they need device specific processing.
    //
    ntStatus = HidRegisterMinidriver(&HidMinidriverRegistration);

    DBGPrint(("'HIDMINI.SYS: DriverEntry Exit = %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
HidMiniAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process AddDevice.  Provides the opportunity to initialize the DeviceObject or the
    DriverObject.

Arguments:

    DriverObject - pointer to the driver object.
    
    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension;

    DBGPrint(("'HIDMINI.SYS: HidMiniAddDevice Entry\n"));

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

    KeInitializeEvent( &deviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE );

    DBGPrint(("'HIDMINI.SYS: HidMiniAddDevice Exit = %x\n", ntStatus));

    return ntStatus;
}



VOID
HidMiniUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc. in anticipation of this driver being unloaded.

Arguments:

    DriverObject - pointer to the driver object.

Return Value:

    VOID.

--*/
{
    DBGPrint(("'HIDMINI.SYS: HidMiniUnload Enter\n"));

    DBGPrint(("'HIDMINI.SYS: Unloading DriverObject = %x\n", DriverObject));

    DBGPrint(("'HIDMINI.SYS: Unloading Exit = VOID\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\hidmini\hidmini.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    hidmini.h

--*/
#ifndef __HIDMINI_H__
#define __HIDMINI_H__

#include <usb100.h>
#include <hidusage.h>

//
//  Declarations of HID descriptor formats
//

#include <PSHPACK1.H>

typedef struct _USB_HID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;
    UCHAR   bReportType;
    USHORT  wReportLength;

} USB_HID_DESCRIPTOR, * PUSB_HID_DESCRIPTOR;

typedef struct _USB_PHYSICAL_DESCRIPTOR
{
    UCHAR   bNumber;
    USHORT  wLength;

} USB_PHYSICAL_DESCRIPTOR, * PUSB_PHYSICAL_DESCRIPTOR;

typedef UCHAR HID_REPORT_DESCRIPTOR, *PHID_REPORT_DESCRIPTOR;

#include <POPPACK.H>


//
//  Device Extension
//
//  This data structure is hooked onto HIDCLASS' device extension, so both drivers can
//  have their own private data on each device object.
//

typedef struct _DEVICE_EXTENSION
{
    ULONG                           DeviceState;

    USB_HID_DESCRIPTOR              HidDescriptor;
    PHID_REPORT_DESCRIPTOR          ReportDescriptor;
    PUSB_STRING_DESCRIPTOR          StringDescriptor;
    PUSB_PHYSICAL_DESCRIPTOR        PhysicalDescriptor;

    ULONG                           NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5

//
// Device Extension Macros
//

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

//
// Built In descriptors for this device
//

HID_REPORT_DESCRIPTOR           MyReportDescriptor[];
USB_HID_DESCRIPTOR              MyHidDescriptor;
PUSB_STRING_DESCRIPTOR          MyStringDescriptor;
PUSB_PHYSICAL_DESCRIPTOR        MyPhysicalDescriptor;

#define HIDMINI_PID              0xFEED
#define HIDMINI_VID              0xBEEF
#define HIDMINI_VERSION          0x0101

//
//  IO lists
//

extern KSPIN_LOCK   HidMini_IrpReadLock;
extern KSPIN_LOCK   HidMini_IrpWriteLock;
extern LIST_ENTRY   HidMini_ReadIrpHead;
extern LIST_ENTRY   HidMini_WriteIrpHead;

typedef struct {
    LIST_ENTRY  List;
    union {
        PIRP    Irp;
    };
} NODE, *PNODE;

extern BOOLEAN IsRunning;

//
// Turn on debug printing and breaking, if appropriate
//

#if DBG
#define DBGPrint(arg) DbgPrint arg
#define DBGBREAK DbgBreakPoint()
#else
#define DBGPrint(arg)
#define DBGBREAK
#endif

//
// Function prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS
HidMiniAbortPendingRequests(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidMiniCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
HidMiniCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
HidMiniAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

NTSTATUS
HidMiniStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidMiniStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
HidMiniInitDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidMiniStopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidMiniStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
HidMiniQueryIDCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
HidMiniRemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

VOID
HidMiniUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
HidMiniGetHIDDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS 
HidMiniGetDeviceAttributes(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );
    
NTSTATUS
HidMiniGetReportDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniGetStringDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniReadReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniReadCompletion(
    PVOID Context
    );

NTSTATUS
HidMiniWriteReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniWriteCompletion(
    VOID
    );

NTSTATUS
HidMiniGetString(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniOpenCollection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidMiniCloseCollection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
HidMiniIncrementPendingRequestCount(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
HidMiniDecrementPendingRequestCount(
    IN PDEVICE_EXTENSION DeviceExtension
    );

#endif // _HIDMINI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\hidmini\ioctl.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver that creates an example
		device.

--*/
#include <WDM.H>
#include <USBDI.H>

#include <HIDPORT.H>
#include <HIDMINI.H>


NTSTATUS
HidMiniIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Control IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;


    DBGPrint(("'HIDMINI.SYS: HidMiniIoctl Enter\n"));

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    switch(IrpStack->Parameters.DeviceIoControl.IoControlCode)
    {

        case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
                //
                //  Return the HID descriptor
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_GET_DEVICE_DESCRIPTOR\n"));
            ntStatus = HidMiniGetHIDDescriptor (DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_REPORT_DESCRIPTOR:
                //
                //  Return the Report descriptor
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_GET_REPORT_DESCRIPTOR\n"));
            ntStatus = HidMiniGetReportDescriptor (DeviceObject, Irp);
            break;

        case IOCTL_HID_READ_REPORT:
                //
                //  Perform a read
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_READ_REPORT\n"));
            ntStatus = HidMiniReadReport (DeviceObject, Irp);
            break;

        case IOCTL_HID_WRITE_REPORT:
                //
                //  Perform a write
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_WRITE_REPORT\n"));
            ntStatus = HidMiniWriteReport (DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_STRING:
                //
                //  Get the friendly name for the device
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_GET_STRING\n"));
            ntStatus = HidMiniGetStringDescriptor(DeviceObject, Irp);
            break;

        case IOCTL_HID_OPEN_COLLECTION:
                //
                //  Notification that a client is opening a top level collection
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_OPEN_COLLECTION\n"));
            ntStatus = HidMiniOpenCollection (DeviceObject, Irp);
            break;

        case IOCTL_HID_CLOSE_COLLECTION:
                //
                //  Notification that a client is closing a top level collection
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_CLOSE_COLLECTION\n"));
            ntStatus = HidMiniCloseCollection (DeviceObject, Irp);
            break;

        case IOCTL_HID_ACTIVATE_DEVICE:
                //
                //  Notification of first open of a device
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_ACTIVATE_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;

        case IOCTL_HID_DEACTIVATE_DEVICE:
                //
                //  Notification of last close of a device
                //
                
            DBGPrint(("'HIDMINI.SYS: IOCTL_HID_DEACTIVATE_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;

        case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
            DBGPrint(("'HIDMINI.SYS: IOCTL_GET_DEVICE_ATTRIBUTES\n"));
            ntStatus = HidMiniGetDeviceAttributes(DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_FEATURE:
        case IOCTL_HID_SET_FEATURE:
        case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        default:
            DBGPrint(("'HIDMINI.SYS: Unknown or unsupported IOCTL (%x)\n", IrpStack->Parameters.DeviceIoControl.IoControlCode));
            ntStatus = STATUS_NOT_SUPPORTED;
            break;
        
    }         


    //
    // Set real return status in Irp
    //

    Irp->IoStatus.Status = ntStatus;
    
    //
    // Complete Irp
    //

    if (ntStatus != STATUS_PENDING) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // NOTE: Real return status set in Irp->IoStatus.Status
        //

        ntStatus = STATUS_SUCCESS;

    } else {
        IoMarkIrpPending( Irp );
    }
    
    DBGPrint(("'HIDMINI.SYS: HidMiniIoctl Exit = %x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\hidmini\pnp.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    pnp.c

Abstract: Human Input Device (HID) minidriver that creates an example
		device.

--*/
#include <WDM.H>
#include <USBDI.H>

#include <HIDPORT.H>
#include <HIDMINI.H>


NTSTATUS
HidMiniPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the PnP IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION IrpStack;
    PIO_STACK_LOCATION NextStack;
    PDEVICE_EXTENSION DeviceExtension;

    DBGPrint(("'HIDMINI.SYS: HidMiniPlugnPlay Enter\n"));

    DBGPrint(("'HIDMINI.SYS: DeviceObject = %x\n", DeviceObject));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    DBGPrint(("'HIDMINI.SYS: IoGetCurrentIrpStackLocation (Irp) = %x\n", IrpStack));

    switch(IrpStack->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            DBGPrint(("'HIDMINI.SYS: IRP_MN_START_DEVICE\n"));

            ntStatus = HidMiniStartDevice(DeviceObject);

            break;

        case IRP_MN_STOP_DEVICE:
            DBGPrint(("'HIDMINI.SYS: IRP_MN_STOP_DEVICE\n"));

            ntStatus = HidMiniStopDevice(DeviceObject);

            break;

        case IRP_MN_REMOVE_DEVICE:
            DBGPrint(("'HIDMINI.SYS: IRP_MN_REMOVE_DEVICE\n"));

            ntStatus = HidMiniRemoveDevice(DeviceObject);

            break;

		case IRP_MN_QUERY_ID:
            DBGPrint(("'HIDMINI.SYS: IRP_MN_QUERY_ID\n"));

            (PWCHAR)Irp->IoStatus.Information = NULL;
            ntStatus = STATUS_SUCCESS;

            break;
          
        default:
            ntStatus = STATUS_SUCCESS;
            DBGPrint(("'HIDMINI.SYS: Unknown PNP IRP Parameter (%lx)\n", IrpStack->MinorFunction));
    }

    //
    // Set the status of the Irp
    //

    Irp->IoStatus.Status = ntStatus;

    if (NT_SUCCESS(ntStatus)) {

        //
        // Set next stack location
        //

        NextStack = IoGetNextIrpStackLocation(Irp);

        ASSERT(NextStack != NULL);

        //
        // Copy the Irp to the next stack location
        //

        RtlCopyMemory(NextStack, IrpStack, sizeof(IO_STACK_LOCATION));
        
        IoMarkIrpPending(Irp);

        //
        // Set our own completion routine or disable completion
        // routine of caller
        //

        switch(IrpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                IoSetCompletionRoutine( Irp,
                                    HidMiniStartCompletion,
                                    DeviceExtension,            // reference data
                                    TRUE,                       // call on success
                                    TRUE,                       // call on failure
                                    TRUE );                     // call on cancel
                break;

            case IRP_MN_STOP_DEVICE:
                IoSetCompletionRoutine( Irp,
                                    HidMiniStopCompletion,
                                    DeviceExtension,            // reference data
                                    TRUE,                       // call on success
                                    TRUE,                       // call on failure
                                    TRUE );                     // call on cancel
                break;
                
    		case IRP_MN_QUERY_ID:
                IoSetCompletionRoutine( Irp,
                                    HidMiniQueryIDCompletion,
                                    DeviceExtension,            // reference data
                                    TRUE,                       // call on success
                                    TRUE,                       // call on failure
                                    TRUE );                     // call on cancel
                break;
                
            default:
                NextStack->Control = 0;
                break;
        }

        //
        // Pass it down to the Next Device Object
        //

        DBGPrint(("'HIDMINI.SYS: Passing PnP Irp down to next object\n"));

        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);   

    } else {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // NOTE: Real status returned in Irp->IoStatus.Status 
        //

        ntStatus = STATUS_SUCCESS;
    }

    DBGPrint(("'HIDMINI.SYS: HidMiniPlugnPlay Exit = %x\n", ntStatus));

    return ntStatus;
}

NTSTATUS
HidMiniStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Begins initialization a given instance of a HID device.  Work done here occurs before
    the parent node gets to do anything.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR DeviceDesc = NULL;

    DBGPrint(("'HIDMINI.SYS: HidMiniStartDevice Enter\n"));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    //
    // Start the device
    //

    DeviceExtension->DeviceState = DEVICE_STATE_STARTING; 

    ntStatus = STATUS_SUCCESS;

    DBGPrint(("'HIDMINI.SYS: HidMiniStartDevice Exit = %x\n", ntStatus));

    return ntStatus;
}
                  
NTSTATUS
HidMiniStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    Completes initialization a given instance of a HID device.  Work done here occurs
    after the parent node has done its StartDevice.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR DeviceDesc = NULL;

    DBGPrint(("'HIDMINI.SYS: HidMiniStartCompletion Enter\n"));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    ntStatus = Irp->IoStatus.Status;

    if(NT_SUCCESS(ntStatus)) {
        DeviceExtension->DeviceState = DEVICE_STATE_RUNNING; 
        IsRunning = TRUE;
        
        DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) was started!\n", DeviceObject));

        ntStatus = HidMiniInitDevice(DeviceObject);

        if(NT_SUCCESS(ntStatus)) {
            DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) was configured!\n", DeviceObject));
        } else {
            DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) configuration failed!\n", DeviceObject));
            DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;
            IsRunning = FALSE;
        }


    } else {
        //
        // The PnP call failed!
        //

        DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;
        IsRunning = FALSE;

        DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) failed to start!\n", DeviceObject));
    }

    DBGPrint(("'HIDMINI.SYS: HidMiniStartCompletion Exit = %x\n", ntStatus));

    return ntStatus;
}




NTSTATUS
HidMiniInitDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Get the device information and attempt to initialize a configuration
    for a device.  If we cannot identify this as a valid HID device or
    configure the device, our start device function is failed.

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;

    DBGPrint(("'HIDMINI.SYS: HidMiniInitDevice Entry\n"));   

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    // Get config, hid, etc. descriptors
    //

    DeviceExtension->HidDescriptor      = MyHidDescriptor;
    DeviceExtension->StringDescriptor   = MyStringDescriptor;
    DeviceExtension->PhysicalDescriptor = MyPhysicalDescriptor;
    DeviceExtension->ReportDescriptor   = MyReportDescriptor;

    InitializeListHead(&HidMini_ReadIrpHead);
    InitializeListHead(&HidMini_WriteIrpHead);

    DBGPrint(("'HIDMINI.SYS: HidMiniInitDevice Exit = 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
HidMiniStopDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs before the parent
    does its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;

    DBGPrint(("'HIDMINI.SYS: HidMiniStopDevice Enter\n"));   

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;
    IsRunning = FALSE;

    //
    // Stop the device
    //

    //
    // Perform a synchronous abort of all pending requests for this
    // device.
    //

    HidMiniAbortPendingRequests( DeviceObject );

    DBGPrint(("'HIDMINI.SYS: HidMiniStopDevice = %x\n", ntStatus));

    return ntStatus;
}

NTSTATUS
HidMiniAbortPendingRequests(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PNODE Node;
    
    //
    //  Dispose of any Irps, free up all the NODEs waiting in the queues.
    //

    while ((Node = (PNODE)ExInterlockedRemoveHeadList(&HidMini_ReadIrpHead, &HidMini_IrpReadLock))) {
        Node->Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Node->Irp, IO_NO_INCREMENT);
        ExFreePool(Node);
    }
        
    return STATUS_SUCCESS;
}

NTSTATUS
HidMiniStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs after the parent
    has done its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR DeviceDesc = NULL;

    DBGPrint(("'HIDMINI.SYS: HidMiniStopCompletion Enter\n"));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus)) {
        
        DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) was stopped!\n", DeviceObject));

    } else {
        //
        // The PnP call failed!
        //

        DBGPrint(("'HIDMINI.SYS: DeviceObject (%x) failed to stop!\n", DeviceObject));
    }

    DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;
    IsRunning = FALSE;

    DBGPrint(("'HIDMINI.SYS: HidMiniStopCompletion Exit = %x\n", ntStatus));

    return ntStatus;
}



NTSTATUS
HidMiniQueryIDCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Fills in a dummy ID

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;

    DBGPrint(("'HIDMINI.SYS: HidMiniQueryIDCompletion Enter\n"));

    //
    //  If this wasn't filled in below us, fill it in with a dummy value
    //
    
    if ((PWCHAR)Irp->IoStatus.Information == NULL) {

        //
        //  Here's the dummy value, allocate a buffer to copy it to.
        //
        static WCHAR MyBusID[] = L"HIDMINI_Device\0";
        
        PWCHAR Buffer = (PWCHAR)ExAllocatePool(NonPagedPool, sizeof(MyBusID));

        if (Buffer) {

            //
            //  Do the copy, store the buffer in the Irp
            //
            RtlCopyMemory(Buffer, MyBusID, sizeof(MyBusID));
            Irp->IoStatus.Information = (ULONG)Buffer;
            ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {

            //
            //  No memory
            //
            ntStatus = Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {

        //
        // Return with whatever we got below us.
        //
        ntStatus = Irp->IoStatus.Status;
    }
    
    DBGPrint(("'HIDMINI.SYS: HidMiniQueryIDCompletion Exit = %x\n", ntStatus));

    return ntStatus;
}

    
NTSTATUS
HidMiniRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes a given instance of a device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;


    DBGPrint(("'HIDMINI.SYS: HidMiniRemoveDevice Enter\n"));   

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPrint(("'HIDMINI.SYS: DeviceExtension = %x\n", DeviceExtension));

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_REMOVING;
    IsRunning = FALSE;

    //
    // Cancel any outstanding IRPs if the device was running
    //

    if(oldDeviceState == DEVICE_STATE_RUNNING)
    {
        ntStatus = HidMiniAbortPendingRequests( DeviceObject );

        DBGPrint(("'HIDMINI.SYS: HidMiniAbortPendingRequests() = %x\n", ntStatus));

    } else {

        ASSERT( DeviceExtension->NumPendingRequests == 0 );
    }

    ntStatus = STATUS_SUCCESS;

    DBGPrint(("'HIDSAMHIDMINI.SYS: HidMiniRemoveDevice = %x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hidexe.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user more client sample driver.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include "hidsdi.h"
#include "setupapi.h"


#define DIGCF_FUNCTION  0x00000010
#define DIOD_FUNCTION   0x00000008
#define DIREG_FUNCTION  0x00000008

#define malloc(size) LocalAlloc (LPTR, size)

typedef struct _SP_FNCLASS_DEVICE_DATA {
   DWORD cbSize;
   GUID  FunctionClassGuid;
   TCHAR DevicePath [ANYSIZE_ARRAY];
} SP_FNCLASS_DEVICE_DATA, *PSP_FNCLASS_DEVICE_DATA;

BOOLEAN
SetupDiGetFunctionClassDeviceInfo (
   IN    HDEVINFO                DeviceInfoSet,
   IN    PSP_DEVINFO_DATA        DeviceInfoData,
   OUT   PSP_FNCLASS_DEVICE_DATA FunctionClassDeviceData,
   IN    DWORD                   FunctionClassDeviceDataSize,
   OUT   PDWORD                  RequiredSize
   );

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage; // The usage page for which we are looking.
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages; // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.
   HIDD_ATTRIBUTES      Attributes;

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;

} HID_DEVICE, *PHID_DEVICE;



BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
CloseHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\assert.c ===
/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

#include "map.h"

#ifdef DEBUG

#include <stdarg.h>

/*****************************************************************************
 *
 *	SquirtSqflPtszV
 *
 *	Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (sqfl == 0 || (sqfl & sqflCur)) {
	va_list ap;
	TCHAR tsz[1024];
	va_start(ap, ptsz);
	wvsprintf(tsz, ptsz, ap);
	va_end(ap);
	OutputDebugString(tsz);
	OutputDebugString(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *	AssertPtszPtszLn
 *
 *	Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
		    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	ArgsPszV
 *
 *	Collect arguments to a procedure.
 *
 *	psz -> ASCIIZ format string
 *	... = argument list
 *
 *	The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
	PPV ppv;
	pal->pszFormat = psz;
	for (ppv = pal->rgpv; *psz; psz++) {
	    *ppv++ = va_arg(ap, PV);
	}
    } else {
	pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *	EmitPal
 *
 *	OutputDebugString the information, given a pal.  No trailing
 *	carriage return is emitted.
 *
 *	pal	 -> place where info was saved
 *
 *	Format characters:
 *
 *	p   - 32-bit flat pointer
 *	x   - 32-bit hex integer
 *	s   - TCHAR string
 *	A   - ANSI string
 *	W   - UNICODE string
 *	G   - GUID
 *	u   - unsigned integer
 *	C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    OutputDebugStringA(pal->pszProc);
    OutputDebugString(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
	if (i) {
	    OutputDebugString(TEXT(", "));
	}
	switch (pal->pszFormat[i]) {

	case 'p':				/* 32-bit flat pointer */
	case 'x':				/* 32-bit hex */
	    wsprintfA(sz, "%08x", pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 's':				/* TCHAR string */
	    if (pal->rgpv[i]) {
		OutputDebugString(pal->rgpv[i]);
	    }
	    break;

	case 'A':				/* ANSI string */
	    if (pal->rgpv[i]) {
		OutputDebugStringA(pal->rgpv[i]);
	    }
	    break;

#if 0
	case 'W':				/* UNICODE string */
#ifdef	UNICODE
	    OutputDebugStringW(pal->rgpv[i]);
#else
	    OleStrToStrN(sz, cA(sz), pal->rgpv[i], -1);
	    OutputDebugStringA(sz);
#endif
	    break;
#endif

	case 'G':				/* GUID */
	    wsprintfA(sz, "%08x", *(LPDWORD)pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 'u':				/* 32-bit unsigned decimal */
	    wsprintfA(sz, "%u", pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 'C':
	    if (GetClipboardFormatNameA((UINT)pal->rgpv[i], sz, cA(sz))) {
	    } else {
		wsprintfA(sz, "[%04x]", pal->rgpv[i]);
	    }
	    OutputDebugStringA(sz);
	    break;

	default: AssertF(0);			/* Invalid */
	}
    }
    OutputDebugString(TEXT(")"));
}

/*****************************************************************************
 *
 *	EnterSqflPtsz
 *
 *	Mark entry to a procedure.  Arguments were already collected by
 *	ArgsPszV.
 *
 *	sqfl	 -> squirty flags
 *	pszProc  -> procedure name
 *	pal	 -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    if (sqfl == 0 || (sqfl & sqflCur)) {
	EmitPal(pal);
	OutputDebugString(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *	ExitSqflPalHresPpv
 *
 *	Mark exit from a procedure.
 *
 *	pal	 -> argument list
 *	hres	 -> exit result
 *	ppv	 -> optional OUT pointer;
 *		    1 means that hres is a boolean
 *		    2 means that hres is nothing at all
 *
 *****************************************************************************/

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    DWORD le = GetLastError();
    if (ppvObj == ppvVoid) {
    } else if (ppvObj == ppvBool) {
	if (hres == 0) {
	    sqfl |= sqflError;
	}
    } else {
	if (FAILED(hres)) {
	    AssertF(fLimpFF(ppvObj, *ppvObj == 0));
	    sqfl |= sqflError;
	}
    }

    if (sqfl == 0 || (sqfl & sqflCur)) {
	EmitPal(pal);
	OutputDebugString(TEXT(" -> "));
	if (ppvObj != ppvVoid) {
	    TCHAR tszBuf[32];
	    wsprintf(tszBuf, TEXT("%08x"), hres);
	    OutputDebugString(tszBuf);
	    if (ppvObj != ppvBool) {
		if (ppvObj) {
		    wsprintf(tszBuf, TEXT(" [%08x]"), *ppvObj);
		    OutputDebugString(tszBuf);
		}
	    } else if (hres == 0) {
		wsprintf(tszBuf, TEXT(" [%d]"), le);
		OutputDebugString(tszBuf);
	    }
	}
	OutputDebugString(TEXT("\r\n"));
    }

    /*
     *	This redundant test prevents a breakpoint on SetLastError()
     *	from being hit constantly.
     */
    if (le != GetLastError()) {
	SetLastError(le);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\common.c ===
/*****************************************************************************
 *
 *	common.c - Shared stuff that operates on all classes
 *
 *	WARNING!  The Common services work only if you pass in the
 *	"primary object".  This is vacuous if you don't use multiple
 *	inheritance, since there's only one object in the first place.
 *
 *	If you use multiple inheritance, make sure you pass the pointer
 *	to the object that you use as IUnknown.
 *
 *	The exceptions are the Forward_* functions, which work on
 *	pointers to non-primary interfaces.  They forward the call to the
 *	primary interface.
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *	Suppose you want to implement an object called CObj that supports
 *	the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *	Foo as the primary interface.
 *
 *	>> NAMING CONVENTION <<
 *
 *	    COM objects begin with the letter "C".
 *
 *	(1) Declare the primary and secondary vtbls.
 *
 *		Primary_Interface(CObj, IFoo);
 *		Secondary_Interface(CObj, IBar);
 *		Secondary_Interface(CObj, IBaz);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct CObj {
 *		    IFoo 	foo;	    // Primary must come first
 *		    IBar	bar;
 *		    IBaz	baz;
 *		    ... other fields ...
 *		} CObj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* reimplement the AddRef and Release methods!
 *	    although you can subclass them.
 *
 *	(5) To allocate an object of the appropriate type, write
 *
 *		hres = Common_New(CObj, ppvOut);
 *
 *	    or, if the object is variable-sized,
 *
 *		hres = Common_NewCb(cb, CObj, ppvOut);
 *
 *	    If the object supports multiple interfaces, you also need to
 *	    initialize all the secondary interfaces.
 *
 *		CObj *pco = *ppvOut;
 *		pco->bar = Secondary_Vtbl(CObj, IBar);
 *		pco->baz = Secondary_Vtbl(CObj, IBaz);
 *
 *	(6) Define the vtbls.
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		// The macros will declare QueryInterface, AddRef and Release
 *		// so don't list them again
 *
 *		Primary_Interface_Begin(CObj, IFoo)
 *		    CObj_FooMethod1,
 *		    CObj_FooMethod2,
 *		    CObj_FooMethod3,
 *		    CObj_FooMethod4,
 *		Primary_Interface_End(Obj, IFoo)
 *
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *		    CObj_Bar_BarMethod1,
 *		    CObj_Bar_BarMethod2,
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *		    CObj_Baz_BazMethod1,
 *		    CObj_Baz_BazMethod2,
 *		    CObj_Baz_BazMethod3,
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *	All objects are COM objects, even if they are never given out.
 *	In the simplest case, it just derives from IUnknown.
 *
 *	Suppose you want to implement an object called Obj which is
 *	used only internally.
 *
 *	(1) Declare the vtbl.
 *
 *		Simple_Interface(Obj);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct Obj {
 *		    IUnknown unk;
 *		    ... other fields ...
 *		} Obj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* override the QueryInterface, AddRef or
 *	    Release methods!
 *
 *	(5) Allocating an object of the appropriate type is the same
 *	    as with OLE objects.
 *
 *	(6) Define the "vtbl".
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		Simple_Interface_Begin(Obj)
 *		Simple_Interface_End(Obj)
 *
 *	    That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CommonInfo
 *
 *	Information tracked for all common objects.
 *
 *	A common object looks like this:
 *
 *			  riid
 *              cRef	  FinalizeProc
 *	pFoo -> lpVtbl -> QueryInterface
 *		data	  Common_AddRef
 *		data	  Common_Release
 *		...	  ...
 *
 *	Essentially, we use the otherwise-unused space above the
 *	pointers to record our bookkeeping information.
 *
 *	cRef	     = object reference count
 *	riid	     = object iid
 *	FinalizeProc = Finalization procedure
 *
 *	For secondary interfaces, it looks like this:
 *
 *              	  offset to primary interface
 *	pFoo -> lpVtbl -> Forward_QueryInterface
 *			  Forward_AddRef
 *			  Forward_Release
 *			  ...
 *
 *****************************************************************************/

typedef struct CommonInfoN {
  D(ULONG cin_dwSig;)
    ULONG cin_cRef;
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {
    PREVTBL *cip_prevtbl;
} CommonInfoP, CIP, *PCIP;

typedef struct CommonInfoP2 {
    PREVTBL2 *cip2_prevtbl2;
} CommonInfoP2, CIP2, *PCIP2;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
    CIP2 cip2[1];
} CommonInfo, CI, *PCI;

#define ci_dwSig	cin[-1].cin_dwSig
#define ci_cRef		cin[-1].cin_cRef
#define ci_rgfp		cip[0].cip_prevtbl
#define ci_riid		cip[0].cip_prevtbl[-1].riid
#define ci_Finalize	cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_lib		cip2[0].cip2_prevtbl2[-1].lib

#ifdef DEBUG
#define ci_Start	ci_dwSig
#else
#define ci_Start	ci_cRef
#endif

#define ci_dwSignature	0x38162378		/* typed by my cat */

/*****************************************************************************
 *
 *	Common_QueryInterface (from IUnknown)
 *
 *	Use this for objects that support only one interface.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    HRESULT hres;
    EnterProc(Common_QueryInterface, (_ "pG", pv, riid));
    AssertF(pci->ci_dwSig == ci_dwSignature);
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, pci->ci_riid)) {
	*ppvObj = pv;
	Common_AddRef(pv);
	hres = NOERROR;
    } else {
	*ppvObj = NULL;
	hres = ResultFromScode(E_NOINTERFACE);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Common_AddRef (from IUnknown)
 *
 *	Increment the object refcount and the dll refcount.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_AddRef(PV pv)
{
    PCI pci = pv;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedIncrement((LPLONG)&g_cRef);
    return ++pci->ci_cRef;
}

/*****************************************************************************
 *
 *	Common_Finalize (from Common_Release)
 *
 *	By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
    SquirtSqflPtszV(sqfl, TEXT("Common_Finalize(%08x)"), pv);
}

/*****************************************************************************
 *
 *	Common_Release (from IUnknown)
 *
 *	Decrement the object refcount and the dll refcount.
 *
 *	If the object refcount drops to zero, finalize the object
 *	and free it.
 *
 *	The finalization handler lives ahead of the object vtbl.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_Release(PV pv)
{
    PCI pci = pv;
    ULONG ulRc;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedDecrement((LPLONG)&g_cRef);
    ulRc = --pci->ci_cRef;
    if (ulRc == 0) {
	pci->ci_Finalize(pv);
	FreePv(&pci->ci_Start);
    }
    return ulRc;
}

/*****************************************************************************
 *
 *	Forward_QueryInterface (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP
Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_QueryInterface(punk, riid, ppvObj);
}

/*****************************************************************************
 *
 *	Forward_AddRef (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_AddRef(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_AddRef(punk);
}

/*****************************************************************************
 *
 *	Forward_Release (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_Release(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_Release(punk);
}

/*****************************************************************************
 *
 *	_Common_New
 *
 *	Create a new object with refcount 1 and the specific vtbl.
 *	All other fields are zero-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New(ULONG cb, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(Common_New, (_ "u", cb));
    SquirtSqflPtszV(sqfl, TEXT("Common_New()"));
    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) {
	PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
      D(pci->ci_dwSig = ci_dwSignature);
	pci->ci_rgfp = (PV)vtbl;
	*ppvObj = pci;
	Common_AddRef(pci);
	hres = NOERROR;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Invoke_Release
 *
 *	Release the object (if there is one) and wipe out the back-pointer.
 *	Note that we wipe out the value before calling the release, in order
 *	to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = (LPUNKNOWN) pvExchangePpvPv(pv, 0);
    if (punk) {
	punk->lpVtbl->Release(punk);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\map.c ===
/*****************************************************************************
 *
 *      map.c
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *	DllGetClassObject
 *
 *	OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(DllGetClassObject, (_ "G", rclsid));
    if (IsEqualIID(rclsid, &CLSID_Monitor)) {
	hres = CMapFactory_New(riid, ppvObj);
    } else {
	*ppvObj = 0;
	hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	DllCanUnloadNow
 *
 *	OLE entry point.  Fail iff there are outstanding refs.
 *
 *	There is an unavoidable race condition between DllCanUnloadNow
 *	and the creation of a new reference:  Between the time we
 *	return from DllCanUnloadNow() and the caller inspects the value,
 *	another thread in the same process may decide to call
 *	DllGetClassObject, thus suddenly creating an object in this DLL
 *	when there previously was none.
 *
 *	It is the caller's responsibility to prepare for this possibility;
 *	there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    SquirtSqflPtszV(sqfl, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
    return g_cRef ? S_FALSE : S_OK;
}

/*****************************************************************************
 *
 *	Entry32
 *
 *	DLL entry point.
 *
 *****************************************************************************/

BOOL APIENTRY
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
	g_hinst = hinst;
#ifdef	DEBUG
        sqflCur = GetProfileInt(TEXT("DEBUG"), TEXT("Monitor"), 0);
        SquirtSqflPtszV(sqfl, TEXT("LoadDll - Monitor"));
#endif
    }
    return 1;
}

/*****************************************************************************
 *
 *	The long-awaited CLSID
 *
 *****************************************************************************/

#include <initguid.h>


// {5665DEC0-A40A-11d1-B984-0020AFD79778}
DEFINE_GUID(CLSID_Monitor, 
0x5665dec0, 0xa40a, 0x11d1, 0xb9, 0x84, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x78);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\mapcf.c ===
/*****************************************************************************
 *
 * mapcf.c - IClassFactory interface
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *****************************************************************************/

 Primary_Interface(CMapFactory, IClassFactory);

/*****************************************************************************
 *
 *	CMapFactory
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

typedef struct CMapFactory {

    /* Supported interfaces */
    IClassFactory 	cf;

} CMapFactory, FCF, *PFCF;

typedef IClassFactory CF, *PCF;

/*****************************************************************************
 *
 *	CMapFactory_QueryInterface (from IUnknown)
 *	CMapFactory_AddRef (from IUnknown)
 *	CMapFactory_Finalize (from Common)
 *	CMapFactory_Release (from IUnknown)
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMapFactory)
Default_AddRef(CMapFactory)
Default_Release(CMapFactory)

#else
#define CMapFactory_QueryInterface Common_QueryInterface
#define CMapFactory_AddRef	Common_AddRef
#define CMapFactory_Release	Common_Release
#endif
#define CMapFactory_Finalize	Common_Finalize

/*****************************************************************************
 *
 *	CMapFactory_CreateInstance (from IClassFactory)
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_CreateInstance(PCF pcf, LPUNKNOWN punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    SquirtSqflPtszV(sqfl, TEXT("CMapFactory_CreateInstance()"));
    if (!punkOuter) {
	/* The only object we know how to create is a propsheet extension */
	hres = CMapPsx_New(riid, ppvObj);
    } else {		/* Does anybody support aggregation any more? */
	hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }
    SquirtSqflPtszV(sqfl, TEXT("CMapFactory_CreateInstance() -> %08x [%08x]"),
		    hres, *ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	CMapFactory_LockServer (from IClassFactory)
 *
 *      Locking the server is identical to
 *	creating an object and not releasing it until you want to unlock
 *	the server.
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_LockServer(PCF pcf, BOOL fLock)
{
    PFCF this = IToClass(CMapFactory, cf, pcf);
    if (fLock) {
	InterlockedIncrement((LPLONG)&g_cRef);
    } else {
	InterlockedDecrement((LPLONG)&g_cRef);
    }
    return NOERROR;
}

/*****************************************************************************
 *
 *	CMapFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IClassFactory)) {
	hres = Common_New(CMapFactory, ppvObj);
    } else {
	hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbl
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CMapFactory, IClassFactory)
	CMapFactory_CreateInstance,
	CMapFactory_LockServer,
Primary_Interface_End(CMapFactory, IClassFactory)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\map.h ===
/*****************************************************************************
 *
 *	map.h - Main private header file
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Coding conventions:
 *
 *	+ Follow standard shell coding conventions.
 *
 *	+ Standard K&R brace placement and indentation style.
 *
 *	+ Indent by 4 spaces.
 *
 *	+ Fully-brace all dependent clauses.  Never write "if (c) foo();"
 *
 *	+ Do not return in the middle of a function.  If forced,
 *	  use a "goto exit".  This way, you can stick entry/exit stuff
 *	  later without getting caught out.  (I learned this rule the
 *	  hard way.)
 *
 *	+ Declare variables with narrowest possible scope.
 *
 *	+ Always test for success, not failure!  The compiler will
 *	  thank you.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	NOTE!  This code was written for readability, not efficiency.
 *
 *	I'm trusting the compiler to do optimizations like these:
 *
 *	"Parameter alias":
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		LPBAR pbar = (LPBAR)pfoo;
 *		... use pbar and never mention pfoo again ...
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		#define pbar ((LPBAR)pfoo)
 *		... use pbar and never mention pfoo again ...
 *		#undef pbar
 *	    }
 *
 *	"Speculative Execution":
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		} else {		// condition 1 failed
 *		    *pfoo = 0;
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc = 0;
 *		*pfoo = 0;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		}
 *		return fRc;
 *	    }
 *
 *	"Single Exit":
 *
 *	    Function(...)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			fRc = 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			fRc = 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(...)
 *	    {
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			return 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			return 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    return 0;
 *		}
 *		NOTREACHED;
 *	    }
 *
 *
 *
 *****************************************************************************/

// #define STRICT
#define NOIME
#define NOSERVICE
#include <windows.h>

#ifdef	RC_INVOKED		/* Define some tags to speed up rc.exe */
#define __RPCNDR_H__		/* Don't need RPC network data representation */
#define __RPC_H__		/* Don't need RPC */
#include <oleidl.h>		/* Get the DROPEFFECT stuff */
#define _OLE2_H_		/* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#else
#include <windowsx.h>
#include <regstr.h>
#endif

#include <shlobj.h>
#include <shellapi.h>

/*****************************************************************************
 *
 *	Resource identifiers
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Dialogs
 *
 *****************************************************************************/

#define IDC_STATIC		-1

#define IDD_MAIN		1


/*****************************************************************************
 *
 *	Strings
 *
 *****************************************************************************/

#define IDS_LKEYFIRST		32
#define IDS_CAPSLOCK		32
#define IDS_LCTRL		33
#define IDS_LALT		34
#define IDS_LSHIFT		35
#define IDS_LKEYLAST		35
#define cidsLMap		(IDS_LKEYLAST - IDS_LKEYFIRST + 1)

#define IDS_RKEYFIRST		36
#define IDS_RWIN		36
#define IDS_RMENU		37
#define IDS_RCTRL		38
#define IDS_RALT		39
#define IDS_RKEYLAST		39
#define cidsRMap		(IDS_RKEYLAST - IDS_RKEYFIRST + 1)

#ifndef	RC_INVOKED

/*****************************************************************************
 *
 *	Stuff I'm tired of typing over and over.
 *
 *****************************************************************************/

typedef LPITEMIDLIST PIDL, *PPIDL;
typedef LPCITEMIDLIST PCIDL;
typedef LPSHELLFOLDER PSF;
typedef LPVOID PV;
typedef LPVOID *PPV;
typedef LPCVOID PCV;
typedef REFIID RIID;
typedef LPUNKNOWN PUNK;

/*****************************************************************************
 *
 *	Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define INTERNAL NTAPI	/* Called only within a translation unit */
#define EXTERNAL NTAPI	/* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#define OBJAT(T, v) (*(T *)(v))		/* Pointer punning */
#define PUN(T, v) OBJAT(T, &(v))	/* General-purpose type-punning */

/*
 * Convert a count of TCHAR's to a count of bytes.
 */
#define cbCtch(ctch) ((ctch) * sizeof(TCHAR))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert an array name (A) to a pointer to its Max.
 * (I.e., one past the last element.)
 */
#define pvMaxA(a) (&a[cA(a)])

#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

/*
 * lfNeVV
 *
 * Given two values, return zero if they are equal and nonzero if they
 * are different.  This is the same as (v1) != (v2), except that the
 * return value on unequal is a random nonzero value instead of 1.
 * (lf = logical flag)
 *
 * lfNePvPv
 *
 * The same as lfNeVV, but for pointers.
 *
 * lfPv
 *
 * Nonzero if pv is not null.
 *
 */
#define lfNeVV(v1, v2) ((v1) - (v2))
#define lfNePvPv(v1, v2) lfNeVV((DWORD)(PV)(v1), (DWORD)(PV)(v2))
#define lfPv(pv) ((BOOL)(PV)(pv))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
#define fLorFF(f1, f2) ({ typeof (f1) _f = f1; if (!_f) _f = f2; _f; })
#else
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 * InOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 * CopyPvPvCb - Copy some memory around
 * MovePvPvCb - Move some memory around
 */
#define CopyPvPvCb RtlCopyMemory
#define MovePvPvCb RtlMoveMemory

/*
 * memeq - Reverse of memcmp
 */
#define memeq !memcmp

/*
 * fPvPfnCmpPv - Compare two objects for equality using the comparison
 *		 function and the desired outcome.  E.g.,
 *
 *			fPvPfnCmpPv(psz1, lstrcmpi, >, psz2)
 *
 *		 returns nonzero if psz1 is greater than psz2 according
 *		 to lstrcmpi.
 */

#define fPvPfnCmpPv(p1, pfn, cmp, p2) (pfn(p1, p2) cmp 0)

/*
 * lstreq   - nonzero if two strings (according to lstrcmp) are equal
 * lstrne   - nonzero if two strings (according to lstrcmp) are different
 *
 * lstrieq   - nonzero if two strings (according to lstrcmpi) are equal
 * lstrine   - nonzero if two strings (according to lstrcmpi) are different
 *
 * lstrieqA  - nonzero if two strings (according to lstrcmpiA) are equal
 * lstrineA  - nonzero if two strings (according to lstrcmpiA) are different
 */

#define lstreq   !lstrcmp
#define lstrne   lstrcmp

#define lstrieq  !lstrcmpi
#define lstrine  lstrcmpi

#define lstrieqA !lstrcmpiA
#define lstrineA lstrcmpiA

/*****************************************************************************
 *
 *	Wrappers and other quickies
 *
 *****************************************************************************/

#define pvExchangePpvPv(ppv, pv) \
	(PV)LongToPtr(InterlockedExchange((PLONG)(ppv), (LONG)(pv)))

#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

#define ILIsSimple(pidl) (ILIsEmpty(_ILNext(pidl)))

/*****************************************************************************
 *
 *	Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst;		/* My instance handle */

// {5665DEC0-A40A-11d1-B984-0020AFD79778}
DEFINE_GUID(CLSID_Monitor, 
0x5665dec0, 0xa40a, 0x11d1, 0xb9, 0x84, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x78);


/*****************************************************************************
 *
 *	Dynamic Globals.  There should be as few of these as possible.
 *
 *	All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef;			/* Global reference count */

/*****************************************************************************
 *
 *	mapcf.c - Class Factory
 *
 *****************************************************************************/

STDMETHODIMP CMapFactory_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	mappsx.c - IPropSheetExt, IShellExtInit
 *
 *****************************************************************************/

STDMETHODIMP CMapPsx_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *      monitor.c - Property sheet
 *
 *****************************************************************************/

INT_PTR CALLBACK MonDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);


/*****************************************************************************
 *
 *	Common object managers.
 *
 *****************************************************************************/

typedef struct PREVTBL0 {		/* Simple (non-OLE) object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL0, *PPREVTBL0;

typedef struct PREVTBL {		/* Primary interface */
    REFIID riid;			/* Type of this object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBL2 {		/* Secondary interface */
    ULONG lib;				/* offset from start of object */
} PREVTBL2, *PPREVTBL2;

#ifdef	DEBUG

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown); \
					Default_QueryInterface(C) \
					Default_AddRef(C) \
					Default_Release(C)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	Primary_Interface_Begin(C, IUnknown)
#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#else

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##IUnknown,				\
	    C##_Finalize,				\
	}, {						\
	    Common##_QueryInterface,			\
	    Common##_AddRef,				\
	    Common##_Release,				\

#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#endif

#define Primary_Interface(C, I)				\
	extern struct S_##C##Vtbl {			\
	    PREVTBL prevtbl;				\
	    I##Vtbl vtbl;				\
	} c_##C##VI					\

#define Primary_Vtbl(C) &c_##C##VI.vtbl

#define Primary_Interface_Begin(C, I)			\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##I,					\
	    C##_Finalize,				\
	}, {						\
	    C##_QueryInterface,				\
	    C##_AddRef,					\
	    C##_Release,				\

#define Primary_Interface_End(C, I)			\
	} };						\

#define Secondary_Interface(C, I)			\
	extern struct S_##I##_##C##Vtbl {		\
	    PREVTBL2 prevtbl;	 			\
	    I##Vtbl vtbl;	 			\
	} c_##I##_##C##VI				\

#define Secondary_Vtbl(C, I) &c_##I##_##C##VI.vtbl

#define Secondary_Interface_Begin(C, I, nm)		\
	struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {	\
	    _IOffset(C, nm),				\
	}, {						\
	    Forward_QueryInterface,			\
	    Forward_AddRef,				\
	    Forward_Release,				\

#define Secondary_Interface_End(C, I, nm)		\
	} };						\

STDMETHODIMP Common_QueryInterface(PV, REFIID, PPV);
STDMETHODIMP_(ULONG) _Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) _Common_Release(PV pv);

/*
 * In DEBUG, go through the vtbl for additional squirties.
 */
#ifdef	DEBUG
#define Common_AddRef(punk) \
		((IUnknown *)(punk))->lpVtbl->AddRef((IUnknown *)(punk))
#define Common_Release(punk) \
		((IUnknown *)(punk))->lpVtbl->Release((IUnknown *)(punk))
#else
#define Common_AddRef _Common_AddRef
#define Common_Release _Common_Release
#endif

void EXTERNAL Common_Finalize(PV);

STDMETHODIMP _Common_New(ULONG cb, PV vtbl, PPV ppvObj);
#define Common_NewCb(cb, C, ppvObj) _Common_New(cb, Primary_Vtbl(C), ppvObj)
#define Common_New(C, ppvObj) Common_NewCb(cbX(C), C, ppvObj)

STDMETHODIMP Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

/*****************************************************************************
 *
 *	Common_CopyAddRef
 *
 *	Copy a pointer and increment its reference count.
 *
 *	Cannot be a macro because Common_AddRef evaluates its argument
 *	twice.
 *
 *****************************************************************************/

INLINE void Common_CopyAddRef(PV pvDst, PV pvSrc)
{
    PPV ppvDst = pvDst;
    *ppvDst = pvSrc;
    Common_AddRef(pvSrc);
}

/*****************************************************************************
 *
 *	Invoking OLE methods.
 *
 *	Invoke_Release is called with a pointer to the object, not with
 *	the object itself.  It zeros out the variable on the release.
 *
 *****************************************************************************/

void EXTERNAL Invoke_AddRef(PV pv);
void EXTERNAL Invoke_Release(PV pv);

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

#define AssertNow(c) switch(0) case 0: case c:
#define CAssertNowPP(c,l) INLINE void Assert##l(void) { AssertNow(c); }
#define CAssertNowP(c,l) CAssertNowPP(c,l)
#define CAssertNow(c) CAssertNowP(c,__LINE__)

typedef enum {
    sqflAlways		= 0x00000000,		/* Unconditional */
    sqflDll		= 0x00000001,		/* Dll bookkeeping */
    sqflFactory		= 0x00000002,		/* IClassFactory */
    sqflPsx		= 0x00000004,		/* IPropSheetExt */
    sqflPs		= 0x00000008,		/* Property sheet */
    sqflCommon		= 0x00000000,		/* common.c */
    sqflError		= 0x80000000,		/* Errors */
} SQFL;						/* squiffle */

void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifndef	DEBUG
#define SquirtSqflPtszV sizeof
#endif

/*****************************************************************************
 *
 *	Procedure enter/exit tracking.
 *
 *	Start a procedure with
 *
 *	EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *	The format string is documented in EmitPal.
 *
 *	End a procedure with one of the following:
 *
 *	    ExitProc();
 *
 *		Procedure returns no value.
 *
 *	    ExitProcX();
 *
 *		Procedure returns an arbitrary DWORD.
 *
 *	    ExitOleProc();
 *
 *		Procedure returns an HRESULT (named "hres").
 *
 *	    ExitOleProcPpv(ppvOut);
 *
 *		Procedure returns an HRESULT (named "hres") and, on success,
 *		puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);

#ifdef	DEBUG

SQFL sqflCur;

#define AssertFPtsz(c, ptsz) \
	((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#define ValidateF(c) \
	((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))
#define D(x)		x

#define SetupEnterProc(nm)				\
	static CHAR s_szProc[] = #nm;			\
	ARGLIST _al[1]					\

#define _ _al,

#define ppvBool	((PPV)1)
#define ppvVoid	((PPV)2)

#define DoEnterProc(v)					\
	ArgsPalPszV v;					\
	EnterSqflPszPal(sqfl, s_szProc, _al)		\

#define EnterProc(nm, v)				\
	SetupEnterProc(nm);				\
	DoEnterProc(v)					\

#define ExitOleProcPpv(ppv)				\
	ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv))	\

#define ExitOleProc()					\
	ExitOleProcPpv(0)				\

#define ExitProc()					\
	ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)	\

#define ExitProcX(x)					\
	ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#else

#define AssertFPtsz(c, ptsz)
#define ValidateF(c)	(c)
#define D(x)

#define SetupEnterProc(nm)
#define DoEnterProc(v)
#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()

#endif

#define AssertF(c)	AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *	Macros that forward to the common handlers after squirting.
 *	Use these only in DEBUG.
 *
 *	It is assumed that sqfl has been #define'd to the appropriate sqfl.
 *
 *****************************************************************************/

#ifdef  DEBUG

#define Default_QueryInterface(Class)				\
STDMETHODIMP							\
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)		\
{								\
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);		\
}								\

#define Default_AddRef(Class)					\
STDMETHODIMP_(ULONG)						\
Class##_AddRef(PV pv)						\
{								\
    ULONG ulRc = _Common_AddRef(pv);				\
    SquirtSqflPtszV(sqfl, TEXT(#Class)				\
			TEXT("_AddRef(%08x) -> %d"), pv, ulRc); \
    return ulRc;						\
}								\

#define Default_Release(Class)					\
STDMETHODIMP_(ULONG)						\
Class##_Release(PV pv)						\
{								\
    ULONG ulRc = _Common_Release(pv);				\
    SquirtSqflPtszV(sqfl, TEXT(#Class)				\
		       TEXT("_Release(%08x) -> %d"), pv, ulRc); \
    return ulRc;						\
}								\

#endif

/*****************************************************************************
 *
 *	mem.c
 *
 *	Be extremely careful with FreePv, because it doesn't work if
 *	the pointer is null.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#define FreePpv(ppv) ReallocCbPpv(0, ppv)
#define FreePv(pv) LocalFree((HLOCAL)(pv))

#endif /* !RC_INVOKED */

//----------------------------------------------------------------------------        // ;Internal
// Internal helper macro                                                              // ;Internal
//----------------------------------------------------------------------------        // ;Internal
										      // ;Internal
#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))                     // ;Internal
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf))) // ;Internal
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)                       // ;Internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\mappsx.c ===
/*****************************************************************************
 *
 *	mappsx.c - IShellPropSheetExt interface
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflPsx

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *	We must implement an IShellExtInit so the shell
 *	will know that we are ready for action.
 *
 *****************************************************************************/

  Primary_Interface(CMapPsx, IShellPropSheetExt);
Secondary_Interface(CMapPsx, IShellExtInit);

/*****************************************************************************
 *
 *	CMapPsx
 *
 *	The property sheet extension for the Map/Ctrl gizmo.
 *
 *****************************************************************************/

typedef struct CMapPsx {

    /* Supported interfaces */
    IShellPropSheetExt 	psx;
    IShellExtInit	sxi;

} CMapPsx, CMSX, *PCMSX;

typedef IShellPropSheetExt PSX, *PPSX;
typedef IShellExtInit SXI, *PSXI;
typedef IDataObject DTO, *PDTO;		/* Used by IShellExtInit */

/*****************************************************************************
 *
 *	CMapPsx_QueryInterface (from IUnknown)
 *
 *	We need to check for our additional interfaces before falling
 *	through to Common_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_QueryInterface(PPSX ppsx, RIID riid, PPV ppvObj)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IShellExtInit)) {
	*ppvObj = &this->sxi;
	Common_AddRef(this);
	hres = NOERROR;
    } else {
	hres = Common_QueryInterface(this, riid, ppvObj);
    }
    AssertF(fLimpFF(FAILED(hres), *ppvObj == 0));
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_AddRef (from IUnknown)
 *	CMapPsx_Release (from IUnknown)
 *
 *****************************************************************************/

#ifdef DEBUG
Default_AddRef(CMapPsx)
Default_Release(CMapPsx)
#else
#define CMapPsx_AddRef Common_AddRef
#define CMapPsx_Release Common_Release
#endif

/*****************************************************************************
 *
 *	CMapPsx_Finalize (from Common)
 *
 *	Release the resources of an CMapPsx.
 *
 *****************************************************************************/

void EXTERNAL
CMapPsx_Finalize(PV pv)
{
    PCMSX this = pv;

    EnterProc(CMapPsx_Finalize, (_ "p", pv));

    ExitProc();
}

/*****************************************************************************
 *
 *	CMapPsx_AddPages (From IShellPropSheetExt)
 *
 *	Add one or more pages to an existing property sheet.
 *
 *	lpfnAdd	  - callback function to add pages
 *	lp	  - refdata for lpfnAdd
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_AddPages(PPSX ppsx, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lp)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    EnterProc(CMapPsx_AddPages, (_ "p", ppsx));
    if (lpfnAdd) {
	HPROPSHEETPAGE hpsp;
	PROPSHEETPAGE psp;
	psp.dwSize = sizeof(psp);
	psp.dwFlags = PSP_DEFAULT;
	psp.hInstance = g_hinst;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_MAIN);
        psp.pfnDlgProc = MonDlgProc;

	hpsp = CreatePropertySheetPage(&psp);
	if (hpsp) {
	    if (lpfnAdd(hpsp, lp)) {
		Common_AddRef(this);
		hres = S_OK;
	    } else {
		DestroyPropertySheetPage(hpsp);
		hres = E_FAIL;
	    }
	} else {
	    hres = E_FAIL;
	}
    } else {
	hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_ReplacePages (From IShellPropSheetExt)
 *
 *	Replaces one or more pages in an existing property sheet.
 *
 *	id	  - page identifier
 *	lpfnReplace  - callback function to replace the page
 *	lp	  - refdata for lpfnReplace
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_ReplacePages(PPSX ppsx, UINT id,
		      LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lp)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    EnterProc(CMapPsx_ReplacePages, (_ "pu", ppsx, id));

    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_SXI_Initialize (from IShellExtension)
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_SXI_Initialize(PSXI psxi, PCIDL pidlFolder, PDTO pdto, HKEY hk)
{
    PCMSX this = IToClass(CMapPsx, sxi, psxi);
    HRESULT hres;
    EnterProc(CMapPsx_SXI_Initialize, (_ ""));

    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_New (from IClassFactory)
 *
 *	Note that we release the pmpsx that Common_New created, because we
 *	are done with it.  The real refcount is handled by the
 *	CMapPsx_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(CMapPsx_New, (_ "G", riid));

    *ppvObj = 0;
    hres = Common_New(CMapPsx, ppvObj);
    if (SUCCEEDED(hres)) {
	PCMSX pmpsx = *ppvObj;
	pmpsx->sxi.lpVtbl = Secondary_Vtbl(CMapPsx, IShellExtInit);
	hres = CMapPsx_QueryInterface(&pmpsx->psx, riid, ppvObj);
	Common_Release(pmpsx);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbls
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CMapPsx, IShellPropSheetExt)
	CMapPsx_AddPages,
	CMapPsx_ReplacePages,
Primary_Interface_End(CMapPsx, IIShellPropSheetExt)

Secondary_Interface_Begin(CMapPsx, IShellExtInit, sxi)
 	CMapPsx_SXI_Initialize,
Secondary_Interface_End(CMapPsx, IShellExtInit, sxi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\monitor.c ===
/*-----------------------------------------
   MONITOR.C  Dll for usb monitor controls

   This is a sample application to demonstrate USB Monitor
   control using HID.DLL.  The application will work with a
   monitor that is compliant with the USB Monitor Control
   Class Specification.

  -----------------------------------------*/
#include "monitor.h"

// global vars for arrow buttons
int cxEdge;
int cyEdge;  

// Global hid device structure
PHID_DEVICE HidDevice;

int DeviceLoaded = 0;  // flag
int RadioControl;

// Global control structure for USB Monitor controls
MONITOR_CONTROL Control[MAXCONTROLS];
MONITOR_CONTROL HCurrent, VCurrent;

// Global app vars.
extern HINSTANCE g_hinst;
HWND g_hwndDlg;

DWORD dwSheetStyles ;
HINSTANCE hInst ;
HICON hiconApp ;


//
// Main Dialog Box Procedure
//

INT_PTR CALLBACK MonDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam) {

    int i, x;
    int change;
    NMHDR FAR *lpnm;

    PUSAGE                      DataBuffer;
    ULONG                       ListLength;
    NTSTATUS                    status;    
    
	switch (iMsg)
    {
        case WM_DRAWITEM:
            switch (wParam)
            {
                case IDC_UP:
                    DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                    DrawUpArrow((LPDRAWITEMSTRUCT)lParam);
                    break;

                case IDC_DOWN:
                    DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                    DrawDownArrow((LPDRAWITEMSTRUCT)lParam);
                    break;
			
                case IDC_LEFT:
                    DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                    DrawLeftArrow((LPDRAWITEMSTRUCT)lParam);
                    break;

                case IDC_RIGHT:
                    DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                    DrawRightArrow((LPDRAWITEMSTRUCT)lParam);                        
                    break;

                default :
                    break;
            }
            return TRUE;  

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
              // This if for the Cancel and Apply buttons
            switch (lpnm->code) {
                case PSN_RESET :
                    ResetControls();
                    break;
                case PSN_APPLY :
                    ApplyControls();
                    break;
                default :
                    break;
            }
            return TRUE;
			
        case WM_INITDIALOG :
                  // Global variables 
            g_hwndDlg = hDlg;
              // fill in monitor array
            InitControlStuct();
              // Find hid devices
            vLoadDevices();
              // Hide all the windows
            InitWindows(hDlg);
			  // Set the first monitor to the current device	
            if (DeviceLoaded) {
                i = (int)SendDlgItemMessage (hDlg, IDC_MON, CB_SETCURSEL, 0, 0);
                i = (int)SendDlgItemMessage (hDlg, IDC_MON, CB_GETCURSEL, 0, 0);

                      //  Get the HidDevice pointer stored in the combo box.
                if (CB_ERR != i) {
                    HidDevice = (PHID_DEVICE) SendDlgItemMessage(hDlg, IDC_MON,
                                                                 CB_GETITEMDATA,
                                                                 i, 0);
                }
                InitMonitor(hDlg);
            }
         	return TRUE;
            	
        case WM_COMMAND :
            switch (LOWORD (wParam))
            {
                case IDC_DEGAUSS :   // Have fun with Degauss!!!
                    //  I currently implement degauss as a feature report.
                    //  It should be treated as an output report since
                    //  it is a write only control, but have not seen
                    //  any hardware that implements that way.

                    if (DeviceLoaded) {
                        ChangeFeature (DEGAUSS_USAGE_PAGE, DEGAUSS_USAGE, 1);
                    }  // End if device loaded
                    break;

                case IDC_RESET :

    			    // Create a buffer with the restore USAGE value
    			    DataBuffer = malloc(sizeof(USAGE));
                    *DataBuffer = SETTINGS_RESET_USAGE;
                    ListLength = 1;
			
        			// Zero buffer so it can be used again
                	memset (HidDevice->FeatureReportBuffer, 0x00, HidDevice->Caps.
		    		FeatureReportByteLength);
                            
                    status = HidP_SetUsages(HidP_Feature,
                                            SETTINGS_RESET_USAGE_PAGE,
                                            Control[SETTINGS].linkcollection,
                                            DataBuffer,
                                            &ListLength,
                                            HidDevice->Ppd,
                                            HidDevice->FeatureReportBuffer,
                                            HidDevice->Caps.FeatureReportByteLength);

                    if (HidDevice->Caps.FeatureReportByteLength > 0 &&
            	            status == HIDP_STATUS_SUCCESS) {
			            	// Send buffer to device
            		        status = HidD_SetFeature (HidDevice->HidDevice,
                                                      HidDevice->FeatureReportBuffer,
                                                      HidDevice->Caps.FeatureReportByteLength);
                	}  // end if HidDevice
		        	free (DataBuffer);
			        break;
                		
                case IDC_OPTION :
                      // Show the proper controls.
                    if (HIWORD (wParam) == CBN_SELCHANGE) {
                        i = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_GETCURSEL, 0, 0);

                        if (i == 0) {
                            InitGeneralControls(hDlg);
                        }

                        if (i == 1) {
                            InitColorControls(hDlg);
                        }

                        if (i == 2) {
                            InitAdvancedControls(hDlg);                                              
                        }
                                     
                    } // end if wparam = selchange 
                    break;

                case IDC_MON :
                        // setup the monitor selected.
                    if (HIWORD (wParam) == CBN_SELCHANGE) {
                        i = (int)SendDlgItemMessage (hDlg, IDC_MON, CB_GETCURSEL, 0, 0);

                          //  Get the HidDevice pointer stored in the combo box.
                        if (CB_ERR != i) {
                            HidDevice = (PHID_DEVICE) SendDlgItemMessage(hDlg,
                                                                         IDC_MON,
                                                                         CB_GETITEMDATA,
                                                                         i,
                                                                         0);
                        }
                        DeviceLoaded = 1;
                        InitMonitor(hDlg);
                    }  // End if hiword == selchange
                    break;

                case IDC_UP :
                    Control[RadioControl + 7].value = min (Control[RadioControl + 7].max, Control[RadioControl + 7].value + 5);

                      // here is the call to update the monitor
                    ChangeFeature (Control[RadioControl + 7].usagepage, Control[RadioControl + 7].usage, Control[RadioControl + 7].value);
                    Control[RadioControl + 7].HasControlChanged = TRUE;
                    SendMessage(GetParent(g_hwndDlg), PSM_CHANGED, (WPARAM)g_hwndDlg, 0L);
                    break;

                case IDC_DOWN :
                    Control[RadioControl + 7].value = max (Control[RadioControl + 7].min, Control[RadioControl + 7].value - 5);

                      // here is the call to update the monitor
                    ChangeFeature (Control[RadioControl + 7].usagepage, Control[RadioControl + 7].usage, Control[RadioControl + 7].value);
                    Control[RadioControl + 7].HasControlChanged = TRUE;
                    SendMessage(GetParent(g_hwndDlg), PSM_CHANGED, (WPARAM)g_hwndDlg, 0);
                    break;

                case IDC_LEFT :
                    Control[RadioControl].value = max (Control[RadioControl].min, Control[RadioControl].value - 5);

                      // here is the call to update the monitor
                    ChangeFeature (Control[RadioControl].usagepage, Control[RadioControl].usage, Control[RadioControl].value);
                    Control[RadioControl].HasControlChanged = TRUE;
                    SendMessage(GetParent(g_hwndDlg), PSM_CHANGED, (WPARAM)g_hwndDlg, 0);
                    break;

                case IDC_RIGHT :
                    Control[RadioControl].value = min (Control[RadioControl].max, Control[RadioControl].value + 5);

                      // here is the call to update the monitor
                    ChangeFeature (Control[RadioControl].usagepage, Control[RadioControl].usage, Control[RadioControl].value);
                    Control[RadioControl].HasControlChanged = TRUE;
                    SendMessage(GetParent(g_hwndDlg), PSM_CHANGED, (WPARAM)g_hwndDlg, 0);
                    break;

                case IDR_SIZE :
                case IDR_POSITION :
                    CheckRadioButton (hDlg, IDR_POSITION, IDR_SIZE, LOWORD(wParam));
                    RadioControl = ((int)LOWORD(wParam)) - 400;
                    break;
				
                default :
                    break;
            } // end switch loword wparam
            return TRUE;
			
        case WM_HSCROLL :

            x = GetWindowLong((HWND) lParam, GWL_ID);
            i = x - 400;
			
            if (Control[i].usagepage != -1)
            {
                // Here is where we change the value when the
                // user scrolls!!!
                change = (Control[i].max - Control[i].min) / 11;
	
                switch (LOWORD (wParam))
                {
                    case TB_PAGEDOWN :    // pagedown = right
                        Control[i].value += change;
                        // fall through
                    case TB_LINEDOWN :
                        Control[i].value = min (Control[i].max, Control[i].value + 1);
                        break;

                    case TB_PAGEUP :        // pageup = left
                        Control[i].value -= change;
                        // fall through
                    case TB_LINEUP :
                        Control[i].value = max (Control[i].min, Control[i].value - 1);
                        break;
		
                    case TB_TOP :
                        Control[i].value = Control[i].min;
                        break;

                    case TB_BOTTOM :
                        Control[i].value = Control[i].max;
                        break;
	
                    case TB_THUMBPOSITION :
                    case TB_THUMBTRACK :
                        Control[i].value = HIWORD (wParam);
                        break;
	
                    default :
                        break;
                } // end switch loword wparam

                // here is the call to update the monitor
                ChangeFeature (Control[i].usagepage, Control[i].usage, Control[i].value);
                Control[i].HasControlChanged = TRUE;
                SendMessage(GetParent(g_hwndDlg), PSM_CHANGED, (WPARAM)g_hwndDlg, 0);
            }
            return TRUE;   
	 	
        default:
            break;
		  		  	
	} // End switch iMsg
	return FALSE;
}

//
//  This func sends the value the user indicated by moving the scroll bar
// to the device.

VOID ChangeFeature(USAGE UsagePage, USAGE Usage, int Value) {
NTSTATUS status;

	if (DeviceLoaded) {

                        // Zero buffer so it can be used again
		memset (HidDevice->FeatureReportBuffer, 0x00, HidDevice->Caps.
					FeatureReportByteLength);

			// Put proper values in buffer
		status = HidP_SetUsageValue (HidP_Feature, 
                                     UsagePage, 
                                     0, 
                                     Usage, 
                                     (ULONG)Value, 
                                     HidDevice->Ppd, 
                                     HidDevice->FeatureReportBuffer, 
                                     (ULONG)(HidDevice->Caps.FeatureReportByteLength));

		if (HidDevice->Caps.FeatureReportByteLength > 0){
				// Send buffer to device
		  status = HidD_SetFeature (HidDevice->HidDevice,
                                    HidDevice->FeatureReportBuffer,
                                    HidDevice->Caps.FeatureReportByteLength);
				// Zero buffer so it can be used again
		  memset (HidDevice->FeatureReportBuffer, 0x00, HidDevice->Caps.
					FeatureReportByteLength);

		}  // end if HidDevice
	} // end if, deviceloaded
} // ChangeFeature


VOID vLoadDevices()
{

	// This function taken from hclient.  It uses some stuff from pnp.c also.
	
        PHID_DEVICE HidDevices;
        ULONG ulCount;
        BOOL bReturn;
        bReturn=FindKnownHidDevices(&HidDevices,&ulCount);

} // end function vLoadDevices

void NEAR PASCAL DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    RECT rc = lpdis->rcItem;
    HDC hdc = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
	DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
	OffsetRect(&rc, 1, 1);
    }
    else  
	DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
}

void NEAR PASCAL DrawUpArrow(LPDRAWITEMSTRUCT lpdis)
{
    HDC hdc = lpdis->hDC;
    LPRECT lprc = &(lpdis->rcItem);
    BOOL bDisabled = lpdis->itemState & ODS_DISABLED;

    HBRUSH hbr;
    int x, y;


    x = (lprc->right / 2) - 5;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 3);

    if (bDisabled)
    {
	hbr = GetSysColorBrush(COLOR_3DHILIGHT);
	hbr = SelectObject(hdc, hbr);

	x++;
	y++;
	PatBlt(hdc, x, y, 5, 1, PATCOPY);
	PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
	PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

	SelectObject(hdc, hbr);
	x--;
	y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = SelectObject(hdc, hbr);

    PatBlt(hdc, x+5, y, 1, 1, PATCOPY);
    PatBlt(hdc, x+4, y+1, 3, 1, PATCOPY);
    PatBlt(hdc, x+3, y+2, 5, 1, PATCOPY);
    PatBlt(hdc, x+2, y+3, 7, 1, PATCOPY);
    PatBlt(hdc, x+1, y+4, 9, 1, PATCOPY);
    PatBlt(hdc, x, y+5, 11, 1, PATCOPY);

    SelectObject(hdc, hbr);
    lprc->right = x;
}

void NEAR PASCAL DrawDownArrow(LPDRAWITEMSTRUCT lpdis)
{
    HDC hdc = lpdis->hDC;
    LPRECT lprc = &(lpdis->rcItem);
    BOOL bDisabled = lpdis->itemState & ODS_DISABLED;

    HBRUSH hbr;
    int x, y;


    x = (lprc->right / 2) - 5;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 3);

    if (bDisabled)
    {
	hbr = GetSysColorBrush(COLOR_3DHILIGHT);
	hbr = SelectObject(hdc, hbr);

	x++;
	y++;
	PatBlt(hdc, x, y, 5, 1, PATCOPY);
	PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
	PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

	SelectObject(hdc, hbr);
	x--;
	y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 11, 1, PATCOPY);
    PatBlt(hdc, x+1, y+1, 9, 1, PATCOPY);
    PatBlt(hdc, x+2, y+2, 7, 1, PATCOPY);
    PatBlt(hdc, x+3, y+3, 5, 1, PATCOPY);
    PatBlt(hdc, x+4, y+4, 3, 1, PATCOPY);
    PatBlt(hdc, x+5, y+5, 1, 1, PATCOPY);

    SelectObject(hdc, hbr);
    lprc->right = x;
}

void NEAR PASCAL DrawRightArrow(LPDRAWITEMSTRUCT lpdis)
{
    HDC hdc = lpdis->hDC;
    LPRECT lprc = &(lpdis->rcItem);
    BOOL bDisabled = lpdis->itemState & ODS_DISABLED;

    HBRUSH hbr;
    int x, y;


    x = (lprc->right / 2) - 2;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 5);

    if (bDisabled)
    {
	hbr = GetSysColorBrush(COLOR_3DHILIGHT);
	hbr = SelectObject(hdc, hbr);

	x++;
	y++;
	PatBlt(hdc, x, y, 5, 1, PATCOPY);
	PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
	PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

	SelectObject(hdc, hbr);
	x--;
	y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 1, 1, PATCOPY);
    PatBlt(hdc, x, y+1, 2, 1, PATCOPY);
    PatBlt(hdc, x, y+2, 3, 1, PATCOPY);
    PatBlt(hdc, x, y+3, 4, 1, PATCOPY);
    PatBlt(hdc, x, y+4, 5, 1, PATCOPY);
    PatBlt(hdc, x, y+5, 4, 1, PATCOPY);
    PatBlt(hdc, x, y+6, 3, 1, PATCOPY);
    PatBlt(hdc, x, y+7, 2, 1, PATCOPY);
    PatBlt(hdc, x, y+8, 1, 1, PATCOPY);


    SelectObject(hdc, hbr);
    lprc->right = x;
}

void NEAR PASCAL DrawLeftArrow(LPDRAWITEMSTRUCT lpdis)
{
    HDC hdc = lpdis->hDC;
    LPRECT lprc = &(lpdis->rcItem);
    BOOL bDisabled = lpdis->itemState & ODS_DISABLED;

    HBRUSH hbr;
    int x, y;


    x = (lprc->right / 2) + 2;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 5);

    if (bDisabled)
    {
	hbr = GetSysColorBrush(COLOR_3DHILIGHT);
	hbr = SelectObject(hdc, hbr);

	x++;
	y++;
	PatBlt(hdc, x, y, 5, 1, PATCOPY);
	PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
	PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

	SelectObject(hdc, hbr);
	x--;
	y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 1, 1, PATCOPY);
    PatBlt(hdc, x-1, y+1, 2, 1, PATCOPY);
    PatBlt(hdc, x-2, y+2, 3, 1, PATCOPY);
    PatBlt(hdc, x-3, y+3, 4, 1, PATCOPY);
    PatBlt(hdc, x-4, y+4, 5, 1, PATCOPY);
    PatBlt(hdc, x-3, y+5, 4, 1, PATCOPY);
    PatBlt(hdc, x-2, y+6, 3, 1, PATCOPY);
    PatBlt(hdc, x-1, y+7, 2, 1, PATCOPY);
    PatBlt(hdc, x, y+8, 1, 1, PATCOPY);


    SelectObject(hdc, hbr);
    lprc->right = x;
}


VOID InitGeneralControls(HWND hDlg)
{

	if (Control[BRIGHTNESS].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_BRIGHT_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_BRIGHTNESS), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_BRIGHT_SLIDER, BRIGHTNESS);
	}
		
	if (Control[CONTRAST].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_CONTRAST_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_CONTRAST), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_CONTRAST_SLIDER, CONTRAST);
	}

	if (Control[HPOS].available == TRUE ||
		Control[VPOS].available == TRUE ) {
		ShowWindow (GetDlgItem(hDlg, IDR_POSITION), SW_SHOWNORMAL);
		CheckRadioButton (hDlg, IDR_POSITION, IDR_SIZE, (HPOS + 400));
		RadioControl = HPOS;
    }

	if (Control[HSIZE].available == TRUE ||
		Control[VSIZE].available == TRUE )
		ShowWindow (GetDlgItem(hDlg, IDR_SIZE), SW_SHOWNORMAL);
	
	ShowWindow (GetDlgItem(hDlg, IDC_UP), SW_SHOWNORMAL);
	ShowWindow (GetDlgItem(hDlg, IDC_DOWN), SW_SHOWNORMAL);
	ShowWindow (GetDlgItem(hDlg, IDC_RIGHT), SW_SHOWNORMAL);
	ShowWindow (GetDlgItem(hDlg, IDC_LEFT), SW_SHOWNORMAL);
											
	ShowWindow (GetDlgItem(hDlg, IDC_RED_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RED_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_BLACK), SW_HIDE);

	ShowWindow (GetDlgItem(hDlg, IDC_PARALLEL_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_PARALLEL), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TRAPEZOID_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TRAPEZOID), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TILT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TILT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_BALANCE_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN_BALANCE), SW_HIDE);
	
}

VOID InitColorControls(HWND hDlg)
{
	if (Control[RED_GAIN].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_RED_GAIN_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_RED_GAIN), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_RED_GAIN_SLIDER, RED_GAIN);
	}
		
	if (Control[GREEN_GAIN].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_GREEN_GAIN_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_GREEN_GAIN), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_GREEN_GAIN_SLIDER, GREEN_GAIN);
	}
		
	if (Control[BLUE_GAIN].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_BLUE_GAIN_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_BLUE_GAIN), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_BLUE_GAIN_SLIDER, BLUE_GAIN);
	}

    	//
	// Sounds like these controls should not be exposed.
	//
		
	// if (Control[RED_BLACK].available == TRUE) {
	//	ShowWindow (GetDlgItem(hDlg, IDT_RED_BLACK), SW_SHOWNORMAL);
	//	ShowWindow (GetDlgItem(hDlg, IDC_RED_BLACK_SLIDER), SW_SHOWNORMAL);
	//	InitSlider(hDlg, IDC_RED_BLACK_SLIDER, RED_BLACK);
	// }
		
	// if (Control[GREEN_BLACK].available == TRUE) {
	//	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_BLACK_SLIDER), SW_SHOWNORMAL);
	//	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_BLACK), SW_SHOWNORMAL);
	//	InitSlider(hDlg, IDC_GREEN_BLACK_SLIDER, GREEN_BLACK);
	// }
		
	// if (Control[BLUE_BLACK].available == TRUE) {
	//	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_BLACK_SLIDER), SW_SHOWNORMAL);
	//	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_BLACK), SW_SHOWNORMAL);
	//	InitSlider(hDlg, IDC_BLUE_BLACK_SLIDER, BLUE_BLACK);
	// }
	
	ShowWindow (GetDlgItem(hDlg, IDC_BRIGHT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BRIGHTNESS), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_CONTRAST_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_CONTRAST), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_SIZE), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_POSITION), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_UP), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_DOWN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_LEFT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RIGHT), SW_HIDE);


	ShowWindow (GetDlgItem(hDlg, IDC_PARALLEL_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_PARALLEL), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TRAPEZOID_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TRAPEZOID), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TILT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TILT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_BALANCE_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN_BALANCE), SW_HIDE);
}

VOID InitAdvancedControls(HWND hDlg)
{
	if (Control[PARALLEL].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_PARALLEL_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_PARALLEL), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_PARALLEL_SLIDER, PARALLEL);
	}
	if (Control[TRAPEZOID].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_TRAPEZOID_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_TRAPEZOID), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_TRAPEZOID_SLIDER, TRAPEZOID);
	}
	if (Control[TILT].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_TILT_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_TILT), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_TILT_SLIDER, TILT);
	}
						
	if (Control[HPIN].available == TRUE){
		ShowWindow (GetDlgItem(hDlg, IDC_HPIN_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_HPIN), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_HPIN_SLIDER, HPIN);
	}

	if (Control[HPIN_BALANCE].available == TRUE) {
		ShowWindow (GetDlgItem(hDlg, IDC_HPIN_BALANCE_SLIDER), SW_SHOWNORMAL);
		ShowWindow (GetDlgItem(hDlg, IDT_HPIN_BALANCE), SW_SHOWNORMAL);
		InitSlider(hDlg, IDC_HPIN_BALANCE_SLIDER, HPIN_BALANCE);
	}
	
	ShowWindow (GetDlgItem(hDlg, IDC_BRIGHT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BRIGHTNESS), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_CONTRAST_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_CONTRAST), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_SIZE), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_POSITION), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_UP), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_DOWN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_LEFT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RIGHT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RED_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RED_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_BLACK), SW_HIDE);
							
}

VOID InitControlStuct()
{

//  Fills in a global Monitor Control Stucture with the
//  appropiate values for each control defined.

//	Control[DEGAUSS].usagepage = DEGAUSS_USAGE_PAGE;
//	Control[DEGAUSS].usage = DEGAUSS_USAGE;
//	Control[DEGAUSS].available = FALSE;

	Control[BRIGHTNESS].usagepage = BRIGHTNESS_USAGE_PAGE;
	Control[BRIGHTNESS].usage = BRIGHTNESS_USAGE;
	Control[BRIGHTNESS].available = FALSE;

	Control[CONTRAST].usagepage = CONTRAST_USAGE_PAGE;
	Control[CONTRAST].usage = CONTRAST_USAGE;
	Control[CONTRAST].available = FALSE;

	Control[TILT].usagepage = TILT_USAGE_PAGE;
	Control[TILT].usage = TILT_USAGE;
	Control[TILT].available = FALSE;

	Control[TRAPEZOID].usagepage = TRAPEZOID_USAGE_PAGE;
	Control[TRAPEZOID].usage = TRAPEZOID_USAGE;
	Control[TRAPEZOID].available = FALSE;

	Control[PARALLEL].usagepage = PARALLEL_USAGE_PAGE;
	Control[PARALLEL].usage = PARALLEL_USAGE;
	Control[PARALLEL].available = FALSE;
			
	Control[RED_GAIN].usagepage = RED_GAIN_USAGE_PAGE;
	Control[RED_GAIN].usage = RED_GAIN_USAGE;
	Control[RED_GAIN].available = FALSE;

	Control[GREEN_GAIN].usagepage = GREEN_GAIN_USAGE_PAGE;
	Control[GREEN_GAIN].usage = GREEN_GAIN_USAGE;
	Control[GREEN_GAIN].available = FALSE;

	Control[BLUE_GAIN].usagepage = BLUE_GAIN_USAGE_PAGE;
	Control[BLUE_GAIN].usage = BLUE_GAIN_USAGE;
	Control[BLUE_GAIN].available = FALSE;

	Control[RED_BLACK].usagepage = RED_BLACK_USAGE_PAGE;
	Control[RED_BLACK].usage = RED_BLACK_USAGE;
	Control[RED_BLACK].available = FALSE;

	Control[GREEN_BLACK].usagepage = GREEN_BLACK_USAGE_PAGE;
	Control[GREEN_BLACK].usage = GREEN_BLACK_USAGE;
	Control[GREEN_BLACK].available = FALSE;

	Control[BLUE_BLACK].usagepage = BLUE_BLACK_USAGE_PAGE;
	Control[BLUE_BLACK].usage = BLUE_BLACK_USAGE;
	Control[BLUE_BLACK].available =FALSE;
		
	Control[HPIN].usagepage = HPIN_USAGE_PAGE;
	Control[HPIN].usage = HPIN_USAGE;
	Control[HPIN].available = FALSE;

	Control[VPIN].usagepage = VPIN_USAGE_PAGE;
	Control[VPIN].usage = VPIN_USAGE;
	Control[VPIN].available = FALSE;

	Control[HPIN_BALANCE].usagepage = HPIN_BALANCE_USAGE_PAGE;
	Control[HPIN_BALANCE].usage = HPIN_BALANCE_USAGE;
	Control[HPIN_BALANCE].available = FALSE;

	Control[VPIN_BALANCE].usagepage = VPIN_BALANCE_USAGE_PAGE;
	Control[VPIN_BALANCE].usage = VPIN_BALANCE_USAGE;
	Control[VPIN_BALANCE].available = FALSE;

	Control[HLIN].usagepage = HLIN_USAGE_PAGE;
	Control[HLIN].usage = HLIN_USAGE;
	Control[HLIN].available = FALSE;

	Control[VLIN].usagepage = VLIN_USAGE_PAGE;
	Control[VLIN].usage = VLIN_USAGE;
	Control[VLIN].available = FALSE;

	Control[HPOS].usagepage = HPOS_USAGE_PAGE;
	Control[HPOS].usage = HPOS_USAGE;
	Control[HPOS].available = FALSE;

	Control[VPOS].usagepage = VPOS_USAGE_PAGE;
	Control[VPOS].usage = VPOS_USAGE;
	Control[VPOS].available = FALSE;

	Control[HSIZE].usagepage = HSIZE_USAGE_PAGE;
	Control[HSIZE].usage = HSIZE_USAGE;
	Control[HSIZE].available = FALSE;

	Control[VSIZE].usagepage = VSIZE_USAGE_PAGE;
    Control[VSIZE].usage = VSIZE_USAGE;
	Control[VSIZE].available = FALSE;

	Control[SETTINGS].usagepage = SETTINGS_USAGE_PAGE;
	Control[SETTINGS].usage = SETTINGS_USAGE;
	Control[SETTINGS].available = FALSE;
}

VOID InitSlider(HWND hDlg, int iSlider, int iUSB_Control)
{
        //  Set appropraite range for slider.
    SendDlgItemMessage (hDlg, iSlider, TBM_SETRANGEMAX, 0, 
                        Control[iUSB_Control].max);

    SendDlgItemMessage (hDlg, iSlider, TBM_SETRANGEMIN, TRUE, 
                        Control[iUSB_Control].min);                                                 

         //  Setting slider to current value of control
    SendDlgItemMessage (hDlg, iSlider, TBM_SETPOS, TRUE,
                        Control[iUSB_Control].value);
}

VOID InitMonitor(HWND hDlg)
{
    int i, x;
    USHORT              usValueCapsLength;
    PHIDP_VALUE_CAPS    pValueCaps, pValWalk;
    NTSTATUS status;
    char TempText[100] = "";

    PHIDP_LINK_COLLECTION_NODE  LinkCollectionNodes;
    PHIDP_BUTTON_CAPS           ButtonCaps;

    ULONG                       LinkLength;
    

    // Remove any entries from the option drop down list.
    i = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_GETCOUNT, 0, 0);
    if (CB_ERR != i) {
        while(i) {
            i = (int)SendDlgItemMessage(hDlg, IDC_OPTION, CB_DELETESTRING, i-1, 0);
            if (CB_ERR == i){
            i = 0;
            }
        }
    }


    usValueCapsLength = HidDevice->Caps.NumberFeatureValueCaps;
      // allocate memory for the caps struct
    pValueCaps = (PHIDP_VALUE_CAPS) calloc (usValueCapsLength, 
                                            sizeof(HIDP_VALUE_CAPS));

      // Get the HID device Capabilities
    status = HidP_GetValueCaps(HidP_Feature,
                               pValueCaps,
                               &usValueCapsLength,
                               HidDevice -> Ppd);
                       				     	  
				    
      // Initialize all Caps
    pValWalk = pValueCaps;
						
      // Disable all controls
    for (i = 1; i < MAXCONTROLS; i++)
        Control[i].available = FALSE;

      // Loop through all detected caps and compare with values in the
      // spec.  If they match enable the control.
    for (x = 0; x < ((int) usValueCapsLength); x++) {
				
        for (i = 1; i < MAXCONTROLS; i++) {
								
            if (Control[i].usagepage == pValueCaps->UsagePage &&
                Control[i].usage == pValueCaps->NotRange.Usage) {
		    	    		
                  // MUST ENABLE CONTROL HERE!!!
                Control[i].max = pValueCaps->LogicalMax;
                Control[i].min = pValueCaps->LogicalMin;
                Control[i].reportid = pValueCaps->ReportID;
                Control[i].available = TRUE;
                Control[i].HasControlChanged = FALSE;

                  //
                  // Set the ReportID to the first byte in the buffer.  This tells
                  //    the system which ReportID it should retrieve the feature report
                  //    value for
                  // 
                *(HidDevice -> FeatureReportBuffer) = Control[i].reportid;
                               
                status = HidD_GetFeature(HidDevice->HidDevice,
                                         HidDevice->FeatureReportBuffer,
                                         HidDevice->Caps.FeatureReportByteLength);
			    	    		
                status = HidP_GetUsageValue(HidP_Feature,
                                            Control[i].usagepage,
                                            0,
                                            Control[i].usage,
                                            &Control[i].value,
                                            HidDevice->Ppd,
                                            HidDevice->FeatureReportBuffer,
                                            HidDevice->Caps.FeatureReportByteLength); 
									
								
                Control[i].OriginalValue = Control[i].value;
                  // Zero out the buffer so we can use it again.
                memset (HidDevice->FeatureReportBuffer, 0x00, 
                        HidDevice->Caps.FeatureReportByteLength);

            }  // End if control usagepage
					
        } //End for
        pValueCaps++;  // Move to the next cap.
							
    } // End for
    pValueCaps = pValWalk;  // Reset to begining of array

      // Special Case for DEGAUSS.  Same as above.
    for (x = 0; x < ((int) usValueCapsLength); x++) {
						
        if (DEGAUSS_USAGE_PAGE == pValueCaps->UsagePage &&
            DEGAUSS_USAGE == pValueCaps->NotRange.Usage) {
		    	    		
            ShowWindow (GetDlgItem(hDlg, IDC_DEGAUSS), SW_SHOWNORMAL);
		   					
        } else {
            ShowWindow (GetDlgItem(hDlg, IDC_DEGAUSS), SW_HIDE);
        } // end if actual value caps length
                                                   
        pValueCaps++;  // Move to the next cap.
							
    } // End for
    pValueCaps = pValWalk;  // Reset to begining of array


        // Special Case for Settings.
    ShowWindow (GetDlgItem(hDlg, IDC_RESET), SW_HIDE);

    // Need a link collection buffer
    LinkCollectionNodes = malloc(HidDevice->Caps.NumberLinkCollectionNodes * 
                                 sizeof(HIDP_LINK_COLLECTION_NODE)); 

    LinkLength = (ULONG)HidDevice->Caps.NumberLinkCollectionNodes;

    status = HidP_GetLinkCollectionNodes(
                       LinkCollectionNodes,
                       &LinkLength,
                       HidDevice -> Ppd);

    Control[SETTINGS].linkcollection = 0;
             // 
    if (status == HIDP_STATUS_SUCCESS) {
        for (i = 0; i < HidDevice->Caps.NumberLinkCollectionNodes; i++) {
            if (LinkCollectionNodes->LinkUsage == SETTINGS_USAGE &&
                LinkCollectionNodes->LinkUsagePage == SETTINGS_USAGE_PAGE) {

                Control[SETTINGS].linkcollection = (USHORT)i;
            }
            LinkCollectionNodes++;
        }
    } 
                        
    ButtonCaps = malloc(HidDevice->Caps.NumberFeatureButtonCaps *
                        sizeof(HIDP_BUTTON_CAPS));

    status = HidP_GetButtonCaps(HidP_Feature,
                                        ButtonCaps,
                                        &HidDevice->Caps.NumberFeatureButtonCaps,
                                        HidDevice->Ppd);

    for (i = 0; i < HidDevice->Caps.NumberFeatureButtonCaps; i++) {
        if (ButtonCaps->UsagePage == SETTINGS_RESET_USAGE_PAGE &&
            ButtonCaps->NotRange.Usage == SETTINGS_RESET_USAGE &&
            ButtonCaps->LinkCollection == Control[SETTINGS].linkcollection) {

            ShowWindow (GetDlgItem(hDlg, IDC_RESET), SW_SHOWNORMAL);
        }
        ButtonCaps++;
    }                                                   

    pValueCaps = pValWalk;  // Reset to begining of array
    free(LinkCollectionNodes);
    free(ButtonCaps);    
    free(pValueCaps);  // Give the memory back.

    if (Control[BRIGHTNESS].available == TRUE ||
        Control[CONTRAST].available == TRUE ||
        Control[HPOS].available == TRUE ||
        Control[VPOS].available == TRUE ||
        Control[HSIZE].available == TRUE ||
        Control[VSIZE].available == TRUE) {

        sprintf(TempText, "General");                    
        x = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_ADDSTRING, 0, (LPARAM) TempText);

        InitGeneralControls(hDlg);
        i = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_SETCURSEL, 0, 0);
			
    }

    if (Control[RED_GAIN].available == TRUE ||
        Control[GREEN_GAIN].available == TRUE ||
        Control[BLUE_GAIN].available == TRUE ||
        Control[RED_BLACK].available == TRUE ||
        Control[GREEN_BLACK].available == TRUE ||
        Control[BLUE_BLACK].available == TRUE) {

        sprintf(TempText, "Color");
        x = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_ADDSTRING, 0, (LPARAM) TempText);

    }

    if (Control[PARALLEL].available == TRUE ||
        Control[TRAPEZOID].available == TRUE ||
        Control[TILT].available == TRUE ||
        Control[HPIN].available == TRUE ||
        Control[HPIN_BALANCE].available == TRUE) {

        sprintf(TempText, "Advanced");
        x = (int)SendDlgItemMessage (hDlg, IDC_OPTION, CB_ADDSTRING, 0, (LPARAM) TempText);
    }
}

VOID InitWindows(HWND hDlg)
{
	ShowWindow (GetDlgItem(hDlg, IDC_BRIGHT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BRIGHTNESS), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_CONTRAST_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_CONTRAST), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_SIZE), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDR_POSITION), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_UP), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_DOWN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_LEFT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RIGHT), SW_HIDE);		
	ShowWindow (GetDlgItem(hDlg, IDC_RED_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_GAIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_GAIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RED_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_RED_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_GREEN_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_GREEN_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_BLUE_BLACK_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_BLUE_BLACK), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_PARALLEL_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_PARALLEL), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TRAPEZOID_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TRAPEZOID), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_TILT_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_TILT), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_HPIN_BALANCE_SLIDER), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDT_HPIN_BALANCE), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_DEGAUSS), SW_HIDE);
	ShowWindow (GetDlgItem(hDlg, IDC_RESET), SW_HIDE);
}

//  Reset control to original value if user cancels changes.

VOID ResetControls() {

    int i;

    for (i = 0; i < MAXCONTROLS; i++) {
        if (Control[i].HasControlChanged) {
            ChangeFeature (Control[i].usagepage, 
                           Control[i].usage, 
                           Control[i].OriginalValue);
        }
    }
}

//  Reset controls if the user applys changes.

VOID ApplyControls() {

    int i;

    for (i = 0; i < MAXCONTROLS; i++) {
        Control[i].HasControlChanged = FALSE;
        Control[i].OriginalValue = Control[i].value;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\mem.c ===
/*****************************************************************************
 *
 *	mem.c - Memory management
 *
 *	WARNING!  These do not go through OLE allocation.  Use these
 *	only for private allocation.
 *
 *****************************************************************************/

#include "map.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *	ReallocCbPpv
 *
 *	Change the size of some zero-initialized memory.
 *
 *	This is the single place where all memory is allocated, resized,
 *	and freed.
 *
 *	If you realloc from a null pointer, memory is allocated.
 *	If you realloc to zero-size, memory is freed.
 *
 *	These semantics avoid boundary cases.  For example, it is no
 *	longer a problem trying to realloc something down to zero.
 *	You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *	If an error is returned, the original pointer is UNCHANGED.
 *	This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {			    /* Alloc or realloc */
	if (hloc) {		    /* Realloc */
	    hloc = LocalReAlloc(hloc, cb,
				LMEM_MOVEABLE+LMEM_ZEROINIT);
	} else {		/* Alloc */
	    hloc = LocalAlloc(LPTR, cb);
	}
	hres = hloc ? NOERROR : E_OUTOFMEMORY;
    } else {			/* Freeing */
	if (hloc) {
	    LocalFree(hloc);
	    hloc = 0;
	    hres = NOERROR;	/* All gone */
	} else {
	    hres = NOERROR;	/* Nothing to free */
	}
    }

    if (SUCCEEDED(hres)) {
	*ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\monitor.h ===
// MONITOR.H
// Contains USB Monitor cotrol usages and usage pages

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <wtypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include "hidsdi.h"
#include "hid.h"


// Func
VOID ChangeFeature(USAGE UsagePage, USAGE Usage, int Value);
VOID vLoadDevices();
VOID InitControlStuct();
VOID InitGeneralControls(HWND hDlg);
VOID InitColorControls(HWND hDlg);
VOID InitAdvancedControls(HWND hDlg);
VOID InitSlider(HWND hDlg, int iSlider, int iUSB_Control);
VOID InitMonitor(HWND hDlg);
VOID InitWindows(HWND hDlg);
VOID ResetControls();
VOID ApplyControls();

void NEAR PASCAL DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis);
void NEAR PASCAL DrawUpArrow(LPDRAWITEMSTRUCT lpdis);
void NEAR PASCAL DrawDownArrow(LPDRAWITEMSTRUCT lpdis);
void NEAR PASCAL DrawRightArrow(LPDRAWITEMSTRUCT lpdis);
void NEAR PASCAL DrawLeftArrow(LPDRAWITEMSTRUCT lpdis);

typedef struct _MONITOR_CONTROL {
	long	min;
	long	max;
	long	value;
	long    OriginalValue;
	USAGE	usagepage;
	USAGE	usage;
	USHORT  linkcollection;
	UCHAR	reportid;
	BOOL	available;
	BOOL    HasControlChanged;
} MONITOR_CONTROL, *PMONITOR_CONTROL;


// Control ID's
#define IDC_HSLIDER             301
#define IDS_NAME                302
#define IDS_INFO                303
#define IDC_MON                 304
#define IDI_MON                 305
#define IDC_BOX                 306
#define IDC_VSLIDER             307
#define IDC_OPTION              308
#define IDC_PIN                 309
#define IDC_MONSIZE             310
#define IDC_POS                 311
#define IDC_TILT                312
#define IDC_TRAPEZOID           313
#define IDC_PARALLEL            314
#define IDC_BLUE_GAIN           315
#define IDC_BLUE_BLACK          316
#define IDC_GREEN_GAIN          317
#define IDC_GREEN_BLACK         318
#define IDC_RED_GAIN            319
#define IDC_RED_BLACK           320
#define IDC_DEGAUSS             321
#define IDC_CONTRAST            322
#define IDC_BRIGHTNESS          323
#define IDC_PIN_BALANCE         324
#define IDC_LIN                 325
#define IDC_UP                  326
#define IDC_DOWN                327
#define IDC_LEFT                328
#define IDC_RIGHT               329
#define IDC_RESET               330
#define IDT_TEST                331
#define IDT_BRIGHTNESS          332
#define IDT_CONTRAST            333
#define IDT_RED_GAIN            336
#define IDT_GREEN_GAIN          337
#define IDT_BLUE_GAIN           338
#define IDT_RED_BLACK           339
#define IDT_GREEN_BLACK         340
#define IDT_BLUE_BLACK          341
#define IDT_PARALLEL            342
#define IDT_TRAPEZOID           343
#define IDT_TILT                344
#define IDT_HPIN                345
#define IDT_HPIN_BALANCE        346

// Slider values must be 400 more than control value
#define IDC_BRIGHT_SLIDER       401
#define IDC_CONTRAST_SLIDER     402
#define IDC_RED_GAIN_SLIDER     403
#define IDC_GREEN_GAIN_SLIDER   404
#define IDC_BLUE_GAIN_SLIDER    405

#define IDR_POSITION            407
#define IDR_SIZE                408
#define IDC_HPIN_SLIDER         409
#define IDC_HPIN_BALANCE_SLIDER 410

#define IDC_PARALLEL_SLIDER     421
#define IDC_TRAPEZOID_SLIDER    422
#define IDC_TILT_SLIDER         423

#define IDC_RED_BLACK_SLIDER    430
#define IDC_GREEN_BLACK_SLIDER  431
#define IDC_BLUE_BLACK_SLIDER   432

// Dialog Box ID's
#define MON_GENERAL             201
#define MON_COLOR               202


// Number of controls to support
#define MAXCONTROLS 36 

// Control Usages from USBMCCS 1.0
// Brightness
#define BRIGHTNESS              1
#define BRIGHTNESS_USAGE_PAGE   0x0082
#define BRIGHTNESS_USAGE        0x0010

// Contrast
#define CONTRAST                2
#define CONTRAST_USAGE_PAGE     0x0082
#define CONTRAST_USAGE          0x0012

// Red Video Gain
#define RED_GAIN                3
#define RED_GAIN_USAGE_PAGE     0x0082
#define RED_GAIN_USAGE          0x0016

// Green Video Gain
#define GREEN_GAIN              4
#define GREEN_GAIN_USAGE_PAGE   0x0082
#define GREEN_GAIN_USAGE        0x0018

// Blue Video Gain
#define BLUE_GAIN               5
#define BLUE_GAIN_USAGE_PAGE    0x0082
#define BLUE_GAIN_USAGE         0x001A

// Focus
#define FOCUS                   6
#define FOCUS_USAGE_PAGE        0x0082
#define FOCUS_USAGE             0x001C

// Horizontal Position
#define HPOS                    7
#define HPOS_USAGE_PAGE         0x0082
#define HPOS_USAGE              0x0020

// Horizontal Size
#define HSIZE                   8
#define HSIZE_USAGE_PAGE        0x0082
#define HSIZE_USAGE             0x0022

// Horizontal Pincusion
#define HPIN                    9
#define HPIN_USAGE_PAGE         0x0082
#define HPIN_USAGE              0x0024

// Horizontal Pincusion Balance
#define HPIN_BALANCE            10
#define HPIN_BALANCE_USAGE_PAGE 0x0082
#define HPIN_BALANCE_USAGE      0x0026

// Horizontal Misconvergence
#define HMISCON                 11
#define HMISCON_USAGE_PAGE      0x0082
#define HMISCON_USAGE           0x0028

// Horizontal Linearity
#define HLIN                    12
#define HLIN_USAGE_PAGE         0x0082
#define HLIN_USAGE              0x002A

// Horizontal Linearity Balance
#define HLIN_BALANCE            13
#define HLIN_BALANCE_USAGE_PAGE 0x0082
#define HLIN_BALANCE_USAGE      0x002C

// Vertical Position
#define VPOS                    14
#define VPOS_USAGE_PAGE         0x0082
#define VPOS_USAGE              0x0030

// Vertical Size
#define VSIZE                   15
#define VSIZE_USAGE_PAGE        0x0082
#define VSIZE_USAGE             0x0032

// Vertical Pincushion
#define VPIN                    16
#define VPIN_USAGE_PAGE         0x0082
#define VPIN_USAGE              0x0034

// Vertical Pincushion Balance
#define VPIN_BALANCE            17
#define VPIN_BALANCE_USAGE_PAGE 0x0082
#define VPIN_BALANCE_USAGE      0x0036

// Vertical Misconvergence
#define VMISCON                 18
#define VMISCON_USAGE_PAGE      0x0082
#define VMISCON_USAGE           0x0038

// Vertical Linearity
#define VLIN                    19
#define VLIN_USAGE_PAGE         0x0082
#define VLIN_USAGE              0x003A

// Vertical Linearity Balance
#define VLIN_BALANCE            20
#define VLIN_BALANCE_USAGE_PAGE 0x0082
#define VLIN_BALANCE_USAGE      0x003C

// Parallelogram Distoriton (Key Balance)
#define PARALLEL                21
#define PARALLEL_USAGE_PAGE     0x0082
#define PARALLEL_USAGE          0x0040

// Trapezoidal Distortion (Key)
#define TRAPEZOID               22
#define TRAPEZOID_USAGE_PAGE    0x0082
#define TRAPEZOID_USAGE         0x0042

// Tilt (Rotation)
#define TILT                    23
#define TILT_USAGE_PAGE         0x0082
#define TILT_USAGE              0x0044

// Top Corner Distortion Control
#define TOP_CONTROL             24
#define TOP_CONTROL_USAGE_PAGE  0x0082
#define TOP_CONTROL_USAGE       0x0046

// Top Corner Distortion Balance
#define TOP_BALANCE             25
#define TOP_BALANCE_USAGE_PAGE  0x0082
#define TOP_BALANCE_USAGE       0x0048

// Bottom Corner Distortion Control
#define BOTTOM_CONTROL          26
#define BOTTOM_CONTROL_USAGE_PAGE  0x0082
#define BOTTOM_CONTROL_USAGE    0x004A

// Bottom Corner Distortion Balance
#define BOTTOM_BALANCE          27
#define BOTTOM_BALANCE_USAGE_PAGE  0x0082
#define BOTTOM_BALANCE_USAGE    0x004C

// Horizontal Moire
#define HMOIRE                  28
#define HMOIRE_USAGE_PAGE       0x0082
#define HMOIRE_USAGE            0x0056

// Vertical Moire
#define VMOIRE                  29
#define VMOIRE_USAGE_PAGE       0x0082
#define VMOIRE_USAGE            0x0058

// Red Video Black Level
#define RED_BLACK               30
#define RED_BLACK_USAGE_PAGE    0x0082
#define RED_BLACK_USAGE         0x006C

// Green Video Black Level
#define GREEN_BLACK             31
#define GREEN_BLACK_USAGE_PAGE  0x0082
#define GREEN_BLACK_USAGE       0x006E

// Blue Video Black Level
#define BLUE_BLACK              32
#define BLUE_BLACK_USAGE_PAGE   0x0082
#define BLUE_BLACK_USAGE        0x0070

// Input Level Select
#define INPUT_LEVEL             33
#define INPUT_LEVEL_USAGE_PAGE  0x0082
#define INPUT_LEVEL_USAGE       0x005E

// Input Source Select
#define INPUT_SOURCE            34
#define INPUT_SOURCE_USAGE_PAGE 0x0082
#define INPUT_SOURCE_USAGE      0x0060

// StereoMode
#define STEREOMODE              35
#define STEREOMODE_USAGE_PAGE   0x0082
#define STEREOMODE_USAGE        0x00D4

// Settings
#define SETTINGS                36
#define SETTINGS_USAGE_PAGE     0x0082
#define SETTINGS_USAGE          0x00B0

#define SETTINGS_RESET_USAGE_PAGE 0x0081
#define SETTINGS_RESET_USAGE      0x0002

// Degauss
#define DEGAUSS                 37
#define DEGAUSS_USAGE_PAGE      0x0082
#define DEGAUSS_USAGE           0x0001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\monitor\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

// #include <stdlib.h>
// #include <wtypes.h>
// #include <setupapi.h>
#include "monitor.h"
// #include "hid.h"
// #include "hidsdi.h"
// #include <cfgmgr32.h>
#include "map.h"

extern HWND g_hwndDlg;
extern int DeviceLoaded;

BOOLEAN
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PHID_DEVICE                 HidDevice
    );

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PHID_DEVICE              hidDeviceInst;
   GUID                     hidGuid;

   // HKEY		hKeyDev;
   DWORD	ii = 50;
   CHAR		keyName[] = "DriverDesc";
   LONG		lReg;
   CHAR	niceName[50] = "foo";
   SP_DEVINFO_DATA	DevInfoData;
   DEVINST dnDevInst;
   ULONG	len;
   int		iIndex;

   memset(&DevInfoData, 0, sizeof(SP_DEVINFO_DATA));
   DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

   HidD_GetHidGuid (&hidGuid);

   *HidDevices = NULL;
   *NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           &hidGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess to start
   //
   *NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      *NumberDevices *= 2;

      if (*HidDevices) {
         *HidDevices =
               realloc (*HidDevices, (*NumberDevices * sizeof (HID_DEVICE)));
      } else {
         *HidDevices = calloc (*NumberDevices, sizeof (HID_DEVICE));
      }

      if (NULL == *HidDevices) {
         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return FALSE;
      }

      hidDeviceInst = *HidDevices + i;

      for (; i < *NumberDevices; i++, hidDeviceInst++) {
         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                          0, // No care about specific PDOs
                                          &hidGuid,
                                          i,
                                          &deviceInfoData)) {

            OpenHidDevice (hardwareDeviceInfo, &deviceInfoData, hidDeviceInst);

         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }

		// This stuff gets the name out of the registry.

  		 if (hidDeviceInst->Caps.UsagePage == 0x80) {

       	 	lReg = SetupDiEnumDeviceInfo(hardwareDeviceInfo,
                                             i,
                                             &DevInfoData);

                CM_Get_Parent(&dnDevInst,
                              DevInfoData.DevInst,
                              0);

                len = sizeof(niceName);
                CM_Get_DevNode_Registry_Property(dnDevInst,
                                                 CM_DRP_DEVICEDESC,
                                                 NULL,
                                                 niceName,
                                                 &len,
                                                 0);
       	 									 
                iIndex = (int)SendDlgItemMessage (g_hwndDlg, 
                                                 IDC_MON, 
                                                 CB_ADDSTRING, 
                                                 (WPARAM)0, 
                                                 (LPARAM) niceName);
	      								
                if (-1 != iIndex) {
                    SendDlgItemMessage(g_hwndDlg, 
                                       IDC_MON, 
                                       CB_SETITEMDATA, 
                                       (WPARAM)iIndex,
                                       (LPARAM)hidDeviceInst);

                    DeviceLoaded = 1;
                }  //end if -1
    	  } //end if Caps.     
      }
   }

   *NumberDevices = i;

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   return TRUE;
}

BOOLEAN
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PHID_DEVICE                 HidDevice
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    ULONG                                i;
    USHORT                               numValues;
    USHORT                               numCaps;
    PHIDP_BUTTON_CAPS                    buttonCaps;
    PHIDP_VALUE_CAPS                     valueCaps;
    PHID_DATA                            data;
    USAGE                                usage;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
        return FALSE;
    }

    HidDevice->HidDevice = CreateFile (
                              functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              0, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) {
        return FALSE;
    }

    if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) {
        return FALSE;
    }

    if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) {
        HidD_FreePreparsedData (HidDevice->Ppd);
        return FALSE;
    }

    if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) {
        HidD_FreePreparsedData (HidDevice->Ppd);
        return FALSE;
    }


    //
    // At this point the client has a choise.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we look for all of the usages in the device.
    //

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //

    HidDevice->InputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.InputReportByteLength, sizeof (CHAR));


    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    HidDevice->InputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberInputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->InputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberInputValueCaps, sizeof (HIDP_VALUE_CAPS));

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = HidDevice->Caps.NumberInputButtonCaps;
    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;
    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //
    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps
                               + numValues;
    HidDevice->InputData = data = (PHID_DATA)
        calloc (HidDevice->InputDataLength, sizeof (HID_DATA));


    //
    // Fill in the button data
    //
    for (i = 0;
         i < HidDevice->Caps.NumberInputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    //
    // Fill in the value data
    //
    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //
    HidDevice->OutputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.OutputReportByteLength, sizeof (CHAR));

    HidDevice->OutputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberOutputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->OutputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberOutputValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberOutputButtonCaps;
    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberOutputValueCaps;
    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                + numValues;
    HidDevice->OutputData = data = (PHID_DATA)
       calloc (HidDevice->OutputDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberOutputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    HidDevice->FeatureReportBuffer = (PCHAR)
           calloc (HidDevice->Caps.FeatureReportByteLength, sizeof (CHAR));

    HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberFeatureButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->FeatureValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberFeatureValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                 + numValues;
    HidDevice->FeatureData = data = (PHID_DATA)
        calloc (HidDevice->FeatureDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberFeatureButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
             calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\vxdclnt\read.c ===
/*
 ********************************************************************************
 *
 *  READ.C
 *
 *
 *  VXDCLNT - Sample Ring-0 HID device mapper for Memphis
 *
 *  Copyright 1997  Microsoft Corp.
 *
 *  (ep)
 *
 ********************************************************************************
 */


#include "vxdclnt.h"



/*
 *  WorkItemCallback_Read
 *
 */
VOID WorkItemCallback_Read(PVOID context)
{
        deviceContext *device = (deviceContext *)context;
        NTSTATUS Status;

        DBGOUT(("==> WorkItemCallback_Read()"));

        device->dataLength.LowPart = device->dataLength.HighPart = 0;
        device->readPending = TRUE;

        /*
         *  Do an asynchronous read on the device device.
         *  When the device has a delta value to report, we will be called back
         *  via ReadCompletion().
         */
        Status = _NtKernReadFile(
                    device->devHandle,
                    NULL,
                    ReadCompletion,
                    (PVOID)device,                   // context for callback
                    (PIO_STATUS_BLOCK)&device->ioStatusBlock,
                    (PVOID)device->report,
                    device->hidCapabilities.InputReportByteLength,
                    &device->dataLength,
                    NULL
            );

        if (!NT_SUCCESS(Status) && (Status != STATUS_PENDING)) {
                /*
                 *  Read failed.  Since device is no longer usable, shut it down.
                 */
                DBGERR(("_NtKernReadFile error (Status=%xh) - SHUTTING DOWN THIS DEVICE", (UINT)Status));
                device->readPending = FALSE;
                DequeueDevice(device);
                DestroyDevice(device);
        }

        DBGOUT(("<== WorkItemCallback_Read()"));
}



/*
 *  DispatchNtReadFile
 *
 *
 */
VOID _cdecl DispatchNtReadFile(deviceContext *device)
{
        DBGOUT(("==> DispatchNtReadFile()"));
        /*
         *  Queue a work item to do the read; this way we'll be on a worker thread
         *  instead of (possibly) the NTKERN thread when we call NtReadFile().
         *  This prevents a contention bug.
         */
        _NtKernQueueWorkItem(&device->workItemRead, DelayedWorkQueue);

        DBGOUT(("<== DispatchNtReadFile()"));
}




/*
 *  ReadCompletion
 *
 *
 */
VOID ReadCompletion(IN PVOID Context, IN PIO_STATUS_BLOCK IoStatusBlock, IN ULONG Reserved)
{
        ULONG dX = 0, dY = 0, Buttons = 0, scrollWheel=0;
        NTSTATUS ntStatus;
        deviceContext *device = (deviceContext *)Context;
        UINT numActualButtons;

        DBGOUT(("==> ReadCompletion()"));

        device->readPending = FALSE;

        /*
         *  If this callback got to us after we've shut down, just delete this device context.
         */
        if (ShutDown){
            TryDestroyAll();
            return;
        }


        /*
         *  If the read succeeded, parse out the report information.
         */
        if (NT_SUCCESS(IoStatusBlock->Status)){


                /*
                 *  <<COMPLETE>>
                 *
                 *  What types of usage-values will you parse out of the device report?
                 *  This is device specific.
                 *  The code below would be appropriate for a 2-dimensional pointing
                 *  device with buttons (e.g. a mouse or touch screen).
                 *
                 */


                /*
                 *  Parse the device "report" for the values we want.
                 *
                 *  For each value, try HIDPARSE's scaled function first;
                 *  failing that, try the non-scaled function.
                 *  (the scaled functions can fail for some devices that don't
                 *   report their min and max values correctly).
                 */

                ntStatus = pHidP_GetScaledUsageValue(HidP_Input,
                                          HID_USAGE_PAGE_GENERIC,
                                          0,
                                          HID_USAGE_GENERIC_X,
                                          (PLONG)&dX,
                                          device->hidDescriptor,
                                          (PUCHAR)device->report,
                                          device->hidCapabilities.InputReportByteLength);
                if (NT_ERROR(ntStatus)){
                    DBGERR(("pHidP_GetScaledUsageValue failed"));

                    ntStatus = pHidP_GetUsageValue(HidP_Input,
                                              HID_USAGE_PAGE_GENERIC,
                                              0,
                                              HID_USAGE_GENERIC_X,
                                              &dX,
                                              device->hidDescriptor,
                                              (PUCHAR)device->report,
                                              device->hidCapabilities.InputReportByteLength);
                    if (NT_ERROR(ntStatus)){
                        DBGERR(("pHidP_GetUsageValue failed"));
                    }
                }

                ntStatus = pHidP_GetScaledUsageValue(HidP_Input,
                                          HID_USAGE_PAGE_GENERIC,
                                          0,
                                          HID_USAGE_GENERIC_Y,
                                          (PLONG)&dY,
                                          device->hidDescriptor,
                                          (PUCHAR)device->report,
                                          device->hidCapabilities.InputReportByteLength);
                if (NT_ERROR(ntStatus)){
                    DBGERR(("pHidP_GetScaledUsageValue failed"));

                    ntStatus = pHidP_GetUsageValue(HidP_Input,
                                              HID_USAGE_PAGE_GENERIC,
                                              0,
                                              HID_USAGE_GENERIC_Y,
                                              &dY,
                                              device->hidDescriptor,
                                              (PUCHAR)device->report,
                                              device->hidCapabilities.InputReportByteLength);
                    if (NT_ERROR(ntStatus)){
                        DBGERR(("pHidP_GetUsageValue failed"));
                    }
                }


                /*
                 *  Parse the button values
                 */
                numActualButtons = device->buttonListLength;
                pHidP_GetUsages(HidP_Input,
                        HID_USAGE_PAGE_BUTTON,
                        0,
                        device->buttonValues,
                        &numActualButtons,
                        device->hidDescriptor,
                        (PUCHAR)device->report,
                        device->hidCapabilities.InputReportByteLength);





                /*
                 *  <<COMPLETE>>
                 *
                 *  What are you going to do with the parsed data from the device?
                 *  This is device specific.
                 *
                 */


        }
        else {
            DBGERR(("ReadCompletion returned ERROR %xh.", (UINT)IoStatusBlock->Status));

            /*
             *  Remove this device and then try to re-open it.
             */
            DequeueDevice(device);
            DestroyDevice(device);
            ConnectNTDeviceDrivers();
        }


        /*
         *  Set up the next read of the device device.
         */
        DispatchNtReadFile(device);

        DBGOUT(("<== ReadCompletion()"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\vxdclnt\write.c ===
/*
 ********************************************************************************
 *
 *  WRITE.C
 *
 *
 *  VXDCLNT - Sample Ring-0 HID device mapper for Memphis
 *
 *  Copyright 1997  Microsoft Corp.
 *
 *  (ep)
 *
 ********************************************************************************
 */


#include "vxdclnt.h"


writeReport *NewWriteReport(PUCHAR report, ULONG reportLen)
{
    writeReport *newReport;

    newReport = _HeapAllocate(sizeof(writeReport), 0);
    if (newReport){
        newReport->report = _HeapAllocate(reportLen, 0);
        if (newReport->report){
            RtlCopyMemory(newReport->report, report, reportLen);
            newReport->reportLen = reportLen;
            newReport->next = NULL;
        }
        else {
            _HeapFree(newReport, 0);
            newReport = NULL;
        }
    }

    return newReport;
}


VOID DestroyWriteReport(writeReport *oldReport)
{
    _HeapFree(oldReport->report, 0);
    _HeapFree(oldReport, 0);
}




VOID WorkItemCallback_Write(PVOID context)
{
    deviceContext *device = (deviceContext *)context;
    
    Wait_Semaphore(device->writeReportQueueSemaphore, 0);
    
    while (device->writeReportQueue){
        writeReport *thisReport = device->writeReportQueue;
        LARGE_INTEGER actualLengthWritten;

        actualLengthWritten.LowPart = actualLengthWritten.HighPart = 0;

        /*
         *  Write one report
         */
        _NtKernWriteFile(   device->devHandle,
                            NULL,
                            NULL,
                            0,
                            (PIO_STATUS_BLOCK)&device->ioStatusBlock,
                            (PVOID)thisReport->report,
                            thisReport->reportLen,
                            &actualLengthWritten,
                            NULL);

        device->writeReportQueue = thisReport->next;
        DestroyWriteReport(thisReport);
    }

    Signal_Semaphore_No_Switch(device->writeReportQueueSemaphore);
}


/*
 *  SendReportFromClient
 *
 *      This function is a hypothetical entry-point into this HID mapper.
 *      It sends a report from some unknown client to the HID device.
 *      In an actual HID mapper driver, this interface might be exposed as a VxD service
 *      or might be passed to another driver as an entrypoint during initialization.
 *
 *
 *      <<COMPLETE>>
 *      Note:  If you are creating your own reports, 
 *             use HidP_SetUsages() (see prototype in vxdclnt.h).
 *
 */
NTSTATUS SendReportFromClient(deviceContext *device, PUCHAR report, ULONG reportLen)
{
    writeReport *newReport;
    NTSTATUS status;

    DBGOUT(("==> SendReportFromClient()"));

    /*
     *  Enqueue this report and queue a work item to do the actual write.
     */
    newReport = NewWriteReport(report, reportLen);
    if (newReport){

        Wait_Semaphore(device->writeReportQueueSemaphore, 0);  

        if (device->writeReportQueue){
            writeReport *item;
            for (item = device->writeReportQueue; item->next; item = item->next){ }
            item->next = newReport;
        }
        else {
            device->writeReportQueue = newReport;
        }

        Signal_Semaphore_No_Switch(device->writeReportQueueSemaphore);

        /*
         *  Queue a work item to do the read; this way we'll be on a worker thread
         *  instead of (possibly) the NTKERN thread when we call NtWriteFile().
         *  This prevents a contention bug.
         */
        _NtKernQueueWorkItem(&device->workItemWrite, DelayedWorkQueue);

        /*
         *  In this sample driver, this function always returns success although the write
         *  is actually pending; an actual driver might provide a richer interface with
         *  a callback or something.
         */
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGOUT(("<== SendReportFromClient()"));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\vxdclnt\vxdclnt.c ===
/*
 ********************************************************************************
 *
 *  VXDCLNT.C
 *
 *
 *  VXDCLNT - Sample Ring-0 HID device mapper for Memphis
 *
 *  Copyright 1997  Microsoft Corp.
 *
 *  (ep)
 *
 ********************************************************************************
 */


#define INITGUID

#include "vxdclnt.h"




deviceContext *firstDevice = NULL, *lastDevice = NULL;
VMM_SEMAPHORE shutdownSemaphore = (VMM_SEMAPHORE)NULL;
BOOL ShutDown = FALSE;

/*
 *  Import function pointers
 */
t_pHidP_GetUsageValue pHidP_GetUsageValue                       = NULL;
t_pHidP_GetScaledUsageValue pHidP_GetScaledUsageValue           = NULL;
t_pHidP_SetUsages pHidP_SetUsages                               = NULL;
t_pHidP_GetUsages pHidP_GetUsages                               = NULL;
t_pHidP_MaxUsageListLength pHidP_MaxUsageListLength             = NULL;
t_pIoGetDeviceClassAssociations pIoGetDeviceClassAssociations   = NULL;
t_pHidP_GetCaps pHidP_GetCaps                                   = NULL;
t_pHidP_GetValueCaps pHidP_GetValueCaps                         = NULL;


#ifdef DEBUG
    UINT dbgOpt = 0;
#endif

/*
 *  GetImportFunctionPtrs
 *
 *              Set global pointers to imported functions from HIDPARSE and NTKERN.
 */
BOOL GetImportFunctionPtrs()
{
        static BOOL haveAllPtrs = FALSE;

        if (!haveAllPtrs){
                pHidP_GetUsageValue = (t_pHidP_GetUsageValue)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_GetUsageValue", NULL);
                pHidP_GetScaledUsageValue = (t_pHidP_GetScaledUsageValue)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_GetScaledUsageValue", NULL);
                pHidP_GetUsages = (t_pHidP_GetUsages)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_GetUsages", NULL);
                pHidP_SetUsages = (t_pHidP_SetUsages)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_SetUsages", NULL);
                pHidP_MaxUsageListLength = (t_pHidP_MaxUsageListLength)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_MaxUsageListLength", NULL);
                pIoGetDeviceClassAssociations = (t_pIoGetDeviceClassAssociations)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"ntpnp.sys",        "IoGetDeviceClassAssociations", NULL);
                pHidP_GetCaps = (t_pHidP_GetCaps)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_GetCaps", NULL);
                pHidP_GetValueCaps = (t_pHidP_GetValueCaps)
                        _PELDR_GetProcAddress((struct HPEMODULE__ *)"hidparse.sys", "HidP_GetValueCaps", NULL);

                if (    pHidP_GetUsageValue             && 
                        pHidP_GetScaledUsageValue       && 
                        pHidP_GetUsages                 && 
                        pHidP_SetUsages                 && 
                        pHidP_MaxUsageListLength        && 
                        pIoGetDeviceClassAssociations   && 
                        pHidP_GetCaps                   && 
                        pHidP_GetValueCaps){

                        haveAllPtrs = TRUE;
                }
        }

        return haveAllPtrs;
}


/*
 *  WStrLen
 *
 */                                 
ULONG WStrLen(PWCHAR str)
{
        ULONG result = 0;
        while (*str++){
                result++;
        }
        return result;
}


/*
 *  NewDevice
 *
 *
 */
deviceContext *NewDevice( HANDLE devHandle,
                                                PHIDP_CAPS caps,
                                                PHIDP_PREPARSED_DATA desc,
                                                UINT descSize,
                                                PWCHAR deviceFileName)
{
        deviceContext *newDevice;

        DBGOUT(("NewDevice()"));

        newDevice = (deviceContext *)_HeapAllocate(sizeof(deviceContext), 0);
        if (newDevice){
                NTSTATUS ntstat;
                ULONG valueCapsLen;

                DBGOUT(("Allocated new device @ %xh ", (UINT)newDevice));

                RtlZeroMemory(newDevice, sizeof(deviceContext));

                newDevice->devHandle = devHandle;
                newDevice->readPending = FALSE;
                newDevice->next = NULL;

                RtlCopyMemory(  (PVOID)&newDevice->deviceFileName,
                                                (PVOID)deviceFileName,
                                                (WStrLen(deviceFileName)*sizeof(WCHAR))+sizeof(UNICODE_NULL));
                RtlCopyMemory((PVOID)&newDevice->hidCapabilities, (PVOID)caps, sizeof(HIDP_CAPS));
                ExInitializeWorkItem(&newDevice->workItemRead, WorkItemCallback_Read, newDevice);
                ExInitializeWorkItem(&newDevice->workItemWrite, WorkItemCallback_Write, newDevice);

                /*
                 *  Allocate space for the device descriptor.
                 */
                newDevice->hidDescriptor = (PHIDP_PREPARSED_DATA)_HeapAllocate(descSize, 0);
                if (newDevice->hidDescriptor){
                        RtlCopyMemory((PVOID)newDevice->hidDescriptor, (PVOID)desc, descSize);
                }
                else {
                        DBGERR(("_HeapAllocate for HID descriptor failed in NewDevice()"));
                        goto _deviceInitError;
                }

                newDevice->writeReportQueueSemaphore = Create_Semaphore(0);
                if (!newDevice->writeReportQueueSemaphore){
                    goto _deviceInitError;
                }

                /*
                 *  Allocate space for the device report.
                 */
                newDevice->report = (PUCHAR)_HeapAllocate(newDevice->hidCapabilities.InputReportByteLength, 0);
                if (!newDevice->report){
                        DBGERR(("_HeapAllocate for report buffer failed in NewDevice()"));
                        goto _deviceInitError;
                }

                /*
                 *  Figure out the length of the buttons value
                 *  and allocate a buffer for reading the buttons.
                 */
                newDevice->buttonListLength = pHidP_MaxUsageListLength(HidP_Input, HID_USAGE_PAGE_BUTTON, newDevice->hidDescriptor);
                DBGOUT(("Button values list length = %d.", newDevice->buttonListLength));
                if (newDevice->buttonListLength){
                    newDevice->buttonValues = (PUSAGE) _HeapAllocate(newDevice->buttonListLength * sizeof (USAGE), 0);
                    if (newDevice->buttonValues){
                        RtlZeroMemory(newDevice->buttonValues, newDevice->buttonListLength);
                    }
                    else {
                        DBGERR(("HeapAlloc failed for button values buffer"));
                        goto _deviceInitError;
                    }
                }

				/*
				 *  Allocate the array of value-caps.
				 */
                valueCapsLen = caps->NumberInputValueCaps;
				if (valueCapsLen){
					newDevice->valueCaps = (PHIDP_VALUE_CAPS)_HeapAllocate(valueCapsLen*sizeof(HIDP_VALUE_CAPS), 0);
					if (!newDevice->valueCaps){
						DBGERR(("HeapAlloc failed for value caps"));
						goto _deviceInitError;
					}

					ntstat = pHidP_GetValueCaps(HidP_Input, newDevice->valueCaps, &valueCapsLen, desc);
					if (NT_SUCCESS(ntstat)){
                        /*
                         *  Read valueCaps structure for information about the types of
                         *  values returned by the device.
                         */

					}
					else {
						DBGERR(("HidP_GetValueCaps failed with %xh", ntstat));
						goto _deviceInitError;
					}
				}
				else {
					DBGERR(("value caps length = 0!"));
                    goto _deviceInitError;
				}
        }
        else {
                DBGERR(("_HeapAllocate failed in NewDevice()"));
                goto _deviceInitError;
        }

        return newDevice;

        _deviceInitError:
                if (newDevice){
                        if (newDevice->hidDescriptor){
                            _HeapFree(newDevice->hidDescriptor, 0);
                        }
                        if (newDevice->report){
                            _HeapFree(newDevice->report, 0);
                        }
                        if (newDevice->buttonValues){
                            _HeapFree(newDevice->buttonValues, 0);
                        }
						if (newDevice->valueCaps){
							_HeapFree(newDevice->valueCaps, 0);
						}
                        _HeapFree(newDevice, 0);
                }
                return NULL;

}


/*
 *  EnqueueDevice
 *
 */
VOID EnqueueDevice(deviceContext *device)
{
        if (lastDevice){
                lastDevice->next = device;
                lastDevice = device;
        }
        else {
                firstDevice = lastDevice = device;
        }
        device->next = NULL;
}


/*
 *  DequeueDevice
 *
 */
VOID DequeueDevice(deviceContext *device)
{
        deviceContext *prevDevice, *thisDevice;

        thisDevice = firstDevice;
        prevDevice = NULL;
        while (thisDevice){
                if (thisDevice == device){
                        if (prevDevice){
                                prevDevice->next = thisDevice->next;
                                if (!thisDevice->next){
                                        lastDevice = prevDevice;
                                }
                        }
                        else {
                                if (thisDevice->next){
                                        firstDevice = thisDevice->next;
                                }
                                else {
                                        firstDevice = lastDevice = NULL;
                                }
                        }

                        thisDevice->next = NULL;
                        break;
                }
                else {
                        prevDevice = thisDevice;
                        thisDevice = thisDevice->next;
                }
        }
}


/*
 *  DestroyDevice
 *
 *              Destroy the device context.
 *              This function assumes the device context has already been dequeued
 *              from the global list headed by firstDevice.
 *
 */
VOID DestroyDevice(deviceContext *device)
{
        DBGOUT(("==> DestroyDevice()"));

        /*
         *  Modify the device's internal workItem to do a close instead of a read.
         *  Then queue the work item so that NtClose is called on a worker thread.
         */
        ExInitializeWorkItem(&device->workItemClose, WorkItemCallback_Close, device);
        _NtKernQueueWorkItem(&device->workItemClose, DelayedWorkQueue);

        DBGOUT(("<== DestroyDevice()"));
}


/*
 *  WorkItemCallback_Close
 *
 */
VOID WorkItemCallback_Close(PVOID context)
{
        deviceContext *device = (deviceContext *)context;

        DBGOUT(("==> WorkItemCallback_Close()"));

        _NtKernClose(device->devHandle);

        if (device->hidDescriptor){
            _HeapFree(device->hidDescriptor, 0);
        }
        if (device->report){
            _HeapFree(device->report, 0);
        }
        if (device->buttonValues){
            _HeapFree(device->buttonValues, 0);
        }
		if (device->valueCaps){
			_HeapFree(device->valueCaps, 0);
		}
        if (device->writeReportQueueSemaphore){
            Destroy_Semaphore(device->writeReportQueueSemaphore);
        }

        _HeapFree(device, 0);

        DBGOUT(("<== WorkItemCallback_Close()"));
}


/*
 *  TryDestroyAll
 *
 *      Destroy all devices which don't have a pending read.
 */
VOID TryDestroyAll()
{
        deviceContext *thisDevice;

        DBGOUT(("=> TryDestroyAll()"));

        thisDevice = firstDevice;
        while (thisDevice){
                deviceContext *nextDevice = thisDevice->next;  // hold the next ptr in case we dequeue

                if (!thisDevice->readPending){
                        /*
                         *  No read pending on this device; we can shut it down.
                         */
                        DequeueDevice(thisDevice);
                        DestroyDevice(thisDevice);
                }

                thisDevice = nextDevice;
        }

        if (!firstDevice){
            /*
             *  All reads are complete and all devices have been destroyed.
             *  If a shutdown is suspended, shutdown now.
             */
            if (shutdownSemaphore){
                Signal_Semaphore_No_Switch(shutdownSemaphore);
            }
        }

        DBGOUT(("<= TryDestroyAll()"));

}


/*
 *  HandleShutdown
 *
 *
 */
VOID _cdecl HandleShutdown(VOID)
{
        /*
         *  Just set a flag.  Wait for read completion to close the device handles.
         */
        DBGOUT(("==> HandleShutdown"));
        TryDestroyAll();

        if (firstDevice && !ShutDown){

            /*
             *  There are still reads pending.
             *  Wait for all reads to complete before returning.
             */

            ShutDown = TRUE;

            shutdownSemaphore = Create_Semaphore(0);
            if (shutdownSemaphore){
             
                Wait_Semaphore(shutdownSemaphore, 0);  
                Destroy_Semaphore(shutdownSemaphore);
            }
        }

        DBGOUT(("<== HandleShutdown"));
}


/*
 *  HandleNewDevice
 *
 */
VOID _cdecl HandleNewDevice(VOID)
{
        DBGOUT(("==> HandleNewDevice"));

        /*
         *  See if there are any new device devices to connect.
         */
        ConnectNTDeviceDrivers();

        DBGOUT(("<== HandleNewDevice"));
}





/*
 *  DeviceHasBeenOpened
 *
 *              BUGBUG - there's got to be a better way of checking for this.
 *
 */
BOOL DeviceHasBeenOpened(PWCHAR deviceFileName, UINT nameWChars)
{
        deviceContext *device;
        UINT nameLen = (nameWChars*sizeof(WCHAR))+sizeof(UNICODE_NULL);

        for (device = firstDevice; device; device = device->next){
                if (memcmp(deviceFileName, device->deviceFileName, nameLen) == 0){
                        return TRUE;
                }
        }

        return FALSE;
}



/*
 *  ConnectNTDeviceDrivers
 *
 *
 */       
VOID ConnectNTDeviceDrivers()
{
        WORK_QUEUE_ITEM *workItemOpen;

        workItemOpen = _HeapAllocate(sizeof(WORK_QUEUE_ITEM), 0);
        if (workItemOpen){

            /*
             *  Initialize the workItem and 
             *  pass the workItem itself as the context so that it can be freed later.
             */
            ExInitializeWorkItem(workItemOpen, WorkItemCallback_Open, workItemOpen);

            DBGOUT(("==> ConnectNTDeviceDrivers() - queueing work item to call "));
            /*
             *  Queue a work item to do the open; this way we'll be on a worker thread
             *  instead of (possibly) the NTKERN thread when we call NtCreateFile().
             *  This prevents a contention bug.
             */
            _NtKernQueueWorkItem(workItemOpen, DelayedWorkQueue);
        }

        DBGOUT(("<== ConnectNTDeviceDrivers()"));

}




/*
 *  WorkItemCallback_Open
 *
 *              Do the actual work of opening the device.
 *
 */
VOID WorkItemCallback_Open(PVOID context)
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS ntStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    PWSTR symbolicLinkList = NULL;
    PWSTR symbolicLink;

    DBGOUT(("==> WorkItemCallback_Open()"));

    /*
     *  The context is just the workItem itself, which can now be freed.
     */
    ASSERT(context);
    _HeapFree(context, 0);


    /*
     *  Get pointers to all our import functions at once.
     */
    if (!GetImportFunctionPtrs()){
        DBGERR(("ERROR: Failed to get import functions."));
        return;
    }

    /*
     *  Get a multi-string (separated by unicode NULL characters)
     *  of symbolic link names to the input-class devices.
     */
    ntStatus = pIoGetDeviceClassAssociations(   (EXTERN_C GUID *)&GUID_CLASS_INPUT,
                                                NULL,
                                                0,
                                                (PWSTR *)&symbolicLinkList);
    if (NT_ERROR(ntStatus) || !symbolicLinkList) {
        DBGERR(("pIoGetDeviceClassAssociations failed"));
        return;
    }

    /*
     *  Go through all the device paths
     */
    symbolicLink = symbolicLinkList;
    while ((WCHAR)*symbolicLink){
        HANDLE deviceHandle;
        ULONG fileNameWChars;
        PWCHAR fileName;
        deviceContext *newDevice = NULL;


        /*
         *  Get a pointer to to the next device name and step the multi-string pointer.
         */
        fileName = symbolicLink;
        fileNameWChars = WStrLen(fileName);
        symbolicLink += fileNameWChars+1;

        /*
         *  Make sure we don't already have this device open.
         *  This can happen because we check for new device on every PNP_NEW_DEVNODE msg.
         */
        if (DeviceHasBeenOpened(fileName, fileNameWChars)){
            DBGOUT(("This device is already open, skipping ..."));
        }
        else {
            FileName.Buffer = fileName;
            FileName.Length = fileNameWChars*sizeof(WCHAR);
            FileName.MaximumLength = FileName.Length + sizeof(UNICODE_NULL);

            /*
             *  Initialize an object-attribute structure with this filename.
             */
            InitializeObjectAttributes(&Obja, &FileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

            /*
             *  Try to open the device.
             */
            DBGOUT(("Opening HID Device : (unicode name @%xh, %xh wchars)", (UINT)fileName, (UINT)fileNameWChars));

            ntStatus = _NtKernCreateFile(
                                            &deviceHandle,
                                            (GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES),
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            FILE_ATTRIBUTE_NORMAL,
                                            (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                            FILE_OPEN,
                                            0,
                                            NULL,
                                            0
                                            );
            if (NT_SUCCESS(ntStatus)){
                HID_COLLECTION_INFORMATION hidColInfo;

                DBGOUT(("Opened some device (handle=%xh), calling _NtKernDeviceIoControl", (UINT)deviceHandle));

                ntStatus = _NtKernDeviceIoControl(
                                                    deviceHandle,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &IoStatusBlock,
                                                    IOCTL_HID_GET_COLLECTION_INFORMATION,
                                                    NULL,
                                                    0,
                                                    &hidColInfo,
                                                    sizeof(HID_COLLECTION_INFORMATION));
                if (NT_SUCCESS(ntStatus)){
                    PHIDP_PREPARSED_DATA phidDescriptor;

                    phidDescriptor = (PHIDP_PREPARSED_DATA)_HeapAllocate(hidColInfo.DescriptorSize, 0);

                    if (phidDescriptor){

                        ntStatus = _NtKernDeviceIoControl(
                                                            deviceHandle,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            &IoStatusBlock,
                                                            IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                                            NULL,
                                                            0,
                                                            phidDescriptor,
                                                            hidColInfo.DescriptorSize);
                        if (NT_SUCCESS(ntStatus)){
                            HIDP_CAPS hidCaps;

                            ntStatus = pHidP_GetCaps(phidDescriptor, (PHIDP_CAPS)&hidCaps);

                            if (NT_SUCCESS(ntStatus)){

                                DBGOUT(("Opened HID device successfully, report size is %d.", (UINT)hidCaps.InputReportByteLength));

                                /*
                                 *  <<COMPLETE>>
                                 * 
                                 *  Check hidCaps.UsagePage and hidCaps.Usage to verify that this is a device
                                 *  that you want to drive.
                                 */

                                if (hidCaps.InputReportByteLength == 0){
                                    DBGERR(("ERROR: Report size is zero!"));
                                }
                                else {

                                    /*
                                     *  Take all the information we have for this device and bundle
                                     *  it into a context.
                                     */
                                    newDevice = NewDevice(deviceHandle,
                                                        (PHIDP_CAPS)&hidCaps,
                                                        phidDescriptor,
                                                        hidColInfo.DescriptorSize,
                                                        fileName);
                                    if (newDevice){
                                        /*
                                         *  Add this device to our global list.
                                         */
                                        EnqueueDevice(newDevice);

                                        /*
                                         *  Then start the first async read in the device device.
                                         */
                                        DispatchNtReadFile(newDevice);
                                    }
                                    else {
                                        DBGERR(("NewDevice() failed"));
                                    }
                                }
                            }
                            else {
                                DBGERR(("pHidP_GetCaps failed"));
                            }
                        }
                        else {
                            DBGERR(("_NtKernDeviceIoControl (#2) failed"));
                        }

                        _HeapFree(phidDescriptor, 0);
                    }
                    else {
                        DBGERR(("HeapAlloc failed"));
                    }
                }
                else {
                    DBGERR(("_NtKernDeviceIoControl failed"));
                }

                if (!newDevice){
                    DBGERR(("Device init failed -- calling _NtKernClose() on device handle"));
                    _NtKernClose(deviceHandle);
                }

            }
            else {
                DBGERR(("_NtKernCreateFile failed to open this Device (ntStatus=%xh)", (UINT)ntStatus));
            }
        }
    }

    // BUGBUG  ExFreePool(symbolicLinkList);

    DBGOUT(("<== WorkItemCallback_Open()"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\vxdclnt\vxd.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXD.ASM
;
;  VXDCLNT - Sample Ring-0 HID device mapper for Memphis
;
;  Copyright 1997  Microsoft Corp.
;
;  (ep)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.386p

	.xlist
	INCLUDE VMM.INC
	INCLUDE VMD.INC
	INCLUDE NTKERN.INC
	INCLUDE DEBUG.INC
	INCLUDE CONFIGMG.INC
	.list

VXDCLNT_Dynamic equ	1

Declare_Virtual_Device VXDCLNT, 1, 0, \
		VXDCLNT_Control, Undefined_Device_Id, Undefined_Init_Order


VxD_Locked_Data_Seg

current_msg			db	0
OurThreadHandle			dd	0

VxD_Locked_Data_Ends

VxD_Locked_Code_Seg

	EXTRN	_HandleShutdown:NEAR
	EXTRN	_HandleNewDevice:NEAR
	EXTRN	_ConnectNTDeviceDrivers@0:NEAR


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXDCLNT_Control
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc VXDCLNT_Control, PUBLIC

	mov current_msg, al

	Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, VXDCLNT_Initialize
	Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, VXDCLNT_Shutdown
	Control_Dispatch PNP_NEW_DEVNODE        , VXDCLNT_NewDevNode

 	;
	;  Need to hook these messages in case SYS_DYNAMIC_DEVICE_INIT
	;  comes while Windows is booting.
	;
	Control_Dispatch Kernel32_Initialized, VXDCLNT_Initialize
	Control_Dispatch Kernel32_Shutdown, VXDCLNT_Shutdown

	clc
	ret

EndProc VXDCLNT_Control
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXDCLNT_Initialize
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc VXDCLNT_Initialize

	EnterProc

	;
	; If Windows is still booting, wait for the Kernel to finish initializing.
	; (Wait for the Kernel32_Initialized message)
	;
	VMMCall	VMM_GetSystemInitState
	cmp	eax, SYSSTATE_KERNEL32INITED
	jb	init_done

	; 
	;  If we are being dynaloaded as a result of a PnP event,
	;  we want to defer the open until appytime.
	;  If we are being loaded at boot time, then we open when we
	;  get the Kernel32_Initialized message.
	;  
	cmp current_msg, Kernel32_Initialized
	je open_now
	VxDCall	_CONFIGMG_Call_At_Appy_Time,<VXDCLNT_Schedule_Open, 0, 0>
	jmp	init_done
open_now:
	call VXDCLNT_Schedule_Open 

init_done:
	clc
	LeaveProc
	return

EndProc VXDCLNT_Initialize
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXDCLNT_NewDevNode
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc VXDCLNT_NewDevNode

	EnterProc

	;	   
	;  If system is fully booted, check to see if the new devnode
	;  is the result of another device being plugged in.
	;  (For the first device, we get a SYS_DYNAMIC_DEVICE_INIT msg,
	;   but for subsequent devices plugged in after boot time, this is
	;   the only message we get).
	;
	VMMCall	VMM_GetSystemInitState
	cmp	eax, SYSSTATE_KERNEL32INITED
	jb	new_devnode_done

	;
	;  The system is initialized.
	;  Wait for appytime to check for new devices.
	;
	VxDCall	_CONFIGMG_Call_At_Appy_Time,<NewDevnode_Callback, 0, 0>

new_devnode_done:
	clc
	LeaveProc
	return

EndProc VXDCLNT_NewDevNode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  NewDevnode_Callback
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc NewDevnode_Callback
	;		
	;  It's appytime following a PNP_NEW_DEVNODE msg.  
	;  Check for any new devices.		
	;		
	call _HandleNewDevice 
	clc
	ret
EndProc NewDevnode_Callback
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXDCLNT_Shutdown
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc VXDCLNT_Shutdown
	call _HandleShutdown
	clc
	ret
EndProc VXDCLNT_Shutdown
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  VXDCLNT_Schedule_Open
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc VXDCLNT_Schedule_Open

	push edi
	VxDCall	_NTKERNGetWorkerThread,<0>
	mov	edi, eax
	or	eax, eax
	jnz	@F
	VMMCall	Get_Sys_VM_Handle
	VMMCall	Get_Initial_Thread_Handle
@@:
	mov	[OurThreadHandle], edi
	sCall	CallRestrictedEvent,<\
			OFFSET32 _ConnectNTDeviceDrivers@0, 0, \
			0, edi>
	pop edi
	clc
	ret

EndProc VXDCLNT_Schedule_Open
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  CallRestrictedEvent
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc CallRestrictedEvent, SCALL, PUBLIC

ArgVar	Routine, DWORD
ArgVar	Context, DWORD
ArgVar	crFlags, DWORD
ArgVar	thisThreadHandle, DWORD

	EnterProc

	SaveReg	<esi, edi, ebx>

	mov	esi, Routine
	mov	edx, Context
	xor	eax, eax
	mov	ecx, PEF_Wait_For_STI OR PEF_Thread_Event
	or	ecx, crFlags
	mov	ebx, thisThreadHandle
	test	ebx, ebx
	jnz	@F
	mov	ebx, thisThreadHandle
@@:
	VMMCall	Call_Restricted_Event

	mov	eax, esi

	RestoreReg <ebx, edi, esi>
	LeaveProc
	return

EndProc CallRestrictedEvent
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



VxD_Locked_Code_Ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\samples\vxdclnt\vxdclnt.h ===
/*
 ********************************************************************************
 *
 *  VXDCLNT.H
 *
 *
 *  VXDCLNT - Sample Ring-0 HID device mapper for Memphis
 *
 *  Copyright 1997  Microsoft Corp.
 *
 *  (ep)
 *
 ********************************************************************************
 */


#define WANTVXDWRAPS
#include <basetyps.h>
#include <wdm.h>
#include <BASEDEF.H>
#include <vmm.h>
#include <vxdldr.h>
#include <ntkern.h>
#include <vxdwraps.h>
#include <hidusage.h>
#include <hidpi.h>
#include <hidclass.h>



/*
 *  Type definitions for imported functions.
 */
typedef NTSTATUS (*t_pIoGetDeviceClassAssociations) (
        IN LPGUID           ClassGuid,
        IN PDEVICE_OBJECT   PhysicalDeviceObject OPTIONAL,
        IN ULONG            Flags,
        OUT PWSTR           *SymbolicLinkList
        );

typedef NTSTATUS (__stdcall *t_pHidP_GetCaps) (
   IN      PHIDP_PREPARSED_DATA      PreparsedData,
   OUT     PHIDP_CAPS                Capabilities
   );

typedef NTSTATUS (__stdcall *t_pHidP_GetUsages) (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   OUT      USAGE *              UsageList,
   IN OUT   ULONG *              UsageLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   );

typedef NTSTATUS (__stdcall *t_pHidP_GetUsageValue) (
   IN    HIDP_REPORT_TYPE     ReportType,
   IN    USAGE                UsagePage,
   IN    USHORT               LinkCollection, // Optional
   IN    USAGE                Usage,
   OUT   PULONG               UsageValue,
   IN    PHIDP_PREPARSED_DATA PreparsedData,
   IN    PCHAR                Report,
   IN    ULONG                ReportLength
   );

typedef NTSTATUS (*t_pHidP_SetUsages) (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       USAGE                 UsagePage,
   IN       USHORT                LinkCollection, // Optional
   IN       PUSAGE                UsageList,
   IN OUT   PULONG                UsageLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   );

typedef NTSTATUS (__stdcall *t_pHidP_GetScaledUsageValue) (
   IN    HIDP_REPORT_TYPE     ReportType,
   IN    USAGE                UsagePage,
   IN    USHORT               LinkCollection, // Optional
   IN    USAGE                Usage,
   OUT   PLONG                UsageValue,
   IN    PHIDP_PREPARSED_DATA PreparsedData,
   IN    PCHAR                Report,
   IN    ULONG                ReportLength
   );

typedef ULONG (__stdcall *t_pHidP_MaxUsageListLength) (
   IN HIDP_REPORT_TYPE      ReportType,
   IN USAGE                 UsagePage,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   );

typedef NTSTATUS (__stdcall * t_pHidP_GetValueCaps) (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PULONG               ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   );


typedef struct tag_writeReport {
                PUCHAR report;
                ULONG reportLen;
                struct tag_writeReport *next;
} writeReport;

typedef struct tag_deviceContext {

                HANDLE devHandle;
                BOOL readPending;
                PUCHAR report;
                LARGE_INTEGER dataLength;
                HIDP_CAPS hidCapabilities;
                PHIDP_VALUE_CAPS valueCaps;
                PHIDP_PREPARSED_DATA hidDescriptor;
                IO_STATUS_BLOCK ioStatusBlock;
                WORK_QUEUE_ITEM workItemRead;
                WORK_QUEUE_ITEM workItemWrite;
                WORK_QUEUE_ITEM workItemClose;

                UINT buttonListLength;
                PUSAGE buttonValues;

                WCHAR deviceFileName[(MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR))+sizeof(UNICODE_NULL)];

                writeReport *writeReportQueue;
                VMM_SEMAPHORE writeReportQueueSemaphore;

                struct tag_deviceContext *next;
} deviceContext;


#ifdef DEBUG
    extern UINT dbgOpt;
    #define DBGOUT(msg_in_parens) if (dbgOpt) { _Debug_Printf_Service("\r\nVXDCLNT> "); _Debug_Printf_Service msg_in_parens; _Debug_Printf_Service("\r\n"); }
    #define DBGERR(msg_in_parens) { _Debug_Printf_Service("\r\n *** VXDCLNT ERROR *** \r\nVXDCLNT> "); _Debug_Printf_Service msg_in_parens; _Debug_Printf_Service("\r\n"); }
    #define DBGBREAK() { _asm { int 3 } }
#else
    #define DBGOUT(msg_in_parens)
    #define DBGERR(msg_in_parens)
    #define DBGBREAK()
#endif

_inline VOID Signal_Semaphore_No_Switch(VMM_SEMAPHORE sem)
{
    _asm mov eax, [sem]
    VMMCall(Signal_Semaphore_No_Switch)
}

VOID ReadCompletion(IN PVOID Context, IN PIO_STATUS_BLOCK IoStatusBlock, IN ULONG Reserved);
VOID VMDPostPointerMessage(LONG deltaX, LONG deltaY, ULONG Buttons, ULONG Wheel);
VOID VMDPostAbsolutePointerMessage(LONG deltaX, LONG deltaY, ULONG Buttons);
VOID WorkItemCallback_Read(PVOID context);
VOID WorkItemCallback_Write(PVOID context);
VOID WorkItemCallback_Open(PVOID context);
VOID WorkItemCallback_Close(PVOID context);
VOID ConnectNTDeviceDrivers();
VOID _cdecl DispatchNtReadFile(deviceContext *device);


extern BOOL ShutDown;


extern t_pHidP_GetUsageValue pHidP_GetUsageValue;
extern t_pHidP_GetScaledUsageValue pHidP_GetScaledUsageValue;
extern t_pHidP_SetUsages pHidP_SetUsages;
extern t_pHidP_GetUsages pHidP_GetUsages;
extern t_pHidP_MaxUsageListLength pHidP_MaxUsageListLength;
extern t_pIoGetDeviceClassAssociations pIoGetDeviceClassAssociations;
extern t_pHidP_GetCaps pHidP_GetCaps;
extern t_pHidP_GetValueCaps pHidP_GetValueCaps;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\buttons.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    buttons.c

Abstract: Button HID Driver.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(INIT, DriverEntry)
  #pragma alloc_text(PAGE, HbutCreateClose)
  #pragma alloc_text(PAGE, HbutAddDevice)
  #pragma alloc_text(PAGE, HbutUnload)
#endif  //ifdef ALLOC_PRAGMA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | DriverEntry |
 *          Installable driver initialization entry point.
 *          <nl>This entry point is called directly by the I/O system.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *  @parm   IN PUNICODE_STRINT | RegPath | Points to the registry path.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    )
{
    PROCNAME("DriverEntry")
    NTSTATUS status = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION hidMinidriverRegistration;

    ENTER(1, ("(DrvObj=%p,RegPath=%p)\n", DrvObj, RegPath));

    DrvObj->MajorFunction[IRP_MJ_CREATE] =
    DrvObj->MajorFunction[IRP_MJ_CLOSE] = HbutCreateClose;

    DrvObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HbutInternalIoctl;

    DrvObj->MajorFunction[IRP_MJ_PNP]   = HbutPnp;
    DrvObj->MajorFunction[IRP_MJ_POWER] = HbutPower;
    DrvObj->DriverUnload                = HbutUnload;
    DrvObj->DriverExtension->AddDevice  = HbutAddDevice;

    //
    // Register with HIDCLASS.SYS module
    //
    RtlZeroMemory(&hidMinidriverRegistration,
                  sizeof(hidMinidriverRegistration));

    hidMinidriverRegistration.Revision            = HID_REVISION;
    hidMinidriverRegistration.DriverObject        = DrvObj;
    hidMinidriverRegistration.RegistryPath        = RegPath;
    hidMinidriverRegistration.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
    hidMinidriverRegistration.DevicesArePolled    = FALSE;

    status = HidRegisterMinidriver(&hidMinidriverRegistration);

    if (NT_SUCCESS(status))
    {
      #ifdef DEBUG
        ExInitializeFastMutex(&gmutexDevExtList);
        InitializeListHead(&glistDevExtHead);
      #endif
    }
    else
    {
        ERRPRINT(("failed to register mini driver (status=%x)\n", status));
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //DriverEntry

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HbutCreateClose |
 *          Process the create and close IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue STATUS_SUCCESS | success
 *  @rvalue STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HbutCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HbutCreateClose")
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER(DevObj);
    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpStack=%p,Major=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MajorFunction, MajorFnNames)));

    switch(irpsp->MajorFunction)
    {
        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            Irp->IoStatus.Information = 0;
            break;

        default:
            ERRPRINT(("invalid major function %s\n",
                       LookupName(irpsp->MajorFunction, MajorFnNames)));
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    EXIT(1, ("=%x\n", status));
    return status;
}       //HbutCreateClose

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HbutAddDevice |
 *          Called by hidclass, allows us to initialize our device extensions.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *  @parm   IN PDEVICE_OBJECT | DevObj |
 *          Points to a functional device object created by hidclass.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS.
 *  @rvalue FAILURE | Returns NT status code.
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HbutAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    )
{
    PROCNAME("HbutAddDevice")
    NTSTATUS status;
    PDEVICE_EXTENSION devext;

    PAGED_CODE ();

    ENTER(1, ("(DrvObj=%p,DevObj=%p)\n", DrvObj, DevObj));

    ASSERT(DevObj != NULL);
    UNREFERENCED_PARAMETER(DrvObj);

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    RtlZeroMemory(devext, sizeof(*devext));
    IoInitializeRemoveLock(&devext->RemoveLock, HBUT_POOL_TAG, 0, 10);
    KeInitializeSpinLock(&devext->SpinLock);
    InitializeListHead(&devext->PendingIrpList);
    devext->DebounceTime.QuadPart = Int32x32To64(OEM_BUTTON_DEBOUNCE_TIME,
                                                 -10000);
    KeInitializeTimer(&devext->DebounceTimer);
    KeInitializeDpc(&devext->TimerDpc, OemButtonDebounceDpc, devext);
  #ifdef DEBUG
    ExAcquireFastMutex(&gmutexDevExtList);
    InsertTailList(&glistDevExtHead, &devext->List);
    ExReleaseFastMutex(&gmutexDevExtList);
  #endif
    DevObj->Flags &= ~DO_DEVICE_INITIALIZING;
    DevObj->Flags |= DO_POWER_PAGABLE;
    status = STATUS_SUCCESS;

    EXIT(1, ("=%x\n", status));
    return status;
}       //HbutAddDevice

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | HbutUnload | Free all the allocated resources, etc.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *
 *****************************************************************************/

VOID EXTERNAL
HbutUnload(
    IN PDRIVER_OBJECT DrvObj
    )
{
    PROCNAME("HbutUnload")

    PAGED_CODE();

    ENTER(1, ("(DrvObj=%p)\n", DrvObj));

    ASSERT(DrvObj->DeviceObject == NULL);
    UNREFERENCED_PARAMETER(DrvObj);

    EXIT(1, ("!\n"));
    return;
}       //HbutUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\debug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    debug.c

Abstract: This module contains all the debug functions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef DEBUG

NAMETABLE MajorFnNames[] =
{
    IRP_MJ_CREATE,                      "Create",
    IRP_MJ_CREATE_NAMED_PIPE,           "CreateNamedPipe",
    IRP_MJ_CLOSE,                       "Close",
    IRP_MJ_READ,                        "Read",
    IRP_MJ_WRITE,                       "Write",
    IRP_MJ_QUERY_INFORMATION,           "QueryInfo",
    IRP_MJ_SET_INFORMATION,             "SetInfo",
    IRP_MJ_QUERY_EA,                    "QueryEA",
    IRP_MJ_SET_EA,                      "SetEA",
    IRP_MJ_FLUSH_BUFFERS,               "FlushBuffers",
    IRP_MJ_QUERY_VOLUME_INFORMATION,    "QueryVolInfo",
    IRP_MJ_SET_VOLUME_INFORMATION,      "SetVolInfo",
    IRP_MJ_DIRECTORY_CONTROL,           "DirectoryControl",
    IRP_MJ_FILE_SYSTEM_CONTROL,         "FileSystemControl",
    IRP_MJ_DEVICE_CONTROL,              "DeviceControl",
    IRP_MJ_INTERNAL_DEVICE_CONTROL,     "InternalDevControl",
    IRP_MJ_SHUTDOWN,                    "Shutdown",
    IRP_MJ_LOCK_CONTROL,                "LockControl",
    IRP_MJ_CLEANUP,                     "CleanUp",
    IRP_MJ_CREATE_MAILSLOT,             "CreateMailSlot",
    IRP_MJ_QUERY_SECURITY,              "QuerySecurity",
    IRP_MJ_SET_SECURITY,                "SetSecurity",
    IRP_MJ_POWER,                       "Power",
    IRP_MJ_SYSTEM_CONTROL,              "SystemControl",
    IRP_MJ_DEVICE_CHANGE,               "DeviceChange",
    IRP_MJ_QUERY_QUOTA,                 "QueryQuota",
    IRP_MJ_SET_QUOTA,                   "SetQuota",
    IRP_MJ_PNP,                         "PnP",
    0x00,                               NULL
};

NAMETABLE PnPMinorFnNames[] =
{
    IRP_MN_START_DEVICE,                "StartDevice",
    IRP_MN_QUERY_REMOVE_DEVICE,         "QueryRemoveDevice",
    IRP_MN_REMOVE_DEVICE,               "RemoveDevice",
    IRP_MN_CANCEL_REMOVE_DEVICE,        "CancelRemoveDevice",
    IRP_MN_STOP_DEVICE,                 "StopDevice",
    IRP_MN_QUERY_STOP_DEVICE,           "QueryStopDevice",
    IRP_MN_CANCEL_STOP_DEVICE,          "CancelStopDevice",
    IRP_MN_QUERY_DEVICE_RELATIONS,      "QueryDeviceRelations",
    IRP_MN_QUERY_INTERFACE,             "QueryInterface",
    IRP_MN_QUERY_CAPABILITIES,          "QueryCapabilities",
    IRP_MN_QUERY_RESOURCES,             "QueryResources",
    IRP_MN_QUERY_RESOURCE_REQUIREMENTS, "QueryResRequirements",
    IRP_MN_QUERY_DEVICE_TEXT,           "QueryDeviceText",
    IRP_MN_FILTER_RESOURCE_REQUIREMENTS,"FilterResRequirements",
    IRP_MN_READ_CONFIG,                 "ReadConfig",
    IRP_MN_WRITE_CONFIG,                "WriteConfig",
    IRP_MN_EJECT,                       "Eject",
    IRP_MN_SET_LOCK,                    "SetLock",
    IRP_MN_QUERY_ID,                    "QueryID",
    IRP_MN_QUERY_PNP_DEVICE_STATE,      "QueryPNPDeviceState",
    IRP_MN_QUERY_BUS_INFORMATION,       "QueryBusInfo",
    IRP_MN_DEVICE_USAGE_NOTIFICATION,   "DeviceUsageNotify",
    IRP_MN_SURPRISE_REMOVAL,            "SurpriseRemoval",
    0x18,                               "QueryLegacyBusInfo",
    0x00,                               NULL
};

NAMETABLE PowerMinorFnNames[] =
{
    IRP_MN_WAIT_WAKE,                   "WaitWake",
    IRP_MN_POWER_SEQUENCE,              "PowerSequence",
    IRP_MN_SET_POWER,                   "SetPower",
    IRP_MN_QUERY_POWER,                 "QueryPower",
    0x00,                               NULL
};

NAMETABLE PowerStateNames[] =
{
    PowerDeviceUnspecified,             "Unspecified",
    PowerDeviceD0,                      "D0",
    PowerDeviceD1,                      "D1",
    PowerDeviceD2,                      "D2",
    PowerDeviceD3,                      "D3",
    PowerDeviceMaximum,                 "Maximum",
    0x00,                               NULL
};

NAMETABLE HidIoctlNames[] =
{
    IOCTL_HID_GET_DEVICE_DESCRIPTOR,    "GetDeviceDescriptor",
    IOCTL_HID_GET_REPORT_DESCRIPTOR,    "GetReportDescriptor",
    IOCTL_HID_READ_REPORT,              "ReadReport",
    IOCTL_HID_WRITE_REPORT,             "WriteReport",
    IOCTL_HID_GET_STRING,               "GetString",
    IOCTL_HID_ACTIVATE_DEVICE,          "ActivateDevice",
    IOCTL_HID_DEACTIVATE_DEVICE,        "DeactivateDevice",
    IOCTL_HID_GET_DEVICE_ATTRIBUTES,    "GetDeviceAttributes",
    0x00,                               NULL
};

NAMETABLE QueryIDTypeNames[] =
{
    BusQueryDeviceID,                   "DeviceID",
    BusQueryHardwareIDs,                "HardwareIDs",
    BusQueryCompatibleIDs,              "CompatibleIDs",
    BusQueryDeviceSerialNumber,         "DeviceSerialNumber",
    0x00,                               NULL
};

FAST_MUTEX gmutexDevExtList = {0};      //synchronization for access to list
LIST_ENTRY glistDevExtHead = {0};       //list of all the device instances
int giVerboseLevel = 0;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSZ | LookupName |
 *
 *          Look up name string of a code in the given name table.
 *
 *  @parm   IN ULONG | Code |
 *
 *          The given code to lookup.
 *
 *  @parm   IN PNAMETABLE | NameTable |
 *
 *          The name table to look into.
 *
 *  @rvalue SUCCESS - Returns pointer to the minor function name string.
 *  @rvalue FAILURE - Returns "unknown".
 *
 *****************************************************************************/

PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    )
{
    PROCNAME("LookupName")
    PSZ pszName = "unknown";

    ENTER(5, ("(Code=%x,pNameTable=%p)\n", Code, NameTable));

    ASSERT(NameTable != NULL);
    while (NameTable->pszName != NULL)
    {
        if (Code == NameTable->Code)
        {
            pszName = NameTable->pszName;
            break;
        }
        NameTable++;
    }

    EXIT(5, ("=%s\n", pszName));
    return pszName;
}       //LookupName

#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\buttons.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    buttons.h

Abstract:  Contains definitions of all constants and data types for the
           serial pen hid driver.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#ifndef _BUTTONS_H
#define _BUTTONS_H

//
// Constants
//
#define HBUT_POOL_TAG           'tubH'
#define STUCK_DETECTION_RETRIES 5
#define MAX_STUCK_COUNT         6

// dwfHBut flag values
#define HBUTF_DEVICE_STARTED            0x00000001
#define HBUTF_DEVICE_REMOVED            0x00000002
#define HBUTF_INTERRUPT_CONNECTED       0x00000004
#define HBUTF_DEBOUNCE_TIMER_SET        0x00000008

//
// Macros
//
#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) \
    ((PDEVICE_EXTENSION)(((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))
#define GET_NEXT_DEVICE_OBJECT(DO)          \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

//
// Type Definitions
//
typedef struct _DEVICE_EXTENSION
{
  #ifdef DEBUG
    LIST_ENTRY     List;                //list of of other tablet devices
  #endif
    ULONG          dwfHBut;             //flags
    IO_REMOVE_LOCK RemoveLock;          //to protect IRP_MN_REMOVE_DEVICE
    CM_PARTIAL_RESOURCE_DESCRIPTOR IORes;//button port resource
    CM_PARTIAL_RESOURCE_DESCRIPTOR IRQRes;//button IRQ resource
    PKINTERRUPT    InterruptObject;     //location of the interrupt object
    KSPIN_LOCK     SpinLock;
    LIST_ENTRY     PendingIrpList;
    LARGE_INTEGER  DebounceTime;
    KTIMER         DebounceTimer;
    KDPC           TimerDpc;
    UCHAR          LastButtonState;
    UCHAR          StuckButtonsMask;
    UCHAR          bStuckCount;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Global Data Declarations
//

//
// Function prototypes
//

// buttons.c
NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    );

NTSTATUS EXTERNAL
HbutCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
HbutAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    );

VOID EXTERNAL
HbutUnload(
    IN PDRIVER_OBJECT DrvObj
    );

// pnp.c
NTSTATUS EXTERNAL
HbutPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
HbutPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
StartDevice(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

VOID INTERNAL
RemoveDevice(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    );

NTSTATUS INTERNAL
SendSyncIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN BOOLEAN        fCopyToNext
    );

NTSTATUS INTERNAL
IrpCompletion(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PKEVENT        Event
    );

// ioctl.c
NTSTATUS EXTERNAL
HbutInternalIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
GetDeviceDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
GetReportDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
ReadReport(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

VOID EXTERNAL
ReadReportCanceled(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
GetString(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    );

NTSTATUS INTERNAL
GetAttributes(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    );

// oembutton.c
BOOLEAN EXTERNAL
OemInterruptServiceRoutine(
    IN PKINTERRUPT       Interrupt,
    IN PDEVICE_EXTENSION DevExt
    );

VOID EXTERNAL
OemButtonDebounceDpc(
    IN PKDPC             Dpc,
    IN PDEVICE_EXTENSION DevExt,
    IN PVOID             SysArg1,
    IN PVOID             SysArg2
    );

// misc.c
PCM_PARTIAL_RESOURCE_DESCRIPTOR INTERNAL
RtlUnpackPartialDesc(
    IN UCHAR             ResType,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG        Count
    );

#endif  //ifndef _BUTTONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:  Contains debug related definitions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

//
// Constants
//

//
// Macros
//
#ifdef DEBUG
  #define TRAP()                DbgBreakPoint()
  #define DBGPRINT(n,x)         if (n <= giVerboseLevel)                    \
                                {                                           \
                                    DbgPrint(MODNAME ": %s: ", ProcName);   \
                                    DbgPrint x;                             \
                                }
  #define WARNPRINT(x)          {                                           \
                                    DbgPrint(MODNAME "_WARN: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                }
  #define ERRPRINT(x)           {                                           \
                                    DbgPrint(MODNAME "_ERR: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                    TRAP();                                 \
                                }
#else
  #define TRAP()
  #define DBGPRINT(n,x)
  #define WARNPRINT(x)
  #define ERRPRINT(x)
#endif  //ifdef DEBUG

//
// Type Definitions
//
typedef struct _NAMETABLE
{
    ULONG Code;
    PSZ   pszName;
} NAMETABLE, *PNAMETABLE;

//
// Exported Data Declarations
//
#ifdef DEBUG
extern NAMETABLE MajorFnNames[];
extern NAMETABLE PnPMinorFnNames[];
extern NAMETABLE PowerMinorFnNames[];
extern NAMETABLE PowerStateNames[];
extern NAMETABLE HidIoctlNames[];
extern NAMETABLE QueryIDTypeNames[];
extern FAST_MUTEX gmutexDevExtList;     //synchronization for access to list
extern LIST_ENTRY glistDevExtHead;      //list of all the device instances
extern int giVerboseLevel;
#endif

//
// Function prototypes
//
#ifdef DEBUG
PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    );
#endif  //ifdef DEBUG

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\misc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    misc.c

Abstract: Miscellaneous functions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, RtlUnpackPartialDesc)
#endif  //ifdef ALLOC_PRAGMA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PCM_PARTIAL_RESOURCE_DESCRIPTOR | RtlUnpackPartialDesc |
 *          Pulls out a pointer to the partial descriptor you are interested
 *          in.
 *
 *  @parm   IN UCHAR | ResType | Specifies the resource type we are interested
 *          in.
 *  @parm   IN PCM_RESOURCE_LIST | ResList | Points to the resource list to
 *          search.
 *  @parm   IN OUT PULONG | Count | Points to the index of the partial
 *          descriptor you are looking for, gets incremented if found.
 *          i.e. starts with *Count = 0, then subsequent calls will find the
 *          next partial descriptor.
 *
 *  @rvalue SUCCESS | returns pointer to the partial descriptor found.
 *  @rvalue FAILURE | returns NULL.
 *
 *****************************************************************************/

PCM_PARTIAL_RESOURCE_DESCRIPTOR INTERNAL
RtlUnpackPartialDesc(
    IN UCHAR             ResType,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG        Count
    )
{
    PROCNAME("RtlUnpackPartialDesc")
    ULONG i, j, hit = 0;

    PAGED_CODE();

    ENTER(2, ("(ResType=%x,ResList=%p,Count=%d)\n", ResType, ResList, *Count));

    for (i = 0; i < ResList->Count; ++i)
    {
        for (j = 0; j < ResList->List[i].PartialResourceList.Count; ++j)
        {
            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type
                == ResType)
            {
                if (hit == *Count)
                {
                    (*Count)++;
                    EXIT(2, ("=%p (Count=%d)\n",
                             &ResList->List[i].PartialResourceList.PartialDescriptors[j],
                             *Count));
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];
                }
                else
                {
                    hit++;
                }
            }
        }
    }

    EXIT(2, ("=NULL (Count=%d)\n", *Count));
    return NULL;
}       //RtlUnpackPartialDesc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\ioctl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Contains routines to support HIDCLASS internal
          ioctl queries for the pen tablet devices.

Environment:

    Kernel mode

Author:
    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, GetDeviceDescriptor)
  #pragma alloc_text(PAGE, GetReportDescriptor)
  #pragma alloc_text(PAGE, GetString)
  #pragma alloc_text(PAGE, GetAttributes)
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HbutInternalIoctl |
 *          Process the Control IRPs sent to this device.
 *          <nl>This function cannot be pageable because reads/writes
 *          can be made at dispatch-level
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HbutInternalIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("HbutInternalIoctl")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Ioctl=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                         HidIoctlNames)));

    Irp->IoStatus.Information = 0;
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        ERRPRINT(("received PnP IRP after device was removed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        ASSERT(devext->dwfHBut & HBUTF_DEVICE_STARTED);
        switch(irpsp->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
                status = GetDeviceDescriptor(DevObj, Irp);
                break;

            case IOCTL_HID_GET_REPORT_DESCRIPTOR:
                status = GetReportDescriptor(DevObj, Irp);
                break;

            case IOCTL_HID_READ_REPORT:
                status = ReadReport(DevObj, Irp);
                break;

            case IOCTL_HID_GET_STRING:
                status = GetString(DevObj, Irp);
                break;

            case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
                status = GetAttributes(DevObj, Irp);
                break;

            case IOCTL_HID_ACTIVATE_DEVICE:
            case IOCTL_HID_DEACTIVATE_DEVICE:
                status = STATUS_SUCCESS;
                break;

            default:
                WARNPRINT(("unsupported ioctl code (ioctl=%s)\n",
                            LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                                       HidIoctlNames)));
                status = Irp->IoStatus.Status;
                break;
        }

        if (status != STATUS_PENDING)
        {
            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else
        {
            IoMarkIrpPending(Irp);
        }
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HbutInternalIoctl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetDeviceDescriptor |
 *          Respond to HIDCLASS IOCTL_HID_GET_DEVICE_DESCRIPTOR
 *          by returning a device descriptor.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns STATUS_BUFFER_TOO_SMALL - need more memory
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetDeviceDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("GetDeviceDescriptor")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(gHidDescriptor))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer,
                      &gHidDescriptor,
                      sizeof(gHidDescriptor));

        Irp->IoStatus.Information = sizeof(gHidDescriptor);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetDeviceDescriptor

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetReportDescriptor |
 *          Respond to HIDCLASS IOCTL_HID_GET_REPORT_DESCRIPTOR
 *          by returning appropriate the report descriptor.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetReportDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("GetReportDescriptor")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(gReportDescriptor))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer,
                      gReportDescriptor,
                      sizeof(gReportDescriptor));

        Irp->IoStatus.Information = sizeof(gReportDescriptor);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetReportDescriptor

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | ReadReport |
 *          Read input report.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
ReadReport(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("ReadReport")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    ASSERT(Irp->UserBuffer != NULL);
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength !=
        sizeof(OEM_INPUT_REPORT))
    {
        ERRPRINT(("invalid input report size (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (!(devext->dwfHBut & HBUTF_DEVICE_STARTED))
    {
        ERRPRINT(("device not started yet\n"));
        status = STATUS_DEVICE_NOT_READY ;
    }
    else
    {
        KIRQL OldIrql;
        PDRIVER_CANCEL OldCancelRoutine;

        KeAcquireSpinLock(&devext->SpinLock, &OldIrql);
        OldCancelRoutine = IoSetCancelRoutine(Irp, ReadReportCanceled);
        ASSERT(OldCancelRoutine == NULL);

        if (Irp->Cancel)
        {
            //
            // This IRP was canceled.  Do not queue it.
            //
            OldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
            if (OldCancelRoutine != NULL)
            {
                //
                // Cancel routine was not called.
                //
                ASSERT(OldCancelRoutine == ReadReportCanceled);
                status = STATUS_CANCELLED;
            }
            else
            {
                //
                // Cancel routine was called and it will complete this IRP
                // as soon as we drop the spinlock.  Return PENDING so the
                // caller doesn't touch this IRP.
                //
                InitializeListHead(&Irp->Tail.Overlay.ListEntry);
                IoMarkIrpPending(Irp);
                status = STATUS_PENDING;
            }
        }
        else
        {
            InsertTailList(&devext->PendingIrpList,
                           &Irp->Tail.Overlay.ListEntry);
            IoMarkIrpPending(Irp);
            status = STATUS_PENDING;
        }

        KeReleaseSpinLock(&devext->SpinLock, OldIrql);
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //ReadReport

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID | ReadReportCanceled |
 *          ReadReport IRP has been canceled, so do the clean up.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID EXTERNAL
ReadReportCanceled(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("ReadReportCanceled")
    PDEVICE_EXTENSION devext;
    KIRQL OldIrql;

    ENTER(2, ("(DevObj=%p,Irp=%p)\n", DevObj, Irp));

    ASSERT(Irp->Cancel);
    ASSERT(Irp->CancelRoutine == NULL);
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    KeAcquireSpinLock(&devext->SpinLock, &OldIrql);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&devext->SpinLock, OldIrql);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoReleaseRemoveLock(&devext->RemoveLock, Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    WARNPRINT(("ReadReport IRP was canceled\n"));

    EXIT(2, ("!\n"));
    return;
}       //ReadReportCanceled

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetString |
 *          Respond to IOCTL_HID_GET_STRING.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetString(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    )
{
    PROCNAME("GetString")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PWSTR pwstrID;
    ULONG lenID;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p,StringID=%x)\n",
              DevObj, Irp, irpsp,
              (ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer));

    switch ((ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer &
            0xffff)
    {
        case HID_STRING_ID_IMANUFACTURER:
            pwstrID = gpwstrManufacturerID;
            break;

        case HID_STRING_ID_IPRODUCT:
            pwstrID = gpwstrProductID;
            break;

        case HID_STRING_ID_ISERIALNUMBER:
            pwstrID = gpwstrSerialNumber;
            break;

        default:
            pwstrID = NULL;
            break;
    }

    lenID = pwstrID? wcslen(pwstrID)*sizeof(WCHAR) + sizeof(UNICODE_NULL): 0;
    if (pwstrID == NULL)
    {
        ERRPRINT(("invalid string ID (ID=%x)\n",
                  (ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer));
        status = STATUS_INVALID_PARAMETER;
    }
    else if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < lenID)
    {
        ERRPRINT(("output buffer too small (bufflen=%d,need=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength, lenID));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer, pwstrID, lenID);

        Irp->IoStatus.Information = lenID;
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x (string=%S)\n", status, pwstrID? pwstrID: L"Null"));
    return status;
}       //GetString

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetAttributes |
 *          Respond to IOCTL_HID_GET_ATTRIBUTES, by filling
 *          the HID_DEVICE_ATTRIBUTES struct.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetAttributes(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    )
{
    PROCNAME("GetAttributes")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(HID_DEVICE_ATTRIBUTES))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        PDEVICE_EXTENSION devext;
        PHID_DEVICE_ATTRIBUTES DevAttrib;

        devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
        DevAttrib = (PHID_DEVICE_ATTRIBUTES)Irp->UserBuffer;

        DevAttrib->Size = sizeof(HID_DEVICE_ATTRIBUTES);
        DevAttrib->VendorID = OEM_VENDOR_ID;
        DevAttrib->ProductID = OEM_PRODUCT_ID;
        DevAttrib->VersionNumber = OEM_VERSION_NUM;

        Irp->IoStatus.Information = sizeof(HID_DEVICE_ATTRIBUTES);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetAttributes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\oembutton.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oempen.c

Abstract: Contains OEM specific functions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#endif  //ifdef ALLOC_PRAGMA

UCHAR gReportDescriptor[32] = {
    0x05, 0x0c,                    // USAGE_PAGE (Consumer Devices)
    0x09, 0x01,                    // USAGE (Consumer Control)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x09, 0x03,                    //   USAGE (Programmable Buttons)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x06,                    //     USAGE_MAXIMUM (Button 6)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x95, 0x06,                    //     REPORT_COUNT (6)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x81, 0x00,                    //     INPUT (Data,Ary,Abs)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};

HID_DESCRIPTOR gHidDescriptor =
{
    sizeof(HID_DESCRIPTOR),             //bLength
    HID_HID_DESCRIPTOR_TYPE,            //bDescriptorType
    HID_REVISION,                       //bcdHID
    0,                                  //bCountry - not localized
    1,                                  //bNumDescriptors
    {                                   //DescriptorList[0]
        HID_REPORT_DESCRIPTOR_TYPE,     //bReportType
        sizeof(gReportDescriptor)       //wReportLength
    }
};

PWSTR gpwstrManufacturerID = L"Microsoft";
PWSTR gpwstrProductID = L"Tablet PC Buttons";
PWSTR gpwstrSerialNumber = L"0";

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   BOOLEAN | OemInterruptServiceRoutine |
 *          Interrupt service routine for the button device.
 *
 *  @parm   IN PKINTERRUPT | Interrupt | Points to the interrupt object.
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns TRUE - it's our interrupt.
 *  @rvalue FAILURE | returns FALSE - it's not our interrupt.
 *
 *****************************************************************************/

BOOLEAN EXTERNAL
OemInterruptServiceRoutine(
    IN PKINTERRUPT       Interrupt,
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemInterruptServiceRoutine")
    BOOLEAN rc = FALSE;
    UCHAR ButtonState;

    ENTER(1, ("(Interrupt=%p,DevExt=%p)\n", Interrupt, DevExt));

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // Note: the action of reading the button state will also clear
    // the interrupt.
    //
    ButtonState = READBUTTONSTATE(DevExt);
    if ((ButtonState & BUTTON_INTERRUPT_MASK) &&
        ((ButtonState & BUTTON_STATUS_MASK)!= DevExt->LastButtonState))
    {
        DBGPRINT(1, ("Button interrupt (Buttons=%x)\n", ButtonState));
        DevExt->LastButtonState = ButtonState & BUTTON_STATUS_MASK;
        DevExt->dwfHBut |= HBUTF_DEBOUNCE_TIMER_SET;
        KeSetTimer(&DevExt->DebounceTimer,
                   DevExt->DebounceTime,
                   &DevExt->TimerDpc);
        DBGPRINT(3, ("Button Interrupt (ButtonState=%x)\n", ButtonState));
        rc = TRUE;
    }

    EXIT(1, ("=%x\n", rc));
    return rc;
}       //OemInterruptServiceRoutine

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID | OemButtonDebounceDpc |
 *          Timer DPC routine to handle button debounce.
 *
 *  @parm   IN PKDPC | Dpc | Points to the DPC object.
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN PVOID | SysArg1 | System argument 1.
 *  @parm   IN PVOID | SysArg2 | System arugment 2.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID EXTERNAL
OemButtonDebounceDpc(
    IN PKDPC             Dpc,
    IN PDEVICE_EXTENSION DevExt,
    IN PVOID             SysArg1,
    IN PVOID             SysArg2
    )
{
    PROCNAME("OemButtonDebounceDpc")
    UCHAR ButtonState;

    ENTER(2, ("(Dpc=%p,DevExt=%p,SysArg1=%p,SysArg2=%p)\n",
              Dpc, DevExt, SysArg1, SysArg2));

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SysArg1);
    UNREFERENCED_PARAMETER(SysArg2);

    ButtonState = READBUTTONSTATE(DevExt) & BUTTON_STATUS_MASK;
    if (ButtonState == DevExt->LastButtonState)
    {
        PIRP irp = NULL;
        KIRQL OldIrql;
        PLIST_ENTRY plist;
        PDRIVER_CANCEL OldCancelRoutine;

        if (ButtonState & DevExt->StuckButtonsMask)
        {
            if (DevExt->bStuckCount >= MAX_STUCK_COUNT)
            {
                DBGPRINT(1, ("Clearing stuck buttons (Buttons=%x,StuckMask=%x)\n",
                             ButtonState, DevExt->StuckButtonsMask));
                ButtonState &= ~DevExt->StuckButtonsMask;
            }
            else
            {
                DBGPRINT(1, ("Detected stuck buttons (Buttons=%x,StuckMask=%x,Count=%d)\n",
                             ButtonState, DevExt->StuckButtonsMask,
                             DevExt->bStuckCount));
                DevExt->bStuckCount++;
            }
        }
        else if (DevExt->StuckButtonsMask != 0)
        {
            //
            // The button has unstuck after all???
            //
            DBGPRINT(1, ("Button has unstuck (Buttons=%x,StuckMask=%x)\n",
                         ButtonState, DevExt->StuckButtonsMask));
            DevExt->bStuckCount = 0;
        }

        DevExt->dwfHBut &= ~HBUTF_DEBOUNCE_TIMER_SET;

        KeAcquireSpinLock(&DevExt->SpinLock, &OldIrql);
        if (!IsListEmpty(&DevExt->PendingIrpList))
        {
            plist = RemoveHeadList(&DevExt->PendingIrpList);
            irp = CONTAINING_RECORD(plist, IRP, Tail.Overlay.ListEntry);
            OldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            ASSERT(OldCancelRoutine == ReadReportCanceled);
        }
        KeReleaseSpinLock(&DevExt->SpinLock, OldIrql);

        if (irp != NULL)
        {
            POEM_INPUT_REPORT report = (POEM_INPUT_REPORT)irp->UserBuffer;

            //
            // Tell the system that we are not idling.
            //
            PoSetSystemState(ES_USER_PRESENT);

            report->ButtonState = ButtonState;
            irp->IoStatus.Information = sizeof(OEM_INPUT_REPORT);
            irp->IoStatus.Status = STATUS_SUCCESS;
            IoReleaseRemoveLock(&DevExt->RemoveLock, irp);
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            DBGPRINT(3, ("Button Event (ButtonState=%x)\n", ButtonState));
        }
        else
        {
            WARNPRINT(("no pending ReadReport irp, must have been canceled\n"));
        }
    }
    else
    {
        DBGPRINT(3, ("button state is unstable, try again (PrevState=%x,NewState=%x)\n",
                     DevExt->LastButtonState, ButtonState));
        DevExt->LastButtonState = ButtonState;
        KeSetTimer(&DevExt->DebounceTimer,
                   DevExt->DebounceTime,
                   &DevExt->TimerDpc);
    }

    EXIT(2, ("!\n"));
    return;
}       //OemButtonDebounceDpc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\pch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:  Pre-compile C header file.


Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "HBUT"
#define INTERNAL
#define EXTERNAL

#if DBG
  #define DEBUG
  #define TRACING
#endif

#include <wdm.h>
#include <hidport.h>
#include "oembutton.h"
#include "buttons.h"
#include "debug.h"
#include "trace.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\oembutton.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    oembutton.h

Abstract:  Contains OEM specific definitions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#ifndef _OEMBUTTON_H
#define _OEMBUTTON_H

//
// Constants
//
#define OEM_VENDOR_ID                   0x3666          //"MSF"
#define OEM_PRODUCT_ID                  0x1234
#define OEM_VERSION_NUM                 1
#define OEM_BUTTON_DEBOUNCE_TIME        10              //10msec

//
// Button ports
//
#define PORT_BUTTONSTATUS(devext)       (PUCHAR)((devext)->IORes.u.Port.Start.LowPart)
#define BUTTON_STATUS_MASK              0x1f
#define BUTTON_INTERRUPT_MASK           0x80
#define BUTTON_VALID_BITS               (BUTTON_STATUS_MASK |   \
                                         BUTTON_INTERRUPT_MASK)

//
// Macros
//
#define READBUTTONSTATE(devext)         (~READ_PORT_UCHAR(                  \
                                            PORT_BUTTONSTATUS(devext)) &    \
                                         BUTTON_VALID_BITS)

//
// Type definitions
//

//
// This must match with hardware, so make sure it is byte aligned.
//
#include <pshpack1.h>
typedef struct _OEM_INPUT_REPORT
{
    UCHAR ButtonState;
} OEM_INPUT_REPORT, *POEM_INPUT_REPORT;


//
// Global Data Declarations
//
extern UCHAR gReportDescriptor[32];
extern HID_DESCRIPTOR gHidDescriptor;
extern PWSTR gpwstrManufacturerID;
extern PWSTR gpwstrProductID;
extern PWSTR gpwstrSerialNumber;

#endif  //ifndef _OEMBUTTON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\pnp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pnp.c

Abstract: This module contains code to handle PnP and Power IRPs.

Environment:

    Kernel mode

  Author:

    Michael Tsang (MikeTs) 13-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, HbutPnp)
  #pragma alloc_text(PAGE, HbutPower)
  #pragma alloc_text(PAGE, StartDevice)
  #pragma alloc_text(PAGE, RemoveDevice)
  #pragma alloc_text(PAGE, SendSyncIrp)
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HbutPnp |
 *          Plug and Play dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Pointer to the device object.
 *  @parm   IN PIRP | Irp | Pointer to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HbutPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HbutPnp")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Minor=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MinorFunction, PnPMinorFnNames)));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        //
        // Someone sent us another plug and play IRP after removed
        //
        ERRPRINT(("received PnP IRP after device was removed\n"));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        BOOLEAN fSkipIt = FALSE;

        switch (irpsp->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ASSERT(!(devext->dwfHBut & HBUTF_DEVICE_STARTED));
                //
                // Forward the IRP down the stack
                //
                status = SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, TRUE);
                if (NT_SUCCESS(status))
                {
                    status = StartDevice(DevObj, Irp);
                    if (NT_SUCCESS(status))
                    {
                        devext->dwfHBut |= HBUTF_DEVICE_STARTED;
                    }
                }
                else
                {
                    ERRPRINT(("failed to forward start IRP (status=%x)\n",
                              status));
                }

                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;

            case IRP_MN_STOP_DEVICE:
                //
                // After the start IRP has been sent to the lower driver
                // object, the bus may NOT send any more IRPS down ``touch''
                // until another START has occured.  Whatever access is
                // required must be done before Irp passed on.
                //
                if (devext->dwfHBut & HBUTF_DEVICE_STARTED)
                {
                    devext->dwfHBut &= ~HBUTF_DEVICE_STARTED;
                    if (devext->dwfHBut & HBUTF_INTERRUPT_CONNECTED)
                    {
                        IoDisconnectInterrupt(devext->InterruptObject);
                        devext->dwfHBut &= ~HBUTF_INTERRUPT_CONNECTED;
                    }
                }

                //
                // We don't need a completion routine so fire and forget.
                // Set the current stack location to the next stack location and
                // call the next device object.
                //
                fSkipIt = TRUE;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:
                //
                // The PlugPlay system has detected the removal of this device.
                // We have no choice but to detach and delete the device object.
                // (If we wanted to express an interest in preventing this
                // removal, we should have filtered the query remove and query
                // stop routines.)
                // Note: we might receive a remove WITHOUT first receiving a
                // stop.
                //

                //
                // Make sure we do not allow more IRPs to start touching the
                // device.
                //
                devext->dwfHBut &= ~HBUTF_DEVICE_STARTED;
                devext->dwfHBut |= HBUTF_DEVICE_REMOVED;

                RemoveDevice(DevObj, Irp);

                //
                // Send on the remove IRP
                //
                fSkipIt = TRUE;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                status = SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, TRUE);
                if (NT_SUCCESS(status))
                {
                    PDEVICE_CAPABILITIES devcaps;

                    devcaps = irpsp->Parameters.DeviceCapabilities.Capabilities;
                    if (devcaps != NULL)
                    {
                        SYSTEM_POWER_STATE i;

                        //
                        // This device is built-in to the system, so it should
                        // be impossible to surprise remove this device, but
                        // we will handle it anyway.
                        //
                        devcaps->SurpriseRemovalOK = TRUE;

                        //
                        // While the underlying serial bus might be able to
                        // wake the machine from low power (via wake on ring),
                        // the tablet cannot.
                        //
                        devcaps->SystemWake = PowerSystemUnspecified;
                        devcaps->DeviceWake = PowerDeviceUnspecified;
                        devcaps->WakeFromD0 =
                                devcaps->WakeFromD1 =
                                devcaps->WakeFromD2 =
                                devcaps->WakeFromD3 = FALSE;
                        devcaps->DeviceState[PowerSystemWorking] =
                                PowerDeviceD0;
                        for (i = PowerSystemSleeping1;
                             i < PowerSystemMaximum;
                             i++)
                        {
                            devcaps->DeviceState[i] = PowerDeviceD3;
                        }
                    }
                }
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;

            default:
                fSkipIt = TRUE;
                break;
        }

        if (fSkipIt)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n",
                      GET_NEXT_DEVICE_OBJECT(DevObj), Irp));
            status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DevObj), Irp);
            EXIT(2, (".IoCallDriver=%x\n", status));
        }

        if (irpsp->MinorFunction == IRP_MN_REMOVE_DEVICE)
        {
            //
            // Wait for the remove lock to free.
            //
            IoReleaseRemoveLockAndWait(&devext->RemoveLock, Irp);
        }
        else
        {
            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
        }
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HbutPnp

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HbutPower | The power dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HbutPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HbutPower")
    NTSTATUS status;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(1, ("(DevObj=%p,Irp=%p,Minor=%s)\n",
              DevObj, Irp,
              LookupName(IoGetCurrentIrpStackLocation(Irp)->MinorFunction,
                         PowerMinorFnNames)));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        //
        // Someone sent us another power IRP after removed
        //
        ERRPRINT(("received Power IRP after device was removed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        IoSkipCurrentIrpStackLocation(Irp);

        ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n",
                  GET_NEXT_DEVICE_OBJECT(DevObj), Irp));
        status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DevObj), Irp);
        EXIT(2, (".PoCallDriver=%x\n", status));

        IoReleaseRemoveLock(&devext->RemoveLock, Irp);
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HbutPower

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | StartDevice |
 *          Get the device information and attempt to initialize a
 *          configuration for a device.  If we cannot identify this as a
 *          valid HID device or configure the device, our start device
 *          function is failed.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
StartDevice(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("StartDevice")
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p)\n", DevObj, Irp));

    irpsp = IoGetCurrentIrpStackLocation(Irp);
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    if (irpsp->Parameters.StartDevice.AllocatedResourcesTranslated == NULL)
    {
        ERRPRINT(("no resources is allocated to the button device!\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        ULONG Count;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pDesc;

        Count = 0;
        pDesc = RtlUnpackPartialDesc(
                    CmResourceTypePort,
                    irpsp->Parameters.StartDevice.AllocatedResourcesTranslated,
                    &Count);
        if (pDesc == NULL)
        {
            ERRPRINT(("no allocated port resources!\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            devext->IORes = *pDesc;
            Count = 0;
            pDesc = RtlUnpackPartialDesc(
                        CmResourceTypeInterrupt,
                        irpsp->Parameters.StartDevice.AllocatedResourcesTranslated,
                        &Count);
            if (pDesc == NULL)
            {
                ERRPRINT(("no allocated IRQ resources!\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                int i;
                UCHAR Buttons;

                ASSERT(!(devext->dwfHBut & HBUTF_INTERRUPT_CONNECTED));
                devext->IRQRes = *pDesc;

                //
                // To determine potential stuck buttons, read the buttons
                // up to 5 times for any button down bits without an interrupt.
                //
                for (i = 0; i < STUCK_DETECTION_RETRIES; ++i)
                {
                    Buttons = READBUTTONSTATE(devext);
                    if (!(Buttons & BUTTON_INTERRUPT_MASK))
                    {
                        devext->StuckButtonsMask |= Buttons &
                                                    BUTTON_STATUS_MASK;
                    }
                }

                devext->StuckButtonsMask = Buttons & BUTTON_STATUS_MASK;
                DBGPRINT(1, ("StuckButtonsMask=%x\n",
                             devext->StuckButtonsMask));

                status = IoConnectInterrupt(
                            &devext->InterruptObject,
                            OemInterruptServiceRoutine,
                            devext,
                            NULL,
                            devext->IRQRes.u.Interrupt.Vector,
                            (KIRQL)devext->IRQRes.u.Interrupt.Level,
                            (KIRQL)devext->IRQRes.u.Interrupt.Level,
                            (devext->IRQRes.Flags & CM_RESOURCE_INTERRUPT_LATCHED)?
                                Latched: LevelSensitive,
                            devext->IRQRes.ShareDisposition == CmResourceShareShared,
                            devext->IRQRes.u.Interrupt.Affinity,
                            FALSE);
                if (NT_SUCCESS(status))
                {
                    devext->dwfHBut |= HBUTF_INTERRUPT_CONNECTED;
                    DBGPRINT(3, ("IO(Start=0x%x%x,Len=0x%x), IRQ(Level=%d,Vector=0x%x,Affinity=%d)\n",
                                 devext->IORes.u.Port.Start.HighPart,
                                 devext->IORes.u.Port.Start.LowPart,
                                 devext->IORes.u.Port.Length,
                                 devext->IRQRes.u.Interrupt.Level,
                                 devext->IRQRes.u.Interrupt.Vector,
                                 devext->IRQRes.u.Interrupt.Affinity));
                }
            }
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //StartDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | RemoveDevice | FDO Remove routine
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *****************************************************************************/

VOID INTERNAL
RemoveDevice(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    )
{
    PROCNAME("RemoveDevice")
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p)\n", DevObj, Irp));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    ASSERT(devext->dwfHBut & HBUTF_DEVICE_REMOVED);
    if (devext->dwfHBut & HBUTF_INTERRUPT_CONNECTED)
    {
        IoDisconnectInterrupt(devext->InterruptObject);
        devext->dwfHBut &= ~HBUTF_INTERRUPT_CONNECTED;
    }

    if (devext->dwfHBut & HBUTF_DEBOUNCE_TIMER_SET)
    {
        KeCancelTimer(&devext->DebounceTimer);
    }

  #ifdef DEBUG
    ExAcquireFastMutex(&gmutexDevExtList);
    RemoveEntryList(&devext->List);
    ExReleaseFastMutex (&gmutexDevExtList);
  #endif

    EXIT(2, ("!\n"));
    return;
}       //RemoveDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | SendSyncIrp |
 *          Send an IRP synchronously down the stack.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to the IRP.
 *  @parm   IN BOOLEAN | fCopyToNext | if TRUE, copy the irpsp to next location.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
SendSyncIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN BOOLEAN        fCopyToNext
    )
{
    PROCNAME("SendSyncIrp")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT event;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p,fCopyToNext=%x,MajorFunc=%s)\n",
              DevObj, Irp, fCopyToNext,
              LookupName(irpsp->MajorFunction, MajorFnNames)));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    if (fCopyToNext)
    {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp, IrpCompletion, &event, TRUE, TRUE, TRUE);
    if (irpsp->MajorFunction == IRP_MJ_POWER)
    {
        ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n", DevObj, Irp));
        status = PoCallDriver(DevObj, Irp);
        EXIT(2, (".IoCallDriver=%x\n", status));
    }
    else
    {
        ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n", DevObj, Irp));
        status = IoCallDriver(DevObj, Irp);
        EXIT(2, (".IoCallDriver=%x\n", status));
    }

    if (status == STATUS_PENDING)
    {
        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }

    if (NT_SUCCESS(status))
    {
        status = Irp->IoStatus.Status;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //SendSyncIrp

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | IrpCompletion | Completion routine for all IRPs.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *  @parm   IN PKEVENT | Event | Points to the event to notify.
 *
 *  @rvalue STATUS_MORE_PROCESSING_REQUIRED | We want the IRP back
 *
 *****************************************************************************/

NTSTATUS INTERNAL
IrpCompletion(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PKEVENT        Event
    )
{
    PROCNAME("IrpCompletion")

    ENTER(2, ("(DevObj=%p,Irp=%p,Event=%p)\n", DevObj, Irp, Event));

    UNREFERENCED_PARAMETER(DevObj);

    KeSetEvent(Event, 0, FALSE);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    EXIT(2, ("=%x\n", STATUS_MORE_PROCESSING_REQUIRED));
    return STATUS_MORE_PROCESSING_REQUIRED;
}       //IrpCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\trace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    This module contains the code for debug tracing.

Author:

    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode

Revision History:


--*/

#include "pch.h"

#ifdef TRACING
//
// Constants
//

//
// Local Data
//
int giTraceLevel = 0;
int giTraceIndent = 0;
ULONG gdwfTrace = 0;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    )
/*++

Routine Description:
    This routine determines if the given procedure should be traced.

Arguments:
    n - trace level of the procedure
    ProcName - points to the procedure name string

Return Value:
    Success - returns TRUE
    Failure - returns FALSE

--*/
{
    BOOLEAN rc = FALSE;

    if (!(gdwfTrace & TF_CHECKING_TRACE) && (giTraceLevel >= n))
    {
        int i;

        DbgPrint(MODNAME ": ");

        for (i = 0; i < giTraceIndent; ++i)
        {
            DbgPrint("| ");
        }

        DbgPrint(ProcName);

        rc = TRUE;
    }

    return rc;
}       //IsTraceOn

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\buttons\trace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module contains definitions of the trace functions

Author:
    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode


Revision History:


--*/

#ifndef _TRACE_H
#define _TRACE_H

//
// Constants
//
#define TF_CHECKING_TRACE       0x00000001

//
// Macros
//
#ifdef TRACING
  #ifndef PROCNAME
    #define PROCNAME(s) static PSZ ProcName = s;
  #endif
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                            ++giTraceIndent;                            \
                        }
  #define EXIT(n,p)     {                                               \
                            --giTraceIndent;                            \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                        }
#else
  #define PROCNAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif

//
// Exported function prototypes
//
#ifdef TRACING
//
// Exported data
//
extern int giTraceIndent;
extern ULONG gdwfTrace;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    );
#endif

#endif  //ifndef _TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\battinfo.c ===
/*++
    Copyright (c) 2000,2001 Microsoft Corporation

    Module Name:
        battinfo.c

    Abstract: SMBus Smart Battery Information Property Sheet module.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 23-Jan-2001

    Revision History:
--*/

#include "pch.h"

#ifdef BATTINFO

char gszUnitmV[] = "mV";
char gszUnitmA[] = "mA";
char gszUnitPercent[] = "%";
char gszReserved[] = "Reserved";
PSZ gapszBattModeNames[] =
{
    "ReportWatt",
    "DisableBroadcastToCharger",
    "PrimaryBatt",
    "ChargerCtrlEnabled",
    "CondCycleReq'd",
    "PrimaryBattSupport",
    "IntChargeCtrler"
};
PSZ gapszBattStatusNames[] =
{
    "OverCharged",
    "TerminateCharge",
    "OverTemp",
    "TerminateDischarge",
    "RemainCapAlarm",
    "RemainTimeAlarm",
    "Init'd",
    "Discharging",
    "Full",
    "Empty"
};

SMBCMD_INFO gBattCmds[] =
{
    BATTCMD_MANUFACTURER_ACCESS, SMB_READ_WORD, WHX, sizeof(WORD),
        "  ManufacturerAcc", NULL, 0, NULL,
    BATTCMD_REMAININGCAP_ALARM,  SMB_READ_WORD, CAP, sizeof(WORD),
        "   RemainCapAlarm", NULL, 0, NULL,
    BATTCMD_REMAININGTIME_ALARM, SMB_READ_WORD, TIM, sizeof(WORD),
        "  RemainTimeAlarm", NULL, 0, NULL,
    BATTCMD_BATTERY_MODE,        SMB_READ_WORD, WBT, sizeof(WORD),
        "      BatteryMode", NULL, 0xc383, gapszBattModeNames,
    BATTCMD_ATRATE,              SMB_READ_WORD, RAT, sizeof(WORD),
        "           AtRate", NULL, 0, NULL,
    BATTCMD_ATRATE_TIMETOFULL,   SMB_READ_WORD, TIM, sizeof(WORD),
        " AtRateTimeToFull", NULL, 0, NULL,
    BATTCMD_ATRATE_TIMETOEMPTY,  SMB_READ_WORD, TIM, sizeof(WORD),
        "AtRateTimeToEmpty", NULL, 0, NULL,
    BATTCMD_ATRATE_OK,           SMB_READ_WORD, WDC, sizeof(WORD),
        "         AtRateOK", NULL, 0, NULL,
    BATTCMD_TEMPERATURE,         SMB_READ_WORD, TMP, sizeof(WORD),
        "      Temperature", NULL, 0, NULL,
    BATTCMD_VOLTAGE,             SMB_READ_WORD, WDC, sizeof(WORD),
        "          Voltage", gszUnitmV, 0, NULL,
    BATTCMD_CURRENT,             SMB_READ_WORD, WSN, sizeof(WORD),
        "          Current", gszUnitmA, 0, NULL,
    BATTCMD_AVG_CURRENT,         SMB_READ_WORD, WSN, sizeof(WORD),
        "       AvgCurrent", gszUnitmA, 0, NULL,
    BATTCMD_MAX_ERROR,           SMB_READ_WORD, WDC, sizeof(WORD),
        "         MaxError", gszUnitPercent, 0, NULL,
    BATTCMD_REL_STATEOFCHARGE,   SMB_READ_WORD, WDC, sizeof(WORD),
        " RelStateOfCharge", gszUnitPercent, 0, NULL,
    BATTCMD_ABS_STATEOFCHARGE,   SMB_READ_WORD, WDC, sizeof(WORD),
        " AbsStateOfCharge", gszUnitPercent, 0, NULL,
    BATTCMD_REMAININGCAP,        SMB_READ_WORD, CAP, sizeof(WORD),
        "        RemainCap", NULL, 0, NULL,
    BATTCMD_FULLCHARGECAP,       SMB_READ_WORD, CAP, sizeof(WORD),
        "    FullChargeCap", NULL, 0, NULL,
    BATTCMD_RUNTIMETOEMPTY,      SMB_READ_WORD, TIM, sizeof(WORD),
        "   RunTimeToEmpty", NULL, 0, NULL,
    BATTCMD_AVGTIMETOEMPTY,      SMB_READ_WORD, TIM, sizeof(WORD),
        "   AvgTimeToEmpty", NULL, 0, NULL,
    BATTCMD_AVGTIMETOFULL,       SMB_READ_WORD, TIM, sizeof(WORD),
        "    AvgTimeToFull", NULL, 0, NULL,
    BATTCMD_CHARGING_CURRENT,    SMB_READ_WORD, WDC, sizeof(WORD),
        "  ChargingCurrent", gszUnitmA, 0, NULL,
    BATTCMD_CHARGING_VOLTAGE,    SMB_READ_WORD, WDC, sizeof(WORD),
        "  ChargingVoltage", gszUnitmV, 0, NULL,
    BATTCMD_BATTERY_STATUS,      SMB_READ_WORD, STA, sizeof(WORD),
        "    BatteryStatus", NULL, 0xdbf0, gapszBattStatusNames,
    BATTCMD_CYCLE_COUNT,         SMB_READ_WORD, WDC, sizeof(WORD),
        "       CycleCount", NULL, 0, NULL,
    BATTCMD_DESIGN_CAP,          SMB_READ_WORD, CAP, sizeof(WORD),
        "        DesignCap", NULL, 0, NULL,
    BATTCMD_DESIGN_VOLTAGE,      SMB_READ_WORD, WDC, sizeof(WORD),
        "    DesignVoltage", gszUnitmV, 0, NULL,
    BATTCMD_SPEC_INFO,           SMB_READ_WORD, SPI, sizeof(WORD),
        "         SpecInfo", NULL, 0, NULL,
    BATTCMD_MANUFACTURE_DATE,    SMB_READ_WORD, DAT, sizeof(WORD),
        "  ManufactureDate", NULL, 0, NULL,
    BATTCMD_SERIAL_NUM,          SMB_READ_WORD, WDC, sizeof(WORD),
        "     SerialNumber", NULL, 0, NULL,
    BATTCMD_MANUFACTURER_NAME,   SMB_READ_BLOCK,STR, sizeof(BLOCK_DATA),
        " ManufacturerName", NULL, 0, NULL,
    BATTCMD_DEVICE_NAME,         SMB_READ_BLOCK,STR, sizeof(BLOCK_DATA),
        "       DeviceName", NULL, 0, NULL,
    BATTCMD_DEVICE_CHEMISTRY,    SMB_READ_BLOCK,STR, sizeof(BLOCK_DATA),
        "  DeviceChemistry", NULL, 0, NULL,
    BATTCMD_MANUFACTURER_DATA,   SMB_READ_BLOCK,MAN, sizeof(BLOCK_DATA),
        " ManufacturerData", NULL, 0, NULL,
};
#define NUM_BATT_CMDS   (sizeof(gBattCmds)/sizeof(SMBCMD_INFO))

BATT_INFO gBattInfo = {0};

/*++
    @doc    EXTERNAL

    @func   INT_PTR | BatteryDlgProc |
            Dialog procedure for the battery page.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uMsg | Message.
    @parm   IN WPARAM | wParam | Word Parameter.
    @parm   IN LPARAM | lParam | Long Parameter.

    @rvalue Return value depends on the message.
--*/

INT_PTR APIENTRY
BatteryDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("BatteryDlgProc", 2)
    INT_PTR rc = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitBatteryPage(hwnd);
            if (!rc)
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_QUERYINITIALFOCUS:
                {
                    SetWindowLong(hwnd,
                                  DWL_MSGRESULT,
                                  (LONG)GetDlgItem(hwnd, IDC_BATTINFO_REFRESH));
                    rc = TRUE;
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BATTINFO_REFRESH:
                    RefreshBatteryInfo(GetDlgItem(hwnd, IDC_BATTINFO_TEXT));
                    break;
            }
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //BatteryDlgProc

/*++
    @doc    INTERNAL

    @func   BOOL | InitBatteryPage |
            Initialize the battery property page.

    @parm   IN HWND | hwnd | Window handle.

    @rvalue Always returns TRUE.
--*/

BOOL
InitBatteryPage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitBatteryPage", 2)
    HWND hwndEdit;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    hwndEdit = GetDlgItem(hwnd, IDC_BATTINFO_TEXT);
    SendMessage(hwndEdit, WM_SETFONT, (WPARAM)ghFont, MAKELONG(FALSE, 0));

    RefreshBatteryInfo(hwndEdit);

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //InitBatteryPage

/*++
    @doc    INTERNAL

    @func   VOID | RefreshBatteryInfo | Refresh battery information.

    @parm   IN HWND | hwndEdit | Handle to edit control.

    @rvalue None.
--*/

VOID
RefreshBatteryInfo(
    IN HWND hwndEdit
    )
{
    TRACEPROC("RefreshBatteryInfo", 3)
    int i;
    PBYTE pbBuff;
    BOOL fWatt = FALSE;

    TRACEENTER(("(hwndEdit=%x)\n", hwndEdit));

    //
    // Erase edit control.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, -1);
    SendMessage(hwndEdit, EM_REPLACESEL, 0, (LPARAM)"");

    memset(&gBattInfo, 0, sizeof(gBattInfo));
    pbBuff = (PBYTE)&gBattInfo.wBatteryMode;
    if (GetSMBDevInfo(SMB_BATTERY_ADDRESS,
                      &gBattCmds[BATTCMD_BATTERY_MODE],
                      pbBuff))
    {
        fWatt = (gBattInfo.wBatteryMode & BATTMODE_CAPMODE_POWER) != 0;
    }
    else
    {
        TRACEWARN(("failed to get battery mode.\n"));
    }

    for (i = 0, pbBuff = (PBYTE)&gBattInfo; i < NUM_BATT_CMDS; ++i)
    {
        if (GetSMBDevInfo(SMB_BATTERY_ADDRESS, &gBattCmds[i], pbBuff))
        {
            DisplayBatteryInfo(hwndEdit, &gBattCmds[i], pbBuff, fWatt);
        }
        else
        {
            TRACEWARN(("failed to get battery info. for %s.\n",
                       gBattCmds[i].pszLabel));
        }
        pbBuff += gBattCmds[i].iDataSize;
    }

    //
    // Scroll back to the top.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, 0);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    TRACEEXIT(("!\n"));
    return;
}       //RefreshBatteryInfo

/*++
    @doc    INTERNAL

    @func   BOOL | DisplayBatteryInfo | Display battery info.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN PSMBCMD_INFO | BattCmd | Points to the battery command.
    @parm   IN PBYTE | pbBuff | Battery data to display.
    @parm   IN BOOL | fWatt | If TRUE, Battery is in mW mode

    @rvalue SUCCESS | Returns TRUE if it handles it.
    @rvalue FAILURE | Returns FALSE if it doesn't handle it.
--*/

BOOL
DisplayBatteryInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO BattCmd,
    IN PBYTE        pbBuff,
    IN BOOL         fWatt
    )
{
    TRACEPROC("DisplayBatteryInfo", 3)
    BOOL rc = TRUE;
    WORD wData = *((PWORD)pbBuff);

    TRACEENTER(("(hwndEdit=%x,BattCmd=%p,Cmd=%s,pbBuff=%p,fWatt=%x)\n",
                hwndEdit, BattCmd, BattCmd->pszLabel, pbBuff, fWatt));

    EditPrintf(hwndEdit, "%s=", BattCmd->pszLabel);
    switch (BattCmd->bType)
    {
        case TYPEF_WORD_CAP:
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       fWatt? wData*10: wData,
                       fWatt? "mWH": "mAH");
            break;

        case TYPEF_WORD_RATE:
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       (SHORT)(fWatt? wData*10: wData),
                       fWatt? "mW": "mA");
            break;

        case TYPEF_WORD_STATUS:
            EditPrintf(hwndEdit, "0x%04x", wData);
            DisplayDevBits(hwndEdit,
                           BattCmd->dwData,
                           (PSZ *)BattCmd->pvData,
                           (DWORD)wData);
            EditPrintf(hwndEdit,
                       ",ErrCode:%x\r\n",
                       wData & BATTSTATUS_ERRCODE_MASK);
            break;

        case TYPEF_WORD_TEMP:
            EditPrintf(hwndEdit, "%4d.%1d \xb0K\r\n", wData/10, wData%10);
            break;

        case TYPEF_WORD_SPECINFO:
            EditPrintf(hwndEdit,
                       "Rev:%d,Ver:%d,VScale:%d,IPScale:%d\r\n",
                       SPECINFO_REVISION(wData),
                       SPECINFO_VERSION(wData),
                       SPECINFO_VSCALE(wData),
                       SPECINFO_IPSCALE(wData));
            break;

        case TYPEF_WORD_DATE:
            EditPrintf(hwndEdit,
                       "%02d/%02d/%04d\r\n",
                       MANUDATE_MONTH(wData),
                       MANUDATE_DAY(wData),
                       MANUDATE_YEAR(wData));
            break;

        case TYPEF_WORD_TIME:
            if (wData == 0xffff)
            {
                EditPrintf(hwndEdit, "%6s\r\n", "n/a");
            }
            else if ((wData/60) == 0)
            {
                EditPrintf(hwndEdit, "%6d minutes\r\n", wData);
            }
            else
            {
                EditPrintf(hwndEdit, "%3d:%02d hours\r\n",
                           wData/60, wData%60);
            }
            break;

        case TYPEF_MANU_DATA:
        {
            static PSZ pszManuModeNames[] =
            {
                "AutoOffsetCal",
                "ShelfSleep",
                "CalMode",
                "VCellReport",
                "LEDDesign",
                "ForceAutoOffsetCal"
            };
            static char szUnitMOhms[] = "mOhm";
            static SMBCMD_INFO ManuData[] =
            {0, 0, WDC, sizeof(WORD), "           CFVolt", NULL, 0, NULL,
             0, 0, WDC, sizeof(WORD), "           CFCurr", NULL, 0, NULL,
             0, 0, WDC, sizeof(WORD), "           CFTemp", NULL, 0, NULL,
             0, 0, TPC, sizeof(WORD), "      AlarmHiTemp", NULL, 0, NULL,
             0, 0, TPC, sizeof(WORD), "             TMax", NULL, 0, NULL,
             0, 0, WDC, sizeof(WORD), "          ITFOver", NULL, 0, NULL,
             0, 0, RES, sizeof(WORD), "          PackRes", szUnitMOhms, 0, NULL,
             0, 0, RES, sizeof(WORD), "         ShuntRes", szUnitMOhms, 0, NULL,
             0, 0, BDC, sizeof(BYTE), "            Cells", NULL, 0, NULL,
             0, 0, BDC, sizeof(BYTE), "           COVolt", NULL, 0, NULL,
             0, 0, BDC, sizeof(BYTE), "           COCurr", NULL, 0, NULL,
             0, 0, BDC, sizeof(BYTE), "              COD", NULL, 0, NULL,
             0, 0, BBT, sizeof(BYTE), "        ManufMode", NULL, 0xfc, pszManuModeNames};
            #define NUM_MANU_DATA   (sizeof(ManuData)/sizeof(SMBCMD_INFO))
            int i;

            TRACEASSERT(((PBLOCK_DATA)pbBuff)->bBlockLen == 21);
            EditPrintf(hwndEdit, "PS331...\r\n");
            pbBuff = ((PBLOCK_DATA)pbBuff)->BlockData;
            for (i = 0; i < NUM_MANU_DATA; ++i)
            {
                DisplayBatteryInfo(hwndEdit, &ManuData[i], pbBuff, fWatt);
                pbBuff += ManuData[i].iDataSize;
            }
            break;
        }

        case TYPEF_TEMP_CELSIUS:
            wData = *((PWORD)pbBuff);
            EditPrintf(hwndEdit, "%6d " "\xb0" "C\r\n", (wData - 150 + 5)/11);
            break;

        case TYPEF_WORD_RESISTOR:
        {
            DWORD dwData = (DWORD)(*((PWORD)pbBuff)*10000/65536 + 5);

            dwData /= 10;
            EditPrintf(hwndEdit, "%6d mOhm\r\n", dwData);
            break;
        }

        default:
            rc = DisplaySMBDevInfo(hwndEdit, BattCmd, pbBuff);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DisplayBatteryInfo

#endif  //ifdef BATTINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\buttons.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    buttons.c

Abstract: Tablet PC Buttons Property Sheet module.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef BUTTONPAGE
#define NUM_HOTKEY_BUTTONS      2
BUTTON_SETTINGS gButtonSettings = {0};
DWORD gButtonTags[NUM_BUTTONS] =
{
    0x00000004,
    0x00000002,
    0x00000001,
    0x00000010,
    0x00000008
};
int giButtonComboIDs[] =
{
    IDC_BUTTON_1,
    IDC_BUTTON_2,
    IDC_BUTTON_3,
    IDC_BUTTON_4,
    IDC_BUTTON_5
};
COMBOBOX_STRING ButtonComboStringTable[] =
{
    ButtonNoAction,             IDS_BUTCOMBO_NONE,
    InvokeNoteBook,             IDS_BUTCOMBO_INVOKENOTEBOOK,
    PageUp,                     IDS_BUTCOMBO_PAGEUP,
    PageDown,                   IDS_BUTCOMBO_PAGEDOWN,
    AltEsc,                     IDS_BUTCOMBO_ALTESC,
    AltTab,                     IDS_BUTCOMBO_ALTTAB,
    Enter,                      IDS_BUTCOMBO_ENTER,
    Esc,                        IDS_BUTCOMBO_ESC,
    0,                          0
};
DWORD gButtonsHelpIDs[] =
{
    IDC_BUTTON_1,               IDH_BUTTONS_BUTTONMAP,
    IDC_BUTTON_2,               IDH_BUTTONS_BUTTONMAP,
    IDC_BUTTON_3,               IDH_BUTTONS_BUTTONMAP,
    IDC_BUTTON_4,               IDH_BUTTONS_BUTTONMAP,
    IDC_BUTTON_5,               IDH_BUTTONS_BUTTONMAP,
    0,                          0
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   INT_PTR | ButtonsDlgProc |
 *          Dialog procedure for the buttons page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

INT_PTR APIENTRY
ButtonsDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("ButtonsDlgProc", 2)
    INT_PTR rc = FALSE;
    static BOOL fInitDone = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames), wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitButtonPage(hwnd);
            if (rc == FALSE)
            {
                EnableWindow(hwnd, FALSE);
            }
            else
            {
                fInitDone = TRUE;
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                    RPC_TRY("TabSrvSetButtonSettings",
                            rc = TabSrvSetButtonSettings(ghBinding,
                                                         &gButtonSettings));
                    if (rc == FALSE)
                    {
                        ErrorMsg(IDSERR_TABSRV_SETBUTTONSETTINGS);
                    }
                    break;
            }
            break;
        }

        case WM_COMMAND:
        {
            int iButtonMapping;
            int i, j;

            switch (LOWORD(wParam))
            {
                case IDC_BUTTON_1:
                    i = BUTTON_1;
                    goto ButtonCommon;

                case IDC_BUTTON_2:
                    i = BUTTON_2;
                    goto ButtonCommon;

                case IDC_BUTTON_3:
                    i = BUTTON_3;
                    goto ButtonCommon;

                case IDC_BUTTON_4:
                    i = BUTTON_4;
                    goto ButtonCommon;

                case IDC_BUTTON_5:
                    i = BUTTON_5;

                ButtonCommon:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            iButtonMapping =
                                (int)SendMessage(GetDlgItem(hwnd,
                                                            LOWORD(wParam)),
                                                 CB_GETCURSEL,
                                                 0,
                                                 0);
                            j = MapButtonTagIndex(i);
                            if (iButtonMapping != gButtonSettings.ButtonMap[j])
                            {
                                //
                                // Mapping has changed, mark the property
                                // sheet dirty.
                                //
                                gButtonSettings.ButtonMap[j] = iButtonMapping;
                                SendMessage(GetParent(hwnd),
                                            PSM_CHANGED,
                                            (WPARAM)hwnd,
                                            0);
                                rc = TRUE;
                            }
                            break;
                    }
                    break;

                case IDC_HOTKEY1:
                case IDC_HOTKEY2:
                    switch (HIWORD(wParam))
                    {
                        case EN_UPDATE:
                        {
                            int hk1, hk2;
                            BOOL fOK1, fOK2;

                            hk1 = GetDlgItemInt(hwnd,
                                                IDC_HOTKEY1,
                                                &fOK1,
                                                FALSE);
                            hk2 = GetDlgItemInt(hwnd,
                                                IDC_HOTKEY2,
                                                &fOK2,
                                                FALSE);
                            if (fOK1 && fOK2 &&
                                (hk1 > 0) && (hk1 <= NUM_BUTTONS) &&
                                (hk2 > 0) && (hk2 <= NUM_BUTTONS))
                            {
                                gButtonSettings.dwHotKeyButtons =
                                    gButtonTags[hk1 - 1] |
                                    gButtonTags[hk2 - 1];
                                SendMessage(GetParent(hwnd),
                                            PSM_CHANGED,
                                            (WPARAM)hwnd,
                                            0);
                            }
                            else if (fInitDone)
                            {
                                SendMessage((HWND)lParam,
                                            EM_SETSEL,
                                            0,
                                            -1);
                                MessageBeep(MB_ICONEXCLAMATION);
                            }
                            break;
                        }
                    }
                    break;
            }
            break;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    TEXT("tabletpc.hlp"),
                    HELP_WM_HELP,
                    (DWORD_PTR)gButtonsHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam,
                    TEXT("tabletpc.hlp"),
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)gButtonsHelpIDs);
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //ButtonsDlgProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | InitButtonPage |
 *          Initialize the Button property page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
InitButtonPage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitButtonPage", 2)
    BOOL rc;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    RPC_TRY("TabSrvGetButtonSettings",
            rc = TabSrvGetButtonSettings(ghBinding,
                                         &gButtonSettings));
    if (rc == TRUE)
    {
        int i, j;
        int HotKeys[2] = {0, 0};

        for (i = 0; i < NUM_BUTTONS; i++)
        {
            InsertComboBoxStrings(hwnd,
                                  giButtonComboIDs[i],
                                  ButtonComboStringTable);
            j = MapButtonTagIndex(i);
            SendDlgItemMessage(hwnd,
                               giButtonComboIDs[i],
                               CB_SETCURSEL,
                               gButtonSettings.ButtonMap[j],
                               0);
        }

        for (i = 0, j = 0; i < NUM_BUTTONS; i++)
        {
            if (gButtonSettings.dwHotKeyButtons & gButtonTags[i])
            {
                HotKeys[j] = i + 1;
                j++;
                if (j >= NUM_HOTKEY_BUTTONS)
                {
                    break;
                }
            }
        }

        SendDlgItemMessage(hwnd,
                           IDC_HOTKEY1_SPIN,
                           UDM_SETRANGE32,
                           1,
                           NUM_BUTTONS);
        SendDlgItemMessage(hwnd,
                           IDC_HOTKEY2_SPIN,
                           UDM_SETRANGE32,
                           1,
                           NUM_BUTTONS);

        SendDlgItemMessage(hwnd,
                           IDC_HOTKEY1_SPIN,
                           UDM_SETPOS32,
                           0,
                           HotKeys[0]);
        SendDlgItemMessage(hwnd,
                           IDC_HOTKEY2_SPIN,
                           UDM_SETPOS32,
                           0,
                           HotKeys[1]);
    }
    else
    {
        ErrorMsg(IDSERR_TABSRV_GETBUTTONSETTINGS);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitButtonPage

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | MapButtonTagIndex | Map button tag index by Button Number.
 *
 *  @parm   IN int | iButton | Button Number.
 *
 *  @rvalue SUCCESS | Returns Button Tag index.
 *  @rvalue FAILURE | Returns -1.
 *
 *****************************************************************************/

int
MapButtonTagIndex(
    IN int iButton
    )
{
    TRACEPROC("MapButtonTagIndex", 3)
    int i;

    TRACEENTER(("(ButtonNumber=%d)\n", iButton));

    for (i = 0; i < NUM_BUTTONS; ++i)
    {
        if (gButtonTags[iButton] == (1 << i))
        {
            break;
        }
    }

    if (i == NUM_BUTTONS)
    {
        i = -1;
    }

    TRACEEXIT(("=%d\n", i));
    return i;
}       //MapButtonTagIndex
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\battinfo.h ===
/*++
    Copyright (c) 2000,2001  Microsoft Corporation

    Module Name:
        battinfo.h

    Abstract:  Contains Smart Battery Information definitions.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 23-Jan-2001

    Revision History:
--*/

#ifndef _BATTINFO_H
#define _BATTINFO_H

//
// Constants
//
#define SMB_BATTERY_ADDRESS             0x0b    //Address on bus (0x16)

// Battery commands
#define BATTCMD_MANUFACTURER_ACCESS     0x00
#define BATTCMD_REMAININGCAP_ALARM      0x01
#define BATTCMD_REMAININGTIME_ALARM     0x02
#define BATTCMD_BATTERY_MODE            0x03
#define BATTCMD_ATRATE                  0x04
#define BATTCMD_ATRATE_TIMETOFULL       0x05
#define BATTCMD_ATRATE_TIMETOEMPTY      0x06
#define BATTCMD_ATRATE_OK               0x07
#define BATTCMD_TEMPERATURE             0x08
#define BATTCMD_VOLTAGE                 0x09
#define BATTCMD_CURRENT                 0x0a
#define BATTCMD_AVG_CURRENT             0x0b
#define BATTCMD_MAX_ERROR               0x0c
#define BATTCMD_REL_STATEOFCHARGE       0x0d
#define BATTCMD_ABS_STATEOFCHARGE       0x0e
#define BATTCMD_REMAININGCAP            0x0f
#define BATTCMD_FULLCHARGECAP           0x10
#define BATTCMD_RUNTIMETOEMPTY          0x11
#define BATTCMD_AVGTIMETOEMPTY          0x12
#define BATTCMD_AVGTIMETOFULL           0x13
#define BATTCMD_CHARGING_CURRENT        0x14
#define BATTCMD_CHARGING_VOLTAGE        0x15
#define BATTCMD_BATTERY_STATUS          0x16
#define BATTCMD_CYCLE_COUNT             0x17
#define BATTCMD_DESIGN_CAP              0x18
#define BATTCMD_DESIGN_VOLTAGE          0x19
#define BATTCMD_SPEC_INFO               0x1a
#define BATTCMD_MANUFACTURE_DATE        0x1b
#define BATTCMD_SERIAL_NUM              0x1c
#define BATTCMD_MANUFACTURER_NAME       0x20
#define BATTCMD_DEVICE_NAME             0x21
#define BATTCMD_DEVICE_CHEMISTRY        0x22
#define BATTCMD_MANUFACTURER_DATA       0x23

// Battery Mode bits
#define BATTCAP_INTERNAL_CHARGE_CTRLER  0x0001
#define BATTCAP_PRIMARY_BATT_SUPPORT    0x0002
#define BATTMODE_CONDITIONING_REQUESTED 0x0080
#define BATTMODE_CHARGE_CTRLER_ENABLED  0x0100
#define BATTMODE_PRIMARY_BATTERY        0x0200
#define BATTMODE_DIS_BROADCAST_CHARGER  0x4000
#define BATTMODE_CAPMODE_POWER          0x8000

//Battery Status bits
#define BATTSTATUS_ERRCODE_MASK         0x000f
#define BATTSTATUS_FULLY_DISCHARGED     0x0010
#define BATTSTATUS_FULLY_CHARGED        0x0020
#define BATTSTATUS_DISCHARGING          0x0040
#define BATTSTATUS_INITIALIZED          0x0080
#define BATTALARM_REMAINING_TIME        0x0100
#define BATTALARM_REMAINING_CAP         0x0200
#define BATTALARM_TERMINATE_DISCHARGE   0x0800
#define BATTALARM_OVER_TEMP             0x1000
#define BATTALARM_TERMINATE_CHARGE      0x4000
#define BATTALARM_OVER_CHARGED          0x8000

//Spec. Info bits
#define SPECINFO_REVISION_MASK          0x000f
#define SPECINFO_VERSION_MASK           0x00f0
#define SPECINFO_VSCALE_MASK            0x0f00
#define SPECINFO_IPSCALE_MASK           0xf000
#define SPECINFO_REVISION(x)            ((x) & SPECINFO_REVISION_MASK)
#define SPECINFO_VERSION(x)             (((x) & SPECINFO_VERSION_MASK) >> 4)
#define SPECINFO_VSCALE(x)              (((x) & SPECINFO_VSCALE_MASK) >> 8)
#define SPECINFO_IPSCALE(x)             (((x) & SPECINFO_IPSCALE_MASK) >> 12)

//Manufacture Date bits
#define MANUDATE_DAY_MASK               0x001f
#define MANUDATE_MONTH_MASK             0x01e0
#define MANUDATE_YEAR_MASK              0xfe00
#define MANUDATE_DAY(x)                 ((x) & MANUDATE_DAY_MASK)
#define MANUDATE_MONTH(x)               (((x) & MANUDATE_MONTH_MASK) >> 5)
#define MANUDATE_YEAR(x)                ((((x) & MANUDATE_YEAR_MASK) >> 9) + \
                                         1980)
#include <pshpack1.h>
typedef struct _BATT_INFO
{
    USHORT wManufacturerAccess;         //[00]Word R/W
    USHORT wRemainingCapAlarm;          //[01]Word R/W (maH/10mwH)
    USHORT wRemainingTimeAlarm;         //[02]Word R/W (minutes)
    USHORT wBatteryMode;                //[03]Word R/W
    SHORT  sAtRate;                     //[04]Word R/W (ma/10mw)
    USHORT wAtRateTimeToFull;           //[05]Word R (minutes)
    USHORT wAtRateTimeToEmpty;          //[06]Word R (minutes)
    USHORT wfAtRateOK;                  //[07]Word R (TRUE/FALSE)
    USHORT wTemperature;                //[08]Word R (0.1K)
    USHORT wVoltage;                    //[09]Word R (mv)
    SHORT  sCurrent;                    //[0a]Word R (ma)
    SHORT  sAvgCurrent;                 //[0b]Word R (ma)
    USHORT wMaxError;                   //[0c]Word R (%)
    USHORT wRelStateOfCharge;           //[0d]Word R (%)
    USHORT wAbsStateOfCharge;           //[0e]Word R (%)
    USHORT wRemainingCap;               //[0f]Word R (maH/10mwH)
    USHORT wFullChargeCap;              //[10]Word R (maH/10mwH)
    USHORT wRunTimeToEmpty;             //[11]Word R (minutes)
    USHORT wAvgTimeToEmpty;             //[12]Word R (minutes)
    USHORT wAvgTimeToFull;              //[13]Word R (minutes)
    USHORT wChargingCurrent;            //[14]Word R (ma)
    USHORT wChargingVoltage;            //[15]Word R (mv)
    USHORT wBatteryStatus;              //[16]Word R
    USHORT wCycleCount;                 //[17]Word R (cycles)
    USHORT wDesignCap;                  //[18]Word R (maH/10mwH)
    USHORT wDesignVoltage;              //[19]Word R (mv)
    USHORT wSpecInfo;                   //[1a]Word R
    USHORT wManufactureDate;            //[1b]Word R
    USHORT wSerialNum;                  //[1c]Word R
    BLOCK_DATA ManufacturerName;        //[20]Block R (string)
    BLOCK_DATA DeviceName;              //[21]Block R (string)
    BLOCK_DATA DeviceChemistry;         //[22]Block R (string)
    BLOCK_DATA ManufacturerData;        //[23]Block R (bytes)
} BATT_INFO, *PBATT_INFO;
#include <poppack.h>

#define TYPEF_WORD_CAP                  (TYPEF_USER + 0x00)
#define TYPEF_WORD_RATE                 (TYPEF_USER + 0x01)
#define TYPEF_WORD_STATUS               (TYPEF_USER + 0x02)
#define TYPEF_WORD_TEMP                 (TYPEF_USER + 0x03)
#define TYPEF_WORD_SPECINFO             (TYPEF_USER + 0x04)
#define TYPEF_WORD_DATE                 (TYPEF_USER + 0x05)
#define TYPEF_WORD_TIME                 (TYPEF_USER + 0x06)
#define TYPEF_MANU_DATA                 (TYPEF_USER + 0x07)
#define TYPEF_TEMP_CELSIUS              (TYPEF_USER + 0x08)
#define TYPEF_WORD_RESISTOR             (TYPEF_USER + 0x09)

#define CAP                             TYPEF_WORD_CAP
#define RAT                             TYPEF_WORD_RATE
#define MOD                             TYPEF_WORD_MODE
#define STA                             TYPEF_WORD_STATUS
#define TMP                             TYPEF_WORD_TEMP
#define SPI                             TYPEF_WORD_SPECINFO
#define DAT                             TYPEF_WORD_DATE
#define TIM                             TYPEF_WORD_TIME
#define MAN                             TYPEF_MANU_DATA
#define TPC                             TYPEF_TEMP_CELSIUS
#define RES                             TYPEF_WORD_RESISTOR

#endif  //ifndef _BATTINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\buttons.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    buttons.h

Abstract:  Contains definitions of the TabletPC Buttons.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#ifndef _BUTTONS_H
#define _BUTTONS_H

#define NUM_BUTTONS                     5

#define BUTCOMBO_NONE                   0
#define BUTCOMBO_CLICK                  1
#define BUTCOMBO_RCLICK                 2
#define BUTCOMBO_AUTOSCROLL             3
#define BUTCOMBO_BACK                   4
#define BUTCOMBO_FORWARD                5
#define BUTCOMBO_ALT                    6
#define BUTCOMBO_BACKSPACE              7
#define BUTCOMBO_CLOSE                  8
#define BUTCOMBO_COPY                   9
#define BUTCOMBO_CTRL                   10
#define BUTCOMBO_CUT                    11
#define BUTCOMBO_DELETE                 12
#define BUTCOMBO_DBLCLICK               13
#define BUTCOMBO_ENTER                  14
#define BUTCOMBO_EXPLORE_COMPUTER       15
#define BUTCOMBO_F1                     16
#define BUTCOMBO_F2                     17
#define BUTCOMBO_F3                     18
#define BUTCOMBO_F4                     19
#define BUTCOMBO_F5                     20
#define BUTCOMBO_F6                     21
#define BUTCOMBO_F7                     22
#define BUTCOMBO_F8                     23
#define BUTCOMBO_F9                     24
#define BUTCOMBO_F10                    25
#define BUTCOMBO_F11                    26
#define BUTCOMBO_F12                    27
#define BUTCOMBO_FAVORITES              28
#define BUTCOMBO_FIND_COMPUTER          29
#define BUTCOMBO_FIND_FILES             30
#define BUTCOMBO_MAXIMIZE               31
#define BUTCOMBO_MINIMIZE               32
#define BUTCOMBO_PAGE_DOWN              33
#define BUTCOMBO_PAGE_UP                34
#define BUTCOMBO_PASTE                  35
#define BUTCOMBO_RECALL_WINDOW          36
#define BUTCOMBO_REDO                   37
#define BUTCOMBO_RUN                    38
#define BUTCOMBO_SELECT_ALL             39
#define BUTCOMBO_SHIFT                  40
#define BUTCOMBO_SHOWHIDE_DESKTOP       41
#define BUTCOMBO_START_MENU             42
#define BUTCOMBO_STOP                   43
#define BUTCOMBO_UNDO                   44

#endif  //ifndef _BUTTONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\chgrinfo.h ===
/*++
    Copyright (c) 2000,2001  Microsoft Corporation

    Module Name:
        chgrinfo.h

    Abstract:  Contains SMBus Battery Charger Information definitions.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 26-Jan-2001

    Revision History:
--*/

#ifndef _CHGRINFO_H
#define _CHGRINFO_H

//
// Constants
//
#define SMB_CHARGER_ADDRESS             0x09    //Address on bus (0x12)

// Temperature sensor commands
#define CHGRCMD_SPECINFO                0x11    //Read
#define CHGRCMD_CHARGER_MODE            0x12    //Write
#define CHGRCMD_STATUS                  0x13    //Read
#define CHGRCMD_CHARGING_CURRENT        0x14    //Write
#define CHGRCMD_CHARGING_VOLTAGE        0x15    //Write
#define CHGRCMD_ALARM_WARNING           0x16    //Write
#define CHGRCMD_LTC_VERSION             0x3c    //Read

// SpecInfo bits
#define CHGRSI_SPEC_MASK                0x000f
#define CHGRSI_SELECTOR_SUPPORT         0x0010

// Status bits
#define CHGRSTATUS_CHARGE_INHIBITED     0x0001
#define CHGRSTATUS_MASTER_MODE          0x0002
#define CHGRSTATUS_VOLTAGE_NOTREG       0x0004
#define CHGRSTATUS_CURRENT_NOTREG       0x0008
#define CHGRSTATUS_CTRL_MASK            0x0030
#define CHGRSTATUS_CTRL_BATT            0x0010
#define CHGRSTATUS_CTRL_HOST            0x0030
#define CHGRSTATUS_CURRENT_INVALID      0x0040
#define CHGRSTATUS_VOLTAGE_INVALID      0x0080
#define CHGRSTATUS_THERM_OVERRANGE      0x0100
#define CHGRSTATUS_THERM_COLD           0x0200
#define CHGRSTATUS_THERM_HOT            0x0400
#define CHGRSTATUS_THERM_UNDERRANGE     0x0800
#define CHGRSTATUS_ALARM_INHIBITED      0x1000
#define CHGRSTATUS_POWER_FAIL           0x2000
#define CHGRSTATUS_BATT_PRESENT         0x4000
#define CHGRSTATUS_AC_PRESENT           0x8000

#include <pshpack1.h>
typedef struct _CHGR_INFO
{
    WORD wChargerSpecInfo;
    WORD wChargerStatus;
    WORD wLTCVersion;
} CHGR_INFO, *PCHGR_INFO;
#include <poppack.h>

#define TYPEF_CHGR_SPECINFO             (TYPEF_USER + 0x10)
#define TYPEF_CHGR_STATUS               (TYPEF_USER + 0x11)

#define CSI                             TYPEF_CHGR_SPECINFO
#define CST                             TYPEF_CHGR_STATUS

#endif  //ifndef CHGRINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\debug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    debug.c

Abstract: This module contains all the debug functions.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef DEBUG
NAMETABLE CPLMsgNames[] =
{
    CPL_INIT,                           "Init",
    CPL_GETCOUNT,                       "GetCount",
    CPL_INQUIRE,                        "Inquire",
    CPL_SELECT,                         "Select",
    CPL_DBLCLK,                         "DoubleClick",
    CPL_STOP,                           "Stop",
    CPL_EXIT,                           "Exit",
    CPL_NEWINQUIRE,                     "NewInquire",
    CPL_STARTWPARMSA,                   "StartWParamsA",
    CPL_STARTWPARMSW,                   "StartWParamsW",
    CPL_SETUP,                          "Setup",
    0x00,                               NULL
};
#endif  //ifdef DEBUG

/*++
    @doc    INTERNAL

    @func   VOID | ErrorMsg | Put out an error message box.

    @parm   IN ULONG | ErrCode | The given error code.
    @parm   ... | Substituting arguments for the error message.

    @rvalue Returns the number of chars in the message.
--*/

int INTERNAL
ErrorMsg(
    IN ULONG ErrCode,
    ...
    )
{
    static TCHAR tszFormat[1024];
    static TCHAR tszErrMsg[1024];
    int n;
    va_list arglist;

    LoadString(ghInstance, ErrCode, tszFormat, sizeof(tszFormat)/sizeof(TCHAR));
    va_start(arglist, ErrCode);
    n = wvsprintf(tszErrMsg, tszFormat, arglist);
    va_end(arglist);
    MessageBox(NULL, tszErrMsg, gtszTitle, MB_OK | MB_ICONERROR);

    return n;
}       //ErrorMsg

/*++
    @doc    INTERNAL

    @func   ULONG | MapError | Map error from one component to another.

    @parm   IN ULONG | dwErrCode | The given error code.
    @parm   IN PERRMAP | ErrorMap | Points to the error map.
    @parm   IN BOOL | fReverse | If TRUE, do a reverse lookup.

    @rvalue Returns the mapped error number.
--*/

ULONG INTERNAL
MapError(
    IN ULONG   dwErrCode,
    IN PERRMAP ErrorMap,
    IN BOOL    fReverse
    )
{
    ULONG dwMapErr = 0;

    while ((ErrorMap->dwFromCode != 0) || (ErrorMap->dwToCode != 0))
    {
        if (!fReverse)
        {
            if (dwErrCode == ErrorMap->dwFromCode)
            {
                dwMapErr = ErrorMap->dwToCode;
                break;
            }
        }
        else
        {
            if (dwErrCode == ErrorMap->dwToCode)
            {
                dwMapErr = ErrorMap->dwFromCode;
                break;
            }
        }
        ErrorMap++;
    }

    return dwMapErr;
}       //MapError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\chgrinfo.c ===
/*++
    Copyright (c) 2000,2001 Microsoft Corporation

    Module Name:
        chgrinfo.c

    Abstract: SMBus Battery Charger Information Property Sheet module.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 26-Jan-2001

    Revision History:
--*/

#include "pch.h"

#ifdef CHGRINFO

PSZ gapszChgrStatus1Names[] =
{
    "ACPresent",
    "BattPresent",
    "PwrFail",
    "AlarmDisabled",
    "ThermUR",
    "ThermHot",
    "ThermCold",
    "ThermOR",
    "InvalidVoltage",
    "InvalidCurrent"
};
PSZ gapszChgrStatus2Names[] =
{
    "CurrentNotInReg",
    "VoltageNotInReg",
    "MasterMode",
    "Disabled"
};

SMBCMD_INFO gChgrCmds[] =
{
    CHGRCMD_SPECINFO,    SMB_READ_WORD,        CSI, sizeof(WORD),
        "ChargerSpecInfo", NULL, 0, NULL,
    CHGRCMD_STATUS,      SMB_READ_WORD,        CST, sizeof(WORD),
        "  ChargerStatus", NULL, 0xffc0, gapszChgrStatus1Names,
    CHGRCMD_LTC_VERSION, SMB_READ_WORD, WHX, sizeof(WORD),
        "     LTCVersion", NULL, 0, NULL,
};
#define NUM_CHGR_CMDS   (sizeof(gChgrCmds)/sizeof(SMBCMD_INFO))

CHGR_INFO gChgrInfo = {0};

/*++
    @doc    EXTERNAL

    @func   INT_PTR | ChargerDlgProc |
            Dialog procedure for the battery charger page.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uMsg | Message.
    @parm   IN WPARAM | wParam | Word Parameter.
    @parm   IN LPARAM | lParam | Long Parameter.

    @rvalue Return value depends on the message.
--*/

INT_PTR APIENTRY
ChargerDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("ChargerDlgProc", 2)
    INT_PTR rc = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitChargerPage(hwnd);
            if (!rc)
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_QUERYINITIALFOCUS:
                {
                    SetWindowLong(hwnd,
                                  DWL_MSGRESULT,
                                  (LONG)GetDlgItem(hwnd, IDC_CHGRINFO_REFRESH));
                    rc = TRUE;
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CHGRINFO_REFRESH:
                    RefreshChgrInfo(GetDlgItem(hwnd, IDC_CHGRINFO_TEXT));
                    break;
            }
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //ChargerDlgProc

/*++
    @doc    INTERNAL

    @func   BOOL | InitChargerPage |
            Initialize the battery charger property page.

    @parm   IN HWND | hwnd | Window handle.

    @rvalue Always returns TRUE.
--*/

BOOL
InitChargerPage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitChargerPage", 2)
    HWND hwndEdit;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    hwndEdit = GetDlgItem(hwnd, IDC_CHGRINFO_TEXT);
    SendMessage(hwndEdit, WM_SETFONT, (WPARAM)ghFont, MAKELONG(FALSE, 0));

    RefreshChgrInfo(hwndEdit);

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //InitChargerPage

/*++
    @doc    INTERNAL

    @func   VOID | RefreshChgrInfo | Refresh charger information.

    @parm   IN HWND | hwndEdit | Handle to edit control.

    @rvalue None.
--*/

VOID
RefreshChgrInfo(
    IN HWND hwndEdit
    )
{
    TRACEPROC("RefreshChgrInfo", 3)
    int i;
    PBYTE pbBuff;

    TRACEENTER(("(hwndEdit=%x)\n", hwndEdit));

    //
    // Erase edit control.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, -1);
    SendMessage(hwndEdit, EM_REPLACESEL, 0, (LPARAM)"");

    memset(&gChgrInfo, 0, sizeof(gChgrInfo));
    for (i = 0, pbBuff = (PBYTE)&gChgrInfo; i < NUM_CHGR_CMDS; ++i)
    {
        if (GetSMBDevInfo(SMB_CHARGER_ADDRESS, &gChgrCmds[i], pbBuff))
        {
            DisplayChgrInfo(hwndEdit, &gChgrCmds[i], pbBuff);
        }
        else
        {
            TRACEWARN(("failed to get charger info. for %s.\n",
                       gChgrCmds[i].pszLabel));
        }
        pbBuff += gChgrCmds[i].iDataSize;
    }

    //
    // Scroll back to the top.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, 0);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    TRACEEXIT(("!\n"));
    return;
}       //RefreshChgrInfo

/*++
    @doc    INTERNAL

    @func   BOOL | DisplayChgrInfo | Display charger info.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN PSMBCMD_INFO | ChgrCmd | Points to the charger command.
    @parm   IN PBYTE | pbBuff | Charger data to display.

    @rvalue SUCCESS | Returns TRUE if it handles it.
    @rvalue FAILURE | Returns FALSE if it doesn't handle it.
--*/

BOOL
DisplayChgrInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO ChgrCmd,
    IN PBYTE        pbBuff
    )
{
    TRACEPROC("DisplayChgrInfo", 3)
    BOOL rc = TRUE;
    WORD wData = *((PWORD)pbBuff);

    TRACEENTER(("(hwndEdit=%x,ChgrCmd=%p,Cmd=%s,pbBuff=%p)\n",
                hwndEdit, ChgrCmd, ChgrCmd->pszLabel, pbBuff));

    EditPrintf(hwndEdit, "%s=", ChgrCmd->pszLabel);
    switch (ChgrCmd->bType)
    {
        case TYPEF_CHGR_SPECINFO:
            EditPrintf(hwndEdit, "0x%04x", wData);
            if (wData & CHGRSI_SELECTOR_SUPPORT)
            {
                EditPrintf(hwndEdit, ",SelectorSupport");
            }
            EditPrintf(hwndEdit, ",Spec:%x\r\n", wData & CHGRSI_SPEC_MASK);
            break;

        case TYPEF_CHGR_STATUS:
            EditPrintf(hwndEdit, "0x%04x", wData);
            DisplayDevBits(hwndEdit,
                           ChgrCmd->dwData,
                           (PSZ *)ChgrCmd->pvData,
                           (DWORD)wData);
            if ((wData & CHGRSTATUS_CTRL_MASK) == CHGRSTATUS_CTRL_BATT)
            {
                EditPrintf(hwndEdit, ",BattCtrl'd");
            }
            else if ((wData & CHGRSTATUS_CTRL_MASK) == CHGRSTATUS_CTRL_HOST)
            {
                EditPrintf(hwndEdit, ",HostCtrl'd");
            }
            DisplayDevBits(hwndEdit,
                           0xf,
                           gapszChgrStatus2Names,
                           (DWORD)wData);
            EditPrintf(hwndEdit, "\r\n");
            break;

        default:
            rc = DisplaySMBDevInfo(hwndEdit, ChgrCmd, pbBuff);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DisplayChgrInfo

#endif  //ifdef CHGRINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:  Contains debug related definitions.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

//
// Type definitions.
//
typedef struct ERRMAP
{
    ULONG dwFromCode;
    ULONG dwToCode;
} ERRMAP, *PERRMAP;

//
// Exported Data Declarations
//
#ifdef DEBUG
extern NAMETABLE CPLMsgNames[];
#endif

//
// Function prototypes
//
int INTERNAL
ErrorMsg(
    IN ULONG      ErrCode,
    ...
    );

ULONG INTERNAL
MapError(
    IN ULONG   dwErrCode,
    IN PERRMAP ErrorMap,
    IN BOOL    fReverse
    );

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\gesture.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    gesture.c

Abstract: Tablet PC Gesture Property Sheet module.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#include "pch.h"

GESTURE_SETTINGS gGestureSettings = {0};
int giGestureControls[] =
{
    IDC_GESTUREMAP_GROUPBOX,
    IDC_UPSPIKE_TEXT,
    IDC_UPSPIKE,
    IDC_DOWNSPIKE_TEXT,
    IDC_DOWNSPIKE,
    IDC_LEFTSPIKE_TEXT,
    IDC_LEFTSPIKE,
    IDC_RIGHTSPIKE_TEXT,
    IDC_RIGHTSPIKE,
    0
};
COMBOBOX_STRING GestureComboStringTable[] =
{
    GestureNoAction,    IDS_GESTCOMBO_NONE,
    PopupSuperTIP,      IDS_GESTCOMBO_POPUP_SUPERTIP,
    PopupMIP,           IDS_GESTCOMBO_POPUP_MIP,
    0,                  0
};
int giGestureComboIDs[] =
{
    IDC_UPSPIKE,
    IDC_DOWNSPIKE,
    IDC_LEFTSPIKE,
    IDC_RIGHTSPIKE
};
DWORD gGestureHelpIDs[] =
{
    IDC_ENABLE_GESTURE, IDH_GESTURE_MAP,
    IDC_UPSPIKE,        IDH_GESTURE_MAP,
    IDC_DOWNSPIKE,      IDH_GESTURE_MAP,
    IDC_LEFTSPIKE,      IDH_GESTURE_MAP,
    IDC_RIGHTSPIKE,     IDH_GESTURE_MAP,
    0,                  0
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   INT_PTR | GestureDlgProc |
 *          Dialog procedure for the Gesture map page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

INT_PTR APIENTRY
GestureDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("GestureDlgProc", 2)
    INT_PTR rc = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames), wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitGesturePage(hwnd);
            if (rc == FALSE)
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                    RPC_TRY("TabSrvSetGestureSettings",
                            rc = TabSrvSetGestureSettings(ghBinding,
                                                          &gGestureSettings));

                    break;
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                int iGestureMapping;
                int i;

                case IDC_ENABLE_GESTURE:
                    gGestureSettings.dwfFeatures &=
                        ~GESTURE_FEATURE_RECOG_ENABLED;
                    if (IsDlgButtonChecked(hwnd, IDC_ENABLE_GESTURE))
                    {
                        gGestureSettings.dwfFeatures |=
                            GESTURE_FEATURE_RECOG_ENABLED;
                    }
                    EnableDlgControls(hwnd,
                                      giGestureControls,
                                      (gGestureSettings.dwfFeatures &
                                       GESTURE_FEATURE_RECOG_ENABLED) != 0);

                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                    break;

                case IDC_UPSPIKE:
                    i = UP_SPIKE;
                    goto GestureCommon;

                case IDC_DOWNSPIKE:
                    i = DOWN_SPIKE;
                    goto GestureCommon;

                case IDC_LEFTSPIKE:
                    i = LEFT_SPIKE;
                    goto GestureCommon;

                case IDC_RIGHTSPIKE:
                    i = RIGHT_SPIKE;

                GestureCommon:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            iGestureMapping =
                                (int)SendMessage(GetDlgItem(hwnd,
                                                            LOWORD(wParam)),
                                                 CB_GETCURSEL,
                                                 0,
                                                 0);
                            if (iGestureMapping !=
                                gGestureSettings.GestureMap[i])
                            {
                                //
                                // Mapping has changed, mark the property
                                // sheet dirty.
                                //
                                gGestureSettings.GestureMap[i] =
                                        iGestureMapping;
                                SendMessage(GetParent(hwnd),
                                            PSM_CHANGED,
                                            (WPARAM)hwnd,
                                            0);
                                rc = TRUE;
                            }
                            break;
                    }
                    break;

                case IDC_ENABLE_PRESSHOLD:
                    gGestureSettings.dwfFeatures &=
                        ~GESTURE_FEATURE_PRESSHOLD_ENABLED;
                    if (IsDlgButtonChecked(hwnd, IDC_ENABLE_PRESSHOLD))
                    {
                        gGestureSettings.dwfFeatures |=
                            GESTURE_FEATURE_PRESSHOLD_ENABLED;
                    }
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                    break;

#ifdef DEBUG
                case IDC_ENABLE_MOUSE:
                    gGestureSettings.dwfFeatures &=
                        ~GESTURE_FEATURE_MOUSE_ENABLED;
                    if (IsDlgButtonChecked(hwnd, IDC_ENABLE_MOUSE))
                    {
                        gGestureSettings.dwfFeatures |=
                            GESTURE_FEATURE_MOUSE_ENABLED;
                    }
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                    break;
#endif
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    TEXT("tabletpc.hlp"),
                    HELP_WM_HELP,
                    (DWORD_PTR)gGestureHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam,
                    TEXT("tabletpc.hlp"),
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)gGestureHelpIDs);
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //GestureDlgProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | InitGesturePage |
 *          Initialize the Gesture property page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
InitGesturePage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitGesturePage", 2)
    BOOL rc;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    RPC_TRY("TabSrvGetGestureSettings",
            rc = TabSrvGetGestureSettings(ghBinding,
                                          &gGestureSettings));
    if (rc == TRUE)
    {
        int i;

        CheckDlgButton(hwnd,
                       IDC_ENABLE_GESTURE,
                       (gGestureSettings.dwfFeatures &
                        GESTURE_FEATURE_RECOG_ENABLED) != 0);

        EnableDlgControls(hwnd,
                          giGestureControls,
                          (gGestureSettings.dwfFeatures &
                           GESTURE_FEATURE_RECOG_ENABLED) != 0);

        CheckDlgButton(hwnd,
                       IDC_ENABLE_PRESSHOLD,
                       (gGestureSettings.dwfFeatures &
                        GESTURE_FEATURE_PRESSHOLD_ENABLED)
                       != 0);

#ifdef DEBUG
        CheckDlgButton(hwnd,
                       IDC_ENABLE_MOUSE,
                       (gGestureSettings.dwfFeatures &
                        GESTURE_FEATURE_MOUSE_ENABLED)
                       != 0);
#endif

        for (i = 0; i < NUM_GESTURES; i++)
        {
            InsertComboBoxStrings(hwnd,
                                  giGestureComboIDs[i],
                                  GestureComboStringTable);
            SendDlgItemMessage(hwnd,
                               giGestureComboIDs[i],
                               CB_SETCURSEL,
                               gGestureSettings.GestureMap[i],
                               0);
        }
    }
    else
    {
        ErrorMsg(IDSERR_TABSRV_GETGESTURESETTINGS);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitGesturePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\display.c ===
/*++
    Copyright (c) 2000 Microsoft Corporation

    Module Name:
        display.c

    Abstract: Tablet PC Display Property Sheet module.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 14-Jun-2000

    Revision History:
--*/

#include "pch.h"

#define BRIGHTSCALE_MIN         0
#define BRIGHTSCALE_MAX         15

#define BRIGHTSCALE_LO          1
#define BRIGHTSCALE_HI          15

HANDLE  ghBackLight = INVALID_HANDLE_VALUE;
HMODULE ghmodSMAPI = NULL;
FARPROC gpfnCallSMAPI = NULL;
ERRMAP SMAPIErrMap[] =
{
    RT_ERR_INSTRETCHMODE,       IDSERR_SMAPI_INSTRETCHMODE,
    RT_ERR_INDUALAPPMODE,       IDSERR_SMAPI_INDUALAPPMODE,
    RT_ERR_INDUALVIEWMODE,      IDSERR_SMAPI_INDUALVIEWMODE,
    RT_ERR_INRGBPROJMODE,       IDSERR_SMAPI_INRGBPROJMODE,
    RT_ERR_INVIRTUALSCREEN,     IDSERR_SMAPI_INVIRTUALSCREEN,
    RT_ERR_INVIRTUALREFRESH,    IDSERR_SMAPI_INVIRTUALREFRESH,
    RT_ERR_INROTATEMODE,        IDSERR_SMAPI_INROTATEMODE,
    RT_ERR_2NDMONITORON,        IDSERR_SMAPI_2NDMONITORON,
    RT_ERR_WRONGHW,             IDSERR_SMAPI_WRONGHW,
    RT_ERR_CLRDEPTH,            IDSERR_SMAPI_CLRDEPTH,
    RT_ERR_MEMORY,              IDSERR_SMAPI_MEMORY,
    RT_ERR_SETMODE,             IDSERR_SMAPI_SETMODE,
    RT_ERR_DIRECTION,           IDSERR_SMAPI_DIRECTION,
    RT_ERR_CAPTUREON,           IDSERR_SMAPI_CAPTUREON,
    RT_ERR_VIDEOON,             IDSERR_SMAPI_VIDEOON,
    RT_ERR_DDRAWON,             IDSERR_SMAPI_DDRAWON,
    RT_ERR_ALREADYSET,          IDSERR_SMAPI_ALREADYSET,
    0,                          0
};

SMBLITE_BRIGHTNESS gBrightness = {0};
BOOL  gfPortraitMode = FALSE;
DWORD gDisplayHelpIDs[] =
{
    IDC_ROTATE_GROUPBOX,        IDH_ROTATE,
    0,                          0
};

/*++
    @doc    EXTERNAL

    @func   INT_PTR | DisplayDlgProc |
            Dialog procedure for the display page.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uMsg | Message.
    @parm   IN WPARAM | wParam | Word Parameter.
    @parm   IN LPARAM | lParam | Long Parameter.

    @rvalue Return value depends on the message.
--*/

INT_PTR APIENTRY
DisplayDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("DisplayDlgProc", 2)
    INT_PTR rc = FALSE;
    static BOOL fPortrait = FALSE;
    static SMBLITE_BRIGHTNESS Brightness = {0};

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitDisplayPage(hwnd);
            if (rc)
            {
                fPortrait = gfPortraitMode;
                Brightness = gBrightness;
            }
            else
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_DESTROY:
            if (ghmodSMAPI != NULL)
            {
                FreeLibrary(ghmodSMAPI);
                ghmodSMAPI = NULL;
                gpfnCallSMAPI = NULL;
            }

            if (ghBackLight != INVALID_HANDLE_VALUE)
            {
                if ((Brightness.bACValue != gBrightness.bACValue) ||
                    (Brightness.bDCValue != gBrightness.bDCValue))
                {
                    //
                    // User must have canceled the setting, so restore
                    // brightness to the original values.
                    //
                    SetBrightness(&gBrightness, FALSE);
                }

                CloseHandle(ghBackLight);
                ghBackLight = INVALID_HANDLE_VALUE;
            }
            break;

        case WM_DISPLAYCHANGE:
            gfPortraitMode = (LOWORD(lParam) < HIWORD(lParam));
            CheckRadioButton(hwnd,
                             IDC_ROTATE_LANDSCAPE,
                             IDC_ROTATE_PORTRAIT,
                             gfPortraitMode? IDC_ROTATE_PORTRAIT:
                                             IDC_ROTATE_LANDSCAPE);
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
                    if (fPortrait ^ gfPortraitMode)
                    {
                        DWORD smrc;

                        smrc = RotateScreen(fPortrait? RT_CLOCKWISE: 0);
                        if (smrc == SMAPI_OK)
                        {
                            gfPortraitMode = fPortrait;
                        }
                        else
                        {
                            DWORD dwErr = MapError(smrc, SMAPIErrMap, FALSE);

                            CheckRadioButton(hwnd,
                                             IDC_ROTATE_LANDSCAPE,
                                             IDC_ROTATE_PORTRAIT,
                                             gfPortraitMode?
                                                 IDC_ROTATE_PORTRAIT:
                                                 IDC_ROTATE_LANDSCAPE);
                            if (dwErr == 0)
                            {
                                ErrorMsg(IDSERR_SMAPI_CALLFAILED, smrc);
                            }
                            else
                            {
                                ErrorMsg(dwErr);
                            }
                        }
                    }

                    if ((Brightness.bACValue != gBrightness.bACValue) ||
                        (Brightness.bDCValue != gBrightness.bDCValue))
                    {
                        //
                        // User has committed to the new values, save them.
                        //
                        if (SetBrightness(&Brightness, TRUE))
                        {
                            gBrightness = Brightness;
                        }
                    }

                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_ROTATE_LANDSCAPE:
                    fPortrait = FALSE;
                    goto CheckRotation;

                case IDC_ROTATE_PORTRAIT:
                    fPortrait = TRUE;

                CheckRotation:
                    if ((HIWORD(wParam) == BN_CLICKED) &&
                        !IsDlgButtonChecked(hwnd, LOWORD(wParam)))
                    {
                        //
                        // Rotation has changed, mark the property
                        // sheet dirty.
                        //
                        CheckRadioButton(hwnd,
                                         IDC_ROTATE_LANDSCAPE,
                                         IDC_ROTATE_PORTRAIT,
                                         LOWORD(wParam));
                        SendMessage(GetParent(hwnd),
                                    PSM_CHANGED,
                                    (WPARAM)hwnd,
                                    0);
                        rc = TRUE;
                    }
                    break;
            }
            break;
        }

#ifdef BACKLIGHT
        case WM_HSCROLL:
        {
            UCHAR BrightScale;

            BrightScale = (UCHAR)SendDlgItemMessage(hwnd,
                                                    IDC_BRIGHTNESS_AC,
                                                    TBM_GETPOS,
                                                    0,
                                                    0);
            Brightness.bACValue = BrightScale*(BRIGHTNESS_MAX + 1)/
                                  (BRIGHTSCALE_MAX + 1);
            BrightScale = (UCHAR)SendDlgItemMessage(hwnd,
                                                    IDC_BRIGHTNESS_DC,
                                                    TBM_GETPOS,
                                                    0,
                                                    0);
            Brightness.bDCValue = BrightScale*(BRIGHTNESS_MAX + 1)/
                                  (BRIGHTSCALE_MAX + 1);

            if ((Brightness.bACValue != gBrightness.bACValue) ||
                (Brightness.bDCValue != gBrightness.bDCValue))
            {
                if (SetBrightness(&Brightness, FALSE))
                {
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                }
            }
            break;
        }
#endif

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    TEXT("tabletpc.hlp"),
                    HELP_WM_HELP,
                    (DWORD_PTR)gDisplayHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam,
                    TEXT("tabletpc.hlp"),
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)gDisplayHelpIDs);
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DisplayDlgProc

/*++
    @doc    INTERNAL

    @func   BOOL | InitDisplayPage |
            Initialize the display property page.

    @parm   IN HWND | hwnd | Window handle.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
InitDisplayPage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitDisplayPage", 2)
    BOOL rc = FALSE;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

#ifdef BACKLIGHT
    SendDlgItemMessage(hwnd,
                       IDC_BRIGHTNESS_AC,
                       TBM_SETRANGE,
                       TRUE,
                       MAKELONG(BRIGHTSCALE_LO, BRIGHTSCALE_HI));
    SendDlgItemMessage(hwnd,
                       IDC_BRIGHTNESS_DC,
                       TBM_SETRANGE,
                       TRUE,
                       MAKELONG(BRIGHTSCALE_LO, BRIGHTSCALE_HI));
#endif
    ghmodSMAPI = LoadLibrary(TEXT("smhook.dll"));
    if (ghmodSMAPI != NULL)
    {
        gpfnCallSMAPI = GetProcAddress(ghmodSMAPI, "CallSMAPI");

        if (gpfnCallSMAPI != NULL)
        {
            LONG cxScreen, cyScreen;

            cxScreen = GetSystemMetrics(SM_CXSCREEN);
            cyScreen = GetSystemMetrics(SM_CYSCREEN);
            gfPortraitMode = (cxScreen < cyScreen);
            CheckRadioButton(hwnd,
                             IDC_ROTATE_LANDSCAPE,
                             IDC_ROTATE_PORTRAIT,
                             gfPortraitMode? IDC_ROTATE_PORTRAIT:
                                             IDC_ROTATE_LANDSCAPE);

#ifdef BACKLIGHT
            ghBackLight = CreateFile(SMBLITE_IOCTL_DEVNAME,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

            if (ghBackLight == INVALID_HANDLE_VALUE)
            {
                ErrorMsg(IDSERR_SMBLITE_OPENDEV, GetLastError());
            }
            else if (GetBrightness(&gBrightness))
            {
                LPARAM lParam;

                lParam = gBrightness.bACValue*(BRIGHTSCALE_MAX + 1)/
                         (BRIGHTNESS_MAX + 1);
                SendDlgItemMessage(hwnd,
                                   IDC_BRIGHTNESS_AC,
                                   TBM_SETPOS,
                                   TRUE,
                                   lParam);
                lParam = gBrightness.bDCValue*(BRIGHTSCALE_MAX + 1)/
                         (BRIGHTNESS_MAX + 1);
                SendDlgItemMessage(hwnd,
                                   IDC_BRIGHTNESS_DC,
                                   TBM_SETPOS,
                                   TRUE,
                                   lParam);
            }
#endif

            rc = TRUE;
        }
        else
        {
            FreeLibrary(ghmodSMAPI);
            ghmodSMAPI = NULL;
            ErrorMsg(IDSERR_GETPROCADDR_SMAPI);
        }
    }
    else
    {
        ErrorMsg(IDSERR_LOADLIBRARY_SMAPI);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitDisplayPage

/*++
    @doc    EXTERNAL

    @func   DWORD | SetRotation | Set display rotation mode.

    @parm   IN DWORD | dwRotation | Specified the rotation.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
__stdcall
SetRotation(
    IN DWORD dwRotation
    )
{
    TRACEPROC("SetRotation", 2)
    BOOL rc = FALSE;
    BOOL fNeedUnload = FALSE;

    TRACEENTER(("(Rotation=%x)\n", dwRotation));

    if (gpfnCallSMAPI == NULL)
    {
        ghmodSMAPI = LoadLibrary(TEXT("smhook.dll"));
        if (ghmodSMAPI != NULL)
        {
            gpfnCallSMAPI = GetProcAddress(ghmodSMAPI, "CallSMAPI");

            if (gpfnCallSMAPI != NULL)
            {
                fNeedUnload = TRUE;
            }
            else
            {
                FreeLibrary(ghmodSMAPI);
                ghmodSMAPI = NULL;
                ErrorMsg(IDSERR_GETPROCADDR_SMAPI);
            }
        }
        else
        {
            ErrorMsg(IDSERR_LOADLIBRARY_SMAPI);
        }
    }

    if (gpfnCallSMAPI != NULL)
    {
        DWORD smrc, dwErr;

        smrc = RotateScreen(dwRotation);
        if (smrc == SMAPI_OK)
        {
            rc = TRUE;
        }
        else
        {
            dwErr = MapError(smrc, SMAPIErrMap, FALSE);
            if (dwErr == 0)
            {
                ErrorMsg(IDSERR_SMAPI_CALLFAILED, smrc);
            }
            else
            {
                ErrorMsg(dwErr);
            }
        }
    }

    if (fNeedUnload)
    {
        gpfnCallSMAPI = NULL;
        FreeLibrary(ghmodSMAPI);
        ghmodSMAPI = NULL;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SetRotation

/*++
    @doc    INTERNAL

    @func   DWORD | RotateScreen |
            Rotate the screen to the given orientation.

    @parm   IN DWORD | dwRotation | Specified the rotation.

    @rvalue SUCCESS | Returns SMAPI_OK.
    @rvalue FAILURE | Returns SMAPI error code.
--*/

DWORD
RotateScreen(
    IN DWORD dwRotation
    )
{
    TRACEPROC("RotateScreen", 2)
    DWORD rc;

    TRACEENTER(("(Rotation=%d)\n", dwRotation));

    if (gpfnCallSMAPI != NULL)
    {
        if (dwRotation == 0)
        {
            rc = gpfnCallSMAPI(ROTATE_EXIT, 0, 0, 0);
        }
        else
        {
            if (gpfnCallSMAPI(ROTATE_STATUS, 0, 0, 0))
            {
                gpfnCallSMAPI(ROTATE_EXIT, 0, 0, 0);
            }

            rc = gpfnCallSMAPI(ROTATE_INIT, dwRotation, 0, 0);
            if (rc == SMAPI_OK)
            {
                //
                // The SMI driver has this dynamic mode table feature that
                // it may not report portrait display modes unless we
                // enumerate them.  Therefore, we do display mode enumeration
                // just to force the SMI driver to load a display mode tablet
                // that support portrait modes.
                //
                EnumDisplayModes();
                rc = gpfnCallSMAPI(ROTATE_EXECUTE, NULL, dwRotation, 0);
            }
        }
    }
    else
    {
        rc = SMAPI_ERR_NODRV;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //RotateScreen

/*++
    @doc    INTERNAL

    @func   VOID | EnumDisplayModes | Enumerate display modes to force
            SMI driver to dynamically load a mode table that supports
            Portrait modes.

    @parm   None.

    @rvalue None.
--*/

VOID
EnumDisplayModes(
    VOID
    )
{
    TRACEPROC("EnumDisplayModes", 3)
    DWORD i;
    DEVMODE DevMode;

    TRACEENTER(("()\n"));

    for (i = 0; EnumDisplaySettings(NULL, i, &DevMode); ++i)
    {
        //
        // Don't have to do anything.
        //
    }

    TRACEEXIT(("!\n"));
    return;
}       //EnumDisplayModes

/*++
    @doc    INTERNAL

    @func   BOOL | GetBrightness | Call the backlight driver to get
            LCD brightness.

    @parm   OUT PSMBLITE_BRIGHTNESS | Brightness | Brightness values.

    @rvalue SUCCESS | Returnes TRUE.
    @rvalue FAILURE | Returnes FALSE.
--*/

BOOL
GetBrightness(
    OUT PSMBLITE_BRIGHTNESS Brightness
    )
{
    TRACEPROC("GetBrightness", 3)
    BOOL rc = FALSE;

    TRACEENTER(("(Brightness=%p)\n", Brightness));

    if (ghBackLight != INVALID_HANDLE_VALUE)
    {
        DWORD dwcbReturned;

        rc = DeviceIoControl(ghBackLight,
                             IOCTL_SMBLITE_GETBRIGHTNESS,
                             NULL,
                             0,
                             Brightness,
                             sizeof(*Brightness),
                             &dwcbReturned,
                             NULL);
        if (rc == FALSE)
        {
            ErrorMsg(IDSERR_SMBLITE_DEVIOCTL, GetLastError());
        }
    }
    else
    {
        ErrorMsg(IDSERR_SMBLITE_NODEVICE);
    }

    TRACEEXIT(("=%x (AC=%d,DC=%d)\n",
               rc, Brightness->bACValue, Brightness->bDCValue));
    return rc;
}       //GetBrightness

/*++
    @doc    INTERNAL

    @func   BOOL | SetBrightness | Call the backlight driver to set
            LCD brightness.

    @parm   IN PSMBLITE_BRIGHTNESS | Brightness | Brightness values.'
    @parm   IN BOOLEAN | fSaveSettings | If TRUE, save new brightness in the
            registry.

    @rvalue SUCCESS | Returnes TRUE.
    @rvalue FAILURE | Returnes FALSE.
--*/

BOOL
SetBrightness(
    IN PSMBLITE_BRIGHTNESS Brightness,
    IN BOOLEAN             fSaveSettings
    )
{
    TRACEPROC("SetBrightness", 3)
    BOOL rc = FALSE;

    TRACEENTER(("(Brightness=%p,ACValue=%d,DCValue=%d)\n",
                Brightness, Brightness->bACValue, Brightness->bDCValue));

    if (ghBackLight != INVALID_HANDLE_VALUE)
    {
        SMBLITE_SETBRIGHTNESS SetLCD;
        DWORD dwcbReturned;

        SetLCD.Brightness = *Brightness;
        SetLCD.fSaveSettings = fSaveSettings;
        rc = DeviceIoControl(ghBackLight,
                             IOCTL_SMBLITE_SETBRIGHTNESS,
                             &SetLCD,
                             sizeof(SetLCD),
                             NULL,
                             0,
                             &dwcbReturned,
                             NULL);
        if (rc == FALSE)
        {
            ErrorMsg(IDSERR_SMBLITE_DEVIOCTL, GetLastError());
        }
    }
    else
    {
        ErrorMsg(IDSERR_SMBLITE_NODEVICE);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SetBrightness
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\lincal.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    lincal.c

Abstract: This module contains code to do linearity calibration of the
          mutoh pen tablet.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Jun-2000

Revision History:

--*/

#include "pch.h"

#ifdef PENPAGE
#define FIRST_X                 16
#define FIRST_Y                 16
#define INTERVAL_X              32
#define INTERVAL_Y              32
#define VICINITY_OFFSET         (INTERVAL_X/2)
#define CIRCLE_RADIUS           6
#define MAX_NORMALIZED_X        65536
#define MAX_NORMALIZED_Y        65536
#define NUM_LINEARCAL_PTS       (NUM_LINEAR_XPTS*NUM_LINEAR_YPTS)

static TCHAR gtszLinearCal[] = TEXT("LinearityCalibration");
static TCHAR gtszLinearCalTitle[64] = {0};
static HWND ghwndParent = 0;
static LONG gcxScreen = 0, gcyScreen = 0;
static HPEN ghpenRed = 0, ghpenBlue = 0;
static CALIBRATE_PT gCalPts[NUM_LINEAR_YPTS][NUM_LINEAR_XPTS] = {0};
static int giNumLinearCalPts = 0;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CreateLinearCalWindow |
 *          Entry point of the linearity calibration code.
 *
 *  @parm   IN HWND | hwndParent | Parent Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
CreateLinearCalWindow(
    IN HWND hwndParent
    )
{
    TRACEPROC("CreateLinearCalWindow", 2)
    BOOL rc = FALSE;
    HWND hwnd;

    TRACEENTER(("(hwndParent=%p)\n", hwndParent));

    giNumLinearCalPts = 0;
    RtlZeroMemory(gCalPts, sizeof(gCalPts));
    ghwndParent = hwndParent;
    LoadString(ghInstance,
               IDS_LINEARCAL_TITLE,
               gtszLinearCalTitle,
               sizeof(gtszLinearCalTitle)/sizeof(TCHAR));
    gcxScreen = GetSystemMetrics(SM_CXSCREEN);
    gcyScreen = GetSystemMetrics(SM_CYSCREEN);

    RegisterLinearCalClass(ghInstance);
    hwnd = CreateWindow(gtszLinearCal,      //Class Name
                        gtszLinearCal,      //Window Name
                        WS_POPUP,           //Style
                        0,                  //Window X
                        0,                  //Window Y
                        gcxScreen,          //Window Width
                        gcyScreen,          //Window Height
                        hwndParent,         //Parent Handle
                        NULL,               //Menu Handle
                        ghInstance,         //Instance Handle
                        NULL);              //Creation Data

    if (hwnd != NULL)
    {
        ShowWindow(hwnd, SW_SHOWNORMAL);
        rc = TRUE;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //CreateLinearCalWindow

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | RegisterLinearCalClass |
 *          Register window class.
 *
 *  @parm   IN HINSTANCE | hInstance | Instance handle.
 *
 *  @rvalue SUCCESS | Returns class atom
 *  @rvalue FAILURE | Returns 0
 *
 *****************************************************************************/

ATOM
RegisterLinearCalClass(
    IN HINSTANCE hInstance
    )
{
    TRACEPROC("RegisterLinearCalClass", 2)
    ATOM atom;
    WNDCLASSEX wcex;

    TRACEENTER(("(hInstance=%p)\n", hInstance));

    wcex.cbSize = sizeof(wcex);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = LinearCalWndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon(hInstance, (LPCTSTR)IDI_TABLETPC);
    wcex.hCursor = NULL;        //No cursor is shown.
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = NULL;
    wcex.lpszClassName = gtszLinearCal;
    wcex.hIconSm = NULL;

    atom = RegisterClassEx(&wcex);

    TRACEEXIT(("=%x\n", atom));
    return atom;
}       //RegisterLinearCalClass

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   LRESULT | LinearCalWndProc |
 *          Dialog procedure for the pen tablet linearity calibration page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

LRESULT CALLBACK
LinearCalWndProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("LinearCalWndProc", 2)
    LRESULT rc = 0;
    HDC hDC;
    static BOOL fCalDone = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_CREATE:
        {
            int i, j;
            LONG x, y, xInterval, yInterval;
            BOOL rcRPC;

            RPC_TRY("TabSrvGetLinearityMap",
                    rcRPC = TabSrvGetLinearityMap(ghBinding,
                                                  &PenSettings.LinearityMap));
            if ((rcRPC == TRUE) &&
                ((PenSettings.LinearityMap.dwcbLen != sizeof(LINEAR_MAP)) ||
                 (PenSettings.LinearityMap.wNumXPts != NUM_LINEAR_XPTS) ||
                 (PenSettings.LinearityMap.wNumYPts != NUM_LINEAR_YPTS)))
            {
                //
                // The map read is not the same size as expected.
                //
                rcRPC = FALSE;
            }
            ghpenRed = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            ghpenBlue = CreatePen(PS_SOLID, 0, RGB(0, 0, 255));
            for (i = 0; i < NUM_LINEAR_YPTS; ++i)
            {
                y = FIRST_Y + INTERVAL_Y*i;
                for (j = 0; j < NUM_LINEAR_XPTS; ++j)
                {
                    x = FIRST_X + INTERVAL_X*j;
                    gCalPts[i][j].ScreenPt.x = x;
                    gCalPts[i][j].ScreenPt.y = y;
                    if (rcRPC == TRUE)
                    {
                        gCalPts[i][j].dwFlags = CPF_VALID;
                        gCalPts[i][j].DigiPt.x =
                            PenSettings.LinearityMap.Data[i][j].wDigiPtX;
                        gCalPts[i][j].DigiPt.y =
                            PenSettings.LinearityMap.Data[i][j].wDigiPtY;
                    }
                    else
                    {
                        gCalPts[i][j].dwFlags = 0;
                        gCalPts[i][j].DigiPt.x = gCalPts[i][j].DigiPt.y = 0;
                    }
                }
            }
            if (rcRPC == TRUE)
            {
                giNumLinearCalPts = PenSettings.LinearityMap.wNumXPts*
                                    PenSettings.LinearityMap.wNumYPts;
            }
            else
            {
                giNumLinearCalPts = 0;
            }

            ShowCursor(FALSE);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            PCALIBRATE_PT CalPt;
            WORD wButtonState;

            fCalDone = FALSE;
            CalPt = FindPoint(GET_X_LPARAM(lParam),
                              GET_Y_LPARAM(lParam),
                              VICINITY_OFFSET);
            if (CalPt != NULL)
            {
                HPEN hpenOld;

                RPC_TRY("TabSrvGetLastRawDigiReport",
                        TabSrvGetLastRawDigiReport(ghBinding,
                                                   &wButtonState,
                                                   (WORD *)&CalPt->DigiPt.x,
                                                   (WORD *)&CalPt->DigiPt.y));
                TRACEASSERT(wButtonState & BUTSTATE_TIP_DOWN);
                MessageBeep(MB_OK);
                hDC = GetDC(hwnd);
                hpenOld = SelectObject(hDC, ghpenRed);
                Ellipse(hDC,
                        CalPt->ScreenPt.x - CIRCLE_RADIUS,
                        CalPt->ScreenPt.y - CIRCLE_RADIUS,
                        CalPt->ScreenPt.x + CIRCLE_RADIUS,
                        CalPt->ScreenPt.y + CIRCLE_RADIUS);
                MoveToEx(hDC,
                         CalPt->ScreenPt.x - CIRCLE_RADIUS,
                         CalPt->ScreenPt.y,
                         NULL);
                LineTo(hDC,
                       CalPt->ScreenPt.x + CIRCLE_RADIUS,
                       CalPt->ScreenPt.y);
                MoveToEx(hDC,
                         CalPt->ScreenPt.x,
                         CalPt->ScreenPt.y - CIRCLE_RADIUS,
                         NULL);
                LineTo(hDC,
                       CalPt->ScreenPt.x,
                       CalPt->ScreenPt.y + CIRCLE_RADIUS);
                SelectObject(hDC, hpenOld);
                ReleaseDC(hwnd, hDC);
                CalPt->dwFlags |= CPF_CALIBRATED;
                if (!(CalPt->dwFlags & CPF_VALID))
                {
                    CalPt->dwFlags |= CPF_VALID;
                    giNumLinearCalPts++;
                }
            }
            break;
        }

        case WM_CHAR:
            switch (wParam)
            {
                case VK_RETURN:
                    if (giNumLinearCalPts < NUM_LINEARCAL_PTS)
                    {
                        MessageBeep(MB_ICONEXCLAMATION);
                    }
                    else if (!fCalDone)
                    {
                        DoLinearCal(hwnd, &PenSettings.LinearityMap);
                        InvalidateRect(hwnd, NULL, TRUE);
                        fCalDone = TRUE;
                    }
                    else
                    {
                        SendMessage(ghwndParent,
                                    WM_LINEARCAL_DONE,
                                    (WPARAM)IDYES,
                                    (LPARAM)hwnd);
                    }
                    break;

                case VK_ESCAPE:
                    SendMessage(ghwndParent,
                                WM_LINEARCAL_DONE,
                                (WPARAM)IDCANCEL,
                                (LPARAM)hwnd);
                    break;
            }
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HPEN hpenOld;
            int i, j;

            hDC = BeginPaint(hwnd, &ps);

            hpenOld = SelectObject(hDC, ghpenBlue);
            for (i = 0; i < NUM_LINEAR_YPTS; ++i)
            {
                MoveToEx(hDC,
                         gCalPts[i][0].ScreenPt.x,
                         gCalPts[i][0].ScreenPt.y,
                         NULL);
                LineTo(hDC,
                       gCalPts[i][NUM_LINEAR_XPTS - 1].ScreenPt.x,
                       gCalPts[i][NUM_LINEAR_XPTS - 1].ScreenPt.y);
            }

            for (i = 0; i < NUM_LINEAR_XPTS; ++i)
            {
                MoveToEx(hDC,
                         gCalPts[0][i].ScreenPt.x,
                         gCalPts[0][i].ScreenPt.y,
                         NULL);
                LineTo(hDC,
                       gCalPts[NUM_LINEAR_YPTS - 1][i].ScreenPt.x,
                       gCalPts[NUM_LINEAR_YPTS - 1][i].ScreenPt.y);
            }

            SelectObject(hDC, ghpenRed);
            for (i = 0; i < NUM_LINEAR_YPTS; ++i)
            {
                for (j = 0; j < NUM_LINEAR_XPTS; ++j)
                {
                    if (gCalPts[i][j].dwFlags & CPF_CALIBRATED)
                    {
                        Ellipse(hDC,
                                gCalPts[i][j].ScreenPt.x - CIRCLE_RADIUS,
                                gCalPts[i][j].ScreenPt.y - CIRCLE_RADIUS,
                                gCalPts[i][j].ScreenPt.x + CIRCLE_RADIUS,
                                gCalPts[i][j].ScreenPt.y + CIRCLE_RADIUS);
                        MoveToEx(hDC,
                                 gCalPts[i][j].ScreenPt.x - CIRCLE_RADIUS,
                                 gCalPts[i][j].ScreenPt.y,
                                 NULL);
                        LineTo(hDC,
                               gCalPts[i][j].ScreenPt.x + CIRCLE_RADIUS,
                               gCalPts[i][j].ScreenPt.y);
                        MoveToEx(hDC,
                                 gCalPts[i][j].ScreenPt.x,
                                 gCalPts[i][j].ScreenPt.y - CIRCLE_RADIUS,
                                 NULL);
                        LineTo(hDC,
                               gCalPts[i][j].ScreenPt.x,
                               gCalPts[i][j].ScreenPt.y + CIRCLE_RADIUS);
                    }
                }
            }

            if (giNumLinearCalPts == NUM_LINEARCAL_PTS)
            {
                DisplayMap(hwnd, &PenSettings.LinearityMap);
            }

            SelectObject(hDC, hpenOld);

            EndPaint(hwnd, &ps);
            break;
        }

        case WM_DESTROY:
            ShowCursor(TRUE);
            if (ghpenRed != NULL)
            {
                DeleteObject(ghpenRed);
            }
            if (ghpenBlue != NULL)
            {
                DeleteObject(ghpenBlue);
            }
            break;

        default:
            rc = DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //LinearCalWndProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCALIBRATE_PT | FindPoint |
 *          Find if the click is in the vicinity of the calibrate points.
 *
 *  @parm   IN int | x | X value.
 *  @parm   IN int | y | Y value.
 *  @parm   IN int | offset | Vicinity offset
 *
 *  @rvalue SUCCESS | Returns calibrate point found in the vicinity.
 *  @rvalue FAILURE | Returns NULL.
 *
 *****************************************************************************/

PCALIBRATE_PT
FindPoint(
    IN int x,
    IN int y,
    IN int offset
    )
{
    TRACEPROC("FindPoint", 2)
    PCALIBRATE_PT CalPt = NULL;
    int i, j;

    TRACEENTER(("(x=%d,y=%d,offset=%d)\n", x, y, offset));

    for (i = 0; i < NUM_LINEAR_YPTS; ++i)
    {
        for (j = 0; j < NUM_LINEAR_XPTS; ++j)
        {
            if ((x >= gCalPts[i][j].ScreenPt.x - offset) &&
                (x <= gCalPts[i][j].ScreenPt.x + offset) &&
                (y >= gCalPts[i][j].ScreenPt.y - offset) &&
                (y <= gCalPts[i][j].ScreenPt.y + offset))
            {
                CalPt = & gCalPts[i][j];
                break;
            }
        }
    }

    TRACEEXIT(("=%p\n", CalPt));
    return CalPt;
}       //FindPoint

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | DoLinearCal | Generates the linearity calibration table.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   OUT PLINEAR_MAP | LinearityMap | Points to the structure to hold
 *          the result of calculation.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID
DoLinearCal(
    IN  HWND        hwnd,
    OUT PLINEAR_MAP LinearityMap
    )
{
    TRACEPROC("DoLinearCal", 2)
    int i, j;

    TRACEENTER(("(hwnd=%x,LinearityMap=%p)\n", hwnd, LinearityMap));

    LinearityMap->dwcbLen = sizeof(LINEAR_MAP);
    LinearityMap->wNumXPts = NUM_LINEAR_XPTS;
    LinearityMap->wNumYPts = NUM_LINEAR_YPTS;
    for (i = 0; i < NUM_LINEAR_YPTS; ++i)
    {
        for (j = 0; j < NUM_LINEAR_XPTS; ++j)
        {
            LinearityMap->Data[i][j].wRefPtX =
                    (USHORT)((gCalPts[i][j].ScreenPt.x*MAX_NORMALIZED_X)/
                             gcxScreen);
            LinearityMap->Data[i][j].wRefPtY =
                    (USHORT)((gCalPts[i][j].ScreenPt.y*MAX_NORMALIZED_Y)/
                             gcyScreen);
            LinearityMap->Data[i][j].wDigiPtX =
                    (USHORT)gCalPts[i][j].DigiPt.x;
            LinearityMap->Data[i][j].wDigiPtY =
                    (USHORT)gCalPts[i][j].DigiPt.y;
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //DoLinearCal

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | DisplayMap | Display the linearity map.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN PLINEAR_MAP | LinearityMap | Points to the linearity map.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID
DisplayMap(
    IN HWND hwnd,
    IN PLINEAR_MAP LinearityMap
    )
{
    TRACEPROC("DisplayMap", 2)
    int i, j;
    LONG xMin, xMax, yMin, yMax, xRange, yRange;
    LONG xScreenMin, xScreenMax,
         yScreenMin, yScreenMax,
         xScreenRange, yScreenRange;
    HDC hDC;
    HPEN hpenOld;
    POINT Pts[4];

    TRACEENTER(("(hwnd=%x,LinearityMap=%p)\n", hwnd, LinearityMap));

    for (i = 0, xMin = xMax = 0; i < NUM_LINEAR_YPTS; ++i)
    {
        xMin += LinearityMap->Data[i][0].wDigiPtX;
        xMax += LinearityMap->Data[i][NUM_LINEAR_XPTS - 1].wDigiPtX;
    }
    xMin /= NUM_LINEAR_YPTS;
    xMax /= NUM_LINEAR_YPTS;
    xRange = xMax - xMin;
    xScreenMin = (LinearityMap->Data[0][0].wRefPtX*gcxScreen)/MAX_NORMALIZED_X;
    xScreenMax = (LinearityMap->Data[0][NUM_LINEAR_XPTS - 1].wRefPtX*gcxScreen)/
                 MAX_NORMALIZED_X;
    xScreenRange = xScreenMax - xScreenMin;

    for (i = 0, yMin = yMax = 0; i < NUM_LINEAR_XPTS; ++i)
    {
        yMin += LinearityMap->Data[0][i].wDigiPtY;
        yMax += LinearityMap->Data[NUM_LINEAR_YPTS - 1][i].wDigiPtY;
    }
    yMin /= NUM_LINEAR_XPTS;
    yMax /= NUM_LINEAR_XPTS;
    yRange = yMax - yMin;
    yScreenMin = (LinearityMap->Data[0][0].wRefPtY*gcyScreen)/MAX_NORMALIZED_Y;
    yScreenMax = (LinearityMap->Data[NUM_LINEAR_YPTS - 1][0].wRefPtY*gcyScreen)/
                 MAX_NORMALIZED_Y;
    yScreenRange = yScreenMax - yScreenMin;

    hDC = GetDC(hwnd);
    hpenOld = SelectObject(hDC, ghpenRed);
    for (i = 0; i < NUM_LINEAR_YPTS - 1; ++i)
    {
        for (j = 0; j < NUM_LINEAR_XPTS - 1; ++j)
        {
            Pts[0].x = xScreenMin +
                       ((LinearityMap->Data[i][j].wDigiPtX - xMin)*
                        xScreenRange)/xRange;
            Pts[0].y = yScreenMin +
                       ((LinearityMap->Data[i][j].wDigiPtY - yMin)*
                        yScreenRange)/yRange;
            Pts[1].x = xScreenMin +
                       ((LinearityMap->Data[i][j+1].wDigiPtX - xMin)*
                        xScreenRange)/xRange;
            Pts[1].y = yScreenMin +
                       ((LinearityMap->Data[i][j+1].wDigiPtY - yMin)*
                        yScreenRange)/yRange;
            Pts[2].x = xScreenMin +
                       ((LinearityMap->Data[i+1][j+1].wDigiPtX - xMin)*
                        xScreenRange)/xRange;
            Pts[2].y = yScreenMin +
                       ((LinearityMap->Data[i+1][j+1].wDigiPtY - yMin)*
                        yScreenRange)/yRange;
            Pts[3].x = xScreenMin +
                       ((LinearityMap->Data[i+1][j].wDigiPtX - xMin)*
                        xScreenRange)/xRange;
            Pts[3].y = yScreenMin +
                       ((LinearityMap->Data[i+1][j].wDigiPtY - yMin)*
                        yScreenRange)/yRange;

            MoveToEx(hDC, Pts[3].x, Pts[3].y, NULL);
            PolylineTo(hDC, Pts, 4);
        }
    }
    SelectObject(hDC, hpenOld);
    ReleaseDC(hwnd, hDC);

    TRACEEXIT(("!\n"));
    return;
}       //DisplayMap
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\mutohpen.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mutohpen.c

Abstract: Tablet PC Mutoh Pen Tablet Property Sheet module.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef PENPAGE
#define CHANGED_SAMPLINGRATE            0x00000001
#define CHANGED_SIDESW_MAP              0x00000002
#define CHANGED_DIGITAL_FILTER          0x00000004
#define CHANGED_GLITCH_FILTER           0x00000008
#define CHANGED_PENTILTCAL              0x00000010
#define CHANGED_LINEARCAL               0x00000020
#define CHANGED_FEATURES                (CHANGED_SAMPLINGRATE |     \
                                         CHANGED_DIGITAL_FILTER |   \
                                         CHANGED_GLITCH_FILTER)
DWORD gdwfChanged = 0;
PEN_SETTINGS PenSettings = {0, SWCOMBO_RCLICK};
TCHAR gtszRateTextFormat[32];
COMBOBOX_STRING SwitchComboStringTable[] =
{
    SWCOMBO_NONE,               IDS_SWCOMBO_NONE,
    SWCOMBO_RCLICK,             IDS_SWCOMBO_RCLICK,
    0,                          0
};
DWORD gMutohPenHelpIDs[] =
{
    IDC_SAMPLINGRATE,           IDH_MUTOHPEN_SAMPLINGRATE,
    IDC_SIDE_SWITCH,            IDH_MUTOHPEN_SIDE_SWITCH,
    IDC_ENABLE_DIGITALFILTER,   IDH_MUTOHPEN_ENABLE_DIGITALFILTER,
    IDC_ENABLE_GLITCHFILTER,    IDH_MUTOHPEN_ENABLE_GLITCHFILTER,
    IDC_CALIBRATE,              IDH_CALIBRATE,
    0,                          0
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   INT_PTR | MutohPenDlgProc |
 *          Dialog procedure for the pen tablet page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

INT_PTR APIENTRY
MutohPenDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("MutohPenDlgProc", 2)
    INT_PTR rc = FALSE;
    ULONG dwFeature, dwMask, Rate;
    int iSideSwitchMapping;
    TCHAR tszRateText[32];

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitMutohPenPage(hwnd);
            if (rc == FALSE)
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                    rc = TRUE;
                    RPC_TRY("TabSrvSetPenFeatures",
                        if ((gdwfChanged & CHANGED_FEATURES) &&
                            !TabSrvSetPenFeatures(ghBinding,
                                                  PENFEATURE_REPORT_ID,
                                                  PENFEATURE_USAGE_PAGE,
                                                  PENFEATURE_USAGE,
                                                  PenSettings.dwFeatures))
                        {
                            ErrorMsg(IDSERR_TABSRV_SETPENFEATURE);
                            rc = FALSE;
                        }
                    );

                    if (gdwfChanged & CHANGED_SIDESW_MAP)
                    {
                        //
                        // BUGBUG: send side switch mapping to TabSrv.
                        //
                    }

                    if (gdwfChanged & CHANGED_PENTILTCAL)
                    {
                        RPC_TRY("TabSrvSetPenTilt",
                                TabSrvSetPenTilt(ghBinding,
                                                 PenSettings.dxPenTilt,
                                                 PenSettings.dyPenTilt));
                    }

                    if (gdwfChanged & CHANGED_LINEARCAL)
                    {
                        RPC_TRY("TabSrvSetLinearityMap",
                                TabSrvSetLinearityMap(ghBinding,
                                                      &PenSettings.LinearityMap));
                    }
                    gdwfChanged = 0;
                    break;
            }
            break;
        }

        case WM_COMMAND:
        {
            DWORD Changed = 0;

            rc = TRUE;
            switch (LOWORD(wParam))
            {
                case IDC_SIDE_SWITCH:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            iSideSwitchMapping =
                                (int)SendMessage(GetDlgItem(hwnd,
                                                            IDC_SIDE_SWITCH),
                                                 CB_GETCURSEL,
                                                 0,
                                                 0);
                            Changed = CHANGED_SIDESW_MAP;
                            break;
                    }
                    break;

                case IDC_ENABLE_DIGITALFILTER:
                    dwFeature = IsDlgButtonChecked(hwnd,
                                                   IDC_ENABLE_DIGITALFILTER)?
                                    PENFEATURE_DIGITAL_FILTER_ON: 0;
                    dwMask = PENFEATURE_DIGITAL_FILTER_ON;
                    Changed = CHANGED_DIGITAL_FILTER;
                    break;

                case IDC_ENABLE_GLITCHFILTER:
                    dwFeature = IsDlgButtonChecked(hwnd,
                                                   IDC_ENABLE_GLITCHFILTER)?
                                    PENFEATURE_GLITCH_FILTER_ON: 0;
                    dwMask = PENFEATURE_GLITCH_FILTER_ON;
                    Changed = CHANGED_GLITCH_FILTER;
                    break;

                case IDC_CALIBRATE:
                    switch (HIWORD(wParam))
                    {
                        case BN_CLICKED:
                        {
                            BOOL fCalLinear = ((GetAsyncKeyState(VK_CONTROL) &
                                                0x8000) &&
                                               (GetAsyncKeyState(VK_MENU) &
                                                0x8000));

                            if (fCalLinear)
                            {
                                LONG cxScreen = GetSystemMetrics(SM_CXSCREEN);
                                LONG cyScreen = GetSystemMetrics(SM_CYSCREEN);

                                if (cxScreen > cyScreen)
                                {
                                    rc = CreateLinearCalWindow(hwnd);
                                }
                                else
                                {
                                    MessageBeep(MB_ICONEXCLAMATION);
                                }
                            }
                            else if (!CreatePenTiltCalWindow(hwnd))
                            {
                                ErrorMsg(IDSERR_CALIBRATE_CREATEWINDOW);
                                rc = FALSE;
                            }
                            break;
                        }
                    }
                    break;
            }

            if ((rc == TRUE) && (Changed != 0))
            {
                if (Changed & CHANGED_FEATURES)
                {
                    PenSettings.dwFeatures &= ~dwMask;
                    PenSettings.dwFeatures |= dwFeature;
                }
                else if (Changed & CHANGED_SIDESW_MAP)
                {
                    PenSettings.iSideSwitchMap = iSideSwitchMapping;
                }

                gdwfChanged |= Changed;
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
            }
            break;
        }

        case WM_HSCROLL:
        {
            dwFeature = (ULONG)(PENFEATURE_RATE_MAX -
                                SendDlgItemMessage(hwnd,
                                                   IDC_SAMPLINGRATE,
                                                   TBM_GETPOS,
                                                   0,
                                                   0));
            if (dwFeature == 1)
            {
                dwFeature = 0;
                Rate = 100;
            }
            else if (dwFeature == 0)
            {
                dwFeature = 1;
                Rate = 133;
            }
            else
            {
                Rate = 133/dwFeature;
            }

            if ((PenSettings.dwFeatures ^ dwFeature) & PENFEATURE_RATE_MASK)
            {
                gdwfChanged |= CHANGED_SAMPLINGRATE;
                PenSettings.dwFeatures &= ~PENFEATURE_RATE_MASK;
                PenSettings.dwFeatures |= dwFeature;
                wsprintf(tszRateText, gtszRateTextFormat, Rate);
                SetDlgItemText(hwnd, IDC_RATE_TEXT, tszRateText);
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                rc = TRUE;
            }
            break;
        }

        case WM_PENTILTCAL_DONE:
            //
            // wParam contains the user response of calibration.
            // lParam contains the calibration window handle.
            //
            if (wParam == IDYES)
            {
                gdwfChanged |= CHANGED_PENTILTCAL;
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
            }
            DestroyWindow((HWND)lParam);
            break;

        case WM_LINEARCAL_DONE:
            //
            // wParam contains the user response of calibration.
            // lParam contains the calibration window handle.
            //
            if (wParam == IDYES)
            {
                gdwfChanged |= CHANGED_LINEARCAL;
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
            }
            DestroyWindow((HWND)lParam);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    TEXT("tabletpc.hlp"),
                    HELP_WM_HELP,
                    (DWORD_PTR)gMutohPenHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam,
                    TEXT("tabletpc.hlp"),
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)gMutohPenHelpIDs);
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //MutohPenDlgProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | InitMutohPenPage |
 *          Initialize the Mutoh Pen property page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
InitMutohPenPage(
    IN HWND   hwnd
    )
{
    TRACEPROC("InitMutohPenPage", 2)
    BOOL rc;
    ULONG dwFeature, Rate;
    TCHAR tszRateText[32];

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    LoadString(ghInstance,
               IDS_RATE_TEXT_FORMAT,
               gtszRateTextFormat,
               sizeof(gtszRateTextFormat)/sizeof(TCHAR));

    SendDlgItemMessage(hwnd,
                       IDC_SAMPLINGRATE,
                       TBM_SETRANGE,
                       TRUE,
                       MAKELONG(PENFEATURE_RATE_MIN, PENFEATURE_RATE_MAX));

    RPC_TRY("TabSrvGetPenFeatures",
            rc = TabSrvGetPenFeatures(ghBinding,
                                      PENFEATURE_REPORT_ID,
                                      PENFEATURE_USAGE_PAGE,
                                      PENFEATURE_USAGE,
                                      &PenSettings.dwFeatures));
    if (rc == TRUE)
    {
        dwFeature = PenSettings.dwFeatures & PENFEATURE_RATE_MASK;
        if (dwFeature == 1)
        {
            //
            // 1 actual means fastest (133 samples/sec)
            //
            dwFeature = 0;
            Rate = 133;
        }
        else if (dwFeature == 0)
        {
            //
            // Custom rate (100 samples/sec)
            //
            dwFeature = 1;
            Rate = 100;
        }
        else
        {
            Rate = 133/dwFeature;
        }

        SendDlgItemMessage(hwnd,
                           IDC_SAMPLINGRATE,
                           TBM_SETPOS,
                           TRUE,
                           PENFEATURE_RATE_MAX - dwFeature);
        wsprintf(tszRateText, gtszRateTextFormat, Rate);
        SetDlgItemText(hwnd, IDC_RATE_TEXT, tszRateText);

        InsertComboBoxStrings(hwnd, IDC_SIDE_SWITCH, SwitchComboStringTable);
        SendDlgItemMessage(hwnd,
                           IDC_SIDE_SWITCH,
                           CB_SETCURSEL,
                           PenSettings.iSideSwitchMap,
                           0);

        CheckDlgButton(hwnd,
                       IDC_ENABLE_DIGITALFILTER,
                       (PenSettings.dwFeatures & PENFEATURE_DIGITAL_FILTER_ON)
                       != 0);

        CheckDlgButton(hwnd,
                       IDC_ENABLE_GLITCHFILTER,
                       (PenSettings.dwFeatures & PENFEATURE_GLITCH_FILTER_ON)
                       != 0);
    }
    else
    {
        PenSettings.dwFeatures = 0;
        ErrorMsg(IDSERR_TABSRV_GETPENFEATURE);
        rc = FALSE;
    }

    if (rc == TRUE)
    {
        //
        // BUGBUG: Read and init side switch mapping.
        //
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitMutohPenPage
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\mutohpen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mutohpen.h

Abstract:  Contains definitions of the Mutoh pen tablet.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#ifndef _MUTOHPEN_H
#define _MUTOHPEN_H

//
// Pen Tablet Feature Report
//
#define PENFEATURE_USAGE_PAGE           0xff00
#define PENFEATURE_USAGE                1
#define PENFEATURE_REPORT_ID            2

//
// Pen Feature bits
//
#define PENFEATURE_RATE_MASK            0x0000000f
#define PENFEATURE_RATE_MIN             0
#define PENFEATURE_RATE_MAX             9
#define PENFEATURE_DIGITAL_FILTER_ON    0x00000010
#define PENFEATURE_GLITCH_FILTER_ON     0x00000020

//
// Button states
//
#define BUTSTATE_TIP_DOWN               0x0001
#define BUTSTATE_SIDESW_ON              0x0002

//
// Side switch combo box string index
//
#define SWCOMBO_NONE                    0
#define SWCOMBO_CLICK                   1
#define SWCOMBO_RCLICK                  2
#define SWCOMBO_DBLCLICK                3

//
// Private window message to the mutoh dialog proc.
//
#define WM_PENTILTCAL_DONE              (WM_APP + 0)
#define WM_LINEARCAL_DONE               (WM_APP + 1)

//
// Type definitions
//
typedef struct _PEN_SETTINGS
{
    DWORD      dwFeatures;
    int        iSideSwitchMap;
    LONG       dxPenTilt;
    LONG       dyPenTilt;
    LINEAR_MAP LinearityMap;
} PEN_SETTINGS, *PPEN_SETTINGS;

// dwFlags values
#define CPF_VALID                       0x00000001
#define CPF_CALIBRATED                  0x00000002

typedef struct _CALIBRATE_PT
{
    ULONG dwFlags;
    POINT ScreenPt;
    POINT DigiPt;
} CALIBRATE_PT, *PCALIBRATE_PT;

#endif  //ifndef _MUTOHPEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\pch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:  Pre-compile C header file.


Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "TPC"
#define INTERNAL
#define EXTERNAL

#if DBG
  #define DEBUG
  #define WINTRACE
  #define PENPAGE
  #define BUTTONPAGE
  #define BACKLIGHT
  #define SYSACC
  #define BATTINFO
  #define CHGRINFO
  #define TMPINFO
#endif

#include <stdio.h>
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <cpl.h>
#include <devioctl.h>
#include <smblite.h>
#include <smapi.h>
#include <hidusage.h>
#include <wintrace.h>
#include "debug.h"
#include "resid.h"
#include "tsrpc.h"
#include "mutohpen.h"
#ifdef SYSACC
#include "smbdev.h"
#endif
#ifdef BATTINFO
#include "battinfo.h"
#endif
#ifdef CHGRINFO
#include "chgrinfo.h"
#endif
#ifdef TMPINFO
#include "tmpinfo.h"
#endif
#include "tabletpc.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\smbdev.c ===
/*++
    Copyright (c) 2000,2001 Microsoft Corporation

    Module Name:
        smbdev.c

    Abstract: This module contains SMBus Device related functions.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 23-Jan-2001

    Revision History:
--*/

#include "pch.h"

#ifdef SYSACC

/*++
    @doc    INTERNAL

    @func   BOOL | GetSMBDevInfo | Call the SysAccess driver to get the
            SMBus device info.

    @parm   IN UCHAR | bDevAddr | SMB device address.
    @parm   IN PSMBCMD_INFO | SmbCmd | Points to the SMB device command.
    @parm   OUT PBYTE | pbBuff | To hold the device info.

    @rvalue SUCCESS | Returnes TRUE.
    @rvalue FAILURE | Returnes FALSE.
--*/

BOOL
GetSMBDevInfo(
    IN  UCHAR        bDevAddr,
    IN  PSMBCMD_INFO SmbCmd,
    OUT PBYTE        pbBuff
    )
{
    TRACEPROC("GetSMBDevInfo", 3)
    BOOL rc;
    SMB_REQUEST SmbReq;
    DWORD dwcbReturned;

    TRACEENTER(("(DevAddr=%x,SmbCmd=%p,Cmd=%s,pbBuff=%p)\n",
                bDevAddr, SmbCmd, SmbCmd->pszLabel, pbBuff));

    TRACEASSERT(ghSysAcc != INVALID_HANDLE_VALUE);
    TRACEASSERT(SmbCmd->bProtocol <= SMB_MAXIMUM_PROTOCOL);

    SmbReq.Status = SMB_UNKNOWN_FAILURE;
    SmbReq.Address = bDevAddr;
    SmbReq.Protocol = SmbCmd->bProtocol;
    SmbReq.Command = SmbCmd->bCmd;
    rc = DeviceIoControl(ghSysAcc,
                         IOCTL_SYSACC_SMBUS_REQUEST,
                         &SmbReq,
                         sizeof(SmbReq),
                         &SmbReq,
                         sizeof(SmbReq),
                         &dwcbReturned,
                         NULL);
    if (rc && (SmbReq.Status == SMB_STATUS_OK))
    {
        if (SmbReq.Protocol == SMB_READ_BLOCK)
        {
            PBLOCK_DATA Block = (PBLOCK_DATA)pbBuff;

            Block->bBlockLen = SmbReq.BlockLength;
            memset(Block->BlockData, 0, sizeof(Block->BlockData));
            memcpy(Block->BlockData, SmbReq.Data, SmbReq.BlockLength);
        }
        else
        {
            memcpy(pbBuff, SmbReq.Data, SmbCmd->iDataSize);
        }
    }
    else
    {
        ErrorMsg(IDSERR_SYSACC_DEVIOCTL, GetLastError());
    }

    TRACEEXIT(("=%x (Data=%x)\n", rc, *((PWORD)pbBuff)));
    return rc;
}       //GetSMBDevInfo

/*++
    @doc    INTERNAL

    @func   BOOL | DisplaySMBDevInfo | Display SMBus device info.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN PSMBCMD_INFO | SmbCmd | Points to the SMB device command.
    @parm   IN PBYTE | pbBuff | SMB device data to display.

    @rvalue SUCCESS | Returns TRUE if it handles it.
    @rvalue FAILURE | Returns FALSE if it doesn't handle it.
--*/

BOOL
DisplaySMBDevInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO SmbCmd,
    IN PBYTE        pbBuff
    )
{
    TRACEPROC("DisplaySMBDevInfo", 3)
    BOOL rc = TRUE;
    WORD wData;
    BYTE bData;
    char *pszUnit = SmbCmd->pszUnit? SmbCmd->pszUnit: "";

    TRACEENTER(("(hwndEdit=%x,SmbCmd=%p,Cmd=%s,pbBuff=%p)\n",
                hwndEdit, SmbCmd, SmbCmd->pszLabel, pbBuff));

    switch (SmbCmd->bType)
    {
        case TYPEF_BYTE_HEX:
            bData = *pbBuff;
            EditPrintf(hwndEdit,
                       "  0x%02x %s\r\n",
                       bData,
                       pszUnit);
            break;

        case TYPEF_BYTE_DEC:
            bData = *pbBuff;
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       bData,
                       pszUnit);
            break;

        case TYPEF_BYTE_INT:
            bData = *pbBuff;
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       (signed char)bData,
                       pszUnit);
            break;

        case TYPEF_WORD_HEX:
            wData = *((PWORD)pbBuff);
            EditPrintf(hwndEdit,
                       "0x%04x %s\r\n",
                       wData,
                       pszUnit);
            break;

        case TYPEF_WORD_DEC:
            wData = *((PWORD)pbBuff);
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       wData,
                       pszUnit);
            break;

        case TYPEF_WORD_INT:
            wData = *((PWORD)pbBuff);
            EditPrintf(hwndEdit,
                       "%6d %s\r\n",
                       (SHORT)wData,
                       pszUnit);
            break;

        case TYPEF_BYTE_BITS:
            bData = *pbBuff;
            EditPrintf(hwndEdit, "  0x%02x", bData);
            DisplayDevBits(hwndEdit,
                           SmbCmd->dwData,
                           (PSZ *)SmbCmd->pvData,
                           (DWORD)bData);
            EditPrintf(hwndEdit, "\r\n");
            break;

        case TYPEF_WORD_BITS:
            wData = *((PWORD)pbBuff);
            EditPrintf(hwndEdit, "0x%04x", wData);
            DisplayDevBits(hwndEdit,
                           SmbCmd->dwData,
                           (PSZ *)SmbCmd->pvData,
                           (DWORD)wData);
            EditPrintf(hwndEdit, "\r\n");
            break;

        case TYPEF_BLOCK_STRING:
            EditPrintf(hwndEdit,
                       "\"%.*s\"\r\n",
                       ((PBLOCK_DATA)pbBuff)->bBlockLen,
                       ((PBLOCK_DATA)pbBuff)->BlockData);
            break;

        case TYPEF_BLOCK_BUFFER:
        {
            PBLOCK_DATA BlockData = (PBLOCK_DATA)pbBuff;
            char szSpaces[32];
            int i, iLen;

            iLen = lstrlenA(SmbCmd->pszLabel);
            for (i = 0; i < iLen; ++i)
            {
                szSpaces[i] = ' ';
            }
            szSpaces[i] = '\0';

            for (i = 0;
                 (i < BlockData->bBlockLen) &&
                 (i < sizeof(BlockData->BlockData));
                 ++i)
            {
                if ((i > 0) && ((i % 8) == 0))
                {
                    EditPrintf(hwndEdit, "\r\n%s ", szSpaces);
                }
                EditPrintf(hwndEdit, " %02x", BlockData->BlockData[i]);
            }
            EditPrintf(hwndEdit, "\r\n");
            break;
        }

        default:
            rc = FALSE;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DisplaySMBDevInfo

/*++
    @doc    INTERNAL

    @func   VOID | DisplayDevBits | Display device bits info.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN DWORD | dwBitMask | Bit mask of relevant data bits.
    @parm   IN PSZ * | apszBitNames | Points to array of bit names.
    @parm   IN DWORD | dwData | device data.

    @rvalue None.
--*/

VOID
DisplayDevBits(
    IN HWND  hwndEdit,
    IN DWORD dwBitMask,
    IN PSZ  *apszBitNames,
    IN DWORD dwData
    )
{
    TRACEPROC("DisplayDevBits", 3)
    ULONG dwBit;
    int i;

    TRACEENTER(("(hwndEdit=%x,BitMask=%x,apszBitNames=%p,Data=%x)\n",
                hwndEdit, dwBitMask, apszBitNames, dwData));

    for (dwBit = 0x80000000, i = 0; dwBit != 0; dwBit >>= 1)
    {
        if (dwBitMask & dwBit)
        {
            if (dwData & dwBit)
            {
                EditPrintf(hwndEdit, ",%s", apszBitNames[i]);
            }
            i++;
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //DisplayDevBits

/*++
    @doc    INTERNAL

    @func   VOID | EditPrintf | Append text to edit control.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN PSZ | pszFormat | Points to format string.
    @parm   ... | Arguments

    @rvalue None.
--*/

VOID
__cdecl
EditPrintf(
    IN HWND hwndEdit,
    IN PSZ  pszFormat,
    ...
    )
{
    TRACEPROC("EditPrintf", 3)
    va_list arglist;
    char szText[256];

    TRACEENTER(("(hwndEdit=%x,Format=%s)\n", hwndEdit, pszFormat));

    va_start(arglist, pszFormat);
    vsprintf(szText, pszFormat, arglist);
    va_end(arglist);

    SendMessage(hwndEdit, EM_SETSEL, -1, -1);
    SendMessage(hwndEdit, EM_REPLACESEL, 0, (LPARAM)szText);

    TRACEEXIT(("!\n"));
    return;
}       //EditPrintf

#endif  //ifdef SYSACC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\resid.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resid.h

Abstract:  Contains definitions of all resource IDs.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#ifndef _RESID_H
#define _RESID_H

//
// Error codes
//
#define IDSERR_ASSERT                   1
#define IDSERR_RPC_FAILED               2
#define IDSERR_STRING_BINDING           3
#define IDSERR_BINDING_HANDLE           4
#define IDSERR_SETAUTHO_INFO            5
#define IDSERR_COMMCTRL                 6
#define IDSERR_PROP_SHEET               7
#define IDSERR_TABSRV_GETPENFEATURE     8
#define IDSERR_TABSRV_SETPENFEATURE     9
#define IDSERR_CALIBRATE_CREATEWINDOW   10
#define IDSERR_TABSRV_GETGESTURESETTINGS 11
#define IDSERR_TABSRV_SETGESTURESETTINGS 12
#define IDSERR_GETPROCADDR_SMAPI        13
#define IDSERR_LOADLIBRARY_SMAPI        14
#define IDSERR_SMAPI_CALLFAILED         15
#define IDSERR_SMAPI_INSTRETCHMODE      16
#define IDSERR_SMAPI_INDUALAPPMODE      17
#define IDSERR_SMAPI_INDUALVIEWMODE     18
#define IDSERR_SMAPI_INRGBPROJMODE      19
#define IDSERR_SMAPI_INVIRTUALSCREEN    20
#define IDSERR_SMAPI_INVIRTUALREFRESH   21
#define IDSERR_SMAPI_INROTATEMODE       22
#define IDSERR_SMAPI_2NDMONITORON       23
#define IDSERR_SMAPI_WRONGHW            24
#define IDSERR_SMAPI_CLRDEPTH           25
#define IDSERR_SMAPI_MEMORY             26
#define IDSERR_SMAPI_SETMODE            27
#define IDSERR_SMAPI_DIRECTION          28
#define IDSERR_SMAPI_CAPTUREON          29
#define IDSERR_SMAPI_VIDEOON            30
#define IDSERR_SMAPI_DDRAWON            31
#define IDSERR_SMAPI_ALREADYSET         32
#define IDSERR_TABSRV_GETBUTTONSETTINGS 33
#define IDSERR_TABSRV_SETBUTTONSETTINGS 34
#define IDSERR_SMBLITE_NODEVICE         35
#define IDSERR_SMBLITE_DEVIOCTL         36
#define IDSERR_SMBLITE_OPENDEV          37
#ifdef SYSACC
#define IDSERR_SYSACC_OPENDEV           80
#define IDSERR_SYSACC_DEVIOCTL          81
#endif

//
// Global Resources
//
#define IDS_NAME                        100
#define IDS_INFO                        101
#define IDS_TITLE                       102

#define IDI_TABLETPC                    200

#ifdef PENPAGE
//
// Calibration strings
//
#define IDS_CALIBRATE_TITLE             300
#define IDS_LINEARCAL_TITLE             301
#define IDS_CALIBRATE_CONFIRM           302
#define IDS_CALIBRATE_INSTRUCTIONS      303

//
// Side Switch Assignment Text Strings
//
#define IDS_SWCOMBO_NONE                500
#define IDS_SWCOMBO_RCLICK              501
#endif

#ifdef BUTTONPAGE
//
// Button Assignment Text Strings
//
#define IDS_BUTCOMBO_NONE               600
#define IDS_BUTCOMBO_INVOKENOTEBOOK     601
#define IDS_BUTCOMBO_PAGEUP             602
#define IDS_BUTCOMBO_PAGEDOWN           603
#define IDS_BUTCOMBO_ALTESC             604
#define IDS_BUTCOMBO_ALTTAB             605
#define IDS_BUTCOMBO_ENTER              606
#define IDS_BUTCOMBO_ESC                607
#endif

//
// Gesture Assignment Text Strings
//
#define IDS_GESTCOMBO_NONE              700
#define IDS_GESTCOMBO_POPUP_SUPERTIP    701
#define IDS_GESTCOMBO_POPUP_MIP         702
#define IDS_GESTCOMBO_SEND_HOTKEY       703

//
// Property Page IDs
//
#ifdef PENPAGE
#define IDD_MUTOHPEN                    1000
#endif
#ifdef BUTTONPAGE
#define IDD_BUTTONS                     1001
#endif
#define IDD_DISPLAY                     1002
#define IDD_GESTURE                     1003
#ifdef DEBUG
#define IDD_TUNING                      1004
#endif
#ifdef BATTINFO
#define IDD_BATTERY                     1005
#endif
#ifdef CHGRINFO
#define IDD_CHARGER                     1006
#endif
#ifdef TMPINFO
#define IDD_TEMPERATURE                 1007
#endif

#ifdef PENPAGE
//
// IDD_MUTOHPEN Controls
//
#define IDC_RATE_GROUPBOX               1100
#define IDC_SAMPLINGRATE                1101
#define IDC_RATE_FASTER                 1102
#define IDC_RATE_SLOWER                 1103
#define IDC_RATE_TEXT                   1104
#define IDS_RATE_TEXT_FORMAT            1105
#define IDC_SWITCH_GROUPBOX             1106
#define IDC_SIDESWITCH_TEXT             1107
#define IDC_SIDE_SWITCH                 1108
#define IDC_ENABLE_DIGITALFILTER        1109
#define IDC_ENABLE_GLITCHFILTER         1110
#define IDC_CALIBRATE                   1111

//
// IDD_MUTOHPEN Help IDs
//
#define IDH_MUTOHPEN_SAMPLINGRATE       1150
#define IDH_MUTOHPEN_SIDE_SWITCH        1151
#define IDH_MUTOHPEN_ENABLE_DIGITALFILTER 1152
#define IDH_MUTOHPEN_ENABLE_GLITCHFILTER 1153
#define IDH_CALIBRATE                   1154
#endif

#ifdef BUTTONPAGE
//
// IDD_BUTTONS Controls
//
#define IDC_BUTTON_GROUPBOX             1200
#define IDC_BUTTON1_TEXT                1201
#define IDC_BUTTON_1                    1202
#define IDC_BUTTON2_TEXT                1203
#define IDC_BUTTON_2                    1204
#define IDC_BUTTON3_TEXT                1205
#define IDC_BUTTON_3                    1206
#define IDC_BUTTON4_TEXT                1207
#define IDC_BUTTON_4                    1208
#define IDC_BUTTON5_TEXT                1209
#define IDC_BUTTON_5                    1210
#define IDC_HOTKEY1_TEXT                1211
#define IDC_HOTKEY1                     1212
#define IDC_HOTKEY1_SPIN                1213
#define IDC_HOTKEY2_TEXT                1214
#define IDC_HOTKEY2                     1215
#define IDC_HOTKEY2_SPIN                1216

//
// IDD_BUTTONS Help IDs
//
#define IDH_BUTTONS_BUTTONMAP           1250
#endif

//
// IDD_DISPLAY Controls
//
#define IDC_ROTATE_GROUPBOX             1300
#define IDC_ROTATE_LANDSCAPE            1301
#define IDC_ROTATE_PORTRAIT             1302
#ifdef BACKLIGHT
#define IDC_BRIGHTNESS_GROUPBOX         1303
#define IDC_BRIGHTNESS_AC               1304
#define IDC_DIMMER_AC_TEXT              1305
#define IDC_BRIGHTER_AC_TEXT            1306
#define IDC_BRIGHTNESS_AC_TEXT          1307
#define IDC_BRIGHTNESS_DC               1308
#define IDC_DIMMER_DC_TEXT              1309
#define IDC_BRIGHTER_DC_TEXT            1310
#define IDC_BRIGHTNESS_DC_TEXT          1311
#endif

//
// IDD_DISPLAY Help IDs
//
#define IDH_ROTATE                      1350

//
// IDD_GESTURE Controls
//
#define IDC_ENABLE_GESTURE              1400
#define IDC_GESTUREMAP_GROUPBOX         1401
#define IDC_UPSPIKE_TEXT                1402
#define IDC_UPSPIKE                     1403
#define IDC_DOWNSPIKE_TEXT              1404
#define IDC_DOWNSPIKE                   1405
#define IDC_LEFTSPIKE_TEXT              1406
#define IDC_LEFTSPIKE                   1407
#define IDC_RIGHTSPIKE_TEXT             1408
#define IDC_RIGHTSPIKE                  1409
#define IDC_ENABLE_PRESSHOLD            1410
#ifdef DEBUG
#define IDC_ENABLE_MOUSE                1411
#endif

//
// IDD_GESTURE Help IDs
//
#define IDH_GESTURE_MAP                 1450

#ifdef DEBUG
//
// IDD_GESTURE_PARAM Controls
//
#define IDC_GESTURE_GROUPBOX            1500
#define IDC_GESTURE_RADIUS              1501
#define IDC_GESTURE_RADIUS_SPIN         1502
#define IDC_GESTURE_RADIUS_TEXT         1503
#define IDC_GESTURE_MINOUTPTS           1504
#define IDC_GESTURE_MINOUTPTS_SPIN      1505
#define IDC_GESTURE_MINOUTPTS_TEXT      1506
#define IDC_GESTURE_MAXTIMETOINSPECT    1507
#define IDC_GESTURE_MAXTIMETOINSPECT_SPIN 1508
#define IDC_GESTURE_MAXTIMETOINSPECT_TEXT 1509
#define IDC_GESTURE_ASPECTRATIO         1510
#define IDC_GESTURE_ASPECTRATIO_SPIN    1511
#define IDC_GESTURE_ASPECTRATIO_TEXT    1512
#define IDC_GESTURE_CHECKTIME           1513
#define IDC_GESTURE_CHECKTIME_SPIN      1514
#define IDC_GESTURE_CHECKTIME_TEXT      1515
#define IDC_GESTURE_PTSTOEXAMINE        1516
#define IDC_GESTURE_PTSTOEXAMINE_SPIN   1517
#define IDC_GESTURE_PTSTOEXAMINE_TEXT   1518
#define IDC_GESTURE_STOPDIST            1519
#define IDC_GESTURE_STOPDIST_SPIN       1520
#define IDC_GESTURE_STOPDIST_TEXT       1521
#define IDC_GESTURE_STOPTIME            1522
#define IDC_GESTURE_STOPTIME_SPIN       1523
#define IDC_GESTURE_STOPTIME_TEXT       1524
#define IDC_PRESSHOLD_GROUPBOX          1525
#define IDC_PRESSHOLD_HOLDTIME          1526
#define IDC_PRESSHOLD_HOLDTIME_SPIN     1527
#define IDC_PRESSHOLD_HOLDTIME_TEXT     1528
#define IDC_PRESSHOLD_TOLERANCE         1529
#define IDC_PRESSHOLD_TOLERANCE_SPIN    1530
#define IDC_PRESSHOLD_TOLERANCE_TEXT    1531
#define IDC_PRESSHOLD_CANCELTIME        1532
#define IDC_PRESSHOLD_CANCELTIME_SPIN   1533
#define IDC_PRESSHOLD_CANCELTIME_TEXT   1534
#endif

#ifdef BATTINFO
//
// IDD_BATTERY Controls
//
#define IDC_BATTINFO_TEXT               5000
#define IDC_BATTINFO_REFRESH            5001
#endif

#ifdef CHGRINFO
//
// IDD_CHARGER Controls
//
#define IDC_CHGRINFO_TEXT               5100
#define IDC_CHGRINFO_REFRESH            5101
#endif

#ifdef TMPINFO
//
// IDD_TEMPERATURE Controls
//
#define IDC_TMPINFO_TEXT                5200
#define IDC_TMPINFO_REFRESH             5201
#endif

#endif  //ifndef _RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tabletpc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tabletpc.h

Abstract:  Contains definitions of all constants and data types for the
           Tablet PC control panel applet.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#ifndef _TABLETPC_H
#define _TABLETPC_H

//
// Constants
//

//
// Macros
//
#define RPC_TRY(n,s)            {                                       \
                                    RpcTryExcept                        \
                                    {                                   \
                                        s;                              \
                                    }                                   \
                                    RpcExcept(1)                        \
                                    {                                   \
                                        ErrorMsg(IDSERR_RPC_FAILED,     \
                                                 n,                     \
                                                 RpcExceptionCode());   \
                                    }                                   \
                                    RpcEndExcept                        \
                                }

//
// Type Definitions
//

typedef struct _TABLETPC_PROPPAGE
{
    LPCTSTR        DlgTemplate;
    DLGPROC        DlgProc;
    HPROPSHEETPAGE hPropSheetPage;
} TABLETPC_PROPPAGE, *PTABLETPC_PROPPAGE;

typedef struct _COMBOBOX_STRING
{
    int  StringIndex;
    UINT StringID;
} COMBOBOX_STRING, *PCOMBOBOX_STRING;

typedef struct _COMBO_MAP
{
    UINT ComboBoxID;
    int  ComboBoxIndex;
} COMBO_MAP, *PCOMBO_MAP;

//
// Global Data Declarations
//
extern HINSTANCE ghInstance;
extern RPC_BINDING_HANDLE ghBinding;
#ifdef SYSACC
extern HANDLE ghSysAcc;
extern HFONT ghFont;
#endif
extern TCHAR gtszTitle[64];
#ifdef PENPAGE
extern TCHAR gtszCalibrate[16];
extern PEN_SETTINGS PenSettings;
#endif
extern GESTURE_SETTINGS gGestureSettings;

//
// Function prototypes
//

// tabletpc.c
BOOL WINAPI
DllInitialize(
    IN HINSTANCE hDLLInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpvReserved OPTIONAL
    );

LONG APIENTRY
CPlApplet(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LONG lParam1,
    IN LONG lParam2
    );

BOOL
RunApplet(
    IN HWND hwnd,
    IN LPTSTR CmdLine OPTIONAL
    );

UINT
CreatePropertyPages(
    IN PTABLETPC_PROPPAGE TabletPCPages,
    OUT HPROPSHEETPAGE *hPages
    );

VOID
InsertComboBoxStrings(
    IN HWND             hwnd,
    IN UINT             ComboBoxID,
    IN PCOMBOBOX_STRING ComboString
    );

VOID
EnableDlgControls(
    IN HWND hwnd,
    IN int *piControls,
    IN BOOL fEnable
    );

#ifdef PENPAGE
// mutohpen.c
INT_PTR APIENTRY
MutohPenDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitMutohPenPage(
    IN HWND   hwnd
    );

// tiltcal.c
BOOL
CreatePenTiltCalWindow(
    IN HWND hwndParent
    );

ATOM
RegisterPenTiltCalClass(
    IN HINSTANCE hInstance
    );

LRESULT CALLBACK
PenTiltCalWndProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

PCALIBRATE_PT
FindVicinity(
    IN int x,
    IN int y,
    IN int offset
    );

VOID
DrawTarget(
    IN HDC hDC,
    IN PCALIBRATE_PT CalPt
    );

int
DoPenTiltCal(
    IN  HWND  hwnd,
    OUT PLONG pdxPenTilt,
    OUT PLONG pdyPenTilt
    );

// linCal.c
BOOL
CreateLinearCalWindow(
    IN HWND hwndParent
    );

ATOM
RegisterLinearCalClass(
    IN HINSTANCE hInstance
    );

LRESULT CALLBACK
LinearCalWndProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

PCALIBRATE_PT
FindPoint(
    IN int x,
    IN int y,
    IN int offset
    );

VOID
DoLinearCal(
    IN  HWND        hwnd,
    OUT PLINEAR_MAP LinearityMap
    );

VOID
DisplayMap(
    IN HWND hwnd,
    IN PLINEAR_MAP LinearityMap
    );
#endif

#ifdef BUTTONPAGE
// buttons.c
INT_PTR APIENTRY
ButtonsDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitButtonPage(
    IN HWND hwnd
    );

int
MapButtonTagIndex(
    IN int iButton
    );
#endif

// display.c
INT_PTR APIENTRY
DisplayDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitDisplayPage(
    IN HWND hwnd
    );

BOOL
__stdcall
SetRotation(
    IN DWORD dwRotation
    );

DWORD
RotateScreen(
    IN DWORD dwRotation
    );

VOID
EnumDisplayModes(
    VOID
    );

BOOL
GetBrightness(
    OUT PSMBLITE_BRIGHTNESS Brightness
    );

BOOL
SetBrightness(
    IN PSMBLITE_BRIGHTNESS Brightness,
    IN BOOLEAN             fSaveSettings
    );

// gesture.c
INT_PTR APIENTRY
GestureDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitGesturePage(
    IN HWND   hwnd
    );

#ifdef DEBUG
// tuning.c
INT_PTR APIENTRY
TuningDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitTuningPage(
    IN HWND   hwnd
    );
#endif  //ifdef DEBUG

#ifdef SYSACC
// smbdev.c
BOOL
GetSMBDevInfo(
    IN  UCHAR        bDevAddr,
    IN  PSMBCMD_INFO SmbCmd,
    OUT PBYTE        pbBuff
    );

BOOL
DisplaySMBDevInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO SmbCmd,
    IN PBYTE        pbBuff
    );

VOID
DisplayDevBits(
    IN HWND  hwndEdit,
    IN DWORD dwBitMask,
    IN PSZ  *apszBitNames,
    IN DWORD dwData
    );

VOID
__cdecl
EditPrintf(
    IN HWND hwndEdit,
    IN PSZ  pszFormat,
    ...
    );
#endif  //ifdef SYSACC

#ifdef BATTINFO
// battinfo.c
INT_PTR APIENTRY
BatteryDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitBatteryPage(
    IN HWND hwnd
    );

VOID
RefreshBatteryInfo(
    IN HWND hwndEdit
    );

BOOL
DisplayBatteryInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO BattCmd,
    IN PBYTE        pbBuff,
    IN BOOL         fWatt
    );
#endif  //ifdef BATTINFO

#ifdef CHGRINFO
// chgrinfo.c
INT_PTR APIENTRY
ChargerDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitChargerPage(
    IN HWND hwnd
    );

VOID
RefreshChgrInfo(
    IN HWND hwndEdit
    );

BOOL
DisplayChgrInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO TmpCmd,
    IN PBYTE        pbBuff
    );
#endif  //ifdef CHGRINFO

#ifdef TMPINFO
// tmpinfo.c
INT_PTR APIENTRY
TemperatureDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitTemperaturePage(
    IN HWND hwnd
    );

VOID
RefreshTmpInfo(
    IN HWND hwndEdit
    );

BOOL
DisplayTmpInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO TmpCmd,
    IN PBYTE        pbBuff
    );
#endif  //ifdef TMPINFO

#endif  //ifndef _TABLETPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tiltcal.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tiltcal.c

Abstract: This module contains code to calibrate pen tilt of the mutoh pen
          tablet.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#include "pch.h"

#ifdef PENPAGE
#define NUM_PENTILTCAL_XPTS     2
#define NUM_PENTILTCAL_YPTS     2
#define NUM_PENTILTCAL_PTS      (NUM_PENTILTCAL_XPTS*NUM_PENTILTCAL_YPTS)
#define SCREEN_TARGET_XOFFSET   128
#define SCREEN_TARGET_YOFFSET   128
#define VICINITY_OFFSET         50
#define INSTRUCTIONS_WIDTH      256
#define INSTRUCTIONS_HEIGHT     128

static TCHAR gtszCalibrate[] = TEXT("Calibrate");
static TCHAR gtszCalibrateTitle[64] = {0};
static TCHAR gtszInstructions[256] = {0};
static RECT grectInstructions = {0};
static CALIBRATE_PT gCalPts[NUM_PENTILTCAL_YPTS][NUM_PENTILTCAL_XPTS] = {0};
static int giNumPenTiltCalPts = 0;
static HWND ghwndParent = 0;
static LONG gcxScreen = 0, gcyScreen = 0;
static HPEN ghpenRed = 0, ghpenBlue = 0;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CreatePenTiltCalWindow |
 *          Entry point of the pen tilt calibration code.
 *
 *  @parm   IN HWND | hwndParent | Parent Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
CreatePenTiltCalWindow(
    IN HWND hwndParent
    )
{
    TRACEPROC("CreatePenTiltCalWindow", 2)
    BOOL rc = FALSE;
    HWND hwnd;

    TRACEENTER(("(hwndParent=%p)\n", hwndParent));

    giNumPenTiltCalPts = 0;
    RtlZeroMemory(gCalPts, sizeof(gCalPts));

    ghwndParent = hwndParent;
    LoadString(ghInstance,
               IDS_CALIBRATE_TITLE,
               gtszCalibrateTitle,
               sizeof(gtszCalibrateTitle)/sizeof(TCHAR));
    LoadString(ghInstance,
               IDS_CALIBRATE_INSTRUCTIONS,
               gtszInstructions,
               sizeof(gtszInstructions)/sizeof(TCHAR));

    gcxScreen = GetSystemMetrics(SM_CXSCREEN);
    gcyScreen = GetSystemMetrics(SM_CYSCREEN);

    grectInstructions.left   = (gcxScreen - INSTRUCTIONS_WIDTH)/2;
    grectInstructions.top    = (gcyScreen - INSTRUCTIONS_HEIGHT)/2;
    grectInstructions.right  = grectInstructions.left + INSTRUCTIONS_WIDTH;
    grectInstructions.bottom = grectInstructions.top + INSTRUCTIONS_HEIGHT;

    RegisterPenTiltCalClass(ghInstance);
    hwnd = CreateWindow(gtszCalibrate,      //Class Name
                        gtszCalibrate,      //Window Name
                        WS_POPUP,           //Style
                        0,                  //Window X
                        0,                  //Window Y
                        gcxScreen,          //Window Width
                        gcyScreen,          //Window Height
                        hwndParent,         //Parent Handle
                        NULL,               //Menu Handle
                        ghInstance,         //Instance Handle
                        NULL);              //Creation Data

    if (hwnd != NULL)
    {
        ShowWindow(hwnd, SW_SHOWNORMAL);
        rc = TRUE;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //CreatePenTiltCalWindow

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | RegisterPenTiltCalClass |
 *          Register window class.
 *
 *  @parm   IN HINSTANCE | hInstance | Instance handle.
 *
 *  @rvalue SUCCESS | Returns class atom
 *  @rvalue FAILURE | Returns 0
 *
 *****************************************************************************/

ATOM
RegisterPenTiltCalClass(
    IN HINSTANCE hInstance
    )
{
    TRACEPROC("RegisterPenTiltCalClass", 2)
    ATOM atom;
    WNDCLASSEX wcex;

    TRACEENTER(("(hInstance=%p)\n", hInstance));

    wcex.cbSize = sizeof(wcex);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = PenTiltCalWndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon(hInstance, (LPCTSTR)IDI_TABLETPC);
    wcex.hCursor = NULL;        //No cursor is shown.
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = NULL;
    wcex.lpszClassName = gtszCalibrate;
    wcex.hIconSm = NULL;

    atom = RegisterClassEx(&wcex);

    TRACEEXIT(("=%x\n", atom));
    return atom;
}       //RegisterPenTiltCalClass

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   LRESULT | PenTiltCalWndProc |
 *          Dialog procedure for the pen tilt calibration page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

LRESULT CALLBACK
PenTiltCalWndProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("PenTiltCalWndProc", 2)
    LRESULT rc = 0;
    HDC hDC;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_CREATE:
        {
            ghpenRed = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            ghpenBlue = CreatePen(PS_SOLID, 0, RGB(0, 0, 255));
            gCalPts[0][0].ScreenPt.x = SCREEN_TARGET_XOFFSET;
            gCalPts[0][0].ScreenPt.y = SCREEN_TARGET_YOFFSET;

            gCalPts[0][1].ScreenPt.x = gcxScreen - SCREEN_TARGET_XOFFSET;
            gCalPts[0][1].ScreenPt.y = SCREEN_TARGET_YOFFSET;

            gCalPts[1][0].ScreenPt.x = SCREEN_TARGET_XOFFSET;
            gCalPts[1][0].ScreenPt.y = gcyScreen - SCREEN_TARGET_YOFFSET;

            gCalPts[1][1].ScreenPt.x = gcxScreen - SCREEN_TARGET_XOFFSET;
            gCalPts[1][1].ScreenPt.y = gcyScreen - SCREEN_TARGET_YOFFSET;
            ShowCursor(FALSE);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            PCALIBRATE_PT CalPt;
            WORD wButtonState;

            CalPt = FindVicinity(GET_X_LPARAM(lParam),
                                 GET_Y_LPARAM(lParam),
                                 VICINITY_OFFSET);
            if (CalPt != NULL)
            {
                CalPt->DigiPt.x = GET_X_LPARAM(lParam);
                CalPt->DigiPt.y = GET_Y_LPARAM(lParam);
                if (!(CalPt->dwFlags & CPF_CALIBRATED))
                {
                    CalPt->dwFlags |= CPF_CALIBRATED;
                    giNumPenTiltCalPts++;
                    hDC = GetDC(hwnd);
                    DrawTarget(hDC, CalPt);
                    ReleaseDC(hwnd, hDC);
                    if (giNumPenTiltCalPts == NUM_PENTILTCAL_PTS)
                    {
                        int rcID = DoPenTiltCal(hwnd,
                                                &PenSettings.dxPenTilt,
                                                &PenSettings.dyPenTilt);

                        if ((rcID == IDYES) || (rcID == IDCANCEL))
                        {
                            SendMessage(ghwndParent,
                                        WM_PENTILTCAL_DONE,
                                        (WPARAM)rcID,
                                        (LPARAM)hwnd);
                        }
                    }
                }
            }
            break;
        }

        case WM_CHAR:
            switch (wParam)
            {
                case VK_ESCAPE:
                    SendMessage(ghwndParent,
                                WM_PENTILTCAL_DONE,
                                (WPARAM)NULL,
                                (LPARAM)hwnd);
                    break;
            }
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            int i, j;

            hDC = BeginPaint(hwnd, &ps);

            for (i = 0; i < NUM_PENTILTCAL_YPTS; ++i)
            {
                for (j = 0; j < NUM_PENTILTCAL_XPTS; ++j)
                {
                    DrawTarget(hDC, &gCalPts[i][j]);
                }
            }

            DrawText(hDC,
                     gtszInstructions,
                     -1,
                     &grectInstructions,
                     DT_WORDBREAK | DT_LEFT | DT_VCENTER);

            EndPaint(hwnd, &ps);
            break;
        }

        case WM_DESTROY:
            ShowCursor(TRUE);
            if (ghpenRed != NULL)
            {
                DeleteObject(ghpenRed);
            }
            if (ghpenBlue != NULL)
            {
                DeleteObject(ghpenBlue);
            }
            break;

        default:
            rc = DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //PenTiltCalWndProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCALIBRATE_PT | FindVicinity |
 *          Find if the click is in the vicinity of the calibrate points.
 *
 *  @parm   IN int | x | X value.
 *  @parm   IN int | y | Y value.
 *  @parm   IN int | offset | Vicinity offset
 *
 *  @rvalue SUCCESS | Returns calibrate point found in the vicinity.
 *  @rvalue FAILURE | Returns NULL.
 *
 *****************************************************************************/

PCALIBRATE_PT
FindVicinity(
    IN int x,
    IN int y,
    IN int offset
    )
{
    TRACEPROC("FindVicinity", 2)
    PCALIBRATE_PT CalPt = NULL;
    int i, j;

    TRACEENTER(("(x=%d,y=%d,offset=%d)\n", x, y, offset));

    for (i = 0; i < NUM_PENTILTCAL_YPTS; ++i)
    {
        for (j = 0; j < NUM_PENTILTCAL_XPTS; ++j)
        {
            if ((x >= gCalPts[i][j].ScreenPt.x - offset) &&
                (x <= gCalPts[i][j].ScreenPt.x + offset) &&
                (y >= gCalPts[i][j].ScreenPt.y - offset) &&
                (y <= gCalPts[i][j].ScreenPt.y + offset))
            {
                CalPt = & gCalPts[i][j];
                break;
            }
        }
    }

    TRACEEXIT(("=%p\n", CalPt));
    return CalPt;
}       //FindVicinity

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | DrawTarget |
 *          Draw the given target point.
 *
 *  @parm   IN HDC | hDC | DC handle.
 *  @parm   IN PCALIBRATE_PT | CalPt | Points to the calibration point.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID
DrawTarget(
    IN HDC hDC,
    IN PCALIBRATE_PT CalPt
    )
{
    TRACEPROC("DrawTarget", 2)
    HPEN hpenOld;

    TRACEENTER(("(hDC=%x,CalPt=%p)\n", hDC, CalPt));

    hpenOld = SelectObject(hDC,
                           (CalPt->dwFlags & CPF_CALIBRATED)?
                                ghpenRed: ghpenBlue);

    MoveToEx(hDC, CalPt->ScreenPt.x - 16, CalPt->ScreenPt.y, NULL);
    LineTo(hDC, CalPt->ScreenPt.x - 4, CalPt->ScreenPt.y);

    MoveToEx(hDC, CalPt->ScreenPt.x - 2, CalPt->ScreenPt.y, NULL);
    LineTo(hDC, CalPt->ScreenPt.x + 2, CalPt->ScreenPt.y);

    MoveToEx(hDC, CalPt->ScreenPt.x + 4, CalPt->ScreenPt.y, NULL);
    LineTo(hDC, CalPt->ScreenPt.x + 16, CalPt->ScreenPt.y);

    MoveToEx(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y - 16, NULL);
    LineTo(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y - 4);

    MoveToEx(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y - 2, NULL);
    LineTo(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y + 2);

    MoveToEx(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y + 4, NULL);
    LineTo(hDC, CalPt->ScreenPt.x, CalPt->ScreenPt.y + 16);

    SelectObject(hDC, hpenOld);

    TRACEEXIT(("!\n"));
    return;
}       //DrawTarget

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | DoPenTiltCal |
 *          Confirm with the user on the calibration data and do the
 *          calibration calculation.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   OUT PLONG | pdxPenTilt | To hold the x pen tilt compensation.
 *  @parm   OUT PLONG | pdyPenTilt | To hold the y pen tilt compensation.
 *
 *  @rvalue SUCCESS | Returns IDYES.
 *  @rvalue FAILURE | Returns IDNO or IDCANCEL.
 *
 *****************************************************************************/

int
DoPenTiltCal(
    IN  HWND  hwnd,
    OUT PLONG pdxPenTilt,
    OUT PLONG pdyPenTilt
    )
{
    TRACEPROC("DoPenTiltCal", 2)
    int rc;
    TCHAR tszMsg[128];

    TRACEENTER(("(hwnd=%x,pdxPenTilt=%p,pdyPenTilt)\n",
                hwnd, pdxPenTilt, pdyPenTilt));

    LoadString(ghInstance,
               IDS_CALIBRATE_CONFIRM,
               tszMsg,
               sizeof(tszMsg)/sizeof(TCHAR));

    ShowCursor(TRUE);
    rc = MessageBox(hwnd,
                    tszMsg,
                    gtszCalibrateTitle,
                    MB_YESNOCANCEL | MB_ICONQUESTION);
    ShowCursor(FALSE);
    if (rc == IDNO)
    {
        int i, j;

        //
        // Reset the calibration.
        //
        for (i = 0; i < NUM_PENTILTCAL_YPTS; ++i)
        {
            for (j = 0; j < NUM_PENTILTCAL_XPTS; ++j)
            {
                gCalPts[i][j].dwFlags &= ~CPF_CALIBRATED;
            }
        }
        giNumPenTiltCalPts = 0;
        InvalidateRect(hwnd, NULL, TRUE);
    }
    else if (rc == IDYES)
    {
        int i, j;

        *pdxPenTilt = *pdyPenTilt = 0;
        for (i = 0; i < NUM_PENTILTCAL_YPTS; ++i)
        {
            for (j = 0; j < NUM_PENTILTCAL_XPTS; ++j)
            {
                *pdxPenTilt += gCalPts[i][j].DigiPt.x -
                               gCalPts[i][j].ScreenPt.x;
                *pdyPenTilt += gCalPts[i][j].DigiPt.y -
                               gCalPts[i][j].ScreenPt.y;
            }
        }

        *pdxPenTilt /= NUM_PENTILTCAL_PTS;
        *pdyPenTilt /= NUM_PENTILTCAL_PTS;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DoPenTiltCal
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\smbdev.h ===
/*++
    Copyright (c) 2000,2001  Microsoft Corporation

    Module Name:
        smbdev.h

    Abstract:  Contains SMBus Device definitions.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 25-Jan-2001

    Revision History:
--*/

#ifndef _SMBDEV_H
#define _SMBDEV_H

#ifndef SMB_MAX_DATA_SIZE
#define SMB_MAX_DATA_SIZE               32

// SMB Bus Status codes
#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1a

typedef struct _SMB_REQUEST
{
    UCHAR  Status;
    UCHAR  Protocol;
    UCHAR  Address;
    UCHAR  Command;
    UCHAR  BlockLength;
    UCHAR  Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// SMBus protocol values
//
#define SMB_WRITE_QUICK                 0x00
#define SMB_READ_QUICK                  0x01
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0a
#define SMB_MAXIMUM_PROTOCOL            0x0a
#endif  //ifndef SMB_MAX_DATA_SIZE

#include <pshpack1.h>
typedef struct _BLOCK_DATA
{
    UCHAR bBlockLen;
    UCHAR BlockData[SMB_MAX_DATA_SIZE];
} BLOCK_DATA, *PBLOCK_DATA;
#include <poppack.h>

//wfType flags
#define TYPEF_BYTE_HEX                  0x00
#define TYPEF_BYTE_DEC                  0x01
#define TYPEF_BYTE_INT                  0x02
#define TYPEF_BYTE_BITS                 0x03
#define TYPEF_WORD_HEX                  0x04
#define TYPEF_WORD_DEC                  0x05
#define TYPEF_WORD_INT                  0x06
#define TYPEF_WORD_BITS                 0x07
#define TYPEF_BLOCK_STRING              0x08
#define TYPEF_BLOCK_BUFFER              0x09
#define TYPEF_USER                      0x80

#define BHX                             TYPEF_BYTE_HEX
#define BDC                             TYPEF_BYTE_DEC
#define BSN                             TYPEF_BYTE_INT
#define BBT                             TYPEF_BYTE_BITS
#define WHX                             TYPEF_WORD_HEX
#define WDC                             TYPEF_WORD_DEC
#define WSN                             TYPEF_WORD_INT
#define WBT                             TYPEF_WORD_BITS
#define STR                             TYPEF_BLOCK_STRING
#define BUF                             TYPEF_BLOCK_BUFFER

typedef struct _SMBCMD_INFO
{
    UCHAR  bCmd;
    UCHAR  bProtocol;
    UCHAR  bType;
    int    iDataSize;
    PSZ    pszLabel;
    PSZ    pszUnit;
    ULONG  dwData;
    PVOID  pvData;
} SMBCMD_INFO, *PSMBCMD_INFO;

#endif  //ifndef _SMBDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tabletpc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tabletpc.c

Abstract: Tablet PC Control Panel applet main module.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Apr-2000

Revision History:

--*/

#include "pch.h"

HINSTANCE ghInstance = NULL;
RPC_BINDING_HANDLE ghBinding = NULL;
#ifdef SYSACC
HANDLE ghSysAcc = INVALID_HANDLE_VALUE;
HFONT ghFont = NULL;
#endif
TCHAR gtszTitle[64] = {0};

UINT uHelpMessage = 0;
TABLETPC_PROPPAGE TabletPCPropPages[] =
{
#ifdef PENPAGE
    MAKEINTRESOURCE(IDD_MUTOHPEN),      MutohPenDlgProc,    0,
#endif
#ifdef BUTTONPAGE
    MAKEINTRESOURCE(IDD_BUTTONS),       ButtonsDlgProc,     0,
#endif
    MAKEINTRESOURCE(IDD_DISPLAY),       DisplayDlgProc,     0,
    MAKEINTRESOURCE(IDD_GESTURE),       GestureDlgProc,     0,
#ifdef DEBUG
    MAKEINTRESOURCE(IDD_TUNING),        TuningDlgProc,      0,
#endif
#ifdef BATTINFO
    MAKEINTRESOURCE(IDD_BATTERY),       BatteryDlgProc,     0,
#endif
#ifdef CHGRINFO
    MAKEINTRESOURCE(IDD_CHARGER),       ChargerDlgProc,     0,
#endif
#ifdef TMPINFO
    MAKEINTRESOURCE(IDD_TEMPERATURE),   TemperatureDlgProc, 0,
#endif
    0,                                  NULL,               0
};
#define MAX_PAGES       (sizeof(TabletPCPropPages)/sizeof(TABLETPC_PROPPAGE))

/*++
    @doc    EXTERNAL

    @func   BOOL | DllInitialize |
            Library entry point.

    @parm   IN HINSTANCE | hDLLInstance | Instance handle.
    @parm   IN DWORD | dwReason | Reason being called.
    @parm   IN LPVOID | lpvReserved | Reserved (Unused).

    @rvalue SUCCESS | always returns TRUE
--*/

BOOL WINAPI
DllInitialize(
    IN HINSTANCE hDLLInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpvReserved OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(lpvReserved);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ghInstance = hDLLInstance;
            LoadString(ghInstance,
                       IDS_TITLE,
                       gtszTitle,
                       sizeof(gtszTitle)/sizeof(TCHAR));
            DisableThreadLibraryCalls(ghInstance);
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}       //DllInitialize

/*++
    @doc    EXTERNAL

    @func   LONG | CPlApplet |
            Library-defined callback function that serves as the entry point
            for a Control Panel application.

    @parm   IN HHWN | hwnd | Main window handle.
    @parm   IN UINT | uMsg | Message.
    @parm   IN LONG | lParam1 | Message specific parameter 1.
    @parm   IN LONG | lParam2 | Message specific parameter 2.

    @rvalue Return value depends on the message.
--*/

LONG APIENTRY
CPlApplet(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LONG lParam1,
    IN LONG lParam2
    )
{
    TRACEPROC("CPlApplet", 1)
    LONG rc = 0;

    TRACEENTER(("(hwnd=%p,Msg=%s,Param1=%x,Param2=%x)\n",
                hwnd, LookupName(uMsg, CPLMsgNames), lParam1, lParam2));

    switch (uMsg)
    {
        case CPL_INIT:
            TRACEINIT(MODNAME, 0, 0);
            uHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
            rc = (LONG)TRUE;
            break;

        case CPL_GETCOUNT:
            rc = 1;
            break;

        case CPL_INQUIRE:
        {
            LPCPLINFO CPLInfo = (LPCPLINFO)lParam2;

            CPLInfo->idIcon = IDI_TABLETPC;
            CPLInfo->idName = IDS_NAME;
            CPLInfo->idInfo = IDS_INFO;
            CPLInfo->lData  = 0;
            rc = (LONG)TRUE;
            break;
        }

        case CPL_NEWINQUIRE:
        {
            LPNEWCPLINFO NewCPLInfo = (LPNEWCPLINFO)lParam2;

            memset(NewCPLInfo, 0, sizeof(NEWCPLINFO));
            NewCPLInfo->dwSize = sizeof(NEWCPLINFO);
            NewCPLInfo->hIcon = LoadIcon(ghInstance,
                                         MAKEINTRESOURCE(IDI_TABLETPC));
            LoadString(ghInstance,
                       IDS_NAME,
                       NewCPLInfo->szName,
                       sizeof(NewCPLInfo->szName)/sizeof(TCHAR));
            LoadString(ghInstance,
                       IDS_INFO,
                       NewCPLInfo->szInfo,
                       sizeof(NewCPLInfo->szInfo)/sizeof(TCHAR));
            lstrcpy(NewCPLInfo->szHelpFile, TEXT(""));
            rc = (LONG)TRUE;
            break;
        }

        case CPL_DBLCLK:
            lParam2 = 0L;
            //
            // Fall through ...
            //
        case CPL_STARTWPARMS:
        {
            HWND hwndMe;

            if (!(gtszTitle[0]))
            {
                LoadString(ghInstance,
                           IDS_TITLE,
                           gtszTitle,
                           sizeof(gtszTitle)/sizeof(TCHAR));
            }
            hwndMe = FindWindow(TEXT("#32770"), gtszTitle);
            if (hwndMe != NULL)
            {
                //
                // We found another copy running, let's just switch focus to it.
                //
                SetForegroundWindow(hwndMe);
            }
            else
            {
                rc = RunApplet(hwnd, (LPTSTR)lParam2);
            }
            break;
        }

        case CPL_STOP:
            break;

        case CPL_EXIT:
#ifdef SYSACC
            if (ghSysAcc != INVALID_HANDLE_VALUE)
            {
                CloseHandle(ghSysAcc);
                ghSysAcc = INVALID_HANDLE_VALUE;
            }
#endif
            TRACETERMINATE();
            break;
    }

    TRACEEXIT(("=%d\n", rc));
    return rc;
}       //CPlApplet

/*++
    @doc    INTERNAL

    @func   VOID | RunApplet |
            The applet has been invoked.

    @parm   IN HHWN | hwnd | Main window handle.
    @parm   IN LPTSTR | CmdLine | Supplies the command line used to
            invoke the applet.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
RunApplet(
    IN HWND hwnd,
    IN LPTSTR CmdLine OPTIONAL
    )
{
    TRACEPROC("RunApplet", 1)
    BOOL rc = FALSE;
    RPC_STATUS status;
    unsigned char *StringBinding;

    TRACEENTER(("(hwnd=%p,CmdLine=%s)\n", hwnd, CmdLine? CmdLine: "NULL"));

    if ((status = RpcStringBindingCompose(NULL,
                                          TEXT("ncalrpc"),
                                          NULL,
                                          NULL,
                                          NULL,
                                          &StringBinding)) != RPC_S_OK)
    {
        ErrorMsg(IDSERR_STRING_BINDING, status);
    }
    else if ((status = RpcBindingFromStringBinding(StringBinding, &ghBinding))
             != RPC_S_OK)
    {
        ErrorMsg(IDSERR_BINDING_HANDLE, status);
    }
    else if ((status = RpcBindingSetAuthInfo(ghBinding,
                                             NULL,
                                             RPC_C_AUTHN_LEVEL_NONE,
                                             RPC_C_AUTHN_WINNT,
                                             NULL,
                                             0)) != RPC_S_OK)
    {
        ErrorMsg(IDSERR_SETAUTHO_INFO, status);
    }
    else
    {
        INITCOMMONCONTROLSEX ComCtrl;
#ifdef SYSACC

        ghSysAcc = CreateFile(SMBLITE_IOCTL_DEVNAME,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

        if (ghSysAcc == INVALID_HANDLE_VALUE)
        {
            ErrorMsg(IDSERR_SYSACC_OPENDEV, GetLastError());
        }

        ghFont = GetStockObject(SYSTEM_FIXED_FONT);
#endif
        ComCtrl.dwSize = sizeof(ComCtrl);
        ComCtrl.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES;
        if (InitCommonControlsEx(&ComCtrl))
        {
            HPROPSHEETPAGE hPages[MAX_PAGES];
            PROPSHEETHEADER psh;

            psh.dwSize = sizeof(psh);
            psh.dwFlags = 0;
            psh.hwndParent = hwnd;
            psh.hInstance = ghInstance;
            psh.pszCaption = MAKEINTRESOURCE(IDS_TITLE);
            psh.phpage = hPages;
            psh.nStartPage = 0;
            psh.nPages = CreatePropertyPages(TabletPCPropPages, hPages);

            if (PropertySheet(&psh) >= 0)
            {
                rc = TRUE;
            }
            else
            {
                ErrorMsg(IDSERR_PROP_SHEET, GetLastError());
            }
        }
        else
        {
            ErrorMsg(IDSERR_COMMCTRL);
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //RunApplet

/*++
    @doc    INTERNAL

    @func   VOID | CreatePropertyPages |
            Create all the property sheet pages according to the property
            page table.

    @parm   IN PTABLETPC_PROPPAGE | TabletPCPages | Points to the property page
            table.
    @parm   OUT HPROPSHEETPAGE * | hPages | Points to the array to hold all
            the created property sheet handles.

    @rvalue Returns number of property page handles created.
--*/

UINT
CreatePropertyPages(
    IN PTABLETPC_PROPPAGE TabletPCPages,
    OUT HPROPSHEETPAGE *hPages
    )
{
    TRACEPROC("CreatePropertyPages", 3)
    UINT nPages = 0;
    PROPSHEETPAGE psp;

    TRACEENTER(("(TabletPCPages=%p,hPages=%p)\n", TabletPCPages, hPages));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = 0;
    psp.hInstance = ghInstance;
    psp.pszTitle = NULL;
    psp.lParam = 0;

    while (TabletPCPages->DlgTemplate != NULL)
    {
        psp.pszTemplate = TabletPCPages->DlgTemplate;
        psp.pfnDlgProc = TabletPCPages->DlgProc;
        TabletPCPages->hPropSheetPage = CreatePropertySheetPage(&psp);
        if (TabletPCPages->hPropSheetPage != NULL)
        {
            hPages[nPages] = TabletPCPages->hPropSheetPage;
            nPages++;
        }
        TabletPCPages++;
    }

    TRACEEXIT(("=%d\n", nPages));
    return nPages;
}       //CreatePropertyPages

/*++
    @doc    INTERNAL

    @func   VOID | InsertComboBoxStrings |
            Insert the strings into the given combo box.

    @parm   IN HWND | hwnd | Dialog handle.
    @parm   IN UINT | ComboBoxID | The ID of the combo box.
    @parm   IN PCOMBOBOX_STRING | ComboString | Points to the combo box
            string table.

    @rvalue None.
--*/

VOID
InsertComboBoxStrings(
    IN HWND             hwnd,
    IN UINT             ComboBoxID,
    IN PCOMBOBOX_STRING ComboString
    )
{
    TRACEPROC("InsertComboBoxStrings", 3)
    TCHAR tszStringText[64];

    TRACEENTER(("(hwnd=%x,ComboBoxID=%x,ComboStringTable=%p)\n",
                hwnd, ComboBoxID, ComboString));

    SendDlgItemMessage(hwnd, ComboBoxID, CB_RESETCONTENT, 0, 0);
    while (ComboString->StringID != 0)
    {
        LoadString(ghInstance,
                   ComboString->StringID,
                   tszStringText,
                   sizeof(tszStringText)/sizeof(TCHAR));
        SendDlgItemMessage(hwnd,
                           ComboBoxID,
                           CB_INSERTSTRING,
                           ComboString->StringIndex,
                           (LPARAM)tszStringText);

        ComboString++;
    }

    TRACEEXIT(("!\n"));
    return;
}       //InsertComboBoxStrings

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | EnableDlgControls | Enable dialog controls.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN int * | piControls | Points to the dialog control array.
 *  @parm   IN BOOL | fEnable | TRUE if enable.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID
EnableDlgControls(
    IN HWND hwnd,
    IN int *piControls,
    IN BOOL fEnable
    )
{
    TRACEPROC("EnableDlgControls", 2)

    TRACEENTER(("(hwnd=%x,piControls=%p,fEnable=%x)\n",
                hwnd, piControls, fEnable));

    while (*piControls != 0)
    {
        EnableWindow(GetDlgItem(hwnd, *piControls), fEnable);
        piControls++;
    }

    TRACEEXIT(("!\n"));
    return;
}       //EnableDlgControls

/*++
    @doc    EXTERNAL

    @func   void __RPC_FAR * | MIDL_user_allocate | MIDL allocate.

    @parm   IN size_t | len | size of allocation.

    @rvalue SUCCESS | Returns the pointer to the memory allocated.
    @rvalue FAILURE | Returns NULL.
--*/

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    IN size_t len
    )
{
    TRACEPROC("MIDL_user_allocate", 5)
    void __RPC_FAR *ptr;

    TRACEENTER(("(len=%d)\n", len));

    ptr = malloc(len);

    TRACEEXIT(("=%p\n", ptr));
    return ptr;
}       //MIDL_user_allocate

/*++
    @doc    EXTERNAL

    @func   void | MIDL_user_free | MIDL free.

    @parm   IN void __PRC_FAR * | ptr | Points to the memory to be freed.

    @rvalue None.
--*/

void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *ptr
    )
{
    TRACEPROC("MIDL_user_free", 5)

    TRACEENTER(("(ptr=%p)\n", ptr));

    free(ptr);

    TRACEEXIT(("!\n"));
    return;
}       //MIDL_user_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tmpinfo.c ===
/*++
    Copyright (c) 2000,2001 Microsoft Corporation

    Module Name:
        tmpinfo.c

    Abstract: SMBus Temperature Sensor Information Property Sheet module.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 25-Jan-2001

    Revision History:
--*/

#include "pch.h"

#ifdef TMPINFO

char gszUnitDegreeC[] = "\xb0" "C";
PSZ gapszTmpStatusNames[] =
{
    "Busy",
    "LocalHiAlarm",
    "LocalLoAlarm",
    "RemoteHiAlarm",
    "RemoteLoAlarm",
    "RemoteOpen"
};
PSZ gapszTmpCfgNames[] =
{
    "Busy",
    "LocalHiAlarm",
    "LocalLoAlarm",
    "RemoteHiAlarm",
    "RemoteLoAlarm",
    "RemoteOpen"
};

SMBCMD_INFO gTmpCmds[] =
{
    TMPCMD_RD_LOCALTMP,          SMB_READ_BYTE, BSN, sizeof(BYTE),
        "        LocalTmp", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_REMOTETMP,         SMB_READ_BYTE, BSN, sizeof(BYTE),
        "       RemoteTmp", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_STATUS,            SMB_READ_BYTE, BBT, sizeof(BYTE),
        "          Status", NULL, 0xfc, gapszTmpStatusNames,
    TMPCMD_RD_CONFIG,            SMB_READ_BYTE, BBT, sizeof(BYTE),
        "          Config", NULL, 0xc0, gapszTmpCfgNames,
    TMPCMD_RD_CONVERSION_RATE,   SMB_READ_BYTE, CNV, sizeof(BYTE),
        "  ConversionRate", NULL, 0, NULL,
    TMPCMD_RD_LOCALTMP_HILIMIT,  SMB_READ_BYTE, BSN, sizeof(BYTE),
        " LocalTmpHiLimit", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_LOCALTMP_LOLIMIT,  SMB_READ_BYTE, BSN, sizeof(BYTE),
        " LocalTmpLoLimit", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_REMOTETMP_HILIMIT, SMB_READ_BYTE, BSN, sizeof(BYTE),
        "RemoteTmpHiLimit", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_REMOTETMP_LOLIMIT, SMB_READ_BYTE, BSN, sizeof(BYTE),
        "RemoteTmpLoLimit", gszUnitDegreeC, 0, NULL,
    TMPCMD_RD_MANUFACTURER_ID,   SMB_READ_BYTE, BHX, sizeof(BYTE),
        "  ManufacturerID", NULL, 0, NULL,
    TMPCMD_RD_DEVICE_ID,         SMB_READ_BYTE, BHX, sizeof(BYTE),
        "        DeviceID", NULL, 0, NULL,
};
#define NUM_TMP_CMDS   (sizeof(gTmpCmds)/sizeof(SMBCMD_INFO))

TMP_INFO gTmpInfo = {0};

/*++
    @doc    EXTERNAL

    @func   INT_PTR | TemperatureDlgProc |
            Dialog procedure for the temperature page.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uMsg | Message.
    @parm   IN WPARAM | wParam | Word Parameter.
    @parm   IN LPARAM | lParam | Long Parameter.

    @rvalue Return value depends on the message.
--*/

INT_PTR APIENTRY
TemperatureDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("TemperatureDlgProc", 2)
    INT_PTR rc = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames) , wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitTemperaturePage(hwnd);
            if (!rc)
            {
                EnableWindow(hwnd, FALSE);
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_QUERYINITIALFOCUS:
                {
                    SetWindowLong(hwnd,
                                  DWL_MSGRESULT,
                                  (LONG)GetDlgItem(hwnd, IDC_TMPINFO_REFRESH));
                    rc = TRUE;
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_TMPINFO_REFRESH:
                    RefreshTmpInfo(GetDlgItem(hwnd, IDC_TMPINFO_TEXT));
                    break;
            }
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //TemperatureDlgProc

/*++
    @doc    INTERNAL

    @func   BOOL | InitTemperaturePage |
            Initialize the temperature sensor property page.

    @parm   IN HWND | hwnd | Window handle.

    @rvalue Always returns TRUE.
--*/

BOOL
InitTemperaturePage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitTemperaturePage", 2)
    HWND hwndEdit;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    hwndEdit = GetDlgItem(hwnd, IDC_TMPINFO_TEXT);
    SendMessage(hwndEdit, WM_SETFONT, (WPARAM)ghFont, MAKELONG(FALSE, 0));

    RefreshTmpInfo(hwndEdit);

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //InitTemperaturePage

/*++
    @doc    INTERNAL

    @func   VOID | RefreshTmpInfo | Refresh termperature information.

    @parm   IN HWND | hwndEdit | Handle to edit control.

    @rvalue None.
--*/

VOID
RefreshTmpInfo(
    IN HWND hwndEdit
    )
{
    TRACEPROC("RefreshTmpInfo", 3)
    int i;
    PBYTE pbBuff;

    TRACEENTER(("(hwndEdit=%x)\n", hwndEdit));

    //
    // Erase edit control.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, -1);
    SendMessage(hwndEdit, EM_REPLACESEL, 0, (LPARAM)"");

    memset(&gTmpInfo, 0, sizeof(gTmpInfo));
    for (i = 0, pbBuff = (PBYTE)&gTmpInfo; i < NUM_TMP_CMDS; ++i)
    {
        if (GetSMBDevInfo(SMB_TMPSENSOR_ADDRESS, &gTmpCmds[i], pbBuff))
        {
            DisplayTmpInfo(hwndEdit, &gTmpCmds[i], pbBuff);
        }
        else
        {
            TRACEWARN(("failed to get temperature info. for %s.\n",
                       gTmpCmds[i].pszLabel));
        }
        pbBuff += gTmpCmds[i].iDataSize;
    }

    //
    // Scroll back to the top.
    //
    SendMessage(hwndEdit, EM_SETSEL, 0, 0);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    TRACEEXIT(("!\n"));
    return;
}       //RefreshTmpInfo

/*++
    @doc    INTERNAL

    @func   BOOL | DisplayTmpInfo | Display temperature info.

    @parm   IN HWND | hwndEdit | Edit window handle.
    @parm   IN PSMBCMD_INFO | TmpCmd | Points to the temperature command.
    @parm   IN PBYTE | pbBuff | Temperature data to display.

    @rvalue SUCCESS | Returns TRUE if it handles it.
    @rvalue FAILURE | Returns FALSE if it doesn't handle it.
--*/

BOOL
DisplayTmpInfo(
    IN HWND         hwndEdit,
    IN PSMBCMD_INFO TmpCmd,
    IN PBYTE        pbBuff
    )
{
    TRACEPROC("DisplayTmpInfo", 3)
    BOOL rc = TRUE;

    TRACEENTER(("(hwndEdit=%x,TmpCmd=%p,Cmd=%s,pbBuff=%p)\n",
                hwndEdit, TmpCmd, TmpCmd->pszLabel, pbBuff));

    EditPrintf(hwndEdit, "%s=", TmpCmd->pszLabel);
    switch (TmpCmd->bType)
    {
        case TYPEF_CONV_RATE:
        {
            static char *RateTable[] =
            {
                "0.0625", "0.125", "0.25", "0.5", "1", "2", "4", "8"
            };

            if (*pbBuff <= 7)
            {
                EditPrintf(hwndEdit, "%6s Hz\r\n", RateTable[*pbBuff]);
            }
            else
            {
                EditPrintf(hwndEdit, "  0x02x\r\n", *pbBuff);
            }
            break;
        }

        default:
            rc = DisplaySMBDevInfo(hwndEdit, TmpCmd, pbBuff);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DisplayTmpInfo

#endif  //ifdef TMPINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tuning.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tuning.c

Abstract: Tablet PC Gesture Tuning Parameters Property Sheet module.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 20-Jul-2000

Revision History:

--*/

#include "pch.h"

#ifdef DEBUG

#define MAX_VALUE               999

DWORD gTuningHelpIDs[] =
{
    0,                          0
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   INT_PTR | TuningDlgProc |
 *          Dialog procedure for the gesture tuning page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *  @parm   IN UINT | uMsg | Message.
 *  @parm   IN WPARAM | wParam | Word Parameter.
 *  @parm   IN LPARAM | lParam | Long Parameter.
 *
 *  @rvalue Return value depends on the message.
 *
 *****************************************************************************/

INT_PTR APIENTRY
TuningDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("TuningDlgProc", 2)
    INT_PTR rc = FALSE;
    static BOOL fInitDone = FALSE;

    TRACEENTER(("(hwnd=%p,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames), wParam, lParam));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            rc = InitTuningPage(hwnd);
            if (rc == FALSE)
            {
                EnableWindow(hwnd, FALSE);
            }
            else
            {
                fInitDone = TRUE;
            }
            break;

        case WM_NOTIFY:
        {
            NMHDR FAR *lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                    RPC_TRY("TabSrvSetGestureFeatures",
                            rc = TabSrvSetGestureSettings(ghBinding,
                                                          &gGestureSettings));
                    if (rc == FALSE)
                    {
                        ErrorMsg(IDSERR_TABSRV_SETGESTURESETTINGS);
                    }

                    rc = TRUE;
                    break;
            }
            break;
        }

        case WM_COMMAND:
        {
            int *piValue;

            switch (LOWORD(wParam))
            {
                case IDC_GESTURE_RADIUS:
                    piValue = &gGestureSettings.iRadius;
                    goto TuningCommon;

                case IDC_GESTURE_MINOUTPTS:
                    piValue = &gGestureSettings.iMinOutPts;
                    goto TuningCommon;

                case IDC_GESTURE_MAXTIMETOINSPECT:
                    piValue = &gGestureSettings.iMaxTimeToInspect;
                    goto TuningCommon;

                case IDC_GESTURE_ASPECTRATIO:
                    piValue = &gGestureSettings.iAspectRatio;
                    goto TuningCommon;

                case IDC_GESTURE_CHECKTIME:
                    piValue = &gGestureSettings.iCheckTime;
                    goto TuningCommon;

                case IDC_GESTURE_PTSTOEXAMINE:
                    piValue = &gGestureSettings.iPointsToExamine;
                    goto TuningCommon;

                case IDC_GESTURE_STOPDIST:
                    piValue = &gGestureSettings.iStopDist;
                    goto TuningCommon;

                case IDC_GESTURE_STOPTIME:
                    piValue = &gGestureSettings.iStopTime;
                    goto TuningCommon;

                case IDC_PRESSHOLD_HOLDTIME:
                    piValue = &gGestureSettings.iPressHoldTime;
                    goto TuningCommon;

                case IDC_PRESSHOLD_TOLERANCE:
                    piValue = &gGestureSettings.iHoldTolerance;
                    goto TuningCommon;

                case IDC_PRESSHOLD_CANCELTIME:
                    piValue = &gGestureSettings.iCancelPressHoldTime;

                TuningCommon:
                    switch (HIWORD(wParam))
                    {
                        case EN_UPDATE:
                        {
                            int n;
                            BOOL fOK;

                            n = GetDlgItemInt(hwnd,
                                              LOWORD(wParam),
                                              &fOK,
                                              FALSE);
                            if (fOK && (n <= MAX_VALUE))
                            {
                                *piValue = n;
                                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                            }
                            else if (fInitDone)
                            {
                                SetDlgItemInt(hwnd,
                                              LOWORD(wParam),
                                              *piValue,
                                              FALSE);
                                SendMessage((HWND)lParam,
                                            EM_SETSEL,
                                            0,
                                            -1);
                                MessageBeep(MB_ICONEXCLAMATION);
                            }
                            break;
                        }
                    }
                    break;
            }
            break;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    TEXT("tabletpc.hlp"),
                    HELP_WM_HELP,
                    (DWORD_PTR)gTuningHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam,
                    TEXT("tabletpc.hlp"),
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)gTuningHelpIDs);
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //GestureDlgProc

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | InitTuningPage |
 *          Initialize the Gesture property page.
 *
 *  @parm   IN HWND | hwnd | Window handle.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOL
InitTuningPage(
    IN HWND hwnd
    )
{
    TRACEPROC("InitTuningPage", 2)
    BOOL rc;

    TRACEENTER(("(hwnd=%x)\n", hwnd));

    RPC_TRY("TabSrvGetGestureSettings",
            rc = TabSrvGetGestureSettings(ghBinding,
                                          &gGestureSettings));
    if (rc == TRUE)
    {
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_RADIUS_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_MINOUTPTS_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_MAXTIMETOINSPECT_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_ASPECTRATIO_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_CHECKTIME_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_PTSTOEXAMINE_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_STOPDIST_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_STOPTIME_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);

        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_RADIUS_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iRadius);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_MINOUTPTS_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iMinOutPts);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_MAXTIMETOINSPECT_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iMaxTimeToInspect);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_ASPECTRATIO_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iAspectRatio);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_CHECKTIME_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iCheckTime);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_PTSTOEXAMINE_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iPointsToExamine);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_STOPDIST_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iStopDist);
        SendDlgItemMessage(hwnd,
                           IDC_GESTURE_STOPTIME_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iStopTime);

        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_HOLDTIME_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_TOLERANCE_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_CANCELTIME_SPIN,
                           UDM_SETRANGE32,
                           0,
                           MAX_VALUE);
        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_HOLDTIME_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iPressHoldTime);
        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_TOLERANCE_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iHoldTolerance);
        SendDlgItemMessage(hwnd,
                           IDC_PRESSHOLD_CANCELTIME_SPIN,
                           UDM_SETPOS32,
                           0,
                           gGestureSettings.iCancelPressHoldTime);
    }
    else
    {
        ErrorMsg(IDSERR_TABSRV_GETGESTURESETTINGS);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitTuningPage

#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\cpl\tmpinfo.h ===
/*++
    Copyright (c) 2000,2001  Microsoft Corporation

    Module Name:
        tmpinfo.h

    Abstract:  Contains SMBus Temperature Sensor Information definitions.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 25-Jan-2001

    Revision History:
--*/

#ifndef _TMPINFO_H
#define _TMPINFO_H

//
// Constants
//
#define SMB_TMPSENSOR_ADDRESS           0x18    //Address on bus (0x30)

// Temperature sensor commands
#define TMPCMD_RD_LOCALTMP              0x00
#define TMPCMD_RD_REMOTETMP             0x01
#define TMPCMD_RD_STATUS                0x02
#define TMPCMD_RD_CONFIG                0x03
#define TMPCMD_RD_CONVERSION_RATE       0x04
#define TMPCMD_RD_LOCALTMP_HILIMIT      0x05
#define TMPCMD_RD_LOCALTMP_LOLIMIT      0x06
#define TMPCMD_RD_REMOTETMP_HILIMIT     0x07
#define TMPCMD_RD_REMOTETMP_LOLIMIT     0x08
#define TMPCMD_WR_CONFIG                0x09
#define TMPCMD_WR_CONVERSION_RATE       0x0a
#define TMPCMD_WR_LOCALTMP_HILIMIT      0x0b
#define TMPCMD_WR_LOCALTMP_LOLIMIT      0x0c
#define TMPCMD_WR_REMOTETMP_HILIMIT     0x0d
#define TMPCMD_WR_REMOTETMP_LOLIMIT     0x0e
#define TMPCMD_ONE_SHOT                 0x0f
#define TMPCMD_WR_SOFTWARE_POR          0xfc
#define TMPCMD_RD_MANUFACTURER_ID       0xfe
#define TMPCMD_RD_DEVICE_ID             0xff

// Status byte bits
#define TMPSTATUS_REMOTE_OPEN           0x04
#define TMPSTATUS_REMOTE_LO_ALARM       0x08
#define TMPSTATUS_REMOTE_HI_ALARM       0x10
#define TMPSTATUS_LOCAL_LO_ALARM        0x20
#define TMPSTATUS_LOCAL_HI_ALARM        0x40
#define TMPSTATUS_BUSY                  0x80

// Config byte bits
#define TMPCFG_STANDBY_MODE             0x40
#define TMPCFG_MASK_ALERT               0x80

#include <pshpack1.h>
typedef struct _TMP_INFO
{
    BYTE bLocalTmp;
    BYTE bRemoteTmp;
    BYTE bStatus;
    BYTE bConfig;
    BYTE bConversionRate;
    BYTE bLocalTmpHiLimit;
    BYTE bLocalTmpLoLimit;
    BYTE bRemoteTmpHiLimit;
    BYTE bRemoteTmpLoLimit;
    BYTE bManufacturerID;
    BYTE bDeviceID;
} TMP_INFO, *PTMP_INFO;
#include <poppack.h>

#define TYPEF_CONV_RATE                 (TYPEF_USER + 0x20)

#define CNV                             TYPEF_CONV_RATE

#endif  //ifndef TMPINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\dt\buttons.h ===
// D:\nt\drivers\wdm\input\hidpen\mutohpen\DT\buttons.h


char ReportDescriptor[32] = {
    0x05, 0x0c,                    // USAGE_PAGE (Consumer Devices)
    0x09, 0x01,                    // USAGE (Consumer Control)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x09, 0x03,                    //   USAGE (Programmable Buttons)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x06,                    //     USAGE_MAXIMUM (Button 6)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x95, 0x06,                    //     REPORT_COUNT (6)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x81, 0x00,                    //     INPUT (Data,Ary,Abs)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\dt\mutoh.h ===
// D:\nt\drivers\wdm\input\tabletpc\DT\mutoh.h


char ReportDescriptor[129] = {
    0x05, 0x0d,                    // USAGE_PAGE (Digitizers)
    0x09, 0x02,                    // USAGE (Pen)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x01,                    //   REPORT_ID (1)
    0x09, 0x20,                    //   USAGE (Stylus)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x09, 0x42,                    //     USAGE (Tip Switch)
    0x09, 0x44,                    //     USAGE (Barrel Switch)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x09, 0x32,                    //     USAGE (In Range)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x26, 0x98, 0x21,              //     LOGICAL_MAXIMUM (8600)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x09, 0x31,                    //     USAGE (Y)
    0x26, 0x50, 0x19,              //     LOGICAL_MAXIMUM (6480)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0xc0,                          //   END_COLLECTION
    0x85, 0x02,                    //   REPORT_ID (2)
    0x05, 0x00,                    //     USAGE_PAGE (Not Defined)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x27, 0xff, 0xff, 0xff, 0x00,  //   LOGICAL_MAXIMUM (16777215)
    0x75, 0x20,                    //   REPORT_SIZE (32)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0xb1, 0x02,                    //   FEATURE (Data,Var,Abs)
    0xc0,                          // END_COLLECTION
    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
    0x09, 0x02,                    // USAGE (Mouse)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x03,                    //   REPORT_ID (3)
    0x09, 0x01,                    //   USAGE (Pointer)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x02,                    //     USAGE_MAXIMUM (Button 2)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x06,                    //     REPORT_COUNT (6)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x09, 0x31,                    //     USAGE (Y)
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\inc\smapi.h ===
#define SMAPI_VERSION            0x00010001  // version 1.1

//
// Flags:
//
// 1st WORD
#define FLAG_NOTSPECIAL          0x0000	     // Not in special mode now
#define FLAG_RGBPROJ_MODE        0x0010      // in RGB Projector mode now ?
#define FLAG_DUALVIEW_MODE       0x0020      // in DualView mode now ?
#define FLAG_DUALAPP_MODE        0x0040      // in DualApp mode now ?
#define FLAG_STRETCH_MODE        0x0080      // in Stretch mode now ?
#define FLAG_ROTATE_MODE         0x0100      // in Rotate mode now ?
#define FLAG_DDRAW_ON            0x0200      // DirectDraw in effect ?
#define FLAG_WIN98_2NDON         0x0400      // 2nd monitor on under Win98
#define FLAG_WIN98_DRV           0x0800      // driver is Win98 native driver
#define FLAG_VIRTUALREFRESH_MODE 0x1000      // in virtual refresh mode now ? 
#define FLAG_IN_DOSFULLSCREEN    0x2000      // in dos full screen mode now ? 
#define FLAG_APP_EXCLUSIVE_DISP  0x4000      // some application exclusive display ?
#define FLAG_LYNXDVM             0x8000      // Is LynxDVM
// 2nd WORD
#define FLAG_NT_ROTATE_SUPPORT   0x0001      // Is rotation support in NT ?
#define FLAG_ROTATE_DIRECTION	 0x0006      // Rotation direction.
#define FLAG_NEW_ROTATE_SUPPORT  0x0008      // New Rotation (QuickRotate(tm)) Support ?

#define DISP2ND_CRT              0           // 2nd display is CRT
#define DISP2ND_TV               1           // 2nd display is TV 

#define TV_NTSC                  0           // TV is NTSC
#define TV_PAL                   1           // TV is PAL
/*
#define TV_NTSC_640x400          0           // TV is NTSC 640 x 400
#define TV_NTSC_640x480          1           // TV is NTSC 640 x 480
#define TV_PAL_640x480           2           // TV is PAL 640 x 480
#define TV_PAL_800x600           3           // TV is PAL 800 x 600
*/

#define LCD_LEFTSIDE             0           // LCD is at left hand side
#define LCD_RIGHTSIDE            1           // LCD is at right hand side

#define DS_LCD                   1           // switch to LCD only
#define DS_CRT                   2           // switch to CRT only
#define DS_TV                    3           // switch to TV only
#define DS_LCDCRT                4           // switch to LCD+CRT
#define DS_LCDTV                 5           // switch to LCD+TV
#define DS_LCD_VR                6           // switch to virtual LCD

#define DA_USEHANDLE             0x00000001  // use window handle for dualapp
#define DA_USEPATH               0x00000002  // use application path for dualapp

#define DV_GRAPHICS              0x00000001  // dualview for graphics
#define DV_VIDEO                 0x00000002  // dualview for video
#define DV_TWO_VIDEO             0x00000003  // dualview for video -- 1.1 --

#define DV_MINCX                 50          // suggestion only!
#define DV_MINCY                 50          // suggestion only!

#define MEM_1M                   1           // 1M video memory
#define MEM_2M                   2           // 2M video memory
#define MEM_4M                   3           // 4M video memory
#define MEM_6M                   4           // 6M video memory

// for rotation -- new for version 1.1
#define RT_CLOCKWISE             1           // clockwise rotation
#define RT_COUNTERCLOCKWISE      2           // counter clockwise rotation
#define RT_180                   3           // rotate 180 degree 

//
// Messages:
//
#define SMAPI_INIT               0x00000001  // initiate SMI API DLL
#define SMAPI_EXIT               0x00000002  // cleanup SMI API DLL
#define SMAPI_DISPLAYCHANGE      0x00000003  // notify SMI API DLL that display changed
#define SMAPI_GETCURDS           0x00000004  // set display settings
#define SMAPI_SETCURDS           0x00000005  // save current display settings
#define SMAPI_GET2NDDISP         0x00000006  // get 2nd display
#define SMAPI_SET2NDDISP         0x00000007  // set 2nd display
#define SMAPI_GETTVTYPE          0x00000008  // get TV type
#define SMAPI_SETTVTYPE          0x00000009  // set TV type
#define SMAPI_GETLCDSIDE         0x0000000a  // get LCD side
#define SMAPI_SETLCDSIDE         0x0000000b  // set LCD side
#define SMAPI_GETDVCRTRES        0x0000000c  // get DualView CRT Res -- new for 1.1
#define SMAPI_SETDVCRTRES        0x0000000d  // set DualView CRT Res -- new for 1.1
#define SMAPI_DV_SWAP2PANEL      0x0000000e  // dv video swap to panel -- new for 1.1
#define TURNOFF_SPECIALMODE      0x0000000f  // turn off special mode
#define SMAPI_SUSPENDRESUME      0x00000010  // suspend or resume

#define DUALAPP_INIT             0x00000011
#define DUALAPP_EXECUTE          0x00000012
#define DUALAPP_SWAPAPP          0x00000013
#define DUALAPP_SWAPDISPLAY      0x00000014
#define DUALAPP_EXIT             0x00000015

#define SMAPI_TVON_COVER         0x00000019     
#define SMAPI_TVOFF_COVER        0x00000020      

#define DUALVIEW_INIT            0x00000021
#define DUALVIEW_CHECKFORMAT     0x00000022
#define DUALVIEW_LOCATEVIDEO     0x00000023
#define DUALVIEW_EXECUTE         0x00000024
#define DUALVIEW_UPDATE          0x00000025
#define DUALVIEW_EXIT            0x00000026
#define DUALVIEW_LOCATE2VIDEO    0x00000027  // -- 1.1 --

#define RGBPROJ_INIT             0x00000031
#define RGBPROJ_EXECUTE          0x00000032
#define RGBPROJ_EXIT             0x00000033

#define STRETCH_INIT             0x00000041
#define STRETCH_EXECUTE          0x00000042
#define STRETCH_EXIT             0x00000043
#define STRETCH_CLEAR            0x00000045

#define ROTATE_INIT              0x00000051  // -- 1.1 --
#define ROTATE_EXECUTE           0x00000052  // -- 1.1 --
#define ROTATE_EXIT              0x00000053  // -- 1.1 --
#define ROTATE_STATUS            0x00000054  // -- 1.1 --
#define ROTATE_STARTUP           0x00000055  // -- 1.1 --
#define ROTATE_NEW				 0x00000056

#define VREFRESH_INIT            0x00000061  // -- 1.1 --
#define VREFRESH_EXECUTE         0x00000062  // -- 1.1 --
#define VREFRESH_EXIT            0x00000063  // -- 1.1 --

#define SMAPI_910_RESET     		0x00000070

//
// Return Values:
//
#define SMAPI_OK                 0x00000000  // API calling is OK
#define SMAPI_ERR_NODRV          0x00000001  // Display driver is not silicon motion's driver
#define SMAPI_ERR_RESET910       0x00000002  // Chip is SM910 for reset
#define SMAPI_ERR_UNKNOWNMSG     0xFFFFFFFF  // unknown API message

#define DS_ERR_LCD               0x00000010  // cannot switch to LCD
#define DS_ERR_CRT               0x00000011  // cannot switch to CRT
#define DS_ERR_TV_INSTRETCHMODE  0x00000012  // cannot switch to TV because in stretch mode
#define DS_ERR_TV_VIDEOON        0x00000013  // cannot switch to TV because hw video on
#define DS_ERR_TV_VIRTUALON      0x00000014  // cannot switch to TV because virtual on 
#define DS_ERR_TV_NOMEMORY       0x00000015  // cannot switch to TV because virtual on 
#define DS_ERR_LCDCRT            0x00000016  // cannot switch to LCD+CRT
#define DS_ERR_LCDTV             0x00000017  // cannot switch to LCD+TV
#define DS_ERR_SETMODE           0x00000018  // unable to set mode
#define DS_ERR_INVALID           0x00000019  // invalid display setting
#define DS_ERR_NOTV              0x00000020  // no TV support
#define DS_ERR_INVALIDDISP       0x00000021  // invalid 2nd display
#define DS_ERR_INVALIDTYPE       0x00000022  // invalid 2nd display type
#define DS_ERR_INVALIDSIDE       0x00000023  // invalid LCD side
#define DS_ERR_NOCRT             0x00000024  // CRT not attached
#define DS_ERR_TV_CLRDEPTH       0x00000025  // cannot turn on TV in 24-bit
#define DS_ERR_2NDMONITORON      0x00000026  // cannot do display switch while 2nd monitor on
#define DS_ERR_LCDTV_RES         0x00000027  // cannot switch to LCD+CRT
#define DS_ERR_TV_NOMS          	0x00000028  // no microvision support
#define DS_ERR_ST_712         	0x00000029  // video on with stretch on

#define DA_ERR_INSTRETCHMODE     0x00000030  // in stretch mode now
#define DA_ERR_INDUALAPPMODE     0x00000031  // in dualapp mode now
#define DA_ERR_INDUALVIEWMODE    0x00000032  // in dualview mode now
#define DA_ERR_INRGBPROJMODE     0x00000033  // in rgbproj mode now
#define DA_ERR_INVIRTUALSCREEN   0x00000034  // in virtual screen mode now
#define DA_ERR_INVIRTUALREFRESH  0x00000035  // in virtual refresh now
#define DA_ERR_VIDEOON           0x00000036  // there is a hardware video on
#define DA_ERR_RESOLUTION        0x00000037  // screen resolution is not match with panel resolution
#define DA_ERR_CLRDEPTH8         0x00000038  // color depth must be set to 8-bit index mode
#define DA_ERR_CLRDEPTH16        0x00000039  // color depth must be set to 16-bit mode
#define DA_ERR_INVALIDSIZE       0x0000003a  // invalid size field
#define DA_ERR_INVALIDFLAG       0x0000003b  // invalid flag     
#define DA_ERR_NOTINDUALAPP      0x0000003c  // not in dualapp mode
#define DA_ERR_NOTWOAPP          0x0000003d  // do not have 2 windows
#define DA_ERR_APPNOTEXIST       0x0000003e  // window not exist
#define DA_ERR_NOTVSWAP          0x0000003f  // cannot swap display when 2nd display is TV
#define DA_ERR_NEED4M            0x00000040  // need 4M of memory to run DualApp
#define DA_ERR_TC_RESTOOBIG      0x00000041  // Dual CRT, resolution too big
#define DA_ERR_INROTATEMODE      0x00000042  // in rotation mode now -- 1.1 --
#define DA_ERR_TWOVIDEO          0x00000043  // not allow 2 hw video -- 1.1 --
#define DA_ERR_VIDEOHIDE         0x00000044  // video is hided -- 1.1 --
#define DA_ERR_ALREADYSET        0x00000045  // already in DualApp Mode
#define DA_ERR_CLRDEPTH          0x00000046  // color depth must be set to 8-bit or 16-bit mode -- 1.1 --
#define DA_ERR_2NDMONITORON      0x00000046  // cannot do dual app while 2nd monitor on

#define DV_ERR_INSTRETCHMODE     DA_ERR_INSTRETCHMODE  
#define DV_ERR_INDUALAPPMODE     DA_ERR_INDUALAPPMODE  
#define DV_ERR_INDUALVIEWMODE    DA_ERR_INDUALVIEWMODE 
#define DV_ERR_INRGBPROJMODE     DA_ERR_INRGBPROJMODE  
#define DV_ERR_INVIRTUALSCREEN   DA_ERR_INVIRTUALSCREEN
#define DV_ERR_INVIRTUALREFRESH  DA_ERR_INVIRTUALREFRESH
#define DV_ERR_INROTATEMODE      DA_ERR_INROTATEMODE     
#define DV_ERR_VIDEOHIDE         DA_ERR_VIDEOHIDE
#define DV_ERR_2NDMONITORON      DA_ERR_2NDMONITORON
#define DV_ERR_CLRDEPTH16        0x00000050  // color depth must be set to 16-bit mode
#define DV_ERR_TWOHWVIDEO        0x00000051  // there are 2 hw videos
#define DV_ERR_RESOLUTION        0x00000052  // screen resolution is not match with panel resolution
#define DV_ERR_LOCATEVIDEO       0x00000053  // cannot locate video window
#define DV_ERR_INVALIDSIZE       0x00000054  // invalid size field
#define DV_ERR_INVALIDFLAG       0x00000055  // invalid flag     
#define DV_ERR_NOTINDUALVIEW     0x00000056  // not in dual view 
#define DV_ERR_INVIDEODV         0x00000057  // in video DualView now, cannot do update
#define DV_ERR_INVALIDRECT       0x00000058  // invalid rectangle, cannot do update
#define DV_ERR_TC_RESTOOBIG      0x00000059  // Dual CRT, resolution too big
#define DV_ERR_CLRDEPTH          0x0000005a  // color depth must be set to 8-bit or 16-bit mode -- 1.1 --
#define DV_ERR_INVALIDPARAM      0x0000005b  // invalid parameter
#define DV_ERR_ALREADYSET        0x0000005c  // already in DualView Mode
#define DV_ERR_FORMAT            0x0000005d  // there is video on after invoke graphics dv
#define DV_ERR_VIDEOON           0x0000005e  // there is video on 
#define DV_ERR_SM712             0x0000005f  // there is video on 

#define RP_ERR_INSTRETCHMODE     DA_ERR_INSTRETCHMODE  
#define RP_ERR_INDUALAPPMODE     DA_ERR_INDUALAPPMODE  
#define RP_ERR_INDUALVIEWMODE    DA_ERR_INDUALVIEWMODE 
#define RP_ERR_INRGBPROJMODE     DA_ERR_INRGBPROJMODE  
#define RP_ERR_INVIRTUALSCREEN   DA_ERR_INVIRTUALSCREEN
#define RP_ERR_INVIRTUALREFRESH  DA_ERR_INVIRTUALREFRESH
#define RP_ERR_INROTATEMODE      DA_ERR_INROTATEMODE     
#define RP_ERR_2NDMONITORON      DA_ERR_2NDMONITORON
#define RP_ERR_RESOLUTION        0x00000060  // screen resolution is > 1024 or < 800                
#define RP_ERR_MEMORY            0x00000061  // not enough memory
#define RP_ERR_BANDWIDTH         0x00000062  // not enough bandwidth
#define RP_ERR_NOTINRGBPROJ      0x00000063  // not in RGB Projector mode
#define RP_ERR_INVALIDCRTRES     0x00000064  // Invalid RGB projector resolution
#define RP_ERR_ALREADYSET        0x00000065  // already in RGB Projector mode

#define ST_ERR_INSTRETCHMODE     DA_ERR_INSTRETCHMODE  
#define ST_ERR_INDUALAPPMODE     DA_ERR_INDUALAPPMODE  
#define ST_ERR_INDUALVIEWMODE    DA_ERR_INDUALVIEWMODE 
#define ST_ERR_INRGBPROJMODE     DA_ERR_INRGBPROJMODE  
#define ST_ERR_INVIRTUALSCREEN   DA_ERR_INVIRTUALSCREEN
#define ST_ERR_INVIRTUALREFRESH  DA_ERR_INVIRTUALREFRESH
#define ST_ERR_INROTATEMODE      DA_ERR_INROTATEMODE     
#define ST_ERR_2NDMONITORON      DA_ERR_2NDMONITORON
#define ST_ERR_VIDEOON           0x00000070  // there is hw video(s)
#define ST_ERR_NOLCD             0x00000071  // LCD is not on
#define ST_ERR_LOWRES            0x00000072  // current resolution is less than 640 x 480
#define ST_ERR_HIGHRES           0x00000073  // current resolution is greater or equal than panel resolution
#define ST_ERR_NOTINSTRETCH      0x00000074  // not in stretch mode
#define ST_ERR_ALREADYSET        0x00000075  // already in stretch Mode

// -- 1.1 -- for rotation mode
#define RT_ERR_INSTRETCHMODE     DA_ERR_INSTRETCHMODE  
#define RT_ERR_INDUALAPPMODE     DA_ERR_INDUALAPPMODE  
#define RT_ERR_INDUALVIEWMODE    DA_ERR_INDUALVIEWMODE 
#define RT_ERR_INRGBPROJMODE     DA_ERR_INRGBPROJMODE  
#define RT_ERR_INVIRTUALSCREEN   DA_ERR_INVIRTUALSCREEN
#define RT_ERR_INVIRTUALREFRESH  DA_ERR_INVIRTUALREFRESH
#define RT_ERR_INROTATEMODE      DA_ERR_INROTATEMODE     
#define RT_ERR_2NDMONITORON      DA_ERR_2NDMONITORON
#define RT_ERR_WRONGHW           0x00000080  // error if SM910
#define RT_ERR_CLRDEPTH          0x00000081  // error if in 24-bit color depth
#define RT_ERR_MEMORY            0x00000082  // not enough memory
#define RT_ERR_SETMODE           0x00000083  // set rotate mode failed
#define RT_ERR_DIRECTION         0x00000084  // error in rotate direction
#define RT_ERR_CAPTUREON         0x00000085  // error in rotate direction
#define RT_ERR_VIDEOON           0x00000086  // video on when rotate 180
#define RT_ERR_DDRAWON           0x00000087  // direct draw in effect
#define RT_ERR_ALREADYSET        0x00000088  // already in rotation Mode

// -- 1.1 -- for virtual refresh mode
#define VR_ERR_INSTRETCHMODE     DA_ERR_INSTRETCHMODE  
#define VR_ERR_INDUALAPPMODE     DA_ERR_INDUALAPPMODE  
#define VR_ERR_INDUALVIEWMODE    DA_ERR_INDUALVIEWMODE 
#define VR_ERR_INRGBPROJMODE     DA_ERR_INRGBPROJMODE  
#define VR_ERR_INVIRTUALSCREEN   DA_ERR_INVIRTUALSCREEN
#define VR_ERR_INROTATEMODE      DA_ERR_INROTATEMODE     
#define VR_ERR_2NDMONITORON      DA_ERR_2NDMONITORON
#define VR_ERR_VIDEOON           0x00000090  // there is hw video(s)
#define VR_ERR_NOTLCDONLY        0x00000091  // not LCD only
#define VR_ERR_MEMORY            0x00000092  // not enough memory
#define VR_ERR_NOTINVREFRESH     0x00000093  // not in virtual refresh mode
#define VR_ERR_ALREADYSET        0x00000094  // already in virtual refresh mode


//
// Structures:
//
typedef struct
{
   BOOL  bWinNT;
   BOOL  bNoTV;
   BOOL  bTwoCRT;
   BOOL  bChronTelTV;                        // -- ver 1.1 --
   int   iMem;
   int   cxPanelRes;
   int   cyPanelRes;
// DWORD dwWinVer1;
   WORD  bCH7005TV; 
   WORD  bNewST;    
// DWORD dwWinVer2;
   WORD  bNewTV;    
   WORD  bNoST;      
   BOOL  bNativeDrv;                         // native windows 98 driver
   BOOL  bNoRT;                              // no rotation mode
   BOOL  bNoDV;                              // no DualView
   BOOL  bNoDA;                              // no DualApp
   WORD  wChipID;                            // -- ver 1.1 --
   WORD  b1024x600Panel;                     // -- ver 1.1 --
   BOOL	bXGANoST24;
   BOOL	wReserved;
} SM_APIINIT;
typedef SM_APIINIT FAR *LPSM_APIINIT;
   
typedef struct
{
   int   iSize;
   DWORD dwFlag;
   HWND  hWnd1;
   HWND  hWnd2;
   char  szApp1[MAX_PATH];
   char  szApp2[MAX_PATH];
} SM_DUALAPP;
typedef SM_DUALAPP FAR *LPSM_DUALAPP;

typedef struct
{
   int   iSize;
   DWORD dwFlag;
   HWND  hWndCaller;
   RECT  rCapRect;
} SM_DUALVIEW;
typedef SM_DUALVIEW FAR *LPSM_DUALVIEW;

typedef struct
{
   int   iSize;
   DWORD dwFlag;
   HWND  hWndVW1;
   HWND  hWndVW2;
} SM_DV2VW;
typedef SM_DV2VW FAR *LPSM_DV2VW;

//
// Function Prototypes:
//
#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY CallSMAPI(DWORD dwMessage, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
DWORD APIENTRY dwRotateStatus();
BOOL  APIENTRY bNoTVSimul();
BOOL  APIENTRY bIsInSpecialMode(WORD wFlag);
int   APIENTRY nIsInSpecialMode();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\inc\wintrace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:
    wintrace.h

Abstract:
    This module contains public definitions of the wintrace debug system.

Author:
    Michael Tsang (MikeTs) 01-May-2000

Environment:
    User mode


Revision History:

--*/

#ifndef _WINTRACE_H
#define _WINTRACE_H

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//
#define MAX_CLIENTNAME_LEN      16
#define MAX_TRACETXT_LEN        256

#define TRACETXT_MSGTYPE_MASK   0x00000003
#define TRACETXT_MSGTYPE_NONE   0x00000000
#define TRACETXT_MSGTYPE_INFO   0x00000001
#define TRACETXT_MSGTYPE_WARN   0x00000002
#define TRACETXT_MSGTYPE_ERROR  0x00000003
#define TRACETXT_BREAK          0x80000000

//
// Macros
//
#ifndef EXPORT
  #define EXPORT                __stdcall
#endif
#ifndef LOCAL
  #define LOCAL                 __stdcall
#endif
#ifdef WINTRACE
  #define TRACEINIT(p,t,v)      TraceInit(p,t,v)
  #define TRACETERMINATE()      TraceTerminate()
  #define TRACEPROC(s,n)        static PSZ ProcName = s;                       \
                                static int ProcLevel = n;
  #define TRACEENTER(p)         {                                              \
                                    if (IsTraceProcOn(ProcName, ProcLevel, TRUE))\
                                    {                                          \
                                        TraceProc p;                           \
                                    }                                          \
                                    giIndentLevel++;                           \
                                    if (gdwfTraceTxt & TRACETXT_BREAK)         \
                                    {                                          \
                                        DebugBreak();                          \
                                    }                                          \
                                }
  #define TRACEEXIT(p)          {                                              \
                                    giIndentLevel--;                           \
                                    if (IsTraceProcOn(ProcName, ProcLevel, FALSE))\
                                    {                                          \
                                        TraceProc p;                           \
                                    }                                          \
                                }
  #define TRACEMSG(t,n,p)       if (IsTraceMsgOn(ProcName, n))                 \
                                {                                              \
                                    gdwfTraceTxt |= (t);                       \
                                    TraceMsg p;                                \
                                }
  #define TRACEINFO(n,p)        TRACEMSG(TRACETXT_MSGTYPE_INFO, n, p)
  #define TRACEWARN(p)          TRACEMSG(TRACETXT_MSGTYPE_WARN, 1, p)
  #define TRACEERROR(p)         TRACEMSG(TRACETXT_MSGTYPE_ERROR, 0, p)
  #define TRACEASSERT(x)        if (!(x))                                      \
                                {                                              \
                                    TRACEERROR(("Assertion failed in file %s " \
                                                "at line %d\n",                \
                                                __FILE__, __LINE__));          \
                                }
#else
  #define TRACEINIT(p,t,v)
  #define TRACETERMINATE()
  #define TRACEPROC(s,n)
  #define TRACEENTER(p)
  #define TRACEEXIT(p)
  #define TRACEMSG(t,n,p)
  #define TRACEINFO(n,p)
  #define TRACEWARN(p)
  #define TRACEERROR(p)
  #define TRACEASSERT(x)
#endif

//
// Type definitions
//
typedef struct _NAMETABLE
{
    ULONG Code;
    PSZ   pszName;
} NAMETABLE, *PNAMETABLE;

//
// Exported Data
//
#ifdef WINTRACE
extern int   giIndentLevel;
extern DWORD gdwfTraceTxt;
extern NAMETABLE WMMsgNames[];
#endif

//
// Exported function prototypes
//
#ifdef WINTRACE
BOOL EXPORT
TraceInit(
    IN PSZ pszClientName,
    IN int iDefTraceLevel,
    IN int iDefVerboseLevel
    );

VOID EXPORT
TraceTerminate(
    VOID
    );

BOOL EXPORT
IsTraceProcOn(
    IN PSZ  pszProcName,
    IN int  iProcLevel,
    IN BOOL fEnter
    );

VOID EXPORT
TraceProc(
    IN PSZ  pszFormat,
    ...
    );

BOOL EXPORT
IsTraceMsgOn(
    IN PSZ pszProcName,
    IN int iVerboseLevel
    );

VOID EXPORT
TraceMsg(
    IN PSZ pszFormat,
    ...
    );

PSZ EXPORT
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    );
#endif

#ifdef __cplusplus
}
#endif

#endif  //ifndef _WINTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:  Contains debug related definitions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

//
// Constants
//

//
// Macros
//
#ifdef DEBUG
  #define TRAP()                DbgBreakPoint()
  #define DBGPRINT(n,x)         if (n <= giVerboseLevel)                    \
                                {                                           \
                                    DbgPrint(MODNAME ": %s: ", ProcName);   \
                                    DbgPrint x;                             \
                                }
  #define WARNPRINT(x)          {                                           \
                                    DbgPrint(MODNAME "_WARN: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                }
  #define ERRPRINT(x)           {                                           \
                                    DbgPrint(MODNAME "_ERR: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                    TRAP();                                 \
                                }
#else
  #define TRAP()
  #define DBGPRINT(n,x)
  #define WARNPRINT(x)
  #define ERRPRINT(x)
#endif  //ifdef DEBUG

//
// Type Definitions
//
typedef struct _NAMETABLE
{
    ULONG Code;
    PSZ   pszName;
} NAMETABLE, *PNAMETABLE;

//
// Exported Data Declarations
//
#ifdef DEBUG
extern NAMETABLE MajorFnNames[];
extern NAMETABLE PnPMinorFnNames[];
extern NAMETABLE PowerMinorFnNames[];
extern NAMETABLE PowerStateNames[];
extern NAMETABLE HidIoctlNames[];
extern NAMETABLE QueryIDTypeNames[];
extern NAMETABLE SerialIoctlNames[];
extern NAMETABLE SerialInternalIoctlNames[];
extern FAST_MUTEX gmutexDevExtList;     //synchronization for access to list
extern LIST_ENTRY glistDevExtHead;      //list of all the device instances
extern int giVerboseLevel;
extern USHORT gwMaxX;
extern USHORT gwMaxY;
extern USHORT gwMaxDX;
extern USHORT gwMaxDY;
extern ULONG gdwcSamples;
extern ULONG gdwcLostBytes;
extern LARGE_INTEGER gStartTime;
#endif

//
// Function prototypes
//
#ifdef DEBUG
PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    );
#endif  //ifdef DEBUG

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\debug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    debug.c

Abstract: This module contains all the debug functions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef DEBUG

NAMETABLE MajorFnNames[] =
{
    IRP_MJ_CREATE,                      "Create",
    IRP_MJ_CREATE_NAMED_PIPE,           "CreateNamedPipe",
    IRP_MJ_CLOSE,                       "Close",
    IRP_MJ_READ,                        "Read",
    IRP_MJ_WRITE,                       "Write",
    IRP_MJ_QUERY_INFORMATION,           "QueryInfo",
    IRP_MJ_SET_INFORMATION,             "SetInfo",
    IRP_MJ_QUERY_EA,                    "QueryEA",
    IRP_MJ_SET_EA,                      "SetEA",
    IRP_MJ_FLUSH_BUFFERS,               "FlushBuffers",
    IRP_MJ_QUERY_VOLUME_INFORMATION,    "QueryVolInfo",
    IRP_MJ_SET_VOLUME_INFORMATION,      "SetVolInfo",
    IRP_MJ_DIRECTORY_CONTROL,           "DirectoryControl",
    IRP_MJ_FILE_SYSTEM_CONTROL,         "FileSystemControl",
    IRP_MJ_DEVICE_CONTROL,              "DeviceControl",
    IRP_MJ_INTERNAL_DEVICE_CONTROL,     "InternalDevControl",
    IRP_MJ_SHUTDOWN,                    "Shutdown",
    IRP_MJ_LOCK_CONTROL,                "LockControl",
    IRP_MJ_CLEANUP,                     "CleanUp",
    IRP_MJ_CREATE_MAILSLOT,             "CreateMailSlot",
    IRP_MJ_QUERY_SECURITY,              "QuerySecurity",
    IRP_MJ_SET_SECURITY,                "SetSecurity",
    IRP_MJ_POWER,                       "Power",
    IRP_MJ_SYSTEM_CONTROL,              "SystemControl",
    IRP_MJ_DEVICE_CHANGE,               "DeviceChange",
    IRP_MJ_QUERY_QUOTA,                 "QueryQuota",
    IRP_MJ_SET_QUOTA,                   "SetQuota",
    IRP_MJ_PNP,                         "PnP",
    0x00,                               NULL
};

NAMETABLE PnPMinorFnNames[] =
{
    IRP_MN_START_DEVICE,                "StartDevice",
    IRP_MN_QUERY_REMOVE_DEVICE,         "QueryRemoveDevice",
    IRP_MN_REMOVE_DEVICE,               "RemoveDevice",
    IRP_MN_CANCEL_REMOVE_DEVICE,        "CancelRemoveDevice",
    IRP_MN_STOP_DEVICE,                 "StopDevice",
    IRP_MN_QUERY_STOP_DEVICE,           "QueryStopDevice",
    IRP_MN_CANCEL_STOP_DEVICE,          "CancelStopDevice",
    IRP_MN_QUERY_DEVICE_RELATIONS,      "QueryDeviceRelations",
    IRP_MN_QUERY_INTERFACE,             "QueryInterface",
    IRP_MN_QUERY_CAPABILITIES,          "QueryCapabilities",
    IRP_MN_QUERY_RESOURCES,             "QueryResources",
    IRP_MN_QUERY_RESOURCE_REQUIREMENTS, "QueryResRequirements",
    IRP_MN_QUERY_DEVICE_TEXT,           "QueryDeviceText",
    IRP_MN_FILTER_RESOURCE_REQUIREMENTS,"FilterResRequirements",
    IRP_MN_READ_CONFIG,                 "ReadConfig",
    IRP_MN_WRITE_CONFIG,                "WriteConfig",
    IRP_MN_EJECT,                       "Eject",
    IRP_MN_SET_LOCK,                    "SetLock",
    IRP_MN_QUERY_ID,                    "QueryID",
    IRP_MN_QUERY_PNP_DEVICE_STATE,      "QueryPNPDeviceState",
    IRP_MN_QUERY_BUS_INFORMATION,       "QueryBusInfo",
    IRP_MN_DEVICE_USAGE_NOTIFICATION,   "DeviceUsageNotify",
    IRP_MN_SURPRISE_REMOVAL,            "SurpriseRemoval",
    0x18,                               "QueryLegacyBusInfo",
    0x00,                               NULL
};

NAMETABLE PowerMinorFnNames[] =
{
    IRP_MN_WAIT_WAKE,                   "WaitWake",
    IRP_MN_POWER_SEQUENCE,              "PowerSequence",
    IRP_MN_SET_POWER,                   "SetPower",
    IRP_MN_QUERY_POWER,                 "QueryPower",
    0x00,                               NULL
};

NAMETABLE PowerStateNames[] =
{
    PowerDeviceUnspecified,             "Unspecified",
    PowerDeviceD0,                      "D0",
    PowerDeviceD1,                      "D1",
    PowerDeviceD2,                      "D2",
    PowerDeviceD3,                      "D3",
    PowerDeviceMaximum,                 "Maximum",
    0x00,                               NULL
};

NAMETABLE HidIoctlNames[] =
{
    IOCTL_HID_GET_DEVICE_DESCRIPTOR,    "GetDeviceDescriptor",
    IOCTL_HID_GET_REPORT_DESCRIPTOR,    "GetReportDescriptor",
    IOCTL_HID_READ_REPORT,              "ReadReport",
    IOCTL_HID_WRITE_REPORT,             "WriteReport",
    IOCTL_HID_GET_STRING,               "GetString",
    IOCTL_HID_ACTIVATE_DEVICE,          "ActivateDevice",
    IOCTL_HID_DEACTIVATE_DEVICE,        "DeactivateDevice",
    IOCTL_HID_GET_DEVICE_ATTRIBUTES,    "GetDeviceAttributes",
    IOCTL_HID_GET_FEATURE,              "GetFeature",
    IOCTL_HID_SET_FEATURE,              "SetFeature",
    0x00,                               NULL
};

NAMETABLE QueryIDTypeNames[] =
{
    BusQueryDeviceID,                   "DeviceID",
    BusQueryHardwareIDs,                "HardwareIDs",
    BusQueryCompatibleIDs,              "CompatibleIDs",
    BusQueryDeviceSerialNumber,         "DeviceSerialNumber",
    0x00,                               NULL
};

NAMETABLE SerialIoctlNames[] =
{
    IOCTL_SERIAL_SET_BAUD_RATE,         "SetBaudRate",
    IOCTL_SERIAL_SET_QUEUE_SIZE,        "SetQueueSize",
    IOCTL_SERIAL_SET_LINE_CONTROL,      "SetLineControl",
    IOCTL_SERIAL_SET_BREAK_ON,          "SetBreakOn",
    IOCTL_SERIAL_SET_BREAK_OFF,         "SetBreakOff",
    IOCTL_SERIAL_IMMEDIATE_CHAR,        "ImmediateChar",
    IOCTL_SERIAL_SET_TIMEOUTS,          "SetTimeouts",
    IOCTL_SERIAL_GET_TIMEOUTS,          "GetTimeouts",
    IOCTL_SERIAL_SET_DTR,               "SetDTR",
    IOCTL_SERIAL_CLR_DTR,               "ClrDTR",
    IOCTL_SERIAL_RESET_DEVICE,          "ResetDevice",
    IOCTL_SERIAL_SET_RTS,               "SetRTS",
    IOCTL_SERIAL_CLR_RTS,               "ClrRTS",
    IOCTL_SERIAL_SET_XOFF,              "SetXOFF",
    IOCTL_SERIAL_SET_XON,               "SetXON",
    IOCTL_SERIAL_GET_WAIT_MASK,         "GetWaitMask",
    IOCTL_SERIAL_SET_WAIT_MASK,         "SetWaitMask",
    IOCTL_SERIAL_WAIT_ON_MASK,          "WaitOnMask",
    IOCTL_SERIAL_PURGE,                 "Purge",
    IOCTL_SERIAL_GET_BAUD_RATE,         "GetBaudRate",
    IOCTL_SERIAL_GET_LINE_CONTROL,      "GetLineControl",
    IOCTL_SERIAL_GET_CHARS,             "GetChars",
    IOCTL_SERIAL_SET_CHARS,             "SetChars",
    IOCTL_SERIAL_GET_HANDFLOW,          "GetHandFlow",
    IOCTL_SERIAL_SET_HANDFLOW,          "SetHandFlow",
    IOCTL_SERIAL_GET_MODEMSTATUS,       "GetModemStatus",
    IOCTL_SERIAL_GET_COMMSTATUS,        "GetCommStatus",
    IOCTL_SERIAL_XOFF_COUNTER,          "XOFFCounter",
    IOCTL_SERIAL_GET_PROPERTIES,        "GetProperties",
    IOCTL_SERIAL_GET_DTRRTS,            "GetDTRRTS",
    IOCTL_SERIAL_LSRMST_INSERT,         "LSRMSTInsert",
    IOCTL_SERIAL_CONFIG_SIZE,           "ConfigSize",
    IOCTL_SERIAL_GET_COMMCONFIG,        "GetCommConfig",
    IOCTL_SERIAL_SET_COMMCONFIG,        "SetCommConfig",
    IOCTL_SERIAL_GET_STATS,             "GetStats",
    IOCTL_SERIAL_CLEAR_STATS,           "ClearStats",
    IOCTL_SERIAL_GET_MODEM_CONTROL,     "GetModemControl",
    IOCTL_SERIAL_SET_MODEM_CONTROL,     "SetModemControl",
    IOCTL_SERIAL_SET_FIFO_CONTROL,      "SetFIFOControl",
    0x00,                               NULL
};

NAMETABLE SerialInternalIoctlNames[] =
{
    IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE, "DoWaitWake",
    IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE,"CancelWaitWake",
    IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS,"BasicSettings",
    IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS,"RestoreSettings",
    0x00,                               NULL
};

FAST_MUTEX gmutexDevExtList = {0};      //synchronization for access to list
LIST_ENTRY glistDevExtHead = {0};       //list of all the device instances
int giVerboseLevel = 0;
USHORT gwMaxX = 0;
USHORT gwMaxY = 0;
USHORT gwMaxDX = 0;
USHORT gwMaxDY = 0;
ULONG gdwcSamples = 0;
ULONG gdwcLostBytes = 0;
LARGE_INTEGER gStartTime = {0};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSZ | LookupName |
 *
 *          Look up name string of a code in the given name table.
 *
 *  @parm   IN ULONG | Code |
 *
 *          The given code to lookup.
 *
 *  @parm   IN PNAMETABLE | NameTable |
 *
 *          The name table to look into.
 *
 *  @rvalue SUCCESS - Returns pointer to the minor function name string.
 *  @rvalue FAILURE - Returns "unknown".
 *
 *****************************************************************************/

PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    )
{
    PROCNAME("LookupName")
    PSZ pszName = "unknown";

    ENTER(5, ("(Code=%x,pNameTable=%p)\n", Code, NameTable));

    ASSERT(NameTable != NULL);
    while (NameTable->pszName != NULL)
    {
        if (Code == NameTable->Code)
        {
            pszName = NameTable->pszName;
            break;
        }
        NameTable++;
    }

    EXIT(5, ("=%s\n", pszName));
    return pszName;
}       //LookupName

#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\inc\smblite.h ===
/*++
    Copyright (c) 2000,2001  Microsoft Corporation

    Module Name:
        smblite.h

    Abstract:  Contains SMBus Back Light IOCTL definitions.

    Environment:
        User/Kernel mode

    Author:
        Michael Tsang (MikeTs) 11-Jan-2001

    Revision History:
--*/

#ifndef _SMBLITE_H
#define _SMBLITE_H

//
// Constants
//
#define BRIGHTNESS_MIN                  0
#define BRIGHTNESS_MAX                  63
#define SMBLITE_IOCTL_DEVNAME           TEXT("\\\\.\\SMBusBackLight")

#define IOCTL_SMBLITE_GETBRIGHTNESS     CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 0,                     \
                                                 METHOD_NEITHER,        \
                                                 FILE_ANY_ACCESS)
#define IOCTL_SMBLITE_SETBRIGHTNESS     CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 1,                     \
                                                 METHOD_NEITHER,        \
                                                 FILE_ANY_ACCESS)

typedef struct _SMBLITE_BRIGHTNESS
{
    UCHAR  bACValue;                    //Brightness value when on AC
    UCHAR  bDCValue;                    //Brightness value when on DC
} SMBLITE_BRIGHTNESS, *PSMBLITE_BRIGHTNESS;

typedef struct _SMBLITE_SETBRIGHTNESS
{
    SMBLITE_BRIGHTNESS Brightness;
    BOOLEAN            fSaveSettings;
} SMBLITE_SETBRIGHTNESS, *PSMBLITE_SETBRIGHTNESS;

#ifdef SYSACC

#define IOCTL_SYSACC_MEM_REQUEST        CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 1000,                  \
                                                 METHOD_NEITHER,        \
                                                 FILE_ANY_ACCESS)
#define IOCTL_SYSACC_IO_REQUEST         CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 1001,                  \
                                                 METHOD_NEITHER,        \
                                                 FILE_ANY_ACCESS)
#define IOCTL_SYSACC_PCICFG_REQUEST     CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 1002,                  \
                                                 METHOD_NEITHER,        \
                                                 FILE_ANY_ACCESS)
#define IOCTL_SYSACC_SMBUS_REQUEST      CTL_CODE(FILE_DEVICE_UNKNOWN,   \
                                                 1003,                  \
                                                 METHOD_BUFFERED,       \
                                                 FILE_ANY_ACCESS)

#endif

#endif  //ifndef _SMBLITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\hidpen.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hidpen.c

Abstract: Serial Pen Tablet HID Driver.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(INIT, DriverEntry)
  #pragma alloc_text(PAGE, HpenCreateClose)
  #pragma alloc_text(PAGE, HpenAddDevice)
  #pragma alloc_text(PAGE, HpenUnload)
#endif  //ifdef ALLOC_PRAGMA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | DriverEntry |
 *          Installable driver initialization entry point.
 *          <nl>This entry point is called directly by the I/O system.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *  @parm   IN PUNICODE_STRINT | RegPath | Points to the registry path.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    )
{
    PROCNAME("DriverEntry")
    NTSTATUS status = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION hidMinidriverRegistration;

    ENTER(1, ("(DrvObj=%p,RegPath=%p)\n", DrvObj, RegPath));

    DrvObj->MajorFunction[IRP_MJ_CREATE] =
    DrvObj->MajorFunction[IRP_MJ_CLOSE] = HpenCreateClose;

    DrvObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HpenInternalIoctl;

    DrvObj->MajorFunction[IRP_MJ_PNP]   = HpenPnp;
    DrvObj->MajorFunction[IRP_MJ_POWER] = HpenPower;
    DrvObj->DriverUnload                = HpenUnload;
    DrvObj->DriverExtension->AddDevice  = HpenAddDevice;

    //
    // Register with HIDCLASS.SYS module
    //
    RtlZeroMemory(&hidMinidriverRegistration,
                  sizeof(hidMinidriverRegistration));

    hidMinidriverRegistration.Revision            = HID_REVISION;
    hidMinidriverRegistration.DriverObject        = DrvObj;
    hidMinidriverRegistration.RegistryPath        = RegPath;
    hidMinidriverRegistration.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
    hidMinidriverRegistration.DevicesArePolled    = FALSE;

    status = HidRegisterMinidriver(&hidMinidriverRegistration);

    if (NT_SUCCESS(status))
    {
      #ifdef DEBUG
        ExInitializeFastMutex(&gmutexDevExtList);
        InitializeListHead(&glistDevExtHead);
      #endif
    }
    else
    {
        ERRPRINT(("failed to register mini driver (status=%x)\n", status));
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //DriverEntry

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HpenCreateClose |
 *          Process the create and close IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue STATUS_SUCCESS | success
 *  @rvalue STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HpenCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HpenCreateClose")
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER(DevObj);
    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpStack=%p,Major=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MajorFunction, MajorFnNames)));

    switch(irpsp->MajorFunction)
    {
        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            Irp->IoStatus.Information = 0;
            break;

        default:
            ERRPRINT(("invalid major function %s\n",
                      LookupName(irpsp->MajorFunction, MajorFnNames)));
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    EXIT(1, ("=%x\n", status));
    return status;
}       //HpenCreateClose

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HpenAddDevice |
 *          Called by hidclass, allows us to initialize our device extensions.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *  @parm   IN PDEVICE_OBJECT | DevObj |
 *          Points to a functional device object created by hidclass.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS.
 *  @rvalue FAILURE | Returns NT status code.
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HpenAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    )
{
    PROCNAME("HpenAddDevice")
    NTSTATUS status;
    PDEVICE_EXTENSION devext;

    PAGED_CODE ();

    ENTER(1, ("(DrvObj=%p,DevObj=%p)\n", DrvObj, DevObj));

    ASSERT(DevObj != NULL);
    UNREFERENCED_PARAMETER(DrvObj);

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    RtlZeroMemory(devext, sizeof(*devext));
    devext->pdo = GET_PDO(DevObj);
    devext->SerialDevObj = GET_NEXT_DEVICE_OBJECT(DevObj);
    devext->ReadWorkItem[0].WorkItem = IoAllocateWorkItem(DevObj);
    if (devext->ReadWorkItem[0].WorkItem != NULL)
    {
        devext->ReadWorkItem[1].WorkItem = IoAllocateWorkItem(DevObj);
        if (devext->ReadWorkItem[1].WorkItem != NULL)
        {
            IoInitializeRemoveLock(&devext->RemoveLock, HPEN_POOL_TAG, 0, 10);
            KeInitializeSpinLock(&devext->SpinLock);
            devext->PowerState = PowerDeviceD0;
          #ifdef DEBUG
            ExAcquireFastMutex(&gmutexDevExtList);
            InsertTailList(&glistDevExtHead, &devext->List);
            ExReleaseFastMutex(&gmutexDevExtList);
          #endif
            OemAddDevice(devext);
            DevObj->Flags &= ~DO_DEVICE_INITIALIZING;
            DevObj->Flags |= DO_POWER_PAGABLE;
            status = STATUS_SUCCESS;
        }
        else
        {
            ERRPRINT(("failed to allocate second read work item\n"));
            IoFreeWorkItem(devext->ReadWorkItem[0].WorkItem);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ERRPRINT(("failed to allocate first read work item\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HpenAddDevice

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | HpenUnload | Free all the allocated resources, etc.
 *
 *  @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
 *
 *****************************************************************************/

VOID EXTERNAL
HpenUnload(
    IN PDRIVER_OBJECT DrvObj
    )
{
    PROCNAME("HpenUnload")

    PAGED_CODE();

    ENTER(1, ("(DrvObj=%p)\n", DrvObj));

    ASSERT(DrvObj->DeviceObject == NULL);
    UNREFERENCED_PARAMETER(DrvObj);

    EXIT(1, ("!\n"));
    return;
}       //HpenUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\hidpen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hidpen.h

Abstract:  Contains definitions of all constants and data types for the
           serial pen hid driver.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _HIDPEN_H
#define _HIDPEN_H

//
// Constants
//
#define HPEN_POOL_TAG           'nepH'

// dwfHPen flag values
#define HPENF_DEVICE_STARTED    0x00000001
#define HPENF_DEVICE_REMOVED    0x00000002
#define HPENF_SERIAL_OPENED     0x00000004
#define HPENF_TABLET_STANDBY    0x00000008

// Serial Port FIFO Control Register bits for Receiver Trigger Level
#define SERIAL_IOC_FCR_RCVR_TRIGGER_01_BYTE     0
#define SERIAL_IOC_FCR_RCVR_TRIGGER_04_BYTES    SERIAL_IOC_FCR_RCVR_TRIGGER_LSB
#define SERIAL_IOC_FCR_RCVR_TRIGGER_08_BYTES    SERIAL_IOC_FCR_RCVR_TRIGGER_MSB
#define SERIAL_IOC_FCR_RCVR_TRIGGER_14_BYTES    (SERIAL_IOC_FCR_RCVR_TRIGGER_LSB |\
                                                 SERIAL_IOC_FCR_RCVR_TRIGGER_MSB)

//
// Macros
//
#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) \
    ((PDEVICE_EXTENSION)(((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

#define GET_PDO(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->PhysicalDeviceObject)

//
// Type Definitions
//
typedef struct _READ_WORKITEM
{
    PIO_WORKITEM      WorkItem;
    PIRP              Irp;
    PHID_INPUT_REPORT HidReport;
    ULONG             WorkItemBit;
} READ_WORKITEM, *PREAD_WORKITEM;

typedef struct _DEVICE_EXTENSION
{
  #ifdef DEBUG
    LIST_ENTRY            List;         //list of of other tablet devices
  #endif
    ULONG                 dwfHPen;      //flags
    PDEVICE_OBJECT        pdo;          //pdo of the pen device
    PDEVICE_OBJECT        SerialDevObj; //points to the serial device object
    IO_REMOVE_LOCK        RemoveLock;   //to protect IRP_MN_REMOVE_DEVICE
    DEVICE_POWER_STATE    PowerState;   //power state of the tablet
    SERIAL_BASIC_SETTINGS PrevSerialSettings;
    KSPIN_LOCK            SpinLock;     //to protect the resync buffer
    OEM_INPUT_REPORT      ResyncData[2];//resync data buffer
    ULONG                 BytesInBuff;  //number of bytes in the resync buffer
    READ_WORKITEM         ReadWorkItem[2];//one for each pending ReadReport
    ULONG                 QueuedWorkItems;//bit mask for queued work items
    OEM_DATA              OemData;      //OEM specific data
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define QUEUED_WORKITEM_0       0x00000001
#define QUEUED_WORKITEM_1       0x00000002
#define QUEUED_WORKITEM_ALL     (QUEUED_WORKITEM_0 | QUEUE_WORKITEM_1)

//
// Global Data Declarations
//

//
// Function prototypes
//

// hidpen.c
NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    );

NTSTATUS EXTERNAL
HpenCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
HpenAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    );

VOID EXTERNAL
HpenUnload(
    IN PDRIVER_OBJECT DrvObj
    );

// pnp.c
NTSTATUS EXTERNAL
HpenPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
HpenPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
InitDevice(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

VOID INTERNAL
RemoveDevice(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    );

NTSTATUS INTERNAL
SendSyncIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN BOOLEAN        fCopyToNext
    );

NTSTATUS INTERNAL
IrpCompletion(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PKEVENT        Event
    );

// ioctl.c
NTSTATUS EXTERNAL
HpenInternalIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
GetDeviceDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
GetReportDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
ReadReport(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
GetString(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    );

NTSTATUS INTERNAL
GetAttributes(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    );

NTSTATUS INTERNAL
ReadReportCompletion(
    IN PDEVICE_OBJECT    DevObj,
    IN PIRP              Irp,
    IN PHID_INPUT_REPORT HidReport
    );

// serial.c
NTSTATUS INTERNAL
SerialSyncSendIoctl(
    IN ULONG          IoctlCode,
    IN PDEVICE_OBJECT DevObj,
    IN PVOID          InBuffer OPTIONAL,
    IN ULONG          InBufferLen,
    OUT PVOID         OutBuffer OPTIONAL,
    IN ULONG          OutBufferLen,
    IN BOOLEAN        fInternal,
    OUT PIO_STATUS_BLOCK Iosb
    );

NTSTATUS INTERNAL
SerialAsyncReadWritePort(
    IN BOOLEAN                fRead,
    IN PDEVICE_EXTENSION      DevExt,
    IN PIRP                   Irp,
    IN PUCHAR                 Buffer,
    IN ULONG                  BuffLen,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID                  Context
    );

NTSTATUS INTERNAL
SerialSyncReadWritePort(
    IN BOOLEAN           fRead,
    IN PDEVICE_EXTENSION DevExt,
    IN PUCHAR            Buffer,
    IN ULONG             BuffLen,
    IN PLARGE_INTEGER    Timeout OPTIONAL,
    OUT PULONG           BytesAccessed OPTIONAL
    );

// oempen.c
NTSTATUS EXTERNAL
OemAddDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemInitSerialPort(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemInitDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemQueryDeviceInfo(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemRemoveDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemWakeupDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemStandbyDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS INTERNAL
OemProcessResyncBuffer(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS INTERNAL
OemProcessInputData(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp,
    IN PHID_INPUT_REPORT HidReport
    );

BOOLEAN INTERNAL
OemIsResyncDataValid(
    IN PDEVICE_EXTENSION DevExt
    );

VOID INTERNAL
OemReadMoreBytes(
    IN PDEVICE_OBJECT DevObj,
    IN PREAD_WORKITEM ReadWorkItem
    );

NTSTATUS INTERNAL
OemNormalizeInputData(
    IN     PDEVICE_EXTENSION DevExt,
    IN OUT POEM_INPUT_REPORT InData
    );

NTSTATUS INTERNAL
OemGetFeatures(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
OemSetFeatures(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
OemSetTabletFeatures(
    IN PDEVICE_EXTENSION DevExt,
    IN ULONG             dwTabletFeatures
    );

NTSTATUS INTERNAL
RegQueryDeviceParam(
    IN PDEVICE_OBJECT pdo,
    IN PWSTR          pwstrParamName,
    OUT PVOID         pbBuff,
    IN ULONG          dwcbLen
    );

NTSTATUS INTERNAL
RegSetDeviceParam(
    IN PDEVICE_OBJECT pdo,
    IN PWSTR          pwstrParamName,
    IN ULONG          dwType,
    IN PVOID          pbBuff,
    IN ULONG          dwcbLen
    );
#endif  //ifndef _HIDPEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\trace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module contains definitions of the trace functions

Author:
    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode


Revision History:


--*/

#ifndef _TRACE_H
#define _TRACE_H

//
// Constants
//
#define TF_CHECKING_TRACE       0x00000001

//
// Macros
//
#ifdef TRACING
  #ifndef PROCNAME
    #define PROCNAME(s) static PSZ ProcName = s;
  #endif
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                            ++giTraceIndent;                            \
                        }
  #define EXIT(n,p)     {                                               \
                            --giTraceIndent;                            \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                        }
#else
  #define PROCNAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif

//
// Exported function prototypes
//
#ifdef TRACING
//
// Exported data
//
extern int giTraceIndent;
extern ULONG gdwfTrace;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    );
#endif

#endif  //ifndef _TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\pch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:  Pre-compile C header file.


Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "HPEN"
#define INTERNAL
#define EXTERNAL

#if DBG
  #define DEBUG
  #define TRACING
#endif

#include <wdm.h>
#include <ntddser.h>
#include <hidport.h>
#include "oempen.h"
#include "hidpen.h"
#include "debug.h"
#include "trace.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\oempen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    oempen.h

Abstract:  Contains OEM specific definitions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _OEMPEN_H
#define _OEMPEN_H

//
// Constants
//
#define OEM_VENDOR_ID           0x3429          //"MAI"
#define STR_TABLET_FEATURES     L"TabletFeatures"

// OEM serial communication parameters
#define OEM_SERIAL_BAUDRATE     19200
#define OEM_SERIAL_WORDLEN      8
#define OEM_SERIAL_PARITY       NO_PARITY
#define OEM_SERIAL_STOPBITS     STOP_BIT_1

#define OEM_PEN_REPORT_ID       1
#define OEM_FEATURE_REPORT_ID   2
#define OEM_MOUSE_REPORT_ID     3
#define OEM_PEN_MAX_X           8600
#define OEM_PEN_MAX_Y           6480
#define OEM_THRESHOLD_DX        500
#define OEM_THRESHOLD_DY        500
#define OEM_MIN_RATE_DIVISOR    0
#define OEM_MAX_RATE_DIVISOR    9

#define NORMALIZE_DATA(w)       ((USHORT)((((w) & 0x7f00) >> 1) |           \
                                          ((w) & 0x007f)))
#define OemIsValidPacket(p)     (((p)->InputReport.bStatus & INSTATUS_SYNC) && \
                                 !((p)->InputReport.bStatus &                  \
                                   (INSTATUS_RESERVED1 | INSTATUS_RESERVED2 |  \
                                    INSTATUS_TEST_DATA)) &&                    \
                                 !((p)->InputReport.wXData & INDATA_SYNC) &&   \
                                 !((p)->InputReport.wYData & INDATA_SYNC))

typedef struct _OEM_DATA
{
    ULONG  dwTabletFeatures;
    ULONG  dwThresholdPeriod;
    USHORT wFirmwareDate;
    USHORT wFirmwareYear;
    USHORT wProductID;
    USHORT wFirmwareRev;
    USHORT wCorrectionRev;
} OEM_DATA, *POEM_DATA;

//
// This must match with hardware, so make sure it is byte aligned.
//
#include <pshpack1.h>
typedef struct _OEM_INPUT_REPORT
{
    union
    {
        struct
        {
            UCHAR  bStatus;
            USHORT wXData;
            USHORT wYData;
        } InputReport;
        UCHAR RawInput[5];
    };
} OEM_INPUT_REPORT, *POEM_INPUT_REPORT;

typedef struct _HID_INPUT_REPORT
{
    UCHAR            ReportID;
    OEM_INPUT_REPORT Report;
} HID_INPUT_REPORT, *PHID_INPUT_REPORT;

// bStatus bit values
#define INSTATUS_PEN_TIP_DOWN           0x01
#define INSTATUS_SIDE_SW_ENABLED        0x02
#define INSTATUS_RESERVED1              0x04
#define INSTATUS_TEST_DATA              0x08
#define INSTATUS_RESERVED2              0x10
#define INSTATUS_IN_PROXIMITY           0x20
#define INSTATUS_SW_CHANGED             0x40
#define INSTATUS_SYNC                   0x80
#define INDATA_SYNC                     0x8080

typedef struct _OEM_FEATURE_REPORT
{
    ULONG dwTabletFeatures;
} OEM_FEATURE_REPORT, *POEM_FEATURE_REPORT;

#define OEM_FEATURE_RATE_MASK           0x0000000f
#define OEM_FEATURE_DIGITAL_FILTER_ON   0x00000010
#define OEM_FEATURE_GLITCH_FILTER_ON    0x00000020
#define OEM_FEATURE_UNUSED_BITS         0xffffffc0

typedef struct _HID_FEATURE_REPORT
{
    UCHAR              ReportID;
    OEM_FEATURE_REPORT Report;
} HID_FEATURE_REPORT, *PHID_FEATURE_REPORT;
#include <poppack.h>

//
// Global Data Declarations
//
extern UCHAR gReportDescriptor[130];
extern HID_DESCRIPTOR gHidDescriptor;
extern PWSTR gpwstrManufacturerID;
extern PWSTR gpwstrProductID;
extern PWSTR gpwstrSerialNumber;
extern OEM_INPUT_REPORT gLastReport;
extern USHORT gwDXThreshold;
extern USHORT gwDYThreshold;

#endif  //ifndef _OEMPEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\ioctl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Contains routines to support HIDCLASS internal
          ioctl queries for the pen tablet devices.

Environment:

    Kernel mode

Author:
    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, GetDeviceDescriptor)
  #pragma alloc_text(PAGE, GetReportDescriptor)
  #pragma alloc_text(PAGE, GetString)
  #pragma alloc_text(PAGE, GetAttributes)
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HpenInternalIoctl |
 *          Process the Control IRPs sent to this device.
 *          <nl>This function cannot be pageable because reads/writes
 *          can be made at dispatch-level
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HpenInternalIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("HpenInternalIoctl")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Ioctl=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                         HidIoctlNames)));

    Irp->IoStatus.Information = 0;
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        ERRPRINT(("received PnP IRP after device was removed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        BOOLEAN fNeedCompletion = TRUE;

        ASSERT(devext->dwfHPen & HPENF_DEVICE_STARTED);
        switch(irpsp->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
                status = GetDeviceDescriptor(DevObj, Irp);
                break;

            case IOCTL_HID_GET_REPORT_DESCRIPTOR:
                status = GetReportDescriptor(DevObj, Irp);
                break;

            case IOCTL_HID_READ_REPORT:
                status = ReadReport(DevObj, Irp);
                fNeedCompletion = FALSE;
                break;

            case IOCTL_HID_GET_FEATURE:
                status = OemGetFeatures(DevObj, Irp);
                break;

            case IOCTL_HID_SET_FEATURE:
                status = OemSetFeatures(DevObj, Irp);
                break;

            case IOCTL_HID_GET_STRING:
                status = GetString(DevObj, Irp);
                break;

            case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
                status = GetAttributes(DevObj, Irp);
                break;

            case IOCTL_HID_ACTIVATE_DEVICE:
            case IOCTL_HID_DEACTIVATE_DEVICE:
                status = STATUS_SUCCESS;
                break;

            default:
                WARNPRINT(("unsupported ioctl code (ioctl=%s)\n",
                           LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                                      HidIoctlNames)));
                status = Irp->IoStatus.Status;
                break;
        }

        if (status != STATUS_PENDING)
        {
            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
            if (fNeedCompletion)
            {
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
        }
        else
        {
            IoMarkIrpPending(Irp);
        }
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HpenInternalIoctl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetDeviceDescriptor |
 *          Respond to HIDCLASS IOCTL_HID_GET_DEVICE_DESCRIPTOR
 *          by returning a device descriptor.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns STATUS_BUFFER_TOO_SMALL - need more memory
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetDeviceDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("GetDeviceDescriptor")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(gHidDescriptor))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer,
                      &gHidDescriptor,
                      sizeof(gHidDescriptor));

        Irp->IoStatus.Information = sizeof(gHidDescriptor);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetDeviceDescriptor

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetReportDescriptor |
 *          Respond to HIDCLASS IOCTL_HID_GET_REPORT_DESCRIPTOR
 *          by returning appropriate the report descriptor.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetReportDescriptor(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("GetReportDescriptor")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(gReportDescriptor))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer,
                      gReportDescriptor,
                      sizeof(gReportDescriptor));

        Irp->IoStatus.Information = sizeof(gReportDescriptor);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetReportDescriptor

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | ReadReport |
 *          Read input report.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
ReadReport(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("ReadReport")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;
    ULONG DataLen;

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    ASSERT(Irp->UserBuffer != NULL);
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    DataLen = irpsp->Parameters.DeviceIoControl.OutputBufferLength;

    if (DataLen != sizeof(HID_INPUT_REPORT))
    {
        ERRPRINT(("invalid input report size (bufflen=%d)\n", DataLen));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (!(devext->dwfHPen & HPENF_DEVICE_STARTED))
    {
        ERRPRINT(("device not started yet\n"));
        status = STATUS_DEVICE_NOT_READY ;
    }
    else
    {
        PHID_INPUT_REPORT HidReport = (PHID_INPUT_REPORT)Irp->UserBuffer;
        KIRQL OldIrql;

        KeAcquireSpinLock(&devext->SpinLock, &OldIrql);
        status = OemProcessResyncBuffer(devext, Irp);
        KeReleaseSpinLock(&devext->SpinLock, OldIrql);

        if (!NT_SUCCESS(status))
        {
            //
            // If we don't have enough bytes in the resync buffer or the packet
            // in the resync buffer is invalid, send an IRP down to read some
            // more.
            //
            status = SerialAsyncReadWritePort(TRUE,
                                              devext,
                                              Irp,
                                              HidReport->Report.RawInput,
                                              sizeof(OEM_INPUT_REPORT),
                                              ReadReportCompletion,
                                              HidReport);
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //ReadReport

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetString |
 *          Respond to IOCTL_HID_GET_STRING.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetString(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    )
{
    PROCNAME("GetString")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PWSTR pwstrID;
    ULONG lenID;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p,StringID=%x)\n",
              DevObj, Irp, irpsp,
              (ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer));

    switch ((ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer &
            0xffff)
    {
        case HID_STRING_ID_IMANUFACTURER:
            pwstrID = gpwstrManufacturerID;
            break;

        case HID_STRING_ID_IPRODUCT:
            pwstrID = gpwstrProductID;
            break;

        case HID_STRING_ID_ISERIALNUMBER:
            pwstrID = gpwstrSerialNumber;
            break;

        default:
            pwstrID = NULL;
            break;
    }

    lenID = pwstrID? wcslen(pwstrID)*sizeof(WCHAR) + sizeof(UNICODE_NULL): 0;
    if (pwstrID == NULL)
    {
        ERRPRINT(("invalid string ID (ID=%x)\n",
                  (ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer));
        status = STATUS_INVALID_PARAMETER;
    }
    else if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < lenID)
    {
        ERRPRINT(("output buffer too small (bufflen=%d,need=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength, lenID));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        RtlCopyMemory(Irp->UserBuffer, pwstrID, lenID);

        Irp->IoStatus.Information = lenID;
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x (string=%S)\n", status, pwstrID? pwstrID: L"Null"));
    return status;
}       //GetString

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | GetAttributes |
 *          Respond to IOCTL_HID_GET_ATTRIBUTES, by filling
 *          the HID_DEVICE_ATTRIBUTES struct.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
GetAttributes(
    PDEVICE_OBJECT DevObj,
    PIRP           Irp
    )
{
    PROCNAME("GetAttributes")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(HID_DEVICE_ATTRIBUTES))
    {
        ERRPRINT(("output buffer too small (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        PDEVICE_EXTENSION devext;
        PHID_DEVICE_ATTRIBUTES DevAttrib;

        devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
        DevAttrib = (PHID_DEVICE_ATTRIBUTES)Irp->UserBuffer;

        DevAttrib->Size = sizeof(HID_DEVICE_ATTRIBUTES);
        DevAttrib->VendorID = OEM_VENDOR_ID;
        DevAttrib->ProductID = devext->OemData.wProductID;
        DevAttrib->VersionNumber = devext->OemData.wFirmwareRev;

        Irp->IoStatus.Information = sizeof(HID_DEVICE_ATTRIBUTES);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //GetAttributes

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | ReadReportCompletion | Completion routine for ReadReport.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *  @parm   IN PHID_INPUT_REPORT | HidReport | Points to input data packet.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS
 *  @rvalue FAILURE | Returns STATUS_MORE_PROCESSING_REQUIRED
 *
 *****************************************************************************/

NTSTATUS INTERNAL
ReadReportCompletion(
    IN PDEVICE_OBJECT    DevObj,
    IN PIRP              Irp,
    IN PHID_INPUT_REPORT HidReport
    )
{
    PROCNAME("ReadReportCompletion")
    NTSTATUS status = Irp->IoStatus.Status;
    PDEVICE_EXTENSION devext;

    ENTER(2, ("(DevObj=%p,Irp=%p,HidReport=%p,Status=%x)\n",
              DevObj, Irp, HidReport, status));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    if (status == STATUS_CANCELLED)
    {
        WARNPRINT(("ReadReport IRP was cancelled\n"));
        status = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(status))
    {
        ERRPRINT(("failed to read input data packet (status=%x)\n", status));
        status = STATUS_SUCCESS;
    }
    else
    {
        status = OemProcessInputData(devext, Irp, HidReport);
    }

    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    if (status != STATUS_MORE_PROCESSING_REQUIRED)
    {
        IoReleaseRemoveLock(&devext->RemoveLock, Irp);
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //ReadReportCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\oempen.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oempen.c

Abstract: Contains OEM specific functions.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, OemAddDevice)
  #pragma alloc_text(PAGE, OemInitSerialPort)
  #pragma alloc_text(PAGE, OemInitDevice)
  #pragma alloc_text(PAGE, OemQueryDeviceInfo)
  #pragma alloc_text(PAGE, OemRemoveDevice)
  #pragma alloc_text(PAGE, OemWakeupDevice)
  #pragma alloc_text(PAGE, OemStandbyDevice)
  #pragma alloc_text(PAGE, OemReadMoreBytes)
  #pragma alloc_text(PAGE, OemGetFeatures)
  #pragma alloc_text(PAGE, OemSetFeatures)
  #pragma alloc_text(PAGE, OemSetTabletFeatures)
  #pragma alloc_text(PAGE, RegQueryDeviceParam)
  #pragma alloc_text(PAGE, RegSetDeviceParam)
#endif  //ifdef ALLOC_PRAGMA

UCHAR gReportDescriptor[130] = {
    0x05, 0x0d,                    // USAGE_PAGE (Digitizers)
    0x09, 0x02,                    // USAGE (Pen)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x01,                    //   REPORT_ID (1)
    0x09, 0x20,                    //   USAGE (Stylus)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x09, 0x42,                    //     USAGE (Tip Switch)
    0x09, 0x44,                    //     USAGE (Barrel Switch)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x09, 0x32,                    //     USAGE (In Range)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x26, 0x98, 0x21,              //     LOGICAL_MAXIMUM (8600)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x09, 0x31,                    //     USAGE (Y)
    0x26, 0x50, 0x19,              //     LOGICAL_MAXIMUM (6480)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0xc0,                          //   END_COLLECTION
    //
    // Feature report
    //
    0x85, 0x02,                    //   REPORT_ID (2)
    0x06, 0x00, 0xff,              //   USAGE_PAGE (Vendor Defined)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x27, 0xff, 0xff, 0xff, 0xff,  //   LOGICAL_MAXIMUM (0xffffffff)
    0x75, 0x20,                    //   REPORT_SIZE (32)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0xb1, 0x02,                    //   FEATURE (Data,Var,Abs)
    0xc0,                          // END_COLLECTION
    //
    // Dummy mouse collection starts here
    //
    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
    0x09, 0x02,                    // USAGE (Mouse)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x03,                    //   REPORT_ID (3)
    0x09, 0x01,                    //   USAGE (Pointer)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x02,                    //     USAGE_MAXIMUM (Button 2)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x06,                    //     REPORT_COUNT (6)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x09, 0x31,                    //     USAGE (Y)
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};

HID_DESCRIPTOR gHidDescriptor =
{
    sizeof(HID_DESCRIPTOR),             //bLength
    HID_HID_DESCRIPTOR_TYPE,            //bDescriptorType
    HID_REVISION,                       //bcdHID
    0,                                  //bCountry - not localized
    1,                                  //bNumDescriptors
    {                                   //DescriptorList[0]
        HID_REPORT_DESCRIPTOR_TYPE,     //bReportType
        sizeof(gReportDescriptor)       //wReportLength
    }
};

PWSTR gpwstrManufacturerID = L"Mutoh";
PWSTR gpwstrProductID = L"Serial Pen Tablet (3310)";
PWSTR gpwstrSerialNumber = L"0";
OEM_INPUT_REPORT gLastReport = {0};
LARGE_INTEGER gLastReportTime = {0};
USHORT gwDXThreshold = OEM_THRESHOLD_DX;
USHORT gwDYThreshold = OEM_THRESHOLD_DY;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemAddDevice |
 *          OEM specific AddDevice code.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue STATUS_SUCCESS | success
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemAddDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemAddDevice")
    NTSTATUS status;
    UCHAR bConversionRate;

    PAGED_CODE ();
    ENTER(2, ("(DevExt=%p)\n", DevExt));

    status = RegQueryDeviceParam(DevExt->pdo,
                                 STR_TABLET_FEATURES,
                                 &DevExt->OemData.dwTabletFeatures,
                                 sizeof(DevExt->OemData.dwTabletFeatures));

    if (!NT_SUCCESS(status))
    {
        //
        // Registry doesn't have this parameter, default to maximum conversion
        // rate, digital filter on.
        //
        DevExt->OemData.dwTabletFeatures = 1 |
                                           OEM_FEATURE_DIGITAL_FILTER_ON;
        status = STATUS_SUCCESS;
    }

    bConversionRate = (UCHAR)(DevExt->OemData.dwTabletFeatures &
                              OEM_FEATURE_RATE_MASK);
    if (bConversionRate != 0)
    {
        //
        // At sampling rate of 133.3, the sampling period is 7.5msec.
        // We set the threshold period 10 times of the sampling period.
        // ThresholdPeriod = 75000*10*ConversionRate (in units of 100nsec)
        //
        DevExt->OemData.dwThresholdPeriod = 75000*10*bConversionRate;
    }
    else
    {
        //
        // Conversion rate of 0 means 100 samples per second which
        // means sampling interval is 10msec.
        // ThresholdPeriod = 100000*10 (in units of 100nsec)
        //
        DevExt->OemData.dwThresholdPeriod = 1000000;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemAddDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemInitSerialPort |
 *          Initialize com port for communication.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemInitSerialPort(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemInitSerialPort")
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    //
    // Set the com port to basic operating mode: reads/writes one byte at
    // time, no handshake flow control or timeouts.
    //
    status = SerialSyncSendIoctl(IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS,
                                 DevExt->SerialDevObj,
                                 NULL,
                                 0,
                                 &DevExt->PrevSerialSettings,
                                 sizeof(DevExt->PrevSerialSettings),
                                 TRUE,
                                 &iosb);

    if (!NT_SUCCESS(status))
    {
        ERRPRINT(("failed to set com to basic settings (status=%x)\n", status));
    }
    else
    {
        SERIAL_BAUD_RATE sbr;

        sbr.BaudRate = OEM_SERIAL_BAUDRATE;
        status = SerialSyncSendIoctl(IOCTL_SERIAL_SET_BAUD_RATE,
                                     DevExt->SerialDevObj,
                                     &sbr,
                                     sizeof(sbr),
                                     NULL,
                                     0,
                                     FALSE,
                                     &iosb);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed to set com port to 19200 baud (status=%x)\n",
                      status));
        }
        else
        {
            SERIAL_LINE_CONTROL slc;

            slc.WordLength = OEM_SERIAL_WORDLEN;
            slc.Parity = OEM_SERIAL_PARITY;
            slc.StopBits = OEM_SERIAL_STOPBITS;
            status = SerialSyncSendIoctl(IOCTL_SERIAL_SET_LINE_CONTROL,
                                         DevExt->SerialDevObj,
                                         &slc,
                                         sizeof(slc),
                                         NULL,
                                         0,
                                         FALSE,
                                         &iosb);

            if (!NT_SUCCESS(status))
            {
                ERRPRINT(("failed to set com line control (status=%x)\n",
                          status));
            }
            else
            {
                //
                // Enable FIFO receive trigger at 4 bytes
                //
                ULONG Data = SERIAL_IOC_FCR_FIFO_ENABLE |
                             SERIAL_IOC_FCR_RCVR_RESET |
                             SERIAL_IOC_FCR_XMIT_RESET |
                             SERIAL_IOC_FCR_RCVR_TRIGGER_04_BYTES;

                status = SerialSyncSendIoctl(IOCTL_SERIAL_SET_FIFO_CONTROL,
                                             DevExt->SerialDevObj,
                                             &Data,
                                             sizeof(Data),
                                             NULL,
                                             0,
                                             FALSE,
                                             &iosb);

                if (!NT_SUCCESS(status))
                {
                    ERRPRINT(("failed to set FIFO control (status=%x)\n",
                              status));
                }
                else
                {
                    Data = SERIAL_PURGE_RXCLEAR;
                    status = SerialSyncSendIoctl(IOCTL_SERIAL_PURGE,
                                                 DevExt->SerialDevObj,
                                                 &Data,
                                                 sizeof(Data),
                                                 NULL,
                                                 0,
                                                 FALSE,
                                                 &iosb);

                    if (!NT_SUCCESS(status))
                    {
                        ERRPRINT(("failed to flush receive buffer (status=%x)\n",
                                  status));
                    }
                }
            }
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemInitSerialPort

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemInitDevice |
 *          Initialize pen tablet device.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemInitDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemInitDevice")
    NTSTATUS status;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    status = SerialSyncReadWritePort(FALSE, DevExt, "@", 1, NULL, NULL);
    if (!NT_SUCCESS(status))
    {
        ERRPRINT(("failed to send reset command to tablet (status=%x)\n",
                  status));
    }
    else
    {
        LONGLONG WaitTime = Int32x32To64(100, -10000);

        //
        // We need to delay 20msec after a software reset is sent.
        //
        KeDelayExecutionThread(KernelMode,
                               FALSE,
                               (LARGE_INTEGER *)&WaitTime);

        status = OemSetTabletFeatures(DevExt, DevExt->OemData.dwTabletFeatures);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed to set default tablet features (status=%x,features=%x)\n",
                      status, DevExt->OemData.dwTabletFeatures));
        }
        else if (!NT_SUCCESS(status = SerialSyncReadWritePort(
                                        FALSE, DevExt, "LO", 2, NULL, NULL)))
        {
            ERRPRINT(("failed to set default tablet configuration (status=%x)\n",
                      status));
        }
        else
        {
            status = OemQueryDeviceInfo(DevExt);
            if (!NT_SUCCESS(status))
            {
                //
                // It's not a big deal if we don't get the device info.
                // It's more important to keep the driver running.
                //
                status = STATUS_SUCCESS;
            }
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemInitDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemQueryDeviceInfo |
 *          Query pen tablet device information.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemQueryDeviceInfo(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemQueryDeviceInfo")
    NTSTATUS status, status2;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    status = SerialSyncReadWritePort(FALSE, DevExt, "K", 1, NULL, NULL);
    if (NT_SUCCESS(status))
    {
        LARGE_INTEGER Timeout;
        OEM_INPUT_REPORT InData[3];
        ULONG BytesRead;

        // Set timeout to 100 msec.
        Timeout.QuadPart = Int32x32To64(100, -10000);
        while ((status = SerialSyncReadWritePort(TRUE,
                                                 DevExt,
                                                 (PUCHAR)InData,
                                                 1,
                                                 &Timeout,
                                                 &BytesRead)) ==
                STATUS_SUCCESS)
        {
            if (InData[0].InputReport.bStatus == 0x88)
            {
                break;
            }
        }

        if (NT_SUCCESS(status))
        {
            status = SerialSyncReadWritePort(TRUE,
                                             DevExt,
                                             ((PUCHAR)InData) + 1,
                                             sizeof(InData) - 1,
                                             &Timeout,
                                             &BytesRead);
            if (NT_SUCCESS(status))
            {
                if ((BytesRead == sizeof(InData) - 1) &&
                    (InData[0].InputReport.bStatus == 0x88) &&
                    (InData[1].InputReport.bStatus == 0x88) &&
                    (InData[2].InputReport.bStatus == 0x8f))
                {
                    DevExt->OemData.wFirmwareDate =
                                NORMALIZE_DATA(InData[0].InputReport.wXData);
                    DevExt->OemData.wFirmwareYear =
                                NORMALIZE_DATA(InData[0].InputReport.wYData);
                    DevExt->OemData.wProductID =
                                NORMALIZE_DATA(InData[1].InputReport.wXData);
                    DevExt->OemData.wFirmwareRev =
                                NORMALIZE_DATA(InData[1].InputReport.wYData);
                    DevExt->OemData.wCorrectionRev =
                                NORMALIZE_DATA(InData[2].InputReport.wXData);
                    DBGPRINT(1, ("FirmwareDate=%d,FirmwareYear=%d,ProductID=%d,FirmwareRev=%d,CorrectionRev=%d\n",
                                 DevExt->OemData.wFirmwareDate,
                                 DevExt->OemData.wFirmwareYear,
                                 DevExt->OemData.wProductID,
                                 DevExt->OemData.wFirmwareRev,
                                 DevExt->OemData.wCorrectionRev));
                }
                else
                {
                    ERRPRINT(("invalid response of status command (size=%d,InData=%p)\n",
                              BytesRead, InData));
                    status = STATUS_DEVICE_DATA_ERROR;
                }
            }
            else
            {
                ERRPRINT(("failed to read response packet (status=%x)\n",
                          status));
            }
        }
        else
        {
            ERRPRINT(("failed to read first byte of the response (status=%x)\n",
                      status));
        }
    }
    else
    {
        ERRPRINT(("failed to send status command (status=%x)\n", status));
    }

    status2 = SerialSyncReadWritePort(FALSE,
                                      DevExt,
                                      "A",
                                      1,
                                      NULL,
                                      NULL);
    if (!NT_SUCCESS(status2))
    {
        ERRPRINT(("failed to send acknowledge command to tablet (status=%x)\n",
                  status2));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemQueryDeviceInfo

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemRemoveDevice |
 *          OEM specific cleanups.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemRemoveDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemRemoveDevice")
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    status = SerialSyncSendIoctl(IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS,
                                 DevExt->SerialDevObj,
                                 &DevExt->PrevSerialSettings,
                                 sizeof(DevExt->PrevSerialSettings),
                                 NULL,
                                 0,
                                 TRUE,
                                 &iosb);
    if (!NT_SUCCESS(status))
    {
        ERRPRINT(("failed to restore serial port settings (status=%x)\n",
                  status));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemRemoveDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemWakeupDevice |
 *          OEM specific wake up code.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemWakeupDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemWakeupDevice")
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    if (DevExt->dwfHPen & HPENF_DEVICE_STARTED)
    {
        status = SerialSyncReadWritePort(FALSE, DevExt, "A", 1, NULL, NULL);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed to send acknowledge command to the tablet (status=%x)\n",
                      status));
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemWakeupDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemStandbyDevice |
 *          OEM specific wake up code.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemStandbyDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemStandbyDevice")
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    if (DevExt->dwfHPen & HPENF_DEVICE_STARTED)
    {
        status = SerialSyncReadWritePort(FALSE, DevExt, "W", 1, NULL, NULL);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed to send standby command to the tablet (status=%x)\n",
                      status));
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemStandbyDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemProcessResyncBuffer |
 *          Process input data from the resync buffer.
 *          Note that this function must be called at IRQL==DISPATCH_LEVEL
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS.
 *  @rvalue FAILURE | Returns STATUS_MORE_PROCESSING_REQUIRED
 *                    (We want the IRP back).
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemProcessResyncBuffer(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    PROCNAME("OemProcessResyncBuffer")
    NTSTATUS status = STATUS_DATA_ERROR;
    PHID_INPUT_REPORT HidReport = (PHID_INPUT_REPORT)Irp->UserBuffer;

    ENTER(2, ("(DevExt=%p,Irp=%p,Len=%d,status=%x,xData=%x,yData=%x)\n",
              DevExt, Irp, DevExt->BytesInBuff,
              DevExt->ResyncData[0].InputReport.bStatus,
              DevExt->ResyncData[0].InputReport.wXData,
              DevExt->ResyncData[0].InputReport.wYData));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    while (DevExt->BytesInBuff >= sizeof(OEM_INPUT_REPORT))
    {
        if (OemIsResyncDataValid(DevExt))
        {
            status = OemNormalizeInputData(DevExt, &DevExt->ResyncData[0]);
            if (NT_SUCCESS(status))
            {
                HidReport->ReportID = OEM_PEN_REPORT_ID;
                RtlCopyMemory(HidReport->Report.RawInput,
                              &DevExt->ResyncData[0],
                              sizeof(OEM_INPUT_REPORT));
                Irp->IoStatus.Information = sizeof(HID_INPUT_REPORT);
            }

            DevExt->BytesInBuff -= sizeof(OEM_INPUT_REPORT);
            if (DevExt->BytesInBuff > 0)
            {
                RtlMoveMemory(&DevExt->ResyncData[0],
                              &DevExt->ResyncData[1],
                              DevExt->BytesInBuff);
            }

            if (NT_SUCCESS(status))
            {
                break;
            }
        }
    }

    EXIT(2, ("=%x (status=%x,xData=%x,yData=%x)\n",
             status,
             HidReport->Report.InputReport.bStatus,
             HidReport->Report.InputReport.wXData,
             HidReport->Report.InputReport.wYData));
    return status;
}       //OemProcessResyncBuffer

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemProcessInputData |
 *          OEM specific code to process input data.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *  @parm   IN PHID_INPUT_REPORT | HidReport | Points to hid report packet.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS.
 *  @rvalue FAILURE | Returns STATUS_MORE_PROCESSING_REQUIRED
 *                    (We want the IRP back).
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemProcessInputData(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp,
    IN PHID_INPUT_REPORT HidReport
    )
{
    PROCNAME("OemProcessInputData")
    NTSTATUS status;
    KIRQL OldIrql;

    ENTER(2, ("(DevExt=%p,Irp=%p,HidReport=%p,Len=%d,status=%x,xData=%x,yData=%x)\n",
              DevExt, Irp, HidReport, Irp->IoStatus.Information,
              HidReport->Report.InputReport.bStatus,
              HidReport->Report.InputReport.wXData,
              HidReport->Report.InputReport.wYData));

    KeAcquireSpinLock(&DevExt->SpinLock, &OldIrql);
    if ((DevExt->BytesInBuff == 0) &&
        (Irp->IoStatus.Information == sizeof(OEM_INPUT_REPORT)) &&
        OemIsValidPacket(&HidReport->Report))
    {
        status = OemNormalizeInputData(DevExt, &HidReport->Report);
        if (NT_SUCCESS(status))
        {
            HidReport->ReportID = OEM_PEN_REPORT_ID;
            Irp->IoStatus.Information = sizeof(HID_INPUT_REPORT);
        }
    }
    else
    {
        //
        // Either resync buffer already has something in it or packet is
        // partial or invalid, so append data to resync buffer and process
        // it again.
        //
        RtlMoveMemory((PUCHAR)&DevExt->ResyncData[0] + DevExt->BytesInBuff,
                      &HidReport->Report,
                      Irp->IoStatus.Information);
        DevExt->BytesInBuff += (ULONG)Irp->IoStatus.Information;
        ASSERT(DevExt->BytesInBuff <= sizeof(DevExt->ResyncData));
        status = OemProcessResyncBuffer(DevExt, Irp);
    }

    if (!NT_SUCCESS(status))
    {
        PREAD_WORKITEM ReadWorkItem;

        //
        // No valid data packet, send another IRP down to read more.
        //
        if (!(DevExt->QueuedWorkItems & QUEUED_WORKITEM_0))
        {
            ReadWorkItem = &DevExt->ReadWorkItem[0];
            ReadWorkItem->WorkItemBit = QUEUED_WORKITEM_0;
        }
        else
        {
            ASSERT(!(DevExt->QueuedWorkItems & QUEUED_WORKITEM_1));
            DBGPRINT(3, ("Queue second work item!\n"));
            ReadWorkItem = &DevExt->ReadWorkItem[1];
            ReadWorkItem->WorkItemBit = QUEUED_WORKITEM_1;
        }

        status = IoAcquireRemoveLock(&DevExt->RemoveLock, Irp);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("trying to queue a work item after device was removed\n"));
        }
        else
        {
            DevExt->QueuedWorkItems |= ReadWorkItem->WorkItemBit;
            ReadWorkItem->Irp = Irp;
            ReadWorkItem->HidReport = HidReport;
            IoQueueWorkItem(ReadWorkItem->WorkItem,
                            OemReadMoreBytes,
                            DelayedWorkQueue,
                            ReadWorkItem);

            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    KeReleaseSpinLock(&DevExt->SpinLock, OldIrql);

    EXIT(2, ("=%x (status=%x,xData=%x,yData=%x)\n",
             status,
             HidReport->Report.InputReport.bStatus,
             HidReport->Report.InputReport.wXData,
             HidReport->Report.InputReport.wYData));
    return status;
}       //OemProcessInputData

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemReadMoreBytes |
 *          Read more bytes to resync packet.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PREAD_WORKITEM | ReadWorkItem | Points to the read work item.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue None.
 *
 *****************************************************************************/

VOID INTERNAL
OemReadMoreBytes(
    IN PDEVICE_OBJECT DevObj,
    IN PREAD_WORKITEM ReadWorkItem
    )
{
    PROCNAME("OemReadMoreBytes")
    PDEVICE_EXTENSION devext;
    ULONG BytesToRead;
    KIRQL OldIrql;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,ReadWorkItem=%p)\n", DevObj, ReadWorkItem));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    KeAcquireSpinLock(&devext->SpinLock, &OldIrql);
    ASSERT(devext->QueuedWorkItems & ReadWorkItem->WorkItemBit);
    devext->QueuedWorkItems &= ~ReadWorkItem->WorkItemBit;
    IoReleaseRemoveLock(&devext->RemoveLock, ReadWorkItem->Irp);
    BytesToRead = sizeof(OEM_INPUT_REPORT) -
                  devext->BytesInBuff%sizeof(OEM_INPUT_REPORT);
    KeReleaseSpinLock(&devext->SpinLock, OldIrql);

    DBGPRINT(3, ("Read %d more bytes (WorkItemBit=%x)\n",
                 BytesToRead, ReadWorkItem->WorkItemBit));
    SerialAsyncReadWritePort(TRUE,
                             devext,
                             ReadWorkItem->Irp,
                             ReadWorkItem->HidReport->Report.RawInput,
                             BytesToRead,
                             ReadReportCompletion,
                             ReadWorkItem->HidReport);

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    EXIT(2, ("!\n"));
    return;
}       //OemReadMoreBytes

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOLEAN | OemIsResyncDataValid |
 *          Check if the data in the resync buffer is valid.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *
 *  @rvalue SUCCESS | Returns TRUE.
 *  @rvalue FAILURE | Returns FALSE.
 *
 *****************************************************************************/

BOOLEAN INTERNAL
OemIsResyncDataValid(
    IN PDEVICE_EXTENSION DevExt
    )
{
    PROCNAME("OemIsResyncDataValid")
    BOOLEAN rc;

    ENTER(2, ("(DevExt=%p)\n", DevExt));

    rc = OemIsValidPacket(&DevExt->ResyncData[0]);
    if ((rc == FALSE) || (DevExt->BytesInBuff > sizeof(OEM_INPUT_REPORT)))
    {
        PUCHAR pb = (PUCHAR)&DevExt->ResyncData[0] + DevExt->BytesInBuff - 1;
        PUCHAR pbEnd = rc? (PUCHAR)&DevExt->ResyncData[1]:
                           (PUCHAR)&DevExt->ResyncData[0];

        //
        // Even if we seem to have a valid packet in the resync buffer, we
        // still need to scan the next packet if any.  If the next packet
        // has a sync bit out of place, the first packet could still be
        // invalid and we better throw it away.
        //
        while (pb > pbEnd)
        {
            if (*pb & INSTATUS_SYNC)
            {
                DBGPRINT(3,
                         ("invalid buffer (len=%d,status0=%x,xData0=%x,yData0=%x,status1=%x,xData1=%x,yData1=%x)\n",
                          DevExt->BytesInBuff,
                          DevExt->ResyncData[0].InputReport.bStatus,
                          DevExt->ResyncData[0].InputReport.wXData,
                          DevExt->ResyncData[0].InputReport.wYData,
                          DevExt->ResyncData[1].InputReport.bStatus,
                          DevExt->ResyncData[1].InputReport.wXData,
                          DevExt->ResyncData[1].InputReport.wYData));
                DevExt->BytesInBuff = (ULONG)((PUCHAR)&DevExt->ResyncData[0] +
                                              DevExt->BytesInBuff - pb);
                RtlMoveMemory(&DevExt->ResyncData[0], pb, DevExt->BytesInBuff);
                DBGPRINT(3,
                         ("Resync'd buffer (len=%d,status=%x,xData=%x,yData=%x)\n",
                          DevExt->BytesInBuff,
                          DevExt->ResyncData[0].InputReport.bStatus,
                          DevExt->ResyncData[0].InputReport.wXData,
                          DevExt->ResyncData[0].InputReport.wYData));
              #ifdef DEBUG
                {
                    ULONG dwcDeletedBytes = (ULONG)(pb -
                                                    (PUCHAR)&DevExt->ResyncData[0]);

                    gdwcLostBytes +=
                        (dwcDeletedBytes > sizeof(OEM_INPUT_REPORT))?
                                sizeof(OEM_INPUT_REPORT)*2 - dwcDeletedBytes:
                                sizeof(OEM_INPUT_REPORT) - dwcDeletedBytes;
                }
              #endif
                rc = FALSE;
                break;
            }
            --pb;
        }

        if ((rc == FALSE) && (pb <= pbEnd))
        {
            //
            // We didn't have a valid packet and we couldn't find the sync
            // bit of the next packet, so the whole resync buffer is invalid.
            //
            DevExt->BytesInBuff = 0;
        }
    }

    EXIT(2, ("=%x\n", rc));
    return rc;
}       //OemIsResyncDataValid

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemNormalizeInputData |
 *          Normalize the input data.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN OUT POEM_INPUT_REPORT | InData | Points to the input data packet.
 *
 *  @rvalue SUCCESS | Returns STATUS_SUCCESS.
 *  @rvalue FAILURE | Returns STATUS_DATA_ERROR.
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemNormalizeInputData(
    IN     PDEVICE_EXTENSION DevExt,
    IN OUT POEM_INPUT_REPORT InData
    )
{
    PROCNAME("OemNormalizeInputData")
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER CurrentTime;

    ENTER(2, ("(DevExt=%p,InData=%p,Status=%x,XData=%x,YData=%x)\n",
              DevExt, InData, InData->InputReport.bStatus,
              InData->InputReport.wXData, InData->InputReport.wYData));

    InData->InputReport.wXData = NORMALIZE_DATA(InData->InputReport.wXData);
    InData->InputReport.wYData = NORMALIZE_DATA(InData->InputReport.wYData);
    if (InData->InputReport.wXData >= OEM_PEN_MAX_X)
    {
      #ifdef DEBUG
        if (InData->InputReport.wXData > gwMaxX)
        {
            gwMaxX = InData->InputReport.wXData;
        }
      #endif
        InData->InputReport.wXData = OEM_PEN_MAX_X - 1;
    }

    if (InData->InputReport.wYData >= OEM_PEN_MAX_Y)
    {
      #ifdef DEBUG
        if (InData->InputReport.wYData > gwMaxY)
        {
            gwMaxY = InData->InputReport.wYData;
        }
      #endif
        InData->InputReport.wYData = 0;
    }
    else
    {
        InData->InputReport.wYData = OEM_PEN_MAX_Y - 1 -
                                     InData->InputReport.wYData;
    }
    KeQuerySystemTime(&CurrentTime);

  #ifdef DEBUG
    if ((gLastReport.InputReport.bStatus ^ InData->InputReport.bStatus) &
        INSTATUS_PEN_TIP_DOWN)
    {
        //
        // The tip switch changes state
        //
        if (InData->InputReport.bStatus & INSTATUS_PEN_TIP_DOWN)
        {
            gdwcSamples = 0;
            gdwcLostBytes = 0;
            gStartTime = CurrentTime;
        }
        else
        {
            CurrentTime.QuadPart -= gStartTime.QuadPart;
            CurrentTime.QuadPart /= (LONGLONG)10000;
            DBGPRINT(1, ("Samples=%d,Elapsed=%d,Rate=%d,BytesLost=%d\n",
                         gdwcSamples,
                         CurrentTime.LowPart,
                         CurrentTime.LowPart?
                             gdwcSamples*1000/CurrentTime.LowPart: 0,
                         gdwcLostBytes));
        }
    }

    gdwcSamples++;
  #endif

    if (DevExt->OemData.dwTabletFeatures & OEM_FEATURE_GLITCH_FILTER_ON)
    {
        LARGE_INTEGER ElapsedTime;

        ElapsedTime.QuadPart = CurrentTime.QuadPart - gLastReportTime.QuadPart;
        if (ElapsedTime.QuadPart < (LONGLONG)DevExt->OemData.dwThresholdPeriod)
        {
            USHORT wDX, wDY;

            wDX = (USHORT)(abs(InData->InputReport.wXData -
                               gLastReport.InputReport.wXData));
            wDY = (USHORT)(abs(InData->InputReport.wYData -
                               gLastReport.InputReport.wYData));

            if ((wDX > gwDXThreshold) || (wDY > gwDYThreshold))
            {
                //
                // Spike detected, drop this packet.
                //
                WARNPRINT(("dX or dY exceeding threshold (dX=%d,dY=%d)\n",
                           wDX, wDY));
                status = STATUS_DATA_ERROR;
            }
          #ifdef DEBUG
            else
            {
                if (wDX > gwMaxDX)
                {
                    gwMaxDX = wDX;
                }

                if (wDY > gwMaxDY)
                {
                    gwMaxDY = wDY;
                }
            }
          #endif
        }
    }

    gLastReportTime = CurrentTime;
    RtlCopyMemory(&gLastReport, InData, sizeof(gLastReport));

    if (NT_SUCCESS(status))
    {
        //
        // We have a valid report, tell the system that we are not idling.
        //
        PoSetSystemState(ES_USER_PRESENT);
    }

    DBGPRINT(3, ("status=%x,xData=%x(%d),yData=%x(%d)\n",
                 InData->InputReport.bStatus,
                 InData->InputReport.wXData,
                 InData->InputReport.wXData,
                 InData->InputReport.wYData,
                 InData->InputReport.wYData));

    EXIT(2, ("=%x (Status=%x,XData=%x(%d),YData=%x(%d)\n",
             status,
             InData->InputReport.bStatus,
             InData->InputReport.wXData,
             InData->InputReport.wXData,
             InData->InputReport.wYData,
             InData->InputReport.wYData));
    return status;
}       //OemNormalizeInputData

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemGetFeatures |
 *          Get feature report.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemGetFeatures(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("OemGetFeatures")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;
    PHID_XFER_PACKET FeaturePacket = (PHID_XFER_PACKET)Irp->UserBuffer;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    ASSERT(FeaturePacket != NULL);
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength !=
        sizeof(HID_XFER_PACKET))
    {
        ERRPRINT(("invalid xfer packet size (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.OutputBufferLength));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (FeaturePacket->reportBufferLen != sizeof(HID_FEATURE_REPORT))
    {
        ERRPRINT(("invalid feature report size (bufflen=%d)\n",
                  FeaturePacket->reportBufferLen));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (!(devext->dwfHPen & HPENF_DEVICE_STARTED))
    {
        ERRPRINT(("device not started yet\n"));
        status = STATUS_DEVICE_NOT_READY ;
    }
    else
    {
        PHID_FEATURE_REPORT Feature =
            (PHID_FEATURE_REPORT)FeaturePacket->reportBuffer;

        ASSERT(FeaturePacket->reportId == OEM_FEATURE_REPORT_ID);
        Feature->ReportID = OEM_FEATURE_REPORT_ID;
        Feature->Report.dwTabletFeatures = devext->OemData.dwTabletFeatures;
        Irp->IoStatus.Information = sizeof(HID_FEATURE_REPORT);
        status = STATUS_SUCCESS;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemGetFeatures

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemSetFeatures |
 *          Set feature report.
 *
 *  @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemSetFeatures(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("OemSetFeatures")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;
    PHID_XFER_PACKET FeaturePacket = (PHID_XFER_PACKET)Irp->UserBuffer;
    PHID_FEATURE_REPORT Feature;


    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(2, ("(DevObj=%p,Irp=%p,IrpSp=%p)\n", DevObj, Irp, irpsp));

    ASSERT(FeaturePacket != NULL);
    Feature = (PHID_FEATURE_REPORT)FeaturePacket->reportBuffer;
    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength !=
        sizeof(HID_XFER_PACKET))
    {
        ERRPRINT(("invalid xfer packet size (bufflen=%d)\n",
                  irpsp->Parameters.DeviceIoControl.InputBufferLength));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (FeaturePacket->reportBufferLen != sizeof(HID_FEATURE_REPORT))
    {
        ERRPRINT(("invalid feature report size (bufflen=%d)\n",
                  FeaturePacket->reportBufferLen));
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else if (!(devext->dwfHPen & HPENF_DEVICE_STARTED))
    {
        ERRPRINT(("device not started yet\n"));
        status = STATUS_DEVICE_NOT_READY ;
    }
    else if ((Feature->Report.dwTabletFeatures & OEM_FEATURE_UNUSED_BITS) ||
             ((Feature->Report.dwTabletFeatures & OEM_FEATURE_RATE_MASK) >
              OEM_MAX_RATE_DIVISOR))
    {
        ERRPRINT(("invalid tablet features (features=%x)\n",
                  Feature->Report.dwTabletFeatures));
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        ASSERT(FeaturePacket->reportId == OEM_FEATURE_REPORT_ID);
        devext->OemData.dwTabletFeatures = Feature->Report.dwTabletFeatures;
        status = OemSetTabletFeatures(devext, Feature->Report.dwTabletFeatures);
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemSetFeatures

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | OemSetTabletFeatures |
 *          Set tablet feature.
 *
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN ULONG | dwTabletFeatures | Specifies the tablet features.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
OemSetTabletFeatures(
    IN PDEVICE_EXTENSION DevExt,
    IN ULONG             dwTabletFeatures
    )
{
    PROCNAME("OemSetTabletFeatures")
    NTSTATUS status;
    char szTabletCmd[3] = "??";
    UCHAR bConversionRate = (UCHAR)(dwTabletFeatures & OEM_FEATURE_RATE_MASK);

    PAGED_CODE();

    ENTER(2, ("(DevExt=%p,Features=%x)\n", DevExt, dwTabletFeatures));

    status = RegSetDeviceParam(DevExt->pdo,
                               STR_TABLET_FEATURES,
                               REG_DWORD,
                               &dwTabletFeatures,
                               sizeof(dwTabletFeatures));
    if (NT_SUCCESS(status))
    {
        szTabletCmd[0] = (dwTabletFeatures & OEM_FEATURE_DIGITAL_FILTER_ON)?
                                    'V': 'N';
        szTabletCmd[1] = (char)('0' + bConversionRate);
        if (bConversionRate != 0)
        {
            //
            // At sampling rate of 133.3, the sampling period is 7.5msec.
            // We set the threshold period 10 times of the sampling period.
            // ThresholdPeriod = 75000*ConversionRate*10 (in units of 100nsec)
            //
            DevExt->OemData.dwThresholdPeriod = bConversionRate*750000;
        }
        else
        {
            //
            // Conversion rate of 0 means 100 samples per second which
            // means sampling interval is 10msec.
            // ThresholdPeriod = 100000*10 (in units of 100nsec)
            //
            DevExt->OemData.dwThresholdPeriod = 1000000;
        }

        status = SerialSyncReadWritePort(FALSE,
                                         DevExt,
                                         szTabletCmd,
                                         sizeof(szTabletCmd) - 1,
                                         NULL,
                                         NULL);
    }
    else
    {
        ERRPRINT(("failed to set tablet features in the registry (status=%x)\n",
                  status));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //OemSetTabletFeatures

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | RegQueryDeviceParam | Query the registry for a device
 *          parameter.
 *
 *  @parm   IN PDEVICE_OBJECT | pdo | Points to the pdo of the device.
 *  @parm   IN PWSTR | pwstrParamName | Points to the param name string.
 *  @parm   OUT PVOID | pbBuff | Points to the buffer to hold the result.
 *  @parm   IN ULONG | dwcbLen | Specifies the length of the buffer.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
RegQueryDeviceParam(
    IN PDEVICE_OBJECT pdo,
    IN PWSTR          pwstrParamName,
    OUT PVOID         pbBuff,
    IN ULONG          dwcbLen
    )
{
    PROCNAME("RegQueryDeviceParam")
    NTSTATUS status;
    ULONG dwSize;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInfo;

    PAGED_CODE();
    ENTER(2, ("(pdo=%p,ParamName=%S,pbBuff=%p,Len=%d)\n",
              pdo, pwstrParamName, pbBuff, dwcbLen));

    dwSize = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwcbLen;
    pValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePool(PagedPool,
                                                                dwSize);
    if (pValueInfo != NULL)
    {
        HANDLE hkey;

        status = IoOpenDeviceRegistryKey(pdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_READ,
                                         &hkey);
        if (NT_SUCCESS(status))
        {
            UNICODE_STRING ucKeyName;

            RtlInitUnicodeString(&ucKeyName, pwstrParamName);
            status = ZwQueryValueKey(hkey,
                                     &ucKeyName,
                                     KeyValuePartialInformation,
                                     pValueInfo,
                                     dwSize,
                                     &dwSize);
            if (NT_SUCCESS(status))
            {
                ASSERT(pValueInfo->DataLength == dwcbLen);
                RtlCopyMemory(pbBuff, pValueInfo->Data, dwcbLen);
            }
            else
            {
                WARNPRINT(("failed to read parameter %S (status=%x)\n",
                           pwstrParamName, status));
            }

            ZwClose(hkey);
        }
        else
        {
            ERRPRINT(("failed to open device registry key (status=%x)\n",
                      status));
        }

        ExFreePool(pValueInfo);
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ERRPRINT(("failed to allocate registry value buffer (size=%d)\n",
                  dwSize));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //RegQueryDeviceParam

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | RegSetDeviceParam | Set the device parameter in the
 *          registry.
 *
 *  @parm   IN PDEVICE_OBJECT | pdo | Points to the pdo of the device.
 *  @parm   IN PWSTR | pwstrParamName | Points to the param name string.
 *  @parm   IN ULONG | dwType | Value type.
 *  @parm   IN PVOID | pbBuff | Points to the buffer to hold the result.
 *  @parm   IN ULONG | dwcbLen | Specifies the length of the buffer.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
RegSetDeviceParam(
    IN PDEVICE_OBJECT pdo,
    IN PWSTR          pwstrParamName,
    IN ULONG          dwType,
    IN PVOID          pbBuff,
    IN ULONG          dwcbLen
    )
{
    PROCNAME("RegSetDeviceParam")
    NTSTATUS status;
    HANDLE hkey;

    PAGED_CODE();
    ENTER(2, ("(pdo=%p,ParamName=%S,Type=%x,pbBuff=%p,Len=%d)\n",
              pdo, pwstrParamName, dwType, pbBuff, dwcbLen));

    status = IoOpenDeviceRegistryKey(pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &hkey);
    if (NT_SUCCESS(status))
    {
        UNICODE_STRING ucKeyName;

        RtlInitUnicodeString(&ucKeyName, pwstrParamName);
        status = ZwSetValueKey(hkey,
                               &ucKeyName,
                               0,
                               dwType,
                               pbBuff,
                               dwcbLen);
        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed to set parameter %S (status=%x)\n",
                      pwstrParamName, status));
        }

        ZwClose(hkey);
    }
    else
    {
        ERRPRINT(("failed to open device registry key (status=%x)\n",
                  status));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //RegSetDeviceParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\serial.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    serial.c

Abstract: Functions to talk to the serial port.

Environment:

    Kernel mode

Author:

    Michael Tsang (MikeTs) 23-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, SerialSyncSendIoctl)
  #pragma alloc_text(PAGE, SerialSyncReadWritePort)
#endif /* ALLOC_PRAGMA */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | SerialSyncSendIoctl |
 *          Performs a synchronous ioctl request to the serial port.
 *
 *  @parm   IN ULONG | IoctlCode | ioctl code.
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PVOID | InBuffer OPTIONAL | Points to the input buffer.
 *  @parm   IN ULONG | InBufferLen | Specifies the size of the input buffer.
 *  @parm   OUT PVOID | OutBuffer OPTIONAL | Points to the output buffer.
 *  @parm   IN ULONG | OutBufferLen | Specifies the size of the output buffer.
 *  @parm   IN BOOLEAN | fInternal | If TRUE, an internal ioctl is sent.
 *  @parm   OUT PIO_STATUS_BLOCK | Iosb | Points to the io status block.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
SerialSyncSendIoctl(
    IN ULONG          IoctlCode,
    IN PDEVICE_OBJECT DevObj,
    IN PVOID          InBuffer OPTIONAL,
    IN ULONG          InBufferLen,
    OUT PVOID         OutBuffer OPTIONAL,
    IN ULONG          OutBufferLen,
    IN BOOLEAN        fInternal,
    OUT PIO_STATUS_BLOCK Iosb
    )
{
    PROCNAME("SerialSyncSendIoctl")
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT event;
    PIRP irp;

    PAGED_CODE();

    ENTER(3, ("(Ioctl=%s,DevObj=%p,InBuff=%p,InLen=%d,OutBuff=%p,OutLen=%d,fInternal=%x,Iosb=%p)\n",
              LookupName(IoctlCode,
                         fInternal? SerialInternalIoctlNames: SerialIoctlNames),
              DevObj, InBuffer, InBufferLen, OutBuffer, OutBufferLen,
              fInternal, Iosb));

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        DevObj,
                                        InBuffer,
                                        InBufferLen,
                                        OutBuffer,
                                        OutBufferLen,
                                        fInternal,
                                        &event,
                                        Iosb);
    if (irp != NULL)
    {
        status = IoCallDriver(DevObj, irp);
        if (status == STATUS_PENDING)
        {
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);
        }

        if (status == STATUS_SUCCESS)
        {
            status = Iosb->Status;
        }
    }
    else
    {
        ERRPRINT(("failed to build ioctl irp (status=%x)\n", status));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    EXIT(3, ("=%x\n", status));
    return status;
}       //SerialSyncSendIoctl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | SerialAsyncReadWritePort |
 *          Read/Write data from/to the Serial Port asynchornously.
 *
 *  @parm   IN BOOLEAN | fRead | If TRUE, the access is a Read.
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN PIRP | Irp | Points to an I/O Request Packet.
 *  @parm   IN PUCHAR | Buffer | Points to the data buffer.
 *  @parm   IN ULONG | BuffLen | Specifies the data buffer length.
 *  @parm   IN PIO_COMPLETION_ROUTINE | CompletionRoutine |
 *          Points to the completion callback routine.
 *  @parm   IN PVOID | Context | Callback context.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
SerialAsyncReadWritePort(
    IN BOOLEAN                fRead,
    IN PDEVICE_EXTENSION      DevExt,
    IN PIRP                   Irp,
    IN PUCHAR                 Buffer,
    IN ULONG                  BuffLen,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID                  Context
    )
{
    PROCNAME("SerialAsyncReadWritePort")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;

    ENTER(2, ("(fRead=%x,DevExt=%p,Irp=%p,Buff=%p,BuffLen=%d,pfnCompletion=%p,Context=%p)\n",
              fRead, DevExt, Irp, Buffer, BuffLen, CompletionRoutine,
              Context));

    ASSERT(Buffer != NULL);
    ASSERT(BuffLen > 0);

    Irp->AssociatedIrp.SystemBuffer = Buffer;
    irpsp = IoGetNextIrpStackLocation(Irp);
    RtlZeroMemory(irpsp, sizeof(*irpsp));
    irpsp->Parameters.Read.Length = BuffLen;
    irpsp->Parameters.Read.ByteOffset.QuadPart = 0;
    irpsp->MajorFunction = fRead? IRP_MJ_READ: IRP_MJ_WRITE;
    IoSetCompletionRoutine(Irp,
                           CompletionRoutine,
                           Context,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(DevExt->SerialDevObj, Irp);

    EXIT(2, ("=%x\n", status));
    return status;
}       //SerialAsyncReadWritePort

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | SerialSyncReadWritePort |
 *          Read/Write data from/to the Serial Port.
 *
 *  @parm   IN BOOLEAN | fRead | If TRUE, the access is a Read.
 *  @parm   IN PDEVICE_EXTENSION | DevExt | Points to the device extension.
 *  @parm   IN PUCHAR | Buffer | Points to the data buffer.
 *  @parm   IN ULONG | BuffLen | Specifies the data buffer length.
 *  @parm   IN PLARGE_INTEGER | Timeout | Points to an optional timeout value
 *  @parm   OUT PULONG | BytesAccessed | Optionally returns number of bytes
 *          accessed.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
SerialSyncReadWritePort(
    IN BOOLEAN           fRead,
    IN PDEVICE_EXTENSION DevExt,
    IN PUCHAR            Buffer,
    IN ULONG             BuffLen,
    IN PLARGE_INTEGER    Timeout OPTIONAL,
    OUT PULONG           BytesAccessed OPTIONAL
    )
{
    PROCNAME("SerialSyncReadWritePort")
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    LARGE_INTEGER StartingOffset = RtlConvertLongToLargeInteger(0);
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();

    ENTER(2, ("(fRead=%x,DevExt=%p,Buff=%p,BuffLen=%d,pTimeout=%p,pBytesAccessed=%p)\n",
              fRead, DevExt, Buffer, BuffLen, Timeout, BytesAccessed));

    ASSERT(Buffer != NULL);
    ASSERT(BuffLen > 0);

    if (BytesAccessed != NULL)
    {
        *BytesAccessed = 0;
    }
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(fRead? IRP_MJ_READ: IRP_MJ_WRITE,
                                       DevExt->SerialDevObj,
                                       Buffer,
                                       BuffLen,
                                       &StartingOffset,
                                       &event,
                                       &iosb);
    if (irp != NULL)
    {
        ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n",
                  DevExt->SerialDevObj, irp));
        status = IoCallDriver(DevExt->SerialDevObj, irp);
        EXIT(2, (".IoCallDriver=%x\n", status));

        if (status == STATUS_PENDING)
        {
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           Timeout);
        }

        if (status == STATUS_SUCCESS)
        {
            status = iosb.Status;
            if (BytesAccessed != NULL)
            {
                *BytesAccessed = (ULONG)iosb.Information;
            }
        }
        else
        {
            ERRPRINT(("failed accessing com port (status=%x)\n",
                      status));
        }
    }
    else
    {
        ERRPRINT(("failed to allocate synchronous IRP\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    EXIT(2, ("=%x (BytesAccessed=%d)\n", status, iosb.Information));
    return status;
}       //SerialSyncReadWritePort
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\pnp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pnp.c

Abstract: This module contains code to handle PnP and Power IRPs.

Environment:

    Kernel mode

  Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, HpenPnp)
  #pragma alloc_text(PAGE, HpenPower)
  #pragma alloc_text(PAGE, InitDevice)
  #pragma alloc_text(PAGE, RemoveDevice)
  #pragma alloc_text(PAGE, SendSyncIrp)
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HpenPnp |
 *          Plug and Play dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Pointer to the device object.
 *  @parm   IN PIRP | Irp | Pointer to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HpenPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HpenPnp")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Minor=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MinorFunction, PnPMinorFnNames)));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        //
        // Someone sent us another plug and play IRP after removed
        //
        ERRPRINT(("received PnP IRP after device was removed\n"));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        BOOLEAN fSkipIt = FALSE;

        switch (irpsp->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ASSERT(!(devext->dwfHPen & HPENF_DEVICE_STARTED));
                //
                // Forward the IRP down the stack
                //
                status = SendSyncIrp(devext->SerialDevObj, Irp, TRUE);
                if (NT_SUCCESS(status))
                {
                    status = InitDevice(DevObj, Irp);
                    if (NT_SUCCESS(status))
                    {
                        devext->dwfHPen |= HPENF_DEVICE_STARTED;
                    }
                }
                else
                {
                    ERRPRINT(("failed to forward start IRP (status=%x)\n",
                              status));
                }

                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;

            case IRP_MN_STOP_DEVICE:
                //
                // After the start IRP has been sent to the lower driver
                // object, the bus may NOT send any more IRPS down ``touch''
                // until another START has occured.  Whatever access is
                // required must be done before Irp passed on.
                //
                if (devext->dwfHPen & HPENF_DEVICE_STARTED)
                {
                    devext->dwfHPen &= ~HPENF_DEVICE_STARTED;
                    //
                    // I don't need to cancel any pending read IRPs since
                    // those IRPs originated from hidclass and presumably
                    // hidclass will cancel them.
                    //
                }

                //
                // We don't need a completion routine so fire and forget.
                // Set the current stack location to the next stack location and
                // call the next device object.
                //
                fSkipIt = TRUE;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:
                //
                // The PlugPlay system has detected the removal of this device.
                // We have no choice but to detach and delete the device object.
                // (If we wanted to express an interest in preventing this
                // removal, we should have filtered the query remove and query
                // stop routines.)
                // Note: we might receive a remove WITHOUT first receiving a
                // stop.
                //

                //
                // Make sure we do not allow more IRPs to start touching the
                // device.
                //
                devext->dwfHPen &= ~HPENF_DEVICE_STARTED;
                devext->dwfHPen |= HPENF_DEVICE_REMOVED;

                RemoveDevice(DevObj, Irp);

                //
                // Send on the remove IRP
                //
                fSkipIt = TRUE;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                status = SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, TRUE);
                if (NT_SUCCESS(status))
                {
                    PDEVICE_CAPABILITIES devcaps;

                    devcaps = irpsp->Parameters.DeviceCapabilities.Capabilities;
                    if (devcaps != NULL)
                    {
                        SYSTEM_POWER_STATE i;

                        //
                        // This device is built-in to the system, so it should
                        // be impossible to surprise remove this device, but
                        // we will handle it anyway.
                        //
                        devcaps->SurpriseRemovalOK = TRUE;

                        //
                        // While the underlying serial bus might be able to
                        // wake the machine from low power (via wake on ring),
                        // the tablet cannot.
                        //
                        devcaps->SystemWake = PowerSystemUnspecified;
                        devcaps->DeviceWake = PowerDeviceUnspecified;
                        devcaps->WakeFromD0 =
                                devcaps->WakeFromD1 =
                                devcaps->WakeFromD2 =
                                devcaps->WakeFromD3 = FALSE;
                        devcaps->DeviceState[PowerSystemWorking] =
                                PowerDeviceD0;
                        for (i = PowerSystemSleeping1;
                             i < PowerSystemMaximum;
                             i++)
                        {
                            devcaps->DeviceState[i] = PowerDeviceD3;
                        }
                    }
                }
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;

            default:
                fSkipIt = TRUE;
                break;
        }

        if (fSkipIt)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n",
                      GET_NEXT_DEVICE_OBJECT(DevObj), Irp));
            status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DevObj), Irp);
            EXIT(2, (".IoCallDriver=%x\n", status));
        }

        if (irpsp->MinorFunction == IRP_MN_REMOVE_DEVICE)
        {
            //
            // Wait for the remove lock to free.
            //
            IoReleaseRemoveLockAndWait(&devext->RemoveLock, Irp);

            IoFreeWorkItem(devext->ReadWorkItem[0].WorkItem);
            IoFreeWorkItem(devext->ReadWorkItem[1].WorkItem);
        }
        else
        {
            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
        }
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HpenPnp

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HpenPower | The power dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS EXTERNAL
HpenPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("HpenPower")
    NTSTATUS status;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(1, ("(DevObj=%p,Irp=%p,Minor=%s)\n",
              DevObj, Irp,
              LookupName(IoGetCurrentIrpStackLocation(Irp)->MinorFunction,
                         PowerMinorFnNames)));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (!NT_SUCCESS(status))
    {
        //
        // Someone sent us another power IRP after removed
        //
        ERRPRINT(("received Power IRP after device was removed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);
        POWER_STATE_TYPE PowerType = irpsp->Parameters.Power.Type;
        POWER_STATE NewPowerState = irpsp->Parameters.Power.State;
        BOOLEAN fSkipCalldown = FALSE;

        switch (irpsp->MinorFunction)
        {
            case IRP_MN_SET_POWER:
                //
                // We only handle DevicePowerState IRPs that change
                // power states.
                //
                if ((PowerType == DevicePowerState) &&
                    (NewPowerState.DeviceState != devext->PowerState))
                {
                    DBGPRINT(1, ("power state change (%s->%s)\n",
                                 LookupName(devext->PowerState,
                                            PowerStateNames),
                                 LookupName(NewPowerState.DeviceState,
                                            PowerStateNames)));
                    switch (NewPowerState.DeviceState)
                    {
                        case PowerDeviceD0:
                            //
                            // Transitioning from a low D state to D0.
                            //
                            status = SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj),
                                                 Irp,
                                                 TRUE);
                            if (NT_SUCCESS(status))
                            {
                                PoSetPowerState(DevObj,
                                                PowerType,
                                                NewPowerState);
                                OemWakeupDevice(devext);
                                devext->PowerState = NewPowerState.DeviceState;
                                devext->dwfHPen &= ~HPENF_TABLET_STANDBY;
                            }
                            Irp->IoStatus.Status = status;
                            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
                            IoCompleteRequest(Irp, IO_NO_INCREMENT);
                            fSkipCalldown = TRUE;
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
//BUGBUG:                            OemStandbyDevice(devext);
                            PoSetPowerState(DevObj, PowerType, NewPowerState);
                            devext->PowerState = NewPowerState.DeviceState;
//BUGBUG:                            devext->dwfHPen |= HPENF_TABLET_STANDBY;
                            IoReleaseRemoveLock(&devext->RemoveLock, Irp);

                            Irp->IoStatus.Status = STATUS_SUCCESS;
                            IoSkipCurrentIrpStackLocation(Irp);

                            ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n",
                                      GET_NEXT_DEVICE_OBJECT(DevObj), Irp));
                            status = PoCallDriver(
                                        GET_NEXT_DEVICE_OBJECT(DevObj),
                                        Irp);
                            EXIT(2, (".PoCallDriver=%x\n", status));

                            fSkipCalldown = TRUE;
                            break;
                    }
                }
                break;

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_QUERY_POWER:
                break;

            default:
                ERRPRINT(("unsupported power IRP (%s)\n",
                          LookupName(irpsp->MinorFunction, PowerMinorFnNames)));
                break;
        }

        if (!fSkipCalldown)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n",
                      GET_NEXT_DEVICE_OBJECT(DevObj), Irp));
            status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DevObj), Irp);
            EXIT(2, (".PoCallDriver=%x\n", status));

            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
        }
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //HpenPower

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | InitDevice |
 *          Get the device information and attempt to initialize a
 *          configuration for a device.  If we cannot identify this as a
 *          valid HID device or configure the device, our start device
 *          function is failed.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
InitDevice(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("InitDevice")
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p)\n", DevObj, Irp));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    if (!(devext->dwfHPen & HPENF_SERIAL_OPENED))
    {
        //
        // If a create hasn't been sent down the stack, send one now.
        // The serial port driver requires a create before it will accept
        // any reads or ioctls.
        //
        PIO_STACK_LOCATION irpspNext = IoGetNextIrpStackLocation(Irp);
        NTSTATUS PrevStatus = Irp->IoStatus.Status;
        ULONG_PTR PrevInfo = Irp->IoStatus.Information;

        RtlZeroMemory(irpspNext, sizeof(*irpspNext));
        irpspNext->MajorFunction = IRP_MJ_CREATE;
        status = SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, FALSE);
        if (NT_SUCCESS(status))
        {
            devext->dwfHPen |= HPENF_SERIAL_OPENED;
            Irp->IoStatus.Status = PrevStatus;
            Irp->IoStatus.Information = PrevInfo;
        }
        else
        {
            ERRPRINT(("failed to send CREATE IRP to serial port (status=%x)\n",
                      status));
        }
    }

    if (NT_SUCCESS(status))
    {
        status = OemInitSerialPort(devext);
        if (NT_SUCCESS(status))
        {
            status = OemInitDevice(devext);
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //InitDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | RemoveDevice | FDO Remove routine
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *
 *****************************************************************************/

VOID INTERNAL
RemoveDevice(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    )
{
    PROCNAME("RemoveDevice")
    PDEVICE_EXTENSION devext;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p)\n", DevObj, Irp));

    devext = GET_MINIDRIVER_DEVICE_EXTENSION(DevObj);

    ASSERT(devext->dwfHPen & HPENF_DEVICE_REMOVED);
    if (devext->dwfHPen & HPENF_SERIAL_OPENED)
    {
        PIO_STACK_LOCATION irpspNext;

        OemRemoveDevice(devext);

        irpspNext = IoGetNextIrpStackLocation(Irp);
        RtlZeroMemory(irpspNext, sizeof(*irpspNext));
        irpspNext->MajorFunction = IRP_MJ_CLEANUP;
        SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, FALSE);

        irpspNext = IoGetNextIrpStackLocation(Irp);
        RtlZeroMemory(irpspNext, sizeof(*irpspNext));
        irpspNext->MajorFunction = IRP_MJ_CLOSE;
        SendSyncIrp(GET_NEXT_DEVICE_OBJECT(DevObj), Irp, FALSE);

        devext->dwfHPen &= ~HPENF_SERIAL_OPENED;
    }
  #ifdef DEBUG
    ExAcquireFastMutex(&gmutexDevExtList);
    RemoveEntryList(&devext->List);
    ExReleaseFastMutex (&gmutexDevExtList);
  #endif

    EXIT(2, ("!\n"));
    return;
}       //RemoveDevice

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | SendSyncIrp |
 *          Send an IRP synchronously down the stack.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to the IRP.
 *  @parm   IN BOOLEAN | fCopyToNext | if TRUE, copy the irpsp to next location.
 *
 *  @rvalue SUCCESS | returns STATUS_SUCCESS
 *  @rvalue FAILURE | returns NT status code
 *
 *****************************************************************************/

NTSTATUS INTERNAL
SendSyncIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN BOOLEAN        fCopyToNext
    )
{
    PROCNAME("SendSyncIrp")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT event;

    PAGED_CODE();

    ENTER(2, ("(DevObj=%p,Irp=%p,fCopyToNext=%x,MajorFunc=%s)\n",
              DevObj, Irp, fCopyToNext,
              LookupName(irpsp->MajorFunction, MajorFnNames)));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    if (fCopyToNext)
    {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp, IrpCompletion, &event, TRUE, TRUE, TRUE);
    if (irpsp->MajorFunction == IRP_MJ_POWER)
    {
        ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n", DevObj, Irp));
        status = PoCallDriver(DevObj, Irp);
        EXIT(2, (".IoCallDriver=%x\n", status));
    }
    else
    {
        ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n", DevObj, Irp));
        status = IoCallDriver(DevObj, Irp);
        EXIT(2, (".IoCallDriver=%x\n", status));
    }

    if (status == STATUS_PENDING)
    {
        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }

    if (NT_SUCCESS(status))
    {
        status = Irp->IoStatus.Status;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //SendSyncIrp

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS | IrpCompletion | Completion routine for all IRPs.
 *
 *  @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
 *  @parm   IN PIRP | Irp | Points to an I/O request packet.
 *  @parm   IN PKEVENT | Event | Points to the event to notify.
 *
 *  @rvalue STATUS_MORE_PROCESSING_REQUIRED | We want the IRP back
 *
 *****************************************************************************/

NTSTATUS INTERNAL
IrpCompletion(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PKEVENT        Event
    )
{
    PROCNAME("IrpCompletion")

    ENTER(2, ("(DevObj=%p,Irp=%p,Event=%p)\n", DevObj, Irp, Event));

    UNREFERENCED_PARAMETER(DevObj);

    KeSetEvent(Event, 0, FALSE);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    EXIT(2, ("=%x\n", STATUS_MORE_PROCESSING_REQUIRED));
    return STATUS_MORE_PROCESSING_REQUIRED;
}       //IrpCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\debug.h ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        debug.h

    Abstract:  Contains debug related definitions.

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#ifndef _DEBUG_H
#define _DEBUG_H

//
// Constants
//

//
// Macros
//
#ifdef DEBUG
  #define TRAP()                DbgBreakPoint()
  #define DBGPRINT(n,x)         if (n <= giVerboseLevel)                    \
                                {                                           \
                                    DbgPrint(MODNAME ": %s: ", ProcName);   \
                                    DbgPrint x;                             \
                                }
  #define WARNPRINT(x)          {                                           \
                                    DbgPrint(MODNAME "_WARN: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                }
  #define ERRPRINT(x)           {                                           \
                                    DbgPrint(MODNAME "_ERR: %s: ", ProcName);\
                                    DbgPrint x;                             \
                                    TRAP();                                 \
                                }
#else
  #define TRAP()
  #define DBGPRINT(n,x)
  #define WARNPRINT(x)
  #define ERRPRINT(x)
#endif  //ifdef DEBUG

//
// Type Definitions
//
typedef struct _NAMETABLE
{
    ULONG Code;
    PSZ   pszName;
} NAMETABLE, *PNAMETABLE;

//
// Exported Data Declarations
//
#ifdef DEBUG
extern NAMETABLE MajorFnNames[];
extern NAMETABLE PnPMinorFnNames[];
extern NAMETABLE PowerMinorFnNames[];
extern NAMETABLE PowerStateNames[];
extern NAMETABLE QueryIDTypeNames[];
extern NAMETABLE IoctlNames[];
extern NAMETABLE ProtocolNames[];
extern int giVerboseLevel;
#endif

//
// Function prototypes
//
#ifdef DEBUG
PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    );
#endif  //ifdef DEBUG

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\pch.h ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        pch.h

    Abstract:  Pre-compile C header file.


    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "SMBLITE"
#define INTERNAL
#define EXTERNAL

#if DBG
  #define DEBUG
  #define TRACING
  #define SYSACC
#endif

#include <ntddk.h>
#include <ntpoapi.h>
#include <poclass.h>
#include <smbus.h>
#include <smblite.h>
#include "smblitep.h"
#include "debug.h"
#include "trace.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\debug.c ===
/*++
    Copyright (c) 2000 Microsoft Corporation

    Module Name:
        debug.c

    Abstract: This module contains all the debug functions.

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#include "pch.h"

#ifdef DEBUG

NAMETABLE MajorFnNames[] =
{
    IRP_MJ_CREATE,                      "Create",
    IRP_MJ_CREATE_NAMED_PIPE,           "CreateNamedPipe",
    IRP_MJ_CLOSE,                       "Close",
    IRP_MJ_READ,                        "Read",
    IRP_MJ_WRITE,                       "Write",
    IRP_MJ_QUERY_INFORMATION,           "QueryInfo",
    IRP_MJ_SET_INFORMATION,             "SetInfo",
    IRP_MJ_QUERY_EA,                    "QueryEA",
    IRP_MJ_SET_EA,                      "SetEA",
    IRP_MJ_FLUSH_BUFFERS,               "FlushBuffers",
    IRP_MJ_QUERY_VOLUME_INFORMATION,    "QueryVolInfo",
    IRP_MJ_SET_VOLUME_INFORMATION,      "SetVolInfo",
    IRP_MJ_DIRECTORY_CONTROL,           "DirectoryControl",
    IRP_MJ_FILE_SYSTEM_CONTROL,         "FileSystemControl",
    IRP_MJ_DEVICE_CONTROL,              "DeviceControl",
    IRP_MJ_INTERNAL_DEVICE_CONTROL,     "InternalDevControl",
    IRP_MJ_SHUTDOWN,                    "Shutdown",
    IRP_MJ_LOCK_CONTROL,                "LockControl",
    IRP_MJ_CLEANUP,                     "CleanUp",
    IRP_MJ_CREATE_MAILSLOT,             "CreateMailSlot",
    IRP_MJ_QUERY_SECURITY,              "QuerySecurity",
    IRP_MJ_SET_SECURITY,                "SetSecurity",
    IRP_MJ_POWER,                       "Power",
    IRP_MJ_SYSTEM_CONTROL,              "SystemControl",
    IRP_MJ_DEVICE_CHANGE,               "DeviceChange",
    IRP_MJ_QUERY_QUOTA,                 "QueryQuota",
    IRP_MJ_SET_QUOTA,                   "SetQuota",
    IRP_MJ_PNP,                         "PnP",
    0x00,                               NULL
};

NAMETABLE PnPMinorFnNames[] =
{
    IRP_MN_START_DEVICE,                "StartDevice",
    IRP_MN_QUERY_REMOVE_DEVICE,         "QueryRemoveDevice",
    IRP_MN_REMOVE_DEVICE,               "RemoveDevice",
    IRP_MN_CANCEL_REMOVE_DEVICE,        "CancelRemoveDevice",
    IRP_MN_STOP_DEVICE,                 "StopDevice",
    IRP_MN_QUERY_STOP_DEVICE,           "QueryStopDevice",
    IRP_MN_CANCEL_STOP_DEVICE,          "CancelStopDevice",
    IRP_MN_QUERY_DEVICE_RELATIONS,      "QueryDeviceRelations",
    IRP_MN_QUERY_INTERFACE,             "QueryInterface",
    IRP_MN_QUERY_CAPABILITIES,          "QueryCapabilities",
    IRP_MN_QUERY_RESOURCES,             "QueryResources",
    IRP_MN_QUERY_RESOURCE_REQUIREMENTS, "QueryResRequirements",
    IRP_MN_QUERY_DEVICE_TEXT,           "QueryDeviceText",
    IRP_MN_FILTER_RESOURCE_REQUIREMENTS,"FilterResRequirements",
    IRP_MN_READ_CONFIG,                 "ReadConfig",
    IRP_MN_WRITE_CONFIG,                "WriteConfig",
    IRP_MN_EJECT,                       "Eject",
    IRP_MN_SET_LOCK,                    "SetLock",
    IRP_MN_QUERY_ID,                    "QueryID",
    IRP_MN_QUERY_PNP_DEVICE_STATE,      "QueryPNPDeviceState",
    IRP_MN_QUERY_BUS_INFORMATION,       "QueryBusInfo",
    IRP_MN_DEVICE_USAGE_NOTIFICATION,   "DeviceUsageNotify",
    IRP_MN_SURPRISE_REMOVAL,            "SurpriseRemoval",
    0x18,                               "QueryLegacyBusInfo",
    0x00,                               NULL
};

NAMETABLE PowerMinorFnNames[] =
{
    IRP_MN_WAIT_WAKE,                   "WaitWake",
    IRP_MN_POWER_SEQUENCE,              "PowerSequence",
    IRP_MN_SET_POWER,                   "SetPower",
    IRP_MN_QUERY_POWER,                 "QueryPower",
    0x00,                               NULL
};

NAMETABLE PowerStateNames[] =
{
    PowerDeviceUnspecified,             "Unspecified",
    PowerDeviceD0,                      "D0",
    PowerDeviceD1,                      "D1",
    PowerDeviceD2,                      "D2",
    PowerDeviceD3,                      "D3",
    PowerDeviceMaximum,                 "Maximum",
    0x00,                               NULL
};

NAMETABLE QueryIDTypeNames[] =
{
    BusQueryDeviceID,                   "DeviceID",
    BusQueryHardwareIDs,                "HardwareIDs",
    BusQueryCompatibleIDs,              "CompatibleIDs",
    BusQueryDeviceSerialNumber,         "DeviceSerialNumber",
    0x00,                               NULL
};

NAMETABLE IoctlNames[] =
{
    IOCTL_SMBLITE_GETBRIGHTNESS,        "GetBrightness",
    IOCTL_SMBLITE_SETBRIGHTNESS,        "SetBrightness",
#ifdef SYSACC
    IOCTL_SYSACC_MEM_REQUEST,           "MemRequest",
    IOCTL_SYSACC_IO_REQUEST,            "IORequest",
    IOCTL_SYSACC_PCICFG_REQUEST,        "PCICfgRequest",
    IOCTL_SYSACC_SMBUS_REQUEST,         "SMBusRequest",
#endif
    0x00,                               NULL
};

NAMETABLE ProtocolNames[] =
{
    SMB_WRITE_QUICK,                    "QuickWrite",
    SMB_READ_QUICK,                     "QuickRead",
    SMB_SEND_BYTE,                      "SendByte",
    SMB_RECEIVE_BYTE,                   "ReceiveByte",
    SMB_WRITE_BYTE,                     "WriteByte",
    SMB_READ_BYTE,                      "ReadByte",
    SMB_WRITE_WORD,                     "WriteWord",
    SMB_READ_WORD,                      "ReadWord",
    SMB_WRITE_BLOCK,                    "WriteBlock",
    SMB_READ_BLOCK,                     "ReadBlock",
    SMB_PROCESS_CALL,                   "ProcessAll",
    0x00,                               NULL
};

int giVerboseLevel = 0;

/*++
    @doc    INTERNAL

    @func   PSZ | LookupName |
            Look up name string of a code in the given name table.

    @parm   IN ULONG | Code | The given code to lookup.

    @parm   IN PNAMETABLE | NameTable | The name table to look into.

    @rvalue SUCCESS - Returns pointer to the minor function name string.
    @rvalue FAILURE - Returns "unknown".
--*/

PSZ INTERNAL
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    )
{
    PROCNAME("LookupName")
    PSZ pszName = "unknown";

    ENTER(5, ("(Code=%x,pNameTable=%p)\n", Code, NameTable));

    ASSERT(NameTable != NULL);
    while (NameTable->pszName != NULL)
    {
        if (Code == NameTable->Code)
        {
            pszName = NameTable->pszName;
            break;
        }
        NameTable++;
    }

    EXIT(5, ("=%s\n", pszName));
    return pszName;
}       //LookupName

#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\ioctl.c ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        ioctl.c

    Abstract: Contains routines to support ioctl queries for the SMB Back Light
              device.

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, SmbLiteIoctl)
  #pragma alloc_text(PAGE, GetBackLightBrightness)
  #pragma alloc_text(PAGE, RegQueryDeviceParam)
#endif

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | SmbLiteIoctl |
            Process the Device Control IRPs sent to this device.

    @parm   IN PDRIVER_OBJECT | DevObj | Points to the driver object.
    @parm   IN PIRP | Irp | Points to an I/O Request Packet.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS EXTERNAL
SmbLiteIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PROCNAME("SmbLiteIoctl")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PSMBLITE_DEVEXT devext;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Ioctl=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                         IoctlNames)));

    devext = DevObj->DeviceExtension;
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (NT_SUCCESS(status))
    {
        BOOLEAN fNeedCompletion = TRUE;

        ASSERT(devext->dwfSmbLite & SMBLITEF_DEVICE_STARTED);
        Irp->IoStatus.Information = 0;
        switch(irpsp->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_SMBLITE_GETBRIGHTNESS:
                if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(SMBLITE_BRIGHTNESS))
                {
                    status = STATUS_BUFFER_TOO_SMALL;
                    WARNPRINT(("GetBrightness buffer too small (len=%d,required=%d).\n",
                               irpsp->Parameters.DeviceIoControl.OutputBufferLength,
                               sizeof(SMBLITE_BRIGHTNESS)));
                }
                else
                {
                    PSMBLITE_BRIGHTNESS Brightness = Irp->UserBuffer;

                    try
                    {
                        ProbeForWrite(Brightness,
                                      sizeof(*Brightness),
                                      sizeof(UCHAR));
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        status = GetExceptionCode();
                        WARNPRINT(("Invalid GetBrightness buffer (status=%x,Buff=%p).\n",
                                   status, Brightness));
                    }

                    if (NT_SUCCESS(status))
                    {
                        status = GetBackLightBrightness(devext, Brightness);
                        if (NT_SUCCESS(status))
                        {
                            Irp->IoStatus.Information = sizeof(*Brightness);
                        }
                    }
                }
                break;

            case IOCTL_SMBLITE_SETBRIGHTNESS:
                if (irpsp->Parameters.DeviceIoControl.InputBufferLength !=
                    sizeof(SMBLITE_SETBRIGHTNESS))
                {
                    status = STATUS_INFO_LENGTH_MISMATCH;
                    WARNPRINT(("SetBrightness buffer length mismatch (len=%d,required=%d).\n",
                               irpsp->Parameters.DeviceIoControl.InputBufferLength,
                               sizeof(SMBLITE_SETBRIGHTNESS)));
                }
                else
                {
                    PSMBLITE_SETBRIGHTNESS SetBrightness = (PSMBLITE_SETBRIGHTNESS)
                        irpsp->Parameters.DeviceIoControl.Type3InputBuffer;

                    try
                    {
                        ProbeForRead(SetBrightness,
                                     sizeof(*SetBrightness),
                                     sizeof(UCHAR));
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        status = GetExceptionCode();
                        WARNPRINT(("Invalid SetBrightness buffer (status=%x,Buff=%p).\n",
                                   status, SetBrightness));
                    }

                    if (NT_SUCCESS(status))
                    {
                        status = SetBackLightBrightness(
                                    devext,
                                    &SetBrightness->Brightness,
                                    SetBrightness->fSaveSettings);
                    }
                }
                break;

#ifdef SYSACC
            case IOCTL_SYSACC_MEM_REQUEST:
                status = STATUS_NOT_SUPPORTED;
                break;

            case IOCTL_SYSACC_IO_REQUEST:
                status = STATUS_NOT_SUPPORTED;
                break;

            case IOCTL_SYSACC_PCICFG_REQUEST:
                status = STATUS_NOT_SUPPORTED;
                break;

            case IOCTL_SYSACC_SMBUS_REQUEST:
                if ((irpsp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(SMB_REQUEST)) ||
                    (irpsp->Parameters.DeviceIoControl.OutputBufferLength <
                     sizeof(SMB_REQUEST)))
                {
                    status = STATUS_BUFFER_TOO_SMALL;
                    WARNPRINT(("SMBusRequest buffer too small (len=%d,required=%d).\n",
                               irpsp->Parameters.DeviceIoControl.InputBufferLength,
                               sizeof(SMB_REQUEST)));
                }
                else
                {
                    PSMB_REQUEST SmbReqIn = (PSMB_REQUEST)
                        Irp->AssociatedIrp.SystemBuffer;
                    PSMB_REQUEST SmbReqOut = (PSMB_REQUEST)
                        Irp->UserBuffer;

                    try
                    {
                        ProbeForWrite(SmbReqOut,
                                      sizeof(*SmbReqOut),
                                      sizeof(UCHAR));
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        status = GetExceptionCode();
                        WARNPRINT(("Invalid SMBRequest buffer (status=%x,Buff=%p).\n",
                                   status, SmbReqOut));
                    }

                    if (NT_SUCCESS(status))
                    {
                        status = SMBRequest(devext, SmbReqIn);
                        if (NT_SUCCESS(status))
                        {
                            RtlCopyMemory(SmbReqOut,
                                          SmbReqIn,
                                          sizeof(*SmbReqOut));
                            Irp->IoStatus.Information = sizeof(*SmbReqOut);
                        }
                    }
                }
                break;
#endif

            default:
                WARNPRINT(("unsupported ioctl code (ioctl=%s)\n",
                           LookupName(irpsp->Parameters.DeviceIoControl.IoControlCode,
                                      IoctlNames)));
                status = STATUS_NOT_SUPPORTED;
                break;
        }
        IoReleaseRemoveLock(&devext->RemoveLock, Irp);
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    EXIT(1, ("=%x\n", status));
    return status;
}       //SmbLiteIoctl

/*++
    @doc    INTERNAL

    @func   NTSTATUS | GetBackLightBrightness |
            Query the Backlight brightness via the SMBus driver.

    @parm   IN PSMBLITE_DEVEXT | devext | Points to the device extension.
    @parm   OUT PSMBLITE_BRIGHTNESS | Brightness | To hold the brightness value.

    @rvalue Always returns STATUS_SUCCESS
--*/

NTSTATUS INTERNAL
GetBackLightBrightness(
    IN  PSMBLITE_DEVEXT     devext,
    OUT PSMBLITE_BRIGHTNESS Brightness
    )
{
    PROCNAME("GetBackLightBrightness")

    PAGED_CODE();
    ENTER(2, ("(devext=%p,Brightness=%p)\n", devext, Brightness));

    *Brightness = devext->BackLightBrightness;

    EXIT(2, ("=%x (ACValue=%d,DCValue=%d)\n",
             STATUS_SUCCESS, Brightness->bACValue, Brightness->bDCValue));
    return STATUS_SUCCESS;
}       //GetBackLightBrightness

/*++
    @doc    INTERNAL

    @func   NTSTATUS | SetBackLightBrightness |
            Set the Backlight brightness via the SMBus driver.

    @parm   IN PSMBLITE_DEVEXT | devext | Points to the device extension.
    @parm   IN PSMBLITE_BRIGHTNESS | Brightness | The backlight brightness
            values.
    @parm   IN BOOL | fSaveSettings | TRUE if need to save setting in the
            registry.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS INTERNAL
SetBackLightBrightness(
    IN PSMBLITE_DEVEXT     devext,
    IN PSMBLITE_BRIGHTNESS Brightness,
    IN BOOLEAN             fSaveSettings
    )
{
    PROCNAME("SetBackLightBrightness")
    NTSTATUS status;
    SMB_REQUEST SmbReq;
    UCHAR bBrightness;

    ENTER(2, ("(devext=%p,Brightness=%p,fSave=%x,ACValue=%d,DCValue=%d)\n",
              devext, Brightness, fSaveSettings, Brightness->bACValue,
              Brightness->bDCValue));

    //
    // Note: this routine must not be pageable because it could be called
    // by PowerStateCallbackProc which could be called at DPC.
    //
    bBrightness = (devext->dwfSmbLite & SMBLITEF_SYSTEM_ON_AC)?
                    Brightness->bACValue: Brightness->bDCValue;
    DBGPRINT(1, ("Set Brightness level=%d (%s).\n",
                 bBrightness,
                 (devext->dwfSmbLite & SMBLITEF_SYSTEM_ON_AC)? "AC": "DC"));
    SmbReq.Protocol = SMB_WRITE_BYTE;
    SmbReq.Address = SMBADDR_BACKLIGHT;
    SmbReq.Command = SMBCMD_BACKLIGHT_NORMAL;
    SmbReq.Data[0] = (UCHAR)(bBrightness << 2);
    status = SMBRequest(devext, &SmbReq);

    if (NT_SUCCESS(status))
    {
        devext->BackLightBrightness = *Brightness;
        if (fSaveSettings)
        {
            RegSetDeviceParam(devext->PDO,
                              gcwstrACBrightness,
                              &Brightness->bACValue,
                              sizeof(Brightness->bACValue));
            RegSetDeviceParam(devext->PDO,
                              gcwstrDCBrightness,
                              &Brightness->bDCValue,
                              sizeof(Brightness->bDCValue));
        }
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //SetBackLightBrightness

/*++
    @doc    INTERNAL

    @func   NTSTATUS | SMBRequest |
            Make a request to the SMBus driver.

    @parm   IN PSMBLITE_DEVEXT | devext | Points to the device extension.
    @parm   IN OUT PSMB_REQUEST | SmbReq | Points to the SMB request.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS INTERNAL
SMBRequest(
    IN     PSMBLITE_DEVEXT devext,
    IN OUT PSMB_REQUEST    SmbReq
    )
{
    PROCNAME("SMBRequest")
    NTSTATUS status;
    PIRP irp;
    KEVENT Event;
    IO_STATUS_BLOCK iosb;

    ENTER(2, ("(devext=%p,Req=%p,Protocol=%s,Addr=%x,Cmd=%x,Data0=%x,Data1=%x)\n",
              devext, SmbReq, LookupName(SmbReq->Protocol, ProtocolNames),
              SmbReq->Address, SmbReq->Command, SmbReq->Data[0],
              SmbReq->Data[1]));

    //
    // Note: this routine must not be pageable because it could be called
    // by SetBackLightBrightness and then PowerStateCallbackProc which could
    // be called at DPC.
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(SMB_BUS_REQUEST,
                                        devext->L