ppns,
                          DWORD dwfNS)
{
    int rc = ASLERR_NONE;
    PSZ psz;

    ENTER((1, "GetNameSpaceObj(ObjPath=%s,Scope=%s,ppns=%p,Flags=%x)\n",
           pszObjPath, pnsScope? GetObjectPath(pnsScope): "", ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = gpnsNameSpaceRoot;
    }
    else
    {
        psz = pszObjPath;

        while ((*psz == '^') && (pnsScope != NULL))
        {
            psz++;
            pnsScope = pnsScope->pnsParent;
        }
    }

    *ppns = pnsScope;

    if (pnsScope == NULL)
        rc = ASLERR_NSOBJ_NOT_FOUND;
    else if (*psz != '\0')
    {
        BOOL fSearchUp;
        PNSOBJ pns;

        fSearchUp = !(dwfNS & NSF_LOCAL_SCOPE) &&
                    (pszObjPath[0] != '\\') &&
                    (pszObjPath[0] != '^') &&
                    (strlen(pszObjPath) <= sizeof(NAMESEG));

        for (;;)
        {
            do
            {
                if ((pns = pnsScope->pnsFirstChild) == NULL)
                    rc = ASLERR_NSOBJ_NOT_FOUND;
                else
                {
                    BOOL fFound;
                    PSZ pszEnd;
                    DWORD dwLen;
                    NAMESEG dwName;

                    if ((pszEnd = strchr(psz, '.')) != NULL)
                        dwLen = (DWORD)(pszEnd - psz);
                    else
                        dwLen = strlen(psz);

                    if (dwLen > sizeof(NAMESEG))
                    {
                        ERROR(("GetNameSpaceObj: invalid name - %s",
                               pszObjPath));
                        rc = ASLERR_INVALID_NAME;
                        fFound = FALSE;
                    }
                    else
                    {
                        dwName = NAMESEG_BLANK;
                        memcpy(&dwName, psz, dwLen);
                        //
                        // Search all siblings for a matching NameSeg.
                        //
                        fFound = FALSE;
                        do
                        {
                            if (pns->dwNameSeg == dwName)
                            {
                                pnsScope = pns;
                                fFound = TRUE;
                                break;
                            }
                            pns = (PNSOBJ)pns->list.plistNext;
                        } while (pns != pns->pnsParent->pnsFirstChild);
                    }

                    if (rc == ASLERR_NONE)
                    {
                        if (!fFound)
                            rc = ASLERR_NSOBJ_NOT_FOUND;
                        else
                        {
                            psz += dwLen;
                            if (*psz == '.')
                            {
                                psz++;
                            }
                            else if (*psz == '\0')
                            {
                                *ppns = pnsScope;
                                break;
                            }
                        }
                    }
                }
            } while (rc == ASLERR_NONE);

            if ((rc == ASLERR_NSOBJ_NOT_FOUND) && fSearchUp &&
                (pnsScope != NULL) && (pnsScope->pnsParent != NULL))
            {
                pnsScope = pnsScope->pnsParent;
                rc = ASLERR_NONE;
            }
            else
            {
                break;
            }
        }
    }

    if (rc != ASLERR_NONE)
    {
        *ppns = NULL;
    }

    EXIT((1, "GetNameSpaceObj=%d (pns=%p)\n", rc, *ppns));
    return rc;
}       //GetNameSpaceObj

/***LP  CreateNameSpaceObj - Create a name space object under current scope
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> name path string
 *      pnsScope -> scope to start the search (NULL means root)
 *      pnsOwner -> owner object
 *      ppns -> to hold the nsobj pointer found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateNameSpaceObj(PTOKEN ptoken, PSZ pszName, PNSOBJ pnsScope,
                             PNSOBJ pnsOwner, PPNSOBJ ppns, DWORD dwfNS)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;
  #ifndef _UNASM_LIB
    char szMsg[MAX_MSG_LEN + 1];
  #endif

    ENTER((1, "CreateNameSpaceObj(ptoken=%p,Name=%s,pnsScope=%s,pnsOwner=%p,ppns=%p,Flags=%x)\n",
           ptoken, pszName, pnsScope? GetObjectPath(pnsScope): "", pnsOwner,
           ppns, dwfNS));

  #ifdef _UNASM_LIB
    DEREF(ptoken);
  #endif

    ASSERT((pszName != NULL) && (*pszName != '\0'));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if ((rc = GetNameSpaceObj(pszName, pnsScope, &pns, NSF_LOCAL_SCOPE)) ==
        ASLERR_NONE)
    {
        if (!(dwfNS & NSF_EXIST_OK))
        {
          #ifndef _UNASM_LIB
            if (ptoken != NULL)
            {
                sprintf(szMsg, "%s already exist", pszName);
                PrintTokenErr(ptoken, szMsg, dwfNS & NSF_EXIST_ERR);
            }
            else
            {
                ERROR(("%s: error: %s already exist",
                       gpszASLFile? gpszASLFile: gpszAMLFile, pszName));
            }
          #endif
            rc = ASLERR_NSOBJ_EXIST;
        }
    }
    else if (rc == ASLERR_NSOBJ_NOT_FOUND)
    {
        rc = ASLERR_NONE;
        //
        // Are we creating root?
        //
        if (strcmp(pszName, "\\") == 0)
        {
            ASSERT(gpnsNameSpaceRoot == NULL);
            ASSERT(pnsOwner == NULL);

            if ((pns = MEMALLOC(sizeof(NSOBJ))) == NULL)
            {
                ERROR(("CreateNameSpaceObj: fail to allocate name space object"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                memset(pns, 0, sizeof(NSOBJ));
                pns->dwNameSeg = NAMESEG_ROOT;
                pns->hOwner = (HANDLE)pnsOwner;
                gpnsNameSpaceRoot = pns;
            }
        }
        else
        {
            PSZ psz;
            PNSOBJ pnsParent;

            if ((psz = strrchr(pszName, '.')) != NULL)
            {
                *psz = '\0';
                psz++;
                if ((rc = GetNameSpaceObj(pszName, pnsScope, &pnsParent,
                                          NSF_LOCAL_SCOPE)) ==
                    ASLERR_NSOBJ_NOT_FOUND)
                {
                  #ifndef _UNASM_LIB
                    if (ptoken != NULL)
                    {
                        sprintf(szMsg, "parent object %s does not exist",
                                pszName);
                        PrintTokenErr(ptoken, szMsg, TRUE);
                    }
                    else
                    {
                        ERROR(("%s: error: parent object %s does not exist",
                               gpszASLFile? gpszASLFile: gpszAMLFile, pszName));
                    }
                  #endif
                }
            }
            else if (*pszName == '\\')
            {
                psz = &pszName[1];
                //
                // By this time, we'd better created root already.
                //
                ASSERT(gpnsNameSpaceRoot != NULL);
                pnsParent = gpnsNameSpaceRoot;
            }
            else if (*pszName == '^')
            {
                psz = pszName;
                pnsParent = pnsScope;
                while ((*psz == '^') && (pnsParent != NULL))
                {
                    pnsParent = pnsParent->pnsParent;
                    psz++;
                }
            }
            else
            {
                ASSERT(pnsScope != NULL);
                psz = pszName;
                pnsParent = pnsScope;
            }

            if (rc == ASLERR_NONE)
            {
                int iLen = strlen(psz);

                if ((*psz != '\0') && (iLen > sizeof(NAMESEG)))
                {
                    ERROR(("CreateNameSpaceObj: invalid name - %s", psz));
                    rc = ASLERR_INVALID_NAME;
                }
                else if ((pns = MEMALLOC(sizeof(NSOBJ))) == NULL)
                {
                    ERROR(("CreateNameSpaceObj: fail to allocate name space object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memset(pns, 0, sizeof(NSOBJ));
                    pns->dwNameSeg = NAMESEG_BLANK;
                    memcpy(&(pns->dwNameSeg), psz, iLen);
                    pns->hOwner = (HANDLE)pnsOwner;
                    pns->pnsParent = pnsParent;
                    ListInsertTail(&pns->list,
                                   (PPLIST)&pnsParent->pnsFirstChild);
                }
            }
        }
    }

    if ((rc == ASLERR_NONE) && (ppns != NULL))
        *ppns = pns;

    EXIT((1, "CreateNameSpaceObj=%d (pns=%p)\n", rc, pns));
    return rc;
}       //CreateNameSpaceObj

/***LP  DumpNameSpacePaths - Dump all the name space object paths
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      pfileOut -> output device
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNameSpacePaths(PNSOBJ pnsObj, FILE *pfileOut)
{
    PNSOBJ pns, pnsNext;

    ENTER((3, "DumpNameSpacePaths(pns=%x,pfileOut=%p)\n", pnsObj, pfileOut));
    //
    // First, dump myself
    //
    fprintf(pfileOut, "%13s: [%08x] %s",
            GetObjectTypeName(pnsObj->ObjData.dwDataType), pnsObj->dwRefCount,
            GetObjectPath(pnsObj));

    if (pnsObj->ObjData.dwDataType == OBJTYPE_METHOD)
    {
        fprintf(pfileOut, " (cArgs=%d)", pnsObj->ObjData.uipDataValue);
    }
    else if (pnsObj->ObjData.dwDataType == OBJTYPE_RES_FIELD)
    {
        fprintf(pfileOut, " (BitOffset=0x%x, BitSize=0x%x)",
                pnsObj->ObjData.uipDataValue, pnsObj->ObjData.dwDataLen);
    }

    fprintf(pfileOut, "%s\n", pnsObj->hOwner? "*": "");

    //
    // Then, recursively dump each of my children
    //
    for (pns = pnsObj->pnsFirstChild; pns != NULL; pns = pnsNext)
    {
        //
        // If this is the last child, we have no more.
        //
        if ((pnsNext = (PNSOBJ)pns->list.plistNext) == pnsObj->pnsFirstChild)
            pnsNext = NULL;
        //
        // Dump a child
        //
        DumpNameSpacePaths(pns, pfileOut);
    }

    EXIT((3, "DumpNameSpacePaths!\n"));
}       //DumpNameSpacePaths

/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PNSOBJ pns)
{
    static char szPath[MAX_NSPATH_LEN + 1] = {0};
    int i;

    ENTER((4, "GetObjectPath(pns=%x)\n", pns));

    if (pns != NULL)
    {
        if (pns->pnsParent == NULL)
            strcpy(szPath, "\\");
        else
        {
            GetObjectPath(pns->pnsParent);
            if (pns->pnsParent->pnsParent != NULL)
            {
                strcat(szPath, ".");
            }
            strncat(szPath, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
        }


        for (i = strlen(szPath) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }

    EXIT((4, "GetObjectPath=%s\n", szPath));
    return szPath;
}       //GetObjectPath

/***LP  GetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetObjectTypeName(DWORD dwObjType)
{
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER((4, "GetObjectTypeName(Type=%x)\n", dwObjType));

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    EXIT((4, "GetObjectTypeName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetObjectTypeName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\basedef.h ===
/*** basedef.h - Basic definitions
 *
 *  Copyright (c) 1989,1992,1993 Microsoft Corporation
 *  Author:     Michael Tsang (MTS)
 *  Created     01/06/89
 *
 *  This module contains basic constants and types
 *
 *  MODIFICATION HISTORY
 */

#pragma warning (disable: 4001)

/***    Commonly used constants
 */

#ifndef NULL
#define NULL            0
#endif

#ifndef FALSE
#define FALSE           0
#endif

#ifndef TRUE
#define TRUE            1
#endif

#define CDECL           __cdecl
#define PASCAL          __pascal

#if defined(IS_32) || defined(_WIN32_WINNT)
#define FAR
#define NEAR
#else
#define FAR             __far
#define NEAR            __near
#endif

/***    Base type declarations
 */

typedef void             VOID;
typedef char             CHAR;          //ch
typedef unsigned char    UCHAR;         //uch
typedef int              INT;           //i
typedef unsigned int     UINT;          //ui
typedef short            SHORT;         //s
typedef unsigned short   USHORT;        //us
typedef long             LONG;          //l
typedef unsigned long    ULONG;         //ul
typedef __int64          LONGLONG;      //ll
typedef unsigned __int64 ULONGLONG;     //ull
typedef ULONG            ULONG_PTR;     //uip

typedef UCHAR           BYTE;           //b
typedef USHORT          WORD;           //w
typedef ULONG           DWORD;          //dw
typedef ULONGLONG	QWORD;		//qw

typedef UINT            BOOL;           //f
typedef UCHAR           BBOOL;          //bf
typedef USHORT          SBOOL;          //sf
typedef ULONG           LBOOL;          //lf
typedef ULONG           FLAGS;          //fl
#if defined(_WIN64)
typedef unsigned __int64 HANDLE;        //h
#else
typedef ULONG           HANDLE;         //h
#endif

/***    Pointer types to base types declarations
 */

typedef VOID *          PVOID;          //pv
typedef VOID FAR *      LPVOID;         //lpv
typedef CHAR *          PCHAR;          //pch
typedef CHAR FAR *      LPCHAR;         //lpch
typedef UCHAR *         PUCHAR;         //puch
typedef UCHAR FAR *     LPUCHAR;        //lpuch
typedef INT *           PINT;           //pi
typedef INT FAR *       LPINT;          //lpi
typedef UINT *          PUINT;          //pui
typedef UINT FAR *      LPUINT;         //lpui
typedef SHORT *         PSHORT;         //ps
typedef SHORT FAR *     LPSHORT;        //lps
typedef USHORT *        PUSHORT;        //pus
typedef USHORT FAR *    LPUSHORT;       //lpus
typedef LONG *          PLONG;          //pl
typedef LONG FAR *      LPLONG;         //lpl
typedef ULONG *         PULONG;         //pul
typedef ULONG FAR *     LPULONG;        //lpul

typedef BYTE *          PBYTE;          //pb
typedef BYTE FAR *      LPBYTE;         //lpb
typedef WORD *          PWORD;          //pw
typedef WORD FAR *      LPWORD;         //lpw
typedef DWORD *         PDWORD;         //pdw
typedef DWORD FAR *     LPDWORD;        //lpdw

typedef BOOL *          PBOOL;          //pf
typedef BOOL FAR *      LPBOOL;         //lpf
typedef BBOOL *         PBBOOL;         //pbf
typedef BBOOL FAR *     LPBBOOL;        //lpbf
typedef SBOOL *         PSBOOL;         //psf
typedef SBOOL FAR *     LPSBOOL;        //lpsf
typedef LBOOL *         PLBOOL;         //plf
typedef LBOOL FAR *     LPLBOOL;        //lplf
typedef FLAGS *         PFLAGS;         //pfl
typedef FLAGS FAR *     LPFLAGS;        //lpfl

/***    Double indirection pointer types to base types declarations
 */

typedef PVOID *         PPVOID;         //ppv
typedef PVOID FAR *     LPPVOID;        //lppv

/***    Other common types (and their pointers)
 */

typedef CHAR *          PSZ;            //psz
typedef CHAR FAR *      LPSZ;           //lpsz
typedef CHAR FAR *      LPSTR;          //lpstr

/***    Constants
 */

#define MAX_BYTE        0xff
#define MAX_WORD        0xffff
#define MAX_DWORD       0xffffffff

/***    Macros
 */

#define DEREF(x)        ((x) = (x))
#define EXPORT          CDECL
#define LOCAL           CDECL
#define BYTEOF(d,i)     (((BYTE *)&(d))[i])
#define WORDOF(d,i)     (((WORD *)&(d))[i])

//
// EFNfix:  This is a slimy hack to include acpitabl.h, why are we not using
// standard types ?
//
typedef BOOL BOOLEAN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\asl.c ===
/*** asl.c - Main module of the ASL assembler
 *
 *  This program compiles the ASL language into AML (p-code).
 *
 *  Copyright (c) 1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     07/23/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  main - main program
 *
 *  ENTRY
 *      icArg - command line arguments count
 *      apszArg - command line arguments array
 *
 *  EXIT-SUCCESS
 *      program terminates with return code ASLERR_NONE
 *  EXIT-FAILURE
 *      program terminates with negative error code
 */

int EXPORT main(int icArg, char **apszArg)
{
    int rc = ASLERR_NONE;

    ParseProgInfo(apszArg[0], &ProgInfo);
    icArg--;
    apszArg++;

    if ((ParseSwitches(&icArg, &apszArg, ArgTypes, &ProgInfo) != ARGERR_NONE) ||
        (gpszTabSig == NULL) && ((icArg != 1) || (gdwfASL & ASLF_CREAT_BIN)) ||
        (gpszTabSig != NULL) && ((icArg != 0) || (gdwfASL & ASLF_UNASM)))
    {
        MSG(("invalid command line options"));
        PrintUsage();
        rc = ASLERR_INVALID_PARAM;
    }
    else
    {
      #ifdef __UNASM
        PBYTE pbTable = NULL;
        DWORD dwTableSig = 0;
        PSZ psz;
      #endif

        OPENTRACE(gpszTraceFile);
        PrintLogo();

        if ((rc = InitNameSpace()) == ASLERR_NONE)
        {
          #ifdef __UNASM
          #pragma message("Building with __UNASM option\r\n")

            if (gdwfASL & ASLF_DUMP_BIN)
            {
                if (((rc = ReadBinFile(*apszArg, &pbTable, &dwTableSig)) ==
                     ASLERR_NONE) &&
                    (gpszLSTFile == NULL))
                {
                    strncpy(gszLSTName, (PSZ)&dwTableSig, sizeof(DWORD));
                    strcpy(&gszLSTName[sizeof(DWORD)], ".TXT");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_DUMP_NONASL | ASLF_UNASM;
                }
            }
            else if (gdwfASL & ASLF_UNASM)
            {
                gpszAMLFile = *apszArg;
                if (gpszLSTFile == NULL)
                {
                    strncpy(gszLSTName, gpszAMLFile, _MAX_FNAME - 1);
                    if ((psz = strchr(gszLSTName, '.')) != NULL)
                    {
                        *psz = '\0';
                    }
                    strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_GENSRC;
                }
            }
            else if (gpszTabSig != NULL)
            {
                gdwfASL |= ASLF_UNASM;
                if (IsWinNT())
                {
                    gdwfASL |= ASLF_NT;
                }

                _strupr(gpszTabSig);
                if ((strcmp(gpszTabSig, "DSDT") != 0) &&
                    (strcmp(gpszTabSig, "SSDT") != 0) &&
                    (strcmp(gpszTabSig, "PSDT") != 0))
                {
                    gdwfASL |= ASLF_DUMP_NONASL;
                }

                if (gpszLSTFile == NULL)
                {
                    gpszLSTFile = gszLSTName;
                    if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        if (strcmp(gpszTabSig, "*") == 0)
                        {
                            strcpy(gszLSTName, "ACPI");
                        }
                        else
                        {
                            strcpy(gszLSTName, gpszTabSig);
                        }
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".TXT");
                    }
                    else
                    {
                        strcpy(gszLSTName, gpszTabSig);
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                        gdwfASL |= ASLF_GENSRC;
                    }
                }

              #ifndef WINNT
                if (!(gdwfASL & ASLF_NT) && ((ghVxD = OpenVxD()) == NULL))
                {
                    rc = ASLERR_OPEN_VXD;
                }
              #endif
            }
            else
            {
          #endif
                rc = ParseASLFile(*apszArg);
          #ifdef __UNASM
            }
          #endif
        }

        if (rc == ASLERR_NONE)
        {
            FILE *pfileOut;

            if (!(gdwfASL & ASLF_DUMP_NONASL))
            {
                if (gpszAMLFile == NULL)
                {
                    if (gpszTabSig == NULL)
                    {
                        ERROR(("%s has no DefinitionBlock", *apszArg));
                    }
                    else
                    {
                        strcpy(gszAMLName, gpszTabSig);
                        strcat(gszAMLName, ".AML");
                    }
                }

                if (gpszASMFile != NULL)
                {
                    if ((pfileOut = fopen(gpszASMFile, "w")) == NULL)
                    {
                        ERROR(("failed to open ASM file - %s", gpszASMFile));
                    }
                    else
                    {
                        gdwfASL |= ASLF_GENASM;
                        UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                  (PFNPRINT)fprintf, pfileOut);
                        gdwfASL &= ~ASLF_GENASM;
                        fclose(pfileOut);
                    }
                }
            }

            if (gpszLSTFile != NULL)
            {
              #ifdef __UNASM
                if (gdwfASL & ASLF_CREAT_BIN)
                {
                    rc = DumpTableBySig(NULL, *((PDWORD)gpszTabSig));
                }
                else if ((pfileOut = fopen(gpszLSTFile, "w")) == NULL)
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
                else
                {
                    if (gdwfASL & ASLF_DUMP_BIN)
                    {
                        ASSERT(pbTable != NULL);
                        ASSERT(dwTableSig != 0);
                        rc = DumpTable(pfileOut, pbTable, 0, dwTableSig);
                        MEMFREE(pbTable);
                    }
                    else if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        DWORD dwAddr;

                        if (((dwAddr = strtoul(gpszTabSig, &psz, 16)) != 0) &&
                            (*psz == 0))
                        {
                            rc = DumpTableByAddr(pfileOut, dwAddr);
                        }
                        else
                        {
                            rc = DumpTableBySig(pfileOut, *((PDWORD)gpszTabSig));
                        }
                    }
                    else
                    {
                        rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                       (PFNPRINT)fprintf, pfileOut);
                    }
                    fclose(pfileOut);
                }
              #else
                if ((pfileOut = fopen(gpszLSTFile, "w")) != NULL)
                {
                    rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                   (PFNPRINT)fprintf, pfileOut);
                    fclose(pfileOut);
                }
                else
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
              #endif
            }

            if (gpszNSDFile != NULL)
            {
                if ((pfileOut = fopen(gpszNSDFile, "w")) == NULL)
                {
                    ERROR(("failed to open NameSpace dump file - %s",
                           gpszNSDFile));
                }
                else
                {
                    fprintf(pfileOut, "Name Space Objects:\n");
                    DumpNameSpacePaths(gpnsNameSpaceRoot, pfileOut);
                    fclose(pfileOut);
                }
            }
        }

      #ifdef __UNASM
      #ifndef WINNT
        if (ghVxD != NULL)
        {
            CloseVxD(ghVxD);
            ghVxD = NULL;
        }
      #endif
      #endif

        CLOSETRACE();
    }

    return rc;
}       //main

#ifdef __UNASM
/***LP  ReadBinFile - Read table from binary file
 *
 *  ENTRY
 *      pszFile -> binary file name
 *      ppb -> to hold the binary buffer pointer
 *      pdwTableSig -> to hold the table signature
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig)
{
    int rc = ASLERR_NONE;
    FILE *pfileBin;
    DESCRIPTION_HEADER dh;

    ENTER((1, "ReadBinFile(File=%s,ppb=%p,pdwTableSig=%p)\n",
           pszFile, ppb, pdwTableSig));

    if ((pfileBin = fopen(pszFile, "rb")) == NULL)
    {
        ERROR(("ReadBinFile: failed to open file %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else if (fread(&dh, 1, sizeof(dh), pfileBin) < 2*sizeof(DWORD))
    {
        ERROR(("ReadBinFile: failed to read file %s", pszFile));
        rc = ASLERR_READ_FILE;
    }
    else if (fseek(pfileBin, 0, SEEK_SET) != 0)
    {
        ERROR(("ReadBinFile: failed to reset file %s", pszFile));
        rc = ASLERR_SEEK_FILE;
    }
    else
    {
        DWORD dwLen = (dh.Signature == SIG_LOW_RSDP)? sizeof(RSDP): dh.Length;

        if ((*ppb = MEMALLOC(dwLen)) == NULL)
        {
            ERROR(("ReadBinFile: failed to allocate table buffer for %s",
                   pszFile));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (fread(*ppb, dwLen, 1, pfileBin) != 1)
        {
            MEMFREE(*ppb);
            *ppb = NULL;
            ERROR(("ReadBinFile: failed to read file %s", pszFile));
            rc = ASLERR_READ_FILE;
        }
        else if (dh.Signature == SIG_LOW_RSDP)
        {
            *pdwTableSig = SIG_RSDP;
        }
        else
        {
            *pdwTableSig = dh.Signature;
        }
    }

    if (pfileBin != NULL)
    {
        fclose(pfileBin);
    }

    EXIT((1, "ReadBinFile=%d (pbTable=%p,TableSig=%s)\n",
          rc, *ppb, GetTableSigStr(*pdwTableSig)));
    return rc;
}       //ReadBinFile
#endif

/***LP  PrintLogo - Print logo message
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintLogo(VOID)
{
    if ((gdwfASL & ASLF_NOLOGO) == 0)
    {
        printf("%s Version %d.%d.%d%s [%s, %s]\n%s\n",
               STR_PROGDESC, VERSION_MAJOR, VERSION_MINOR, VERSION_RELEASE,
             #ifdef WINNT
               "NT",
	     #else
	       "",
	     #endif
               __DATE__, __TIME__, STR_COPYRIGHT);
	printf("Compliant with ACPI 1.0 specification\n\n");
    }
}       //PrintLogo

/***LP  PrintHelp - Print help messages
 *
 *  ENTRY
 *      ppszArg -> pointer to argument (not used)
 *      pAT -> argument type structure (not used)
 *
 *  EXIT
 *      program terminated with exit code 0
 */

int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT)
{
    DEREF(ppszArg);
    DEREF(pAT);

    PrintLogo();
    PrintUsage();
    printf("\t?            - Print this help message.\n");
    printf("\tnologo       - Supress logo banner.\n");
    printf("\tFo=<AMLFile> - Override the AML file name in the DefinitionBlock.\n");
    printf("\tFa=<ASMFile> - Generate .ASM file with the name <ASMFile>.\n");
    printf("\tFl=<LSTFile> - Generate .LST file with the name <LSTFile>.\n");
    printf("\tFn=<NSDFile> - Generate NameSpace Dump file with the name <NSDFile>.\n");
  #ifdef __UNASM
    printf("\td            - Dump the binary file in text form.\n");
    printf("\tu            - Unassemble AML file to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\ttab=<TabSig> - Unassemble ASL table to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\t               Dump non ASL table to an .TXT file.\n");
    printf("\t               If <TabSig> is '*', all tables are dump to ACPI.TXT.\n");
    printf("\t               <TabSig> can also be the physical address of the table.\n");
    printf("\tc            - Create binary files from tables.\n");
  #endif
  #ifdef TRACING
    printf("\tt=<n>        - Enable tracing at trace level n.\n");
    printf("\tl=<LogFile>  - Overriding the default trace log file name.\n");
  #endif
    exit(0);

    return ASLERR_NONE;
}       //PrintHelp

/***LP  PrintUsage - Print program usage syntax
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintUsage(VOID)
{
    printf("Usage:\n%s /?\n", MODNAME);
  #ifdef __UNASM
    printf("%s [/nologo] /d <BinFile>\n", MODNAME);
    printf("%s [/nologo] /u [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <AMLFile>\n",
           MODNAME);
    printf("%s [/nologo] /tab=<TabSig> [/c] [/Fa=<ASMfile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>]\n",
           MODNAME);
  #endif
  #ifdef TRACING
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] [/t=<n>] [/l=<LogFile>] <ASLFile>\n",
           MODNAME);
  #else
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <ASLFile>\n",
           MODNAME);
  #endif
  printf("\n");
}       //PrintUsage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\aslp.h ===
/*** aslp.h - ASL Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ASLP_H
#define _ASLP_H

/*** Constants
 */

// String constants
#define STR_PROGDESC            "ACPI Source Language Assembler"
#define STR_COPYRIGHT           "Copyright (c) 1996,1999 Microsoft Corporation"
#define STR_MS          "MSFT"

// Error codes
#define ASLERR_NONE             0
#define ASLERR_INVALID_PARAM    -1
#define ASLERR_OPEN_FILE        -2
#define ASLERR_CREATE_FILE      -3
#define ASLERR_READ_FILE        -4
#define ASLERR_WRITE_FILE       -5
#define ASLERR_SEEK_FILE        -6
#define ASLERR_INIT_SCANNER     -7
#define ASLERR_OUT_OF_MEM       -8
#define ASLERR_NAME_TOO_LONG    -9
#define ASLERR_NEST_DDB         -10
#define ASLERR_SYNTAX           -11
#define ASLERR_PKTLEN_TOO_LONG  -12
#define ASLERR_NAME_EXIST       -13
#define ASLERR_NSOBJ_EXIST      -14
#define ASLERR_NSOBJ_NOT_FOUND  -15
#define ASLERR_INVALID_NAME     -16
#define ASLERR_INTERNAL_ERROR   -17
#define ASLERR_INVALID_EISAID   -18
#define ASLERR_EXPECT_EOF       -19
#define ASLERR_INVALID_OPCODE   -20
#define ASLERR_SIG_NOT_FOUND    -21
#define ASLERR_GET_TABLE        -22
#define ASLERR_CHECKSUM         -23
#define ASLERR_INVALID_ARGTYPE  -24
#define ASLERR_INVALID_OBJTYPE  -25
#define ASLERR_OPEN_VXD         -26

// Misc. constants
#define VERSION_MAJOR           1
#define VERSION_MINOR           0
#define VERSION_RELEASE         13
#define VERSION_DWORD           ((VERSION_MAJOR << 24) | \
                                 (VERSION_MINOR << 16) | \
                                 VERSION_RELEASE)

// Implementation constants
#define MAX_STRING_LEN          199
#define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
#define MAX_MSG_LEN             127
#define MAX_PACKAGE_LEN         0x0fffffff

// gdwfASL flags
#define ASLF_NOLOGO             0x00000001
#define ASLF_UNASM              0x00000002
#define ASLF_GENASM             0x00000004
#define ASLF_GENSRC             0x00000008
#define ASLF_NT                 0x00000010
#define ASLF_DUMP_NONASL        0x00000020
#define ASLF_DUMP_BIN           0x00000040
#define ASLF_CREAT_BIN          0x00000080

// Code flags
#define CF_MISSING_ARG          0x00000001
#define CF_PARSING_FIXEDLIST    0x00000002
#define CF_PARSING_VARLIST      0x00000004
#define CF_CREATED_NSOBJ        0x00000008

// Data types
#define CODETYPE_UNKNOWN        0
#define CODETYPE_ASLTERM        1
#define CODETYPE_NAME           2
#define CODETYPE_DATAOBJ        3
#define CODETYPE_FIELDOBJ       4
#define CODETYPE_INTEGER        5
#define CODETYPE_STRING         6
#define CODETYPE_KEYWORD        7
#define CODETYPE_USERTERM       8
#define CODETYPE_QWORD          9

/*** Macros
 */

#define MODNAME                 ProgInfo.pszProgName
#define ISLEADNAMECHAR(c)       (((c) >= 'A') && ((c) <= 'Z') || ((c) == '_'))
#define ISNAMECHAR(c)           (ISLEADNAMECHAR(c) || ((c) >= '0') && ((c) <= '9'))
#define OPCODELEN(d)            (((d) == OP_NONE)? 0: (((d) & 0x0000ff00)? 2: 1))
#ifdef DEBUG
  #define MEMALLOC(n)           (++gdwcMemObjs, malloc(n))
  #define MEMFREE(p)            {ASSERT(gdwcMemObjs > 0); free(p); --gdwcMemObjs;}
#else
  #define MEMALLOC(n)           malloc(n)
  #define MEMFREE(p)            free(p)
#endif

/*** Type definitions
 */

typedef struct _codeobj
{
    LIST   list;                //link to siblings
    struct _codeobj *pcParent;
    struct _codeobj *pcFirstChild;
    PNSOBJ pnsObj;
    DWORD  dwTermIndex;
    DWORD  dwfCode;
    DWORD  dwCodeType;
    DWORD  dwCodeValue;
    DWORD  dwDataLen;
    PBYTE  pbDataBuff;
    DWORD  dwCodeLen;
    BYTE   bCodeChkSum;
} CODEOBJ, *PCODEOBJ;

typedef struct _nschk
{
    struct _nschk *pnschkNext;
    char   szObjName[MAX_NSPATH_LEN + 1];
    PSZ    pszFile;
    PNSOBJ pnsScope;
    PNSOBJ pnsMethod;
    ULONG  dwExpectedType;
    ULONG  dwChkData;
    WORD   wLineNum;
} NSCHK, *PNSCHK;

typedef struct _resfield
{
    PSZ   pszName;
    DWORD dwBitOffset;
    DWORD dwBitSize;
} RESFIELD, *PRESFIELD;

#endif  //ifndef _ASLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\acpins.h ===
/*** acpins.h - ACPI NameSpace definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ACPINS_H
#define _ACPINS_H

// NS flags
#define NSF_EXIST_OK            0x00010000
#define NSF_EXIST_ERR           0x00020000

// Misc. constants
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"

//
// Local function prototypes
//
VOID LOCAL DumpNameSpacePaths(PNSOBJ pnsObj, FILE *pfileOut);
PSZ LOCAL GetObjectPath(PNSOBJ pns);
PSZ LOCAL GetObjectTypeName(DWORD dwObjType);

//
// Exported function prototypes
//
int LOCAL InitNameSpace(VOID);
int LOCAL GetNameSpaceObj(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                          DWORD dwfNS);
int LOCAL CreateNameSpaceObj(PTOKEN ptoken, PSZ pszName, PNSOBJ pnsScope,
                             PNSOBJ pnsOwner, PPNSOBJ ppns, DWORD dwfNS);

#endif  //ifndef _ACPINS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\binfmt.h ===
/*** binfmt.h - Format services definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#ifndef _BITFMT_H
#define _BITFMT_H

#ifndef ENTER
  #define ENTER(n,p)
#endif

#ifndef EXIT
  #define EXIT(n,p)
#endif

#ifndef TRACENAME
  #define TRACENAME(s)
#endif

#include <ctype.h>
#ifdef USE_CRUNTIME
    #include <stdio.h>
    #include <string.h>
    #define PRINTF		printf
    #define FPRINTF		fprintf
    #define SPRINTF             sprintf
    #define STRCPY              strcpy
    #define STRCPYN             strncpy
    #define STRCAT              strcat
    #define STRLEN              strlen
#else
  #ifdef WINAPP
    #define SPRINTF             wsprintf
    #define STRCPY              lstrcpy
    #define STRCPYN             lstrcpyn
    #define STRCAT              lstrcat
    #define STRLEN              lstrlen
  #else         //assume VxD
    #define SPRINTF             _Sprintf
    #define STRCPY(s1,s2)       _lstrcpyn(s1,s2,(DWORD)(-1))
    #define STRCPYN(s1,s2,n)    _lstrcpyn(s1,s2,(n)+1)
    #define STRCAT(s1,s2)       _lstrcpyn((s1)+_lstrlen(s1),s2,(DWORD)(-1))
    #define STRLEN              _lstrlen
  #endif
#endif

//
// Error Codes
//
#define FERR_NONE               0
#define FERR_INVALID_FORMAT     -1
#define FERR_INVALID_UNITSIZE   -2

//
// String Constants
//
#define SZ_SEP_SPACE            " "
#define SZ_SEP_TAB              "\t"
#define SZ_SEP_COMMA            ","
#define SZ_SEP_SEMICOLON        ";"
#define SZ_SEP_COLON            ":"
#define SZ_FMT_DEC              "%d"
#define SZ_FMT_HEX              "%x"
#define SZ_FMT_HEX_BYTE         "%02x"
#define SZ_FMT_HEX_WORD         "%04x"
#define SZ_FMT_HEX_DWORD        "%08lx"
#define SZ_FMT_WORDOFFSET       SZ_FMT_HEX_WORD SZ_SEP_COLON
#define SZ_FMT_DWORDOFFSET      SZ_FMT_HEX_DWORD SZ_SEP_COLON

//
// bFmtType Values
//
#define FMT_NUMBER              0
#define FMT_ENUM                1
#define FMT_BITS                2
#define FMT_STRING              3

//
// bUnitSize Values
//
#define UNIT_BYTE               sizeof(BYTE)
#define UNIT_WORD               sizeof(WORD)
#define UNIT_DWORD              sizeof(DWORD)

//
// dwfFormat Flags
//
#define FMTF_NO_EOL             0x80000000
#define FMTF_NO_INC_OFFSET      0x40000000
#define FMTF_NO_SEP             0x20000000
#define FMTF_NO_PRINT_DATA      0x10000000
#define FMTF_PRINT_OFFSET       0x08000000
#define FMTF_NO_RAW_DATA        0x04000000
#define FMTF_STR_ASCIIZ         0x00000001
#define FMTF_FIRST_FIELD        (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
				 FMTF_NO_PRINT_DATA)
#define FMTF_MIDDLE_FIELD       (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
                                 FMTF_NO_PRINT_DATA)
#define FMTF_LAST_FIELD         FMTF_NO_PRINT_DATA

//
// Structure and Type Definitions
//
typedef VOID (*LPFN)(FILE *, BYTE *, DWORD);

typedef struct fmthdr_s
{
    BYTE bFmtType;              //Format type: see FMT_*
    BYTE bUnitSize;             //Data unit size: see UNIT_*
    BYTE bUnitCnt;              //Data unit count for a format record
    DWORD dwfFormat;            //Format flags: see FMTF_*
    int iRepeatCnt;             //Repeat count for this format record
    char *pszOffsetFmt;         //Offset format
    char *pszFieldSep;          //Field separator between bUnitCnt of data
    char *pszLabel;             //LHS label
} FMTHDR, *PFMTHDR;

typedef struct fmt_s
{
    char *pszLabel;
    PFMTHDR pfmtType;
    LPFN lpfn;
} FMT, *PFMT;

typedef struct fmtnum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    char *pszNumFmt;
} FMTNUM, *PFMTNUM;

typedef struct fmtenum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    DWORD dwStartEnum;
    DWORD dwEndEnum;
    char **ppszEnumNames;
    char *pszOutOfRange;
} FMTENUM, *PFMTENUM;

typedef struct fmtbits_s
{
    FMTHDR hdr;
    DWORD dwMask;
    char **ppszOnNames;
    char **ppszOffNames;
} FMTBITS, *PFMTBITS;

typedef struct fmtstr_s
{
    FMTHDR hdr;
} FMTSTR, *PFMTSTR;

typedef struct fmtchar_s
{
    FMTHDR hdr;
} FMTCHAR, *PFMTCHAR;

//
// API Prototypes
//
#ifdef FPRINTF
int BinFPrintf(FILE *pfile, char *pszBuffer, PFMT pfmt, BYTE *pb,
	       DWORD *pdwOffset, char *pszOffsetFormat);
#endif
int BinSprintf(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);

#endif	//ifndef _BINFMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\binfmt.c ===
/*** binfmt.c - Binary Data Format services
 *
 *  This module contains format services for converting binary data into format
 *  text strings according to the format record.
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#ifdef __UNASM

#pragma warning (disable: 4001)
#include "basedef.h"
#define USE_CRUNTIME
#include "binfmt.h"

typedef int (*PFNFMT)(char *, PFMTHDR, BYTE *, DWORD *);

//Local function prototypes
int FormatNum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatEnum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatBits(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatString(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int GetData(BYTE bUnitSize, BYTE *pb, DWORD dwOffset, DWORD *pdwData);
int PrintData(char *pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace);

char szDefSep[] = SZ_SEP_SPACE;
char szDefOffsetFmt[] = SZ_FMT_WORDOFFSET;
PFNFMT FmtFuncTable[] =
{
    FormatNum,          //0: FMT_NUMBER
    FormatEnum,         //1: FMT_ENUM
    FormatBits,         //2: FMT_BITS
    FormatString,       //3: FMT_STRING
};
#define NUM_FMT_FUNCS   (sizeof(FmtFuncTable)/sizeof(PFNFMT))

#ifdef FPRINTF
/***EP  BinFPrintf - Binary fprintf
 *
 *  ENTRY
 *      pfile -> output file
 *      pszBuffer -> buffer to hold the formatted string
 *                   (if NULL, use internal buffer)
 *      pfmt -> format record array
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer (if NULL, use internal)
 *      pszOffsetFormat -> offset format string (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinFPrintf(FILE *pfile, char *pszBuffer, PFMT pfmt, BYTE *pb,
              DWORD *pdwOffset, char *pszOffsetFormat)
{
    TRACENAME("BINFPRINTF")
    int rc = FERR_NONE;
    DWORD dwOffset = 0, dwOldOffset;
    DWORD dwData;
    char szBuff[256];
    char *psz = pszBuffer? pszBuffer: szBuff;
    DWORD *pdw = pdwOffset? pdwOffset: &dwOffset;

    ENTER(4, ("BinFPrintf(pszBuff=%lx,pfmt=%lx,pdwOffset=%lx,Offset=%lx)\n",
              pszBuffer, pfmt, pdwOffset, pdwOffset? *pdwOffset: 0));

    if (pfmt != NULL)
    {
        BYTE i, j;

        for (i = 0; pfmt[i].pfmtType != NULL; ++i)
        {
            if (pfmt[i].pszLabel != NULL)
            {
                if (pszOffsetFormat != NULL)
                {
                    FPRINTF(pfile, pszOffsetFormat,
                            *pdw, pfmt[i].pfmtType->bUnitSize);
                    if (pfmt[i].pfmtType->dwfFormat & FMTF_NO_RAW_DATA)
                    {
                        FPRINTF(pfile, "        ");
                    }
                    else
                    {
                        if (GetData(pfmt[i].pfmtType->bUnitSize, pb, *pdw,
                                    &dwData) == FERR_NONE)
                        {
                            PrintData(psz, pfmt[i].pfmtType->bUnitSize, dwData,
                                      TRUE);
                            FPRINTF(pfile, psz);
                        }

                        for (j = 1; j < pfmt[i].pfmtType->bUnitCnt; ++j)
                        {
                            if (GetData(pfmt[i].pfmtType->bUnitSize, pb,
                                        *pdw + j*pfmt[i].pfmtType->bUnitSize,
                                        &dwData) == FERR_NONE)
                            {
                                FPRINTF(pfile, ",");
                                PrintData(psz, pfmt[i].pfmtType->bUnitSize,
                                          dwData, FALSE);
                                FPRINTF(pfile, psz);
                            }
                        }
                    }
                }
                if (pfmt[i].pszLabel[0] != '\0')
                    FPRINTF(pfile, ";%s", pfmt[i].pszLabel);
                else
                    FPRINTF(pfile, "\n");
            }

            dwOldOffset = *pdw;
	    if ((pfmt[i].pszLabel != NULL) && (pfmt[i].pszLabel[0] == '\0'))
	    {
                *pdw += pfmt[i].pfmtType->bUnitCnt*pfmt[i].pfmtType->bUnitSize;
	    }
            else
            {
                if (pfmt[i].pszLabel == NULL)
                    FPRINTF(pfile, ",");
                rc = BinSprintf(psz, pfmt[i].pfmtType, pb, pdw);
                if (rc == FERR_NONE)
                {
                    char *psz1, *psz2;
                    BOOL fSpace = FALSE, fInQuote = FALSE, fInString = FALSE;

                    for (psz1 = psz2 = psz; *psz2 != '\0'; ++psz2)
                    {
                        if (*psz2 == '"')
                        {
                            fSpace = FALSE;
                            fInString = ~fInString;
                            *psz1 = *psz2;
                            psz1++;
                        }
                        else if (*psz2 == '\'')
                        {
                            fSpace = FALSE;
                            fInQuote = ~fInQuote;
                            *psz1 = *psz2;
                            psz1++;
                        }
                        else if (*psz2 == ' ')
                        {
                            if (!fSpace && !fInString && !fInQuote &&
                                (psz1 != psz))
                            {
                                *psz1 = ',';
                                psz1++;
                            }
                            else if (fInString || fInQuote)
                            {
                                *psz1 = *psz2;
                                psz1++;
                            }
                            fSpace = TRUE;
                        }
                        else
                        {
                            fSpace = FALSE;
                            *psz1 = *psz2;
                            psz1++;
                        }
                    }


                    if ((psz1 > psz) && (*(psz1 - 1) == ','))
                        *(psz1 - 1) = '\0';
                    else if ((psz1 > psz) && (*(psz1 - 1) == '\n') &&
                             (*(psz1 - 2) == ','))
                    {
                        *(psz1 - 2) = '\n';
                        *(psz1 - 1) = '\0';
                    }
                    else
                        *psz1 = '\0';
                    FPRINTF(pfile, psz);
                }
            }

            if (pfmt[i].lpfn != NULL)
                (*pfmt[i].lpfn)(pfile, pb, dwOldOffset);
        }
    }

    EXIT(4, ("BinFPrintf=%d (Offset=%lx,Buff=%s)\n",
         rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinFPrintf
#endif  //ifdef FPRINTF

/***EP  BinSprintf - Binary sprintf
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold the formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinSprintf(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("BINSPRINTF")
    int rc = FERR_NONE;

    ENTER(4, ("BinSprintf(fmt=%d,Offset=%lx)\n", pfmt->bFmtType, *pdwOffset));

    if (pfmt->bFmtType >= NUM_FMT_FUNCS)
        rc = FERR_INVALID_FORMAT;
    else
    {
        int i;
        BYTE j;
        DWORD dwData;

        *pszBuffer = '\0';
        for (i = 0; (rc == FERR_NONE) && (i < pfmt->iRepeatCnt); ++i)
        {
            if (pfmt->dwfFormat & FMTF_PRINT_OFFSET)
            {
                SPRINTF(pszBuffer,
                        pfmt->pszOffsetFmt? pfmt->pszOffsetFmt: szDefOffsetFmt,
                        *pdwOffset);
            }

            if (!(pfmt->dwfFormat & FMTF_NO_PRINT_DATA) &&
                (GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData) ==
                 FERR_NONE))
            {
                PrintData(pszBuffer, pfmt->bUnitSize, dwData, FALSE);
                STRCAT(pszBuffer, ";");
            }

            if (pfmt->pszLabel)
                STRCAT(pszBuffer, pfmt->pszLabel);

            for (j = 0; (rc == FERR_NONE) && (j < pfmt->bUnitCnt); ++j)
            {
                rc = (*FmtFuncTable[pfmt->bFmtType])
                        (&pszBuffer[STRLEN(pszBuffer)], pfmt, pb, pdwOffset);

                if (rc == FERR_NONE)
                {
                    if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                    {
                        STRCAT(pszBuffer,
                               pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                    }

                    if (!(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
                        *pdwOffset += pfmt->bUnitSize;
                }
            }

            if ((rc == FERR_NONE) && !(pfmt->dwfFormat & FMTF_NO_EOL))
            {
                STRCAT(pszBuffer, "\n");
            }
        }
    }

    EXIT(4, ("BinSprintf=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinSprintf

/***LP  FormatNum - Format numbers
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatNum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATNUM")
    int rc;
    PFMTNUM pfmtNum = (PFMTNUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatNum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtNum->dwMask;
        dwData >>= pfmtNum->bShiftCnt;

        SPRINTF(&pszBuffer[STRLEN(pszBuffer)], pfmtNum->pszNumFmt, dwData);
    }

    EXIT(5, ("FormatNum=%d (Offset=%lx,Buff=%s)\n",
         rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatNum

/***LP  FormatEnum - Format enumerated values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatEnum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATENUM")
    int rc = FERR_NONE;
    PFMTENUM pfmtEnum = (PFMTENUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatEnum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtEnum->dwMask;
        dwData >>= pfmtEnum->bShiftCnt;

        if ((dwData < pfmtEnum->dwStartEnum) || (dwData > pfmtEnum->dwEndEnum))
            STRCAT(pszBuffer, pfmtEnum->pszOutOfRange);
        else
        {
            dwData -= pfmtEnum->dwStartEnum;
            STRCAT(pszBuffer, pfmtEnum->ppszEnumNames[dwData]);
        }
    }

    EXIT(5, ("FormatEnum=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatEnum

/***LP  FormatBits - Format bit values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatBits(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATBITS")
    int rc = FERR_NONE;
    PFMTBITS pfmtBits = (PFMTBITS)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatBits(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        int i, j;
        DWORD dw;

        for (i = 31, j = 0; i >= 0; --i)
        {
            dw = 1L << i;
            if (pfmtBits->dwMask & dw)
            {
                if (dwData & dw)
                {
                    if ((pfmtBits->ppszOnNames != NULL) &&
                        (pfmtBits->ppszOnNames[j] != NULL))
                    {
                        STRCAT(pszBuffer, pfmtBits->ppszOnNames[j]);
                    }
                }
                else
                {
                    if ((pfmtBits->ppszOffNames != NULL) &&
                        (pfmtBits->ppszOffNames[j] != NULL))
                    {
                        STRCAT(pszBuffer, pfmtBits->ppszOffNames[j]);
                    }
                }

                if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                {
                    STRCAT(pszBuffer,
                           pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                }

                j++;
            }
        }
    }

    EXIT(5, ("FormatBits=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatBits

/***LP  FormatString - Format string data
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatString(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATSTRING")
    int rc = FERR_NONE;

    ENTER(5, ("FormatString(Offset=%lx)\n", *pdwOffset));

    pb += *pdwOffset;
    if (pfmt->dwfFormat & FMTF_STR_ASCIIZ)
    {
        pszBuffer[0] = '"';
        STRCPY(pszBuffer + 1, (char *)pb);
        pszBuffer[STRLEN(pszBuffer)] = '"';
        if ((pfmt->bUnitSize == 0) && !(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
            *pdwOffset += STRLEN((char *)pb) + 3;
    }
    else if (pfmt->bUnitSize != 0)
    {
        if (isalnum(*pb) || (*pb == ' '))
        {
            pszBuffer[0] = '\'';
            STRCPYN(pszBuffer + 1, (char *)pb, pfmt->bUnitSize);
            pszBuffer[pfmt->bUnitSize + 1] = '\'';
            pszBuffer[pfmt->bUnitSize + 2] = '\0';
        }
        else
        {
            rc = PrintData(pszBuffer, pfmt->bUnitSize, *((PDWORD)pb), FALSE);
        }
    }

    EXIT(5, ("FormatString=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatString

/***LP  GetData - Get data of appropriate size from the binary buffer
 *
 *  ENTRY
 *      bUnitSize - size of data unit
 *      pb -> data buffer
 *      dwOffset - offset into data buffer
 *      pdwData -> to hold data
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int GetData(BYTE bUnitSize, BYTE *pb, DWORD dwOffset, DWORD *pdwData)
{
    TRACENAME("GETDATA")
    int rc = FERR_NONE;

    ENTER(6, ("GetData(UnitSize=%d,Data=%lx,Offset=%lx)\n",
              bUnitSize, *(DWORD *)pb, dwOffset));

    pb += dwOffset;
    switch (bUnitSize)
    {
        case UNIT_BYTE:
            *pdwData = (DWORD)(*pb);
            break;
        case UNIT_WORD:
            *pdwData = (DWORD)(*((WORD *)pb));
            break;
        case UNIT_DWORD:
            *pdwData = *(DWORD *)pb;
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;
    }

    EXIT(6, ("GetData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetData

/***LP  PrintData - Print data value according to its size
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      bUnitSize - size of data unit
 *      dwData - number
 *      fPadSpace - if TRUE pad space to 8 chars
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int PrintData(char *pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace)
{
    TRACENAME("PRINTDATA")
    int rc = FERR_NONE;

    ENTER(6, ("PrintData(UnitSize=%d,Data=%lx)\n", bUnitSize, dwData));

    switch (bUnitSize)
    {
        case UNIT_BYTE:
            SPRINTF(pszBuffer, "%02x", (BYTE)dwData);
            if (fPadSpace)
                STRCAT(pszBuffer, "      ");
            break;
        case UNIT_WORD:
            SPRINTF(pszBuffer, "%04x", (WORD)dwData);
            if (fPadSpace)
                STRCAT(pszBuffer, "    ");
            break;
        case UNIT_DWORD:
            SPRINTF(pszBuffer, "%08lx", dwData);
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;
    }

    EXIT(6, ("PrintData=%d (Buff=%s)\n", rc, pszBuffer));
    return rc;
}       //PrintData

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\aslterms.c ===
/*** aslterms.c - Parse ASL terms
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/10/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  DefinitionBlock - Generate code for DefinitionBlock
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    #define OFLAGS  (_O_BINARY | _O_CREAT | _O_RDWR | _O_TRUNC)
    #define PMODE   (_S_IREAD | _S_IWRITE)

    ENTER((1, "DefinitionBlock(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (fActionFL)
    {
        if (gpcodeScope->pcParent != NULL)
        {
            PrintTokenErr(ptoken, "Definition block cannot nest", TRUE);
            rc = ASLERR_NEST_DDB;
        }
        else if (strlen((PSZ)pArgs[1].pbDataBuff) != sizeof(ghdrDDB.Signature))
        {
            ERROR(("DefinitionBlock: DDB signature too long - %s",
                   pArgs[1].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[3].pbDataBuff) > sizeof(ghdrDDB.OEMID))
        {
            ERROR(("DefinitionBlock: OEM ID too long - %s",
                   pArgs[3].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[4].pbDataBuff) > sizeof(ghdrDDB.OEMTableID))
        {
            ERROR(("DefinitionBlock: OEM Table ID too long - %s",
                   pArgs[4].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else
        {
            memset(&ghdrDDB, 0, sizeof(DESCRIPTION_HEADER));
            memcpy(&ghdrDDB.Signature, pArgs[1].pbDataBuff,
                   sizeof(ghdrDDB.Signature));
            memcpy(&ghdrDDB.Revision, &pArgs[2].dwCodeValue,
                   sizeof(ghdrDDB.Revision));
            memcpy(ghdrDDB.OEMID, pArgs[3].pbDataBuff,
                   strlen((PSZ)pArgs[3].pbDataBuff));
            memcpy(ghdrDDB.OEMTableID, pArgs[4].pbDataBuff,
                   strlen((PSZ)pArgs[4].pbDataBuff));
            memcpy(&ghdrDDB.OEMRevision, &pArgs[5].dwCodeValue,
                   sizeof(ghdrDDB.OEMRevision));
            memcpy(ghdrDDB.CreatorID, STR_MS, sizeof(ghdrDDB.CreatorID));
            ghdrDDB.CreatorRev = VERSION_DWORD;
        }
    }
    else
    {
    int fhAML = 0;
        PBYTE pb;
        DWORD dwCodeOffset = sizeof(ghdrDDB);

        ASSERT(gpcodeScope->pcParent == NULL);
        ghdrDDB.Length = gpcodeRoot->dwCodeLen + sizeof(DESCRIPTION_HEADER);
        ghdrDDB.Checksum = (BYTE)(-(gpcodeRoot->bCodeChkSum +
                                    ComputeDataChkSum((PBYTE)&ghdrDDB,
                                                      sizeof(DESCRIPTION_HEADER))));

        if ((gpnschkHead == NULL) ||
            ((rc = ValidateNSChkList(gpnschkHead)) == ASLERR_NONE))
        {
            if (gpszAMLFile == NULL)
            {
                strncpy(gszAMLName, (PSZ)pArgs[0].pbDataBuff,
                        _MAX_FNAME - 1);
                gpszAMLFile = gszAMLName;
            }

            if ((fhAML = _open(gpszAMLFile, OFLAGS, PMODE))== -1)
            {
                ERROR(("DefinitionBlock: failed to open AML file - %s",
                       pArgs[0].pbDataBuff));
                rc = ASLERR_CREATE_FILE;
            }
            else if (_write(fhAML, &ghdrDDB, sizeof(ghdrDDB)) != sizeof(ghdrDDB))
            {
                ERROR(("DefinitionBlock: failed to write DDB header"));
                rc = ASLERR_WRITE_FILE;
            }
            else if ((rc = WriteAMLFile(fhAML, gpcodeRoot, &dwCodeOffset)) !=
                     ASLERR_NONE)
            {
                ERROR(("DefinitionBlock: failed to write AML file"));
            }
            else if ((pb = MEMALLOC(ghdrDDB.Length)) != NULL)
            {
                if (_lseek(fhAML, 0, SEEK_SET) == -1)
                {
                    ERROR(("DefinitionBlock: failed seeking to beginning of image file"));
                }
                else if (_read(fhAML, pb, ghdrDDB.Length) != (int)ghdrDDB.Length)
                {
                    ERROR(("DefinitionBlock: failed to read back image file"));
                }
                else if (ComputeDataChkSum(pb, ghdrDDB.Length) != 0)
                {
                    ERROR(("DefinitionBlock: failed to verify checksum of image file"));
                }
                MEMFREE(pb);
            }

            if (rc == ASLERR_NONE)
            {
                printf("%s(%s): Image Size=%ld, Image Checksum=0x%x\n\n",
                       MODNAME, pArgs[0].pbDataBuff, ghdrDDB.Length, ghdrDDB.Checksum);
            }

            if (fhAML != 0)
            {
                _close(fhAML);
            }
        }
        FreeCodeObjs(gpcodeRoot);
        gpcodeRoot = NULL;
    }

    EXIT((1, "DefinitionBlock=%d\n", rc));
    return rc;
}       //DefinitionBlock

/***LP  Include - Include an ASL file
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Include(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "Include(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    rc = ParseASLFile((PSZ)pArgs[0].pbDataBuff);

    EXIT((1, "Include=%d\n", rc));
    return rc;
}       //Include

/***LP  External - Declaring external object
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL External(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "External(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    gpcodeScope->pnsObj->ObjData.dwDataType = (USHORT) pArgs[1].dwCodeValue;
    if (!(pArgs[2].dwfCode & CF_MISSING_ARG))
    {
        gpcodeScope->pnsObj->ObjData.uipDataValue = pArgs[2].dwCodeValue;
    }

    EXIT((1, "External=%d\n", rc));
    return rc;
}       //External

/***LP  Method - Parse Method statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Method(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Method(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeValue > MAX_ARGS)
    {
        PrintTokenErr(ptoken, "Method has too many formal arguments", TRUE);
        rc = ASLERR_SYNTAX;
    }

    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_METHOD);
    gpcodeScope->pnsObj->ObjData.uipDataValue = pArgs[1].dwCodeValue;

    if ((rc == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_NOTSERIALIZED)) == ASLERR_NONE))
    {
        pArgs[1].dwCodeValue |= TermTable[pArgs[2].dwTermIndex].dwTermData &
                                0xff;
        pArgs[1].bCodeChkSum = (BYTE)pArgs[1].dwCodeValue;
    }

    EXIT((1, "Method=%d\n", rc));
    return rc;
}       //Method

/***LP  Field - Parse Field statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Field(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Field(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x0e, 1);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[1].dwCodeValue);

    EXIT((1, "Field=%d\n", rc));
    return rc;
}       //Field

/***LP  IndexField - Parse IndexField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "IndexField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x1c, 2);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[2].dwCodeValue);

    EXIT((1, "IndexField=%d\n", rc));
    return rc;
}       //IndexField

/***LP  BankField - Parse BankField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "BankField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x38, 3);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[3].dwCodeValue);

    EXIT((1, "BankField=%d\n", rc));
    return rc;
}       //BankField

/***LP  OpRegion - Parse OperationRegion statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "OpRegion(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_OPREGION);
    gpcodeScope->pnsObj->ObjData.uipDataValue =
        (pArgs[3].dwCodeType != CODETYPE_DATAOBJ)? 0xffffffff:
        (pArgs[3].pbDataBuff[0] == OP_BYTE)? pArgs[3].pbDataBuff[1]:
        (pArgs[3].pbDataBuff[0] == OP_WORD)? *(PWORD)(&pArgs[3].pbDataBuff[1]):
                                             *(PDWORD)(&pArgs[3].pbDataBuff[1]);

    EXIT((1, "OpRegion=%d\n", rc));
    return rc;
}       //OpRegion

/***LP  EISAID - Parse EISAID statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;
    DWORD dwEISAID;

    ENTER((1, "EISAID(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if ((rc = ComputeEISAID((PSZ)pArgs[0].pbDataBuff, &dwEISAID)) ==
        ASLERR_NONE)
    {
        DWORD dwLen;

        MEMFREE(pArgs[0].pbDataBuff);
        pArgs[0].pbDataBuff = NULL;
        dwLen = (dwEISAID & 0xffff0000)? sizeof(DWORD):
                (dwEISAID & 0xffffff00)? sizeof(WORD): sizeof(BYTE);
        SetIntObject(&pArgs[0], dwEISAID, dwLen);
        pArgs[0].pcParent->dwCodeValue = (dwLen == sizeof(DWORD))? OP_DWORD:
                                         (dwLen == sizeof(WORD))? OP_WORD:
                                                                  OP_BYTE;
    }
    else
    {
        ERROR(("EISAID: invalid EISAID - %s", pArgs[0].pbDataBuff));
    }

    EXIT((1, "EISAID=%d\n", rc));
    return rc;
}       //EISAID

/***LP  Match - Parse Match statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Match(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Match(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x02, 1);
    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x08, 3);

    EXIT((1, "Match=%d\n", rc));
    return rc;
}       //Match

/***LP  AccessAs - Parse AccessAs macro
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "AccessAs(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeType == CODETYPE_KEYWORD) {
        EncodeKeywords(pArgs, 0x02, 1);
    }
    else if ((pArgs[1].dwCodeType == CODETYPE_INTEGER) && pArgs[1].dwCodeValue > MAX_BYTE)
    {
        PrintTokenErr(ptoken, "Access Attribute can only be a byte value",
                      TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "AccessAs=%d\n", rc));
    return rc;
}       //AccessAs

/***LP  Else - Parse Else statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Else(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcPrevSibling = (PCODEOBJ)gpcodeScope->list.plistPrev;

    ENTER((1, "Else(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    if ((pcPrevSibling->dwCodeType != CODETYPE_ASLTERM) ||
        (TermTable[pcPrevSibling->dwTermIndex].lID != ID_IF))
    {
        PrintTokenErr(ptoken, "Else statement has no matching If", TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "Else=%d\n", rc));
    return rc;
}       //Else
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\data.c ===
/*** data.c - Global Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUG
DWORD gdwcMemObjs = 0;
#endif

#pragma warning(disable: 4054)
ARGTYPE FAR ArgTypes[] =
{
    {"?",     AT_ACTION, 0,            (VOID *)PrintHelp, 0,             NULL},
    {"Fo",    AT_STRING, PF_SEPARATOR, &gpszAMLFile,      0,             NULL},
    {"Fa",    AT_STRING, PF_SEPARATOR, &gpszASMFile,      0,             NULL},
    {"Fl",    AT_STRING, PF_SEPARATOR, &gpszLSTFile,      0,             NULL},
    {"Fn",    AT_STRING, PF_SEPARATOR, &gpszNSDFile,      0,             NULL},
  #ifdef __UNASM
    {"d",     AT_ENABLE, 0,            &gdwfASL,          ASLF_DUMP_BIN, NULL},
    {"u",     AT_ENABLE, 0,            &gdwfASL,          ASLF_UNASM,    NULL},
    {"c",     AT_ENABLE, 0,            &gdwfASL,          ASLF_CREAT_BIN,NULL},
    {"tab",   AT_STRING, PF_SEPARATOR, &gpszTabSig,       0,             NULL},
  #endif
  #ifdef TRACING
    {"t",     AT_NUM,    PF_SEPARATOR, &giTraceLevel,     0,             NULL},
    {"l",     AT_STRING, PF_SEPARATOR, &gpszTraceFile,    0,             NULL},
  #endif
    {"nologo",AT_ENABLE, 0,            &gdwfASL,          ASLF_NOLOGO,   NULL},
    {"",      0,         0,            NULL,              0,             NULL}
};
#pragma warning(default: 4054)

PROGINFO ProgInfo = {NULL, NULL, NULL, NULL};

#ifdef __UNASM
HANDLE ghVxD = NULL;
#endif
char gszAMLName[_MAX_FNAME] = {0};
char gszLSTName[_MAX_FNAME] = {0};
PSZ gpszASLFile = NULL;
PSZ gpszAMLFile = NULL;
PSZ gpszASMFile = NULL;
PSZ gpszLSTFile = NULL;
PSZ gpszNSDFile = NULL;
PSZ gpszTabSig = NULL;
DWORD gdwfASL = 0;
PCODEOBJ gpcodeRoot = NULL;
PCODEOBJ gpcodeScope = NULL;
PNSOBJ gpnsNameSpaceRoot = NULL;
PNSOBJ gpnsCurrentScope = NULL;
PNSOBJ gpnsCurrentOwner = NULL;
PNSCHK gpnschkHead = NULL;
PNSCHK gpnschkTail = NULL;
DWORD gdwFieldAccSize = 0;
DESCRIPTION_HEADER ghdrDDB = {0};
char SymCharTable[] = "{}(),/*";
char * FAR gapszTokenType[] = {"ASL/User Term", "String", "Character", "Number",
                               "Symbol", "Space"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\debug.h ===
/*** debug.h - debug related definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DEBUG_H
#define _DEBUG_H

/*** Macros
 */

/*XLATOFF*/

#pragma warning (disable: 4704) //don't complain about in-line assembly

#define MSG(x)          {                                               \
                            ErrPrintf("%s: ", MODNAME);                 \
                            ErrPrintf x;                                \
                            ErrPrintf("\n");                            \
                        }
#define WARN(x)         {                                               \
                            ErrPrintf("%s_WARN: ", MODNAME);            \
                            ErrPrintf x;                                \
                            ErrPrintf("\n");                            \
                        }
#define ERROR(x)        {                                               \
                            ErrPrintf("%s_ERR: ", MODNAME);             \
                            ErrPrintf x;                                \
			    ErrPrintf("\n");				\
                        }

#ifndef DEBUG
  #define WARN1(x)      {}
  #define WARN2(x)      {}
  #define ASSERT(x)     {}
#else
  #define ASSERT(x)   if (!(x))                                         \
                      {                                                 \
                          ErrPrintf("%s_ASSERT: (" #x                   \
                                    ") in line %d of file %s\n",        \
                                    MODNAME, __LINE__, __FILE__);       \
                      }
  #ifndef MAXDEBUG
    #define WARN1       WARN
    #define WARN2(x)    {}
  #else
    #define WARN1       WARN
    #define WARN2       WARN
  #endif
#endif

#ifdef TRACING
  #define OPENTRACE     OpenTrace
  #define CLOSETRACE    CloseTrace
  #define ENTER(p)      EnterProc p
  #define EXIT(p)       ExitProc p
#else
  #define OPENTRACE(x)
  #define CLOSETRACE()
  #define ENTER(p)
  #define EXIT(p)
#endif

/*XLATON*/

//
// Exported data definitions
//
#ifdef TRACING
extern FILE *gpfileTrace;
extern PSZ gpszTraceFile;
extern int giTraceLevel;
extern int giIndent;
#endif


//
// Exported function prototypes
//
VOID CDECL ErrPrintf(char *pszFormat, ...);
#ifdef TRACING
VOID LOCAL OpenTrace(char *pszTraceOut);
VOID LOCAL CloseTrace(VOID);
VOID CDECL EnterProc(int n, char *pszFormat, ...);
VOID CDECL ExitProc(int n, char *pszFormat, ...);
#endif

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\debug.c ===
/*** debug.c - Debug functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include <stdarg.h>     //for va_*

#ifdef TRACING

#define TRACEFILE_NAME  "tracelog.txt"

FILE *gpfileTrace = NULL;
PSZ gpszTraceFile = NULL;
int giTraceLevel = 0;
int giIndent = 0;

/***LP  OpenTrace - Initialize tracing
 *
 *  This function opens the device that the trace output will go to.
 *  It will first try the caller's filename, or else the default filenmae.
 *
 *  ENTRY
 *      pszTraceOut -> output device name
 *
 *  EXIT
 *      None
 */

VOID LOCAL OpenTrace(char *pszTraceOut)
{
    if ((gpfileTrace == NULL) && (giTraceLevel > 0))
    {
        if ((pszTraceOut == NULL) ||
            ((gpfileTrace = fopen(pszTraceOut, "w")) == NULL))
        {
            gpfileTrace = fopen(TRACEFILE_NAME, "w");
        }
    }
}       //OpenTrace

/***LP  CloseTrace - Finish tracing
 *
 *  This function close the device that the trace output will go to.
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseTrace(VOID)
{
    if (gpfileTrace != NULL)
    {
        fclose(gpfileTrace);
        gpfileTrace = NULL;
    }
    giTraceLevel = 0;
}       //CloseTrace

/***LP  EnterProc - Entering a procedure
 *
 *  ENTRY
 *      n - trace level of this procedure
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL EnterProc(int n, char *pszFormat, ...)
{
    int i;
    va_list marker;

    if (n <= giTraceLevel)
    {
        if (gpfileTrace != NULL)
        {
            fprintf(gpfileTrace, "%s:", MODNAME);
            for (i = 0; i < giIndent; ++i)
                fprintf(gpfileTrace, "| ");
            va_start(marker, pszFormat);
            vfprintf(gpfileTrace, pszFormat, marker);
            fflush(gpfileTrace);
            va_end(marker);
        }
        ++giIndent;
    }
}       //EnterProc

/***LP  ExitProc - Exiting a procedure
 *
 *  ENTRY
 *      n - trace level of this procedure
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL ExitProc(int n, char *pszFormat, ...)
{
    int i;
    va_list marker;

    if (n <= giTraceLevel)
    {
        --giIndent;
        if (gpfileTrace != NULL)
        {
            fprintf(gpfileTrace, "%s:", MODNAME);
            for (i = 0; i < giIndent; ++i)
                fprintf(gpfileTrace, "| ");
            va_start(marker, pszFormat);
            vfprintf(gpfileTrace, pszFormat, marker);
            fflush(gpfileTrace);
            va_end(marker);
        }
    }
}       //ExitProc

#endif  //ifdef TRACING

/***LP  ErrPrintf - Print to stderr
 *
 *  ENTRY
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL ErrPrintf(char *pszFormat, ...)
{
    va_list marker;

    va_start(marker, pszFormat);
    vfprintf(stdout, pszFormat, marker);
    va_end(marker);
}       //ErrPrintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\data.h ===
/*** data.h - Global Data Definitions
 *
 *  This module contains global data definitions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DATA_H
#define _DATA_H

#ifdef DEBUG
extern DWORD gdwcMemObjs;
#endif

extern ARGTYPE FAR ArgTypes[];
extern PROGINFO ProgInfo;

#ifdef __UNASM
extern HANDLE ghVxD;
#endif
extern char gszAMLName[];
extern char gszLSTName[];
extern PSZ gpszASLFile;
extern PSZ gpszAMLFile;
extern PSZ gpszASMFile;
extern PSZ gpszLSTFile;
extern PSZ gpszNSDFile;
extern PSZ gpszTabSig;
extern DWORD gdwfASL;
extern PCODEOBJ gpcodeRoot;
extern PCODEOBJ gpcodeScope;
extern PNSOBJ gpnsNameSpaceRoot;
extern PNSOBJ gpnsCurrentScope;
extern PNSOBJ gpnsCurrentOwner;
extern PNSCHK gpnschkHead;
extern PNSCHK gpnschkTail;
extern DWORD gdwFieldAccSize;
extern DESCRIPTION_HEADER ghdrDDB;
extern char FAR SymCharTable[];
extern char * FAR gapszTokenType[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\fmtdata.h ===
/*** fmtdata.h - Format Data
 *
 *  This module contains all the format data.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/08/99
 *
 *  MODIFICATION HISTORY
 */

//
// Common Strings
//
char szReserved[] = "Reserved";
char szLabelReserved[] = "Reserved        =";
char szNull[] = "";
char szDecFmt[] = SZ_FMT_DEC;
char szHexFmt[] = SZ_FMT_HEX;
char szByteFmt[] = SZ_FMT_HEX_BYTE;
char szWordFmt[] = SZ_FMT_HEX_WORD;
char szDWordFmt[] = SZ_FMT_HEX_DWORD;
char szOffsetFmt[] = "%02x: ";
char szSectFmt[] = "\n[%08lx: %s]\n";

//
// Common Formats
//
FMTNUM fmtHexByteNoEOL =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA | FMTF_NO_EOL, 1, NULL, NULL,
     NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmtHexByte =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmt3HexByte =
{
    {FMT_NUMBER, UNIT_BYTE, 3, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmtHexWord =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffff, 0, szWordFmt
};

FMTNUM fmtHexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt2HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 2, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt4HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 4, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt6HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 6, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt8HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 8, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmtDecNum =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, szDecFmt
};

FMTSTR fmtChar4 =
{
    {FMT_STRING, UNIT_BYTE, 4, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

FMTSTR fmtChar6 =
{
    {FMT_STRING, UNIT_BYTE, 6, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

FMTSTR fmtChar8 =
{
    {FMT_STRING, UNIT_BYTE, 8, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

//
// RSD PTR Table
//
FMT afmtRSDPTR[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar8,       NULL},
    {"Checksum        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"OEMID           =", (PFMTHDR)&fmtChar6,       NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"RSDTAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// Common Table Header
//
FMT afmtTableHdr[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar4,       NULL},
    {"Length          =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"Revision        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"Checksum        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"OEMID           =", (PFMTHDR)&fmtChar6,       NULL},
    {"OEMTableID      =", (PFMTHDR)&fmtChar8,       NULL},
    {"OEMTableRev     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"CreatorID       =", (PFMTHDR)&fmtChar4,       NULL},
    {"CreatorRev      =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// Generic Register Address Structure
//
char *ppszAddrSpaceNames[] = {"SystemMemory", "SystemIO", "PCIConfigSpace"};
FMTENUM fmtAddrSpaceID =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 2, ppszAddrSpaceNames, szReserved
};

FMT afmtGRASCommon[] =
{
    {"RegAddrSpce     =", (PFMTHDR)&fmtAddrSpaceID, NULL},
    {"RegBitWidth     =", (PFMTHDR)&fmtHexByte,     NULL},
    {"RegBitOffset    =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtGRASPCICS[] =
{
    {szLabelReserved,     (PFMTHDR)&fmtHexWord,     NULL},
    {"DeviceNum       =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FunctionNum     =", (PFMTHDR)&fmtHexWord,     NULL},
    {"CfgSpaceOffset  =", (PFMTHDR)&fmtHexWord,     NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtGRASRegAddr[] =
{
    {"RegAddrLo       =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"RegAddrHi       =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// FACP Table
//
char *ppszIntModelNames[] = {"DualPIC", "MultipleAPIC"};
FMTENUM fmtIntModel =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 0x01, ppszIntModelNames, szReserved
};

char *ppszBootArchFlagNames[] = {"8042", "LegacyDevices"};
FMTBITS fmtBootArch =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x0003, ppszBootArchFlagNames, NULL
};

char *ppszFACPFlagNames[] = {"ResetRegSupported", "DckCap", "TmrValExt",
                             "RTCS4", "FixRTC", "SlpButton", "PwrButton",
                             "PLvl2UP", "ProcC1", "WBINVDFlush", "WBINVD"};
FMTBITS fmtFACPFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x000007ff, ppszFACPFlagNames, NULL
};

FMT afmtFACP[] =
{
    {"FACSAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"DSDTAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"IntModel        =", (PFMTHDR)&fmtIntModel,    NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"SCIInt          =", (PFMTHDR)&fmtHexWord,     NULL},
    {"SMICmdAddr      =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"ACPIEnableValue =", (PFMTHDR)&fmtHexByte,     NULL},
    {"ACPIDisableValue=", (PFMTHDR)&fmtHexByte,     NULL},
    {"S4BIOSReqValue  =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"PM1aEvtBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1bEvtBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1aCtrlBlkAddr =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1bCtrlBlkAddr =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM2CtrlBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PMTmrBlkAddr    =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GPE0BlkAddr     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GPE1BlkAddr     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1EvtBlkLen    =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PM1CtrlBlkLen   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PM2CtrlBlkLen   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PMTmrBlkLen     =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE0BlkLen      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE1BlkLen      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE1BaseOffset  =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"PLvl2Latency    =", (PFMTHDR)&fmtHexWord,     NULL},
    {"PLvl3Latency    =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FlushSize       =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FlushStride     =", (PFMTHDR)&fmtHexWord,     NULL},
    {"DutyOffset      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"DutyWidth       =", (PFMTHDR)&fmtHexByte,     NULL},
    {"DayAlarmIndex   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"MonthAlarmIndex =", (PFMTHDR)&fmtHexByte,     NULL},
    {"CenturyIndex    =", (PFMTHDR)&fmtHexByte,     NULL},
    {"BootArchFlags   =", (PFMTHDR)&fmtBootArch,    NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"Flags           =", (PFMTHDR)&fmtFACPFlags,   NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtFACP2[] =
{
    {"ResetValue      =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// FACS Table
//
char *ppszGLNames[] = {"Owned", "Pending"};
FMTBITS fmtGlobalLock =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000003, ppszGLNames, NULL
};

char *ppszFACSFlagNames[] = {"S4BIOS"};
FMTBITS fmtFACSFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000001, ppszFACSFlagNames, NULL
};

FMT afmtFACS[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar4,       NULL},
    {"Length          =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"HWSignature     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"FirmwareWakeVect=", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GlobalLock      =", (PFMTHDR)&fmtGlobalLock,  NULL},
    {"Flags           =", (PFMTHDR)&fmtFACSFlags,   NULL},
    {szNull,              (PFMTHDR)&fmt2HexDWord,   NULL},
    {szNull,              (PFMTHDR)&fmt8HexDWord,   NULL},
    {NULL,                NULL,                     NULL}
};

//
// APIC Table
//
char *ppszAPICFlagNames[] = {"PCATCompat"};
FMTBITS fmtAPICFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000001, ppszAPICFlagNames, NULL
};

FMT afmtAPIC[] =
{
    {"LocalAPICAddr   =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"Flags           =", (PFMTHDR)&fmtAPICFlags,   NULL},
    {NULL,                NULL,                     NULL}
};

//
// SBST Table
//
FMT afmtSBST[] =
{
    {"WarnEnergyLevel =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"LowEnergyLevel  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"CritEnergyLevel =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// BOOT Table
//
FMT afmtBOOT[] =
{
    {"CMOSOffset      =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// DBGP Table
//
char *ppszInterfaceNames[] = {"16550Full", "16550Subset"};
FMTENUM fmtInterfaceType =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 0x01, ppszIntModelNames, szReserved
};

FMT afmtDBGP[] =
{
    {"InterfaceType   =", (PFMTHDR)&fmtInterfaceType,NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,     NULL},
    {NULL,                NULL,                     NULL}
};

typedef struct _fmtentry
{
    DWORD dwTableSig;
    DWORD dwFlags;
    PFMT  pfmt;
} FMTENTRY, *PFMTENTRY;

#define TF_NOHDR                0x00000001
#define SIG_DBGP                'PGBD'

FMTENTRY FmtTable[] = {
    {FADT_SIGNATURE, 0,        afmtFACP},
    {FACS_SIGNATURE, TF_NOHDR, afmtFACS},
    {APIC_SIGNATURE, 0,        afmtAPIC},
    {SBST_SIGNATURE, 0,        afmtSBST},
    {SIG_BOOT,       0,        afmtBOOT},
    {SIG_DBGP,       0,        afmtDBGP},
    {RSDT_SIGNATURE, 0,        NULL},
    {DSDT_SIGNATURE, 0,        NULL},
    {PSDT_SIGNATURE, 0,        NULL},
    {SSDT_SIGNATURE, 0,        NULL},
    {0,              0,        NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\line.c ===
/*** line.c - Line stream related functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/04/96
 *
 *  This module implements the line stream layer so that it can
 *  keep track of the information such as line number and line
 *  position.  This information is necessary for the scanner or
 *  even the parser to accurately pin point the error location
 *  in case of syntax or semantic errors.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  OpenLine - allocate and initialize line structure
 *
 *  ENTRY
 *      pfileSrc -> source file
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated line structure.
 *  EXIT-FAILURE
 *      returns NULL.
 */

PLINE EXPORT OpenLine(FILE *pfileSrc)
{
    PLINE pline;

    ENTER((5, "OpenLine(pfileSrc=%p)\n", pfileSrc));

    if ((pline = malloc(sizeof(LINE))) == NULL)
        MSG(("OpenLine: failed to allocate line structure"))
    else
    {
        memset(pline, 0, sizeof(LINE));
        pline->pfileSrc = pfileSrc;
    }

    EXIT((5, "OpenLine=%p\n", pline));
    return pline;
}       //OpenLine

/***EP  CloseLine - free line structure
 *
 *  ENTRY
 *      pline->line structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT CloseLine(PLINE pline)
{
    ENTER((5, "CloseLine(pline=%p)\n", pline));

    free(pline);

    EXIT((5, "CloseLine!\n"));
}       //CloseLine

/***EP  LineGetC - get a character from the line stream
 *
 *  This is equivalent to fgetc() except that it has the line
 *  stream layer below it instead of directly from the file.  It
 *  is done this way to preserve the line number and line position
 *  information for accurately pin pointing the error location
 *  if necessary.
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the character
 *  EXIT-FAILURE
 *      returns error code - EOF (end-of-file)
 */

int EXPORT LineGetC(PLINE pline)
{
    int ch = 0;

    ENTER((5, "LineGetC(pline=%p)\n", pline));

    if (pline->wLinePos >= pline->wLineLen)
    {
        //
        // EOL is encountered
        //
        if (fgets(pline->szLineBuff, sizeof(pline->szLineBuff), pline->pfileSrc)
            != NULL)
        {
            pline->wLinePos = 0;
            if (!(pline->wfLine & LINEF_LONGLINE))
                pline->wLineNum++;

            pline->wLineLen = (WORD)strlen(pline->szLineBuff);

            if (pline->szLineBuff[pline->wLineLen - 1] == '\n')
                pline->wfLine &= ~LINEF_LONGLINE;
            else
                pline->wfLine |= LINEF_LONGLINE;
        }
        else
            ch = EOF;
    }

    if (ch == 0)
        ch = (int)pline->szLineBuff[pline->wLinePos++];

    EXIT((5, "LineGetC=%x (ch=%c,Line=%u,NextPos=%u,LineLen=%u)\n",
          ch, ch, pline->wLineNum, pline->wLinePos, pline->wLineLen));
    return ch;
}       //LineGetC

/***EP  LineUnGetC - push a character back to the line stream
 *
 *  This is equivalent to fungetc() except that it's source is
 *  the line stream not the file stream.  Refer to LineGetC for
 *  explanation on this implementation.
 *
 *  ENTRY
 *      ch - character being pushed back
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the character being pushed
 *  EXIT-FAILURE
 *      returns -1
 */

int EXPORT LineUnGetC(int ch, PLINE pline)
{
    ENTER((5, "LineUnGetC(ch=%c,pline=%p)\n", ch, pline));

    ASSERT(pline->wLinePos != 0);
    if (ch != EOF)
    {
        pline->wLinePos--;
        ASSERT((int)pline->szLineBuff[pline->wLinePos] == ch);
    }

    EXIT((5, "LineUnGetC=%x (ch=%c)\n", ch, ch));
    return ch;
}       //LineUnGetC

/***EP  LineFlush - flush a line
 *
 *  The scanner may want to discard the rest of the line when it
 *  detects an in-line comment symbol, for example.
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT
 *      none
 */

VOID EXPORT LineFlush(PLINE pline)
{
    ENTER((5, "LineFlush(pline=%p)\n", pline));

    pline->wLinePos = pline->wLineLen;

    EXIT((5, "LineFlush!\n"));
}       //LineFlush
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\line.h ===
/*** line.h - Line stream definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/04/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the line.c module.
 *
 *  MODIFICATION HISTORY
 */

#ifndef _LINE_H
#define _LINE_H

/*** Constants
 */

#define MAX_LINE_LEN            255
#define LINEF_LONGLINE          0x0001

/***    Imported data types
 */

/***    Exported data types
 */

typedef struct line_s
{
    FILE *pfileSrc;
    WORD wfLine;
    WORD wLineNum;
    WORD wLinePos;
    WORD wLineLen;
    char szLineBuff[MAX_LINE_LEN + 1];
} LINE;

typedef LINE *PLINE;

/***    Exported function prototypes
 */

PLINE EXPORT OpenLine(FILE *pfileSrc);
VOID EXPORT CloseLine(PLINE pline);
int EXPORT LineGetC(PLINE pline);
int EXPORT LineUnGetC(int ch, PLINE pline);
VOID EXPORT LineFlush(PLINE pline);

#endif  //ifndef _LINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\list.c ===
/*** list.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ListRemoveEntry - Remove an entry from the list
 *
 *  ENTRY
 *      plist -> list object to be removed
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead);
    ENTER((4, "ListRemoveEntry(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (plist->plistNext == plist)
    {
        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(plist == *pplistHead);
        *pplistHead = NULL;
    }
    else
    {
        if (plist == *pplistHead)
        {
            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *pplistHead = (*pplistHead)->plistNext;
        }

        plist->plistNext->plistPrev = plist->plistPrev;
        plist->plistPrev->plistNext = plist->plistNext;
    }

    EXIT((4, "ListRemoveEntry! (plistHead=%p)\n", *pplistHead));
}       //ListRemoveEntry

/***LP  ListRemoveHead - Remove the head entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveHead(PPLIST pplistHead)
{
    PLIST plist;

    ASSERT(pplistHead);
    ENTER((4, "ListRemoveHead(plistHead=%p)\n", *pplistHead));

    if ((plist = *pplistHead) != NULL)
        ListRemoveEntry(plist, pplistHead);

    EXIT((4, "ListRemoveHead=%p (plistHead=%p)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveHead

/***LP  ListRemoveTail - Remove the tail entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveTail(PPLIST pplistHead)
{
    PLIST plist;

    ASSERT(pplistHead);
    ENTER((4, "ListRemoveTail(plistHead=%p)\n", *pplistHead));

    if (*pplistHead == NULL)
        plist = NULL;
    else
    {
        //
        // List is not empty, so find the tail.
        //
        plist = (*pplistHead)->plistPrev;
        ListRemoveEntry(plist, pplistHead);
    }

    EXIT((4, "ListRemoveTail=%p (plistHead=%p)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveTail

/***LP  ListInsertHead - Insert an entry at the head of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead != NULL);
    ENTER((4, "ListInsertHead(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    ListInsertTail(plist, pplistHead);
    *pplistHead = plist;

    EXIT((4, "ListInsertHead! (plistHead=%p)\n", *pplistHead));
}       //ListInsertHead

/***LP  ListInsertTail - Insert an entry at the tail of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead != NULL);
    ENTER((4, "ListInsertTail(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (*pplistHead == NULL)
    {
        //
        // List is empty, so this becomes the head.
        //
        *pplistHead = plist;
        plist->plistPrev = plist->plistNext = plist;
    }
    else
    {
        plist->plistNext = *pplistHead;
        plist->plistPrev = (*pplistHead)->plistPrev;
        (*pplistHead)->plistPrev->plistNext = plist;
        (*pplistHead)->plistPrev = plist;
    }

    EXIT((4, "ListInsertTail! (plistHead=%p)\n", *pplistHead));
}       //ListInsertTail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\misc.c ===
/*** misc.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ValidASLNameSeg - Check if the token is an ASL NameSeg
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *      icbLen - length of the token to be considered a NameSeg
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen)
{
    BOOL rc = TRUE;
    int i, j;
    static PSZ apszReservedNames[] = {
        "ADR", "ALN", "BAS", "BBN", "BCL", "BCM", "BDN", "BIF", "BM_", "BST",
        "BTP", "CID", "CRS", "CRT", "DCK", "DCS", "DDC", "DDN", "DEC", "DGS",
        "DIS", "DMA", "DOD", "DOS", "DSS", "EC_", "EJD", "FDE", "FDI", "GL_",
        "GLK", "GPE", "GRA", "GTF", "GTM", "HE_", "HID", "INI", "INT", "IRC",
        "LCK", "LEN", "LID", "LL_", "MAF", "MAX", "MEM", "MIF", "MIN", "MSG",
        "OFF", "ON_", "OS_", "PCL", "PIC", "PR_", "PRS", "PRT", "PRW", "PSC",
        "PSL", "PSR", "PSV", "PSW", "PTS", "PWR", "REG", "REV", "RMV", "RNG",
        "ROM", "RQ_", "RW_", "SB_", "SBS", "SCP", "SHR", "SI_", "SIZ", "SRS",
        "SST", "STA", "STM", "SUN", "TC1", "TC2", "TMP", "TRA", "TSP", "TYP",
        "TZ_", "UID", "WAK", "AC0", "AC1", "AC2", "AC3", "AC4", "AC5", "AC6",
        "AC7", "AC8", "AC9", "AL0", "AL1", "AL2", "AL3", "AL4", "AL5", "AL6",
        "AL7", "AL8", "AL9", "EC0", "EC1", "EC2", "EC3", "EC4", "EC5", "EC6",
        "EC7", "EC7", "EC9", "EJ0", "EJ1", "EJ2", "EJ3", "EJ4",
        "Exx", "Lxx", "Qxx",
        "S0_", "S1_", "S2_", "S3_", "S4_", "S5_",
        "S0D", "S1D", "S2D", "S3D", "S4D", "S5D",
        "PR0", "PR1", "PR2",
        "PS0", "PS1", "PS2", "PS3"
    };
    #define NUM_RESERVED_NAMES  (sizeof(apszReservedNames)/sizeof(PSZ))

    ENTER((1, "ValidASLNameSeg(ptoken=%p, Token=%s,Len=%d)\n",
           ptoken, pszToken, icbLen));

    pszToken[0] = (char)toupper(pszToken[0]);
    if ((icbLen > sizeof(NAMESEG)) || !ISLEADNAMECHAR(pszToken[0]))
    {
        rc = FALSE;
    }
    else
    {
        for (i = 1; i < icbLen; ++i)
        {
            pszToken[i] = (char)toupper(pszToken[i]);
            if (!ISNAMECHAR(pszToken[i]))
            {
                rc = FALSE;
                break;
            }
        }

        if ((rc == TRUE) && (*pszToken == '_'))
        {
            char szName[sizeof(NAMESEG)] = "___";

            memcpy(szName, &pszToken[1], icbLen - 1);
            for (i = 0; i < NUM_RESERVED_NAMES; ++i)
            {
                if (strcmp(szName, apszReservedNames[i]) == 0)
                    break;
                else
                {
                    for (j = 0; j < sizeof(NAMESEG) - 1; ++j)
                    {
                        if (apszReservedNames[i][j] != szName[j])
                        {
                            if ((apszReservedNames[i][j] != 'x') ||
                                !isxdigit(szName[j]))
                            {
                                break;
                            }
                        }
                    }

                    if (j == sizeof(NAMESEG) - 1)
                    {
                        break;
                    }
                }
            }

            if (i == NUM_RESERVED_NAMES)
            {
                PrintTokenErr(ptoken, "not a valid reserved NameSeg", FALSE);
            }
        }
    }

    EXIT((1, "ValidASLNameSeg=%d\n", rc));
    return rc;
}       //ValidASLNameSeg

/***LP  ValidASLName - Check if the token is an ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken)
{
    BOOL rc = TRUE;
    PSZ psz1, psz2 = NULL;
    int icbLen;

    ENTER((1, "ValidASLName(ptoken=%p,Token=%s)\n", ptoken, pszToken));

    if (*pszToken == CH_ROOT_PREFIX)
    {
        pszToken++;
    }
    else
    {
        while (*pszToken == CH_PARENT_PREFIX)
        {
            pszToken++;
        }
    }

    for (psz1 = pszToken;
         (rc == TRUE) && (psz1 != NULL) && (*psz1 != '\0');
         psz1 = psz2)
    {
        psz2 = strchr(psz1, CH_NAMESEG_SEP);
        icbLen = (psz2 != NULL)? (int)(psz2 - psz1): strlen(psz1);
        if (((rc = ValidASLNameSeg(ptoken, psz1, icbLen)) == TRUE) &&
            (psz2 != NULL))
        {
            psz2++;
        }
    }

    EXIT((1, "ValidASLName=%d\n", rc));
    return rc;
}       //ValidASLName

/***LP  EncodeName - Encode name string
 *
 *  ENTRY
 *      pszName -> name string
 *      pbBuff -> buffer to hold name encoding
 *      pdwLen -> initially contains buffer size, but will be updated to show
 *                actual encoding length
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen)
{
    int rc = ASLERR_NONE;
    PBYTE pb = pbBuff;
    PSZ psz;
    int icNameSegs, i;

    ENTER((1, "EncodeName(Name=%s,pbBuff=%p,Len=%d)\n",
           pszName, pbBuff, *pdwLen));

    if (*pszName == CH_ROOT_PREFIX)
    {
        if (*pdwLen >= 1)
        {
            *pb = OP_ROOT_PREFIX;
            pb++;
            (*pdwLen)--;
            pszName++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        while (*pszName == CH_PARENT_PREFIX)
        {
            if (*pdwLen >= 1)
            {
                *pb = OP_PARENT_PREFIX;
                pb++;
                (*pdwLen)--;
                pszName++;
            }
            else
            {
                rc = ASLERR_NAME_TOO_LONG;
                break;
            }
        }
    }

    for (psz = pszName, icNameSegs = 0; (psz != NULL) && (*psz != '\0');)
    {
        icNameSegs++;
        if ((psz = strchr(psz, CH_NAMESEG_SEP)) != NULL)
            psz++;
    }

    if (icNameSegs > 255)
        rc = ASLERR_NAME_TOO_LONG;
    else if (icNameSegs > 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*icNameSegs + 2)
        {
            *pb = OP_MULTI_NAME_PREFIX;
            pb++;
            *pb = (BYTE)icNameSegs;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else if (icNameSegs == 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*2 + 1)
        {
            *pb = OP_DUAL_NAME_PREFIX;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (rc == ASLERR_NONE)
    {
        //
        // If we have only name prefix characters, we must put a null name
        // separator to tell the boundary from the next opcode which may happen
        // to be a NameSeg.
        //
        if (icNameSegs == 0)
        {
            *pb = 0;
            pb++;
        }
        else
        {
            while (icNameSegs > 0)
            {
                *((PDWORD)pb) = NAMESEG_BLANK;
                for (i = 0;
                     (i < sizeof(NAMESEG)) && ISNAMECHAR(*pszName);
                     ++i, pszName++)
                {
                    pb[i] = *pszName;
                }

                if (*pszName == CH_NAMESEG_SEP)
                    pszName++;

                pb += 4;
                icNameSegs--;
            }
        }

        *pdwLen = (DWORD)(pb - pbBuff);
    }

    EXIT((1, "EncodeName=%d (Len=%d)\n", rc, *pdwLen));
    return rc;
}       //EncodeName

/***LP  EncodePktLen - Encode packet length
 *
 *  ENTRY
 *      dwCodeLen - actual code length
 *      pdwPktLen -> to hold the encoded packet length
 *      picbEncoding -> to hold the number of encoding bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding)
{
    int rc = ASLERR_NONE;

    ENTER((1, "EncodePktLen(CodeLen=%ld,pdwPktLen=%p)\n",
           dwCodeLen, pdwPktLen));

    if (dwCodeLen <= 0x3f)
    {
        *pdwPktLen = dwCodeLen;
        *picbEncoding = 1;
    }
    else
    {
        *pdwPktLen = (dwCodeLen & 0x0ffffff0) << 4;
        *pdwPktLen |= (dwCodeLen & 0xf);

        if (dwCodeLen <= 0x0fff)
            *picbEncoding = 2;
        else if (dwCodeLen <= 0x0fffff)
            *picbEncoding = 3;
        else if (dwCodeLen <= 0x0fffffff)
            *picbEncoding = 4;
        else
            rc = ASLERR_PKTLEN_TOO_LONG;

        if (rc == ASLERR_NONE)
            *pdwPktLen |= (*picbEncoding - 1) << 6;
    }

    EXIT((1, "EncodePktLen=%d (Encoding=%lx,icbEncoding=%d)\n",
          rc, *pdwPktLen, *picbEncoding));
    return rc;
}       //EncodePktLen

/***LP  EncodeKeywords - Encode keyword arguments
 *
 *  ENTRY
 *      pArgs -> argument array
 *      dwSrcArgs - source argument bit vector
 *      iDstArgNum - destination argument number
 *
 *  EXIT
 *      None
 */

VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum)
{
    int i;
    DWORD dwData = 0;

    ENTER((1, "EncodeKeywords(pArgs=%p,SrcArgs=%lx,DstArgNum=%d)\n",
           pArgs, dwSrcArgs, iDstArgNum));

    for (i = 0; i < MAX_ARGS; ++i)
    {
        if (dwSrcArgs & (1 << i))
        {
            if (pArgs[i].dwCodeType == CODETYPE_KEYWORD)
            {
                dwData |= TermTable[pArgs[i].dwTermIndex].dwTermData & 0xff;
            }
            else if (pArgs[i].dwCodeType == CODETYPE_INTEGER)
            {
                pArgs[i].dwCodeType = CODETYPE_UNKNOWN;
                dwData |= pArgs[i].dwCodeValue;
            }
            else
            {
                ASSERT(pArgs[i].dwCodeType == CODETYPE_INTEGER);
            }
        }
    }

    SetIntObject(&pArgs[iDstArgNum], dwData, sizeof(BYTE));

    EXIT((1, "EncodeKeywords!\n"));
}       //EncodeKeywords

/***LP  DecodeName - Decode name encoding back to a name string
 *
 *  ENTRY
 *      pb -> name encoding buffer
 *      pszName -> to hold the decoded name string
 *      iLen - length of name string buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen)
{
    int rc = ASLERR_NONE;
    int i = 0, icNameSegs;

    ENTER((1, "DecodeName(pb=%p,pszName=%p,iLen=%d)\n", pb, pszName, iLen));

    iLen--;     //reserve one space for NULL character
    pszName[iLen] = '\0';
    if (*pb == OP_ROOT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_ROOT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    while (*pb == OP_PARENT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_PARENT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (*pb == OP_DUAL_NAME_PREFIX)
    {
        icNameSegs = 2;
        pb++;
    }
    else if (*pb == OP_MULTI_NAME_PREFIX)
    {
        pb++;
        icNameSegs = (int)(*pb);
        pb++;
    }
    else if (*pb == 0)
    {
        icNameSegs = 0;
    }
    else
    {
        icNameSegs = 1;
    }

    if (icNameSegs > 0)
    {
        do
        {
            if ((int)(i + sizeof(NAMESEG)) <= iLen)
            {
                strncpy(&pszName[i], (PCHAR)pb, sizeof(NAMESEG));
                pb += sizeof(NAMESEG);
                i += sizeof(NAMESEG);
                icNameSegs--;

                if (icNameSegs > 0)
                {
                    if (i < iLen)
                    {
                        pszName[i] = CH_NAMESEG_SEP;
                        i++;
                    }
                    else
                        rc = ASLERR_NAME_TOO_LONG;
                }
            }
            else
                rc = ASLERR_NAME_TOO_LONG;

        } while ((rc == ASLERR_NONE) && (icNameSegs > 0));
    }

    if (rc == ASLERR_NONE)
        pszName[i] = '\0';
    else
    {
        ERROR(("DecodeName: Name is too long - %s", pszName));
    }

    EXIT((1, "DecodeName=%d (Name=%s)\n", rc, pszName));
    return rc;
}       //DecodeName

/***LP  SetDefMissingKW - Set default missing keyword
 *
 *  ENTRY
 *      pArg -> argument code object
 *      dwDefID - default ID to be used if argument is missing
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID)
{
    int rc = ASLERR_NONE;

    ENTER((2, "SetDefMissingKW(pArg=%p,ID=%d)\n", pArg, dwDefID));

    if (pArg->dwfCode & CF_MISSING_ARG)
    {
        pArg->dwfCode &= ~CF_MISSING_ARG;
        pArg->dwCodeType = CODETYPE_KEYWORD;
        pArg->dwCodeValue = dwDefID;
        rc = LookupIDIndex(pArg->dwCodeValue, &pArg->dwTermIndex);
    }

    EXIT((2, "SetDefMissingKW=%d (TermIndex=%ld)\n", rc, pArg->dwTermIndex));
    return rc;
}       //SetDefMissingKW

/***LP  SetIntObject - Set an object to type integer
 *
 *  ENTRY
 *      pc -> object
 *      dwData - integer data
 *      dwLen - data length
 *
 *  EXIT
 *      None
 */

VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen)
{
    ENTER((2, "SetIntObject(pc=%p,Data=%x,Len=%d)\n", pc, dwData, dwLen));

    pc->dwCodeType = CODETYPE_INTEGER;
    pc->dwCodeValue = dwData;
    pc->dwDataLen = pc->dwCodeLen = dwLen;
    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&dwData, dwLen);

    EXIT((2, "SetIntObject!\n"));
}       //SetIntObject

/***LP  ComputeChildChkSumLen - Compute len and chksum of child for parent
 *
 *  ENTRY
 *      pcParent -> code block of parent
 *      pcChild -> code block of child
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild)
{
    ENTER((1, "ComputeChildChkSumLen(pcParent=%p,pcChild=%p,ChildLen=%ld,ChildChkSum=%x)\n",
           pcParent, pcChild, pcChild->dwCodeLen, pcChild->bCodeChkSum));

    pcParent->dwCodeLen += pcChild->dwCodeLen;
    pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                   pcChild->bCodeChkSum);

    if (pcChild->dwCodeType == CODETYPE_ASLTERM)
    {
        int i;

        for (i = 0; i < OPCODELEN(pcChild->dwCodeValue); ++i)
        {
            pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                           ((PBYTE)(&pcChild->dwCodeValue))[i]);
            pcParent->dwCodeLen++;
        }
    }

    EXIT((1, "ComputeChildChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcParent->dwCodeLen, pcParent->bCodeChkSum));
}       //ComputeChildChkSumLen

/***LP  ComputeArgsChkSumLen - Compute length and checksum of arguments
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i;

    ENTER((1, "ComputeArgsChkSumLen(pcode=%p)\n", pcode));

    ASSERT((pcode->dwCodeType == CODETYPE_ASLTERM) ||
           (pcode->dwCodeType == CODETYPE_USERTERM));
    //
    // Sum the length of arguments
    //
    for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
         i < (int)pcode->dwDataLen;
         ++i)
    {
        ComputeChildChkSumLen(pcode, &pc[i]);
    }

    EXIT((1, "ComputeArgsChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeArgsChkSumLen

/***LP  ComputeChkSumLen - Compute length and checksum of code block
 *
 *  Compute the length of the given code block and store it in the dwCodeLen
 *  field of the code block.
 *  Compute the checksum of the given code block and store it in the
 *  bCodeChkSum field of the code block.
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      This function does not count the opcode length of the given ASLTERM.
 *      The caller is responsible for adding it if necessary.
 */

VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i, j;

    ENTER((1, "ComputeChkSumLen(pcode=%p)\n", pcode));

    ASSERT(pcode->dwCodeType == CODETYPE_ASLTERM);

    if (!(TermTable[pcode->dwTermIndex].dwfTermClass & TC_COMPILER_DIRECTIVE))
    {
        ComputeArgsChkSumLen(pcode);
    }
    //
    // Sum the lengths of children
    //
    for (pc = pcode->pcFirstChild; pc != NULL;)
    {
        ComputeChildChkSumLen(pcode, pc);

        if ((PCODEOBJ)pc->list.plistNext == pcode->pcFirstChild)
            pc = NULL;
        else
            pc = (PCODEOBJ)pc->list.plistNext;
    }
    //
    // If this term requires a PkgLength encoding, we must include it in the
    // length.
    //
    if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
    {
        DWORD dwPktLen;

        if (pcode->dwCodeLen <= 0x3f - 1)
            pcode->dwCodeLen++;
        else if (pcode->dwCodeLen <= 0xfff - 2)
            pcode->dwCodeLen += 2;
        else if (pcode->dwCodeLen <= 0xfffff - 3)
            pcode->dwCodeLen += 3;
        else
            pcode->dwCodeLen += 4;

        if (EncodePktLen(pcode->dwCodeLen, &dwPktLen, &j) == ASLERR_NONE)
        {
            for (i = 0; i < j; ++i)
            {
                pcode->bCodeChkSum = (BYTE)(pcode->bCodeChkSum +
                                            ((PBYTE)&dwPktLen)[i]);
            }
        }
    }

    EXIT((1, "ComputeChkSumLen! (len=%ld,ChkSum=%x)\n",
	  pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeChkSumLen

/***LP  ComputeEISAID - Compute EISA ID from the ID string
 *
 *  ENTRY
 *      pszID -> ID string
 *      pdwEISAID -> to hold the EISA ID
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ComputeEISAID(pszID=%s,pdwEISAID=%p)\n", pszID, pdwEISAID));

    if (*pszID == '*')
        pszID++;

    if (strlen(pszID) != 7)
        rc = ASLERR_INVALID_EISAID;
    else
    {
        int i;

        *pdwEISAID = 0;
        for (i = 0; i < 3; ++i)
        {
            if ((pszID[i] < '@') || (pszID[i] > '_'))
            {
                rc = ASLERR_INVALID_EISAID;
                break;
            }
            else
            {
                (*pdwEISAID) <<= 5;
                (*pdwEISAID) |= pszID[i] - '@';
            }
        }

        if (rc == ASLERR_NONE)
        {
            PSZ psz;
            WORD wData;

            (*pdwEISAID) = ((*pdwEISAID & 0x00ff) << 8) |
                           ((*pdwEISAID & 0xff00) >> 8);
            wData = (WORD)strtoul(&pszID[3], &psz, 16);

            if (*psz != '\0')
            {
                rc = ASLERR_INVALID_EISAID;
            }
            else
            {
                wData = (WORD)(((wData & 0x00ff) << 8) |
                               ((wData & 0xff00) >> 8));
                (*pdwEISAID) |= (DWORD)wData << 16;
            }
        }
    }

    EXIT((1, "ComputeEISAID=%d (EISAID=%lx)\n", rc, *pdwEISAID));
    return rc;
}       //ComputeEISAID

/***LP  LookupIDIndex - lookup the given ID in the TermTable and return index
 *
 *  ENTRY
 *      lID - ID to look up
 *      pdwTermIndex -> to hold term index found
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((1, "LookupIDIndex(ID=%ld,pdwTermIndex=%p)\n", lID, pdwTermIndex));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if (lID == TermTable[i].lID)
        {
            *pdwTermIndex = (DWORD)i;
            break;
        }
    }

    if (TermTable[i].pszID == NULL)
    {
        ERROR(("LookupIDIndex: failed to find ID %ld in TermTable", lID));
        rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "LookupIDIndex=%d (Index=%d)\n", rc, *pdwTermIndex));
    return rc;
}       //LookupIDIndex

/***LP  WriteAMLFile - Write code block to AML file
 *
 *  ENTRY
 *      fhAML - AML image file handle
 *      pcode -> code block
 *      pdwOffset -> file offset
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset)
{
    int rc = ASLERR_NONE;
    int iLen;
    DWORD dwPktLen, dwLen;

    ENTER((1, "WriteAMLFile(fhAML=%x,pcode=%p,FileOffset=%x)\n",
           fhAML, pcode, *pdwOffset));

    if (pcode->dwfCode & CF_CREATED_NSOBJ)
    {
        ASSERT(pcode->pnsObj != NULL);
        ASSERT(pcode->pnsObj->dwRefCount == 0);
        pcode->pnsObj->dwRefCount = *pdwOffset;
    }

    switch (pcode->dwCodeType)
    {
        case CODETYPE_ASLTERM:
            if (pcode->dwCodeValue != OP_NONE)
            {
                iLen = OPCODELEN(pcode->dwCodeValue);
                *pdwOffset += iLen;

                if (_write(fhAML, &pcode->dwCodeValue, iLen) != iLen)
                    rc = ASLERR_WRITE_FILE;
                else if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
                {
                    if ((rc = EncodePktLen(pcode->dwCodeLen, &dwPktLen, &iLen))
                        == ASLERR_NONE)
                    {
                        *pdwOffset += iLen;
                        if (_write(fhAML, &dwPktLen, iLen) != iLen)
                        {
                            rc = ASLERR_WRITE_FILE;
                        }
                    }
                }

                if (rc == ASLERR_NONE)
                {
                    if (pcode->pbDataBuff != NULL)
                    {
                        PCODEOBJ pc;
                        int i;

                        for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                             i < (int)pcode->dwDataLen;
                             ++i)
                        {
                            if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset))
                                != ASLERR_NONE)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            if (rc == ASLERR_NONE)
            {
                PCODEOBJ pc;

                for (pc = pcode->pcFirstChild; pc != NULL;)
                {
                    if ((rc = WriteAMLFile(fhAML, pc, pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }

                    if ((PCODEOBJ)pc->list.plistNext ==
                        pcode->pcFirstChild)
                    {
                        pc = NULL;
                    }
                    else
                        pc = (PCODEOBJ)pc->list.plistNext;
                }
            }
            break;

        case CODETYPE_USERTERM:
            if (pcode->pbDataBuff != NULL)
            {
                PCODEOBJ pc;
                int i;

                for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                     i < (int)pcode->dwDataLen;
                     ++i)
                {
                    if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }
                }
            }
            break;

        case CODETYPE_FIELDOBJ:
            dwPktLen = pcode->dwCodeValue? sizeof(NAMESEG): sizeof(BYTE);
            dwLen = ((pcode->dwDataLen & 0xc0) >> 6) + 1;
            *pdwOffset += dwPktLen + dwLen;
            if ((_write(fhAML, &pcode->dwCodeValue, dwPktLen) !=
                 (int)dwPktLen) ||
                (_write(fhAML, &pcode->dwDataLen, dwLen) != (int)dwLen))
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_NAME:
        case CODETYPE_DATAOBJ:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, pcode->pbDataBuff, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_INTEGER:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, &pcode->dwCodeValue, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_UNKNOWN:
        case CODETYPE_KEYWORD:
            break;

        default:
            ERROR(("WriteAMLFile: unexpected code type - %x",
                   pcode->dwCodeType));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "WriteAMLFile=%d\n", rc));
    return rc;
}       //WriteAMLFile

/***LP  FreeCodeObjs - free code object tree
 *
 *  ENTRY
 *      pcodeRoot -> root of code object subtree to be free
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot)
{
    PCODEOBJ pcode, pcodeNext;

    ENTER((1, "FreeCodeObjs(pcodeRoot=%p,Type=%d,Term=%s,Buff=%p)\n",
           pcodeRoot, pcodeRoot->dwCodeType,
           pcodeRoot->dwCodeType == CODETYPE_ASLTERM?
               TermTable[pcodeRoot->dwTermIndex].pszID: "<null>",
           pcodeRoot->pbDataBuff));
    //
    // Free all my children
    //
    for (pcode = pcodeRoot->pcFirstChild; pcode != NULL; pcode = pcodeNext)
    {
        if ((pcodeNext = (PCODEOBJ)pcode->list.plistNext) ==
            pcodeRoot->pcFirstChild)
        {
            pcodeNext = NULL;
        }

        FreeCodeObjs(pcode);
    }

    if (pcodeRoot->pbDataBuff != NULL)
        MEMFREE(pcodeRoot->pbDataBuff);

    MEMFREE(pcodeRoot);

    EXIT((1, "FreeCodeObjs!\n"));
}       //FreeCodeObjs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\nt.c ===
/*** nt.c - NT specific functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    11/03/97
 *
 *  MODIFICATION HISTORY
 */

#ifdef ___UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
#ifndef WINNT
#define _X86_
#endif
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#define EXCL_BASEDEF
#include "aslp.h"

/***LP  IsWinNT - check if OS is NT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns TRUE - OS is NT
 *  EXIT-FAILURE
 *      returns FALSE - OS is not NT
 */

BOOL LOCAL IsWinNT(VOID)
{
    BOOL rc = FALSE;
    OSVERSIONINFO osinfo;

    ENTER((2, "IsWinNT()\n"));

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osinfo) && (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {
        rc = TRUE;
    }

    EXIT((2, "IsWinNT=%x\n", rc));
    return rc;
}       //IsWinNT

/***LP  EnumSubKey - enumerate subkey
 *
 *  ENTRY
 *      hkey - key to enumerate
 *      dwIndex - subkey index
 *
 *  EXIT-SUCCESS
 *      returns subkey
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL EnumSubKey(HKEY hkey, DWORD dwIndex)
{
    HKEY hkeySub = NULL;
    char szSubKey[32];
    DWORD dwSubKeySize = sizeof(szSubKey);

    ENTER((2, "EnumSubKey(hkey=%x,Index=%d)\n", hkey, dwIndex));

    if ((RegEnumKeyEx(hkey, dwIndex, szSubKey, &dwSubKeySize, NULL, NULL, NULL,
                      NULL) == ERROR_SUCCESS) &&
        (RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub) != ERROR_SUCCESS))
    {
        hkeySub = NULL;
    }

    EXIT((2, "EnumSubKey=%x\n", hkeySub));
    return hkeySub;
}       //EnumSubKey

/***LP  OpenNTTable - Open ACPI table in NT registry
 *
 *  ENTRY
 *      pszTabSig -> table signature string
 *
 *  EXIT-SUCCESS
 *      returns table registry handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL OpenNTTable(PSZ pszTabSig)
{
    HKEY hkeyTab = NULL, hkey1 = NULL, hkey2 = NULL;
    static char szTabKey[] = "Hardware\\ACPI\\xxxx";

    ENTER((2, "OpenNTTable(TabSig=%s)\n", pszTabSig));

    lstrcpyn(&szTabKey[lstrlen(szTabKey) - 4], pszTabSig, 5);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTabKey, 0, KEY_READ, &hkey1) ==
        ERROR_SUCCESS)
    {
        //
        // hkey1 is now "Hardware\ACPI\<TabSig>"
        //
        if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
        {
            //
            // hkey2 is now "Hardware\ACPI\<TabSig>\<OEMID>"
            //
            RegCloseKey(hkey1);
            if ((hkey1 = EnumSubKey(hkey2, 0)) != NULL)
            {
                //
                // hkey1 is now "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>"
                //
                RegCloseKey(hkey2);
                if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
                {
                    //
                    // hkey2 is now
                    // "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>\<OEMRev>"
                    //
                    hkeyTab = hkey2;
                }
            }
        }
    }

    if (hkey1 != NULL)
    {
        RegCloseKey(hkey1);
    }

    if ((hkey2 != NULL) && (hkeyTab != hkey2))
    {
        RegCloseKey(hkey2);
    }

    EXIT((2, "OpenNTTable=%x\n", hkeyTab));
    return hkeyTab;
}       //OpenNTTable

/***LP  GetNTTable - Get ACPI table from NT registry
 *
 *  ENTRY
 *      pszTabSig -> table signature string
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetNTTable(PSZ pszTabSig)
{
    PBYTE pb = NULL;
    HKEY hkeyTab;

    ENTER((2, "GetNTTable(TabSig=%s)\n", pszTabSig));

    if ((hkeyTab = OpenNTTable(pszTabSig)) != NULL)
    {
        DWORD dwLen = 0;
        PSZ pszTabKey = "00000000";

        if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, NULL, &dwLen) ==
            ERROR_SUCCESS)
        {
            if ((pb = MEMALLOC(dwLen)) != NULL)
            {
                if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, pb, &dwLen)
                    != ERROR_SUCCESS)
                {
                    ERROR(("GetNTTable: failed to read table"));
                }
            }
            else
            {
                ERROR(("GetNTTable: failed to allocate table buffer"));
            }
        }
        else
        {
            ERROR(("GetNTTable: failed to read table key"));
        }
        RegCloseKey(hkeyTab);
    }
    else
    {
        ERROR(("GetNTTable: failed to get table %s", pszTabSig));
    }

    EXIT((2, "GetNTTable=%x\n", pb));
    return pb;
}       //GetNTTable

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\pnpmacro.c ===
/*** pnpmacro.c - Parse PNP Macro terms
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    05/05/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

RESFIELD IRQFields[] =
{
    "_INT", 1*8 + 0, 16,
    "_HE",  3*8 + 0, 1,
    "_LL",  3*8 + 3, 1,
    "_SHR", 3*8 + 4, 1,
    NULL,   0,       0
};

RESFIELD IRQNoFlagsFields[] =
{
    "_INT", 1*8 + 0, 16,
    NULL,   0,       0
};

RESFIELD DMAFields[] =
{
    "_DMA", 1*8 + 0, 8,
    "_SIZ", 2*8 + 0, 2,
    "_BM",  2*8 + 2, 1,
    "_TYP", 2*8 + 5, 2,
    NULL,   0,       0
};

RESFIELD IOFields[] =
{
    "_DEC", 1*8 + 0, 1,
    "_MIN", 2*8 + 0, 16,
    "_MAX", 4*8 + 0, 16,
    "_ALN", 6*8 + 0, 8,
    "_LEN", 7*8 + 0, 8,
    NULL,   0,       0
};

RESFIELD FixedIOFields[] =
{
    "_BAS", 1*8 + 0, 16,
    "_LEN", 3*8 + 0, 8,
    NULL,   0,       0
};

RESFIELD Mem24Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_MIN", 4*8 + 0, 16,
    "_MAX", 6*8 + 0, 16,
    "_ALN", 8*8 + 0, 16,
    "_LEN", 10*8+ 0, 16,
    NULL,   0,       0
};

RESFIELD Mem32Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_MIN", 4*8 + 0, 32,
    "_MAX", 8*8 + 0, 32,
    "_ALN", 12*8+ 0, 32,
    "_LEN", 16*8+ 0, 32,
    NULL,   0,       0
};

RESFIELD FixedMem32Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_BAS", 4*8 + 0, 32,
    "_LEN", 8*8 + 0, 32,
    NULL,   0,       0
};

RESFIELD GenFlagFields[] =
{
    "_DEC", 4*8 + 1, 1,
    "_MIF", 4*8 + 2, 1,
    "_MAF", 4*8 + 3, 1,
    NULL,   0,       0
};

RESFIELD MemTypeFields[] =
{
    "_RW",  5*8 + 0, 1,
    "_MEM", 5*8 + 1, 3,
    NULL,   0,       0
};

RESFIELD IOTypeFields[] =
{
    "_RNG", 5*8 + 0, 2,
    NULL,   0,       0
};

RESFIELD DWordFields[] =
{
    "_GRA", 6*8 + 0, 32,
    "_MIN", 10*8+ 0, 32,
    "_MAX", 14*8+ 0, 32,
    "_TRA", 18*8+ 0, 32,
    "_LEN", 22*8+ 0, 32,
    NULL,   0,       0
};

RESFIELD WordFields[] =
{
    "_GRA", 6*8 + 0, 16,
    "_MIN", 8*8 + 0, 16,
    "_MAX", 10*8+ 0, 16,
    "_TRA", 12*8+ 0, 16,
    "_LEN", 14*8+ 0, 16,
    NULL,   0,       0
};

RESFIELD QWordFields[] =
{
    "_GRA", 6*8 + 0, 64,
    "_MIN", 14*8+ 0, 64,
    "_MAX", 22*8+ 0, 64,
    "_TRA", 30*8+ 0, 64,
    "_LEN", 38*8+ 0, 64,
    NULL,   0,       0
};

RESFIELD IRQExFields[] =
{
    "_HE",  3*8 + 1, 1,
    "_LL",  3*8 + 2, 1,
    "_SHR", 3*8 + 3, 1,
    NULL,   0,       0
};

ULONG dwResBitOffset = 0;

/***LP  XferCodeToBuff - Transfer code object tree to buffer
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      pdwcb -> length
 *      pcCode -> code object tree
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL XferCodeToBuff(PBYTE pbBuff, PDWORD pdwcb, PCODEOBJ pcCode)
{
    int rc = ASLERR_NONE;
    DWORD dwLen;
    int iLen;
    PCODEOBJ pc, pcNext;

    ENTER((2, "XferCodeToBuff(pbBuff=%x,Len=%x,pcCode=%x,CodeType=%x)\n",
           pbBuff, *pdwcb, pcCode, pcCode->dwCodeType));

    switch (pcCode->dwCodeType)
    {
        case CODETYPE_ASLTERM:
            if (pcCode->dwCodeValue != OP_NONE)
            {
                iLen = OPCODELEN(pcCode->dwCodeValue);
                memcpy(&pbBuff[*pdwcb], &pcCode->dwCodeValue, iLen);
                *pdwcb += (DWORD)iLen;

                if ((TermTable[pcCode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN) &&
                    ((rc = EncodePktLen(pcCode->dwCodeLen, &dwLen, &iLen)) ==
                     ASLERR_NONE))
                {
                    memcpy(&pbBuff[*pdwcb], &dwLen, iLen);
                    *pdwcb += (DWORD)iLen;
                }

                if ((rc == ASLERR_NONE) && (pcCode->pbDataBuff != NULL))
                {
                    int i;

                    for (i = 0, pc = (PCODEOBJ)pcCode->pbDataBuff;
                         i < (int)pcCode->dwDataLen;
                         ++i)
                    {
                        if ((rc = XferCodeToBuff(pbBuff, pdwcb, &pc[i])) !=
                            ASLERR_NONE)
                        {
                            break;
                        }
                    }

                    if (rc == ASLERR_NONE)
                    {
                        MEMFREE(pcCode->pbDataBuff);
                        pcCode->pbDataBuff = NULL;
                    }
                }
            }

            if (rc == ASLERR_NONE)
            {
                for (pc = pcCode->pcFirstChild; pc != NULL; pc = pcNext)
                {
                    if ((rc = XferCodeToBuff(pbBuff, pdwcb, pc)) != ASLERR_NONE)
                        break;
                    //
                    // Am I the only one left in the list?
                    //
                    if (pc->list.plistNext == &pc->list)
                        pcNext = NULL;
                    else
                        pcNext = (PCODEOBJ)pc->list.plistNext;

                    ListRemoveEntry(&pc->list,
                                    (PPLIST)&pcCode->pcFirstChild);
                    MEMFREE(pc);
                }
            }
            break;

        case CODETYPE_DATAOBJ:
        case CODETYPE_STRING:
        case CODETYPE_QWORD:
            memcpy(&pbBuff[*pdwcb], pcCode->pbDataBuff, pcCode->dwDataLen);
            *pdwcb += pcCode->dwDataLen;
            break;

        case CODETYPE_INTEGER:
            memcpy(&pbBuff[*pdwcb], &pcCode->dwCodeValue, pcCode->dwDataLen);
            *pdwcb += pcCode->dwDataLen;
            break;

        case CODETYPE_KEYWORD:
        case CODETYPE_UNKNOWN:
            break;

        default:
            ERROR(("XferCodeToBuff: unexpected code object type - %d",
                   pcCode->dwCodeType));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "XferCodeToBuff=%x (Len=%x)\n", rc, *pdwcb));
    return rc;
}       //XferCodeToBuff

/***LP  ResourceTemplate - Start of PNP Resource Template
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ResourceTemplate(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcData;

    ENTER((1, "ResourceTemplate(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);

    if (fActionFL)
    {
        dwResBitOffset = 0;
    }
    else
    {
        if ((pcData = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ResourceTemplate: failed to allocate buffer object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pcData, 0, sizeof(CODEOBJ));
            pcData->dwCodeType = CODETYPE_DATAOBJ;
            if (gpcodeScope->dwCodeLen <= 0x3f)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 1;
            else if (gpcodeScope->dwCodeLen <= 0xfff)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 2;
            else if (gpcodeScope->dwCodeLen <= 0xfffff)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 3;
            else
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 4;

            pcData->dwDataLen += 2;         //add length of EndTag

            if ((pcData->pbDataBuff = MEMALLOC(pcData->dwDataLen)) == NULL)
            {
                ERROR(("ResourceTemplate: failed to allocate data buffer"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                PCODEOBJ pc, pcNext;
                DWORD dwcb = 0;

                for (pc = gpcodeScope->pcFirstChild; pc != NULL; pc = pcNext)
                {
                    if ((rc = XferCodeToBuff(pcData->pbDataBuff, &dwcb, pc)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }
                    //
                    // Am I the only one left in the list?
                    //
                    if (pc->list.plistNext == &pc->list)
                        pcNext = NULL;
                    else
                        pcNext = (PCODEOBJ)pc->list.plistNext;

                    ListRemoveEntry(&pc->list,
                                    (PPLIST)&gpcodeScope->pcFirstChild);
                    MEMFREE(pc);
                }

                if (rc == ASLERR_NONE)
                {
                    pcData->pbDataBuff[dwcb] = 0x79;        //EndTag
                    dwcb++;
                    //
                    // Generate a zero-checksum EndTag because the ASL code
                    // will probably change the resources anyway.
                    //
                    pcData->pbDataBuff[dwcb] = 0;

                    pcData->pcParent = gpcodeScope;
                    ListInsertTail(&pcData->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);
                    ASSERT(dwcb + 1 == pcData->dwDataLen);
                    pcData->dwCodeLen = pcData->dwDataLen;
                    pcData->bCodeChkSum = ComputeDataChkSum(pcData->pbDataBuff,
                                                            pcData->dwDataLen);
                    if ((gpcodeScope->pbDataBuff = MEMALLOC(sizeof(CODEOBJ))) ==
                        NULL)
                    {
                        ERROR(("ResourceTemplate: failed to allocate buffer argument object"));
                        rc = ASLERR_OUT_OF_MEM;
                    }
                    else
                    {
                        memset(gpcodeScope->pbDataBuff, 0, sizeof(CODEOBJ));
                        if ((rc = MakeIntData(pcData->dwDataLen,
                                              (PCODEOBJ)gpcodeScope->pbDataBuff))
                            == ASLERR_NONE)
                        {
                            gpcodeScope->dwDataLen = 1;
                            gpcodeScope->dwCodeLen = 0;
                            gpcodeScope->bCodeChkSum = 0;
                            ComputeChkSumLen(gpcodeScope);
                        }
                    }
                }
            }
        }
    }

    EXIT((1, "ResourceTemplate=%d\n", rc));
    return rc;
}       //ResourceTemplate

/***LP  AddSmallOffset - Add code length to cumulative bit offset
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL AddSmallOffset(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "AddSmallOffset(ptoken=%p,fActionFL=%d)\n",
           ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);
    ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);

    dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;

    EXIT((1, "AddSmallOffset=%d\n", rc));
    return rc;
}       //AddSmallOffset

/***LP  StartDependentFn - Start of Dependent Function
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL StartDependentFn(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "StartDependentFn(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (pArgs[0].dwCodeValue > 2)
    {
        PrintTokenErr(ptoken, "Arg0 should be between 0-2", TRUE);
        rc = ASLERR_SYNTAX;
    }
    else if (pArgs[1].dwCodeValue > 2)
    {
        PrintTokenErr(ptoken, "Arg1 should be between 0-2", TRUE);
        rc = ASLERR_SYNTAX;
    }
    else
    {
        pArgs[0].dwCodeValue |= pArgs[1].dwCodeValue << 2;
        pArgs[0].bCodeChkSum = (BYTE)pArgs[0].dwCodeValue;
        gpcodeScope->dwDataLen = 1;
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "StartDependentFn=%d\n", rc));
    return rc;
}       //StartDependentFn

/***LP  IRQDesc - IRQ resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IRQDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    DWORD dwLen, dwIRQ = 0, dw;
    PCODEOBJ pc;
    #define MAX_IRQ     0x0f

    ENTER((1, "IRQDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (gpcodeScope->dwDataLen == 4)    //IRQ
    {
        dwLen = 3;

        if ((rc = SetDefMissingKW(&pArgs[2], ID_EXCLUSIVE)) == ASLERR_NONE)
        {
            EncodeKeywords(pArgs, 0x07, 0);
            if ((pArgs[0].dwCodeValue & (_LL | _HE)) == (_LL | _HE))
            {
                PrintTokenErr(ptoken,
                              "Illegal combination of interrupt level and trigger mode",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
    }
    else                                //IRQNoFlags
    {
        ASSERT(gpcodeScope->dwDataLen == 1);

        dwLen = 2;
    }

    if (rc == ASLERR_NONE)
    {
        pc = gpcodeScope->pcFirstChild;
        if (pc != NULL)
        {
            ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
            for (dw = 0; dw < pc->dwDataLen; ++dw)
            {
                if (pc->pbDataBuff[dw] > MAX_IRQ)
                {
                    PrintTokenErr(ptoken, "Invalid IRQ number", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    dwIRQ |= 1 << pc->pbDataBuff[dw];
                }
            }

            if (rc == ASLERR_NONE)
            {
                MEMFREE(pc->pbDataBuff);
                pc->pbDataBuff = NULL;
            }
        }
        else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
        {
            memset(pc, 0, sizeof(CODEOBJ));
            pc->pcParent = gpcodeScope;
            ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        }
        else
        {
            ERROR(("IRQDesc: failed to allocate DMA descriptor"));
            rc = ASLERR_OUT_OF_MEM;
        }

        if (rc == ASLERR_NONE)
        {
            PCODEOBJ pa;

            if (dwLen == 3)
                dwIRQ |= (pArgs[0].dwCodeValue & 0xff) << 16;

            SetIntObject(pc, dwIRQ, dwLen);

            pa = &pArgs[gpcodeScope->dwDataLen == 4? 3: 0];
            if (pa->dwCodeType == CODETYPE_STRING)
            {
                PNSOBJ pns;

                if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pa->pbDataBuff,
                                             gpnsCurrentScope, gpnsCurrentOwner,
                                             &pns, NSF_EXIST_ERR)) ==
                    ASLERR_NONE)
                {
                    pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                    rc = CreateResFields(ptoken, pns,
                                         gpcodeScope->dwDataLen == 4?
                                             IRQFields: IRQNoFlagsFields);
                }
                MEMFREE(pa->pbDataBuff);
                memset(pa, 0, sizeof(CODEOBJ));
            }

            if (rc == ASLERR_NONE)
            {
                gpcodeScope->dwDataLen = 0;
                MEMFREE(gpcodeScope->pbDataBuff);
                gpcodeScope->pbDataBuff = NULL;
                gpcodeScope->dwCodeLen = 0;
                gpcodeScope->bCodeChkSum = 0;
                ComputeChkSumLen(gpcodeScope);
                ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
                dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
            }
        }
    }

    EXIT((1, "IRQDesc=%d\n", rc));
    return rc;
}       //IRQDesc

/***LP  DMADesc - DMA resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DMADesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    DWORD dwDMA = 0, dw;
    PCODEOBJ pc;
    #define MAX_DMA     0x07

    ENTER((1, "DMADesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x07, 0);
    pc = gpcodeScope->pcFirstChild;
    if (pc != NULL)
    {
        ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
        for (dw = 0; dw < pc->dwDataLen; ++dw)
        {
            if (pc->pbDataBuff[dw] > MAX_DMA)
            {
                PrintTokenErr(ptoken, "Invalid DMA number", TRUE);
                rc = ASLERR_SYNTAX;
                break;
            }
            else
            {
                dwDMA |= 1 << pc->pbDataBuff[dw];
            }
        }

        if (rc == ASLERR_NONE)
        {
            MEMFREE(pc->pbDataBuff);
            pc->pbDataBuff = NULL;
        }
    }
    else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
    {
        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
    }
    else
    {
        ERROR(("DMADesc: failed to allocate DMA descriptor"));
        rc = ASLERR_OUT_OF_MEM;
    }

    if (rc == ASLERR_NONE)
    {
        dwDMA |= (pArgs[0].dwCodeValue & 0xff) << 8;

        SetIntObject(pc, dwDMA, sizeof(WORD));

        if (pArgs[3].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[3].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                rc = CreateResFields(ptoken, pns, DMAFields);
            }
            MEMFREE(pArgs[3].pbDataBuff);
            memset(&pArgs[3], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            gpcodeScope->dwDataLen = 0;
            MEMFREE(gpcodeScope->pbDataBuff);
            gpcodeScope->pbDataBuff = NULL;
            gpcodeScope->dwCodeLen = 0;
            gpcodeScope->bCodeChkSum = 0;
            ComputeChkSumLen(gpcodeScope);
            ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
            dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
        }
    }

    EXIT((1, "DMADesc=%d\n", rc));
    return rc;
}       //DMADesc

/***LP  IODesc - IO resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "IODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, IOFields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if (rc == ASLERR_NONE)
    {
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "IODesc=%d\n", rc));
    return rc;
}       //IODesc

/***LP  FixedIODesc - FixedIO resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FixedIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;

    ENTER((1, "FixedIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    if (pArgs[2].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[2].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, FixedIOFields);
        }
        MEMFREE(pArgs[2].pbDataBuff);
        memset(&pArgs[2], 0, sizeof(CODEOBJ));
    }

    if (rc == ASLERR_NONE)
    {
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "FixedIODesc=%d\n", rc));
    return rc;
}       //FixedIODesc

/***LP  VendorDesc - Vendor-defined resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      dwMaxSize - 0x07 if short resource, 0xffff if long resource
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorDesc(PTOKEN ptoken, DWORD dwMaxSize)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;
    PBYTE pbOldBuff = NULL;
    DWORD dwOldLen = 0;
    #define SHORT_MAX_SIZE      0x07
    #define LONG_MAX_SIZE       0xffff

    ENTER((1, "VendorDesc(ptoken=%p,MaxSize=%d)\n", ptoken, dwMaxSize));

    ASSERT((dwMaxSize == SHORT_MAX_SIZE) || (dwMaxSize == LONG_MAX_SIZE));
    pc = gpcodeScope->pcFirstChild;
    if (pc != NULL)
    {
        ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
        if (pc->dwDataLen > dwMaxSize)
        {
            PrintTokenErr(ptoken, "Vendor resource data can only be up to "
                          "7 bytes for short descriptor and 64K-1 bytes for "
                          "long descriptor", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else
        {
            pbOldBuff = pc->pbDataBuff;
            dwOldLen = pc->dwDataLen;
        }
    }
    else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
    {
        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
    }
    else
    {
        ERROR(("VendorDesc: failed to allocate vendor-defined resource object"));
        rc = ASLERR_OUT_OF_MEM;
    }

    if (rc == ASLERR_NONE)
    {
        int i;

        pc->dwCodeType = CODETYPE_DATAOBJ;
        if (dwMaxSize == SHORT_MAX_SIZE)
            pc->dwDataLen = dwOldLen + 1;
        else
            pc->dwDataLen = dwOldLen + sizeof(WORD);

        if ((pc->pbDataBuff = MEMALLOC(pc->dwDataLen)) != NULL)
        {
            PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;

            if (dwMaxSize == SHORT_MAX_SIZE)
            {
                pc->pbDataBuff[0] = (BYTE)(0x70 | dwOldLen);
                i = 1;
            }
            else
            {
                *((PWORD)&pc->pbDataBuff[0]) = (WORD)dwOldLen;
                i = sizeof(WORD);
            }

            if (pbOldBuff != NULL)
            {
                memcpy(&pc->pbDataBuff[i], pbOldBuff, dwOldLen);
                MEMFREE(pbOldBuff);
            }
            pc->dwCodeLen = pc->dwDataLen;
            pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&pc->pbDataBuff,
                                                pc->dwCodeLen);

            if (pArgs[0].dwCodeType == CODETYPE_STRING)
            {
                PNSOBJ pns;

                if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[0].pbDataBuff,
                                             gpnsCurrentScope, gpnsCurrentOwner,
                                             &pns, NSF_EXIST_ERR)) ==
                    ASLERR_NONE)
                {
                    pns->ObjData.dwDataType = OBJTYPE_RES_FIELD;
                    pns->ObjData.uipDataValue = dwResBitOffset +
                                               (dwMaxSize == SHORT_MAX_SIZE?
                                                8: 8*3);
                    pns->ObjData.dwDataLen = 8*dwOldLen;
                }
                MEMFREE(pArgs[0].pbDataBuff);
                memset(&pArgs[0], 0, sizeof(CODEOBJ));
            }

            if (rc == ASLERR_NONE)
            {
                gpcodeScope->dwDataLen = 0;
                MEMFREE(gpcodeScope->pbDataBuff);
                gpcodeScope->pbDataBuff = NULL;
                gpcodeScope->dwCodeLen = 0;
                gpcodeScope->bCodeChkSum = 0;
                ComputeChkSumLen(gpcodeScope);

                if (dwMaxSize == SHORT_MAX_SIZE)
                {
                    dwResBitOffset += ((pc->pbDataBuff[0] & 0x07) + 1)*8;
                }
                else
                {
                    dwResBitOffset += (*((PWORD)&pc->pbDataBuff[0]) + 3)*8;
                }
            }
        }
        else
        {
            ERROR(("VendorDesc: failed to allocate vendor-defined resource buffer"));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((1, "VendorDesc=%d\n", rc));
    return rc;
}       //VendorDesc

/***LP  VendorShort - Vendor-defined short resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorShort(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "VendorShort(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    rc = VendorDesc(ptoken, 0x07);

    EXIT((1, "VendorShort=%d\n", rc));
    return rc;
}       //VendorShort

/***LP  InsertDescLength - Insert long descriptor length
 *
 *  ENTRY
 *      pcode -> code object
 *      dwDescLen - length of descriptor
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InsertDescLength(PCODEOBJ pcode, DWORD dwDescLen)
{
    int rc;
    PCODEOBJ pNewArgs;

    ENTER((2, "InsertDescLength(pcode=%x,DescLen=%d)\n", pcode, dwDescLen));

    if ((pNewArgs = MEMALLOC((pcode->dwDataLen + 1)*sizeof(CODEOBJ))) != NULL)
    {
        memcpy(&pNewArgs[1], pcode->pbDataBuff,
               pcode->dwDataLen*sizeof(CODEOBJ));
        memset(&pNewArgs[0], 0, sizeof(CODEOBJ));
        SetIntObject(&pNewArgs[0], dwDescLen, sizeof(WORD));
        MEMFREE(pcode->pbDataBuff);
        pcode->dwDataLen++;
        pcode->pbDataBuff = (PBYTE)pNewArgs;

        rc = ASLERR_NONE;
    }
    else
    {
        ERROR(("InsertDescLength: failed to allocate new argument objects"));
        rc = ASLERR_OUT_OF_MEM;
    }

    EXIT((2, "InsertDescLength=%d\n", rc));
    return rc;
}       //InsertDescLength

/***LP  Memory24Desc - 24-bit memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Memory24Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Memory24Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, Mem24Fields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 9)) == ASLERR_NONE))
    {
        dwResBitOffset += 12*8;
    }

    EXIT((1, "Memory24Desc=%d\n", rc));
    return rc;
}       //Memory24Desc

/***LP  VendorLong - Vendor-defined long resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorLong(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "VendorLong(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    rc = VendorDesc(ptoken, 0xffff);

    EXIT((1, "VendorLong=%d\n", rc));
    return rc;
}       //VendorLong

/***LP  Memory32Desc - 32-bit memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Memory32Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Memory32Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, Mem32Fields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 17)) == ASLERR_NONE))
    {
        dwResBitOffset += 20*8;
    }

    EXIT((1, "Memory32Desc=%d\n", rc));
    return rc;
}       //Memory32Desc

/***LP  FixedMemory32Desc - 32-bit fixed memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FixedMemory32Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "FixedMemory32Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[3].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[3].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, FixedMem32Fields);
        }
        MEMFREE(pArgs[3].pbDataBuff);
        memset(&pArgs[3], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 9)) == ASLERR_NONE))
    {
        dwResBitOffset += 12*8;
    }

    EXIT((1, "FixedMemory32Desc=%d\n", rc));
    return rc;
}       //FixedMemory32Desc

#define RESTYPE_MEM     0
#define RESTYPE_IO      1
#define RESTYPE_BUSNUM  2

/***LP  MemSpaceDesc - Memory space descriptor
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      dwMinLen - minimum descriptor length
 *      ResFields -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL MemSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "MemSpaceDesc(ptoken=%p,MinLen=%d,ResFields=%p)\n",
           ptoken, dwMinLen, ResFields));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_POSDECODE)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[4], ID_NONCACHEABLE)) == ASLERR_NONE))
    {
        EncodeKeywords(pArgs, 0x0f, 2);
        EncodeKeywords(pArgs, 0x30, 3);
        SetIntObject(&pArgs[1], RESTYPE_MEM, sizeof(BYTE));

        if (!(pArgs[11].dwfCode & CF_MISSING_ARG))
            dwMinLen++;

        if (!(pArgs[12].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[12].dwCodeType == CODETYPE_STRING);
            dwMinLen += pArgs[12].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwMinLen, sizeof(WORD));

        if (pArgs[13].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[13].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if (((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                     ASLERR_NONE) &&
                    ((rc = CreateResFields(ptoken, pns, MemTypeFields)) ==
                     ASLERR_NONE))
                {
                    rc = CreateResFields(ptoken, pns, ResFields);
                }
            }
            MEMFREE(pArgs[13].pbDataBuff);
            memset(&pArgs[13], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwMinLen + 3)*8;
        }
    }

    EXIT((1, "MemSpaceDesc=%d\n", rc));
    return rc;
}       //MemSpaceDesc

/***LP  IOSpaceDesc - IO space descriptor
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      dwMinLen - minimum descriptor length
 *      ResFields -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IOSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((2, "IOSpaceDesc(ptoken=%p,MinLen=%d,ResFields=%p)\n",
           ptoken, dwMinLen, ResFields));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_POSDECODE)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[4], ID_ENTIRERNG)) == ASLERR_NONE))
    {
        EncodeKeywords(pArgs, 0x0f, 2);
        EncodeKeywords(pArgs, 0x10, 3);
        SetIntObject(&pArgs[1], RESTYPE_IO, sizeof(BYTE));

        if (!(pArgs[10].dwfCode & CF_MISSING_ARG))
            dwMinLen++;

        if (!(pArgs[11].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[11].dwCodeType == CODETYPE_STRING);
            dwMinLen += pArgs[11].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwMinLen, sizeof(WORD));

        if (pArgs[12].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[12].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if (((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                     ASLERR_NONE) &&
                    ((rc = CreateResFields(ptoken, pns, MemTypeFields)) ==
                     ASLERR_NONE))
                {
                    rc = CreateResFields(ptoken, pns, ResFields);
                }
            }
            MEMFREE(pArgs[12].pbDataBuff);
            memset(&pArgs[12], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwMinLen + 3)*8;
        }
    }

    EXIT((2, "IOSpaceDesc=%d\n", rc));
    return rc;
}       //IOSpaceDesc

/***LP  DWordMemDesc - DWord memory descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DWordMemDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "DWordMemDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = MemSpaceDesc(ptoken, 23, DWordFields);

    EXIT((1, "DWordMemDesc=%d\n", rc));
    return rc;
}       //DWordMemDesc

/***LP  DWordIODesc - DWord IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DWordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "DWordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 23, DWordFields);

    EXIT((1, "DWordIODesc=%d\n", rc));
    return rc;
}       //DWordIODesc

/***LP  WordIODesc - Word IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "WordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 13, WordFields);

    EXIT((1, "WordIODesc=%d\n", rc));
    return rc;
}       //WordIODesc

/***LP  WordBusNumDesc - Word BusNum descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WordBusNumDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "WordBusNumDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_POSDECODE)) == ASLERR_NONE))
    {
        DWORD dwLen;

        EncodeKeywords(pArgs, 0x0f, 2);
        SetIntObject(&pArgs[1], RESTYPE_BUSNUM, sizeof(BYTE));
        SetIntObject(&pArgs[3], 0, sizeof(BYTE));

        dwLen = 13;
        if (!(pArgs[9].dwfCode & CF_MISSING_ARG))
            dwLen++;

        if (!(pArgs[10].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[10].dwCodeType == CODETYPE_STRING);
            dwLen += pArgs[10].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwLen, sizeof(WORD));

        if (pArgs[11].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[11].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if ((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                    ASLERR_NONE)
                {
                    rc = CreateResFields(ptoken, pns, WordFields);
                }
            }
            MEMFREE(pArgs[11].pbDataBuff);
            memset(&pArgs[11], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwLen + 3)*8;
        }
    }

    EXIT((1, "WordBusNumDesc=%d\n", rc));
    return rc;
}       //WordBusNumDesc

/***LP  InterruptDesc - Extended Interrupt resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InterruptDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    PCODEOBJ pc;

    ENTER((1, "InterruptDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    pc = gpcodeScope->pcFirstChild;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_EXCLUSIVE)) == ASLERR_NONE))
    {
        if (pArgs[1].dwCodeValue == ID_EDGE)
            pArgs[1].dwCodeValue = ID_EXT_EDGE;
        else if (pArgs[1].dwCodeValue == ID_LEVEL)
            pArgs[1].dwCodeValue = ID_EXT_LEVEL;

        if (pArgs[2].dwCodeValue == ID_ACTIVEHI)
            pArgs[2].dwCodeValue = ID_EXT_ACTIVEHI;
        else if (pArgs[2].dwCodeValue == ID_ACTIVELO)
            pArgs[2].dwCodeValue = ID_EXT_ACTIVELO;

        if (pArgs[3].dwCodeValue == ID_SHARED)
            pArgs[3].dwCodeValue = ID_EXT_SHARED;
        else if (pArgs[3].dwCodeValue == ID_EXCLUSIVE)
            pArgs[3].dwCodeValue = ID_EXT_EXCLUSIVE;

        if (((rc = LookupIDIndex(pArgs[1].dwCodeValue, &pArgs[1].dwTermIndex))
             == ASLERR_NONE) &&
            ((rc = LookupIDIndex(pArgs[2].dwCodeValue, &pArgs[2].dwTermIndex))
             == ASLERR_NONE) &&
            ((rc = LookupIDIndex(pArgs[3].dwCodeValue, &pArgs[3].dwTermIndex))
             == ASLERR_NONE))
        {
            EncodeKeywords(pArgs, 0x0f, 1);
            {
                DWORD dwNumIRQs = 0;
                DWORD dwLen;

                if (pc != NULL)
                {
                    ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
                    dwNumIRQs = pc->dwDataLen/sizeof(DWORD);
                }

                SetIntObject(&pArgs[2], dwNumIRQs, sizeof(BYTE));
                memcpy(&pArgs[3], pc, sizeof(CODEOBJ));
                MEMFREE(pc);
                gpcodeScope->pcFirstChild = NULL;

                dwLen = 2 + dwNumIRQs*sizeof(DWORD);
                if (!(pArgs[4].dwfCode & CF_MISSING_ARG))
                    dwLen++;

                if (!(pArgs[5].dwfCode & CF_MISSING_ARG))
                {
                    ASSERT(pArgs[5].dwCodeType == CODETYPE_STRING);
                    dwLen += pArgs[5].dwDataLen;
                }

                SetIntObject(&pArgs[0], dwLen, sizeof(WORD));

                if (pArgs[6].dwCodeType == CODETYPE_STRING)
                {
                    PNSOBJ pns;
                    static RESFIELD IRQTabFields[] =
                    {
                        "_INT", 5*8 + 0, 0,
                        NULL,   0,       0
                    };

                    IRQTabFields[0].dwBitSize = dwNumIRQs*32;
                    if ((rc = CreateNameSpaceObj(ptoken,
                                                 (PSZ)pArgs[6].pbDataBuff,
                                                 gpnsCurrentScope,
                                                 gpnsCurrentOwner,
                                                 &pns, NSF_EXIST_ERR)) ==
                        ASLERR_NONE)
                    {
                        pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                        if ((rc = CreateResFields(ptoken, pns, IRQExFields)) ==
                            ASLERR_NONE)
                        {
                            rc = CreateResFields(ptoken, pns, IRQTabFields);
                        }
                    }
                    MEMFREE(pArgs[6].pbDataBuff);
                    memset(&pArgs[6], 0, sizeof(CODEOBJ));
                }

                if (rc == ASLERR_NONE)
                {
                    gpcodeScope->dwCodeLen = 0;
                    gpcodeScope->bCodeChkSum = 0;
                    ComputeChkSumLen(gpcodeScope);
                    dwResBitOffset = (dwLen + 3)*8;
                }
            }
        }
    }

    EXIT((1, "InterruptDesc=%d\n", rc));
    return rc;
}       //InterruptDesc

/***LP  QWordMemDesc - QWord memory descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QWordMemDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "QWordMemDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = MemSpaceDesc(ptoken, 43, QWordFields);

    EXIT((1, "QWordMemDesc=%d\n", rc));
    return rc;
}       //QWordMemDesc

/***LP  QWordIODesc - QWord IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QWordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "QWordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 43, QWordFields);

    EXIT((1, "QWordIODesc=%d\n", rc));
    return rc;
}       //QWordIODesc

/***LP  CreateResFields - Create resource fields
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pnsParent -> parent object
 *      prf -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateResFields(PTOKEN ptoken, PNSOBJ pnsParent, PRESFIELD prf)
{
    int rc = ASLERR_NONE;
    int i;
    PNSOBJ pns;

    ENTER((2, "CreateResFields(ptoken=%p,pnsParent=%s,prf=%p)\n",
           ptoken, GetObjectPath(pnsParent), prf));

    for (i = 0; prf[i].pszName != NULL; ++i)
    {
        if ((rc = CreateNameSpaceObj(ptoken, prf[i].pszName, pnsParent,
                                     gpnsCurrentOwner, &pns, NSF_EXIST_ERR))
            == ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_RES_FIELD;
            pns->ObjData.uipDataValue = dwResBitOffset + prf[i].dwBitOffset;
            pns->ObjData.dwDataLen = prf[i].dwBitSize;
        }
    }

    EXIT((2, "CreateResFields=%d\n", rc));
    return rc;
}      //CreateResFields
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\parsearg.c ===
/*** parsearg.c - Library functions for parsing command line arguments
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This module provides general purpose services to parse
 *  command line arguments.
 *
 *  MODIFICATION HISTORY
 */

#include "basedef.h"
#include "parsearg.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*** Local function prototypes
 */

int LOCAL ParseArgSwitch(char **, PARGTYPE, PPROGINFO);
VOID LOCAL PrintError(int, char *, PPROGINFO);

/***EP  ParseProgInfo - parse program path and module name
 *
 *  ENTRY
 *      pszArg0 -> argument 0
 *      pPI -> program info structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT ParseProgInfo(char *pszArg0, PPROGINFO pPI)
{
    char *pch;

    pPI->pszProgPath = _strlwr(pszArg0);
    if ((pch = strrchr(pszArg0, '\\')) != NULL)
    {
        *pch = '\0';
        pPI->pszProgName = pch + 1;
    }
    else
    {
	pPI->pszProgName = pszArg0;
    }

    if ((pch = strchr(pPI->pszProgName, '.')) != NULL)
        *pch = '\0';
}       //ParseProgInfo

/***EP  ParseSwitches - parse command switches
 *
 *  ENTRY
 *      pcArg -> argument count
 *      pppszArg -> pointer to array of pointers to argument strings
 *      pAT -> argument type array
 *      pPI -> program info. structure
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns error code, *pppszArg -> error argument
 */

int EXPORT ParseSwitches(int *pcArg, char ***pppszArg, PARGTYPE pAT, PPROGINFO pPI)
{
    int  rc = ARGERR_NONE;
    char *pszArg;

    if (pPI->pszSwitchChars == NULL)
        pPI->pszSwitchChars = DEF_SWITCHCHARS;

    if (pPI->pszSeparators == NULL)
        pPI->pszSeparators = DEF_SEPARATORS;

    for (; *pcArg; (*pcArg)--, (*pppszArg)++)
    {
        pszArg = **pppszArg;
        if (strchr(pPI->pszSwitchChars, *pszArg))
        {
            pszArg++;
            if ((rc = ParseArgSwitch(&pszArg, pAT, pPI)) != ARGERR_NONE)
            {
                PrintError(rc, pszArg, pPI);
                break;
            }
        }
        else
            break;
    }

    return rc;
}       //ParseSwitches


/***LP  ParseArgSwitch - parse a command line switch
 *
 *  ENTRY
 *      ppszArg -> pointer to argument
 *      pAT -> argument type table
 *      pPI -> program info. structure
 *
 *  EXIT
 *      return argument parsed status - ARGERR_NONE
 *                                    - ARGERR_UNKNOWN_SWITCH
 *                                    - ARGERR_INVALID_NUM
 *                                    - ARGERR_NO_SEPARATOR
 *                                    - ARGERR_INVALID_TAIL
 */

int LOCAL ParseArgSwitch(char **ppszArg, PARGTYPE pAT, PPROGINFO pPI)
{
    int rc = ARGERR_NONE;
    char *pEnd;
    PARGTYPE pAT1;
    int fFound = FALSE;
    int lenMatch = 0;

    pAT1 = pAT;
    while (pAT1->pszArgID[0])
    {
        lenMatch = strlen(pAT1->pszArgID);
        if (pAT1->uParseFlags & PF_NOI)
            fFound = (strncmp(pAT1->pszArgID, *ppszArg, lenMatch) == 0);
        else
            fFound = (_strnicmp(pAT1->pszArgID, *ppszArg, lenMatch) == 0);

        if (fFound)
            break;
        else
            pAT1++;
    }

    if (fFound)
    {
        *ppszArg += lenMatch;
        switch (pAT1->uArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pAT1->uParseFlags & PF_SEPARATOR)
                {
                    if (**ppszArg && strchr(pPI->pszSeparators, **ppszArg))
                        (*ppszArg)++;
                    else
                    {
                        rc = ARGERR_NO_SEPARATOR;
                        break;
                    }
                }

                if (pAT1->uArgType == AT_STRING)
                    *(char **)pAT1->pvArgData = *ppszArg;
                else
                {
                    *(int *)pAT1->pvArgData = (int)
                        strtol(*ppszArg, &pEnd, pAT1->uArgParam);
                    if (*ppszArg == pEnd)
                    {
                        rc = ARGERR_INVALID_NUM;
                        break;
                    }
                    else
                        *ppszArg = pEnd;
                }
                if (pAT1->pfnArgVerify)
                    rc = (*pAT1->pfnArgVerify)(ppszArg, pAT1);
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pAT1->uArgType == AT_ENABLE)
                    *(unsigned *)pAT1->pvArgData |= pAT1->uArgParam;
                else
                    *(unsigned *)pAT1->pvArgData &= ~pAT1->uArgParam;

                if ((pAT1->pfnArgVerify) &&
                    ((rc = (*pAT1->pfnArgVerify)(ppszArg, pAT1)) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (**ppszArg)
                {
                    if (strchr(pPI->pszSwitchChars, **ppszArg))
                        (*ppszArg)++;
                    rc = ParseArgSwitch(ppszArg, pAT, pPI);
                }
                break;

            case AT_ACTION:
#pragma warning(disable: 4055)
                rc = (*(PFNARG)pAT1->pvArgData)(ppszArg, pAT1);
#pragma warning(default: 4055)
                break;
        }
    }
    else
        rc = ARGERR_UNKNOWN_SWITCH;

    return rc;
}       //ParseArgSwitch


/***LP  PrintError - print appropriate error message according to error code
 *
 *  ENTRY
 *      iErr = error code
 *      pszArg -> argument in error
 *      pPI -> program info. structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintError(int iErr, char *pszArg, PPROGINFO pPI)
{
    switch (iErr)
    {
        case ARGERR_UNKNOWN_SWITCH:
            printf("%s: unknown switch \"%s\"\n", pPI->pszProgName, pszArg);
            break;

        case ARGERR_NO_SEPARATOR:
            printf("%s: separator missing after the switch char '%c'\n",
                   pPI->pszProgName, *(pszArg-1));
            break;

        case ARGERR_INVALID_NUM:
            printf("%s: invalid numeric switch \"%s\"\n",
                   pPI->pszProgName, pszArg);
            break;

        case ARGERR_INVALID_TAIL:
            printf("%s: invalid argument tail \"%s\"\n",
                   pPI->pszProgName, pszArg);
    }
}       //PrintError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\parsearg.h ===
/*** parsearg.h - Exported definitions for parsearg.c
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PARSEARG_H
#define _PARSEARG_H

// Error codes
#define ARGERR_NONE             0
#define ARGERR_UNKNOWN_SWITCH   1
#define ARGERR_NO_SEPARATOR     2
#define ARGERR_INVALID_NUM      3
#define ARGERR_INVALID_TAIL     4

#define DEF_SWITCHCHARS         "/-"
#define DEF_SEPARATORS          ":="

typedef struct argtype_s    ARGTYPE;
typedef ARGTYPE *           PARGTYPE;
typedef int (*PFNARG)(char **, PARGTYPE);

// Argument types
#define AT_STRING       1
#define AT_NUM          2
#define AT_ENABLE       3
#define AT_DISABLE      4
#define AT_ACTION       5

//Parse flags
#define PF_NOI          0x0001  //No-Ignore-Case
#define PF_SEPARATOR    0x0002  //parse for separator

struct argtype_s
{
    char        *pszArgID;      //argument ID string
    unsigned    uArgType;       //see argument types defined above
    unsigned    uParseFlags;    //see parse flags defined above
    VOID        *pvArgData;     //ARG_STRING: (char **) - ptr to string ptr
                                //ARG_NUM: (int *) - ptr to integer number
                                //ARG_ENABLE: (unsigned *) - ptr to flags
                                //ARG_DISABLE: (unsigned *) - ptr to flags
                                //ARG_ACTION: ptr to function
    unsigned    uArgParam;      //ARG_STRING: none
                                //ARG_NUM: base
                                //ARG_ENABLE: flag bit mask
                                //ARG_DISABLE: flag bit mask
                                //ARG_ACTION: none
    PFNARG      pfnArgVerify;   //pointer to argument verification function
                                //this will be ignored for ARG_ACTION
};

typedef struct proginfo_s
{
    char *pszSwitchChars;       //if null, DEF_SWITCHCHARS is used
    char *pszSeparators;        //if null, DEF_SEPARATORS is used
    char *pszProgPath;          //ParseProgInfo set this ptr to prog. path
    char *pszProgName;          //ParseProgInfo set this ptr to prog. name
} PROGINFO;
typedef PROGINFO *PPROGINFO;

//Export function prototypes
VOID EXPORT ParseProgInfo(char *, PPROGINFO);
int  EXPORT ParseSwitches(int *, char ***, PARGTYPE, PPROGINFO);

#endif  //ifndef _PARSEARG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\pch.h ===
#pragma warning (disable: 4201)

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define TUNE
#endif

#ifndef EXCL_BASEDEF
  #include "basedef.h"
#endif

#include <stdio.h>      //for FILE *
#include <stdlib.h>     //for malloc
#include <string.h>     //for _stricmp
#include <ctype.h>      //for isspace
#ifdef WINNT
  #include <crt\io.h>   //for _open, _close, _read, _write
#else
  #include <io.h>
#endif
#include <fcntl.h>      //for open flags
#include <sys\stat.h>   //for pmode flags

//#define _UNASM_LIB

#include <acpitabl.h>
#include "list.h"
#include "debug.h"
#define _INC_NSOBJ_ONLY
#include "amli.h"
#include "aml.h"
#include "uasmdata.h"

#ifdef _UNASM_LIB
  #define PTOKEN PVOID
#else
  #include "aslp.h"
  #include "parsearg.h"
  #include "line.h"
  #define TOKERR_BASE -100
  #include "token.h"
  #include "scanasl.h"
  #ifdef __UNASM
    #include "..\acpitab\acpitab.h"
    #define USE_CRUNTIME
    #include "binfmt.h"
  #endif
  #include "proto.h"
  #include "data.h"
#endif  //ifdef _UNASM_LIB

#include "acpins.h"
#include "unasm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\proto.h ===
/*** proto.h - Local function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PROTO_H
#define _PROTO_H

// asl.c
int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig);
VOID LOCAL PrintLogo(VOID);
int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT);
VOID LOCAL PrintUsage(VOID);

// parseasl.c
int LOCAL ParseASLFile(PSZ pszFile);
int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel);
BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent);
int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel);
int LOCAL ParseFieldList(PTOKEN ptoken);
int LOCAL ParsePackageList(PTOKEN ptoken);
int LOCAL ParseBuffList(PTOKEN ptoken);
int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize);
int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs);
int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK);
int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode);
int LOCAL ParseSuperName(PTOKEN ptoken);
int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc);
int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData);
int LOCAL ParseData(PTOKEN ptoken);
int LOCAL ParseInteger(PTOKEN ptoken, char c);
int LOCAL ParseOpcode(PTOKEN ptoken, char c);
int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType);
int LOCAL ParseString(PTOKEN ptoken);
int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType);
int LOCAL ValidateNSChkList(PNSCHK pnschkHead);
int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData);

// aslterms.c
int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Include(PTOKEN ptoken, BOOL fActionFL);
int LOCAL External(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Method(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Alias(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Name(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Scope(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Field(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL);
int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Match(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Else(PTOKEN ptoken, BOOL fActionFL);

// pnpmacro.c
int LOCAL XferCodeToBuff(PBYTE pbBuff, PDWORD pdwcb, PCODEOBJ pcCode);
int LOCAL ResourceTemplate(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AddSmallOffset(PTOKEN ptoken, BOOL fActionFL);
int LOCAL StartDependentFn(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IRQDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DMADesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorDesc(PTOKEN ptoken, DWORD dwMaxSize);
int LOCAL VendorShort(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InsertDescLength(PCODEOBJ pcode, DWORD dwDescLen);
int LOCAL Memory24Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorLong(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Memory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedMemory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL MemSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL IOSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL DWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordBusNumDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InterruptDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL CreateResFields(PTOKEN ptoken, PNSOBJ pnsParent, PRESFIELD prf);

// misc.c
BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen);
BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken);
int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen);
int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding);
VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum);
int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen);
int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID);
VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen);
VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild);
VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode);
VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode);
int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID);
int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex);
int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset);
VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot);

#ifdef __UNASM
// tables.c
BOOL LOCAL IsWinNT(VOID);
#ifndef WINNT
HANDLE LOCAL OpenVxD(VOID);
VOID LOCAL CloseVxD(HANDLE hVxD);
PBYTE LOCAL VxDGetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL VxDGetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
#endif
PBYTE LOCAL GetNTTable(DWORD dwTabSig);
PBYTE LOCAL GetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL GetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
int LOCAL DumpAllTables(FILE *pfileOut);
int LOCAL DumpTableBySig(FILE *pfileOut, DWORD dwTableSig);
int LOCAL DumpTableByAddr(FILE *pfileOut, DWORD dwTableAddr);
int LOCAL DumpRSDP(FILE *pfileOut, PBYTE pb, DWORD dwAddr);
int LOCAL DumpTable(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                    DWORD dwTableSig);
int LOCAL DumpTableTxt(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                       DWORD dwTableSig);
int LOCAL DumpTableBin(DWORD dwTableSig, DWORD dwAddr, PBYTE pb, DWORD dwLen);
int LOCAL FindTableFmt(DWORD dwTableSig, PFMT *ppfmt, PDWORD pdwFlags);
PSZ LOCAL GetTableSigStr(DWORD dwTableSig);
BOOL LOCAL ValidateTable(PBYTE pbTable, DWORD dwLen);
BOOL LOCAL IsALikelySig(DWORD dwTableSig);
#endif

#endif  //ifndef _PROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\parseasl.c ===
/*** parseasl.c - Parse ASL source file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/07/96
 *
 *  This module implements a recursive decent parser for the ASL language.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ParseASLFile - Parse the ASL source file
 *
 *  ENTRY
 *      pszFile -> file name string
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLFile(PSZ pszFile)
{
    int rc = ASLERR_NONE;
    FILE *pfileSrc;
    PTOKEN ptoken;
    PSZ pszOldFile;

    ENTER((1, "ParseASLFile(File=%s)\n", pszFile));

    if ((pfileSrc = fopen(pszFile, "r")) == NULL)
    {
        ERROR(("ParseASLFile: failed to open source file - %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else
    {
        if ((ptoken = OpenScan(pfileSrc)) == NULL)
        {
            ERROR(("ParseASLFile: failed to initialize scanner"));
            rc = ASLERR_INIT_SCANNER;
        }
        else
        {
            pszOldFile = gpszASLFile;
            gpszASLFile = pszFile;
            printf("%s:\n", pszFile);
            if ((rc = ParseASLTerms(ptoken, 0)) == TOKERR_EOF)
                rc = ASLERR_NONE;
            else if (rc == ASLERR_EXPECT_EOF)
            {
                PrintTokenErr(ptoken, "Expecting end-of-file", TRUE);
            }

            gpszASLFile = pszOldFile;
            CloseScan(ptoken);
        }

        fclose(pfileSrc);
    }

    EXIT((1, "ParseASLFile=%d\n", rc));
    return rc;
}       //ParseASLFile

/***LP  ParseASLTerms - Parse all ASL statements
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcode;

    ENTER((1, "ParseASLTerms(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    do
    {
        if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParseASLTerms: failed to allocate code object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pcode, 0, sizeof(CODEOBJ));

            if (gpcodeRoot == NULL)
                gpcodeRoot = pcode;
            else if (gpcodeScope != NULL)
            {
                pcode->pcParent = gpcodeScope;
                ListInsertTail(&pcode->list,
                               (PPLIST)&gpcodeScope->pcFirstChild);
            }

            gpcodeScope = pcode;
            rc = ParseASLTerm(ptoken, iNestLevel);
            gpcodeScope = pcode->pcParent;

            if (rc != ASLERR_NONE)
            {
                if (gpcodeRoot == pcode)
                    gpcodeRoot = NULL;
                else if (gpcodeScope != NULL)
                {
                    ListRemoveEntry(&pcode->list,
                                    (PPLIST)&gpcodeScope->pcFirstChild);
                }

                MEMFREE(pcode);
            }
        }
    } while (rc == ASLERR_NONE);

    EXIT((1, "ParseASLTerms=%d\n", rc));
    return rc;
}       //ParseASLTerms

/***LP  ValidateTermClass - Validate term class with parent
 *
 *  ENTRY
 *      dwTermClass - term class of child
 *      pcParent -> parent
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent)
{
    BOOL rc = TRUE;

    ENTER((2, "ValidateTermClass(TermClass=%x,Parent=%p)\n",
           dwTermClass, pcParent));

    if ((dwTermClass & TC_COMPILER_DIRECTIVE) == 0)
    {
        while (pcParent != NULL)
        {
            //
            // Go upward to find a parent that is not "Include".
            //
            if (TermTable[pcParent->dwTermIndex].lID == ID_INCLUDE)
            {
                pcParent = pcParent->pcParent;
            }
            else
            {
                break;
            }
        }

        if ((pcParent != NULL) && (pcParent->dwfCode & CF_PARSING_VARLIST))
        {
            rc = (dwTermClass & TermTable[pcParent->dwTermIndex].dwfTerm) != 0;
        }
    }

    EXIT((2, "ValidateTermClass=%d\n", rc));
    return rc;
}       //ValidateTermClass

/***LP  ParseASLTerm - Parse an ASL statement
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel)
{
    int rc;

    ENTER((1, "ParseASLTerm(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RBRACE, MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (iNestLevel == 0)
            rc = ASLERR_EXPECT_EOF;
        else
        {
            //
            // We have no more terms in the current scope
            //
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
    }
    else if ((rc != TOKERR_EOF) &&
             ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE, NULL)) ==
              TOKERR_NONE))
    {
        if ((gpcodeRoot == NULL) &&
            ((ptoken->llTokenValue < 0) ||
             (TermTable[ptoken->llTokenValue].lID != ID_DEFBLK)))
        {
            //
            // outside of definition block
            //
            rc = ASLERR_EXPECT_EOF;
        }
        else if (ptoken->llTokenValue == ID_USER)       //user term
        {
            if ((rc = ParseUserTerm(ptoken, FALSE)) == TOKERR_NO_MATCH)
            {
                PrintTokenErr(ptoken, "User ID is not a method", TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->llTokenValue >= 0)             //ASL term
        {
            PNSOBJ pnsScopeSave = gpnsCurrentScope;
            PNSOBJ pnsOwnerSave = gpnsCurrentOwner;
            PASLTERM pterm;
            int iNumArgs;

            pterm = &TermTable[ptoken->llTokenValue];
            iNumArgs = pterm->pszArgTypes? strlen(pterm->pszArgTypes): 0;
            gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = pterm->dwOpcode;
            gpcodeScope->dwDataLen = (DWORD)iNumArgs;

            if (!ValidateTermClass(pterm->dwfTermClass, gpcodeScope->pcParent))
            {
                PrintTokenErr(ptoken, "unexpected ASL term type", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if (pterm->pszArgTypes != NULL)        //there is a fixed list
                rc = ParseArgs(ptoken, pterm, iNumArgs);

            if ((rc == ASLERR_NONE) && (pterm->dwfTerm & TF_ACTION_FLIST))
            {
                ASSERT(pterm->pfnTerm != NULL);
                rc = pterm->pfnTerm(ptoken, TRUE);
            }

            if (rc == ASLERR_NONE)
            {
                if (pterm->dwfTerm & TF_ALL_LISTS)
                {
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LBRACE, 0,
                                         NULL)) == TOKERR_NONE)
                    {
                        if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                        {
                            ASSERT(gpcodeScope->pnsObj != NULL);
                            gpnsCurrentScope = gpcodeScope->pnsObj;
                        }

                        if (pterm->lID == ID_METHOD)
                        {
                            gpnsCurrentOwner = gpcodeScope->pnsObj;
                        }

                        gpcodeScope->dwfCode |= CF_PARSING_VARLIST;

                        if (pterm->dwfTerm & TF_FIELD_LIST)
                            rc = ParseFieldList(ptoken);
                        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
                            rc = ParsePackageList(ptoken);
                        else if (pterm->dwfTerm & TF_DATA_LIST)
                            rc = ParseBuffList(ptoken);
                        else if (pterm->dwfTerm & TF_BYTE_LIST)
                            rc = ParseDataList(ptoken, sizeof(BYTE));
                        else if (pterm->dwfTerm & TF_DWORD_LIST)
                            rc = ParseDataList(ptoken, sizeof(DWORD));
                        else
                            rc = ParseASLTerms(ptoken, iNestLevel + 1);

                        gpcodeScope->dwfCode &= ~CF_PARSING_VARLIST;

                        if (((rc == TOKERR_NO_MATCH) || (rc == TOKERR_EOF)) &&
                            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL,
                                              SYM_RBRACE, 0, NULL)) ==
                             TOKERR_NONE))
                        {
                            ComputeChkSumLen(gpcodeScope);
                            if (pterm->dwfTerm & TF_ACTION_VLIST)
                            {
                                ASSERT(pterm->pfnTerm != NULL);
                                rc = pterm->pfnTerm(ptoken, FALSE);
                            }
                        }
                    }
                }
                else
                {
                    ComputeChkSumLen(gpcodeScope);
                }
            }
            gpnsCurrentScope = pnsScopeSave;
            gpnsCurrentOwner = pnsOwnerSave;
        }
        else
        {
            PrintTokenErr(ptoken, "unexpected term type", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParseASLTerm=%d\n", rc));
    return rc;
}       //ParseASLTerm

/***LP  ParseFieldList - Parse Field List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseFieldList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    NAMESEG NameSeg;
    DWORD dwcbLen;
    DWORD dwcBits = 0, dwcTotalBits = 0;
    PCODEOBJ pc;
    PNSOBJ pns;

    ENTER((1, "ParseFieldList(ptoken=%p,AccSize=%ld)\n",
           ptoken, gdwFieldAccSize));

    while ((rc == ASLERR_NONE) &&
           (((rc = MatchToken(ptoken, TOKTYPE_ID, 0,
                              MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
             TOKERR_NONE) ||
            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                              NULL)) == TOKERR_NONE)))
    {
        pns = NULL;
        if (ptoken->iTokenType == TOKTYPE_SYMBOL)
        {
            NameSeg = 0;
            rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
            dwcBits = (DWORD)ptoken->llTokenValue;
        }
        else if (ptoken->llTokenValue >= 0)
        {
            if (TermTable[ptoken->llTokenValue].lID == ID_OFFSET)
            {
                if (((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0,
                                      NULL)) == TOKERR_NONE) &&
                    ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE))
                {
                    NameSeg = 0;
                    if ((DWORD)ptoken->llTokenValue*8 >= dwcTotalBits)
                    {
                        dwcBits = (DWORD)ptoken->llTokenValue*8 - dwcTotalBits;
                        rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                        NULL);
                    }
                    else
                    {
                        PrintTokenErr(ptoken, "backward offset is not allowed",
                                      TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }
            }
            else if (TermTable[ptoken->llTokenValue].lID == ID_ACCESSAS)
            {
                PCODEOBJ pcode;

                UnGetToken(ptoken);
                if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
                {
                    ERROR(("ParseFieldList: failed to allocate code object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    ASSERT(gpcodeScope != NULL);
                    memset(pcode, 0, sizeof(CODEOBJ));
                    pcode->pcParent = gpcodeScope;
                    ListInsertTail(&pcode->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);

                    gpcodeScope = pcode;
                    rc = ParseASLTerm(ptoken, 0);
                    gpcodeScope = pcode->pcParent;

                    if (rc != ASLERR_NONE)
                    {
                        ListRemoveEntry(&pcode->list,
                                        (PPLIST)&gpcodeScope->pcFirstChild);
                        MEMFREE(pcode);
                    }
                    else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                              MTF_NOT_ERR, NULL)) ==
                             TOKERR_NONE)
                    {
                        continue;
                    }
                }
            }
            else
            {
                PrintTokenErr(ptoken, "unexpected ASL term in field list",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else
        {
            //
            // expecting a NameSeg and an integer
            //
            dwcbLen = sizeof(NAMESEG);
            if ((ptoken->llTokenValue >= 0) ||      //an ASL term?
                !ValidASLNameSeg(ptoken, ptoken->szToken, strlen(ptoken->szToken)) ||
                ((rc = EncodeName(ptoken->szToken, (PBYTE)&NameSeg, &dwcbLen)) !=
                 ASLERR_NONE) ||
                (dwcbLen != sizeof(NAMESEG)))
            {
                PrintTokenErr(ptoken, "not a valid NameSeg", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((rc = CreateNameSpaceObj(ptoken, ptoken->szToken,
                                              gpnsCurrentScope,
                                              gpnsCurrentOwner,
                                              &pns, NSF_EXIST_ERR)) ==
                     ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, 0,
                                     NULL)) == TOKERR_NONE)
                {
                    rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
                    dwcBits = (DWORD)ptoken->llTokenValue;
                }
            }
        }

        if  (rc == ASLERR_NONE)
        {
            if ((NameSeg == 0) && (dwcBits == 0))
            {
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                                NULL);
            }
            else if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
            {
                ERROR(("ParseFieldList: failed to allocate field code object"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                int icb;

                memset(pc, 0, sizeof(CODEOBJ));
                if ((rc = EncodePktLen(dwcBits, &pc->dwDataLen, &icb)) ==
                    ASLERR_NONE)
                {
                    dwcTotalBits += dwcBits;
                    if (gpcodeScope->pnsObj != NULL)
                    {
                        ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType ==
                               OBJTYPE_OPREGION);
                        if ((gpcodeScope->pnsObj->ObjData.uipDataValue !=
                             0xffffffff) &&
                            ((dwcTotalBits + 7)/8 >
                             gpcodeScope->pnsObj->ObjData.uipDataValue))
                        {
                            char szMsg[MAX_MSG_LEN + 1];

                            sprintf(szMsg,
                                    "field offset is exceeding operation region range (offset=0x%x)",
                                    (dwcTotalBits + 7)/8);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }

                    pc->pcParent = gpcodeScope;
                    ListInsertTail(&pc->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);
                    pc->dwCodeType = CODETYPE_FIELDOBJ;
                    if (pns != NULL)
                    {
                        pc->dwfCode |= CF_CREATED_NSOBJ;
                        pc->pnsObj = pns;
                        pns->Context = pc;
                    }
                    pc->dwCodeValue = NameSeg;
                    pc->dwCodeLen = (NameSeg == 0)? sizeof(BYTE):
                                                    sizeof(NAMESEG);
                    pc->dwCodeLen += icb;
                    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&NameSeg,
                                                        sizeof(NAMESEG));
                    pc->bCodeChkSum = (BYTE)
                        (pc->bCodeChkSum +
                         ComputeDataChkSum((PBYTE)&pc->dwDataLen, icb));

                    rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                    MTF_NOT_ERR, NULL);
                }
                else
                {
                    MEMFREE(pc);
                    PrintTokenErr(ptoken, "exceeding maximum encoding limit",
                                  TRUE);
                }
            }
        }
    }

    EXIT((1, "ParseFieldList=%d\n", rc));
    return rc;
}       //ParseFieldList

/***LP  ParsePackageList - Parse Package List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParsePackageList(PTOKEN ptoken)
{
    int rc;
    PCODEOBJ pc;
    int icElements = 0;
    PCODEOBJ pArgs;

    ENTER((1, "ParsePackageList(ptoken=%p)\n", ptoken));

    do
    {
        if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParsePackageList: failed to allocate package object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pc, 0, sizeof(CODEOBJ));
            pc->pcParent = gpcodeScope;
            ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);

            gpcodeScope = pc;
            if ((rc = ParseData(ptoken)) == TOKERR_NO_MATCH)
            {
                UnGetToken(ptoken);
                rc = ParseName(ptoken, TRUE);
            }
            gpcodeScope = pc->pcParent;

            if (rc != ASLERR_NONE)
            {
                ListRemoveEntry(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
                MEMFREE(pc);
            }
            else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE)
            {
                icElements++;
                if (ptoken->llTokenValue == SYM_RBRACE)
                {
                    UnGetToken(ptoken);
                    rc = TOKERR_NO_MATCH;
                }
                else if (ptoken->llTokenValue != SYM_COMMA)
                {
                    PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
    } while (rc == ASLERR_NONE);

    if (rc == TOKERR_NO_MATCH)
    {
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        if (pArgs[0].dwfCode & CF_MISSING_ARG)
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            SetIntObject(&pArgs[0], (DWORD)icElements, sizeof(BYTE));
        }
        else if (pArgs[0].dwCodeValue < (DWORD)icElements)
        {
            PrintTokenErr(ptoken, "Package has too many elements", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParsePackageList=%d\n", rc));
    return rc;
}       //ParsePackageList

/***LP  ParseBuffList - Parse Buffer List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseBuffList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseBuffList(ptoken=%p)\n", ptoken));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseBuffList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PCODEOBJ pArgs;
        DWORD dwReservedLen;
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0,
                             MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) == TOKERR_NONE)
        {
            pc->dwDataLen = strlen(ptoken->szToken) + 1;

            if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                ((rc = GetIntData(&pArgs[0], &dwReservedLen)) == ASLERR_NONE) &&
                (pc->dwDataLen > dwReservedLen))
            {
                PrintTokenErr(ptoken, "Buffer has too many initializers", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else
            {
                if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseBuffList: failed to allocate string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memset(pc->pbDataBuff, 0, pc->dwDataLen);
                    memcpy(pc->pbDataBuff, ptoken->szToken, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
        }
        else if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseBuffList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                if (ptoken->llTokenValue > MAX_BYTE)
                {
                    PrintTokenErr(ptoken, "expecting byte value", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else if (dwLen >= MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen >= dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseBuffList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    pbBuff[dwLen++] = (BYTE)ptoken->llTokenValue;
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                    (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                    ((rc = GetIntData(&pArgs[0], &dwReservedLen)) ==
                     ASLERR_NONE) &&
                    (pc->dwDataLen > dwReservedLen))
                {
                    PrintTokenErr(ptoken, "Buffer has too many initializers",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }
                else
                {
                    if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) ==
                        NULL)
                    {
                        ERROR(("ParseBuffList: failed to allocate data object"));
                        rc = ASLERR_OUT_OF_MEM;
                    }
                    else
                    {
                        memset(pc->pbDataBuff, 0, pc->dwDataLen);
                        memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                        pc->dwCodeLen = pc->dwDataLen;
                        pc->bCodeChkSum =
                            ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                    }
                }
            }
            MEMFREE(pbBuff);
        }

        if ((rc == ASLERR_NONE) && (pArgs[0].dwfCode & CF_MISSING_ARG))
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            rc = MakeIntData(pc->dwDataLen, &pArgs[0]);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseBuffList=%d\n", rc));
    return rc;
}       //ParseBuffList

/***LP  ParseDataList - Parse Data List
 *
 *  ENTRY
 *      ptoken - token stream
 *      icbDataSize - data size in bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseDataList(ptoken=%p,DataSize=%d)\n", ptoken, icbDataSize));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseDataList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF*icbDataSize;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseDataList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                switch (icbDataSize)
                {
                    case sizeof(BYTE):
                        if (ptoken->llTokenValue > MAX_BYTE)
                        {
                            PrintTokenErr(ptoken, "expecting byte value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(WORD):
                        if (ptoken->llTokenValue > MAX_WORD)
                        {
                            PrintTokenErr(ptoken, "expecting word value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(DWORD):
                        if (ptoken->llTokenValue > MAX_DWORD)
                        {
                            PrintTokenErr(ptoken, "expecting dword value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    default:
                        ERROR(("ParseDataList: unexpected data size - %d",
                               icbDataSize));
                        rc = ASLERR_INTERNAL_ERROR;
                }

                if (rc != ASLERR_NONE)
                    break;

                if (dwLen + icbDataSize > MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen + icbDataSize > dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF*icbDataSize;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseDataList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    switch (icbDataSize)
                    {
                        case sizeof(BYTE):
                            pbBuff[dwLen] = (BYTE)ptoken->llTokenValue;
                            break;

                        case sizeof(WORD):
                            *((PWORD)&pbBuff[dwLen]) = (WORD)
                                ptoken->llTokenValue;
                            break;

                        case sizeof(DWORD):
                            *((PDWORD)&pbBuff[dwLen]) = (DWORD)
                                ptoken->llTokenValue;
                            break;
                    }
                    dwLen += icbDataSize;

                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if ((pc->pbDataBuff = MEMALLOC(pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseDataList: failed to allocate data object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
            MEMFREE(pbBuff);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseDataList=%d\n", rc));
    return rc;
}       //ParseDataList

/***LP  ParseArgs - Parse ASL term arguments
 *
 *  ENTRY
 *      ptoken - token stream
 *      pterm -> asl term
 *      iNumArgs - number of arguments
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ParseArgs(ptoken=%p,pterm=%p,NumArgs=%d)\n",
           ptoken, pterm, iNumArgs));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0, NULL)) ==
        TOKERR_NONE)
    {
        PCODEOBJ pArgs = NULL;

        if ((iNumArgs != 0) &&
            ((pArgs = MEMALLOC(sizeof(CODEOBJ)*iNumArgs)) == NULL))
        {
            ERROR(("ParseArgs: failed to allocate argument objects"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            int i;
            char chArgType;
            char szNameBuff[MAX_NSPATH_LEN + 1];
            BOOL fOptional;
            PSZ pszArgType = "Unknown";

            gpcodeScope->dwfCode |= CF_PARSING_FIXEDLIST;
            if (pArgs != NULL)
            {
                gpcodeScope->pbDataBuff = (PBYTE)pArgs;
                memset(pArgs, 0, sizeof(CODEOBJ)*iNumArgs);
            }

            for (i = 0; (rc == ASLERR_NONE) && (i < iNumArgs); ++i)
            {
                chArgType = pterm->pszArgTypes[i];
                if (islower(chArgType))
                {
                    chArgType = (char)_toupper(chArgType);
                    fOptional = TRUE;
                }
                else
                    fOptional = FALSE;

                pArgs[i].pcParent = gpcodeScope;

                gpcodeScope = &pArgs[i];
                switch (chArgType)
                {
                    case 'N':
                    case 'R':
                        rc = ParseName(ptoken, (chArgType == 'N')? TRUE: FALSE);
                        pszArgType = "Name";
                        break;

                    case 'S':
                        if (((rc = ParseSuperName(ptoken)) ==
                             TOKERR_NO_MATCH) && fOptional)
                        {
                            pArgs[i].dwCodeType = CODETYPE_ASLTERM;
                            pArgs[i].dwCodeValue = OP_ZERO;
                            pArgs[i].dwCodeLen = 0;
                            pArgs[i].bCodeChkSum = OP_ZERO;
                            rc = LookupIDIndex(ID_ZERO,
                                               &pArgs[i].dwTermIndex);
                        }
                        pszArgType = "SuperName";
                        break;

                    case 'O':
                        rc = ParseData(ptoken);
                        pszArgType = "DataObject";
                        break;

                    case 'B':
                    case 'W':
                    case 'D':
                    case 'U':
                    case 'Q':
                        rc = ParseInteger(ptoken, chArgType);
                        if (chArgType == 'B')
                            pszArgType = "ByteInteger";
                        else if (chArgType == 'W')
                            pszArgType = "WordInteger";
                        else if (chArgType == 'D')
                            pszArgType = "DWordInteger";
                        else if (chArgType == 'Q')
                            pszArgType = "QWordInteger";
                        else
                            pszArgType = "Integer";
                        break;

                    case 'C':
                    case 'M':
                    case 'P':
                        rc = ParseOpcode(ptoken, chArgType);
                        pszArgType = "Opcode";
                        break;

                    case 'E':
                    case 'K':
                        rc = ParseKeyword(ptoken, pterm->pszArgActions[i]);
                        pszArgType = "Keyword";
                        if ((chArgType == 'E') && (rc == TOKERR_NO_MATCH))
                        {
                            if ((rc = ParseInteger(ptoken, 'B')) == ASLERR_NONE)
                            {
                                if ((pterm->pszArgActions[i] != 'Y') &&
                                    //
                                    // AccessAttribKeyword ( pszArgActions type 'Y' ) may be replaced
                                    // by any integer value.  
                                    // Size checking is performed in AccessAs function.
                                    //
                                    ((gpcodeScope->dwCodeValue <
                                      (pterm->dwTermData >> 24)) ||
                                     (gpcodeScope->dwCodeValue >
                                      ((pterm->dwTermData >> 16) & 0xff))))
                                {
                                    PrintTokenErr(ptoken,
                                                  "invalid integer range",
                                                  TRUE);
                                    rc = ASLERR_SYNTAX;
                                }
                            }
                        }
                        break;

                    case 'Z':
                        rc = ParseString(ptoken);
                        pszArgType = "String";
                        break;
                }
                gpcodeScope = pArgs[i].pcParent;

                if (rc == TOKERR_NO_MATCH)
                {
                    if (fOptional)
                    {
                        pArgs[i].dwfCode |= CF_MISSING_ARG;
                        rc = ASLERR_NONE;
                    }
                    else
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        sprintf(szMsg, "expecting argument type \"%s\"",
                                pszArgType);
                        PrintTokenErr(ptoken, szMsg, TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }

                if ((rc == ASLERR_NONE) && (pterm->pszArgActions != NULL) &&
                    ((chArgType == 'N') || (chArgType == 'S') ||
                     (chArgType == 'C') || (chArgType == 'M') ||
                     (chArgType == 'P')) &&
                    (pArgs[i].dwCodeType == CODETYPE_NAME) &&
                    ((rc = DecodeName(pArgs[i].pbDataBuff, szNameBuff,
                                      sizeof(szNameBuff))) == ASLERR_NONE))
                {
                    char chActType = pterm->pszArgActions[i];

                    if (islower(chActType))
                    {
                        rc = CreateObject(ptoken, szNameBuff,
                                          (char)_toupper(chActType), NULL);
                    }
                    else
                    {
                        rc = ValidateObject(ptoken, szNameBuff, chActType,
                                            chArgType);
                    }
                }

                if (rc == ASLERR_NONE)
                {   //
                    // expecting either a comma or a close paran.
                    //
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RPARAN)
                        {
                            UnGetToken(ptoken);
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (i == iNumArgs - 1)     //last argument
                        {
                            PrintTokenErr(ptoken, "expecting ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            gpcodeScope->dwfCode &= ~CF_PARSING_FIXEDLIST;

            if (rc == ASLERR_NONE)
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0, NULL);
        }

    }

    EXIT((1, "ParseArgs=%d\n", rc));
    return rc;
}       //ParseArgs

/***LP  ParseUserTerm - Parse user method name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fNonMethodOK - if TRUE, user term can be a non-method
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK)
{
    int rc;

    ENTER((1, "ParseUserTerm(ptoken=%p,fNonMethodOK=%d)\n",
           ptoken, fNonMethodOK));

    //
    // Max number of argument is 7 but we need to store the user term name too,
    // we will store it in Arg0, so we will make it 8.
    //
    if ((gpcodeScope->pbDataBuff = MEMALLOC(sizeof(CODEOBJ)*(MAX_ARGS + 1))) ==
        NULL)
    {
        ERROR(("ParseUserTerm: failed to allocate user term object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        int i;

        gpcodeScope->dwCodeType = CODETYPE_USERTERM;
        gpcodeScope->dwDataLen = MAX_ARGS + 1;
        memset(pArgs, 0, sizeof(CODEOBJ)*gpcodeScope->dwDataLen);

        pArgs[0].pcParent = gpcodeScope;
        gpcodeScope = &pArgs[0];
        UnGetToken(ptoken);
        if ((rc = ParseName(ptoken, TRUE)) == TOKERR_NONE)
        {
            PNSOBJ pns;
            char szName[MAX_NSPATH_LEN + 1];

            strcpy(szName, ptoken->szToken);
            GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0);

            gpcodeScope = pArgs[0].pcParent;
            if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN,
                                 fNonMethodOK? MTF_NOT_ERR: 0, NULL)) ==
                TOKERR_NONE)
            {
                for (i = 1;
                     (rc == TOKERR_NONE) && (i < (int)gpcodeScope->dwDataLen);
                     ++i)
                {
                    pArgs[i].pcParent = gpcodeScope;
                    gpcodeScope = &pArgs[i];
                    if ((rc = ParseOpcode(ptoken, 'C')) == TOKERR_NONE)
                    {
                        if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                             MTF_ANY_VALUE, NULL)) ==
                            TOKERR_NONE)
                        {
                            if (ptoken->llTokenValue == SYM_RPARAN)
                            {
                                UnGetToken(ptoken);
                                gpcodeScope = pArgs[i].pcParent;
                                //
                                // Readjust the number of arguments
                                //
                                gpcodeScope->dwDataLen = i + 1;
                                break;
                            }
                            else if (ptoken->llTokenValue != SYM_COMMA)
                            {
                                PrintTokenErr(ptoken, "expecting ',' or ')'",
                                              TRUE);
                                rc = ASLERR_SYNTAX;
                            }
                        }
                    }
                    else if (rc == TOKERR_NO_MATCH)
                    {
                        gpcodeScope = pArgs[i].pcParent;
                        //
                        // Readjust the number of arguments
                        //
                        gpcodeScope->dwDataLen = i;
                        rc = TOKERR_NONE;
                        break;
                    }

                    gpcodeScope = pArgs[i].pcParent;
                }

                if (rc == TOKERR_NONE)
                {
                    ComputeArgsChkSumLen(gpcodeScope);
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                         NULL)) == ASLERR_NONE)
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        if (pns == NULL)
                        {
                            rc = QueueNSChk(ptoken, szName, OBJTYPE_METHOD,
                                            gpcodeScope->dwDataLen - 1);
                        }
                        else if (pns->ObjData.dwDataType != OBJTYPE_METHOD)
                        {
                            sprintf(szMsg, "%s is not a method", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue <
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too many arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue >
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too few arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            else if (rc == TOKERR_NO_MATCH)
            {
                gpcodeScope->dwCodeType = pArgs[0].dwCodeType;
                gpcodeScope->dwDataLen = pArgs[0].dwDataLen;
                gpcodeScope->pbDataBuff = pArgs[0].pbDataBuff;
                gpcodeScope->dwCodeLen = pArgs[0].dwCodeLen;
                gpcodeScope->bCodeChkSum = pArgs[0].bCodeChkSum;
                MEMFREE(pArgs);
                if (pns == NULL)
                {
                    rc = QueueNSChk(ptoken, szName, OBJTYPE_UNKNOWN, 0);
                }
                else
                {
                    rc = TOKERR_NONE;
                }
            }
        }
    }

    EXIT((1, "ParseUserTerm=%d\n", rc));
    return rc;
}       //ParseUserTerm

/***LP  ParseName - Parse ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fEncode - TRUE if encode name else store it raw as string
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode)
{
    int rc;
    BYTE abBuff[MAX_NAMECODE_LEN];
    DWORD dwLen = sizeof(abBuff);

    ENTER((1, "ParseName(ptoken=%p,fEncode=%x)\n", ptoken, fEncode));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, ID_USER, MTF_NOT_ERR, NULL)) ==
        TOKERR_NONE)
    {
        if (!ValidASLName(ptoken, ptoken->szToken))
        {
            PrintTokenErr(ptoken, "expecting ASL name", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (fEncode)
        {
            if ((rc = EncodeName(ptoken->szToken, abBuff, &dwLen)) ==
                ASLERR_NONE)
            {
                if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
                {
                    ERROR(("ParseName: failed to allocate name string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(gpcodeScope->pbDataBuff, abBuff, (int)dwLen);
                    gpcodeScope->dwCodeType = CODETYPE_NAME;
                    gpcodeScope->dwDataLen = dwLen;
                    gpcodeScope->dwCodeLen = dwLen;
                    gpcodeScope->bCodeChkSum =
                        ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
                }
            }
            else
            {
                PrintTokenErr(ptoken, "name too long", TRUE);
            }
        }
        else
        {
            gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
            if ((gpcodeScope->pbDataBuff = MEMALLOC(gpcodeScope->dwDataLen)) !=
                NULL)
            {
                memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                       gpcodeScope->dwDataLen);
                gpcodeScope->dwCodeType = CODETYPE_STRING;
                gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                      gpcodeScope->dwDataLen);
            }
            else
            {
                ERROR(("ParseName: failed to allocate raw name string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }

    EXIT((1, "ParseName=%d (Name=%s)\n", rc, ptoken->szToken));
    return rc;
}       //ParseName

/***LP  ParseSuperName - Parse ASL super name
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseSuperName(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseSuperName(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            UnGetToken(ptoken);
            rc = ParseName(ptoken, TRUE);
        }
        else
        {
            if (TermTable[ptoken->llTokenValue].dwfTermClass &
                TC_SHORT_NAME)
            {
                gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
                gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
                gpcodeScope->dwCodeValue =
                    TermTable[ptoken->llTokenValue].dwOpcode;
            }
            else if (TermTable[ptoken->llTokenValue].dwfTermClass &
                     TC_REF_OBJECT)
            {
                UnGetToken(ptoken);
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                UnGetToken(ptoken);
                rc = TOKERR_NO_MATCH;
            }
        }
    }

    EXIT((1, "ParseSuperName=%d\n", rc));
    return rc;
}       //ParseSuperName

/***LP  MakeIntData - make integer data object
 *
 *  ENTRY
 *      dwData - integer data
 *      pc -> code object
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc)
{
    int rc = ASLERR_NONE;
    DWORD dwLen;
    BYTE bOp;

    ENTER((1, "MakeIntData(Data=%lx,pc=%p)\n", dwData, pc));

    pc->dwCodeType = CODETYPE_DATAOBJ;
    if ((dwData & 0xffffff00) == 0)
    {
        bOp = OP_BYTE;
        dwLen = 2;
    }
    else if ((dwData & 0xffff0000) == 0)
    {
        bOp = OP_WORD;
        dwLen = 3;
    }
    else
    {
        bOp = OP_DWORD;
        dwLen = 5;
    }

    if ((pc->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
    {
        ERROR(("MakeIntData: failed to allocate data object - %lx", dwData));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        pc->dwDataLen = dwLen;
        pc->dwCodeLen = dwLen;
        pc->pbDataBuff[0] = bOp;
        memcpy(&pc->pbDataBuff[1], &dwData, (int)(dwLen - 1));
        pc->bCodeChkSum = ComputeDataChkSum(pc->pbDataBuff, dwLen);
    }

    EXIT((1, "MakeIntData=%d\n", rc));
    return rc;
}       //MakeIntData

/***LP  GetIntData - get integer from a data object
 *
 *  ENTRY
 *      pc -> code object
 *      pdwData -> to hold integer data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData)
{
    int rc = ASLERR_NONE;

    ENTER((1, "GetIntData(pc=%p,pdwData=%p)\n", pc, pdwData));

    ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
    switch (pc->pbDataBuff[0])
    {
        case OP_BYTE:
            *pdwData = (DWORD)(*((PBYTE)&pc->pbDataBuff[1]));
            break;

        case OP_WORD:
            *pdwData = (DWORD)(*((PWORD)&pc->pbDataBuff[1]));
            break;

        case OP_DWORD:
            *pdwData = *((PDWORD)&pc->pbDataBuff[1]);
            break;

        default:
            ERROR(("GetIntData: data object is not integer type"));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    EXIT((1, "GetIntData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetIntData

/***LP  ParseData - Parse ASL data object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseData(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseData(ptoken=%p)\n", ptoken));

    if ((rc = GetToken(ptoken)) == TOKERR_NONE)
    {
        if (ptoken->iTokenType == TOKTYPE_NUMBER)
        {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->iTokenType == TOKTYPE_STRING)
        {
            DWORD dwLen;

            gpcodeScope->dwCodeType = CODETYPE_DATAOBJ;
            dwLen = strlen(ptoken->szToken) + 2;
            if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
            {
                ERROR(("ParseData: failed to allocate string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                gpcodeScope->dwDataLen = dwLen;
                gpcodeScope->dwCodeLen = dwLen;
                gpcodeScope->pbDataBuff[0] = OP_STRING;
                memcpy(&gpcodeScope->pbDataBuff[1], ptoken->szToken,
                       (int)(dwLen - 1));
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
            }
        }
        else if ((ptoken->iTokenType != TOKTYPE_ID) ||
                 (ptoken->llTokenValue < 0) ||
                 ((TermTable[ptoken->llTokenValue].dwfTermClass &
                   (TC_DATA_OBJECT | TC_CONST_NAME)) == 0))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else
        {
            UnGetToken(ptoken);
            rc = ParseASLTerm(ptoken, 0);
        }
    }

    EXIT((1, "ParseData=%d\n", rc));
    return rc;
}       //ParseData

/***LP  ParseInteger - Parse integer data
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - integer type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseInteger(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseInteger(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwCodeValue = 0;
        if ((c == 'B') && ((ptoken->llTokenValue & 0xffffffffffffff00) != 0) ||
            (c == 'W') && ((ptoken->llTokenValue & 0xffffffffffff0000) != 0) ||
            (c == 'D') && ((ptoken->llTokenValue & 0xffffffff00000000) != 0))
        {
            char szMsg[MAX_MSG_LEN + 1];

            sprintf(szMsg, "expecting %s value",
                    (c == 'B')? "byte":
                    (c == 'W')? "word": "dword");
            PrintTokenErr(ptoken, szMsg, TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (c == 'U')
        {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (c != 'Q')
        {
            gpcodeScope->dwCodeType = CODETYPE_INTEGER;
            gpcodeScope->dwDataLen = (c == 'B')? sizeof(BYTE):
                                     (c == 'W')? sizeof(WORD):
                                     (c == 'D')? sizeof(DWORD):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffffff00) == 0)? sizeof(BYTE):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffff0000) == 0)? sizeof(WORD):
                                     sizeof(DWORD);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->dwCodeValue = (DWORD)ptoken->llTokenValue;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum((PBYTE)&ptoken->llTokenValue,
                                  gpcodeScope->dwDataLen);
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC(gpcodeScope->dwDataLen = sizeof(QWORD))) != NULL)
        {
            gpcodeScope->dwCodeType = CODETYPE_QWORD;
            memcpy(gpcodeScope->pbDataBuff, &ptoken->llTokenValue,
                   gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
        else
        {
            ERROR(("ParseInteger: failed to allocate QWord object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((1, "ParseInteger=%d\n", rc));
    return rc;
}       //ParseInteger

/***LP  ParseOpcode - Parse ASL opcode: MachineCode, FunctionCode, SuperName
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - opcode type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseOpcode(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseOpcode(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            PNSOBJ pns;

            if ((GetNameSpaceObj(ptoken->szToken, gpnsCurrentScope, &pns, 0) ==
                 ASLERR_NONE) &&
                (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
                ((c == 'M') || (c == 'P')))
            {
                DWORD dwValue = 0;

                if (c == 'P')
                {
                    dwValue = pns->ObjData.uipDataValue;
                }
                else if (pns->ObjData.uipDataValue%8 == 0)
                {
                    dwValue = pns->ObjData.uipDataValue/8;
                }
                else
                {
                    PrintTokenErr(ptoken,
                                  "object can only be used in CreateField "
                                  "or CreateBitField statements",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }

                if (rc == ASLERR_NONE)
                {
                    rc = MakeIntData(dwValue, gpcodeScope);
                }
            }
            else
            {
                rc = ParseUserTerm(ptoken, TRUE);
            }
        }
        else
        {
            UnGetToken(ptoken);
            if (TermTable[ptoken->llTokenValue].dwfTermClass & TC_OPCODE)
            {
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                rc = TOKERR_NO_MATCH;
            }
        }
    }
    else
        rc = ParseData(ptoken);

    EXIT((1, "ParseOpcode=%d\n", rc));
    return rc;
}       //ParseOpcode

/***LP  ParseKeyword - Parse ASL keyword
 *
 *  ENTRY
 *      ptoken - token stream
 *      chExpectType - expected keyword type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 *
 *  NOTE
 *      DATATYPE_KEYWORD is a transient type.  It will be lumped together with
 *      other keyword type arguments and be converted into one DATATYPE_INTEGER.
 */

int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType)
{
    int rc;

    ENTER((1, "ParseKeyword(ptoken=%p,ExpectedType=%c)\n",
           ptoken, chExpectType));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if ((ptoken->llTokenValue == ID_USER) ||
            !(TermTable[ptoken->llTokenValue].dwfTermClass & TC_KEYWORD))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else if (TermTable[ptoken->llTokenValue].pszArgActions[0] !=
                 chExpectType)
        {
            PrintTokenErr(ptoken, "incorrect keyword type", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_KEYWORD;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = TOKID(ptoken->llTokenValue);
        }
    }

    EXIT((1, "ParseKeyword=%d\n", rc));
    return rc;
}       //ParseKeyword

/***LP  ParseString - Parse string object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseString(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseString(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
        if (gpcodeScope->dwDataLen > MAX_STRING_LEN + 1)
        {
            ERROR(("ParseString: string too big - %s", ptoken->szToken));
            rc = ASLERR_SYNTAX;
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC((size_t)gpcodeScope->dwDataLen)) == NULL)
        {
            ERROR(("ParseString: failed to allocate string object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_STRING;
            memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                   (int)gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
    }

    EXIT((1, "ParseString=%d\n", rc));
    return rc;
}       //ParseString

/***LP  ValidateObject - Validate the existence and type of the object
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *  chActType - action type
 *      chArgType - argument type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType)
{
    int rc = ASLERR_NONE;
    ULONG dwDataType = OBJTYPE_UNKNOWN;

    ENTER((2, "ValidateObject(ptoken=%p,Name=%s,ActType=%c,ArgType=%c)\n",
           ptoken, pszName, chActType, chArgType));

    switch (chActType)
    {
        case NSTYPE_UNKNOWN:
        case NSTYPE_SCOPE:
            break;

        case NSTYPE_FIELDUNIT:
            dwDataType = OBJTYPE_FIELDUNIT;
            break;

        case NSTYPE_DEVICE:
            dwDataType = OBJTYPE_DEVICE;
            break;

        case NSTYPE_EVENT:
            dwDataType = OBJTYPE_EVENT;
            break;

        case NSTYPE_METHOD:
            dwDataType = OBJTYPE_METHOD;
            break;

        case NSTYPE_MUTEX:
            dwDataType = OBJTYPE_MUTEX;
            break;

        case NSTYPE_OPREGION:
            dwDataType = OBJTYPE_OPREGION;
            break;

        case NSTYPE_POWERRES:
            dwDataType = OBJTYPE_POWERRES;
            break;

        case NSTYPE_PROCESSOR:
            dwDataType = OBJTYPE_PROCESSOR;
            break;

        case NSTYPE_THERMALZONE:
            dwDataType = OBJTYPE_THERMALZONE;
            break;

        case NSTYPE_OBJALIAS:
            dwDataType = OBJTYPE_OBJALIAS;
            break;

        case NSTYPE_BUFFFIELD:
            dwDataType = OBJTYPE_BUFFFIELD;
            break;

        default:
            ERROR(("ValidateObject: invalid object type %c", chActType));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    if (rc == ASLERR_NONE)
    {
        PNSOBJ pns;
        char szMsg[MAX_MSG_LEN + 1];

        if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
             ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == gpnsCurrentOwner)))
        {
        if ((pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
            (chArgType != 'M') && (chArgType != 'P'))
        {
                PrintTokenErr(ptoken,
                              "object can only be used in the index argument "
                              "of CreateXField or Index statements",
                              TRUE);
                rc = ASLERR_SYNTAX;
        }
            else if ((dwDataType != OBJTYPE_UNKNOWN) &&
                (pns->ObjData.dwDataType != dwDataType))
            {
                sprintf(szMsg,
                        "%s has an incorrect type (ObjType=%s, ExpectedType=%s)",
                        pszName, GetObjectTypeName(pns->ObjData.dwDataType),
                        GetObjectTypeName(dwDataType));
                PrintTokenErr(ptoken, szMsg, TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((chActType == NSTYPE_SCOPE) ||
                 (chActType == NSTYPE_OPREGION))
            {
                ASSERT(gpcodeScope->pnsObj == NULL);
                gpcodeScope->pnsObj = pns;
            }
        }
        else if ((rc == ASLERR_NSOBJ_NOT_FOUND) && (gpnsCurrentOwner != NULL))
        {
            //
            // We are in a method referring to something not yet defined.
            // Let's queue it and check it after we are done.
            //
            rc = QueueNSChk(ptoken, pszName, dwDataType, 0);
        }
        else
        {
            sprintf(szMsg, "%s does not exist or not in accessible scope",
                    pszName);
            PrintTokenErr(ptoken, szMsg, FALSE);
            rc = ASLERR_NONE;
        }
    }

    EXIT((2, "ValidateObject=%d\n", rc));
    return rc;
}       //ValidateObject

/***LP  ValidateNSChkList - Validate objects in NSCHK list
 *
 *  ENTRY
 *      pnschkHead -> NSCHK list
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateNSChkList(PNSCHK pnschkHead)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;
    ENTER((2, "ValidateNSChkList(Head=%p)\n", pnschkHead));

    while ((rc == ASLERR_NONE) && (pnschkHead != NULL))
    {
        if ((GetNameSpaceObj(pnschkHead->szObjName, pnschkHead->pnsScope, &pns,
                             0) == ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == pnschkHead->pnsMethod)))
        {
            if (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD)
            {
                ErrPrintf("%s(%d): error: cannot make forward reference to PNP resource object %s\n",
                          pnschkHead->pszFile, pnschkHead->wLineNum,
                          pnschkHead->szObjName);
                rc = ASLERR_SYNTAX;
            }
            else if ((pnschkHead->dwExpectedType != OBJTYPE_UNKNOWN) &&
                     (pns->ObjData.dwDataType != pnschkHead->dwExpectedType))
            {
                ErrPrintf("%s(%d): warning: %s has incorrect type (ObjType=%s, ExpectedType=%s)\n",
                          pnschkHead->pszFile,
                          pnschkHead->wLineNum,
                          pnschkHead->szObjName,
                          GetObjectTypeName(pns->ObjData.dwDataType),
                          GetObjectTypeName(pnschkHead->dwExpectedType));
            }
            else if (pnschkHead->dwExpectedType == OBJTYPE_METHOD)

            {
                if (pns->ObjData.uipDataValue < pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too many arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
                else if (pns->ObjData.uipDataValue > pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too few arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
        else
        {
            ErrPrintf("%s(%d): warning: %s does not exist or not in accessible scope\n",
                      pnschkHead->pszFile,
                      pnschkHead->wLineNum,
                      pnschkHead->szObjName);

        }

        pnschkHead = pnschkHead->pnschkNext;
    }

    EXIT((2, "ValidateNSChkList=%d\n", rc));
    return rc;
}       //ValidateNSChkList

/***LP  QueueNSChk - Queue a NSChk request
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszObjName -> object name
 *      dwExpectedType - expected object type
 *      dwChkData - object specific check data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData)
{
    int rc = ASLERR_NONE;
    PNSCHK pnschk;

    ENTER((2, "QueueNSChk(ptoken=%p,Obj=%s,ExpectedType=%s,ChkData=%x)\n",
           ptoken, pszObjName, GetObjectTypeName(dwExpectedType), dwChkData));

    if ((pnschk = MEMALLOC(sizeof(NSCHK))) == NULL)
    {
        ERROR(("QueueNSChk: failed to allocate NSCHK object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        memset(pnschk, 0, sizeof(NSCHK));
        strcpy(pnschk->szObjName, pszObjName);
        pnschk->pszFile = gpszASLFile;
        pnschk->pnsScope = gpnsCurrentScope;
        pnschk->pnsMethod = gpnsCurrentOwner;
        pnschk->dwExpectedType = dwExpectedType;
        pnschk->dwChkData = dwChkData;
        pnschk->wLineNum = ptoken->pline->wLineNum;
        if (gpnschkTail != NULL)
        {
            gpnschkTail->pnschkNext = pnschk;
            gpnschkTail = pnschk;
        }
        else
        {
            gpnschkHead = gpnschkTail = pnschk;
        }
    }

    EXIT((2, "QueueNSChk=%d\n"));
    return rc;
}       //QueueNSChk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\scanasl.c ===
/*** scanasl.c - ASL scanner
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This module provides the token scanning functions for the ASL language.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/*** Local function prototypes
 */

int LOCAL ScanSym(int c, PTOKEN ptoken);
int LOCAL ScanSpace(int c, PTOKEN ptoken);
int LOCAL ScanID(int c, PTOKEN ptoken);
int LOCAL ScanNum(int c, PTOKEN ptoken);
int LOCAL ScanString(int c, PTOKEN ptoken);
int LOCAL ScanChar(int c, PTOKEN ptoken);
int LOCAL ProcessInLineComment(PTOKEN ptoken);
int LOCAL ProcessComment(PTOKEN ptoken);
int LOCAL LookupSym(PTOKEN ptoken, int iTable);
LONG LOCAL LookupID(PTOKEN ptoken);
int LOCAL GetEscapedChar(PLINE pline);
BOOL EXPORT StrToQWord(PSZ psz, DWORD dwBase, QWORD *pqw);

/*** Local data
 */

PFNTOKEN apfnToken[] =
{
    ScanSym,
    ScanSpace,
    ScanID,
    ScanNum,
    ScanString,
    ScanChar,
    (PFNTOKEN)NULL
};

#ifdef TUNE
  WORD awcTokenType[] =
  {
        0,              //TOKTYPE_SYMBOL
        0,              //TOKTYPE_SPACE
        0,              //TOKTYPE_ID
        0,              //TOKTYPE_NUM
        0,              //TOKTYPE_STRING
        0               //TOKTYPE_CHAR
  };
#endif

//
// The string positions of the symbol characters in SymCharTable
// is used as an index into the SymTokTable.  Therefore, if anything
// is changed in either SymCharTable or SymTokTable, the other
// table has to be changed correspondingly.
//
typedef struct symtok_s
{
    char chSym;
    int  iSymType;
    int  iLink;
} SYMTOK;
//
// Note that the symbol position in the following array must be the same
// position as in the SymCharTable array.
//
SYMTOK SymTokTable[] =
{
    '{',  SYM_LBRACE,           0,              //0
    '}',  SYM_RBRACE,           0,              //1
    '(',  SYM_LPARAN,           0,              //2
    ')',  SYM_RPARAN,           0,              //3
    ',',  SYM_COMMA,            0,              //4
    '/',  SYM_SLASH,            7,              //5
    '*',  SYM_ASTERISK,         9,              //6
    '/',  SYM_INLINECOMMENT,    8,              //7
    '*',  SYM_OPENCOMMENT,      0,              //8
    '/',  SYM_CLOSECOMMENT,     0,              //9
};

#define SYMTOK_TABLE_SIZE       (sizeof(SymTokTable)/sizeof(SYMTOK))

/***EP  OpenScan - scanner initialization
 *
 *  ENTRY
 *      pfileSrc -> source file
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated token structure;
 *  EXIT-FAILURE
 *      returns NULL
 */

PTOKEN EXPORT OpenScan(FILE *pfileSrc)
{
    PTOKEN ptoken;

    ENTER((4, "OpenScan(pfileSrc=%p)\n", pfileSrc));

  #ifdef TUNE
    ptoken = OpenToken(pfileSrc, apfnToken, awcTokenType);
  #else
    ptoken = OpenToken(pfileSrc, apfnToken);
  #endif

    EXIT((4, "OpenScan=%p\n", ptoken));
    return ptoken;
}       //OpenScan

/***EP  CloseScan - scanner cleanup
 *
 *  ENTRY
 *      ptoken->token structure
 *  EXIT
 *      None
 */

VOID EXPORT CloseScan(PTOKEN ptoken)
{
    ENTER((4, "CloseScan(ptoken=%p)\n", ptoken));

    CloseToken(ptoken);

    EXIT((4, "CloseScan!\n"));
}       //CloseScan

/***LP  ScanSym - scan symbols token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKERR_NO_MATCH - not a symbol token
 */

int LOCAL ScanSym(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;
    char *pch;

    ENTER((4, "ScanSym(c=%c,ptoken=%p)\n", c, ptoken));

    if ((pch = strchr(SymCharTable, c)) != NULL)
    {
        int i, j;

        i = (int)(pch - SymCharTable);
        if (i != (j = LookupSym(ptoken, i)))
        {
            i = j;
            ptoken->szToken[ptoken->wTokenLen++] = SymTokTable[i].chSym;
        }

        ptoken->iTokenType = TOKTYPE_SYMBOL;
        ptoken->llTokenValue = SymTokTable[i].iSymType;
        ptoken->szToken[ptoken->wTokenLen] = '\0';

        if (ptoken->llTokenValue == SYM_INLINECOMMENT)
            rc = ProcessInLineComment(ptoken);
        else if (ptoken->llTokenValue == SYM_OPENCOMMENT)
            rc = ProcessComment(ptoken);
        else
            rc = TOKERR_NONE;
    }

    EXIT((4, "ScanSym=%d (SymType=%I64d,Symbol=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanSym

/***LP  ScanSpace - scans and skips all white spaces
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not a space token
 */

int LOCAL ScanSpace(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanSpace(c=%c,ptoken=%p)\n", c, ptoken));

    if (isspace(c))
    {
        rc = TOKERR_NONE;
        while (((c = LineGetC(ptoken->pline)) != EOF) && isspace(c))
            ;

        LineUnGetC(c, ptoken->pline);

        if (ptoken->wfToken & TOKF_NOIGNORESPACE)
        {
            strcpy(ptoken->szToken, " ");
            ptoken->wTokenLen = 1;
            ptoken->iTokenType = TOKTYPE_SPACE;
        }
        else
            ptoken->iTokenType = TOKTYPE_NULL;
    }

    EXIT((4, "ScanSpace=%d\n", rc));
    return rc;
}       //ScanSpace

/***LP  ScanID - scan ID token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not an ID token
 *              TOKERR_TOKEN_TOO_LONG - ID too long
 */

int LOCAL ScanID(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanID(c=%c,ptoken=%p)\n", c, ptoken));

    if (isalpha(c) || (c == '_') ||
        (c == CH_ROOT_PREFIX) || (c == CH_PARENT_PREFIX))
    {
        BOOL fParentPrefix = (c == CH_PARENT_PREFIX);

        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_ID;
        while (((c = LineGetC(ptoken->pline)) != EOF) &&
               (fParentPrefix && (c == CH_PARENT_PREFIX) ||
                isalnum(c) || (c == '_') || (c == CH_NAMESEG_SEP)))
        {
            fParentPrefix = (c == CH_PARENT_PREFIX);
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen < MAX_TOKEN_LEN)
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            else
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        LineUnGetC(c, ptoken->pline);
        if (rc == TOKERR_NONE)
        {
            ptoken->llTokenValue = LookupID(ptoken);
        }
    }

    EXIT((4, "ScanID=%d (IDType=%I64d,ID=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanID

/***LP  ScanNum - scan number token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not a number token
 *              TOKERR_TOKEN_TOO_LONG - number too long
 */

int LOCAL ScanNum(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanNum(c=%c,ptoken=%p)\n", c, ptoken));

    if (isdigit(c))
    {
        BOOL fHex = FALSE;

        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_NUMBER;
        if ((c == '0') && ((c = LineGetC(ptoken->pline)) != EOF))
        {
            if (c != 'x')
                LineUnGetC(c, ptoken->pline);
            else
            {
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
                fHex = TRUE;
            }
        }

        while (((c = LineGetC(ptoken->pline)) != EOF) &&
               ((!fHex && isdigit(c)) || fHex && isxdigit(c)))
        {
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen < MAX_TOKEN_LEN)
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            else
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        LineUnGetC(c, ptoken->pline);

        if (rc == TOKERR_NONE)
        {
            if (!StrToQWord(ptoken->szToken, 0, (QWORD *)&ptoken->llTokenValue))
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }
    }

    EXIT((4, "ScanNum=%d (Num=%I64d,Token=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanNum

/***LP  ScanString - scan string token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH       - not a string token
 *              TOKERR_TOKEN_TOO_LONG  - string too long
 *              TOKERR_UNCLOSED_STRING - EOF before string close
 */

int LOCAL ScanString(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanString(c=%c,ptoken=%p)\n", c, ptoken));

    if (c == '"')
    {
        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_STRING;
        ptoken->wTokenLen--;
        while (((c = LineGetC(ptoken->pline)) != EOF) && (c != '"'))
        {
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen >= MAX_TOKEN_LEN)
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
            else
            {
                if (c == '\\')
                    c = GetEscapedChar(ptoken->pline);
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        if (c == EOF)
        {
            ptoken->wErrLine = ptoken->pline->wLineNum;
            if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                ptoken->wErrPos--;
            rc = TOKERR_UNCLOSED_STRING;
        }
    }

    EXIT((4, "ScanString=%d (string=%s)\n", rc, ptoken->szToken));
    return rc;
}       //ScanString

/***LP  ScanChar - scan character token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKERR_NO_MATCH       - not a character token
 *              TOKERR_TOKEN_TOO_LONG - token too long
 *              TOKERR_UNCLOSED_CHAR  - cannot find character close
 */

int LOCAL ScanChar(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanChar(c=%c,ptoken=%p)\n", c, ptoken));

    if (c == '\'')
    {
        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_CHAR;
        ptoken->wTokenLen--;
        if (((c = LineGetC(ptoken->pline)) == EOF) ||
            (c == '\\') && ((c = GetEscapedChar(ptoken->pline)) == EOF))
        {
            rc = TOKERR_UNCLOSED_CHAR;
        }
        else
        {
            ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            ptoken->szToken[ptoken->wTokenLen] = '\0';
            ptoken->llTokenValue = c;
            if ((c = LineGetC(ptoken->pline)) == EOF)
                rc = TOKERR_UNCLOSED_CHAR;
            else if (c != '\'')
                rc = TOKERR_TOKEN_TOO_LONG;
        }

        if (rc != TOKERR_NONE)
        {
            ptoken->wErrLine = ptoken->pline->wLineNum;
            if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                ptoken->wErrPos--;

            if (rc == TOKERR_TOKEN_TOO_LONG)
            {
                while (((c = LineGetC(ptoken->pline)) != EOF) && (c != '\''))
                    ;

                if (c == EOF)
                    rc = TOKERR_UNCLOSED_CHAR;
            }
        }
    }

    EXIT((4, "ScanChar=%d (Value=%I64d,Char=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanChar

/***LP  ProcessInLineComment - handle inline comment
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      always returns TOKERR_NONE
 */

int LOCAL ProcessInLineComment(PTOKEN ptoken)
{
    ENTER((4, "ProcessInLineComment(ptoken=%p,Token=%s,Comment=%s)\n",
           ptoken, ptoken->szToken,
           &ptoken->pline->szLineBuff[ptoken->pline->wLinePos]));

    LineFlush(ptoken->pline);
    ptoken->iTokenType = TOKTYPE_NULL;

    EXIT((4, "ProcessInLineComment=%d\n", TOKERR_NONE));
    return TOKERR_NONE;
}       //ProcessInLineComment

/***LP  ProcessComment - handle comment
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      always returns TOKERR_NONE
 */

int LOCAL ProcessComment(PTOKEN ptoken)
{
    int rc = TOKERR_UNCLOSED_COMMENT;
    int c;
    char *pch;

    ENTER((4, "ProcessComment(ptoken=%p,Token=%s,Comment=%s)\n",
           ptoken, ptoken->szToken,
           &ptoken->pline->szLineBuff[ptoken->pline->wLinePos]));

    while ((c = LineGetC(ptoken->pline)) != EOF)
    {
        if ((pch = strchr(SymCharTable, c)) != NULL)
        {
            int i;

            i = LookupSym(ptoken, (int)(pch - SymCharTable));
            if (SymTokTable[i].iSymType == SYM_CLOSECOMMENT)
            {
                ptoken->iTokenType = TOKTYPE_NULL;
                rc = TOKERR_NONE;
                break;
            }
        }
    }

    if (rc != TOKERR_NONE)
    {
        ptoken->wErrLine = ptoken->pline->wLineNum;
        if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
            ptoken->wErrPos--;
    }

    EXIT((4, "ProcessComment=%d\n", rc));
    return rc;
}       //ProcessComment

/***LP  LookupSym - match for 2-char. symbols
 *
 *  ENTRY
 *      ptoken -> token structure
 *      iTable = SymCharTable index
 *
 *  EXIT-SUCCESS
 *      returns a different index than iTable;
 *  EXIT-FAILURE
 *      returns iTable;
 */

int LOCAL LookupSym(PTOKEN ptoken, int iTable)
{
    int i = iTable;
    int c;

    ENTER((4, "LookupSym(ptoken=%p,iTable=%d)\n", ptoken, iTable));

    if ((SymTokTable[iTable].iLink != 0) &&
        ((c = LineGetC(ptoken->pline)) != EOF))
    {
        i = SymTokTable[iTable].iLink;
        while ((c != SymTokTable[i].chSym) && (SymTokTable[i].iLink != 0))
            i = SymTokTable[i].iLink;

        if (c != SymTokTable[i].chSym)
        {
            LineUnGetC(c, ptoken->pline);
            i = iTable;
        }
    }

    EXIT((4, "LookupSym=%d\n", i));
    return i;
}       //LookupSym

/***LP  LookupID - lookup the token in our reserved ID list
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns index of TermTable
 *  EXIT-FAILURE
 *      returns ID_USER
 */

LONG LOCAL LookupID(PTOKEN ptoken)
{
    LONG lID = ID_USER;
    LONG i;

    ENTER((4, "LookupID(ptoken=%p)\n", ptoken));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if (_stricmp(TermTable[i].pszID, ptoken->szToken) == 0)
        {
            lID = i;
            break;
        }
    }

    EXIT((4, "LookupID=%ld\n", lID));
    return lID;
}       //LookupID

/***LP  GetEscapedChar - read and translate escape character
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the escape character
 *  EXIT-FAILURE
 *      returns EOF - eof encountered
 */

int LOCAL GetEscapedChar(PLINE pline)
{
    int c;
    #define ESCAPE_BUFF_SIZE    5
    char achEscapedBuff[ESCAPE_BUFF_SIZE];
    int i;

    ENTER((4, "GetEscapedChar(pline=%p)\n", pline));

    if ((c = LineGetC(pline)) != EOF)
    {
        switch(c)
        {
            case '0':
                achEscapedBuff[0] = (char)c;
                for (i = 1; i < 4; i++) //maximum 3 digits
                {
                    if (((c = LineGetC(pline)) != EOF) &&
                        (c >= '0') && (c <= '7'))
                    {
                        achEscapedBuff[i] = (char)c;
                    }
                    else
                    {
                        LineUnGetC(c, pline);
                        break;
                    }
                }
                achEscapedBuff[i] = '\0';
                c = (int)strtoul(achEscapedBuff, NULL, 8);
                break;

            case 'a':
                c = '\a';       //alert (bell)
                break;

            case 'b':
                c = '\b';       //backspace
                break;

            case 'f':
                c = '\f';       //form feed
                break;

            case 'n':
                c = '\n';       //newline
                break;

            case 'r':
                c = '\r';       //carriage return
                break;

            case 't':
                c = '\t';       //horizontal tab
                break;

            case 'v':
                c = '\v';       //vertical tab
                break;

            case 'x':
                for (i = 0; i < 2; i++) //maximum 2 digits
                {
                    if (((c = LineGetC(pline)) != EOF) && isxdigit(c))
                        achEscapedBuff[i] = (char)c;
                    else
                    {
                        LineUnGetC(c, pline);
                        break;
                    }
                }
                achEscapedBuff[i] = '\0';
                c = (int)strtoul(achEscapedBuff, NULL, 16);
        }
    }

    EXIT((4, "GetEscapedChar=%x\n", c));
    return c;
}       //GetEscapedChar

/***EP  PrintScanErr - print scan error
 *
 *  ENTRY
 *      ptoken -> token structure
 *      rcErr - error code
 *
 *  EXIT
 *      None
 */

VOID EXPORT PrintScanErr(PTOKEN ptoken, int rcErr)
{
    WORD i;

    ENTER((4, "PrintScanErr(ptoken=%p,Err=%d)\n", ptoken, rcErr));

    ASSERT(ptoken->wTokenLine == ptoken->wErrLine);

    ErrPrintf("%5u: %s\n       ",
              ptoken->wTokenLine, ptoken->pline->szLineBuff);

    for (i = 0; i < ptoken->wErrPos; ++i)
    {
        if (ptoken->pline->szLineBuff[i] == '\t')
        {
            ErrPrintf("\t");
        }
        else
        {
            ErrPrintf(" ");
        }
    }

    ErrPrintf("^***\n");

    switch (rcErr)
    {
        case TOKERR_TOKEN_TOO_LONG:
            ErrPrintf("ScanErr: Token too long\n");
            break;

        case TOKERR_UNCLOSED_STRING:
            ErrPrintf("ScanErr: Unclosed string\n");
            break;

        case TOKERR_UNCLOSED_CHAR:
            ErrPrintf("ScanErr: Unclosed character quote\n");
            break;

        default:
            ErrPrintf("ScanErr: Syntax error\n");
            break;
    }

    EXIT((4, "PrintScanErr!\n"));
}       //PrintScanErr

/***EP  StrToQWord - convert the number in a string to a QWord
 *
 *  ENTRY
 *      psz -> string
 *      dwBase - the base of the number (if 0, auto-detect base)
 *      pqw -> to hold the resulting QWord
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL EXPORT StrToQWord(PSZ psz, DWORD dwBase, QWORD *pqw)
{
    BOOL rc = TRUE;
    ULONG m;

    ENTER((4, "StrToQWord(Str=%s,Base=%x,pqw=%p)\n", psz, dwBase, pqw));

    *pqw = 0;
    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
        {
            rc = FALSE;
	    break;
        }

        if (m < dwBase)
        {
            *pqw = (*pqw * dwBase) + m;
            psz++;
        }
        else
        {
            rc = FALSE;
            break;
        }
    }

    EXIT((4, "StrToQWord=%x (QWord=0x%I64x)\n", rc, *pqw));
    return rc;
}       //StrToQWord
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\tables.c ===
/*** tables.c - Dump various ACPI tables
 *
 *  This module provides the functions to dump various ACPI tables.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/08/99
 *
 *  MODIFICATION HISTORY
 */

#ifdef __UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
//#define _X86_
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#define ULONG_PTR ULONG
#define EXCL_BASEDEF
#include "pch.h"
#include "fmtdata.h"

#define BYTEOF(d,i)	(((BYTE *)&(d))[i])

/***LP  IsWinNT - check if OS is NT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns TRUE - OS is NT
 *  EXIT-FAILURE
 *      returns FALSE - OS is not NT
 */

BOOL LOCAL IsWinNT(VOID)
{
    BOOL rc = FALSE;
    OSVERSIONINFO osinfo;

    ENTER((2, "IsWinNT()\n"));

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osinfo) && (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {
        rc = TRUE;
    }

    EXIT((2, "IsWinNT=%x\n", rc));
    return rc;
}       //IsWinNT

#ifndef WINNT
/***LP  OpenVxD - Open ACPITAB.VXD
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns VxD handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HANDLE LOCAL OpenVxD(VOID)
{
    HANDLE hVxD;
    DWORD dwVersion;

    ENTER((2, "OpenVxD()\n"));

    if ((hVxD = CreateFile(ACPITAB_VXD_NAME, 0, 0, NULL, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL)) ==
        INVALID_HANDLE_VALUE)
    {
	ERROR(("OpenVxD: failed to open VxD %s (rc=%x)",
	       ACPITAB_VXD_NAME, GetLastError()));
        hVxD = NULL;
    }
    else if (!DeviceIoControl(hVxD, ACPITAB_DIOC_GETVERSION, NULL, 0,
                              &dwVersion, sizeof(dwVersion), NULL, NULL))
    {
        ERROR(("OpenVxD: failed to get VxD version. (rc=%x)", GetLastError()));
        CloseVxD(hVxD);
        hVxD = NULL;
    }
    else if (dwVersion != ((ACPITAB_MAJOR_VER << 8) | ACPITAB_MINOR_VER))
    {
        ERROR(("OpenVxD: version error (Ver=%x)", dwVersion));
        CloseVxD(hVxD);
        hVxD = NULL;
    }

    EXIT((2, "OpenVxD=%x\n", hVxD));
    return hVxD;
}       //OpenVxD

/***LP  CloseVxD - Close the VxD
 *
 *  ENTRY
 *      hVxD - VxD handle
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseVxD(HANDLE hVxD)
{
    ENTER((2, "CloseVxD(hVxD=%x)\n", hVxD));

    CloseHandle(hVxD);

    EXIT((2, "CloseVxD!\n"));
}       //CloseVxD

/***LP  VxDGetTableBySig - Get table by its signature
 *
 *  ENTRY
 *      dwTabSig - table signature
 *      pdwTableAddr -> to hold physical address of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL VxDGetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr)
{
    PBYTE pb = NULL;
    TABINFO TabInfo;

    ENTER((2, "VxDGetTableBySig(TabSig=%x,pdwAddr=%p)\n",
           dwTabSig, pdwTableAddr));

    TabInfo.dwTabSig = dwTabSig;
    if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABINFO, NULL, 0, &TabInfo,
                        sizeof(TabInfo), NULL, NULL))
    {
        if (dwTabSig == SIG_RSDP)
        {
            //
            // We are getting RSD PTR
            //
            if ((pb = MEMALLOC(sizeof(RSDP))) != NULL)
            {
                memcpy(pb, &TabInfo.rsdp, sizeof(RSDP));
                if (pdwTableAddr != NULL)
                {
                    *pdwTableAddr = TabInfo.dwPhyAddr;
                }
            }
            else
            {
                ERROR(("VxDGetTableBySig: failed to allocate RSDP buffer"));
            }
        }
        else if (dwTabSig == FACS_SIGNATURE)
        {
            if ((pb = MEMALLOC(sizeof(FACS))) != NULL)
            {
                memcpy(pb, &TabInfo.facs, sizeof(FACS));
                if (pdwTableAddr != NULL)
                {
                    *pdwTableAddr = TabInfo.dwPhyAddr;
                }
            }
            else
            {
                ERROR(("VxDGetTableBySig: failed to allocate FACS buffer"));
            }
        }
        else if ((pb = MEMALLOC(TabInfo.dh.Length)) != NULL)
        {
            if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)TabInfo.dwPhyAddr, 0, pb,
                                TabInfo.dh.Length, NULL, NULL) == 0)
            {
                ERROR(("VxDGetTableBySig: failed to get table %s. (rc=%x)",
                       GetTableSigStr(dwTabSig), GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
	    else
	    {
		if (pdwTableAddr != NULL)
		{
                    *pdwTableAddr = TabInfo.dwPhyAddr;
		}

		ValidateTable(pb, TabInfo.dh.Length);
	    }
        }
        else
        {
            ERROR(("VxDGetTableBySig: failed to allocate table buffer (len=%d)",
                   TabInfo.dh.Length));
        }
    }
    else
    {
        ERROR(("VxDGetTableBySig: failed to get table info %s. (rc=%x)",
               GetTableSigStr(dwTabSig), GetLastError()));
    }

    EXIT((2, "VxDGetTableBySig=%x\n", pb));
    return pb;
}       //VxDGetTableBySig

/***LP  VxDGetTableByAddr - Get table by its physical address
 *
 *  ENTRY
 *      dwTableAddr - physical address of table
 *      pdwTableSig -> to hold signature of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL VxDGetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig)
{
    PBYTE pb = NULL;
    DESCRIPTION_HEADER dh;

    ENTER((2, "VxDGetTableByAddr(TabAddr=%x,pdwSig=%p)\n",
           dwTableAddr, pdwTableSig));

    if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE, (PVOID)dwTableAddr, 0,
                        &dh, sizeof(dh), NULL, NULL))
    {
        DWORD dwLen = (dh.Signature == SIG_LOW_RSDP)? sizeof(RSDP): dh.Length;

        if ((pb = MEMALLOC(dwLen)) != NULL)
        {
            if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)dwTableAddr, 0, pb, dwLen, NULL, NULL)
                == 0)
            {
                ERROR(("VxDGetTableByAddr: failed to get table %s at %x. (rc=%x)",
                       GetTableSigStr(dh.Signature), dwTableAddr,
		       GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
            else if (pdwTableSig != NULL)
            {
		if (pdwTableSig != NULL)
		{
                    *pdwTableSig = (dh.Signature == SIG_LOW_RSDP)?
                                    SIG_RSDP: dh.Signature;
		}

		ValidateTable(pb, dwLen);
            }
        }
        else
        {
            ERROR(("VxDGetTableByAddr: failed to allocate table buffer (len=%d)",
                   dh.Length));
        }
    }
    else
    {
        ERROR(("VxDGetTableByAddr: failed to get table %s header (rc=%x)",
               GetTableSigStr(dh.Signature), GetLastError()));
    }

    EXIT((2, "VxDGetTableByAddr=%x\n", pb));
    return pb;
}       //VxDGetTableByAddr
#endif  //ifndef WINNT

/***LP  EnumSubKey - enumerate subkey
 *
 *  ENTRY
 *      hkey - key to enumerate
 *      dwIndex - subkey index
 *
 *  EXIT-SUCCESS
 *      returns subkey
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL EnumSubKey(HKEY hkey, DWORD dwIndex)
{
    HKEY hkeySub = NULL;
    char szSubKey[32];
    DWORD dwSubKeySize = sizeof(szSubKey);

    ENTER((2, "EnumSubKey(hkey=%x,Index=%d)\n", hkey, dwIndex));

    if ((RegEnumKeyEx(hkey, dwIndex, szSubKey, &dwSubKeySize, NULL, NULL, NULL,
                      NULL) == ERROR_SUCCESS) &&
        (RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub) != ERROR_SUCCESS))
    {
        hkeySub = NULL;
    }

    EXIT((2, "EnumSubKey=%x\n", hkeySub));
    return hkeySub;
}       //EnumSubKey

/***LP  OpenNTTable - Open ACPI table in NT registry
 *
 *  ENTRY
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns table registry handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL OpenNTTable(DWORD dwTabSig)
{
    HKEY hkeyTab = NULL, hkey1 = NULL, hkey2 = NULL;
    static char szTabKey[] = "Hardware\\ACPI\\xxxx";

    ENTER((2, "OpenNTTable(TabSig=%s)\n", GetTableSigStr(dwTabSig)));

    if (dwTabSig == FADT_SIGNATURE)
    {
        memcpy(&szTabKey[strlen(szTabKey) - 4], "FADT", sizeof(ULONG));
    }
    else
    {
        memcpy(&szTabKey[strlen(szTabKey) - 4], &dwTabSig, sizeof(ULONG));
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTabKey, 0, KEY_READ, &hkey1) ==
        ERROR_SUCCESS)
    {
        //
        // hkey1 is now "Hardware\ACPI\<TabSig>"
        //
        if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
        {
            //
            // hkey2 is now "Hardware\ACPI\<TabSig>\<OEMID>"
            //
            RegCloseKey(hkey1);
            if ((hkey1 = EnumSubKey(hkey2, 0)) != NULL)
            {
                //
                // hkey1 is now "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>"
                //
                RegCloseKey(hkey2);
                if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
                {
                    //
                    // hkey2 is now
                    // "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>\<OEMRev>"
                    //
                    hkeyTab = hkey2;
                }
            }
        }
    }

    if (hkey1 != NULL)
    {
        RegCloseKey(hkey1);
    }

    if ((hkey2 != NULL) && (hkeyTab != hkey2))
    {
        RegCloseKey(hkey2);
    }

    EXIT((2, "OpenNTTable=%x\n", hkeyTab));
    return hkeyTab;
}       //OpenNTTable

/***LP  GetNTTable - Get ACPI table from NT registry
 *
 *  ENTRY
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetNTTable(DWORD dwTabSig)
{
    PBYTE pb = NULL;
    HKEY hkeyTab;

    ENTER((2, "GetNTTable(TabSig=%s)\n", GetTableSigStr(dwTabSig)));

    if ((hkeyTab = OpenNTTable(dwTabSig)) != NULL)
    {
        DWORD dwLen = 0;
        PSZ pszTabKey = "00000000";

        if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, NULL, &dwLen) ==
            ERROR_SUCCESS)
        {
            if ((pb = MEMALLOC(dwLen)) != NULL)
            {
                if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, pb, &dwLen)
                    != ERROR_SUCCESS)
                {
                    ERROR(("GetNTTable: failed to read table"));
                }
            }
            else
            {
                ERROR(("GetNTTable: failed to allocate table buffer"));
            }
        }
        else
        {
            ERROR(("GetNTTable: failed to read table key"));
        }
        RegCloseKey(hkeyTab);
    }
    else
    {
        ERROR(("GetNTTable: failed to get table %s", GetTableSigStr(dwTabSig)));
    }

    EXIT((2, "GetNTTable=%x\n", pb));
    return pb;
}       //GetNTTable

/***LP  GetTableBySig - Get table by its signature
 *
 *  ENTRY
 *      dwTabSig - table signature
 *      pdwTableAddr -> to hold physical address of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr)
{
    PBYTE pb = NULL;

    ENTER((2, "GetTableBySig(TabSig=%x,pdwAddr=%p)\n", dwTabSig, pdwTableAddr));

    if (gdwfASL & ASLF_NT)
    {
        if (((pb = GetNTTable(dwTabSig)) != NULL) && (pdwTableAddr != NULL))
        {
            *pdwTableAddr = 0;
        }
    }
  #ifndef WINNT
    else
    {
        pb = VxDGetTableBySig(dwTabSig, pdwTableAddr);
    }
  #endif

    EXIT((2, "GetTableBySig=%x\n", pb));
    return pb;
}       //GetTableBySig

/***LP  GetTableByAddr - Get table by its physical address
 *
 *  ENTRY
 *      dwTableAddr - physical address of table
 *      pdwTableSig -> to hold signature of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig)
{
    PBYTE pb = NULL;

    ENTER((2, "GetTableByAddr(TabAddr=%x,pdwSig=%p)\n",
           dwTableAddr, pdwTableSig));

    if (gdwfASL & ASLF_NT)
    {
        ERROR(("GetTableByAddr: not supported by NT"));
    }
  #ifndef WINNT
    else
    {
        pb = VxDGetTableByAddr(dwTableAddr, pdwTableSig);
    }
  #endif

    EXIT((2, "GetTableByAddr=%x\n", pb));
    return pb;
}       //GetTableByAddr

/***LP  DumpAllTables - Dump all ACPI tables
 *
 *  ENTRY
 *	pfileOut -> output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpAllTables(FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwAddr;

    ENTER((1, "DumpAllTables(pfileOut=%p)\n", pfileOut));

    if (gdwfASL & ASLF_NT)
    {
        DumpTableBySig(pfileOut, RSDT_SIGNATURE);
        DumpTableBySig(pfileOut, FADT_SIGNATURE);
        DumpTableBySig(pfileOut, FACS_SIGNATURE);
        DumpTableBySig(pfileOut, SBST_SIGNATURE);
        DumpTableBySig(pfileOut, APIC_SIGNATURE);
        DumpTableBySig(pfileOut, SIG_BOOT);
	DumpTableBySig(pfileOut, SIG_DBGP);
        DumpTableBySig(pfileOut, DSDT_SIGNATURE);
        DumpTableBySig(pfileOut, SSDT_SIGNATURE);
        DumpTableBySig(pfileOut, PSDT_SIGNATURE);
    }
    else if ((pb = GetTableBySig(SIG_RSDP, &dwAddr)) != NULL)
    {
        if ((rc = DumpRSDP(pfileOut, pb, dwAddr)) == ASLERR_NONE)
        {
            DWORD dwRSDTAddr = ((PRSDP)pb)->RsdtAddress;
            DWORD dwTableSig;

            MEMFREE(pb);
            if ((pb = GetTableByAddr(dwRSDTAddr, &dwTableSig)) != NULL)
            {
                if ((rc = DumpTable(pfileOut, pb, dwRSDTAddr, dwTableSig)) ==
                    ASLERR_NONE)
                {
                    PRSDT pRSDT = (PRSDT)pb;
                    DWORD i, dwcEntries;

                    dwcEntries = (pRSDT->Header.Length -
                                  sizeof(DESCRIPTION_HEADER))/sizeof(ULONG);

                    for (i = 0; i < dwcEntries; ++i)
                    {
                        if ((rc = DumpTableByAddr(pfileOut, pRSDT->Tables[i]))
                            != ASLERR_NONE)
                        {
                            break;
                        }
                    }
                }

                if ((rc == ASLERR_NONE) &&
                    ((rc = DumpTableBySig(pfileOut, FACS_SIGNATURE)) ==
                     ASLERR_NONE))
                {
                    rc = DumpTableBySig(pfileOut, DSDT_SIGNATURE);
                }
            }
            else
            {
                rc = ASLERR_GET_TABLE;
            }
        }

        if (pb != NULL)
        {
            MEMFREE(pb);
        }
    }
    else
    {
	rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpAllTables=%d\n", rc));
    return rc;
}	//DumpAllTables

/***LP  DumpTableBySig - Dump an ACPI table by its Table Signature
 *
 *  ENTRY
 *	pfileOut -> output file
 *      dwTableSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableBySig(FILE *pfileOut, DWORD dwTableSig)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwTableAddr;

    ENTER((1, "DumpTableBySig(pfileOut=%p,TableSig=%s)\n",
           pfileOut, GetTableSigStr(dwTableSig)));

    if (((PSZ)&dwTableSig)[0] == '*')
    {
        rc = DumpAllTables(pfileOut);
    }
    else if ((pb = GetTableBySig(dwTableSig, &dwTableAddr)) != NULL)
    {
        rc = DumpTable(pfileOut, pb, dwTableAddr, dwTableSig);
        MEMFREE(pb);
    }
    else
    {
        rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpTableBySig=%d\n", rc));
    return rc;
}       //DumpTableBySig

/***LP  DumpTableByAddr - Dump an ACPI table by its address
 *
 *  ENTRY
 *	pfileOut -> output file
 *      dwTableAddr - physical address of the table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableByAddr(FILE *pfileOut, DWORD dwTableAddr)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwTableSig;

    ENTER((1, "DumpTableByAddr(pfileOut=%p,TableAddr=%x)\n",
           pfileOut, dwTableAddr));

    if ((pb = GetTableByAddr(dwTableAddr, &dwTableSig)) != NULL)
    {
        rc = DumpTable(pfileOut, pb, dwTableAddr, dwTableSig);
        MEMFREE(pb);
    }
    else
    {
        rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpTableByAddr=%d\n", rc));
    return rc;
}       //DumpTableByAddr

/***LP  DumpRSDP - Dump the RSD PTR table
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> RSDP structure
 *      dwAddr - physical address of RSDP
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpRSDP(FILE *pfileOut, PBYTE pb, DWORD dwAddr)
{
    int rc = ASLERR_NONE;

    ENTER((1, "DumpRSDP(pfileOut=%p,Addr=%x,pRSDP=%p)\n",
           pfileOut, dwAddr, pb));

    if (pfileOut != NULL)
    {
        DWORD dwOffset = 0;

        fprintf(pfileOut, szSectFmt, dwAddr, "RSD PTR");
        if (BinFPrintf(pfileOut, NULL, afmtRSDPTR, pb, &dwOffset, szOffsetFmt)
            != FERR_NONE)
        {
            ERROR(("DumpRSDP: failed to dump RSD PTR structure"));
            rc = ASLERR_INTERNAL_ERROR;
        }
    }
    else
    {
        rc = DumpTableBin(SIG_RSDP, dwAddr, pb, sizeof(RSDP));
    }

    EXIT((1, "DumpRSDP=%d\n", rc));
    return rc;
}       //DumpRSDP

/***LP  DumpTable - Dump an ACPI table
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> ACPI table
 *      dwTableAddr - physical address of table
 *      dwTableSig - signature of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTable(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                    DWORD dwTableSig)
{
    int rc = ASLERR_NONE;

    ENTER((1, "DumpTable(pfileOut=%p,pb=%p,TableAddr=%x,TableSig=%s)\n",
           pfileOut, pb, dwTableAddr, GetTableSigStr(dwTableSig)));

    if (dwTableSig == SIG_RSDP)
    {
        rc = DumpRSDP(pfileOut, pb, dwTableAddr);
    }
    else if (pfileOut != NULL)
    {
        rc = DumpTableTxt(pfileOut, pb, dwTableAddr, dwTableSig);
    }
    else
    {
        rc = DumpTableBin(dwTableSig, dwTableAddr, pb,
                          (dwTableSig == FACS_SIGNATURE)?
                            sizeof(FACS):
                            ((PDESCRIPTION_HEADER)pb)->Length);
    }

    EXIT((1, "DumpTable=%d\n", rc));
    return rc;
}       //DumpTable

/***LP  DumpTableTxt - Dump an ACPI table to a text file
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> ACPI table
 *      dwTableAddr - physical address of table
 *      dwTableSig - signature of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableTxt(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                       DWORD dwTableSig)
{
    int rc = ASLERR_NONE;
    PFMT pfmt;
    DWORD dwFlags;

    ENTER((1, "DumpTableTxt(pfileOut=%p,pb=%p,TableAddr=%x,TableSig=%s)\n",
           pfileOut, pb, dwTableAddr, GetTableSigStr(dwTableSig)));

    if ((rc = FindTableFmt(dwTableSig, &pfmt, &dwFlags)) ==
        ASLERR_SIG_NOT_FOUND)
    {
        rc = ASLERR_NONE;
    }

    if (rc == ASLERR_NONE)
    {
        DWORD dwOffset = 0;

        fprintf(pfileOut, szSectFmt, dwTableAddr, GetTableSigStr(dwTableSig));
        if (!(dwFlags & TF_NOHDR) &&
            (BinFPrintf(pfileOut, NULL, afmtTableHdr, pb, &dwOffset,
                        szOffsetFmt) != FERR_NONE))
        {
            ERROR(("DumpTableTxt: failed to dump %s structure header",
                   GetTableSigStr(dwTableSig)));
            rc = ASLERR_INTERNAL_ERROR;
        }
        else if (pfmt != NULL)
        {
            if (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset, szOffsetFmt) !=
                FERR_NONE)
            {
                ERROR(("DumpTableTxt: failed to dump %s structure",
                       GetTableSigStr(dwTableSig)));
                rc = ASLERR_INTERNAL_ERROR;
            }
            else if ((dwTableSig == FADT_SIGNATURE) &&
                     (((PDESCRIPTION_HEADER)pb)->Revision > 1))
            {
                /*
                pfmt = (((PGRAS)pb)->id == REGSPACE_PCICFG)? afmtGRASPCICS:
                                                             afmtGRASRegAddr;*/
                fprintf(pfileOut, "; Reset Register\n");
                if ((BinFPrintf(pfileOut, NULL, afmtGRASCommon, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, afmtFACP2, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE))
                {
                    ERROR(("DumpTableTxt: failed to dump extended %s structure",
                           GetTableSigStr(dwTableSig)));
                    rc = ASLERR_INTERNAL_ERROR;
                }
            }
            else if (dwTableSig == SIG_DBGP)
            {

                /*
                pfmt = (((PGRAS)pb)->id == REGSPACE_PCICFG)? afmtGRASPCICS:
                                                             afmtGRASRegAddr;*/

                fprintf(pfileOut, "; Debug Port Base Address\n");
                if ((BinFPrintf(pfileOut, NULL, afmtGRASCommon, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE))
                {
                    ERROR(("DumpTableTxt: failed to dump extended %s structure",
                           GetTableSigStr(dwTableSig)));
                    rc = ASLERR_INTERNAL_ERROR;
                }
            }
        }
        else
        {
            #define NUM_COLS    16
            PRSDT pRSDT;
            DWORD i, dwcEntries;
            PBYTE pbEnd;
            char szAMLName[_MAX_FNAME];
            char szBytes[NUM_COLS + 1];

            switch (dwTableSig)
            {
                case RSDT_SIGNATURE:
                    pRSDT = (PRSDT)pb;
                    dwcEntries = (pRSDT->Header.Length -
                                  sizeof(DESCRIPTION_HEADER))/sizeof(ULONG);
                    for (i = 0; i < dwcEntries; ++i)
                    {
                        fprintf(pfileOut, szOffsetFmt, dwOffset);
                        fprintf(pfileOut, "[%02d] %08lx\n",
                                i, pRSDT->Tables[i]);
                        dwOffset += sizeof(ULONG);
                    }
                    break;

                case DSDT_SIGNATURE:
                case SSDT_SIGNATURE:
                case PSDT_SIGNATURE:
                    strncpy(szAMLName, (PSZ)&dwTableSig, sizeof(DWORD));
                    strcpy(&szAMLName[sizeof(DWORD)], ".AML");
                    rc = UnAsmAML(szAMLName, dwTableAddr, pb,
                                  (PFNPRINT)fprintf, pfileOut);
                    break;

                default:
                    //
                    // Don't return error because we want to continue.
                    //
                    WARN(("DumpTableTxt: unexpected table signature %s",
                          GetTableSigStr(dwTableSig)));

                    pbEnd = pb + ((PDESCRIPTION_HEADER)pb)->Length;
                    pb += sizeof(DESCRIPTION_HEADER);
                    i = 0;
                    while (pb < pbEnd)
                    {
                        szBytes[i] = (char)(isprint(*pb)? *pb: '.');
                        if (i == 0)
                        {
                            fprintf(pfileOut, szOffsetFmt, dwOffset);
                            fprintf(pfileOut, "%02x", *pb);
                        }
                        else if (i == NUM_COLS/2)
                        {
                            fprintf(pfileOut, "-%02x", *pb);
                        }
                        else
                        {
                            fprintf(pfileOut, ",%02x", *pb);
                        }
                        i++;
                        if (i == NUM_COLS)
                        {
                            szBytes[i] = '\0';
                            fprintf(pfileOut, "  ;%s\n", szBytes);
                            i = 0;
                        }
                        dwOffset += sizeof(BYTE);
                        pb += sizeof(BYTE);
                    }

                    if (i < NUM_COLS)
                    {
                        szBytes[i] = '\0';
                        while (i < NUM_COLS)
                        {
                            fprintf(pfileOut, "   ");
                            i++;
                        }
                        fprintf(pfileOut, "  ;%s\n", szBytes);
                    }
            }
        }
    }

    EXIT((1, "DumpTableTxt=%d\n", rc));
    return rc;
}       //DumpTableTxt

/***LP  DumpTableBin - Dump an ACPI table to a binary file
 *
 *  ENTRY
 *      dwTableSig - table signature
 *      dwAddr - physical address of table
 *      pb -> ACPI table
 *      dwLen - length of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableBin(DWORD dwTableSig, DWORD dwAddr, PBYTE pb, DWORD dwLen)
{
    int rc = ASLERR_NONE;
    char szBinFile[_MAX_FNAME];
    FILE *pfile;

    ENTER((1, "DumpTableBin(TableSig=%s,Addr=%x,pb=%p,Len=%d)\n",
           GetTableSigStr(dwTableSig), dwAddr, pb, dwLen));

    strncpy(szBinFile, (PSZ)&dwTableSig, sizeof(DWORD));
    sprintf(&szBinFile[sizeof(DWORD)], "%04x", (WORD)dwAddr);
    strcpy(&szBinFile[sizeof(DWORD) + 4], ".BIN");
    if ((pfile = fopen(szBinFile, "wb")) == NULL)
    {
        ERROR(("DumpTableBin: failed to create file %s", szBinFile));
        rc = ASLERR_CREATE_FILE;
    }
    else
    {
        if (fwrite(pb, dwLen, 1, pfile) != 1)
        {
            ERROR(("DumpTableBin: failed to write to file %s", szBinFile));
            rc = ASLERR_WRITE_FILE;
        }
        fclose(pfile);
    }

    EXIT((1, "DumpTableBin=%d\n", rc));
    return rc;
}       //DumpTableBin

/***LP  FindTableFmt - Find the appropriate table format structure
 *
 *  ENTRY
 *      dwTableSig - table signature
 *      ppfmt -> to hold pfmt found
 *      pdwFlags -> to hold table flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FindTableFmt(DWORD dwTableSig, PFMT *ppfmt, PDWORD pdwFlags)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((1, "FindTableFmt(TableSig=%s,ppfmt=%p,pdwFlags=%p)\n",
           GetTableSigStr(dwTableSig), ppfmt, pdwFlags));

    for (i = 0; FmtTable[i].dwTableSig != 0; ++i)
    {
        if (dwTableSig == FmtTable[i].dwTableSig)
        {
            *ppfmt = FmtTable[i].pfmt;
            *pdwFlags = FmtTable[i].dwFlags;
            break;
        }
    }

    if (FmtTable[i].dwTableSig == 0)
    {
        *ppfmt = NULL;
        *pdwFlags = 0;
        rc = ASLERR_SIG_NOT_FOUND;
    }

    EXIT((1, "FindTableFmt=%d (pfmt=%p,Flags=%x)\n", rc, *ppfmt, *pdwFlags));
    return rc;
}       //FindTableFmt

/***LP  GetTableSigStr - Get table signature string
 *
 *  ENTRY
 *      dwTableSig - table signature
 *
 *  EXIT
 *      returns the table signature string
 */

PSZ LOCAL GetTableSigStr(DWORD dwTableSig)
{
    static char szTableSig[5] = {0};

    ENTER((2, "GetTableSigStr(TableSig=%08x)\n", dwTableSig));

    strncpy(szTableSig, (PSZ)&dwTableSig, sizeof(DWORD));

    EXIT((2, "GetTableSigStr=%s\n", szTableSig));
    return szTableSig;
}       //GetTableSigStr

/***LP	ValidateTable - Validate the given table
 *
 *  ENTRY
 *	pbTable -> Table
 *	dwLen - Table length
 *
 *  EXIT-SUCCESS
 *	returns TRUE
 *  EXIT-FAILURE
 *	returns FALSE
 */

BOOL LOCAL ValidateTable(PBYTE pbTable, DWORD dwLen)
{
    BOOL rc = TRUE;
    DWORD dwTableSig, dwTableLen = 0;
    BOOL fNeedChkSum = FALSE;

    ENTER((2, "ValidateTable(pbTable=%x,Len=%d)\n", pbTable, dwLen));

    dwTableSig = ((PDESCRIPTION_HEADER)pbTable)->Signature;
    switch (dwTableSig)
    {
	case SIG_LOW_RSDP:
	    dwTableLen = sizeof(RSDP);
	    fNeedChkSum = TRUE;
	    break;

	case RSDT_SIGNATURE:
	case FADT_SIGNATURE:
	case DSDT_SIGNATURE:
	case SSDT_SIGNATURE:
	case PSDT_SIGNATURE:
	case APIC_SIGNATURE:
	case SBST_SIGNATURE:
	case SIG_BOOT:
	case SIG_DBGP:
	    dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
	    fNeedChkSum = TRUE;
	    break;

	case FACS_SIGNATURE:
	    dwTableLen = ((PFACS)pbTable)->Length;
	    break;

	default:
	    if (IsALikelySig(dwTableSig) &&
	        (((PDESCRIPTION_HEADER)pbTable)->Length < 256))
	    {
		dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
		fNeedChkSum = TRUE;
	    }
	    else
	    {
		WARN(("ValidateTable: invalid table signature %s",
                      GetTableSigStr(dwTableSig)));
		rc = FALSE;
	    }
    }

    if (dwTableLen > dwLen)
    {
        WARN(("ValidateTable: invalid length %d in table %s",
              dwTableLen, GetTableSigStr(dwTableSig)));
	rc = FALSE;
    }

    if ((rc == TRUE) && fNeedChkSum &&
        (ComputeDataChkSum(pbTable, dwTableLen) != 0))
    {
        WARN(("ValidateTable: invalid checksum in table %s",
              GetTableSigStr(dwTableSig)));
	rc = FALSE;
    }

    EXIT((2, "ValidateTable=%x\n", rc));
    return rc;
}	//ValidateTable

/***LP	IsALikelySig - Check if a table signature is possibly valid
 *
 *  ENTRY
 *	dwTableSig - table signature
 *
 *  EXIT-SUCCESS
 *	returns TRUE
 *  EXIT-FAILURE
 *	returns FALSE
 */

BOOL LOCAL IsALikelySig(DWORD dwTableSig)
{
    BOOL rc = TRUE;
    int i, ch;

    ENTER((2, "IsALikelySig(dwTableSig=%x)\n", dwTableSig));

    for (i = 0; i < sizeof(DWORD); ++i)
    {
	ch = BYTEOF(dwTableSig, i);
	if ((ch < 'A') || (ch > 'Z'))
	{
	    rc = FALSE;
	    break;
        }
    }

    EXIT((2, "IsALikelySig=%x\n", rc));
    return rc;
}	//IsALikelySig

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\uasmdata.c ===
/*** uasmdata.c - Unassembler Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

PBYTE gpbOpTop = NULL;
PBYTE gpbOpBegin = NULL;

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      TC_COMPILER_DIRECTIVE
#define FM      TC_FIELD_MACRO
#define CN      TC_CONST_NAME
#define SN      TC_SHORT_NAME
#define NS      TC_NAMESPACE_MODIFIER
#define DO      TC_DATA_OBJECT
#define KW      TC_KEYWORD
#define NO      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define RO      TC_REF_OBJECT
#define PM      TC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM       | 0xff00)
#define IO      (REGSPACE_IO        | 0xff00)
#define CFG     (REGSPACE_PCICFG    | 0xff00)
#define EC      (REGSPACE_EC        | 0xff00)
#define SMB     (REGSPACE_SMB       | 0xff00)
#define CMOSCFG (REGSPACE_CMOSCFG   | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

#ifdef _UNASM_LIB
  #define DefinitionBlock   NULL
  #define Include           NULL
  #define External          NULL
  #define EISAID            NULL
  #define AccessAs          NULL
  #define BankField         NULL
  #define Field             NULL
  #define IndexField        NULL
  #define Method            NULL
  #define OpRegion          NULL
  #define Else              NULL
  #define Match             NULL
  #define ResourceTemplate  NULL
  #define AddSmallOffset    NULL
  #define StartDependentFn  NULL
  #define AddSmallOffset    NULL
  #define IRQDesc           NULL
  #define IRQDesc           NULL
  #define DMADesc           NULL
  #define IODesc            NULL
  #define FixedIODesc       NULL
  #define VendorShort       NULL
  #define Memory24Desc      NULL
  #define VendorLong        NULL
  #define Memory32Desc      NULL
  #define FixedMemory32Desc NULL
  #define DWordMemDesc      NULL
  #define DWordIODesc       NULL
  #define WordIODesc        NULL
  #define WordBusNumDesc    NULL
  #define InterruptDesc     NULL
  #define QWordMemDesc      NULL
  #define QWordIODesc       NULL
#endif

ASLTERM TermTable[] =
{
    "DefinitionBlock",  ID_DEFBLK,       CD, 0, OP_NONE,     NULL, "ZZBZZD", NULL, OL|CL|LL|AF|AV, DefinitionBlock,
    "Include",          ID_INCLUDE,      CD, 0, OP_NONE,     NULL, "Z",      NULL, AF, Include,
    "External",         ID_EXTERNAL,     CD, 0, OP_NONE,     NULL, "Nkd",    "uX", AF, External,

    // Short Objects
    "Zero",             ID_ZERO,         CN, 0, OP_ZERO,     NULL, NULL, NULL, 0, NULL,
    "One",              ID_ONE,          CN, 0, OP_ONE,      NULL, NULL, NULL, 0, NULL,
    "Ones",             ID_ONES,         CN, 0, OP_ONES,     NULL, NULL, NULL, 0, NULL,
    "Revision",         ID_REVISION,     CN, 0, OP_REVISION, NULL, NULL, NULL, 0, NULL,
    "Arg0",             ID_ARG0,         SN, 0, OP_ARG0,     NULL, NULL, NULL, 0, NULL,
    "Arg1",             ID_ARG1,         SN, 0, OP_ARG1,     NULL, NULL, NULL, 0, NULL,
    "Arg2",             ID_ARG2,         SN, 0, OP_ARG2,     NULL, NULL, NULL, 0, NULL,
    "Arg3",             ID_ARG3,         SN, 0, OP_ARG3,     NULL, NULL, NULL, 0, NULL,
    "Arg4",             ID_ARG4,         SN, 0, OP_ARG4,     NULL, NULL, NULL, 0, NULL,
    "Arg5",             ID_ARG5,         SN, 0, OP_ARG5,     NULL, NULL, NULL, 0, NULL,
    "Arg6",             ID_ARG6,         SN, 0, OP_ARG6,     NULL, NULL, NULL, 0, NULL,
    "Local0",           ID_LOCAL0,       SN, 0, OP_LOCAL0,   NULL, NULL, NULL, 0, NULL,
    "Local1",           ID_LOCAL1,       SN, 0, OP_LOCAL1,   NULL, NULL, NULL, 0, NULL,
    "Local2",           ID_LOCAL2,       SN, 0, OP_LOCAL2,   NULL, NULL, NULL, 0, NULL,
    "Local3",           ID_LOCAL3,       SN, 0, OP_LOCAL3,   NULL, NULL, NULL, 0, NULL,
    "Local4",           ID_LOCAL4,       SN, 0, OP_LOCAL4,   NULL, NULL, NULL, 0, NULL,
    "Local5",           ID_LOCAL5,       SN, 0, OP_LOCAL5,   NULL, NULL, NULL, 0, NULL,
    "Local6",           ID_LOCAL6,       SN, 0, OP_LOCAL6,   NULL, NULL, NULL, 0, NULL,
    "Local7",           ID_LOCAL7,       SN, 0, OP_LOCAL7,   NULL, NULL, NULL, 0, NULL,
    "Debug",            ID_DEBUG,        SN, 0, OP_DEBUG,    NULL, NULL, NULL, 0, NULL,

    // Named Terms
    "Alias",            ID_ALIAS,        NS, 0, OP_ALIAS,    "NN", "NN", "Ua", 0, NULL,
    "Name",             ID_NAME,         NS, 0, OP_NAME,     "NO", "NO", "u",  0, NULL,
    "Scope",            ID_SCOPE,        NS, 0, OP_SCOPE,    "N",  "N",  "S",  OL|LN|CC, NULL,

    // Data Objects
    "Buffer",           ID_BUFFER,       DO, 0, OP_BUFFER,   "C", "c",  "U",  DL|LN, NULL,
    "Package",          ID_PACKAGE,      DO, 0, OP_PACKAGE,  "B", "b",  NULL, PL|LN, NULL,
    "EISAID",           ID_EISAID,       DO, 0, OP_DWORD,    NULL,"Z",  NULL, AF, EISAID,

    // Argument Keywords
    "AnyAcc",           ID_ANYACC,       KW, AANY, OP_NONE, NULL, NULL, "A", 0, NULL,
    "ByteAcc",          ID_BYTEACC,      KW, AB,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "WordAcc",          ID_WORDACC,      KW, AW,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "DWordAcc",         ID_DWORDACC,     KW, ADW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "QWordAcc",         ID_QWORDACC,     KW, AQW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "BufferAcc",        ID_BUFFERACC,    KW, ABFR, OP_NONE, NULL, NULL, "A", 0, NULL,

    "Lock",             ID_LOCK,         KW, LK,   OP_NONE, NULL, NULL, "B", 0, NULL,
    "NoLock",           ID_NOLOCK,       KW, NOLK, OP_NONE, NULL, NULL, "B", 0, NULL,

    "Preserve",         ID_PRESERVE,     KW, PSRV, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsOnes",      ID_WRONES,       KW, WA1S, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsZeros",     ID_WRZEROS,      KW, WA0S, OP_NONE, NULL, NULL, "C", 0, NULL,

    "SystemMemory",     ID_SYSMEM,       KW, MEM,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "SystemIO",         ID_SYSIO,        KW, IO,   		OP_NONE, NULL, NULL, "D", 0, NULL,
    "PCI_Config",       ID_PCICFG,       KW, CFG,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "EmbeddedControl",  ID_EMBCTRL,      KW, EC,   		OP_NONE, NULL, NULL, "D", 0, NULL,
    "SMBus",            ID_SMBUS,        KW, SMB,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "CMOS",             ID_CMOSCFG,      KW, CMOSCFG, 	OP_NONE, NULL, NULL, "D", 0, NULL,

    "Serialized",       ID_SERIALIZED,   KW, SER,  OP_NONE, NULL, NULL, "E", 0, NULL,
    "NotSerialized",    ID_NOTSERIALIZED,KW, NOSER,OP_NONE, NULL, NULL, "E", 0, NULL,

    "MTR",              ID_MTR,          KW, OMTR, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MEQ",              ID_MEQ,          KW, OMEQ, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLE",              ID_MLE,          KW, OMLE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLT",              ID_MLT,          KW, OMLT, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGE",              ID_MGE,          KW, OMGE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGT",              ID_MGT,          KW, OMGT, OP_NONE, NULL, NULL, "F", 0, NULL,

    "Edge",             ID_EDGE,         KW, _HE,  OP_NONE, NULL, NULL, "G", 0, NULL,
    "Level",            ID_LEVEL,        KW, _LL,  OP_NONE, NULL, NULL, "G", 0, NULL,

    "ActiveHigh",       ID_ACTIVEHI,     KW, _HE,  OP_NONE, NULL, NULL, "H", 0, NULL,
    "ActiveLow",        ID_ACTIVELO,     KW, _LL,  OP_NONE, NULL, NULL, "H", 0, NULL,

    "Shared",           ID_SHARED,       KW, _SHR, OP_NONE, NULL, NULL, "I", 0, NULL,
    "Exclusive",        ID_EXCLUSIVE,    KW, _EXC, OP_NONE, NULL, NULL, "I", 0, NULL,

    "Compatibility",    ID_COMPAT,       KW, COMP, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeA",            ID_TYPEA,        KW, TYPA, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeB",            ID_TYPEB,        KW, TYPB, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeF",            ID_TYPEF,        KW, TYPF, OP_NONE, NULL, NULL, "J", 0, NULL,

    "BusMaster",        ID_BUSMASTER,    KW, BM,   OP_NONE, NULL, NULL, "K", 0, NULL,
    "NotBusMaster",     ID_NOTBUSMASTER, KW, NOBM, OP_NONE, NULL, NULL, "K", 0, NULL,

    "Transfer8",        ID_TRANSFER8,    KW, X8,   OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer8_16",     ID_TRANSFER8_16, KW, X816, OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer16",       ID_TRANSFER16,   KW, X16,  OP_NONE, NULL, NULL, "L", 0, NULL,

    "Decode16",         ID_DECODE16,     KW, DC16, OP_NONE, NULL, NULL, "M", 0, NULL,
    "Decode10",         ID_DECODE10,     KW, DC10, OP_NONE, NULL, NULL, "M", 0, NULL,

    "ReadWrite",        ID_READWRITE,    KW, _RW,  OP_NONE, NULL, NULL, "N", 0, NULL,
    "ReadOnly",         ID_READONLY,     KW, _ROM, OP_NONE, NULL, NULL, "N", 0, NULL,

    "ResourceConsumer", ID_RESCONSUMER,  KW, RCS,  OP_NONE, NULL, NULL, "O", 0, NULL,
    "ResourceProducer", ID_RESPRODUCER,  KW, RPD,  OP_NONE, NULL, NULL, "O", 0, NULL,

    "SubDecode",        ID_SUBDECODE,    KW, BSD,  OP_NONE, NULL, NULL, "P", 0, NULL,
    "PosDecode",        ID_POSDECODE,    KW, BPD,  OP_NONE, NULL, NULL, "P", 0, NULL,

    "MinFixed",         ID_MINFIXED,     KW, MIF,  OP_NONE, NULL, NULL, "Q", 0, NULL,
    "MinNotFixed",      ID_MINNOTFIXED,  KW, NMIF, OP_NONE, NULL, NULL, "Q", 0, NULL,

    "MaxFixed",         ID_MAXFIXED,     KW, MAF,  OP_NONE, NULL, NULL, "R", 0, NULL,
    "MaxNotFixed",      ID_MAXNOTFIXED,  KW, NMAF, OP_NONE, NULL, NULL, "R", 0, NULL,

    "Cacheable",        ID_CACHEABLE,    KW, CACH, OP_NONE, NULL, NULL, "S", 0, NULL,
    "WriteCombining",   ID_WRCOMBINING,  KW, WRCB, OP_NONE, NULL, NULL, "S", 0, NULL,
    "Prefetchable",     ID_PREFETCHABLE, KW, PREF, OP_NONE, NULL, NULL, "S", 0, NULL,
    "NonCacheable",     ID_NONCACHEABLE, KW, NCAC, OP_NONE, NULL, NULL, "S", 0, NULL,

    "ISAOnlyRanges",    ID_ISAONLYRNG,   KW, ISA,  OP_NONE, NULL, NULL, "T", 0, NULL,
    "NonISAOnlyRanges", ID_NONISAONLYRNG,KW, NISA, OP_NONE, NULL, NULL, "T", 0, NULL,
    "EntireRange",      ID_ENTIRERNG,    KW, ERNG, OP_NONE, NULL, NULL, "T", 0, NULL,

    "ExtEdge",          ID_EXT_EDGE,     KW, $EDG, OP_NONE, NULL, NULL, "U", 0, NULL,
    "ExtLevel",         ID_EXT_LEVEL,    KW, $LVL, OP_NONE, NULL, NULL, "U", 0, NULL,

    "ExtActiveHigh",    ID_EXT_ACTIVEHI, KW, $HGH, OP_NONE, NULL, NULL, "V", 0, NULL,
    "ExtActiveLow",     ID_EXT_ACTIVELO, KW, $LOW, OP_NONE, NULL, NULL, "V", 0, NULL,

    "ExtShared",        ID_EXT_SHARED,   KW, $SHR, OP_NONE, NULL, NULL, "W", 0, NULL,
    "ExtExclusive",     ID_EXT_EXCLUSIVE,KW, $EXC, OP_NONE, NULL, NULL, "W", 0, NULL,

    "UnknownObj",       ID_UNKNOWN_OBJ,  KW, UNK,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "IntObj",           ID_INT_OBJ,      KW, INT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "StrObj",           ID_STR_OBJ,      KW, STR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffObj",          ID_BUFF_OBJ,     KW, BUF,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PkgObj",           ID_PKG_OBJ,      KW, PKG,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "FieldUnitObj",     ID_FIELDUNIT_OBJ,KW, FDU,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DeviceObj",        ID_DEV_OBJ,      KW, DEV,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "EventObj",         ID_EVENT_OBJ,    KW, EVT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MethodObj",        ID_METHOD_OBJ,   KW, MET,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MutexObj",         ID_MUTEX_OBJ,    KW, MUT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "OpRegionObj",      ID_OPREGION_OBJ, KW, OPR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PowerResObj",      ID_POWERRES_OBJ, KW, PWR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "ThermalZoneObj",   ID_THERMAL_OBJ,  KW, THM,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffFieldObj",     ID_BUFFFIELD_OBJ,KW, BFD,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DDBHandleObj",     ID_DDBHANDLE_OBJ,KW, DDB,  OP_NONE, NULL, NULL, "X", 0, NULL,

    "SMBQuick",            ID_SMBQUICK,            KW, SMBQ, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBSendReceive",      ID_SMBSENDRECEIVE,      KW, SMBS, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBByte",             ID_SMBBYTE,             KW, SMBB, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBWord",             ID_SMBWORD,             KW, SMBW, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBBlock",            ID_SMBBLOCK,            KW, SMBK, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBProcessCall",      ID_SMBPROCESSCALL,      KW, SMBP, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBBlockProcessCall", ID_SMBBLOCKPROCESSCALL, KW, SMBC, OP_NONE, NULL, NULL, "Y", 0, NULL,

    // Field Macros
    "Offset",           ID_OFFSET,       FM, 0, OP_NONE, NULL, "B",  NULL, 0,  NULL,
    "AccessAs",         ID_ACCESSAS,     FM, 0, 0x01,    NULL, "Ke", "AY", AF, AccessAs,

    // Named Object Creators
    "BankField",        ID_BANKFIELD,    NO, 0, OP_BANKFIELD,  "NNCKkk","NNCKKK","OFUABC", FL|FM|LN|AF, BankField,
    "CreateBitField",   ID_BITFIELD,     NO, 0, OP_BITFIELD,   "CCN", "CPN", "UUb",0, NULL,
    "CreateByteField",  ID_BYTEFIELD,    NO, 0, OP_BYTEFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "CreateDWordField", ID_DWORDFIELD,   NO, 0, OP_DWORDFIELD, "CCN", "CMN", "UUb",0, NULL,
    "CreateField",      ID_CREATEFIELD,  NO, 0, OP_CREATEFIELD,"CCCN","CPCN","UUUb",0,NULL,
    "CreateWordField",  ID_WORDFIELD,    NO, 0, OP_WORDFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "Device",           ID_DEVICE,       NO, 0, OP_DEVICE,     "N",    "N",      "d",      OL|LN|CC, NULL,
    "Event",            ID_EVENT,        NO, 0, OP_EVENT,      "N",    "N",      "e",      0, NULL,
    "Field",            ID_FIELD,        NO, 0, OP_FIELD,      "NKkk", "NKKK",   "OABC",   FL|FM|LN|AF, Field,
    "IndexField",       ID_IDXFIELD,     NO, 0, OP_IDXFIELD,   "NNKkk","NNKKK",  "FFABC",  FL|FM|LN|AF, IndexField,
    "Method",           ID_METHOD,       NO, 0, OP_METHOD,     "NKk",  "Nbk",    "m!E",    CL|OL|LN|AF|CC, Method,
    "Mutex",            ID_MUTEX,        NO, 0, OP_MUTEX,      "NB",   "NB",     "x",      0,  NULL,
    "OperationRegion",  ID_OPREGION,     NO, 0x80ff00ff,OP_OPREGION,"NECC","NECC","oDUU",  AF, OpRegion,
    "PowerResource",    ID_POWERRES,     NO, 0, OP_POWERRES,   "NBW",  "NBW",    "p",      OL|LN|CC, NULL,
    "Processor",        ID_PROCESSOR,    NO, 0, OP_PROCESSOR,  "NBDB", "NBDB",   "c",      OL|LN|CC, NULL,
    "ThermalZone",      ID_THERMALZONE,  NO, 0, OP_THERMALZONE,"N",    "N",      "t",      OL|LN|CC, NULL,

    // Type 1 Opcode Terms
    "Break",            ID_BREAK,        C1, 0, OP_BREAK,       NULL,  NULL,  NULL, 0, NULL,
    "BreakPoint",       ID_BREAKPOINT,   C1, 0, OP_BREAKPOINT,  NULL,  NULL,  NULL, 0, NULL,
    "Else",             ID_ELSE,         C1, 0, OP_ELSE,        NULL,  NULL,  NULL, AF|CL|OL|LN, Else,
    "Fatal",            ID_FATAL,        C1, 0, OP_FATAL,       "BDC", "BDC", "  U",0, NULL,
    "If",               ID_IF,           C1, 0, OP_IF,          "C",   "C",   "U",  CL|OL|LN, NULL,
    "Load",             ID_LOAD,         C1, 0, OP_LOAD,        "NS",  "NS",  "UU", 0, NULL,
    "Noop",             ID_NOP,          C1, 0, OP_NOP,         NULL,  NULL,  NULL, 0, NULL,
    "Notify",           ID_NOTIFY,       C1, 0, OP_NOTIFY,      "SC",  "SC",  "UU", 0, NULL,
    "Release",          ID_RELEASE,      C1, 0, OP_RELEASE,     "S",   "S",   "X",  0, NULL,
    "Reset",            ID_RESET,        C1, 0, OP_RESET,       "S",   "S",   "E",  0, NULL,
    "Return",           ID_RETURN,       C1, 0, OP_RETURN,      "C",   "C",   "U",  0, NULL,
    "Signal",           ID_SIGNAL,       C1, 0, OP_SIGNAL,      "S",   "S",   "E",  0, NULL,
    "Sleep",            ID_SLEEP,        C1, 0, OP_SLEEP,       "C",   "C",   "U",  0, NULL,
    "Stall",            ID_STALL,        C1, 0, OP_STALL,       "C",   "C",   "U",  0, NULL,
    "Unload",           ID_UNLOAD,       C1, 0, OP_UNLOAD,      "S",   "S",   "U",  0, NULL,
    "While",            ID_WHILE,        C1, 0, OP_WHILE,       "C",   "C",   "U",  CL|OL|LN, NULL,

    // Type 2 Opcode Terms
    "Acquire",          ID_ACQUIRE,      C2, 0, OP_ACQUIRE,     "SW",     "SW",     "X",  0, NULL,
    "Add",              ID_ADD,          C2, 0, OP_ADD,         "CCS",    "CCs",    "UUU",0, NULL,
    "And",              ID_AND,          C2, 0, OP_AND,         "CCS",    "CCs",    "UUU",0, NULL,
    "Concatenate",      ID_CONCAT,       C2, 0, OP_CONCAT,      "CCS",    "CCS",    "UUU",0, NULL,
    "CondRefOf",        ID_CONDREFOF,    C2, 0, OP_CONDREFOF,   "SS",     "SS",     "UU", 0, NULL,
    "Decrement",        ID_DECREMENT,    C2, 0, OP_DECREMENT,   "S",      "S",      "U",  0, NULL,
    "DerefOf",		ID_DEREFOF,	 C2, 0, OP_DEREFOF,	"C",      "C",	    "U",  0, NULL,
    "Divide",           ID_DIVIDE,       C2, 0, OP_DIVIDE,      "CCSS",   "CCss",   "UUUU",0,NULL,
    "FindSetLeftBit",   ID_FINDSETLBIT,  C2, 0, OP_FINDSETLBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FindSetRightBit",  ID_FINDSETRBIT,  C2, 0, OP_FINDSETRBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FromBCD",          ID_FROMBCD,      C2, 0, OP_FROMBCD,     "CS",     "Cs",     "UU", 0, NULL,
    "Increment",        ID_INCREMENT,    C2, 0, OP_INCREMENT,   "S",      "S",      "U",  0, NULL,
    "Index",            ID_INDEX,     RO|C2, 0, OP_INDEX,       "CCS",    "CMs",    "UUU",0, NULL,
    "LAnd",             ID_LAND,         C2, 0, OP_LAND,        "CC",     "CC",     "UU", 0, NULL,
    "LEqual",           ID_LEQ,          C2, 0, OP_LEQ,         "CC",     "CC",     "UU", 0, NULL,
    "LGreater",         ID_LG,           C2, 0, OP_LG,          "CC",     "CC",     "UU", 0, NULL,
    "LGreaterEqual",    ID_LGEQ,         C2, 0, OP_LGEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LLess",            ID_LL,           C2, 0, OP_LL,          "CC",     "CC",     "UU", 0, NULL,
    "LLessEqual",       ID_LLEQ,         C2, 0, OP_LLEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LNot",             ID_LNOT,         C2, 0, OP_LNOT,        "C",      "C",      "U",  0, NULL,
    "LNotEqual",        ID_LNOTEQ,       C2, 0, OP_LNOTEQ,      "CC",     "CC",     "UU", 0, NULL,
    "LOr",              ID_LOR,          C2, 0, OP_LOR,         "CC",     "CC",     "UU", 0, NULL,
    "Match",            ID_MATCH,        C2, 0, OP_MATCH,       "CKCKCC", "CKCKCC", "UFUFUU",AF,Match,
    "Multiply",         ID_MULTIPLY,     C2, 0, OP_MULTIPLY,    "CCS",    "CCs",    "UUU",0, NULL,
    "NAnd",             ID_NAND,         C2, 0, OP_NAND,        "CCS",    "CCs",    "UUU",0, NULL,
    "NOr",              ID_NOR,          C2, 0, OP_NOR,         "CCS",    "CCs",    "UUU",0, NULL,
    "Not",              ID_NOT,          C2, 0, OP_NOT,         "CS",     "Cs",     "UU", 0, NULL,
    "ObjectType",       ID_OBJTYPE,      C2, 0, OP_OBJTYPE,     "S",      "S",      "U",  0, NULL,
    "Or",               ID_OR,           C2, 0, OP_OR,          "CCS",    "CCs",    "UUU",0, NULL,
    "RefOf",            ID_REFOF,        C2, 0, OP_REFOF,       "S",      "S",      "U",  0, NULL,
    "ShiftLeft",        ID_SHIFTL,       C2, 0, OP_SHIFTL,      "CCS",    "CCs",    "UUU",0, NULL,
    "ShiftRight",       ID_SHIFTR,       C2, 0, OP_SHIFTR,      "CCS",    "CCs",    "UUU",0, NULL,
    "SizeOf",           ID_SIZEOF,       C2, 0, OP_SIZEOF,      "S",      "S",      "U",  0, NULL,
    "Store",            ID_STORE,        C2, 0, OP_STORE,       "CS",     "CS",     "UU", 0, NULL,
    "Subtract",         ID_SUBTRACT,     C2, 0, OP_SUBTRACT,    "CCS",    "CCs",    "UUU",0, NULL,
    "ToBCD",            ID_TOBCD,        C2, 0, OP_TOBCD,       "CS",     "Cs",     "UU", 0, NULL,
    "Wait",             ID_WAIT,         C2, 0, OP_WAIT,        "SC",     "SC",     "E",  0, NULL,
    "XOr",              ID_XOR,          C2, 0, OP_XOR,         "CCS",    "CCs",    "UUU",0, NULL,

    // PNP Macros
    "ResourceTemplate", ID_RESTEMP,      DO, 0, OP_BUFFER, NULL, "",       NULL, ML|AF|AV|LN,ResourceTemplate,
    "StartDependentFnNoPri",ID_STARTDEPFNNOPRI,PM,0,0x30,  NULL, "",       NULL, ML|AF,   AddSmallOffset,
    "StartDependentFn", ID_STARTDEPFN,   PM, 0, 0x31,      NULL, "BB",     NULL, ML|AF,   StartDependentFn,
    "EndDependentFn",   ID_ENDDEPFN,     PM, 0, 0x38,      NULL, "",       NULL, AF,      AddSmallOffset,
    "IRQNoFlags",       ID_IRQNOFLAGS,   PM, 0, 0x22,      NULL, "r",      NULL, BL|AV,   IRQDesc,
    "IRQ",              ID_IRQ,          PM, 0, 0x23,      NULL, "KKkr",   "GHI",BL|AV,   IRQDesc,
    "DMA",              ID_DMA,          PM, 0, 0x2a,      NULL, "KKKr",   "JKL",BL|AV,   DMADesc,
    "IO",               ID_IO,           PM, 0, 0x47,      NULL, "KWWBBr", "M",  AF,      IODesc,
    "FixedIO",          ID_FIXEDIO,      PM, 0, 0x4b,      NULL, "WBr",    NULL, AF,      FixedIODesc,
    "VendorShort",      ID_VENDORSHORT,  PM, 0, OP_NONE,   NULL, "r",      NULL, BL|AV,   VendorShort,
    "Memory24",         ID_MEMORY24,     PM, 0, 0x81,      NULL, "KWWWWr", "N",  AF,      Memory24Desc,
    "VendorLong",       ID_VENDORLONG,   PM, 0, 0x84,      NULL, "r",      NULL, BL|AV,   VendorLong,
    "Memory32",         ID_MEMORY32,     PM, 0, 0x85,      NULL, "KDDDDr", "N",  AF,      Memory32Desc,
    "Memory32Fixed",    ID_MEMORY32FIXED,PM, 0, 0x86,      NULL, "KDDr",   "N",  AF,      FixedMemory32Desc,
    "DWORDMemory",      ID_DWORDMEMORY,  PM, 0, 0x87,      NULL, "kkkkkKDDDDDbzr","OPQRSN",AF,  DWordMemDesc,
    "DWORDIO",          ID_DWORDIO,      PM, 0, 0x87,      NULL, "kkkkkDDDDDbzr", "OQRPT", AF,  DWordIODesc,
    "WORDIO",           ID_WORDIO,       PM, 0, 0x88,      NULL, "kkkkkWWWWWbzr", "OQRPT", AF,  WordIODesc,
    "WORDBusNumber",    ID_WORDBUSNUMBER,PM, 0, 0x88,      NULL, "kkkkWWWWWbzr",  "OQRP",  AF,  WordBusNumDesc,
    "Interrupt",        ID_INTERRUPT,    PM, 0, 0x89,      NULL, "kKKkbzr",       "OGHI",DD|AV, InterruptDesc,
    "QWORDMemory",	ID_QWORDMEMORY,	 PM, 0, 0x8a,      NULL, "kkkkkKQQQQQbzr","OPQRSN",AF,  QWordMemDesc,
    "QWORDIO",		ID_QWORDIO,	 PM, 0, 0x8a,	   NULL, "kkkkkQQQQQbzr", "OQRPT", AF,  QWordIODesc,

    NULL,               0,               0,  0, OP_NONE,   NULL, NULL, NULL, 0, NULL
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

BYTE OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\scanasl.h ===
/*** scanasl.h - Definitions for scanasl.c
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the scan.c module.
 *
 *  MODIFICATIONS
 */

/***    Constants
 */

// Return values of Token functions
//   return value is the token type if it is positive
//   return value is the error number if it is negative

// Error values (negative)
#define TOKERR_TOKEN_TOO_LONG   (TOKERR_LANG - 1)
#define TOKERR_UNCLOSED_STRING  (TOKERR_LANG - 2)
#define TOKERR_UNCLOSED_CHAR    (TOKERR_LANG - 3)
#define TOKERR_UNCLOSED_COMMENT (TOKERR_LANG - 4)
#define TOKERR_SYNTAX           (TOKERR_LANG - 5)

// Token types (positive)
#define TOKTYPE_ID              (TOKTYPE_LANG + 1)
#define TOKTYPE_STRING          (TOKTYPE_LANG + 2)
#define TOKTYPE_CHAR            (TOKTYPE_LANG + 3)
#define TOKTYPE_NUMBER          (TOKTYPE_LANG + 4)
#define TOKTYPE_SYMBOL          (TOKTYPE_LANG + 5)
#define TOKTYPE_SPACE           (TOKTYPE_LANG + 6)

#define TOKID(i)                TermTable[i].lID

// Identifier token values
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_QWORDACC             (ID_LANG + 404)
#define ID_BUFFERACC            (ID_LANG + 405)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)
#define ID_CMOSCFG              (ID_LANG + 480)
#define ID_SMBQUICK             (ID_LANG + 481)
#define ID_SMBSENDRECEIVE       (ID_LANG + 482)
#define ID_SMBBYTE              (ID_LANG + 483)
#define ID_SMBWORD              (ID_LANG + 484)
#define ID_SMBBLOCK             (ID_LANG + 485)
#define ID_SMBPROCESSCALL       (ID_LANG + 486)
#define ID_SMBBLOCKPROCESSCALL  (ID_LANG + 487)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

// Symbol token values
#define SYM_ANY                 0
#define SYM_LBRACE              1       // {
#define SYM_RBRACE              2       // }
#define SYM_LPARAN              3       // (
#define SYM_RPARAN              4       // )
#define SYM_COMMA               5       // ,
#define SYM_SLASH               6       // /
#define SYM_ASTERISK            7       // *
#define SYM_INLINECOMMENT       8       // //
#define SYM_OPENCOMMENT         9       // SLASH-STAR
#define SYM_CLOSECOMMENT        10      // STAR-SLASH

#define CH_ROOT_PREFIX          '\\'
#define CH_PARENT_PREFIX        '^'
#define CH_NAMESEG_SEP          '.'

/***    Exported function prototypes
 */

PTOKEN EXPORT OpenScan(FILE *pfileSrc);
VOID EXPORT CloseScan(PTOKEN ptoken);
VOID EXPORT PrintScanErr(PTOKEN ptoken, int rcErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\token.h ===
/*** token.h - Token definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/04/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the token.c module.
 *
 *  MODIFICATIONS
 */

#ifndef _TOKEN_H
#define _TOKEN_H

/*** Constants
 */

// GetToken return values
//   return value is the token type if it is positive
//   return value is the error number if it is negative

// Error values (negative)
#define TOKERR_NONE             0
#define TOKERR_EOF              (TOKERR_BASE - 0)
#define TOKERR_NO_MATCH         (TOKERR_BASE - 1)
#define TOKERR_ASSERT_FAILED    (TOKERR_BASE - 2)

// TOKERR_LANG must always be the last TOKERR from the above list
#define TOKERR_LANG             TOKERR_ASSERT_FAILED

// Token type
#define TOKTYPE_NULL            0

#define TOKTYPE_LANG            TOKTYPE_NULL

// Identifier token types
#define ID_USER                 -1      //user identifier

#define ID_LANG                 0       //language specific ID base

//Token flags values
#define TOKF_NOIGNORESPACE      0x0001
#define TOKF_CACHED             0x8000

//Match token flags
#define MTF_NOT_ERR             0x00000001
#define MTF_ANY_VALUE           0x00000002

/***    Exported data types
 */

#define MAX_TOKEN_LEN           255

typedef struct token_s TOKEN;
typedef TOKEN *PTOKEN;
typedef int (LOCAL *PFNTOKEN)(int, PTOKEN);

struct token_s
{
    PLINE       pline;
    PFNTOKEN    *papfnToken;
    WORD        wfToken;
    int         iTokenType;
    LONGLONG    llTokenValue;
    WORD        wTokenLine;
    WORD        wTokenPos;
    WORD        wErrLine;
    WORD        wErrPos;
    WORD        wTokenLen;
    char        szToken[MAX_TOKEN_LEN + 1];
  #ifdef TUNE
    WORD        *pawcTokenType;
  #endif
};

/***    Imported data types
 */

/***    Exported function prototypes
 */

#ifdef TUNE
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken,
                        WORD *pawcTokenType);
#else
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken);
#endif
VOID EXPORT CloseToken(PTOKEN ptoken);
int EXPORT GetToken(PTOKEN ptoken);
int EXPORT UnGetToken(PTOKEN ptoken);
int EXPORT MatchToken(PTOKEN ptoken, int iTokenType, LONG lTokenValue,
                      DWORD dwfMatch, PSZ pszErrMsg);
VOID EXPORT PrintTokenErr(PTOKEN ptoken, PSZ pszErrMsg, BOOL fErr);

#endif  //ifndef _TOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\uasmdata.h ===
/*** uasmdata.h - Unassembler Data Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UASMDATA_H
#define _UASMDATA_H

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// Term classes
#define TC_PNP_MACRO            0x00100000
#define TC_REF_OBJECT           0x00200000
#define TC_FIELD_MACRO          0x00400000
#define TC_DATA_OBJECT          0x00800000
#define TC_NAMED_OBJECT         0x01000000
#define TC_NAMESPACE_MODIFIER   0x02000000
#define TC_OPCODE_TYPE1         0x04000000
#define TC_OPCODE_TYPE2         0x08000000
#define TC_CONST_NAME           0x10000000
#define TC_SHORT_NAME           0x20000000
#define TC_COMPILER_DIRECTIVE   0x40000000
#define TC_KEYWORD              0x80000000
#define TC_OPCODE               (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | TC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          TC_FIELD_MACRO
#define TF_DATA_OBJECT          TC_DATA_OBJECT
#define TF_NAMED_OBJECT         TC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   TC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         TC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         TC_OPCODE_TYPE2
#define TF_CONST_NAME           TC_CONST_NAME
#define TF_SHORT_NAME           TC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   TC_COMPILER_DIRECTIVE
#define TF_KEYWORD              TC_KEYWORD
#define TF_PNP_MACRO            TC_PNP_MACRO
#define TF_OBJECT_LIST          (TC_NAMED_OBJECT | TC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (TC_DATA_OBJECT | TC_SHORT_NAME | \
                                 TC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Object types
#define OBJTYPE_PRIVATE         0xf0
#define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
#define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)
#define OBJTYPE_EXTERNAL        (OBJTYPE_PRIVATE + 0x02)

// Identifier token values
#define ID_LANG                 0
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_QWORDACC             (ID_LANG + 404)
#define ID_BUFFERACC            (ID_LANG + 405)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)
#define ID_CMOSCFG              (ID_LANG + 480)
#define ID_SMBQUICK             (ID_LANG + 481)
#define ID_SMBSENDRECEIVE       (ID_LANG + 482)
#define ID_SMBBYTE              (ID_LANG + 483)
#define ID_SMBWORD              (ID_LANG + 484)
#define ID_SMBBLOCK             (ID_LANG + 485)
#define ID_SMBPROCESSCALL       (ID_LANG + 486)
#define ID_SMBBLOCKPROCESSCALL  (ID_LANG + 487)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

//
// Type definitions
//
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    LONG    lID;
    DWORD   dwfTermClass;
    DWORD   dwTermData;
    DWORD   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgTypes;
    PSZ     pszArgActions;
    DWORD   dwfTerm;
    PFNTERM pfnTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    BYTE    bExOp;
    BYTE    bOpClass;
} OPMAP, *POPMAP;

//
// Imported data
//
extern PBYTE   gpbOpTop;
extern PBYTE   gpbOpBegin;
extern ASLTERM TermTable[];
extern BYTE    OpClassTable[];
extern OPMAP   ExOpClassTable[];

#endif  //ifndef _UASMDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\token.c ===
/*** token.c - functions dealing with token stream
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    08/05/96
 *
 *  This module implements a general purpose scanner.  The
 *  implementation is language independent.  It is a pseudo
 *  table driven scanner which uses a table to determine
 *  the token type by its first character and calls the
 *  appropriate routine to scan the rest of the token
 *  characters.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  OpenToken - token stream initialization
 *
 *  ENTRY
 *      pfileSrc -> source file
 *      apfnToken -> table of token parsing functions
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated token structure.
 *  EXIT-FAILURE
 *      returns NULL.
 */

#ifdef TUNE
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken,
                        WORD *pawcTokenType)
#else
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken)
#endif
{
    PTOKEN ptoken = NULL;

    ENTER((3, "OpenToken(pfileSrc=%p,apfnToken=%p)\n", pfileSrc, apfnToken));

    if ((ptoken = (PTOKEN)malloc(sizeof(TOKEN))) == NULL)
        MSG(("OpenToken: failed to allocate token structure"))
    else
    {
        memset(ptoken, 0, sizeof(TOKEN));
        if ((ptoken->pline = OpenLine(pfileSrc)) == NULL)
        {
            free(ptoken);
            ptoken = NULL;
        }
        else
        {
            ptoken->papfnToken = apfnToken;
          #ifdef TUNE
            ptoken->pawcTokenType = pawcTokenType;
          #endif
        }
    }

    EXIT((3, "OpenToken=%p\n", ptoken));
    return ptoken;
}       //OpenToken

/***EP  CloseToken - free token structure
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT CloseToken(PTOKEN ptoken)
{
    ENTER((3, "CloseToken(ptoken=%p)\n", ptoken));

    CloseLine(ptoken->pline);
    free(ptoken);

    EXIT((3, "CloseToken!\n"));
}       //CloseToken

/***EP  GetToken - get a token from a line buffer
 *
 *  This procedure scans the line buffer and returns a token.
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns error code - TOKERR_*
 */

int EXPORT GetToken(PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((3, "GetToken(ptoken=%p)\n", ptoken));

    if (ptoken->wfToken & TOKF_CACHED)
    {
        ptoken->wfToken &= ~TOKF_CACHED;
        rc = TOKERR_NONE;
    }
    else
    {
        int c, i;

        do
        {
            if ((c = LineGetC(ptoken->pline)) == EOF)
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_EOF;
                break;
            }

            ptoken->wTokenPos = (WORD)(ptoken->pline->wLinePos - 1);
            ptoken->wTokenLine = ptoken->pline->wLineNum;
            ptoken->iTokenType = TOKTYPE_NULL;
            ptoken->llTokenValue = 0;
            ptoken->wTokenLen = 0;

            ptoken->szToken[ptoken->wTokenLen++] = (char)c;

            for (i = 0; ptoken->papfnToken[i]; i++)
            {
                if ((rc = (*ptoken->papfnToken[i])(c, ptoken)) ==
                    TOKERR_NO_MATCH)
                {
                    continue;
                }
                else
                {
                  #ifdef TUNE
                    if (rc == TOKERR_NONE)
                        ptoken->pawcTokenType[i]++;
                  #endif
                    break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
            {
                ptoken->szToken[ptoken->wTokenLen] = '\0';
                ptoken->wErrLine = ptoken->pline->wLineNum;
                if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                    ptoken->wErrPos--;
                PrintTokenErr(ptoken, "unrecognized token", TRUE);
            }
            else if (rc != TOKERR_NONE)
            {
                PrintScanErr(ptoken, rc);
            }
        } while ((rc == TOKERR_NONE) && (ptoken->iTokenType == TOKTYPE_NULL));
    }

    EXIT((3, "GetToken=%d (Type=%d,Value=%I64d,Token=%s,TokenLine=%d,TokenPos=%d)\n",
          rc, ptoken->iTokenType, ptoken->llTokenValue,
          ptoken->szToken, ptoken->wTokenLine, ptoken->wTokenPos));
    return rc;
}       //GetToken

/***EP  UnGetToken - push a token back to the token stream
 *
 *  This procedure unget the last token.
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns error code - TOKERR_*
 */

int EXPORT UnGetToken(PTOKEN ptoken)
{
    int rc;

    ENTER((3, "UnGetToken(ptoken=%p)\n", ptoken));

    if (!(ptoken->wfToken & TOKF_CACHED))
    {
        ptoken->wfToken |= TOKF_CACHED;
        rc = TOKERR_NONE;
    }
    else
    {
        ASSERT(ptoken->wfToken & TOKF_CACHED);
        rc = TOKERR_ASSERT_FAILED;
    }

    EXIT((3, "UnGetToken=%d\n", rc));
    return rc;
}       //UnGetToken

/***EP  MatchToken - Match the next token type
 *
 *  ENTRY
 *      ptoken -> token structure
 *      iTokenType - token type to match
 *      lTokenValue - token value to match
 *      dwfMatch - match flags
 *      pszErrMsg -> error message to print if not matched
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int EXPORT MatchToken(PTOKEN ptoken, int iTokenType, LONG lTokenValue,
                      DWORD dwfMatch, PSZ pszErrMsg)
{
    int rc;

    ENTER((3, "MatchToken(ptoken=%p,TokType=%d,TokValue=%ld,dwfMatch=%lx,ErrMsg=%s)\n",
           ptoken, iTokenType, lTokenValue, dwfMatch,
           pszErrMsg? pszErrMsg: "<none>"));

    if (((rc = GetToken(ptoken)) == TOKERR_NONE) &&
        ((ptoken->iTokenType != iTokenType) ||
         !(dwfMatch & MTF_ANY_VALUE) &&
         ((LONG)ptoken->llTokenValue != lTokenValue)))
    {
        if (dwfMatch & MTF_NOT_ERR)
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else
        {
            rc = TOKERR_SYNTAX;
        }
    }

    if ((rc != TOKERR_NONE) && !(dwfMatch & MTF_NOT_ERR))
    {
        char szMsg[MAX_MSG_LEN + 1];

        if (pszErrMsg == NULL)
        {
            sprintf(szMsg, "expecting %s",
                    gapszTokenType[iTokenType - TOKTYPE_LANG - 1]);

            if (!(dwfMatch & MTF_ANY_VALUE) && (iTokenType == TOKTYPE_SYMBOL))
            {
                sprintf(&szMsg[strlen(szMsg)], " '%c'",
                        SymCharTable[lTokenValue - 1]);
            }
            pszErrMsg = szMsg;
        }

        PrintTokenErr(ptoken, pszErrMsg, TRUE);

        if (rc == TOKERR_EOF)
        {
            rc = TOKERR_SYNTAX;
        }
    }

    EXIT((3, "MatchToken=%d (Type=%d,Value=%I64d,Token=%s)\n",
          rc, ptoken->iTokenType, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //MatchToken

/***EP  PrintTokenErr - print token error line
 *
 *  ENTRY
 *      ptoken -> token structure
 *      pszErrMsg -> error message string
 *      fErr - TRUE if it is an error, FALSE if warning
 *
 *  EXIT
 *      None
 */

VOID EXPORT PrintTokenErr(PTOKEN ptoken, PSZ pszErrMsg, BOOL fErr)
{
    WORD i;

    ENTER((3, "PrintTokenErr(ptoken=%p,Line=%d,Pos=%d,Msg=%s)\n",
           ptoken, ptoken->wTokenLine, ptoken->wTokenPos, pszErrMsg));

    ErrPrintf("\n%5u: %s",
              ptoken->wTokenLine, ptoken->pline->szLineBuff);

    ErrPrintf("       ");
    for (i = 0; i < ptoken->wTokenPos; ++i)
    {
        if (ptoken->pline->szLineBuff[i] == '\t')
        {
            ErrPrintf("\t");
        }
        else
        {
            ErrPrintf(" ");
        }
    }
    ErrPrintf("^***\n");

    if (pszErrMsg != NULL)
    {
        ErrPrintf("%s(%d): %s: %s\n",
                  gpszASLFile, ptoken->wTokenLine, fErr? "error": "warning",
                  pszErrMsg);
    }

    EXIT((3, "PrintTokenErr!\n"));
}       //PrintTokenErr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\vxd.c ===
/*** vxd.c - ACPITAB.VXD related functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/09/97
 *
 *  MODIFICATION HISTORY
 */

#ifdef ___UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
#define _X86_
#include <windef.h>
#include <winbase.h>
#define EXCL_BASEDEF
#include "aslp.h"
#include "..\acpitab\acpitab.h"

/***LP  OpenVxD - Open ACPITAB.VXD
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns VxD handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HANDLE LOCAL OpenVxD(VOID)
{
    HANDLE hVxD;
    DWORD dwVersion;

    ENTER((2, "OpenVxD()\n"));

    if ((hVxD = CreateFile(ACPITAB_VXD_NAME, 0, 0, NULL, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL)) ==
        INVALID_HANDLE_VALUE)
    {
        hVxD = NULL;
    }
    else if (!DeviceIoControl(hVxD, ACPITAB_DIOC_GETVERSION, NULL, 0,
                              &dwVersion, sizeof(dwVersion), NULL, NULL) ||
             (dwVersion != (ACPITAB_MAJOR_VER << 8) | ACPITAB_MINOR_VER))
    {
        ERROR(("OpenVxD: version error"));
        CloseVxD(hVxD);
        hVxD = NULL;
    }

    EXIT((2, "OpenVxD=%x\n", hVxD));
    return hVxD;
}       //OpenVxD

/***LP  CloseVxD - Close the VxD
 *
 *  ENTRY
 *      hVxD - VxD handle
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseVxD(HANDLE hVxD)
{
    ENTER((2, "CloseVxD(hVxD=%x)\n", hVxD));

    CloseHandle(hVxD);

    EXIT((2, "CloseVxD!\n"));
}       //CloseVxD

/***LP  GetTable - Get table
 *
 *  ENTRY
 *      hVxD - VxD handle
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTable(HANDLE hVxD, DWORD dwTabSig)
{
    PBYTE pb = NULL;
    TABINFO TabInfo;

    ENTER((2, "GetTable(hVxD=%x,TabSig=%x)\n", hVxD, dwTabSig));

    TabInfo.dwTabSig = dwTabSig;
    if (DeviceIoControl(hVxD, ACPITAB_DIOC_GETTABINFO, NULL, 0, &TabInfo,
                         sizeof(TabInfo), NULL, NULL))
    {
        if ((pb = MEMALLOC(TabInfo.dh.Length)) != NULL)
        {
            if (DeviceIoControl(hVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)TabInfo.dwPhyAddr, 0, pb,
                                TabInfo.dh.Length, NULL, NULL) == 0)
            {
                ERROR(("GetTable: failed to get table. (rc=%x)",
                       GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
        }
        else
        {
            ERROR(("GetTable: failed to allocate table buffer"));
        }
    }
    else
    {
        ERROR(("GetTable: failed to get table info. (rc=%x)", GetLastError()));
    }

    EXIT((2, "GetTable=%x\n", pb));
    return pb;
}       //GetTable

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\unasm.c ===
/*** unasm.c - Unassemble AML file and convert to Intel .ASM file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

//
// Local data
//
int giLevel = 0;

/***LP  UnAsmFile - Unassemble AML file
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFile(PSZ pszAMLName, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    PBYTE pb = NULL;
    DWORD dwAddr = 0;
    int fhAML = 0;
    ULONG dwLen = 0;

    ENTER((1, "UnAsmFile(AMLName=%s,pfnPrint=%p,pv=%p)\n",
           pszAMLName, pfnPrint, pv));
    ASSERT(pfnPrint != NULL);

    if (gpszAMLFile != NULL)
    {
        if ((fhAML = _open(gpszAMLFile, _O_BINARY | _O_RDONLY)) == -1)
        {
            ERROR(("UnAsmFile: failed to open AML file - %s", gpszAMLFile));
            rc = ASLERR_OPEN_FILE;
        }
        else if ((pb = MEMALLOC(sizeof(DESCRIPTION_HEADER))) == NULL)
        {
            ERROR(("UnAsmFile: failed to allocate description header block"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (_read(fhAML, pb, sizeof(DESCRIPTION_HEADER)) !=
                 sizeof(DESCRIPTION_HEADER))
        {
            ERROR(("UnAsmFile: failed to read description header block"));
            rc = ASLERR_READ_FILE;
        }
        else if (_lseek(fhAML, 0, SEEK_SET) == -1)
        {
            ERROR(("UnAsmFile: failed seeking to beginning of AML file"));
            rc = ASLERR_SEEK_FILE;
        }
        else
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
            MEMFREE(pb);
            if ((pb = MEMALLOC(dwLen)) == NULL)
            {
                ERROR(("UnAsmFile: failed to allocate AML file buffer"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else if (_read(fhAML, pb, dwLen) != (int)dwLen)
            {
                ERROR(("UnAsmFile: failed to read AML file"));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }
  #ifdef __UNASM
    else
    {
        DWORD dwTableSig = (gdwfASL & ASLF_DUMP_NONASL)? *((PDWORD)pszAMLName):
                                                         *((PDWORD)gpszTabSig);

        ASSERT(gpszTabSig != NULL);

        if ((pb = GetTableBySig(dwTableSig, &dwAddr)) != NULL)
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
        }
        else
        {
            rc = ASLERR_GET_TABLE;
        }
    }
  #endif

    if (rc == ASLERR_NONE)
    {
        rc = UnAsmAML(pszAMLName, dwAddr, pb, pfnPrint, pv);
    }

    if (pb != NULL)
    {
        MEMFREE(pb);
    }

    if (fhAML != 0)
    {
        _close(fhAML);
    }

    EXIT((1, "UnAsmFile=%d\n", rc));
    return rc;
}       //UnAsmFile

/***LP  BuildNameSpace - Do a NameSpace building pass
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb)
{
    typedef struct _AMLName
    {
        struct _AMLName *panNext;
        PSZ              pszAMLName;
        DWORD            dwAddr;
    } AMLNAME, *PAMLNAME;
    int rc = ASLERR_NONE;
    static PAMLNAME panAMLNames = NULL;
    PAMLNAME pan;

    ENTER((2, "BuildNameSpace(AMLName=%s,Addr=%x,pb=%p)\n",
           pszAMLName, dwAddr, pb));

    for (pan = panAMLNames; pan != NULL; pan = pan->panNext)
    {
        if ((strcmp(pszAMLName, pan->pszAMLName) == 0) &&
            (dwAddr == pan->dwAddr))
        {
            break;
        }
    }

    if (pan == NULL)
    {
        if ((pan = MEMALLOC(sizeof(AMLNAME))) != NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pb)->Length;

            pan->pszAMLName = pszAMLName;
            pan->dwAddr = dwAddr;
            pan->panNext = panAMLNames;
            panAMLNames = pan;
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + dwLen - sizeof(DESCRIPTION_HEADER), NULL,
                            NULL);
        }
        else
        {
            ERROR(("BuildNameSpace: failed to allocate AMLName entry"));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((2, "BuildNameSpace=%d\n", rc));
    return rc;
}       //BuildNameSpace

/***LP  UnAsmAML - Unassemble AML buffer
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, PFNPRINT pfnPrint,
                   PVOID pv)
{
    int rc = ASLERR_NONE;
    PDESCRIPTION_HEADER pdh = (PDESCRIPTION_HEADER)pb;

    ENTER((2, "UnAsmAML(AMLName=%s,Addr=%x,pb=%p,pfnPrint=%p,pv=%p)\n",
           pszAMLName, dwAddr, pb, pfnPrint, pv));

    ASSERT(gpnsNameSpaceRoot != NULL);
    gpnsCurrentOwner = NULL;
    gpnsCurrentScope = gpnsNameSpaceRoot;

    if (ComputeDataChkSum(pb, pdh->Length) != 0)
    {
        ERROR(("UnAsmAML: failed to verify AML checksum"));
        rc = ASLERR_CHECKSUM;
    }
    else if ((rc = BuildNameSpace(pszAMLName, dwAddr, pb)) == ASLERR_NONE)
    {
        gpbOpTop = gpbOpBegin = pb;
        if ((rc = UnAsmHeader(pszAMLName, pdh, pfnPrint, pv)) == ASLERR_NONE)
        {
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + pdh->Length - sizeof(DESCRIPTION_HEADER),
                            pfnPrint, pv);

            if ((rc == ASLERR_NONE) && (pfnPrint != NULL))
            {
                pfnPrint(pv, "\n");
            }
        }
    }

    EXIT((2, "UnAsmAML=%d\n", rc));
    return rc;
}       //UnAsmAML

/***LP  UnAsmHeader - Unassemble table header
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pdh -> DESCRIPTION_HEADER
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh,
                      PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    char szSig[sizeof(pdh->Signature) + 1] = {0};
    char szOEMID[sizeof(pdh->OEMID) + 1] = {0};
    char szOEMTableID[sizeof(pdh->OEMTableID) + 1] = {0};
    char szCreatorID[sizeof(pdh->CreatorID) + 1] = {0};

    ENTER((2, "UnAsmHeader(AMLName=%s,pdh=%p,pfnPrint=%p,pv=%p)\n",
           pszAMLName, pdh, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        strncpy(szSig, (PSZ)&pdh->Signature, sizeof(pdh->Signature));
        strncpy(szOEMID, (PSZ)pdh->OEMID, sizeof(pdh->OEMID));
        strncpy(szOEMTableID, (PSZ)pdh->OEMTableID, sizeof(pdh->OEMTableID));
        strncpy(szCreatorID, (PSZ)pdh->CreatorID, sizeof(pdh->CreatorID));

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "// CreatorID=%s\tCreatorRev=%x.%x.%d\n",
                 szCreatorID, pdh->CreatorRev >> 24,
                 (pdh->CreatorRev >> 16) & 0xff, pdh->CreatorRev & 0xffff);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "// FileLength=%d\tFileChkSum=0x%x\n\n",
                 pdh->Length, pdh->Checksum);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "DefinitionBlock(\"%s\", \"%s\", 0x%02x, \"%s\", \"%s\", 0x%08x)",
                 pszAMLName, szSig, pdh->Revision, szOEMID, szOEMTableID,
                 pdh->OEMRevision);
    }

    EXIT((2, "UnAsmHeader=%d\n", rc));
    return rc;
}       //UnAsmHeader

/***LP  DumpBytes - Dump byte stream in ASM file
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length to dump
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, PFNPRINT pfnPrint, PVOID pv)
{
    int i;
    #define MAX_LINE_BYTES  8

    ENTER((2, "DumpBytes(pb=%p,Len=%x,pfnPrint=%p,pv=%p)\n",
           pb, dwLen, pfnPrint, pv));

    while (dwLen > 0)
    {
        pfnPrint(pv, "\tdb\t0%02xh", *pb);
        for (i = 1; i < MAX_LINE_BYTES; ++i)
        {
            if ((int)dwLen - i > 0)
            {
                pfnPrint(pv, ", 0%02xh", pb[i]);
            }
            else
            {
                pfnPrint(pv, "      ");
            }
        }

        pfnPrint(pv, "\t; ");
        for (i = 0; (dwLen > 0) && (i < MAX_LINE_BYTES); ++i)
        {
            pfnPrint(pv, "%c", ((*pb >= ' ') && (*pb <= '~'))? *pb: '.');
            dwLen--;
            pb++;
        }

        pfnPrint(pv, "\n");
    }
    pfnPrint(pv, "\n");

    EXIT((2, "DumpBytes!\n"));
}       //DumpBytes

/***LP  DumpCode - Dump code stream in ASM file
 *
 *  ENTRY
 *      pbOp -> Opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpCode(PBYTE pbOp, PFNPRINT pfnPrint, PVOID pv)
{
    ENTER((2, "DumpCode(pbOp=%p,pfnPrint=%p,pv=%p)\n", pbOp, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        if (gdwfASL & ASLF_GENASM)
        {
            if (gpbOpBegin != pbOp)
            {
                pfnPrint(pv, "\n");
                pfnPrint(pv, "; %08x:\n", gpbOpBegin - gpbOpTop);
                DumpBytes(gpbOpBegin, (DWORD)(pbOp - gpbOpBegin), pfnPrint, pv);
                gpbOpBegin = pbOp;
            }
        }
        else
        {
            pfnPrint(pv, "\n");
        }
    }

    EXIT((2, "DumpCode!\n"));
}       //DumpCode

/***LP  PrintIndent - Print indent level
 *
 *  ENTRY
 *      iLevel - indent level
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintIndent(int iLevel, PFNPRINT pfnPrint, PVOID pv)
{
    int i;

    ENTER((3, "PrintIndent(Level=%d,pfnPrint=%p,pv=%p)\n",
           iLevel, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        for (i = 0; i < iLevel; ++i)
        {
            pfnPrint(pv,
                     ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))?
                     "| ": "    ");
        }
    }

    EXIT((3, "PrintIndent!\n"));
}       //PrintIndent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable)
{
    BYTE bOpClass = OPCLASS_INVALID;

    ENTER((2, "FindOpClass(Op=%x,pOpTable=%x)\n", bOp, pOpTable));

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
            pOpTable++;
    }

    EXIT((2, "FindOpClass=%x\n", bOpClass));
    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(DWORD dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindOpTerm(Opcode=%x)\n", dwOpcode));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (TC_CONST_NAME | TC_SHORT_NAME | TC_NAMESPACE_MODIFIER |
              TC_DATA_OBJECT | TC_NAMED_OBJECT | TC_OPCODE_TYPE1 |
              TC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindOpTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bData)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindKeywordTerm(cKWGroup=%c,Data=%x)\n", cKWGroup, bData));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == TC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (BYTE)(TermTable[i].dwTermData >> 8)) ==
             (BYTE)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindKeywordTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pbEnd -> end of scope
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmScope(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((rc == ASLERR_NONE) && (*ppbOp < pbEnd))
    {
        PrintIndent(giLevel, pfnPrint, pv);
        rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
        if (gpbOpBegin != *ppbOp)
        {
            DumpCode(*ppbOp, pfnPrint, pv);
        }
        else if (pfnPrint != NULL)
        {
            pfnPrint(pv, "\n");
        }
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmScope=%d\n", rc));
    return rc;
}       //UnAsmScope

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmOpcode(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    DWORD dwOpcode;
    BYTE bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    PNSOBJ pns;
    int i;

    ENTER((2, "UnAsmOpcode(pbOp=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pfnPrint, pv));

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((DWORD)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (DWORD)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
            break;

        case OPCLASS_NAME_OBJ:
            if (((rc = UnAsmNameObj(ppbOp, pfnPrint, pv, &pns, NSTYPE_UNKNOWN))
                 == ASLERR_NONE) &&
                (pns != NULL) &&
                (pns->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                for (i = 0; i < (int)pns->ObjData.uipDataValue; ++i)
                {
                    szUnAsmArgTypes[i] = 'C';
                }
                szUnAsmArgTypes[i] = '\0';
                rc = UnAsmArgs(szUnAsmArgTypes, NULL, 0, ppbOp, NULL, pfnPrint,
                               pv);
            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = ASLERR_INVALID_OPCODE;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
            }
            break;

        default:
            ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "UnAsmOpcode=%d\n", rc));
    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    BYTE bOp = **ppbOp;

    ENTER((2, "UnAsmDataObj(pbOp=%p,bOp=%x,pfnPrint=%p,pv=%p)\n",
           *ppbOp, bOp, pfnPrint, pv));

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", **ppbOp);
            }
            *ppbOp += sizeof(BYTE);
            break;

        case OP_WORD:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", *((PWORD)*ppbOp));
            }
            *ppbOp += sizeof(WORD);
            break;

        case OP_DWORD:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", *((PDWORD)*ppbOp));
            }
            *ppbOp += sizeof(DWORD);
            break;

        case OP_STRING:
            if (pfnPrint != NULL)
            {
		PSZ psz;

		pfnPrint(pv, "\"");
		for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
		{
		    if (*psz == '\\')
		    {
			pfnPrint(pv, "\\");
		    }
		    pfnPrint(pv, "%c", *psz);
		}
		pfnPrint(pv, "\"");
            }
            *ppbOp += strlen((PSZ)*ppbOp) + 1;
            break;

        default:
            ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = ASLERR_INVALID_OPCODE;
    }

    EXIT((2, "UnAsmDataObj=%d\n", rc));
    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *      ppns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmNameObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv, PNSOBJ *ppns,
                       char c)
{
    int rc = ASLERR_NONE;
    char szName[MAX_NSPATH_LEN + 1];
    int iLen = 0;

    ENTER((2, "UnAsmNameObj(pbOp=%p,pfnPrint=%p,pv=%p,ppns=%p,c=%c)\n",
           *ppbOp, pfnPrint, pv, ppns, c));

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = ParseNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NSPATH_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = ASLERR_NAME_TOO_LONG;
        }
        else
        {
            rc = ParseNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = ParseNameTail(ppbOp, szName, iLen);
    }

    if (rc == ASLERR_NONE)
    {
        PNSOBJ pns = NULL;

        if (pfnPrint != NULL)
        {
            pfnPrint(pv, "%s", szName);
        }

        if (islower(c) && (gdwfASL & ASLF_UNASM) &&
            ((pfnPrint == NULL) ||
             (gpnsCurrentScope->ObjData.dwDataType == OBJTYPE_METHOD)))
        {
            rc = CreateObject(NULL, szName, (char)_toupper(c), &pns);
            if ((rc == ASLERR_NSOBJ_EXIST) &&
                (gpnsCurrentScope->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                //
                // If we are creating an object inside a method scope, it
                // may already exist because we may have unassembled this
                // method before.  So it is not an error.
                //
                rc = ASLERR_NONE;
            }
        }
        else if ((rc = GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0)) ==
                 ASLERR_NSOBJ_NOT_FOUND)
        {
            if (c == NSTYPE_SCOPE)
            {
                rc = CreateScopeObj(szName, &pns);
            }
            else
            {
                rc = ASLERR_NONE;
            }
        }

        if (rc == ASLERR_NONE)
        {
            if ((c == NSTYPE_SCOPE) && (pns != NULL))
            {
                gpnsCurrentScope = pns;
            }

            if (ppns != NULL)
            {
                *ppns = pns;
            }
        }
    }

    EXIT((2, "UnAsmNameObj=%d (pns=%p)\n", rc, ppns? *ppns: 0));
    return rc;
}       //UnAsmNameObj

/***LP  ParseNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen)
{
    int rc = ASLERR_NONE;
    int icNameSegs = 0;

    ENTER((2, "ParseNameTail(pbOp=%x,Name=%s,iLen=%d)\n",
           *ppbOp, pszBuff, iLen));

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NSPATH_LEN))
    {
        strncpy(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NSPATH_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        ERROR(("ParseNameTail: name too long - %s", pszBuff));
        rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    EXIT((2, "ParseNameTail=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, PFNPRINT pfnPrint,
                       PVOID pv)
{
    int rc = ASLERR_NONE;
    PBYTE pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurrentScope;
    PNSOBJ pns = NULL;

    ENTER((2, "UnAsmTermObj(pterm=%p,Term=%s,pbOp=%p,pfnPrint=%p,pv=%p)\n",
           pterm, pterm->pszID, *ppbOp, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "%s", pterm->pszID);
    }

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions,
                       pterm->dwTermData, ppbOp, &pns, pfnPrint, pv);
    }

    if (rc == ASLERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
	    if ((pfnPrint == NULL) && (pterm->lID == ID_METHOD))
	    {
		//
		// We are in NameSpace building pass, so don't need to
		// go into methods.
		//
		*ppbOp = pbEnd;
	    }
	    else
	    {
                if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                {
                    ASSERT(pns != NULL);
                    gpnsCurrentScope = pns;
                }

                rc = UnAsmScope(ppbOp, pbEnd, pfnPrint, pv);
	    }
        }
    }
    gpnsCurrentScope = pnsScopeSave;

    EXIT((2, "UnAsmTermObj=%d\n", rc));
    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      dwTermData - Term data
 *      ppbOp -> opcode pointer
 *      ppns -> to hold created object
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    static BYTE bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm;

    ENTER((2, "UnAsmArgs(UnAsmArgTypes=%s,ArgActions=%s,TermData=%x,pbOp=%p,ppns=%p,pfnPrint=%p,pv=%p)\n",
           pszUnAsmArgTypes, pszArgActions? pszArgActions: "", dwTermData,
           *ppbOp, ppns, pfnPrint, pv));

    iNumArgs = strlen(pszUnAsmArgTypes);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "(");
    }

    for (i = 0; i < iNumArgs; ++i)
    {
        if ((i != 0) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, pfnPrint, pv, ppns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((DWORD)(**ppbOp));
                    
                    if(pterm)
                    {
                        (*ppbOp)++;
                        rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
                    }
                    else
                    {
                        ASSERT(pterm != NULL);
                        rc = ASLERR_INVALID_OPCODE;
                    }
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
                break;

            case 'B':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", **ppbOp);
                }

                *ppbOp += sizeof(BYTE);
                break;

            case 'E':
            case 'e':
            case 'K':
            case 'k':
                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    if ((gdwfASL & ASLF_UNASM) && (*ppns != NULL))
                    {
                        (*ppns)->ObjData.uipDataValue = (DWORD)(**ppbOp & 0x07);
                    }

                    if (pfnPrint != NULL)
                    {
                        pfnPrint(pv, "0x%x", **ppbOp & 0x07);
                    }
                }
                else if (pfnPrint != NULL)
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    if (pterm != NULL)
                    {
                        pfnPrint(pv, "%s", pterm->pszID);
                    }
                    else
                    {
                        pfnPrint(pv, "0x%x", bArgData & dwTermData & 0xff);
                    }
                }

                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    *ppbOp += sizeof(BYTE);
                }
                break;

            case 'W':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", *((PWORD)*ppbOp));
                }

                *ppbOp += sizeof(WORD);
                break;

            case 'D':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", *((PDWORD)*ppbOp));
                }

                *ppbOp += sizeof(DWORD);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp, pfnPrint, pv);
                break;

            default:
                ERROR(("UnAsmOpcode: invalid ArgType '%c'", pszUnAsmArgTypes[i]));
                rc = ASLERR_INVALID_ARGTYPE;
        }
    }

    if (pfnPrint != NULL)
    {
        pfnPrint(pv, ")");
    }

    EXIT((2, "UnAsmArgs=%d\n", rc));
    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmSuperName(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmSuperName(pbOp=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pfnPrint, pv));

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        if (pfnPrint != NULL)
        {
            pfnPrint(pv, "Debug");
        }
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, pfnPrint, pv, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
    }
    else
    {
        ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = ASLERR_INVALID_NAME;
    }

    EXIT((2, "UnAsmSuperName=%d\n", rc));
    return rc;
}       //UnAsmSuperName

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext)
{
    DWORD dwLen;
    BYTE bFollowCnt, i;

    ENTER((2, "ParsePackageLen(pbOp=%x,ppbOpNext=%x)\n", *ppbOp, ppbOpNext));

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (DWORD)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (BYTE)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (DWORD)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    EXIT((2, "ParsePackageLen=%x (pbOp=%x,pbOpNext=%x)\n",
          dwLen, *ppbOp, ppbOpNext? *ppbOpNext: 0));
    return dwLen;
}       //ParsePackageLen

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((2, "UnAsmDataList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }

    while (*ppbOp < pbEnd)
    {
        if (pfnPrint != NULL)
        {
            if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
            {
                pfnPrint(pv, ";");
            }
            pfnPrint(pv, "\t0x%02x", **ppbOp);
        }

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 12); ++i)
        {
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, ", 0x%02x", **ppbOp);
            }
            (*ppbOp)++;
        }

        if (pfnPrint != NULL)
        {
            if (*ppbOp < pbEnd)
            {
                pfnPrint(pv, ",");
            }
            pfnPrint(pv, "\n");
        }
    }

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmDataList=%d\n", rc));
    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    PASLTERM pterm;

    ENTER((2, "UnAsmPkgList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfnPrint, pv);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((DWORD)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, pfnPrint, pv, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
        }

        if ((*ppbOp < pbEnd) && (rc == ASLERR_NONE) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ",");
        }

        DumpCode(*ppbOp, pfnPrint, pv);
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmPkgList=%d\n", rc));
    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    DWORD dwBitPos = 0;

    ENTER((2, "UnAsmFieldList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfnPrint, pv);
        if (((rc = UnAsmField(ppbOp, pfnPrint, pv, &dwBitPos)) ==
             ASLERR_NONE) &&
            (*ppbOp < pbEnd) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ",");
        }
        DumpCode(*ppbOp, pfnPrint, pv);
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmFieldList=%d\n", rc));
    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmField(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv,
                     PDWORD pdwBitPos)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmField(pbOp=%p,pfnPrint=%p,pv=%p,BitPos=%x)\n",
           *ppbOp, pfnPrint, pv, *pdwBitPos));

    if (**ppbOp == 0x01)
    {
        (*ppbOp)++;
        if (pfnPrint != NULL)
        {
            PASLTERM pterm;

            pterm = FindKeywordTerm('A', **ppbOp);
            if(pterm)
                pfnPrint(pv, "AccessAs(%s, 0x%x)",
                     pterm->pszID, *(*ppbOp + 1));
            else
                pfnPrint(pv, "FindKeywordTerm('A', **ppbOp); returned NULL");
        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        DWORD dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            strncpy(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if (pfnPrint != NULL)
            {
                if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
                {
                    pfnPrint(pv, "Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
                }
                else
                {
                    pfnPrint(pv, ", %d", dwcbBits);
                }
            }
        }
        else
        {
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "%s, %d", szNameSeg, dwcbBits);
            }

            if ((gdwfASL & ASLF_UNASM) && (pfnPrint == NULL))
            {
                rc = CreateObject(NULL, szNameSeg, NSTYPE_FIELDUNIT, NULL);
            }
        }

        *pdwBitPos += dwcbBits;
    }

    EXIT((2, "UnAsmField=%d\n", rc));
    return rc;
}       //UnAsmField

/***LP  CreateObject - Create NameSpace object for the term
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *      c - object type to be created
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;

    ENTER((2, "CreateObject(ptoken=%p,Name=%s,Type=%c)\n",
           ptoken, pszName, c));

    if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
         ASLERR_NONE) &&
        (pns->ObjData.dwDataType == OBJTYPE_EXTERNAL) ||
        ((rc = CreateNameSpaceObj(ptoken, pszName, gpnsCurrentScope,
                                  gpnsCurrentOwner, &pns, NSF_EXIST_ERR)) ==
         ASLERR_NONE))
    {
#ifndef _UNASM_LIB
        if (!(gdwfASL & ASLF_UNASM))
        {
            ASSERT(gpcodeScope->pnsObj == NULL);
            gpcodeScope->dwfCode |= CF_CREATED_NSOBJ;
            gpcodeScope->pnsObj = pns;
            pns->Context = gpcodeScope;
        }
#endif  //ifndef _UNASM_LIB

        switch (c)
        {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                pns->ObjData.dwDataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                pns->ObjData.dwDataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                pns->ObjData.dwDataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                pns->ObjData.dwDataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                pns->ObjData.dwDataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                pns->ObjData.dwDataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                pns->ObjData.dwDataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                pns->ObjData.dwDataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                pns->ObjData.dwDataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                pns->ObjData.dwDataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                ERROR(("CreateObject: invalid object type %c", c));
                rc = ASLERR_INVALID_OBJTYPE;
        }

        if (ppns != NULL)
        {
            *ppns = pns;
        }
    }

    EXIT((2, "CreateObject=%d\n", rc));
    return rc;
}       //CreateObject

/***LP  CreateScopeObj - Create Scope object
 *
 *  ENTRY
 *      pszName -> object name
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pnsScope;
    PSZ psz;

    ENTER((2, "CreateScopeObj(Name=%s)\n", pszName));
    ASSERT(ppns != NULL);

    if ((psz = strrchr(pszName, '.')) != NULL)
    {
        *psz = '\0';
        if ((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pnsScope, 0)) ==
            ASLERR_NSOBJ_NOT_FOUND)
        {
            rc = CreateScopeObj(pszName, &pnsScope);
        }
        *psz = '.';
        psz++;
    }
    else if (pszName[0] == '\\')
    {
        pnsScope = gpnsNameSpaceRoot;
        psz = &pszName[1];
    }
    else
    {
        pnsScope = gpnsCurrentScope;
        psz = pszName;
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = CreateNameSpaceObj(NULL, psz, pnsScope, NULL, ppns,
                                  NSF_EXIST_OK)) == ASLERR_NONE))
    {
        (*ppns)->ObjData.dwDataType = OBJTYPE_EXTERNAL;
    }

    EXIT((2, "CreateScopeObj=%d (pns=%p)\n", rc, *ppns));
    return rc;
}       //CreateScopeObj

/***LP  ComputeDataChkSum - Compute checksum of a data buffer
 *
 *  ENTRY
 *      pb -> data buffer
 *      dwLen - size of data buffer
 *
 *  EXIT
 *      returns the checksum byte
 */

BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen)
{
    BYTE bChkSum = 0;

    ENTER((1, "ComputeDataChkSum(pb=%p,Len=%ld)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT((1, "ComputeDataChkSum=%x\n", bChkSum));
    return bChkSum;
}       //ComputeDataChkSum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\aslp.h ===
/*** aslp.h - ASL Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ASLP_H
#define _ASLP_H

#pragma warning (disable: 4201)

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define TUNE
#endif

#define ULONG_PTR ULONG

#define SPEC_VER 99
#ifndef EXCL_BASEDEF
#include "basedef.h"
#endif
#include <stdio.h>      //for FILE *
#include <string.h>     //for _stricmp
#include <stdlib.h>     //for malloc
#include <memory.h>     //for memset
#include <ctype.h>      //for isspace
#ifdef WINNT
#include <crt\io.h>     //for _open, _close, _read, _write
#else
#include <io.h>
#endif
#include <fcntl.h>      //for open flags
#include <sys\stat.h>   //for pmode flags
#include "parsearg.h"
#include "debug.h"
#include "line.h"
#define TOKERR_BASE -100
#include "token.h"
#include "scanasl.h"
#include "acpitabl.h"
#include "list.h"
#define _INC_NSOBJ_ONLY
#include "amli.h"
#include "aml.h"
#ifdef __UNASM
#include "..\acpitab\acpitab.h"
#define USE_CRUNTIME
#include "binfmt.h"
#endif

/*** Constants
 */

// String constants
#define STR_PROGDESC            "ACPI Source Language Assembler"
#define STR_COPYRIGHT           "Copyright (c) 1996,1999 Microsoft Corporation"
#define STR_MS			"MSFT"

// Error codes
#define ASLERR_NONE             0
#define ASLERR_INVALID_PARAM    -1
#define ASLERR_OPEN_FILE        -2
#define ASLERR_CREATE_FILE      -3
#define ASLERR_READ_FILE        -4
#define ASLERR_WRITE_FILE       -5
#define ASLERR_SEEK_FILE        -6
#define ASLERR_INIT_SCANNER     -7
#define ASLERR_OUT_OF_MEM       -8
#define ASLERR_NAME_TOO_LONG    -9
#define ASLERR_NEST_DDB         -10
#define ASLERR_SYNTAX           -11
#define ASLERR_PKTLEN_TOO_LONG  -12
#define ASLERR_NAME_EXIST       -13
#define ASLERR_NSOBJ_EXIST      -14
#define ASLERR_NSOBJ_NOT_FOUND  -15
#define ASLERR_INVALID_NAME     -16
#define ASLERR_INTERNAL_ERROR	-17
#define ASLERR_INVALID_EISAID   -18
#define ASLERR_EXPECT_EOF       -19
#define ASLERR_INVALID_OPCODE   -20
#define ASLERR_SIG_NOT_FOUND	-21
#define ASLERR_GET_TABLE        -22
#define ASLERR_CHECKSUM         -23
#define ASLERR_INVALID_ARGTYPE  -24
#define ASLERR_INVALID_OBJTYPE  -25
#define ASLERR_OPEN_VXD         -26

// Misc. constants
#define VERSION_MAJOR           1
#define VERSION_MINOR           0
#define VERSION_RELEASE         12
#define VERSION_DWORD           ((VERSION_MAJOR << 24) | \
                                 (VERSION_MINOR << 16) | \
                                 VERSION_RELEASE)
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"

// Implementation constants
#define MAX_STRING_LEN          199
#define MAX_NAME_LEN            1599    //approx. 255*4 + 254 + 255
#define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
#define MAX_MSG_LEN             127
#define MAX_ARGS                7
#define MAX_PACKAGE_LEN         0x0fffffff

// gdwfASL flags
#define ASLF_NOLOGO             0x00000001
#define ASLF_UNASM              0x00000002
#define ASLF_GENASM             0x00000004
#define ASLF_GENSRC             0x00000008
#define ASLF_NT                 0x00000010
#define ASLF_DUMP_NONASL        0x00000020
#define ASLF_DUMP_BIN           0x00000040
#define ASLF_CREAT_BIN          0x00000080

// Term classes
#define TC_PNP_MACRO            0x00100000
#define TC_REF_OBJECT           0x00200000
#define TC_FIELD_MACRO          0x00400000
#define TC_DATA_OBJECT          0x00800000
#define TC_NAMED_OBJECT         0x01000000
#define TC_NAMESPACE_MODIFIER   0x02000000
#define TC_OPCODE_TYPE1         0x04000000
#define TC_OPCODE_TYPE2         0x08000000
#define TC_CONST_NAME           0x10000000
#define TC_SHORT_NAME           0x20000000
#define TC_COMPILER_DIRECTIVE   0x40000000
#define TC_KEYWORD              0x80000000
#define TC_OPCODE               (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | TC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          TC_FIELD_MACRO
#define TF_DATA_OBJECT          TC_DATA_OBJECT
#define TF_NAMED_OBJECT         TC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   TC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         TC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         TC_OPCODE_TYPE2
#define TF_CONST_NAME           TC_CONST_NAME
#define TF_SHORT_NAME           TC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   TC_COMPILER_DIRECTIVE
#define TF_KEYWORD              TC_KEYWORD
#define TF_PNP_MACRO            TC_PNP_MACRO
#define TF_OBJECT_LIST          (TC_NAMED_OBJECT | TC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (TC_DATA_OBJECT | TC_SHORT_NAME | \
                                 TC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

// Code flags
#define CF_MISSING_ARG          0x00000001
#define CF_PARSING_FIXEDLIST    0x00000002
#define CF_PARSING_VARLIST      0x00000004
#define CF_CREATED_NSOBJ        0x00000008

// NS flags
#define NSF_EXIST_OK            0x00010000
#define NSF_EXIST_ERR           0x00020000

// Data types
#define CODETYPE_UNKNOWN        0
#define CODETYPE_ASLTERM        1
#define CODETYPE_NAME           2
#define CODETYPE_DATAOBJ        3
#define CODETYPE_FIELDOBJ       4
#define CODETYPE_INTEGER        5
#define CODETYPE_STRING         6
#define CODETYPE_KEYWORD        7
#define CODETYPE_USERTERM       8
#define CODETYPE_QWORD          9

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

#define OBJTYPE_PRIVATE         0xf0
#define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
#define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)
#define OBJTYPE_EXTERNAL        (OBJTYPE_PRIVATE + 0x02)

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

/*** Macros
 */

#define MODNAME                 ProgInfo.pszProgName
#define ISLEADNAMECHAR(c)       (((c) >= 'A') && ((c) <= 'Z') || ((c) == '_'))
#define ISNAMECHAR(c)           (ISLEADNAMECHAR(c) || ((c) >= '0') && ((c) <= '9'))
#define OPCODELEN(d)            (((d) == OP_NONE)? 0: (((d) & 0x0000ff00)? 2: 1))
#ifdef DEBUG
  #define MEMALLOC(n)           (++gdwcMemObjs, malloc(n))
  #define MEMFREE(p)            {ASSERT(gdwcMemObjs > 0); free(p); --gdwcMemObjs;}
#else
  #define MEMALLOC(n)           malloc(n)
  #define MEMFREE(p)            free(p)
#endif

/*** Type definitions
 */

typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    LONG    lID;
    DWORD   dwfTermClass;
    DWORD   dwTermData;
    DWORD   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgTypes;
    PSZ     pszArgActions;
    DWORD   dwfTerm;
    PFNTERM pfnTerm;
} ASLTERM, *PASLTERM;

typedef struct _codeobj
{
    LIST   list;                //link to siblings
    struct _codeobj *pcParent;
    struct _codeobj *pcFirstChild;
    PNSOBJ pnsObj;
    DWORD  dwTermIndex;
    DWORD  dwfCode;
    DWORD  dwCodeType;
    DWORD  dwCodeValue;
    DWORD  dwDataLen;
    PBYTE  pbDataBuff;
    DWORD  dwCodeLen;
    BYTE   bCodeChkSum;
} CODEOBJ, *PCODEOBJ;

typedef struct _nschk
{
    struct _nschk *pnschkNext;
    char   szObjName[MAX_NAME_LEN + 1];
    PSZ    pszFile;
    PNSOBJ pnsScope;
    PNSOBJ pnsMethod;
    ULONG  dwExpectedType;
    ULONG  dwChkData;
    WORD   wLineNum;
} NSCHK, *PNSCHK;

typedef struct _resfield
{
    PSZ   pszName;
    DWORD dwBitOffset;
    DWORD dwBitSize;
} RESFIELD, *PRESFIELD;

typedef struct _opmap
{
    BYTE    bExOp;
    BYTE    bOpClass;
} OPMAP, *POPMAP;

#include "proto.h"
#include "data.h"

#endif  //ifndef _ASLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef _UNASM_LIB

//
// Constant definitions
//

#ifndef MODNAME
  #define MODNAME             "UnAsm"
#endif

// Error codes
#define ASLERR_NONE                     0
#define ASLERR_OUT_OF_MEM               -1
#define ASLERR_OPEN_FILE                -2
#define ASLERR_SEEK_FILE                -3
#define ASLERR_READ_FILE                -4
#define ASLERR_GET_TABLE                -5
#define ASLERR_CHECKSUM                 -6
#define ASLERR_INVALID_OPCODE           -7
#define ASLERR_INTERNAL_ERROR           -8
#define ASLERR_NAME_TOO_LONG            -9
#define ASLERR_NSOBJ_NOT_FOUND          -10
#define ASLERR_INVALID_NAME             -11
#define ASLERR_INVALID_ARGTYPE          -12
#define ASLERR_INVALID_OBJTYPE          -13
#define ASLERR_NSOBJ_EXIST              -14

// gdwfASL flags
#define ASLF_UNASM              0x00000001
#define ASLF_GENASM             0x00000002
#define ASLF_GENSRC             0x00000004

//
// Imported data
//
extern DWORD gdwfASL;
extern PNSOBJ gpnsNameSpaceRoot;
extern PNSOBJ gpnsCurrentScope;
extern PNSOBJ gpnsCurrentOwner;
extern PSZ gpszAMLFile;
extern PSZ gpszTabSig;

#endif  //ifdef _UNASM_LIB

#ifndef MEMALLOC
  #define MEMALLOC malloc
#endif

#ifndef MEMFREE
  #define MEMFREE free
#endif

//
// Type definitions
//
typedef int (*PFNPRINT)(PVOID, PSZ, ...);

//
// Local function prototypes
//
int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh,
                      PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL DumpCode(PBYTE pbOp, PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL PrintIndent(int iLevel, PFNPRINT pfnPrint, PVOID pv);
BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(DWORD dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bDate);
int LOCAL UnAsmOpcode(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmDataObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmNameObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv, PNSOBJ *ppns,
                       char c);
int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen);
int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, PFNPRINT pfnPrint,
                       PVOID pv);
int LOCAL UnAsmSuperName(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, PFNPRINT pfnPrint, PVOID pv);
DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext);
int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint,
                         PVOID pv);
int LOCAL UnAsmField(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv,
                     PDWORD pdwBitPos);
int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns);
int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns);
BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen);

//
// Exported function prototypes
//
int LOCAL UnAsmFile(PSZ pszAMLName, PFNPRINT pfnPrint, PVOID pv);
int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb);
int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, PFNPRINT pfnPrint,
                   PVOID pv);
int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\data.c ===
/*** data.c - Global Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

#ifdef TRACING
FILE *gpfileTrace = NULL;
PSZ gpszTraceFile = NULL;
int giTraceLevel = 0;
int giIndent = 0;
#endif  //ifdef TRACING

#ifdef DEBUG
DWORD gdwcMemObjs = 0;
#endif

#pragma warning(disable: 4054)
ARGTYPE FAR ArgTypes[] =
{
    {"?",     AT_ACTION, 0,            (VOID *)PrintHelp, 0,             NULL},
    {"Fo",    AT_STRING, PF_SEPARATOR, &gpszAMLFile,      0,             NULL},
    {"Fa",    AT_STRING, PF_SEPARATOR, &gpszASMFile,      0,             NULL},
    {"Fl",    AT_STRING, PF_SEPARATOR, &gpszLSTFile,      0,             NULL},
    {"Fn",    AT_STRING, PF_SEPARATOR, &gpszNSDFile,      0,             NULL},
  #ifdef __UNASM
    {"d",     AT_ENABLE, 0,            &gdwfASL,          ASLF_DUMP_BIN, NULL},
    {"u",     AT_ENABLE, 0,            &gdwfASL,          ASLF_UNASM,    NULL},
    {"c",     AT_ENABLE, 0,            &gdwfASL,          ASLF_CREAT_BIN,NULL},
    {"tab",   AT_STRING, PF_SEPARATOR, &gpszTabSig,       0,             NULL},
  #endif
  #ifdef TRACING
    {"t",     AT_NUM,    PF_SEPARATOR, &giTraceLevel,     0,             NULL},
    {"l",     AT_STRING, PF_SEPARATOR, &gpszTraceFile,    0,             NULL},
  #endif
    {"nologo",AT_ENABLE, 0,            &gdwfASL,          ASLF_NOLOGO,   NULL},
    {"",      0,         0,            NULL,              0,             NULL}
};
#pragma warning(default: 4054)

PROGINFO ProgInfo = {NULL, NULL, NULL, NULL};

#ifdef __UNASM
HANDLE ghVxD = NULL;
#endif
char gszAMLName[_MAX_FNAME] = {0};
char gszLSTName[_MAX_FNAME] = {0};
PSZ gpszASLFile = NULL;
PSZ gpszAMLFile = NULL;
PSZ gpszASMFile = NULL;
PSZ gpszLSTFile = NULL;
PSZ gpszNSDFile = NULL;
PSZ gpszTabSig = NULL;
int giLevel = 0;
PBYTE gpbOpTop = NULL;
PBYTE gpbOpBegin = NULL;
DWORD gdwfASL = 0;
PCODEOBJ gpcodeRoot = NULL;
PCODEOBJ gpcodeScope = NULL;
PNSOBJ gpnsNameSpaceRoot = NULL;
PNSOBJ gpnsCurrentScope = NULL;
PNSOBJ gpnsCurrentOwner = NULL;
PNSCHK gpnschkHead = NULL;
PNSCHK gpnschkTail = NULL;
DWORD gdwFieldAccSize = 0;
DESCRIPTION_HEADER ghdrDDB = {0};
char SymCharTable[] = "{}(),/*";
char * FAR gapszTokenType[] = {"ASL/User Term", "String", "Character", "Number",
                               "Symbol", "Space"};
//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      TC_COMPILER_DIRECTIVE
#define FM      TC_FIELD_MACRO
#define CN	TC_CONST_NAME
#define SN      TC_SHORT_NAME
#define NS      TC_NAMESPACE_MODIFIER
#define DO      TC_DATA_OBJECT
#define KW      TC_KEYWORD
#define NO      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define RO      TC_REF_OBJECT
#define PM      TC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY	(ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB	(ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW	(ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW	(ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define ABLK	(ACCTYPE_BLOCK | (ACCTYPE_MASK << 8))
#define ASSR	(ACCTYPE_SMBSENDRECV | (ACCTYPE_MASK << 8))
#define ASQ	(ACCTYPE_SMBQUICK | (ACCTYPE_MASK << 8))
#define LK	(LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK	(LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV	(UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S	(UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S	(UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB	(REGSPACE_SMB | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  ID_DEFBLK,       CD, 0, OP_NONE,     NULL, "ZZBZZD", NULL, OL|CL|LL|AF|AV, DefinitionBlock,
    "Include",          ID_INCLUDE,      CD, 0, OP_NONE,     NULL, "Z",      NULL, AF, Include,
    "External",         ID_EXTERNAL,     CD, 0, OP_NONE,     NULL, "Nk",     "uX", AF, External,

    // Short Objects
    "Zero",             ID_ZERO,         CN, 0, OP_ZERO,     NULL, NULL, NULL, 0, NULL,
    "One",              ID_ONE,          CN, 0, OP_ONE,      NULL, NULL, NULL, 0, NULL,
    "Ones",             ID_ONES,         CN, 0, OP_ONES,     NULL, NULL, NULL, 0, NULL,
    "Revision",         ID_REVISION,     CN, 0, OP_REVISION, NULL, NULL, NULL, 0, NULL,
    "Arg0",             ID_ARG0,         SN, 0, OP_ARG0,     NULL, NULL, NULL, 0, NULL,
    "Arg1",             ID_ARG1,         SN, 0, OP_ARG1,     NULL, NULL, NULL, 0, NULL,
    "Arg2",             ID_ARG2,         SN, 0, OP_ARG2,     NULL, NULL, NULL, 0, NULL,
    "Arg3",             ID_ARG3,         SN, 0, OP_ARG3,     NULL, NULL, NULL, 0, NULL,
    "Arg4",             ID_ARG4,         SN, 0, OP_ARG4,     NULL, NULL, NULL, 0, NULL,
    "Arg5",             ID_ARG5,         SN, 0, OP_ARG5,     NULL, NULL, NULL, 0, NULL,
    "Arg6",             ID_ARG6,         SN, 0, OP_ARG6,     NULL, NULL, NULL, 0, NULL,
    "Local0",           ID_LOCAL0,       SN, 0, OP_LOCAL0,   NULL, NULL, NULL, 0, NULL,
    "Local1",           ID_LOCAL1,       SN, 0, OP_LOCAL1,   NULL, NULL, NULL, 0, NULL,
    "Local2",           ID_LOCAL2,       SN, 0, OP_LOCAL2,   NULL, NULL, NULL, 0, NULL,
    "Local3",           ID_LOCAL3,       SN, 0, OP_LOCAL3,   NULL, NULL, NULL, 0, NULL,
    "Local4",           ID_LOCAL4,       SN, 0, OP_LOCAL4,   NULL, NULL, NULL, 0, NULL,
    "Local5",           ID_LOCAL5,       SN, 0, OP_LOCAL5,   NULL, NULL, NULL, 0, NULL,
    "Local6",           ID_LOCAL6,       SN, 0, OP_LOCAL6,   NULL, NULL, NULL, 0, NULL,
    "Local7",           ID_LOCAL7,       SN, 0, OP_LOCAL7,   NULL, NULL, NULL, 0, NULL,
    "Debug",            ID_DEBUG,        SN, 0, OP_DEBUG,    NULL, NULL, NULL, 0, NULL,

    // Named Terms
    "Alias",            ID_ALIAS,        NS, 0, OP_ALIAS,    "NN", "NN", "Ua", 0, NULL,
    "Name",             ID_NAME,         NS, 0, OP_NAME,     "NO", "NO", "u",  0, NULL,
    "Scope",            ID_SCOPE,        NS, 0, OP_SCOPE,    "N",  "N",  "S",  OL|LN|CC, NULL,

    // Data Objects
    "Buffer",           ID_BUFFER,       DO, 0, OP_BUFFER,   "C", "c",  "U",  DL|LN, NULL,
    "Package",          ID_PACKAGE,      DO, 0, OP_PACKAGE,  "B", "b",  NULL, PL|LN, NULL,
    "EISAID",		ID_EISAID,       DO, 0, OP_DWORD,    NULL,"Z",  NULL, AF, EISAID,

    // Argument Keywords
    "AnyAcc",           ID_ANYACC,       KW, AANY, OP_NONE, NULL, NULL, "A", 0, NULL,
    "ByteAcc",          ID_BYTEACC,      KW, AB,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "WordAcc",          ID_WORDACC,      KW, AW,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "DWordAcc",         ID_DWORDACC,     KW, ADW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "BlockAcc",         ID_BLOCKACC,     KW, ABLK, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBSendRecvAcc",   ID_SMBSENDRCVACC,KW, ASSR, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBQuickAcc",      ID_SMBQUICKACC,  KW, ASQ,  OP_NONE, NULL, NULL, "A", 0, NULL,

    "Lock",             ID_LOCK,         KW, LK,   OP_NONE, NULL, NULL, "B", 0, NULL,
    "NoLock",           ID_NOLOCK,       KW, NOLK, OP_NONE, NULL, NULL, "B", 0, NULL,

    "Preserve",         ID_PRESERVE,     KW, PSRV, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsOnes",      ID_WRONES,       KW, WA1S, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsZeros",     ID_WRZEROS,      KW, WA0S, OP_NONE, NULL, NULL, "C", 0, NULL,

    "SystemMemory",     ID_SYSMEM,       KW, MEM,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "SystemIO",         ID_SYSIO,        KW, IO,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "PCI_Config",       ID_PCICFG,       KW, CFG,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "EmbeddedControl",  ID_EMBCTRL,      KW, EC,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "SMBus",            ID_SMBUS,        KW, SMB,  OP_NONE, NULL, NULL, "D", 0, NULL,

    "Serialized",       ID_SERIALIZED,   KW, SER,  OP_NONE, NULL, NULL, "E", 0, NULL,
    "NotSerialized",    ID_NOTSERIALIZED,KW, NOSER,OP_NONE, NULL, NULL, "E", 0, NULL,

    "MTR",              ID_MTR,          KW, OMTR, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MEQ",              ID_MEQ,          KW, OMEQ, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLE",              ID_MLE,          KW, OMLE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLT",              ID_MLT,          KW, OMLT, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGE",              ID_MGE,          KW, OMGE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGT",              ID_MGT,          KW, OMGT, OP_NONE, NULL, NULL, "F", 0, NULL,

    "Edge",             ID_EDGE,         KW, _HE,  OP_NONE, NULL, NULL, "G", 0, NULL,
    "Level",            ID_LEVEL,        KW, _LL,  OP_NONE, NULL, NULL, "G", 0, NULL,

    "ActiveHigh",       ID_ACTIVEHI,     KW, _HE,  OP_NONE, NULL, NULL, "H", 0, NULL,
    "ActiveLow",        ID_ACTIVELO,     KW, _LL,  OP_NONE, NULL, NULL, "H", 0, NULL,

    "Shared",           ID_SHARED,       KW, _SHR, OP_NONE, NULL, NULL, "I", 0, NULL,
    "Exclusive",        ID_EXCLUSIVE,    KW, _EXC, OP_NONE, NULL, NULL, "I", 0, NULL,

    "Compatibility",    ID_COMPAT,       KW, COMP, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeA",            ID_TYPEA,        KW, TYPA, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeB",            ID_TYPEB,        KW, TYPB, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeF",            ID_TYPEF,        KW, TYPF, OP_NONE, NULL, NULL, "J", 0, NULL,

    "BusMaster",        ID_BUSMASTER,    KW, BM,   OP_NONE, NULL, NULL, "K", 0, NULL,
    "NotBusMaster",     ID_NOTBUSMASTER, KW, NOBM, OP_NONE, NULL, NULL, "K", 0, NULL,

    "Transfer8",        ID_TRANSFER8,    KW, X8,   OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer8_16",     ID_TRANSFER8_16, KW, X816, OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer16",       ID_TRANSFER16,   KW, X16,  OP_NONE, NULL, NULL, "L", 0, NULL,

    "Decode16",         ID_DECODE16,     KW, DC16, OP_NONE, NULL, NULL, "M", 0, NULL,
    "Decode10",         ID_DECODE10,     KW, DC10, OP_NONE, NULL, NULL, "M", 0, NULL,

    "ReadWrite",        ID_READWRITE,    KW, _RW,  OP_NONE, NULL, NULL, "N", 0, NULL,
    "ReadOnly",         ID_READONLY,     KW, _ROM, OP_NONE, NULL, NULL, "N", 0, NULL,

    "ResourceConsumer", ID_RESCONSUMER,  KW, RCS,  OP_NONE, NULL, NULL, "O", 0, NULL,
    "ResourceProducer", ID_RESPRODUCER,  KW, RPD,  OP_NONE, NULL, NULL, "O", 0, NULL,

    "SubDecode",        ID_SUBDECODE,    KW, BSD,  OP_NONE, NULL, NULL, "P", 0, NULL,
    "PosDecode",        ID_POSDECODE,    KW, BPD,  OP_NONE, NULL, NULL, "P", 0, NULL,

    "MinFixed",         ID_MINFIXED,     KW, MIF,  OP_NONE, NULL, NULL, "Q", 0, NULL,
    "MinNotFixed",      ID_MINNOTFIXED,  KW, NMIF, OP_NONE, NULL, NULL, "Q", 0, NULL,

    "MaxFixed",         ID_MAXFIXED,     KW, MAF,  OP_NONE, NULL, NULL, "R", 0, NULL,
    "MaxNotFixed",      ID_MAXNOTFIXED,  KW, NMAF, OP_NONE, NULL, NULL, "R", 0, NULL,

    "Cacheable",        ID_CACHEABLE,    KW, CACH, OP_NONE, NULL, NULL, "S", 0, NULL,
    "WriteCombining",   ID_WRCOMBINING,  KW, WRCB, OP_NONE, NULL, NULL, "S", 0, NULL,
    "Prefetchable",     ID_PREFETCHABLE, KW, PREF, OP_NONE, NULL, NULL, "S", 0, NULL,
    "NonCacheable",     ID_NONCACHEABLE, KW, NCAC, OP_NONE, NULL, NULL, "S", 0, NULL,

    "ISAOnlyRanges",    ID_ISAONLYRNG,   KW, ISA,  OP_NONE, NULL, NULL, "T", 0, NULL,
    "NonISAOnlyRanges", ID_NONISAONLYRNG,KW, NISA, OP_NONE, NULL, NULL, "T", 0, NULL,
    "EntireRange",      ID_ENTIRERNG,    KW, ERNG, OP_NONE, NULL, NULL, "T", 0, NULL,

    "ExtEdge",          ID_EXT_EDGE,     KW, $EDG, OP_NONE, NULL, NULL, "U", 0, NULL,
    "ExtLevel",         ID_EXT_LEVEL,    KW, $LVL, OP_NONE, NULL, NULL, "U", 0, NULL,

    "ExtActiveHigh",    ID_EXT_ACTIVEHI, KW, $HGH, OP_NONE, NULL, NULL, "V", 0, NULL,
    "ExtActiveLow",     ID_EXT_ACTIVELO, KW, $LOW, OP_NONE, NULL, NULL, "V", 0, NULL,

    "ExtShared",        ID_EXT_SHARED,   KW, $SHR, OP_NONE, NULL, NULL, "W", 0, NULL,
    "ExtExclusive",     ID_EXT_EXCLUSIVE,KW, $EXC, OP_NONE, NULL, NULL, "W", 0, NULL,

    "UnknownObj",       ID_UNKNOWN_OBJ,  KW, UNK,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "IntObj",           ID_INT_OBJ,      KW, INT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "StrObj",           ID_STR_OBJ,      KW, STR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffObj",          ID_BUFF_OBJ,     KW, BUF,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PkgObj",           ID_PKG_OBJ,      KW, PKG,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "FieldUnitObj",     ID_FIELDUNIT_OBJ,KW, FDU,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DeviceObj",        ID_DEV_OBJ,      KW, DEV,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "EventObj",         ID_EVENT_OBJ,    KW, EVT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MethodObj",        ID_METHOD_OBJ,   KW, MET,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MutexObj",         ID_MUTEX_OBJ,    KW, MUT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "OpRegionObj",      ID_OPREGION_OBJ, KW, OPR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PowerResObj",      ID_POWERRES_OBJ, KW, PWR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "ThermalZoneObj",   ID_THERMAL_OBJ,  KW, THM,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffFieldObj",     ID_BUFFFIELD_OBJ,KW, BFD,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DDBHandleObj",     ID_DDBHANDLE_OBJ,KW, DDB,  OP_NONE, NULL, NULL, "X", 0, NULL,

    // Field Macros
    "Offset",           ID_OFFSET,       FM, 0, OP_NONE, NULL, "B",  NULL, 0,  NULL,
    "AccessAs",         ID_ACCESSAS,     FM, 0, 0x01,    NULL, "Kb", "A", AF, AccessAs,

    // Named Object Creators
    "BankField",        ID_BANKFIELD,    NO, 0, OP_BANKFIELD,  "NNCKkk","NNCKKK","OFUABC", FL|FM|LN|AF, BankField,
    "CreateBitField",   ID_BITFIELD,     NO, 0, OP_BITFIELD,   "CCN", "CPN", "UUb",0, NULL,
    "CreateByteField",  ID_BYTEFIELD,    NO, 0, OP_BYTEFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "CreateDWordField", ID_DWORDFIELD,   NO, 0, OP_DWORDFIELD, "CCN", "CMN", "UUb",0, NULL,
    "CreateField",      ID_CREATEFIELD,  NO, 0, OP_CREATEFIELD,"CCCN","CPCN","UUUb",0,NULL,
    "CreateWordField",  ID_WORDFIELD,    NO, 0, OP_WORDFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "Device",           ID_DEVICE,       NO, 0, OP_DEVICE,     "N",    "N",      "d",      OL|LN|CC, NULL,
    "Event",            ID_EVENT,        NO, 0, OP_EVENT,      "N",    "N",      "e",      0, NULL,
    "Field",            ID_FIELD,        NO, 0, OP_FIELD,      "NKkk", "NKKK",   "OABC",   FL|FM|LN|AF, Field,
    "IndexField",       ID_IDXFIELD,     NO, 0, OP_IDXFIELD,   "NNKkk","NNKKK",  "FFABC",  FL|FM|LN|AF, IndexField,
    "Method",           ID_METHOD,       NO, 0, OP_METHOD,     "NKk",  "Nbk",    "m!E",    CL|OL|LN|AF|CC, Method,
    "Mutex",            ID_MUTEX,        NO, 0, OP_MUTEX,      "NB",   "NB",     "x",      0,  NULL,
    "OperationRegion",  ID_OPREGION,     NO, 0x80ff00ff,OP_OPREGION,"NECC","NECC","oDUU",  AF, OpRegion,
    "PowerResource",    ID_POWERRES,     NO, 0, OP_POWERRES,   "NBW",  "NBW",    "p",      OL|LN|CC, NULL,
    "Processor",        ID_PROCESSOR,    NO, 0, OP_PROCESSOR,  "NBDB", "NBDB",   "c",      OL|LN|CC, NULL,
    "ThermalZone",      ID_THERMALZONE,  NO, 0, OP_THERMALZONE,"N",    "N",      "t",      OL|LN|CC, NULL,

    // Type 1 Opcode Terms
    "Break",            ID_BREAK,        C1, 0, OP_BREAK,       NULL,  NULL,  NULL, 0, NULL,
    "BreakPoint",       ID_BREAKPOINT,   C1, 0, OP_BREAKPOINT,  NULL,  NULL,  NULL, 0, NULL,
    "Else",             ID_ELSE,         C1, 0, OP_ELSE,        NULL,  NULL,  NULL, AF|CL|OL|LN, Else,
    "Fatal",            ID_FATAL,        C1, 0, OP_FATAL,       "BDC", "BDC", "  U",0, NULL,
    "If",               ID_IF,           C1, 0, OP_IF,          "C",   "C",   "U",  CL|OL|LN, NULL,
    "Load",             ID_LOAD,         C1, 0, OP_LOAD,        "NS",  "NS",  "UU", 0, NULL,
    "Noop",             ID_NOP,          C1, 0, OP_NOP,         NULL,  NULL,  NULL, 0, NULL,
    "Notify",           ID_NOTIFY,       C1, 0, OP_NOTIFY,      "SC",  "SC",  "UU", 0, NULL,
    "Release",          ID_RELEASE,      C1, 0, OP_RELEASE,     "S",   "S",   "X",  0, NULL,
    "Reset",            ID_RESET,        C1, 0, OP_RESET,       "S",   "S",   "E",  0, NULL,
    "Return",           ID_RETURN,       C1, 0, OP_RETURN,      "C",   "C",   "U",  0, NULL,
    "Signal",           ID_SIGNAL,       C1, 0, OP_SIGNAL,      "S",   "S",   "E",  0, NULL,
    "Sleep",            ID_SLEEP,        C1, 0, OP_SLEEP,       "C",   "C",   "U",  0, NULL,
    "Stall",            ID_STALL,        C1, 0, OP_STALL,       "C",   "C",   "U",  0, NULL,
    "Unload",           ID_UNLOAD,       C1, 0, OP_UNLOAD,      "S",   "S",   "U",  0, NULL,
    "While",            ID_WHILE,        C1, 0, OP_WHILE,       "C",   "C",   "U",  CL|OL|LN, NULL,

    // Type 2 Opcode Terms
    "Acquire",          ID_ACQUIRE,      C2, 0, OP_ACQUIRE,     "SW",     "SW",     "X",  0, NULL,
    "Add",              ID_ADD,          C2, 0, OP_ADD,         "CCS",    "CCs",    "UUU",0, NULL,
    "And",              ID_AND,          C2, 0, OP_AND,         "CCS",    "CCs",    "UUU",0, NULL,
    "Concatenate",      ID_CONCAT,       C2, 0, OP_CONCAT,      "CCS",    "CCS",    "UUU",0, NULL,
    "CondRefOf",        ID_CONDREFOF,    C2, 0, OP_CONDREFOF,   "SS",     "SS",     "UU", 0, NULL,
    "Decrement",        ID_DECREMENT,    C2, 0, OP_DECREMENT,   "S",      "S",      "U",  0, NULL,
    "DerefOf",		ID_DEREFOF,	 C2, 0, OP_DEREFOF,	"C",      "C",	    "U",  0, NULL,
    "Divide",           ID_DIVIDE,       C2, 0, OP_DIVIDE,      "CCSS",   "CCss",   "UUUU",0,NULL,
    "FindSetLeftBit",   ID_FINDSETLBIT,  C2, 0, OP_FINDSETLBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FindSetRightBit",  ID_FINDSETRBIT,  C2, 0, OP_FINDSETRBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FromBCD",          ID_FROMBCD,      C2, 0, OP_FROMBCD,     "CS",     "Cs",     "UU", 0, NULL,
    "Increment",        ID_INCREMENT,    C2, 0, OP_INCREMENT,   "S",      "S",      "U",  0, NULL,
    "Index",            ID_INDEX,     RO|C2, 0, OP_INDEX,       "CCS",    "CMs",    "UUU",0, NULL,
    "LAnd",             ID_LAND,         C2, 0, OP_LAND,        "CC",     "CC",     "UU", 0, NULL,
    "LEqual",           ID_LEQ,          C2, 0, OP_LEQ,         "CC",     "CC",     "UU", 0, NULL,
    "LGreater",         ID_LG,           C2, 0, OP_LG,          "CC",     "CC",     "UU", 0, NULL,
    "LGreaterEqual",    ID_LGEQ,         C2, 0, OP_LGEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LLess",            ID_LL,           C2, 0, OP_LL,          "CC",     "CC",     "UU", 0, NULL,
    "LLessEqual",       ID_LLEQ,         C2, 0, OP_LLEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LNot",             ID_LNOT,         C2, 0, OP_LNOT,        "C",      "C",      "U",  0, NULL,
    "LNotEqual",        ID_LNOTEQ,       C2, 0, OP_LNOTEQ,      "CC",     "CC",     "UU", 0, NULL,
    "LOr",              ID_LOR,          C2, 0, OP_LOR,         "CC",     "CC",     "UU", 0, NULL,
    "Match",            ID_MATCH,        C2, 0, OP_MATCH,       "CKCKCC", "CKCKCC", "UFUFUU",AF,Match,
    "Multiply",         ID_MULTIPLY,     C2, 0, OP_MULTIPLY,    "CCS",    "CCs",    "UUU",0, NULL,
    "NAnd",             ID_NAND,         C2, 0, OP_NAND,        "CCS",    "CCs",    "UUU",0, NULL,
    "NOr",              ID_NOR,          C2, 0, OP_NOR,         "CCS",    "CCs",    "UUU",0, NULL,
    "Not",              ID_NOT,          C2, 0, OP_NOT,         "CS",     "Cs",     "UU", 0, NULL,
    "ObjectType",       ID_OBJTYPE,      C2, 0, OP_OBJTYPE,     "S",      "S",      "U",  0, NULL,
    "Or",               ID_OR,           C2, 0, OP_OR,          "CCS",    "CCs",    "UUU",0, NULL,
    "RefOf",            ID_REFOF,        C2, 0, OP_REFOF,       "S",      "S",      "U",  0, NULL,
    "ShiftLeft",        ID_SHIFTL,       C2, 0, OP_SHIFTL,      "CCS",    "CCs",    "UUU",0, NULL,
    "ShiftRight",       ID_SHIFTR,       C2, 0, OP_SHIFTR,      "CCS",    "CCs",    "UUU",0, NULL,
    "SizeOf",           ID_SIZEOF,       C2, 0, OP_SIZEOF,      "S",      "S",      "U",  0, NULL,
    "Store",            ID_STORE,        C2, 0, OP_STORE,       "CS",     "CS",     "UU", 0, NULL,
    "Subtract",         ID_SUBTRACT,     C2, 0, OP_SUBTRACT,    "CCS",    "CCs",    "UUU",0, NULL,
    "ToBCD",            ID_TOBCD,        C2, 0, OP_TOBCD,       "CS",     "Cs",     "UU", 0, NULL,
    "Wait",             ID_WAIT,         C2, 0, OP_WAIT,        "SC",     "SC",     "E",  0, NULL,
    "XOr",              ID_XOR,          C2, 0, OP_XOR,         "CCS",    "CCs",    "UUU",0, NULL,

    // PNP Macros
    "ResourceTemplate", ID_RESTEMP,      DO, 0, OP_BUFFER, NULL, "",       NULL, ML|AF|AV|LN,ResourceTemplate,
    "StartDependentFnNoPri",ID_STARTDEPFNNOPRI,PM,0,0x30,  NULL, "",       NULL, ML|AF,   AddSmallOffset,
    "StartDependentFn", ID_STARTDEPFN,   PM, 0, 0x31,      NULL, "BB",     NULL, ML|AF,   StartDependentFn,
    "EndDependentFn",   ID_ENDDEPFN,     PM, 0, 0x38,      NULL, "",       NULL, AF,      AddSmallOffset,
    "IRQNoFlags",       ID_IRQNOFLAGS,   PM, 0, 0x22,      NULL, "r",      NULL, BL|AV,   IRQDesc,
    "IRQ",              ID_IRQ,          PM, 0, 0x23,      NULL, "KKkr",   "GHI",BL|AV,   IRQDesc,
    "DMA",              ID_DMA,          PM, 0, 0x2a,      NULL, "KKKr",   "JKL",BL|AV,   DMADesc,
    "IO",               ID_IO,           PM, 0, 0x47,      NULL, "KWWBBr", "M",  AF,      IODesc,
    "FixedIO",          ID_FIXEDIO,      PM, 0, 0x4b,      NULL, "WBr",    NULL, AF,      FixedIODesc,
    "VendorShort",      ID_VENDORSHORT,  PM, 0, OP_NONE,   NULL, "r",      NULL, BL|AV,   VendorShort,
    "Memory24",         ID_MEMORY24,     PM, 0, 0x81,      NULL, "KWWWWr", "N",  AF,      Memory24Desc,
    "VendorLong",       ID_VENDORLONG,   PM, 0, 0x84,      NULL, "r",      NULL, BL|AV,   VendorLong,
    "Memory32",         ID_MEMORY32,     PM, 0, 0x85,      NULL, "KDDDDr", "N",  AF,      Memory32Desc,
    "Memory32Fixed",    ID_MEMORY32FIXED,PM, 0, 0x86,      NULL, "KDDr",   "N",  AF,      FixedMemory32Desc,
    "DWORDMemory",      ID_DWORDMEMORY,  PM, 0, 0x87,      NULL, "kkkkkKDDDDDbzr","OPQRSN",AF,  DWordMemDesc,
    "DWORDIO",          ID_DWORDIO,      PM, 0, 0x87,      NULL, "kkkkkDDDDDbzr", "OQRPT", AF,  DWordIODesc,
    "WORDIO",           ID_WORDIO,       PM, 0, 0x88,      NULL, "kkkkkWWWWWbzr", "OQRPT", AF,  WordIODesc,
    "WORDBusNumber",    ID_WORDBUSNUMBER,PM, 0, 0x88,      NULL, "kkkkWWWWWbzr",  "OQRP",  AF,  WordBusNumDesc,
    "Interrupt",        ID_INTERRUPT,    PM, 0, 0x89,      NULL, "kKKkbzr",       "OGHI",DD|AV, InterruptDesc,
    "QWORDMemory",	ID_QWORDMEMORY,	 PM, 0, 0x8a,      NULL, "kkkkkKQQQQQbzr","OPQRSN",AF,  QWordMemDesc,
    "QWORDIO",		ID_QWORDIO,	 PM, 0, 0x8a,	   NULL, "kkkkkQQQQQbzr", "OQRPT", AF,  QWordIODesc,

    NULL,               0,               0,  0, OP_NONE,   NULL, NULL, NULL, 0, NULL
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

BYTE OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\aslterms.c ===
/*** aslterms.c - Parse ASL terms
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/10/96
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

/***LP  DefinitionBlock - Generate code for DefinitionBlock
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    #define OFLAGS  (_O_BINARY | _O_CREAT | _O_RDWR | _O_TRUNC)
    #define PMODE   (_S_IREAD | _S_IWRITE)

    ENTER((1, "DefinitionBlock(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (fActionFL)
    {
        if (gpcodeScope->pcParent != NULL)
        {
            PrintTokenErr(ptoken, "Definition block cannot nest", TRUE);
            rc = ASLERR_NEST_DDB;
        }
        else if (strlen((PSZ)pArgs[1].pbDataBuff) != sizeof(ghdrDDB.Signature))
        {
            ERROR(("DefinitionBlock: DDB signature too long - %s",
                   pArgs[1].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[3].pbDataBuff) > sizeof(ghdrDDB.OEMID))
        {
            ERROR(("DefinitionBlock: OEM ID too long - %s",
                   pArgs[3].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[4].pbDataBuff) > sizeof(ghdrDDB.OEMTableID))
        {
            ERROR(("DefinitionBlock: OEM Table ID too long - %s",
                   pArgs[4].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else
        {
            memset(&ghdrDDB, 0, sizeof(DESCRIPTION_HEADER));
            memcpy(&ghdrDDB.Signature, pArgs[1].pbDataBuff,
                   sizeof(ghdrDDB.Signature));
            memcpy(&ghdrDDB.Revision, &pArgs[2].dwCodeValue,
                   sizeof(ghdrDDB.Revision));
            memcpy(ghdrDDB.OEMID, pArgs[3].pbDataBuff,
                   strlen((PSZ)pArgs[3].pbDataBuff));
            memcpy(ghdrDDB.OEMTableID, pArgs[4].pbDataBuff,
                   strlen((PSZ)pArgs[4].pbDataBuff));
            memcpy(&ghdrDDB.OEMRevision, &pArgs[5].dwCodeValue,
                   sizeof(ghdrDDB.OEMRevision));
            memcpy(ghdrDDB.CreatorID, STR_MS, sizeof(ghdrDDB.CreatorID));
            ghdrDDB.CreatorRev = VERSION_DWORD;
        }
    }
    else
    {
	int fhAML = 0;
        PBYTE pb;
        DWORD dwCodeOffset = sizeof(ghdrDDB);

        ASSERT(gpcodeScope->pcParent == NULL);
        ghdrDDB.Length = gpcodeRoot->dwCodeLen + sizeof(DESCRIPTION_HEADER);
        ghdrDDB.Checksum = (BYTE)(-(gpcodeRoot->bCodeChkSum +
                                    ComputeDataChkSum((PBYTE)&ghdrDDB,
                                                      sizeof(DESCRIPTION_HEADER))));

        if ((gpnschkHead == NULL) ||
            ((rc = ValidateNSChkList(gpnschkHead)) == ASLERR_NONE))
        {
            if (gpszAMLFile == NULL)
            {
                strncpy(gszAMLName, (PSZ)pArgs[0].pbDataBuff,
                        _MAX_FNAME - 1);
                gpszAMLFile = gszAMLName;
            }

            if ((fhAML = _open(gpszAMLFile, OFLAGS, PMODE))== -1)
            {
                ERROR(("DefinitionBlock: failed to open AML file - %s",
                       pArgs[0].pbDataBuff));
                rc = ASLERR_CREATE_FILE;
            }
            else if (_write(fhAML, &ghdrDDB, sizeof(ghdrDDB)) != sizeof(ghdrDDB))
            {
                ERROR(("DefinitionBlock: failed to write DDB header"));
                rc = ASLERR_WRITE_FILE;
            }
            else if ((rc = WriteAMLFile(fhAML, gpcodeRoot, &dwCodeOffset)) !=
                     ASLERR_NONE)
            {
                ERROR(("DefinitionBlock: failed to write AML file"));
            }
            else if ((pb = MEMALLOC(ghdrDDB.Length)) != NULL)
            {
                if (_lseek(fhAML, 0, SEEK_SET) == -1)
                {
                    ERROR(("DefinitionBlock: failed seeking to beginning of image file"));
                }
                else if (_read(fhAML, pb, ghdrDDB.Length) != (int)ghdrDDB.Length)
                {
                    ERROR(("DefinitionBlock: failed to read back image file"));
                }
                else if (ComputeDataChkSum(pb, ghdrDDB.Length) != 0)
                {
                    ERROR(("DefinitionBlock: failed to verify checksum of image file"));
                }
                MEMFREE(pb);
            }

            if (rc == ASLERR_NONE)
            {
                printf("%s(%s): Image Size=%ld, Image Checksum=0x%x\n\n",
                       MODNAME, pArgs[0].pbDataBuff, ghdrDDB.Length, ghdrDDB.Checksum);
            }

            if (fhAML != 0)
            {
                _close(fhAML);
            }
        }
        FreeCodeObjs(gpcodeRoot);
        gpcodeRoot = NULL;
    }

    EXIT((1, "DefinitionBlock=%d\n", rc));
    return rc;
}       //DefinitionBlock

/***LP  Include - Include an ASL file
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Include(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "Include(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    rc = ParseASLFile((PSZ)pArgs[0].pbDataBuff);

    EXIT((1, "Include=%d\n", rc));
    return rc;
}       //Include

/***LP  External - Declaring external object
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL External(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "External(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    gpcodeScope->pnsObj->ObjData.dwDataType = pArgs[1].dwCodeValue;

    EXIT((1, "External=%d\n", rc));
    return rc;
}       //External

/***LP  Method - Parse Method statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Method(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Method(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeValue > MAX_ARGS)
    {
        PrintTokenErr(ptoken, "Method has too many formal arguments", TRUE);
        rc = ASLERR_SYNTAX;
    }

    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_METHOD);
    gpcodeScope->pnsObj->ObjData.uipDataValue = pArgs[1].dwCodeValue;

    if ((rc == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_NOTSERIALIZED)) == ASLERR_NONE))
    {
        pArgs[1].dwCodeValue |= TermTable[pArgs[2].dwTermIndex].dwTermData &
                                0xff;
        pArgs[1].bCodeChkSum = (BYTE)pArgs[1].dwCodeValue;
    }

    EXIT((1, "Method=%d\n", rc));
    return rc;
}       //Method

/***LP  Field - Parse Field statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Field(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Field(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x0e, 1);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[1].dwCodeValue);

    EXIT((1, "Field=%d\n", rc));
    return rc;
}       //Field

/***LP  IndexField - Parse IndexField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "IndexField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x1c, 2);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[2].dwCodeValue);

    EXIT((1, "IndexField=%d\n", rc));
    return rc;
}       //IndexField

/***LP  BankField - Parse BankField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "BankField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x38, 3);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[3].dwCodeValue);

    EXIT((1, "BankField=%d\n", rc));
    return rc;
}       //BankField

/***LP  OpRegion - Parse OperationRegion statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "OpRegion(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_OPREGION);
    gpcodeScope->pnsObj->ObjData.uipDataValue =
        (pArgs[3].dwCodeType != CODETYPE_DATAOBJ)? 0xffffffff:
        (pArgs[3].pbDataBuff[0] == OP_BYTE)? pArgs[3].pbDataBuff[1]:
        (pArgs[3].pbDataBuff[0] == OP_WORD)? *(PWORD)(&pArgs[3].pbDataBuff[1]):
                                             *(PDWORD)(&pArgs[3].pbDataBuff[1]);

    EXIT((1, "OpRegion=%d\n", rc));
    return rc;
}       //OpRegion

/***LP  EISAID - Parse EISAID statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;
    DWORD dwEISAID;

    ENTER((1, "EISAID(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if ((rc = ComputeEISAID((PSZ)pArgs[0].pbDataBuff, &dwEISAID)) ==
        ASLERR_NONE)
    {
        DWORD dwLen;

        MEMFREE(pArgs[0].pbDataBuff);
        pArgs[0].pbDataBuff = NULL;
        dwLen = (dwEISAID & 0xffff0000)? sizeof(DWORD):
                (dwEISAID & 0xffffff00)? sizeof(WORD): sizeof(BYTE);
        SetIntObject(&pArgs[0], dwEISAID, dwLen);
        pArgs[0].pcParent->dwCodeValue = (dwLen == sizeof(DWORD))? OP_DWORD:
                                         (dwLen == sizeof(WORD))? OP_WORD:
                                                                  OP_BYTE;
    }
    else
    {
        ERROR(("EISAID: invalid EISAID - %s", pArgs[0].pbDataBuff));
    }

    EXIT((1, "EISAID=%d\n", rc));
    return rc;
}       //EISAID

/***LP  Match - Parse Match statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Match(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Match(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x02, 1);
    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x08, 3);

    EXIT((1, "Match=%d\n", rc));
    return rc;
}       //Match

/***LP  AccessAs - Parse AccessAs macro
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "AccessAs(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeValue > MAX_BYTE)
    {
        PrintTokenErr(ptoken, "Access Attribute can only be a byte value",
                      TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "AccessAs=%d\n", rc));
    return rc;
}       //AccessAs

/***LP  Else - Parse Else statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Else(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcPrevSibling = (PCODEOBJ)gpcodeScope->list.plistPrev;

    ENTER((1, "Else(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    if ((pcPrevSibling->dwCodeType != CODETYPE_ASLTERM) ||
        (TermTable[pcPrevSibling->dwTermIndex].lID != ID_IF))
    {
        PrintTokenErr(ptoken, "Else statement has no matching If", TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "Else=%d\n", rc));
    return rc;
}       //Else
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\asl.c ===
/*** asl.c - Main module of the ASL assembler
 *
 *  This program compiles the ASL language into AML (p-code).
 *
 *  Copyright (c) 1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     07/23/96
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

/***EP  main - main program
 *
 *  ENTRY
 *      icArg - command line arguments count
 *      apszArg - command line arguments array
 *
 *  EXIT-SUCCESS
 *      program terminates with return code ASLERR_NONE
 *  EXIT-FAILURE
 *      program terminates with negative error code
 */

int EXPORT main(int icArg, char **apszArg)
{
    int rc = ASLERR_NONE;

    ParseProgInfo(apszArg[0], &ProgInfo);
    icArg--;
    apszArg++;

    if ((ParseSwitches(&icArg, &apszArg, ArgTypes, &ProgInfo) != ARGERR_NONE) ||
        (gpszTabSig == NULL) && ((icArg != 1) || (gdwfASL & ASLF_CREAT_BIN)) ||
        (gpszTabSig != NULL) && ((icArg != 0) || (gdwfASL & ASLF_UNASM)))
    {
        MSG(("invalid command line options"));
        PrintUsage();
        rc = ASLERR_INVALID_PARAM;
    }
    else
    {
      #ifdef __UNASM
        PBYTE pbTable = NULL;
        DWORD dwTableSig = 0;
        PSZ psz;
      #endif

        OPENTRACE(gpszTraceFile);
        PrintLogo();

        if ((rc = InitNameSpace()) == ASLERR_NONE)
        {
          #ifdef __UNASM
            if (gdwfASL & ASLF_DUMP_BIN)
            {
                if (((rc = ReadBinFile(*apszArg, &pbTable, &dwTableSig)) ==
                     ASLERR_NONE) &&
                    (gpszLSTFile == NULL))
                {
                    strncpy(gszLSTName, (PSZ)&dwTableSig, sizeof(DWORD));
                    strcpy(&gszLSTName[sizeof(DWORD)], ".TXT");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_DUMP_NONASL | ASLF_UNASM;
                }
            }
            else if (gdwfASL & ASLF_UNASM)
            {
                gpszAMLFile = *apszArg;
                if (gpszLSTFile == NULL)
                {
                    strncpy(gszLSTName, gpszAMLFile, _MAX_FNAME - 1);
                    if ((psz = strchr(gszLSTName, '.')) != NULL)
                    {
                        *psz = '\0';
                    }
                    strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_GENSRC;
                }
            }
            else if (gpszTabSig != NULL)
            {
                gdwfASL |= ASLF_UNASM;
                if (IsWinNT())
                {
                    gdwfASL |= ASLF_NT;
                }

                _strupr(gpszTabSig);
                if ((strcmp(gpszTabSig, "DSDT") != 0) &&
                    (strcmp(gpszTabSig, "SSDT") != 0) &&
                    (strcmp(gpszTabSig, "PSDT") != 0))
                {
                    gdwfASL |= ASLF_DUMP_NONASL;
                }

                if (gpszLSTFile == NULL)
                {
                    gpszLSTFile = gszLSTName;
                    if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        if (strcmp(gpszTabSig, "*") == 0)
                        {
                            strcpy(gszLSTName, "ACPI");
                        }
                        else
                        {
                            strcpy(gszLSTName, gpszTabSig);
                        }
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".TXT");
                    }
                    else
                    {
                        strcpy(gszLSTName, gpszTabSig);
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                        gdwfASL |= ASLF_GENSRC;
                    }
                }

              #ifndef WINNT
                if (!(gdwfASL & ASLF_NT) && ((ghVxD = OpenVxD()) == NULL))
                {
                    ERROR(("option is not available"));
                    rc = ASLERR_OPEN_VXD;
                }
              #endif
            }
            else
            {
          #endif
                rc = ParseASLFile(*apszArg);
          #ifdef __UNASM
            }
          #endif
        }

        if (rc == ASLERR_NONE)
        {
            FILE *pfileOut;

            if (!(gdwfASL & ASLF_DUMP_NONASL))
            {
                if (gpszAMLFile == NULL)
                {
                    if (gpszTabSig == NULL)
                    {
                        ERROR(("%s has no DefinitionBlock", *apszArg));
                    }
                    else
                    {
                        strcpy(gszAMLName, gpszTabSig);
                        strcat(gszAMLName, ".AML");
                    }
                }

                if (gpszASMFile != NULL)
                {
                    if ((pfileOut = fopen(gpszASMFile, "w")) == NULL)
                    {
                        ERROR(("failed to open ASM file - %s", gpszASMFile));
                    }
                    else
                    {
                        gdwfASL |= ASLF_GENASM;
                        UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                  pfileOut);
                        gdwfASL &= ~ASLF_GENASM;
                        fclose(pfileOut);
                    }
                }
            }

            if (gpszLSTFile != NULL)
            {
              #ifdef __UNASM
                if (gdwfASL & ASLF_CREAT_BIN)
                {
                    rc = DumpTableBySig(NULL, *((PDWORD)gpszTabSig));
                }
                else if ((pfileOut = fopen(gpszLSTFile, "w")) == NULL)
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
                else
                {
                    if (gdwfASL & ASLF_DUMP_BIN)
                    {
                        ASSERT(pbTable != NULL);
                        ASSERT(dwTableSig != 0);
                        rc = DumpTable(pfileOut, pbTable, 0, dwTableSig);
                        MEMFREE(pbTable);
                    }
                    else if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        DWORD dwAddr;

                        if (((dwAddr = strtoul(gpszTabSig, &psz, 16)) != 0) &&
                            (*psz == 0))
                        {
                            rc = DumpTableByAddr(pfileOut, dwAddr);
                        }
                        else
                        {
                            rc = DumpTableBySig(pfileOut, *((PDWORD)gpszTabSig));
                        }
                    }
                    else
                    {
                        rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                       pfileOut);
                    }
                    fclose(pfileOut);
                }
              #else
                if ((pfileOut = fopen(gpszLSTFile, "w")) != NULL)
                {
                    rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                   pfileOut);
                    fclose(pfileOut);
                }
                else
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
              #endif
            }

            if (gpszNSDFile != NULL)
            {
                if ((pfileOut = fopen(gpszNSDFile, "w")) == NULL)
                {
                    ERROR(("failed to open NameSpace dump file - %s",
                           gpszNSDFile));
                }
                else
                {
                    fprintf(pfileOut, "Name Space Objects:\n");
                    DumpNameSpacePaths(gpnsNameSpaceRoot, pfileOut);
                    fclose(pfileOut);
                }
            }
        }

      #ifdef __UNASM
      #ifndef WINNT
        if (ghVxD != NULL)
        {
            CloseVxD(ghVxD);
            ghVxD = NULL;
        }
      #endif
      #endif

        CLOSETRACE();
    }

    return rc;
}       //main

#ifdef __UNASM
/***LP  ReadBinFile - Read table from binary file
 *
 *  ENTRY
 *      pszFile -> binary file name
 *      ppb -> to hold the binary buffer pointer
 *      pdwTableSig -> to hold the table signature
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig)
{
    int rc = ASLERR_NONE;
    FILE *pfileBin;
    DESCRIPTION_HEADER dh;

    ENTER((1, "ReadBinFile(File=%s,ppb=%p,pdwTableSig=%p)\n",
           pszFile, ppb, pdwTableSig));

    if ((pfileBin = fopen(pszFile, "rb")) == NULL)
    {
        ERROR(("ReadBinFile: failed to open file %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else if (fread(&dh, 1, sizeof(dh), pfileBin) < 2*sizeof(DWORD))
    {
        ERROR(("ReadBinFile: failed to read file %s", pszFile));
        rc = ASLERR_READ_FILE;
    }
    else if (fseek(pfileBin, 0, SEEK_SET) != 0)
    {
        ERROR(("ReadBinFile: failed to reset file %s", pszFile));
        rc = ASLERR_SEEK_FILE;
    }
    else
    {
        DWORD dwLen = (dh.Signature == SIG_LOW_RSDP)? sizeof(RSDP): dh.Length;

        if ((*ppb = MEMALLOC(dwLen)) == NULL)
        {
            ERROR(("ReadBinFile: failed to allocate table buffer for %s",
                   pszFile));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (fread(*ppb, dwLen, 1, pfileBin) != 1)
        {
            MEMFREE(*ppb);
            *ppb = NULL;
            ERROR(("ReadBinFile: failed to read file %s", pszFile));
            rc = ASLERR_READ_FILE;
        }
        else if (dh.Signature == SIG_LOW_RSDP)
        {
            *pdwTableSig = SIG_RSDP;
        }
        else
        {
            *pdwTableSig = dh.Signature;
        }
    }

    if (pfileBin != NULL)
    {
        fclose(pfileBin);
    }

    EXIT((1, "ReadBinFile=%d (pbTable=%p,TableSig=%s)\n",
          rc, *ppb, GetTableSigStr(*pdwTableSig)));
    return rc;
}       //ReadBinFile
#endif

/***LP  InitNameSpace - Initialize NameSpace
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InitNameSpace(VOID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "InitNameSpace()\n"));

    if ((rc = CreateNameSpaceObj(NULL, "\\", NULL, NULL, NULL, NSF_EXIST_ERR))
        == ASLERR_NONE)
    {
        static struct _defobj {
            PSZ   pszName;
            ULONG dwObjType;
        } DefinedRootObjs[] = {
            "_GPE", OBJTYPE_UNKNOWN,
            "_PR",  OBJTYPE_UNKNOWN,
            "_SB",  OBJTYPE_UNKNOWN,
            "_SI",  OBJTYPE_UNKNOWN,
            "_TZ",  OBJTYPE_UNKNOWN,
            "_REV", OBJTYPE_INTDATA,
            "_OS",  OBJTYPE_STRDATA,
            "_GL",  OBJTYPE_MUTEX,
            NULL,   0
        };
        int i;
        PNSOBJ pns;

        gpnsCurrentScope = gpnsNameSpaceRoot;

        for (i = 0; DefinedRootObjs[i].pszName != NULL; ++i)
        {
            if ((rc = CreateNameSpaceObj(NULL, DefinedRootObjs[i].pszName, NULL,
                                         NULL, &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = DefinedRootObjs[i].dwObjType;
            }
            else
            {
                break;
            }
        }
    }

    EXIT((1, "InitNameSpace=%d\n", rc));
    return rc;
}       //InitNameSpace

/***LP  PrintLogo - Print logo message
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintLogo(VOID)
{
    if ((gdwfASL & ASLF_NOLOGO) == 0)
    {
        printf("%s Version %d.%d.%d%s [%s, %s]\n%s\n",
               STR_PROGDESC, VERSION_MAJOR, VERSION_MINOR, VERSION_RELEASE,
             #ifdef WINNT
               "NT",
	     #else
	       "",
	     #endif
               __DATE__, __TIME__, STR_COPYRIGHT);
	printf("Compliant with ACPI 1.0 specification\n\n");
    }
}       //PrintLogo

/***LP  PrintHelp - Print help messages
 *
 *  ENTRY
 *      ppszArg -> pointer to argument (not used)
 *      pAT -> argument type structure (not used)
 *
 *  EXIT
 *      program terminated with exit code 0
 */

int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT)
{
    DEREF(ppszArg);
    DEREF(pAT);

    PrintLogo();
    PrintUsage();
    printf("\t?            - Print this help message.\n");
    printf("\tnologo       - Supress logo banner.\n");
    printf("\tFo=<AMLFile> - Override the AML file name in the DefinitionBlock.\n");
    printf("\tFa=<ASMFile> - Generate .ASM file with the name <ASMFile>.\n");
    printf("\tFl=<LSTFile> - Generate .LST file with the name <LSTFile>.\n");
    printf("\tFn=<NSDFile> - Generate NameSpace Dump file with the name <NSDFile>.\n");
  #ifdef __UNASM
    printf("\td            - Dump the binary file in text form.\n");
    printf("\tu            - Unassemble AML file to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\ttab=<TabSig> - Unassemble ASL table to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\t               Dump non ASL table to an .TXT file.\n");
    printf("\t               If <TabSig> is '*', all tables are dump to ACPI.TXT.\n");
    printf("\t               <TabSig> can also be the physical address of the table.\n");
    printf("\tc            - Create binary files from tables.\n");
  #endif
  #ifdef TRACING
    printf("\tt=<n>        - Enable tracing at trace level n.\n");
    printf("\tl=<LogFile>  - Overriding the default trace log file name.\n");
  #endif
    exit(0);

    return ASLERR_NONE;
}       //PrintHelp

/***LP  PrintUsage - Print program usage syntax
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintUsage(VOID)
{
    printf("Usage:\n%s /?\n", MODNAME);
  #ifdef __UNASM
    printf("%s [/nologo] /d <BinFile>\n", MODNAME);
    printf("%s [/nologo] /u [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <AMLFile>\n",
           MODNAME);
    printf("%s [/nologo] /tab=<TabSig> [/c] [/Fa=<ASMfile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>]\n",
           MODNAME);
  #endif
  #ifdef TRACING
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] [/t=<n>] [/l=<LogFile>] <ASLFile>\n",
           MODNAME);
  #else
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <ASLFile>\n",
           MODNAME);
  #endif
  printf("\n");
}       //PrintUsage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\misc.c ===
/*** misc.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

/***LP  ValidASLNameSeg - Check if the token is an ASL NameSeg
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *      icbLen - length of the token to be considered a NameSeg
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen)
{
    BOOL rc = TRUE;
    int i, j;
    static PSZ apszReservedNames[] = {
        "ADR", "ALN", "BAS", "BBN", "BCL", "BCM", "BDN", "BIF", "BM_", "BST",
        "BTP", "CID", "CRS", "CRT", "DCK", "DCS", "DDC", "DDN", "DEC", "DGS",
        "DIS", "DMA", "DOD", "DOS", "DSS", "EC_", "EJD", "FDE", "FDI", "GL_",
        "GLK", "GPE", "GRA", "GTF", "GTM", "HE_", "HID", "INI", "INT", "IRC",
        "LCK", "LEN", "LID", "LL_", "MAF", "MAX", "MEM", "MIF", "MIN", "MSG",
        "OFF", "ON_", "OS_", "PCL", "PIC", "PR_", "PRS", "PRT", "PRW", "PSC",
        "PSL", "PSR", "PSV", "PSW", "PTS", "PWR", "REG", "REV", "RMV", "RNG",
        "ROM", "RQ_", "RW_", "SB_", "SBS", "SCP", "SHR", "SI_", "SIZ", "SRS",
        "SST", "STA", "STM", "SUN", "TC1", "TC2", "TMP", "TRA", "TSP", "TYP",
        "TZ_", "UID", "WAK", "AC0", "AC1", "AC2", "AC3", "AC4", "AC5", "AC6",
        "AC7", "AC8", "AC9", "AL0", "AL1", "AL2", "AL3", "AL4", "AL5", "AL6",
        "AL7", "AL8", "AL9", "EC0", "EC1", "EC2", "EC3", "EC4", "EC5", "EC6",
        "EC7", "EC7", "EC9", "EJ0", "EJ1", "EJ2", "EJ3", "EJ4",
        "Exx", "Lxx", "Qxx",
        "S0_", "S1_", "S2_", "S3_", "S4_", "S5_",
        "S0D", "S1D", "S2D", "S3D", "S4D", "S5D",
        "PR0", "PR1", "PR2",
        "PS0", "PS1", "PS2", "PS3"
    };
    #define NUM_RESERVED_NAMES  (sizeof(apszReservedNames)/sizeof(PSZ))

    ENTER((1, "ValidASLNameSeg(ptoken=%p, Token=%s,Len=%d)\n",
           ptoken, pszToken, icbLen));

    pszToken[0] = (char)toupper(pszToken[0]);
    if ((icbLen > sizeof(NAMESEG)) || !ISLEADNAMECHAR(pszToken[0]))
    {
        rc = FALSE;
    }
    else
    {
        for (i = 1; i < icbLen; ++i)
        {
            pszToken[i] = (char)toupper(pszToken[i]);
            if (!ISNAMECHAR(pszToken[i]))
            {
                rc = FALSE;
                break;
            }
        }

        if ((rc == TRUE) && (*pszToken == '_'))
        {
            char szName[sizeof(NAMESEG)] = "___";

            memcpy(szName, &pszToken[1], icbLen - 1);
            for (i = 0; i < NUM_RESERVED_NAMES; ++i)
            {
                if (strcmp(szName, apszReservedNames[i]) == 0)
                    break;
                else
                {
                    for (j = 0; j < sizeof(NAMESEG) - 1; ++j)
                    {
                        if (apszReservedNames[i][j] != szName[j])
                        {
                            if ((apszReservedNames[i][j] != 'x') ||
                                !isxdigit(szName[j]))
                            {
                                break;
                            }
                        }
                    }

                    if (j == sizeof(NAMESEG) - 1)
                    {
                        break;
                    }
                }
            }

            if (i == NUM_RESERVED_NAMES)
            {
                PrintTokenErr(ptoken, "not a valid reserved NameSeg", FALSE);
            }
        }
    }

    EXIT((1, "ValidASLNameSeg=%d\n", rc));
    return rc;
}       //ValidASLNameSeg

/***LP  ValidASLName - Check if the token is an ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken)
{
    BOOL rc = TRUE;
    PSZ psz1, psz2 = NULL;
    int icbLen;

    ENTER((1, "ValidASLName(ptoken=%p,Token=%s)\n", ptoken, pszToken));

    if (*pszToken == CH_ROOT_PREFIX)
    {
        pszToken++;
    }
    else
    {
        while (*pszToken == CH_PARENT_PREFIX)
        {
            pszToken++;
        }
    }

    for (psz1 = pszToken;
         (rc == TRUE) && (psz1 != NULL) && (*psz1 != '\0');
         psz1 = psz2)
    {
        psz2 = strchr(psz1, CH_NAMESEG_SEP);
        icbLen = (psz2 != NULL)? (int)(psz2 - psz1): strlen(psz1);
        if (((rc = ValidASLNameSeg(ptoken, psz1, icbLen)) == TRUE) &&
            (psz2 != NULL))
        {
            psz2++;
        }
    }

    EXIT((1, "ValidASLName=%d\n", rc));
    return rc;
}       //ValidASLName

/***LP  EncodeName - Encode name string
 *
 *  ENTRY
 *      pszName -> name string
 *      pbBuff -> buffer to hold name encoding
 *      pdwLen -> initially contains buffer size, but will be updated to show
 *                actual encoding length
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen)
{
    int rc = ASLERR_NONE;
    PBYTE pb = pbBuff;
    PSZ psz;
    int icNameSegs, i;

    ENTER((1, "EncodeName(Name=%s,pbBuff=%p,Len=%d)\n",
           pszName, pbBuff, *pdwLen));

    if (*pszName == CH_ROOT_PREFIX)
    {
        if (*pdwLen >= 1)
        {
            *pb = OP_ROOT_PREFIX;
            pb++;
            (*pdwLen)--;
            pszName++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        while (*pszName == CH_PARENT_PREFIX)
        {
            if (*pdwLen >= 1)
            {
                *pb = OP_PARENT_PREFIX;
                pb++;
                (*pdwLen)--;
                pszName++;
            }
            else
            {
                rc = ASLERR_NAME_TOO_LONG;
                break;
            }
        }
    }

    for (psz = pszName, icNameSegs = 0; (psz != NULL) && (*psz != '\0');)
    {
        icNameSegs++;
        if ((psz = strchr(psz, CH_NAMESEG_SEP)) != NULL)
            psz++;
    }

    if (icNameSegs > 255)
        rc = ASLERR_NAME_TOO_LONG;
    else if (icNameSegs > 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*icNameSegs + 2)
        {
            *pb = OP_MULTI_NAME_PREFIX;
            pb++;
            *pb = (BYTE)icNameSegs;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else if (icNameSegs == 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*2 + 1)
        {
            *pb = OP_DUAL_NAME_PREFIX;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (rc == ASLERR_NONE)
    {
        //
        // If we have only name prefix characters, we must put a null name
        // separator to tell the boundary from the next opcode which may happen
        // to be a NameSeg.
        //
        if (icNameSegs == 0)
        {
            *pb = 0;
            pb++;
        }
        else
        {
            while (icNameSegs > 0)
            {
                *((PDWORD)pb) = NAMESEG_BLANK;
                for (i = 0;
                     (i < sizeof(NAMESEG)) && ISNAMECHAR(*pszName);
                     ++i, pszName++)
                {
                    pb[i] = *pszName;
                }

                if (*pszName == CH_NAMESEG_SEP)
                    pszName++;

                pb += 4;
                icNameSegs--;
            }
        }

        *pdwLen = (DWORD)(pb - pbBuff);
    }

    EXIT((1, "EncodeName=%d (Len=%d)\n", rc, *pdwLen));
    return rc;
}       //EncodeName

/***LP  EncodePktLen - Encode packet length
 *
 *  ENTRY
 *      dwCodeLen - actual code length
 *      pdwPktLen -> to hold the encoded packet length
 *      picbEncoding -> to hold the number of encoding bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding)
{
    int rc = ASLERR_NONE;

    ENTER((1, "EncodePktLen(CodeLen=%ld,pdwPktLen=%p)\n",
           dwCodeLen, pdwPktLen));

    if (dwCodeLen <= 0x3f)
    {
        *pdwPktLen = dwCodeLen;
        *picbEncoding = 1;
    }
    else
    {
        *pdwPktLen = (dwCodeLen & 0x0ffffff0) << 4;
        *pdwPktLen |= (dwCodeLen & 0xf);

        if (dwCodeLen <= 0x0fff)
            *picbEncoding = 2;
        else if (dwCodeLen <= 0x0fffff)
            *picbEncoding = 3;
        else if (dwCodeLen <= 0x0fffffff)
            *picbEncoding = 4;
        else
            rc = ASLERR_PKTLEN_TOO_LONG;

        if (rc == ASLERR_NONE)
            *pdwPktLen |= (*picbEncoding - 1) << 6;
    }

    EXIT((1, "EncodePktLen=%d (Encoding=%lx,icbEncoding=%d)\n",
          rc, *pdwPktLen, *picbEncoding));
    return rc;
}       //EncodePktLen

/***LP  EncodeKeywords - Encode keyword arguments
 *
 *  ENTRY
 *      pArgs -> argument array
 *      dwSrcArgs - source argument bit vector
 *      iDstArgNum - destination argument number
 *
 *  EXIT
 *      None
 */

VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum)
{
    int i;
    DWORD dwData = 0;

    ENTER((1, "EncodeKeywords(pArgs=%p,SrcArgs=%lx,DstArgNum=%d)\n",
           pArgs, dwSrcArgs, iDstArgNum));

    for (i = 0; i < MAX_ARGS; ++i)
    {
        if (dwSrcArgs & (1 << i))
        {
            if (pArgs[i].dwCodeType == CODETYPE_KEYWORD)
            {
                dwData |= TermTable[pArgs[i].dwTermIndex].dwTermData & 0xff;
            }
            else if (pArgs[i].dwCodeType == CODETYPE_INTEGER)
            {
                pArgs[i].dwCodeType = CODETYPE_UNKNOWN;
                dwData |= pArgs[i].dwCodeValue;
            }
            else
            {
                ASSERT(pArgs[i].dwCodeType == CODETYPE_INTEGER);
            }
        }
    }

    SetIntObject(&pArgs[iDstArgNum], dwData, sizeof(BYTE));

    EXIT((1, "EncodeKeywords!\n"));
}       //EncodeKeywords

/***LP  DecodeName - Decode name encoding back to a name string
 *
 *  ENTRY
 *      pb -> name encoding buffer
 *      pszName -> to hold the decoded name string
 *      iLen - length of name string buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen)
{
    int rc = ASLERR_NONE;
    int i = 0, icNameSegs;

    ENTER((1, "DecodeName(pb=%p,pszName=%p,iLen=%d)\n", pb, pszName, iLen));

    iLen--;     //reserve one space for NULL character
    pszName[iLen] = '\0';
    if (*pb == OP_ROOT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_ROOT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    while (*pb == OP_PARENT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_PARENT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (*pb == OP_DUAL_NAME_PREFIX)
    {
        icNameSegs = 2;
        pb++;
    }
    else if (*pb == OP_MULTI_NAME_PREFIX)
    {
        pb++;
        icNameSegs = (int)(*pb);
        pb++;
    }
    else if (*pb == 0)
    {
        icNameSegs = 0;
    }
    else
    {
        icNameSegs = 1;
    }

    if (icNameSegs > 0)
    {
        do
        {
            if ((int)(i + sizeof(NAMESEG)) <= iLen)
            {
                strncpy(&pszName[i], (PCHAR)pb, sizeof(NAMESEG));
                pb += sizeof(NAMESEG);
                i += sizeof(NAMESEG);
                icNameSegs--;

                if (icNameSegs > 0)
                {
                    if (i < iLen)
                    {
                        pszName[i] = CH_NAMESEG_SEP;
                        i++;
                    }
                    else
                        rc = ASLERR_NAME_TOO_LONG;
                }
            }
            else
                rc = ASLERR_NAME_TOO_LONG;

        } while ((rc == ASLERR_NONE) && (icNameSegs > 0));
    }

    if (rc == ASLERR_NONE)
        pszName[i] = '\0';
    else
    {
        ERROR(("DecodeName: Name is too long - %s", pszName));
    }

    EXIT((1, "DecodeName=%d (Name=%s)\n", rc, pszName));
    return rc;
}       //DecodeName

/***LP  SetDefMissingKW - Set default missing keyword
 *
 *  ENTRY
 *      pArg -> argument code object
 *      dwDefID - default ID to be used if argument is missing
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID)
{
    int rc = ASLERR_NONE;

    ENTER((2, "SetDefMissingKW(pArg=%p,ID=%d)\n", pArg, dwDefID));

    if (pArg->dwfCode & CF_MISSING_ARG)
    {
        pArg->dwfCode &= ~CF_MISSING_ARG;
        pArg->dwCodeType = CODETYPE_KEYWORD;
        pArg->dwCodeValue = dwDefID;
        rc = LookupIDIndex(pArg->dwCodeValue, &pArg->dwTermIndex);
    }

    EXIT((2, "SetDefMissingKW=%d (TermIndex=%ld)\n", rc, pArg->dwTermIndex));
    return rc;
}       //SetDefMissingKW

/***LP  SetIntObject - Set an object to type integer
 *
 *  ENTRY
 *      pc -> object
 *      dwData - integer data
 *      dwLen - data length
 *
 *  EXIT
 *      None
 */

VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen)
{
    ENTER((2, "SetIntObject(pc=%p,Data=%x,Len=%d)\n", pc, dwData, dwLen));

    pc->dwCodeType = CODETYPE_INTEGER;
    pc->dwCodeValue = dwData;
    pc->dwDataLen = pc->dwCodeLen = dwLen;
    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&dwData, dwLen);

    EXIT((2, "SetIntObject!\n"));
}       //SetIntObject

/***LP  ComputeChildChkSumLen - Compute len and chksum of child for parent
 *
 *  ENTRY
 *      pcParent -> code block of parent
 *      pcChild -> code block of child
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild)
{
    ENTER((1, "ComputeChildChkSumLen(pcParent=%p,pcChild=%p,ChildLen=%ld,ChildChkSum=%x)\n",
           pcParent, pcChild, pcChild->dwCodeLen, pcChild->bCodeChkSum));

    pcParent->dwCodeLen += pcChild->dwCodeLen;
    pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                   pcChild->bCodeChkSum);

    if (pcChild->dwCodeType == CODETYPE_ASLTERM)
    {
        int i;

        for (i = 0; i < OPCODELEN(pcChild->dwCodeValue); ++i)
        {
            pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                           ((PBYTE)(&pcChild->dwCodeValue))[i]);
            pcParent->dwCodeLen++;
        }
    }

    EXIT((1, "ComputeChildChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcParent->dwCodeLen, pcParent->bCodeChkSum));
}       //ComputeChildChkSumLen

/***LP  ComputeArgsChkSumLen - Compute length and checksum of arguments
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i;

    ENTER((1, "ComputeArgsChkSumLen(pcode=%p)\n", pcode));

    ASSERT((pcode->dwCodeType == CODETYPE_ASLTERM) ||
           (pcode->dwCodeType == CODETYPE_USERTERM));
    //
    // Sum the length of arguments
    //
    for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
         i < (int)pcode->dwDataLen;
         ++i)
    {
        ComputeChildChkSumLen(pcode, &pc[i]);
    }

    EXIT((1, "ComputeArgsChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeArgsChkSumLen

/***LP  ComputeChkSumLen - Compute length and checksum of code block
 *
 *  Compute the length of the given code block and store it in the dwCodeLen
 *  field of the code block.
 *  Compute the checksum of the given code block and store it in the
 *  bCodeChkSum field of the code block.
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      This function does not count the opcode length of the given ASLTERM.
 *      The caller is responsible for adding it if necessary.
 */

VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i, j;

    ENTER((1, "ComputeChkSumLen(pcode=%p)\n", pcode));

    ASSERT(pcode->dwCodeType == CODETYPE_ASLTERM);

    if (!(TermTable[pcode->dwTermIndex].dwfTermClass & TC_COMPILER_DIRECTIVE))
    {
        ComputeArgsChkSumLen(pcode);
    }
    //
    // Sum the lengths of children
    //
    for (pc = pcode->pcFirstChild; pc != NULL;)
    {
        ComputeChildChkSumLen(pcode, pc);

        if ((PCODEOBJ)pc->list.plistNext == pcode->pcFirstChild)
            pc = NULL;
        else
            pc = (PCODEOBJ)pc->list.plistNext;
    }
    //
    // If this term requires a PkgLength encoding, we must include it in the
    // length.
    //
    if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
    {
        DWORD dwPktLen;

        if (pcode->dwCodeLen <= 0x3f - 1)
            pcode->dwCodeLen++;
        else if (pcode->dwCodeLen <= 0xfff - 2)
            pcode->dwCodeLen += 2;
        else if (pcode->dwCodeLen <= 0xfffff - 3)
            pcode->dwCodeLen += 3;
        else
            pcode->dwCodeLen += 4;

        if (EncodePktLen(pcode->dwCodeLen, &dwPktLen, &j) == ASLERR_NONE)
        {
            for (i = 0; i < j; ++i)
            {
                pcode->bCodeChkSum = (BYTE)(pcode->bCodeChkSum +
                                            ((PBYTE)&dwPktLen)[i]);
            }
        }
    }

    EXIT((1, "ComputeChkSumLen! (len=%ld,ChkSum=%x)\n",
	  pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeChkSumLen

/***LP  ComputeDataChkSum - Compute checksum of a data buffer
 *
 *  ENTRY
 *      pb -> data buffer
 *      dwLen - size of data buffer
 *
 *  EXIT
 *      returns the checksum byte
 */

BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen)
{
    BYTE bChkSum = 0;

    ENTER((1, "ComputeDataChkSum(pb=%p,Len=%ld)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT((1, "ComputeDataChkSum=%x\n", bChkSum));
    return bChkSum;
}       //ComputeChkSumLen

/***LP  ComputeEISAID - Compute EISA ID from the ID string
 *
 *  ENTRY
 *      pszID -> ID string
 *      pdwEISAID -> to hold the EISA ID
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ComputeEISAID(pszID=%s,pdwEISAID=%p)\n", pszID, pdwEISAID));

    if (*pszID == '*')
        pszID++;

    if (strlen(pszID) != 7)
        rc = ASLERR_INVALID_EISAID;
    else
    {
        int i;

        *pdwEISAID = 0;
        for (i = 0; i < 3; ++i)
        {
            if ((pszID[i] < '@') || (pszID[i] > '_'))
            {
                rc = ASLERR_INVALID_EISAID;
                break;
            }
            else
            {
                (*pdwEISAID) <<= 5;
                (*pdwEISAID) |= pszID[i] - '@';
            }
        }

        if (rc == ASLERR_NONE)
        {
            PSZ psz;
            WORD wData;

            (*pdwEISAID) = ((*pdwEISAID & 0x00ff) << 8) |
                           ((*pdwEISAID & 0xff00) >> 8);
            wData = (WORD)strtoul(&pszID[3], &psz, 16);

            if (*psz != '\0')
            {
                rc = ASLERR_INVALID_EISAID;
            }
            else
            {
                wData = (WORD)(((wData & 0x00ff) << 8) |
                               ((wData & 0xff00) >> 8));
                (*pdwEISAID) |= (DWORD)wData << 16;
            }
        }
    }

    EXIT((1, "ComputeEISAID=%d (EISAID=%lx)\n", rc, *pdwEISAID));
    return rc;
}       //ComputeEISAID

/***LP  LookupIDIndex - lookup the given ID in the TermTable and return index
 *
 *  ENTRY
 *      lID - ID to look up
 *      pdwTermIndex -> to hold term index found
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((1, "LookupIDIndex(ID=%ld,pdwTermIndex=%p)\n", lID, pdwTermIndex));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if (lID == TermTable[i].lID)
        {
            *pdwTermIndex = (DWORD)i;
            break;
        }
    }

    if (TermTable[i].pszID == NULL)
    {
        ERROR(("LookupIDIndex: failed to find ID %ld in TermTable", lID));
        rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "LookupIDIndex=%d (Index=%d)\n", rc, *pdwTermIndex));
    return rc;
}       //LookupIDIndex

/***LP  WriteAMLFile - Write code block to AML file
 *
 *  ENTRY
 *      fhAML - AML image file handle
 *      pcode -> code block
 *      pdwOffset -> file offset
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset)
{
    int rc = ASLERR_NONE;
    int iLen;
    DWORD dwPktLen, dwLen;

    ENTER((1, "WriteAMLFile(fhAML=%x,pcode=%p,FileOffset=%x)\n",
           fhAML, pcode, *pdwOffset));

    if (pcode->dwfCode & CF_CREATED_NSOBJ)
    {
        ASSERT(pcode->pnsObj != NULL);
        ASSERT(pcode->pnsObj->dwRefCount == 0);
        pcode->pnsObj->dwRefCount = *pdwOffset;
    }

    switch (pcode->dwCodeType)
    {
        case CODETYPE_ASLTERM:
            if (pcode->dwCodeValue != OP_NONE)
            {
                iLen = OPCODELEN(pcode->dwCodeValue);
                *pdwOffset += iLen;

                if (_write(fhAML, &pcode->dwCodeValue, iLen) != iLen)
                    rc = ASLERR_WRITE_FILE;
                else if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
                {
                    if ((rc = EncodePktLen(pcode->dwCodeLen, &dwPktLen, &iLen))
                        == ASLERR_NONE)
                    {
                        *pdwOffset += iLen;
                        if (_write(fhAML, &dwPktLen, iLen) != iLen)
                        {
                            rc = ASLERR_WRITE_FILE;
                        }
                    }
                }

                if (rc == ASLERR_NONE)
                {
                    if (pcode->pbDataBuff != NULL)
                    {
                        PCODEOBJ pc;
                        int i;

                        for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                             i < (int)pcode->dwDataLen;
                             ++i)
                        {
                            if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset))
                                != ASLERR_NONE)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            if (rc == ASLERR_NONE)
            {
                PCODEOBJ pc;

                for (pc = pcode->pcFirstChild; pc != NULL;)
                {
                    if ((rc = WriteAMLFile(fhAML, pc, pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }

                    if ((PCODEOBJ)pc->list.plistNext ==
                        pcode->pcFirstChild)
                    {
                        pc = NULL;
                    }
                    else
                        pc = (PCODEOBJ)pc->list.plistNext;
                }
            }
            break;

        case CODETYPE_USERTERM:
            if (pcode->pbDataBuff != NULL)
            {
                PCODEOBJ pc;
                int i;

                for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                     i < (int)pcode->dwDataLen;
                     ++i)
                {
                    if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }
                }
            }
            break;

        case CODETYPE_FIELDOBJ:
            dwPktLen = pcode->dwCodeValue? sizeof(NAMESEG): sizeof(BYTE);
            dwLen = ((pcode->dwDataLen & 0xc0) >> 6) + 1;
            *pdwOffset += dwPktLen + dwLen;
            if ((_write(fhAML, &pcode->dwCodeValue, dwPktLen) !=
                 (int)dwPktLen) ||
                (_write(fhAML, &pcode->dwDataLen, dwLen) != (int)dwLen))
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_NAME:
        case CODETYPE_DATAOBJ:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, pcode->pbDataBuff, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_INTEGER:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, &pcode->dwCodeValue, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_UNKNOWN:
        case CODETYPE_KEYWORD:
            break;

        default:
            ERROR(("WriteAMLFile: unexpected code type - %x",
                   pcode->dwCodeType));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "WriteAMLFile=%d\n", rc));
    return rc;
}       //WriteAMLFile

/***LP  FreeCodeObjs - free code object tree
 *
 *  ENTRY
 *      pcodeRoot -> root of code object subtree to be free
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot)
{
    PCODEOBJ pcode, pcodeNext;

    ENTER((1, "FreeCodeObjs(pcodeRoot=%p,Type=%d,Term=%s,Buff=%p)\n",
           pcodeRoot, pcodeRoot->dwCodeType,
           pcodeRoot->dwCodeType == CODETYPE_ASLTERM?
               TermTable[pcodeRoot->dwTermIndex].pszID: "<null>",
           pcodeRoot->pbDataBuff));
    //
    // Free all my children
    //
    for (pcode = pcodeRoot->pcFirstChild; pcode != NULL; pcode = pcodeNext)
    {
        if ((pcodeNext = (PCODEOBJ)pcode->list.plistNext) ==
            pcodeRoot->pcFirstChild)
        {
            pcodeNext = NULL;
        }

        FreeCodeObjs(pcode);
    }

    if (pcodeRoot->pbDataBuff != NULL)
        MEMFREE(pcodeRoot->pbDataBuff);

    MEMFREE(pcodeRoot);

    EXIT((1, "FreeCodeObjs!\n"));
}       //FreeCodeObjs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\unasm.c ===
/*** unasm.c - Unassemble AML file and convert to Intel .ASM file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

/***LP  UnAsmFile - Unassemble AML file
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFile(PSZ pszAMLName, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PBYTE pb = NULL;
    DWORD dwAddr = 0;
    int fhAML = 0;
    ULONG dwLen = 0;

    ENTER((1, "UnAsmFile(AMLName=%s,pfileOut=%p)\n",
           pszAMLName, pfileOut));
    ASSERT(pfileOut != NULL);

    if (gpszAMLFile != NULL)
    {
        if ((fhAML = _open(gpszAMLFile, _O_BINARY | _O_RDONLY)) == -1)
        {
            ERROR(("UnAsmFile: failed to open AML file - %s", gpszAMLFile));
            rc = ASLERR_OPEN_FILE;
        }
        else if ((pb = MEMALLOC(sizeof(DESCRIPTION_HEADER))) == NULL)
        {
            ERROR(("UnAsmFile: failed to allocate description header block"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (_read(fhAML, pb, sizeof(DESCRIPTION_HEADER)) !=
                 sizeof(DESCRIPTION_HEADER))
        {
            ERROR(("UnAsmFile: failed to read description header block"));
            rc = ASLERR_READ_FILE;
        }
        else if (_lseek(fhAML, 0, SEEK_SET) == -1)
        {
            ERROR(("UnAsmFile: failed seeking to beginning of AML file"));
            rc = ASLERR_SEEK_FILE;
        }
        else
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
            MEMFREE(pb);
            if ((pb = MEMALLOC(dwLen)) == NULL)
            {
                ERROR(("UnAsmFile: failed to allocate AML file buffer"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else if (_read(fhAML, pb, dwLen) != (int)dwLen)
            {
                ERROR(("UnAsmFile: failed to read AML file"));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }
  #ifdef __UNASM
    else
    {
        DWORD dwTableSig = (gdwfASL & ASLF_DUMP_NONASL)? *((PDWORD)pszAMLName):
                                                         *((PDWORD)gpszTabSig);

        ASSERT(gpszTabSig != NULL);

        if ((pb = GetTableBySig(dwTableSig, &dwAddr)) != NULL)
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
        }
        else
        {
            rc = ASLERR_GET_TABLE;
        }
    }
  #endif

    if (rc == ASLERR_NONE)
    {
        rc = UnAsmAML(pszAMLName, dwAddr, pb, pfileOut);
    }

    if (pb != NULL)
    {
        MEMFREE(pb);
    }

    if (fhAML != 0)
    {
        _close(fhAML);
    }

    EXIT((1, "UnAsmFile=%d\n", rc));
    return rc;
}       //UnAsmFile

/***LP  BuildNameSpace - Do a NameSpace building pass
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb)
{
    #define MAX_NUM_NAMES   4
    int rc = ASLERR_NONE;
    static PSZ pszNames[MAX_NUM_NAMES] = {NULL};
    static DWORD adwAddr[MAX_NUM_NAMES] = {0};
    int i;

    ENTER((2, "BuildNameSpace(AMLName=%s,Addr=%x,pb=%p)\n",
           pszAMLName, dwAddr, pb));

    for (i = 0; i < MAX_NUM_NAMES; ++i)
    {
        if (pszNames[i] == NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pb)->Length;

            //
            // Do a pass to build NameSpace.
            //
            pszNames[i] = pszAMLName;
            adwAddr[i] = dwAddr;
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + dwLen - sizeof(DESCRIPTION_HEADER), NULL);
            break;
        }
        else if ((strcmp(pszAMLName, pszNames[i]) == 0) &&
                 (dwAddr == adwAddr[i]))
        {
            break;
        }
    }

    if (i >= MAX_NUM_NAMES)
    {
        ERROR(("BuildNameSpace: Too many AML tables"));
        rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "BuildNameSpace=%d\n", rc));
    return rc;
}       //BuildNameSpace

/***LP  UnAsmAML - Unassemble AML buffer
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PDESCRIPTION_HEADER pdh = (PDESCRIPTION_HEADER)pb;

    ENTER((2, "UnAsmAML(AMLName=%s,Addr=%x,pb=%p,pfileOut=%p)\n",
           pszAMLName, dwAddr, pb, pfileOut));

    ASSERT(gpnsNameSpaceRoot != NULL);
    gpnsCurrentOwner = NULL;
    gpnsCurrentScope = gpnsNameSpaceRoot;

    if (ComputeDataChkSum(pb, pdh->Length) != 0)
    {
        ERROR(("UnAsmAML: failed to verify AML checksum"));
        rc = ASLERR_CHECKSUM;
    }
    else if ((rc = BuildNameSpace(pszAMLName, dwAddr, pb)) == ASLERR_NONE)
    {
        gpbOpTop = gpbOpBegin = pb;
        if ((rc = UnAsmHeader(pszAMLName, pdh, pfileOut)) == ASLERR_NONE)
        {
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + pdh->Length - sizeof(DESCRIPTION_HEADER),
                            pfileOut);

            if ((rc == ASLERR_NONE) && (pfileOut != NULL))
            {
                fprintf(pfileOut, "\n");
            }
        }
    }

    EXIT((2, "UnAsmAML=%d\n", rc));
    return rc;
}       //UnAsmAML

/***LP  UnAsmHeader - Unassemble table header
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pdh -> DESCRIPTION_HEADER
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    char szSig[sizeof(pdh->Signature) + 1] = {0};
    char szOEMID[sizeof(pdh->OEMID) + 1] = {0};
    char szOEMTableID[sizeof(pdh->OEMTableID) + 1] = {0};
    char szCreatorID[sizeof(pdh->CreatorID) + 1] = {0};

    ENTER((2, "UnAsmHeader(AMLName=%s,pdh=%p,pfileOut=%p)\n",
           pszAMLName, pdh, pfileOut));

    if (pfileOut != NULL)
    {
        strncpy(szSig, (PSZ)&pdh->Signature, sizeof(pdh->Signature));
        strncpy(szOEMID, (PSZ)pdh->OEMID, sizeof(pdh->OEMID));
        strncpy(szOEMTableID, (PSZ)pdh->OEMTableID, sizeof(pdh->OEMTableID));
        strncpy(szCreatorID, (PSZ)pdh->CreatorID, sizeof(pdh->CreatorID));

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            fprintf(pfileOut, "; ");
        }

        fprintf(pfileOut, "// CreatorID=%s\tCreatorRev=%x.%x.%d\n",
                szCreatorID, pdh->CreatorRev >> 24,
                (pdh->CreatorRev >> 16) & 0xff, pdh->CreatorRev & 0xffff);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            fprintf(pfileOut, "; ");
        }

        fprintf(pfileOut, "// FileLength=%d\tFileChkSum=0x%x\n\n",
                pdh->Length, pdh->Checksum);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            fprintf(pfileOut, "; ");
        }

        fprintf(pfileOut, "DefinitionBlock(\"%s\", \"%s\", 0x%02x, \"%s\", \"%s\", 0x%08x)",
                pszAMLName, szSig, pdh->Revision, szOEMID, szOEMTableID,
                pdh->OEMRevision);
    }

    EXIT((2, "UnAsmHeader=%d\n", rc));
    return rc;
}       //UnAsmHeader

/***LP  DumpBytes - Dump byte stream in ASM file
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length to dump
 *      pfileOut -> ASM output file
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, FILE *pfileOut)
{
    int i;
    #define MAX_LINE_BYTES  8

    ENTER((2, "DumpBytes(pb=%p,Len=%x,pfileOut=%p)\n", pb, dwLen, pfileOut));

    while (dwLen > 0)
    {
        fprintf(pfileOut, "\tdb\t0%02xh", *pb);
        for (i = 1; i < MAX_LINE_BYTES; ++i)
        {
            if ((int)dwLen - i > 0)
            {
                fprintf(pfileOut, ", 0%02xh", pb[i]);
            }
            else
            {
                fprintf(pfileOut, "      ");
            }
        }

        fprintf(pfileOut, "\t; ");
        for (i = 0; (dwLen > 0) && (i < MAX_LINE_BYTES); ++i)
        {
            fprintf(pfileOut, "%c",
                    ((*pb >= ' ') && (*pb <= '~'))? *pb: '.');
            dwLen--;
            pb++;
        }

        fprintf(pfileOut, "\n");
    }
    fprintf(pfileOut, "\n");

    EXIT((2, "DumpBytes!\n"));
}       //DumpBytes

/***LP  DumpCode - Dump code stream in ASM file
 *
 *  ENTRY
 *      pbOp -> Opcode pointer
 *      pfileOut -> ASM output file
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpCode(PBYTE pbOp, FILE *pfileOut)
{
    ENTER((2, "DumpCode(pbOp=%p,pfileOut=%p)\n", pbOp, pfileOut));

    if (pfileOut != NULL)
    {
        if (gdwfASL & ASLF_GENASM)
        {
            if (gpbOpBegin != pbOp)
            {
                fprintf(pfileOut, "\n");
                fprintf(pfileOut, "; %08x:\n", gpbOpBegin - gpbOpTop);
                DumpBytes(gpbOpBegin, (DWORD)(pbOp - gpbOpBegin), pfileOut);
                gpbOpBegin = pbOp;
            }
        }
        else
        {
            fprintf(pfileOut, "\n");
        }
    }

    EXIT((2, "DumpCode!\n"));
}       //DumpCode

/***LP  PrintIndent - Print indent level
 *
 *  ENTRY
 *      iLevel - indent level
 *      pfileOut -> ASM output file
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintIndent(int iLevel, FILE *pfileOut)
{
    int i;

    ENTER((3, "PrintIndent(Level=%d,pfileOut=%p)\n", iLevel, pfileOut));

    if (pfileOut != NULL)
    {
        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            fprintf(pfileOut, "; ");
        }

        for (i = 0; i < iLevel; ++i)
        {
            fprintf(pfileOut,
                    ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))?
                    "| ": "    ");
        }
    }

    EXIT((3, "PrintIndent!\n"));
}       //PrintIndent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable)
{
    BYTE bOpClass = OPCLASS_INVALID;

    ENTER((2, "FindOpClass(Op=%x,pOpTable=%x)\n", bOp, pOpTable));

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
            pOpTable++;
    }

    EXIT((2, "FindOpClass=%x\n", bOpClass));
    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(DWORD dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindOpTerm(Opcode=%x)\n", dwOpcode));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (TC_CONST_NAME | TC_SHORT_NAME | TC_NAMESPACE_MODIFIER |
              TC_DATA_OBJECT | TC_NAMED_OBJECT | TC_OPCODE_TYPE1 |
              TC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindOpTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bData)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindKeywordTerm(cKWGroup=%c,Data=%x)\n", cKWGroup, bData));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == TC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (BYTE)(TermTable[i].dwTermData >> 8)) ==
             (BYTE)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindKeywordTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pbEnd -> end of scope
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmScope(pbOp=%p,pbEnd=%p,pfileOut=%p)\n",
           *ppbOp, pbEnd, pfileOut));

    DumpCode(*ppbOp, pfileOut);

    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "{\n");
    }
    giLevel++;

    while ((rc == ASLERR_NONE) && (*ppbOp < pbEnd))
    {
        PrintIndent(giLevel, pfileOut);
        rc = UnAsmOpcode(ppbOp, pfileOut);
        if (gpbOpBegin != *ppbOp)
        {
            DumpCode(*ppbOp, pfileOut);
        }
        else if (pfileOut != NULL)
        {
            fprintf(pfileOut, "\n");
        }
    }

    giLevel--;
    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "}");
    }

    EXIT((2, "UnAsmScope=%d\n", rc));
    return rc;
}       //UnAsmScope

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmOpcode(PBYTE *ppbOp, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    DWORD dwOpcode;
    BYTE bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    PNSOBJ pns;
    int i;

    ENTER((2, "UnAsmOpcode(pbOp=%p,pfileOut=%p)\n", *ppbOp, pfileOut));

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((DWORD)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (DWORD)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp, pfileOut);
            break;

        case OPCLASS_NAME_OBJ:
            if (((rc = UnAsmNameObj(ppbOp, pfileOut, &pns, NSTYPE_UNKNOWN)) ==
                 ASLERR_NONE) &&
                (pns != NULL) &&
                (pns->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                for (i = 0; i < (int)pns->ObjData.uipDataValue; ++i)
                {
                    szUnAsmArgTypes[i] = 'C';
                }
                szUnAsmArgTypes[i] = '\0';
                rc = UnAsmArgs(szUnAsmArgTypes, NULL, 0, ppbOp, NULL, pfileOut);
            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = ASLERR_INVALID_OPCODE;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp, pfileOut);
            }
            break;

        default:
            ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "UnAsmOpcode=%d\n", rc));
    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataObj(PBYTE *ppbOp, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    BYTE bOp = **ppbOp;

    ENTER((2, "UnAsmDataObj(pbOp=%p,bOp=%x,pfileOut=%p)\n",
           *ppbOp, bOp, pfileOut));

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            if (pfileOut != NULL)
            {
                fprintf(pfileOut, "0x%x", **ppbOp);
            }
            *ppbOp += sizeof(BYTE);
            break;

        case OP_WORD:
            if (pfileOut != NULL)
            {
                fprintf(pfileOut, "0x%x", *((PWORD)*ppbOp));
            }
            *ppbOp += sizeof(WORD);
            break;

        case OP_DWORD:
            if (pfileOut != NULL)
            {
                fprintf(pfileOut, "0x%x", *((PDWORD)*ppbOp));
            }
            *ppbOp += sizeof(DWORD);
            break;

        case OP_STRING:
            if (pfileOut != NULL)
            {
		PSZ psz;

		fprintf(pfileOut, "\"");
		for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
		{
		    if (*psz == '\\')
		    {
			fprintf(pfileOut, "\\");
		    }
		    fprintf(pfileOut, "%c", *psz);
		}
		fprintf(pfileOut, "\"");
            }
            *ppbOp += strlen((PSZ)*ppbOp) + 1;
            break;

        default:
            ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = ASLERR_INVALID_OPCODE;
    }

    EXIT((2, "UnAsmDataObj=%d\n", rc));
    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfileOut -> ASM output file
 *      ppns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmNameObj(PBYTE *ppbOp, FILE *pfileOut, PNSOBJ *ppns, char c)
{
    int rc = ASLERR_NONE;
    char szName[MAX_NAME_LEN + 1];
    int iLen = 0;

    ENTER((2, "UnAsmNameObj(pbOp=%p,pfileOut=%p,ppns=%p,c=%c)\n",
           *ppbOp, pfileOut, ppns, c));

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = ParseNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NAME_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = ASLERR_NAME_TOO_LONG;
        }
        else
        {
            rc = ParseNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = ParseNameTail(ppbOp, szName, iLen);
    }

    if (rc == ASLERR_NONE)
    {
        PNSOBJ pns = NULL;

        if (pfileOut != NULL)
        {
            fprintf(pfileOut, "%s", szName);
        }

        if (islower(c) && (gdwfASL & ASLF_UNASM) &&
            ((pfileOut == NULL) ||
             (gpnsCurrentScope->ObjData.dwDataType == OBJTYPE_METHOD)))
        {
            rc = CreateObject(NULL, szName, (char)_toupper(c), &pns);
        }
        else if ((rc = GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0)) ==
                 ASLERR_NSOBJ_NOT_FOUND)
        {
            if (c == NSTYPE_SCOPE)
            {
                rc = CreateScopeObj(szName, &pns);
            }
            else
            {
                rc = ASLERR_NONE;
            }
        }

        if (rc == ASLERR_NONE)
        {
            if ((c == NSTYPE_SCOPE) && (pns != NULL))
            {
                gpnsCurrentScope = pns;
            }

            if (ppns != NULL)
            {
                *ppns = pns;
            }
        }
    }

    EXIT((2, "UnAsmNameObj=%d (pns=%p)\n", rc, ppns? *ppns: 0));
    return rc;
}       //UnAsmNameObj

/***LP  ParseNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen)
{
    int rc = ASLERR_NONE;
    int icNameSegs = 0;

    ENTER((2, "ParseNameTail(pbOp=%x,Name=%s,iLen=%d)\n",
           *ppbOp, pszBuff, iLen));

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NAME_LEN))
    {
        strncpy(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NAME_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        ERROR(("ParseNameTail: name too long - %s", pszBuff));
        rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    EXIT((2, "ParseNameTail=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PBYTE pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurrentScope;
    PNSOBJ pns = NULL;

    ENTER((2, "UnAsmTermObj(pterm=%p,Term=%s,pbOp=%p,pfileOut=%p)\n",
           pterm, pterm->pszID, *ppbOp, pfileOut));

    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "%s", pterm->pszID);
    }

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions,
                       pterm->dwTermData, ppbOp, &pns, pfileOut);
    }

    if (rc == ASLERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd, pfileOut);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd, pfileOut);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd, pfileOut);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
	    if ((pfileOut == NULL) && (pterm->lID == ID_METHOD))
	    {
		//
		// We are in NameSpace building pass, so don't need to
		// go into methods.
		//
		*ppbOp = pbEnd;
	    }
	    else
	    {
                if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                {
                    ASSERT(pns != NULL);
                    gpnsCurrentScope = pns;
                }

                rc = UnAsmScope(ppbOp, pbEnd, pfileOut);
	    }
        }
    }
    gpnsCurrentScope = pnsScopeSave;

    EXIT((2, "UnAsmTermObj=%d\n", rc));
    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      dwTermData - Term data
 *      ppbOp -> opcode pointer
 *      ppns -> to hold created object
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    static BYTE bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm;

    ENTER((2, "UnAsmArgs(UnAsmArgTypes=%s,ArgActions=%s,TermData=%x,pbOp=%p,ppns=%p,pfileOut=%p)\n",
           pszUnAsmArgTypes, pszArgActions? pszArgActions: "", dwTermData,
           *ppbOp, ppns, pfileOut));

    iNumArgs = strlen(pszUnAsmArgTypes);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "(");
    }

    for (i = 0; i < iNumArgs; ++i)
    {
        if ((i != 0) && (pfileOut != NULL))
        {
            fprintf(pfileOut, ", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, pfileOut, ppns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((DWORD)(**ppbOp));
                    ASSERT(pterm != NULL);
                    (*ppbOp)++;
                    rc = UnAsmTermObj(pterm, ppbOp, pfileOut);
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp, pfileOut);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp, pfileOut);
                break;

            case 'B':
                if (pfileOut != NULL)
                {
                    fprintf(pfileOut, "0x%x", **ppbOp);
                }

                *ppbOp += sizeof(BYTE);
                break;

            case 'E':
            case 'e':
            case 'K':
            case 'k':
                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    if ((gdwfASL & ASLF_UNASM) && (*ppns != NULL))
                    {
                        (*ppns)->ObjData.uipDataValue = (DWORD)(**ppbOp & 0x07);
                    }

                    if (pfileOut != NULL)
                    {
                        fprintf(pfileOut, "0x%x", **ppbOp & 0x07);
                    }
                }
                else if (pfileOut != NULL)
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    if (pterm != NULL)
                    {
                        fprintf(pfileOut, "%s", pterm->pszID);
                    }
                    else
                    {
                        fprintf(pfileOut, "0x%x", bArgData & dwTermData & 0xff);
                    }
                }

                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    *ppbOp += sizeof(BYTE);
                }
                break;

            case 'W':
                if (pfileOut != NULL)
                {
                    fprintf(pfileOut, "0x%x", *((PWORD)*ppbOp));
                }

                *ppbOp += sizeof(WORD);
                break;

            case 'D':
                if (pfileOut != NULL)
                {
                    fprintf(pfileOut, "0x%x", *((PDWORD)*ppbOp));
                }

                *ppbOp += sizeof(DWORD);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp, pfileOut);
                break;

            default:
                ERROR(("UnAsmOpcode: invalid ArgType '%c'", pszUnAsmArgTypes[i]));
                rc = ASLERR_INVALID_ARGTYPE;
        }
    }

    if (pfileOut != NULL)
    {
        fprintf(pfileOut, ")");
    }

    EXIT((2, "UnAsmArgs=%d\n", rc));
    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmSuperName(PBYTE *ppbOp, FILE *pfileOut)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmSuperName(pbOp=%p,pfileOut=%p)\n", *ppbOp, pfileOut));

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        if (pfileOut != NULL)
        {
            fprintf(pfileOut, "Debug");
        }
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, pfileOut, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp, pfileOut);
    }
    else
    {
        ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = ASLERR_INVALID_NAME;
    }

    EXIT((2, "UnAsmSuperName=%d\n", rc));
    return rc;
}       //UnAsmSuperName

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext)
{
    DWORD dwLen;
    BYTE bFollowCnt, i;

    ENTER((2, "ParsePackageLen(pbOp=%x,ppbOpNext=%x)\n", *ppbOp, ppbOpNext));

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (DWORD)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (BYTE)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (DWORD)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    EXIT((2, "ParsePackageLen=%x (pbOp=%x,pbOpNext=%x)\n",
          dwLen, *ppbOp, ppbOpNext? *ppbOpNext: 0));
    return dwLen;
}       //ParsePackageLen

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((2, "UnAsmDataList(pbOp=%p,pbEnd=%p,pfileOut=%p)\n",
           *ppbOp, pbEnd, pfileOut));

    DumpCode(*ppbOp, pfileOut);

    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "{\n");
    }

    while (*ppbOp < pbEnd)
    {
        if (pfileOut != NULL)
        {
            if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
            {
                fprintf(pfileOut, ";");
            }
            fprintf(pfileOut, "\t0x%02x", **ppbOp);
        }

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 12); ++i)
        {
            if (pfileOut != NULL)
            {
                fprintf(pfileOut, ", 0x%02x", **ppbOp);
            }
            (*ppbOp)++;
        }

        if (pfileOut != NULL)
        {
            if (*ppbOp < pbEnd)
            {
                fprintf(pfileOut, ",");
            }
            fprintf(pfileOut, "\n");
        }
    }

    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "}");
    }

    EXIT((2, "UnAsmDataList=%d\n", rc));
    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PASLTERM pterm;

    ENTER((2, "UnAsmPkgList(pbOp=%p,pbEnd=%p,pfileOut=%p)\n",
           *ppbOp, pbEnd, pfileOut));

    DumpCode(*ppbOp, pfileOut);

    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfileOut);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((DWORD)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp, pfileOut);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, pfileOut, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp, pfileOut);
        }

        if ((*ppbOp < pbEnd) && (rc == ASLERR_NONE) && (pfileOut != NULL))
        {
            fprintf(pfileOut, ",");
        }

        DumpCode(*ppbOp, pfileOut);
    }

    giLevel--;
    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "}");
    }

    EXIT((2, "UnAsmPkgList=%d\n", rc));
    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfileOut -> ASM output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    DWORD dwBitPos = 0;

    ENTER((2, "UnAsmFieldList(pbOp=%p,pbEnd=%p,pfileOut=%p)\n",
           *ppbOp, pbEnd, pfileOut));

    DumpCode(*ppbOp, pfileOut);

    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfileOut);
        if (((rc = UnAsmField(ppbOp, pfileOut, &dwBitPos)) == ASLERR_NONE) &&
            (*ppbOp < pbEnd) && (pfileOut != NULL))
        {
            fprintf(pfileOut, ",");
        }
        DumpCode(*ppbOp, pfileOut);
    }

    giLevel--;
    PrintIndent(giLevel, pfileOut);
    if (pfileOut != NULL)
    {
        fprintf(pfileOut, "}");
    }

    EXIT((2, "UnAsmFieldList=%d\n", rc));
    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfileOut -> ASM output file
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmField(PBYTE *ppbOp, FILE *pfileOut, PDWORD pdwBitPos)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmField(pbOp=%p,pfileOut=%p,BitPos=%x)\n",
           *ppbOp, pfileOut, *pdwBitPos));

    if (**ppbOp == 0x01)
    {
        (*ppbOp)++;
        if (pfileOut != NULL)
        {
            PASLTERM pterm;

            pterm = FindKeywordTerm('A', **ppbOp);
            fprintf(pfileOut, "AccessAs(%s, 0x%x)",
                    pterm->pszID, *(*ppbOp + 1));
        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        DWORD dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            strncpy(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if (pfileOut != NULL)
            {
                if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
                {
                    fprintf(pfileOut, "Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
                }
                else
                {
                    fprintf(pfileOut, ", %d", dwcbBits);
                }
            }
        }
        else
        {
            if (pfileOut != NULL)
            {
                fprintf(pfileOut, "%s, %d", szNameSeg, dwcbBits);
            }

            if ((gdwfASL & ASLF_UNASM) && (pfileOut == NULL))
            {
                rc = CreateObject(NULL, szNameSeg, NSTYPE_FIELDUNIT, NULL);
            }
        }

        *pdwBitPos += dwcbBits;
    }

    EXIT((2, "UnAsmField=%d\n", rc));
    return rc;
}       //UnAsmField
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\parseasl.c ===
/*** parseasl.c - Parse ASL source file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/07/96
 *
 *  This module implements a recursive decent parser for the ASL language.
 *
 *  MODIFICATION HISTORY
 */

#include "aslp.h"

/***LP  ParseASLFile - Parse the ASL source file
 *
 *  ENTRY
 *      pszFile -> file name string
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLFile(PSZ pszFile)
{
    int rc = ASLERR_NONE;
    FILE *pfileSrc;
    PTOKEN ptoken;
    PSZ pszOldFile;

    ENTER((1, "ParseASLFile(File=%s)\n", pszFile));

    if ((pfileSrc = fopen(pszFile, "r")) == NULL)
    {
        ERROR(("ParseASLFile: failed to open source file - %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else
    {
        if ((ptoken = OpenScan(pfileSrc)) == NULL)
        {
            ERROR(("ParseASLFile: failed to initialize scanner"));
            rc = ASLERR_INIT_SCANNER;
        }
        else
        {
            pszOldFile = gpszASLFile;
            gpszASLFile = pszFile;
            printf("%s:\n", pszFile);
            if ((rc = ParseASLTerms(ptoken, 0)) == TOKERR_EOF)
                rc = ASLERR_NONE;
            else if (rc == ASLERR_EXPECT_EOF)
            {
                PrintTokenErr(ptoken, "Expecting end-of-file", TRUE);
            }

            gpszASLFile = pszOldFile;
            CloseScan(ptoken);
        }

        fclose(pfileSrc);
    }

    EXIT((1, "ParseASLFile=%d\n", rc));
    return rc;
}       //ParseASLFile

/***LP  ParseASLTerms - Parse all ASL statements
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcode;

    ENTER((1, "ParseASLTerms(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    do
    {
        if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParseASLTerms: failed to allocate code object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pcode, 0, sizeof(CODEOBJ));

            if (gpcodeRoot == NULL)
                gpcodeRoot = pcode;
            else if (gpcodeScope != NULL)
            {
                pcode->pcParent = gpcodeScope;
                ListInsertTail(&pcode->list,
                               (PPLIST)&gpcodeScope->pcFirstChild);
            }

            gpcodeScope = pcode;
            rc = ParseASLTerm(ptoken, iNestLevel);
            gpcodeScope = pcode->pcParent;

            if (rc != ASLERR_NONE)
            {
                if (gpcodeRoot == pcode)
                    gpcodeRoot = NULL;
                else if (gpcodeScope != NULL)
                {
                    ListRemoveEntry(&pcode->list,
                                    (PPLIST)&gpcodeScope->pcFirstChild);
                }

                MEMFREE(pcode);
            }
        }
    } while (rc == ASLERR_NONE);

    EXIT((1, "ParseASLTerms=%d\n", rc));
    return rc;
}       //ParseASLTerms

/***LP  ValidateTermClass - Validate term class with parent
 *
 *  ENTRY
 *      dwTermClass - term class of child
 *      pcParent -> parent
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent)
{
    BOOL rc = TRUE;

    ENTER((2, "ValidateTermClass(TermClass=%x,Parent=%p)\n",
           dwTermClass, pcParent));

    if ((dwTermClass & TC_COMPILER_DIRECTIVE) == 0)
    {
        while (pcParent != NULL)
        {
            //
            // Go upward to find a parent that is not "Include".
            //
            if (TermTable[pcParent->dwTermIndex].lID == ID_INCLUDE)
            {
                pcParent = pcParent->pcParent;
            }
            else
            {
                break;
            }
        }

        if ((pcParent != NULL) && (pcParent->dwfCode & CF_PARSING_VARLIST))
        {
            rc = (dwTermClass & TermTable[pcParent->dwTermIndex].dwfTerm) != 0;
        }
    }

    EXIT((2, "ValidateTermClass=%d\n", rc));
    return rc;
}       //ValidateTermClass

/***LP  ParseASLTerm - Parse an ASL statement
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel)
{
    int rc;

    ENTER((1, "ParseASLTerm(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RBRACE, MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (iNestLevel == 0)
            rc = ASLERR_EXPECT_EOF;
        else
        {
            //
            // We have no more terms in the current scope
            //
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
    }
    else if ((rc != TOKERR_EOF) &&
             ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE, NULL)) ==
              TOKERR_NONE))
    {
        if ((gpcodeRoot == NULL) &&
            ((ptoken->llTokenValue < 0) ||
             (TermTable[ptoken->llTokenValue].lID != ID_DEFBLK)))
        {
            //
            // outside of definition block
            //
            rc = ASLERR_EXPECT_EOF;
        }
        else if (ptoken->llTokenValue == ID_USER)       //user term
        {
            if ((rc = ParseUserTerm(ptoken, FALSE)) == TOKERR_NO_MATCH)
            {
                PrintTokenErr(ptoken, "User ID is not a method", TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->llTokenValue >= 0)             //ASL term
        {
            PNSOBJ pnsScopeSave = gpnsCurrentScope;
            PNSOBJ pnsOwnerSave = gpnsCurrentOwner;
            PASLTERM pterm;
            int iNumArgs;

            pterm = &TermTable[ptoken->llTokenValue];
            iNumArgs = pterm->pszArgTypes? strlen(pterm->pszArgTypes): 0;
            gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = pterm->dwOpcode;
            gpcodeScope->dwDataLen = (DWORD)iNumArgs;

            if (!ValidateTermClass(pterm->dwfTermClass, gpcodeScope->pcParent))
            {
                PrintTokenErr(ptoken, "unexpected ASL term type", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if (pterm->pszArgTypes != NULL)        //there is a fixed list
                rc = ParseArgs(ptoken, pterm, iNumArgs);

            if ((rc == ASLERR_NONE) && (pterm->dwfTerm & TF_ACTION_FLIST))
            {
                ASSERT(pterm->pfnTerm != NULL);
                rc = pterm->pfnTerm(ptoken, TRUE);
            }

            if (rc == ASLERR_NONE)
            {
                if (pterm->dwfTerm & TF_ALL_LISTS)
                {
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LBRACE, 0,
                                         NULL)) == TOKERR_NONE)
                    {
                        if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                        {
                            ASSERT(gpcodeScope->pnsObj != NULL);
                            gpnsCurrentScope = gpcodeScope->pnsObj;
                        }

                        if (pterm->lID == ID_METHOD)
                        {
                            gpnsCurrentOwner = gpcodeScope->pnsObj;
                        }

                        gpcodeScope->dwfCode |= CF_PARSING_VARLIST;

                        if (pterm->dwfTerm & TF_FIELD_LIST)
                            rc = ParseFieldList(ptoken);
                        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
                            rc = ParsePackageList(ptoken);
                        else if (pterm->dwfTerm & TF_DATA_LIST)
                            rc = ParseBuffList(ptoken);
                        else if (pterm->dwfTerm & TF_BYTE_LIST)
                            rc = ParseDataList(ptoken, sizeof(BYTE));
                        else if (pterm->dwfTerm & TF_DWORD_LIST)
                            rc = ParseDataList(ptoken, sizeof(DWORD));
                        else
                            rc = ParseASLTerms(ptoken, iNestLevel + 1);

                        gpcodeScope->dwfCode &= ~CF_PARSING_VARLIST;

                        if (((rc == TOKERR_NO_MATCH) || (rc == TOKERR_EOF)) &&
                            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL,
                                              SYM_RBRACE, 0, NULL)) ==
                             TOKERR_NONE))
                        {
                            ComputeChkSumLen(gpcodeScope);
                            if (pterm->dwfTerm & TF_ACTION_VLIST)
                            {
                                ASSERT(pterm->pfnTerm != NULL);
                                rc = pterm->pfnTerm(ptoken, FALSE);
                            }
                        }
                    }
                }
                else
                {
                    ComputeChkSumLen(gpcodeScope);
                }
            }
            gpnsCurrentScope = pnsScopeSave;
            gpnsCurrentOwner = pnsOwnerSave;
        }
        else
        {
            PrintTokenErr(ptoken, "unexpected term type", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParseASLTerm=%d\n", rc));
    return rc;
}       //ParseASLTerm

/***LP  ParseFieldList - Parse Field List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseFieldList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    NAMESEG NameSeg;
    DWORD dwcbLen;
    DWORD dwcBits = 0, dwcTotalBits = 0;
    PCODEOBJ pc;
    PNSOBJ pns;

    ENTER((1, "ParseFieldList(ptoken=%p,AccSize=%ld)\n",
           ptoken, gdwFieldAccSize));

    while ((rc == ASLERR_NONE) &&
           (((rc = MatchToken(ptoken, TOKTYPE_ID, 0,
                              MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
             TOKERR_NONE) ||
            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                              NULL)) == TOKERR_NONE)))
    {
        pns = NULL;
        if (ptoken->iTokenType == TOKTYPE_SYMBOL)
        {
            NameSeg = 0;
            rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
            dwcBits = (DWORD)ptoken->llTokenValue;
        }
        else if (ptoken->llTokenValue >= 0)
        {
            if (TermTable[ptoken->llTokenValue].lID == ID_OFFSET)
            {
                if (((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0,
                                      NULL)) == TOKERR_NONE) &&
                    ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE))
                {
                    NameSeg = 0;
                    if ((DWORD)ptoken->llTokenValue*8 >= dwcTotalBits)
                    {
                        dwcBits = (DWORD)ptoken->llTokenValue*8 - dwcTotalBits;
                        rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                        NULL);
                    }
                    else
                    {
                        PrintTokenErr(ptoken, "backward offset is not allowed",
                                      TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }
            }
            else if (TermTable[ptoken->llTokenValue].lID == ID_ACCESSAS)
            {
                PCODEOBJ pcode;

                UnGetToken(ptoken);
                if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
                {
                    ERROR(("ParseFieldList: failed to allocate code object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    ASSERT(gpcodeScope != NULL);
                    memset(pcode, 0, sizeof(CODEOBJ));
                    pcode->pcParent = gpcodeScope;
                    ListInsertTail(&pcode->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);

                    gpcodeScope = pcode;
                    rc = ParseASLTerm(ptoken, 0);
                    gpcodeScope = pcode->pcParent;

                    if (rc != ASLERR_NONE)
                    {
                        ListRemoveEntry(&pcode->list,
                                        (PPLIST)&gpcodeScope->pcFirstChild);
                        MEMFREE(pcode);
                    }
                    else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                              MTF_NOT_ERR, NULL)) ==
                             TOKERR_NONE)
                    {
                        continue;
                    }
                }
            }
            else
            {
                PrintTokenErr(ptoken, "unexpected ASL term in field list",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else
        {
            //
            // expecting a NameSeg and an integer
            //
            dwcbLen = sizeof(NAMESEG);
            if ((ptoken->llTokenValue >= 0) ||      //an ASL term?
                !ValidASLNameSeg(ptoken, ptoken->szToken, strlen(ptoken->szToken)) ||
                ((rc = EncodeName(ptoken->szToken, (PBYTE)&NameSeg, &dwcbLen)) !=
                 ASLERR_NONE) ||
                (dwcbLen != sizeof(NAMESEG)))
            {
                PrintTokenErr(ptoken, "not a valid NameSeg", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((rc = CreateNameSpaceObj(ptoken, ptoken->szToken,
                                              gpnsCurrentScope,
                                              gpnsCurrentOwner,
                                              &pns, NSF_EXIST_ERR)) ==
                     ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, 0,
                                     NULL)) == TOKERR_NONE)
                {
                    rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
                    dwcBits = (DWORD)ptoken->llTokenValue;
                }
            }
        }

        if  (rc == ASLERR_NONE)
        {
            if ((NameSeg == 0) && (dwcBits == 0))
            {
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                                NULL);
            }
            else if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
            {
                ERROR(("ParseFieldList: failed to allocate field code object"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                int icb;

                memset(pc, 0, sizeof(CODEOBJ));
                if ((rc = EncodePktLen(dwcBits, &pc->dwDataLen, &icb)) ==
                    ASLERR_NONE)
                {
                    dwcTotalBits += dwcBits;
                    if (gpcodeScope->pnsObj != NULL)
                    {
                        ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType ==
                               OBJTYPE_OPREGION);
                        if ((gpcodeScope->pnsObj->ObjData.uipDataValue !=
                             0xffffffff) &&
                            ((dwcTotalBits + 7)/8 >
                             gpcodeScope->pnsObj->ObjData.uipDataValue))
                        {
                            char szMsg[MAX_MSG_LEN + 1];

                            sprintf(szMsg,
                                    "field offset is exceeding operation region range (offset=0x%x)",
                                    (dwcTotalBits + 7)/8);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }

                    pc->pcParent = gpcodeScope;
                    ListInsertTail(&pc->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);
                    pc->dwCodeType = CODETYPE_FIELDOBJ;
                    if (pns != NULL)
                    {
                        pc->dwfCode |= CF_CREATED_NSOBJ;
                        pc->pnsObj = pns;
                        pns->Context = pc;
                    }
                    pc->dwCodeValue = NameSeg;
                    pc->dwCodeLen = (NameSeg == 0)? sizeof(BYTE):
                                                    sizeof(NAMESEG);
                    pc->dwCodeLen += icb;
                    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&NameSeg,
                                                        sizeof(NAMESEG));
                    pc->bCodeChkSum = (BYTE)
                        (pc->bCodeChkSum +
                         ComputeDataChkSum((PBYTE)&pc->dwDataLen, icb));

                    rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                    MTF_NOT_ERR, NULL);
                }
                else
                {
                    MEMFREE(pc);
                    PrintTokenErr(ptoken, "exceeding maximum encoding limit",
                                  TRUE);
                }
            }
        }
    }

    EXIT((1, "ParseFieldList=%d\n", rc));
    return rc;
}       //ParseFieldList

/***LP  ParsePackageList - Parse Package List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParsePackageList(PTOKEN ptoken)
{
    int rc;
    PCODEOBJ pc;
    int icElements = 0;
    PCODEOBJ pArgs;

    ENTER((1, "ParsePackageList(ptoken=%p)\n", ptoken));

    do
    {
        if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParsePackageList: failed to allocate package object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pc, 0, sizeof(CODEOBJ));
            pc->pcParent = gpcodeScope;
            ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);

            gpcodeScope = pc;
            if ((rc = ParseData(ptoken)) == TOKERR_NO_MATCH)
            {
                UnGetToken(ptoken);
                rc = ParseName(ptoken, TRUE);
            }
            gpcodeScope = pc->pcParent;

            if (rc != ASLERR_NONE)
            {
                ListRemoveEntry(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
                MEMFREE(pc);
            }
            else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE)
            {
                icElements++;
                if (ptoken->llTokenValue == SYM_RBRACE)
                {
                    UnGetToken(ptoken);
                    rc = TOKERR_NO_MATCH;
                }
                else if (ptoken->llTokenValue != SYM_COMMA)
                {
                    PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
    } while (rc == ASLERR_NONE);

    if (rc == TOKERR_NO_MATCH)
    {
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        if (pArgs[0].dwfCode & CF_MISSING_ARG)
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            SetIntObject(&pArgs[0], (DWORD)icElements, sizeof(BYTE));
        }
        else if (pArgs[0].dwCodeValue < (DWORD)icElements)
        {
            PrintTokenErr(ptoken, "Package has too many elements", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParsePackageList=%d\n", rc));
    return rc;
}       //ParsePackageList

/***LP  ParseBuffList - Parse Buffer List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseBuffList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseBuffList(ptoken=%p)\n", ptoken));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseBuffList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PCODEOBJ pArgs;
        DWORD dwReservedLen;
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0,
                             MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) == TOKERR_NONE)
        {
            pc->dwDataLen = strlen(ptoken->szToken) + 1;

            if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                ((rc = GetIntData(&pArgs[0], &dwReservedLen)) == ASLERR_NONE) &&
                (pc->dwDataLen > dwReservedLen))
            {
                PrintTokenErr(ptoken, "Buffer has too many initializers", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else
            {
                if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseBuffList: failed to allocate string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memset(pc->pbDataBuff, 0, pc->dwDataLen);
                    memcpy(pc->pbDataBuff, ptoken->szToken, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
        }
        else if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseBuffList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                if (ptoken->llTokenValue > MAX_BYTE)
                {
                    PrintTokenErr(ptoken, "expecting byte value", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else if (dwLen >= MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen >= dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseBuffList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    pbBuff[dwLen++] = (BYTE)ptoken->llTokenValue;
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                    (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                    ((rc = GetIntData(&pArgs[0], &dwReservedLen)) ==
                     ASLERR_NONE) &&
                    (pc->dwDataLen > dwReservedLen))
                {
                    PrintTokenErr(ptoken, "Buffer has too many initializers",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }
                else
                {
                    if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) ==
                        NULL)
                    {
                        ERROR(("ParseBuffList: failed to allocate data object"));
                        rc = ASLERR_OUT_OF_MEM;
                    }
                    else
                    {
                        memset(pc->pbDataBuff, 0, pc->dwDataLen);
                        memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                        pc->dwCodeLen = pc->dwDataLen;
                        pc->bCodeChkSum =
                            ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                    }
                }
            }
            MEMFREE(pbBuff);
        }

        if ((rc == ASLERR_NONE) && (pArgs[0].dwfCode & CF_MISSING_ARG))
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            rc = MakeIntData(pc->dwDataLen, &pArgs[0]);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseBuffList=%d\n", rc));
    return rc;
}       //ParseBuffList

/***LP  ParseDataList - Parse Data List
 *
 *  ENTRY
 *      ptoken - token stream
 *      icbDataSize - data size in bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseDataList(ptoken=%p,DataSize=%d)\n", ptoken, icbDataSize));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseDataList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF*icbDataSize;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseDataList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                switch (icbDataSize)
                {
                    case sizeof(BYTE):
                        if (ptoken->llTokenValue > MAX_BYTE)
                        {
                            PrintTokenErr(ptoken, "expecting byte value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(WORD):
                        if (ptoken->llTokenValue > MAX_WORD)
                        {
                            PrintTokenErr(ptoken, "expecting word value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(DWORD):
                        if (ptoken->llTokenValue > MAX_DWORD)
                        {
                            PrintTokenErr(ptoken, "expecting dword value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    default:
                        ERROR(("ParseDataList: unexpected data size - %d",
                               icbDataSize));
                        rc = ASLERR_INTERNAL_ERROR;
                }

                if (rc != ASLERR_NONE)
                    break;

                if (dwLen + icbDataSize > MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen + icbDataSize > dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF*icbDataSize;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseDataList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    switch (icbDataSize)
                    {
                        case sizeof(BYTE):
                            pbBuff[dwLen] = (BYTE)ptoken->llTokenValue;
                            break;

                        case sizeof(WORD):
                            *((PWORD)&pbBuff[dwLen]) = (WORD)
                                ptoken->llTokenValue;
                            break;

                        case sizeof(DWORD):
                            *((PDWORD)&pbBuff[dwLen]) = (DWORD)
                                ptoken->llTokenValue;
                            break;
                    }
                    dwLen += icbDataSize;

                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if ((pc->pbDataBuff = MEMALLOC(pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseDataList: failed to allocate data object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
            MEMFREE(pbBuff);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseDataList=%d\n", rc));
    return rc;
}       //ParseDataList

/***LP  ParseArgs - Parse ASL term arguments
 *
 *  ENTRY
 *      ptoken - token stream
 *      pterm -> asl term
 *      iNumArgs - number of arguments
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ParseArgs(ptoken=%p,pterm=%p,NumArgs=%d)\n",
           ptoken, pterm, iNumArgs));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0, NULL)) ==
        TOKERR_NONE)
    {
        PCODEOBJ pArgs = NULL;

        if ((iNumArgs != 0) &&
            ((pArgs = MEMALLOC(sizeof(CODEOBJ)*iNumArgs)) == NULL))
        {
            ERROR(("ParseArgs: failed to allocate argument objects"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            int i;
            char chArgType;
            char szNameBuff[MAX_NAME_LEN + 1];
            BOOL fOptional;
            PSZ pszArgType = "Unknown";

            gpcodeScope->dwfCode |= CF_PARSING_FIXEDLIST;
            if (pArgs != NULL)
            {
                gpcodeScope->pbDataBuff = (PBYTE)pArgs;
                memset(pArgs, 0, sizeof(CODEOBJ)*iNumArgs);
            }

            for (i = 0; (rc == ASLERR_NONE) && (i < iNumArgs); ++i)
            {
                chArgType = pterm->pszArgTypes[i];
                if (islower(chArgType))
                {
                    chArgType = (char)_toupper(chArgType);
                    fOptional = TRUE;
                }
                else
                    fOptional = FALSE;

                pArgs[i].pcParent = gpcodeScope;

                gpcodeScope = &pArgs[i];
                switch (chArgType)
                {
                    case 'N':
                    case 'R':
                        rc = ParseName(ptoken, (chArgType == 'N')? TRUE: FALSE);
                        pszArgType = "Name";
                        break;

                    case 'S':
                        if (((rc = ParseSuperName(ptoken)) ==
                             TOKERR_NO_MATCH) && fOptional)
                        {
                            pArgs[i].dwCodeType = CODETYPE_ASLTERM;
                            pArgs[i].dwCodeValue = OP_ZERO;
                            pArgs[i].dwCodeLen = 0;
                            pArgs[i].bCodeChkSum = OP_ZERO;
                            rc = LookupIDIndex(ID_ZERO,
                                               &pArgs[i].dwTermIndex);
                        }
                        pszArgType = "SuperName";
                        break;

                    case 'O':
                        rc = ParseData(ptoken);
                        pszArgType = "DataObject";
                        break;

                    case 'B':
                    case 'W':
                    case 'D':
                    case 'U':
                    case 'Q':
                        rc = ParseInteger(ptoken, chArgType);
                        if (chArgType == 'B')
                            pszArgType = "ByteInteger";
                        else if (chArgType == 'W')
                            pszArgType = "WordInteger";
                        else if (chArgType == 'D')
                            pszArgType = "DWordInteger";
                        else if (chArgType == 'Q')
                            pszArgType = "QWordInteger";
                        else
                            pszArgType = "Integer";
                        break;

                    case 'C':
                    case 'M':
                    case 'P':
                        rc = ParseOpcode(ptoken, chArgType);
                        pszArgType = "Opcode";
                        break;

                    case 'E':
                    case 'K':
                        rc = ParseKeyword(ptoken, pterm->pszArgActions[i]);
                        pszArgType = "Keyword";
                        if ((chArgType == 'E') && (rc == TOKERR_NO_MATCH))
                        {
                            if ((rc = ParseInteger(ptoken, 'B')) == ASLERR_NONE)
                            {
                                if ((gpcodeScope->dwCodeValue <
                                     (pterm->dwTermData >> 24)) ||
                                    (gpcodeScope->dwCodeValue >
                                     ((pterm->dwTermData >> 16) & 0xff)))
                                {
                                    PrintTokenErr(ptoken,
                                                  "invalid integer range",
                                                  TRUE);
                                    rc = ASLERR_SYNTAX;
                                }
                            }
                        }
                        break;

                    case 'Z':
                        rc = ParseString(ptoken);
                        pszArgType = "String";
                        break;
                }
                gpcodeScope = pArgs[i].pcParent;

                if (rc == TOKERR_NO_MATCH)
                {
                    if (fOptional)
                    {
                        pArgs[i].dwfCode |= CF_MISSING_ARG;
                        rc = ASLERR_NONE;
                    }
                    else
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        sprintf(szMsg, "expecting argument type \"%s\"",
                                pszArgType);
                        PrintTokenErr(ptoken, szMsg, TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }

                if ((rc == ASLERR_NONE) && (pterm->pszArgActions != NULL) &&
                    ((chArgType == 'N') || (chArgType == 'S') ||
                     (chArgType == 'C') || (chArgType == 'M') ||
                     (chArgType == 'P')) &&
                    (pArgs[i].dwCodeType == CODETYPE_NAME) &&
                    ((rc = DecodeName(pArgs[i].pbDataBuff, szNameBuff,
                                      sizeof(szNameBuff))) == ASLERR_NONE))
                {
                    char chActType = pterm->pszArgActions[i];

                    if (islower(chActType))
                    {
                        rc = CreateObject(ptoken, szNameBuff,
                                          (char)_toupper(chActType), NULL);
                    }
                    else
                    {
                        rc = ValidateObject(ptoken, szNameBuff, chActType,
                                            chArgType);
                    }
                }

                if (rc == ASLERR_NONE)
                {   //
                    // expecting either a comma or a close paran.
                    //
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RPARAN)
                        {
                            UnGetToken(ptoken);
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (i == iNumArgs - 1)     //last argument
                        {
                            PrintTokenErr(ptoken, "expecting ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            gpcodeScope->dwfCode &= ~CF_PARSING_FIXEDLIST;

            if (rc == ASLERR_NONE)
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0, NULL);
        }

    }

    EXIT((1, "ParseArgs=%d\n", rc));
    return rc;
}       //ParseArgs

/***LP  ParseUserTerm - Parse user method name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fNonMethodOK - if TRUE, user term can be a non-method
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK)
{
    int rc;

    ENTER((1, "ParseUserTerm(ptoken=%p,fNonMethodOK=%d)\n",
           ptoken, fNonMethodOK));

    //
    // Max number of argument is 7 but we need to store the user term name too,
    // we will store it in Arg0, so we will make it 8.
    //
    if ((gpcodeScope->pbDataBuff = MEMALLOC(sizeof(CODEOBJ)*(MAX_ARGS + 1))) ==
        NULL)
    {
        ERROR(("ParseUserTerm: failed to allocate user term object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        int i;

        gpcodeScope->dwCodeType = CODETYPE_USERTERM;
        gpcodeScope->dwDataLen = MAX_ARGS + 1;
        memset(pArgs, 0, sizeof(CODEOBJ)*gpcodeScope->dwDataLen);

        pArgs[0].pcParent = gpcodeScope;
        gpcodeScope = &pArgs[0];
        UnGetToken(ptoken);
        if ((rc = ParseName(ptoken, TRUE)) == TOKERR_NONE)
        {
            PNSOBJ pns;
            char szName[MAX_NAME_LEN + 1];

            strcpy(szName, ptoken->szToken);
            GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0);

            gpcodeScope = pArgs[0].pcParent;
            if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN,
                                 fNonMethodOK? MTF_NOT_ERR: 0, NULL)) ==
                TOKERR_NONE)
            {
                for (i = 1;
                     (rc == TOKERR_NONE) && (i < (int)gpcodeScope->dwDataLen);
                     ++i)
                {
                    pArgs[i].pcParent = gpcodeScope;
                    gpcodeScope = &pArgs[i];
                    if ((rc = ParseOpcode(ptoken, 'C')) == TOKERR_NONE)
                    {
                        if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                             MTF_ANY_VALUE, NULL)) ==
                            TOKERR_NONE)
                        {
                            if (ptoken->llTokenValue == SYM_RPARAN)
                            {
                                UnGetToken(ptoken);
                                gpcodeScope = pArgs[i].pcParent;
                                //
                                // Readjust the number of arguments
                                //
                                gpcodeScope->dwDataLen = i + 1;
                                break;
                            }
                            else if (ptoken->llTokenValue != SYM_COMMA)
                            {
                                PrintTokenErr(ptoken, "expecting ',' or ')'",
                                              TRUE);
                                rc = ASLERR_SYNTAX;
                            }
                        }
                    }
                    else if (rc == TOKERR_NO_MATCH)
                    {
                        gpcodeScope = pArgs[i].pcParent;
                        //
                        // Readjust the number of arguments
                        //
                        gpcodeScope->dwDataLen = i;
                        rc = TOKERR_NONE;
                        break;
                    }

                    gpcodeScope = pArgs[i].pcParent;
                }

                if (rc == TOKERR_NONE)
                {
                    ComputeArgsChkSumLen(gpcodeScope);
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                         NULL)) == ASLERR_NONE)
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        if (pns == NULL)
                        {
                            rc = QueueNSChk(ptoken, szName, OBJTYPE_METHOD,
                                            gpcodeScope->dwDataLen - 1);
                        }
                        else if (pns->ObjData.dwDataType != OBJTYPE_METHOD)
                        {
                            sprintf(szMsg, "%s is not a method", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue <
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too many arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue >
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too few arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            else if (rc == TOKERR_NO_MATCH)
            {
                gpcodeScope->dwCodeType = pArgs[0].dwCodeType;
                gpcodeScope->dwDataLen = pArgs[0].dwDataLen;
                gpcodeScope->pbDataBuff = pArgs[0].pbDataBuff;
                gpcodeScope->dwCodeLen = pArgs[0].dwCodeLen;
                gpcodeScope->bCodeChkSum = pArgs[0].bCodeChkSum;
                MEMFREE(pArgs);
                if (pns == NULL)
                {
                    rc = QueueNSChk(ptoken, szName, OBJTYPE_UNKNOWN, 0);
                }
                else
                {
                    rc = TOKERR_NONE;
                }
            }
        }
    }

    EXIT((1, "ParseUserTerm=%d\n", rc));
    return rc;
}       //ParseUserTerm

/***LP  ParseName - Parse ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fEncode - TRUE if encode name else store it raw as string
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode)
{
    int rc;
    BYTE abBuff[MAX_NAMECODE_LEN];
    DWORD dwLen = sizeof(abBuff);

    ENTER((1, "ParseName(ptoken=%p,fEncode=%x)\n", ptoken, fEncode));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, ID_USER, MTF_NOT_ERR, NULL)) ==
        TOKERR_NONE)
    {
        if (!ValidASLName(ptoken, ptoken->szToken))
        {
            PrintTokenErr(ptoken, "expecting ASL name", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (fEncode)
        {
            if ((rc = EncodeName(ptoken->szToken, abBuff, &dwLen)) ==
                ASLERR_NONE)
            {
                if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
                {
                    ERROR(("ParseName: failed to allocate name string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(gpcodeScope->pbDataBuff, abBuff, (int)dwLen);
                    gpcodeScope->dwCodeType = CODETYPE_NAME;
                    gpcodeScope->dwDataLen = dwLen;
                    gpcodeScope->dwCodeLen = dwLen;
                    gpcodeScope->bCodeChkSum =
                        ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
                }
            }
            else
            {
                PrintTokenErr(ptoken, "name too long", TRUE);
            }
        }
        else
        {
            gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
            if ((gpcodeScope->pbDataBuff = MEMALLOC(gpcodeScope->dwDataLen)) !=
                NULL)
            {
                memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                       gpcodeScope->dwDataLen);
                gpcodeScope->dwCodeType = CODETYPE_STRING;
                gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                      gpcodeScope->dwDataLen);
            }
            else
            {
                ERROR(("ParseName: failed to allocate raw name string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }

    EXIT((1, "ParseName=%d (Name=%s)\n", rc, ptoken->szToken));
    return rc;
}       //ParseName

/***LP  ParseSuperName - Parse ASL super name
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseSuperName(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseSuperName(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            UnGetToken(ptoken);
            rc = ParseName(ptoken, TRUE);
        }
        else
        {
            if (TermTable[ptoken->llTokenValue].dwfTermClass &
                TC_SHORT_NAME)
            {
                gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
                gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
                gpcodeScope->dwCodeValue =
                    TermTable[ptoken->llTokenValue].dwOpcode;
            }
            else if (TermTable[ptoken->llTokenValue].dwfTermClass &
                     TC_REF_OBJECT)
            {
                UnGetToken(ptoken);
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                UnGetToken(ptoken);
                rc = TOKERR_NO_MATCH;
            }
        }
    }

    EXIT((1, "ParseSuperName=%d\n", rc));
    return rc;
}       //ParseSuperName

/***LP  MakeIntData - make integer data object
 *
 *  ENTRY
 *      dwData - integer data
 *      pc -> code object
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc)
{
    int rc = ASLERR_NONE;
    DWORD dwLen;
    BYTE bOp;

    ENTER((1, "MakeIntData(Data=%lx,pc=%p)\n", dwData, pc));

    pc->dwCodeType = CODETYPE_DATAOBJ;
    if ((dwData & 0xffffff00) == 0)
    {
        bOp = OP_BYTE;
        dwLen = 2;
    }
    else if ((dwData & 0xffff0000) == 0)
    {
        bOp = OP_WORD;
        dwLen = 3;
    }
    else
    {
        bOp = OP_DWORD;
        dwLen = 5;
    }

    if ((pc->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
    {
        ERROR(("MakeIntData: failed to allocate data object - %lx", dwData));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        pc->dwDataLen = dwLen;
        pc->dwCodeLen = dwLen;
        pc->pbDataBuff[0] = bOp;
        memcpy(&pc->pbDataBuff[1], &dwData, (int)(dwLen - 1));
        pc->bCodeChkSum = ComputeDataChkSum(pc->pbDataBuff, dwLen);
    }

    EXIT((1, "MakeIntData=%d\n", rc));
    return rc;
}       //MakeIntData

/***LP  GetIntData - get integer from a data object
 *
 *  ENTRY
 *      pc -> code object
 *      pdwData -> to hold integer data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData)
{
    int rc = ASLERR_NONE;

    ENTER((1, "GetIntData(pc=%p,pdwData=%p)\n", pc, pdwData));

    ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
    switch (pc->pbDataBuff[0])
    {
        case OP_BYTE:
            *pdwData = (DWORD)(*((PBYTE)&pc->pbDataBuff[1]));
            break;

        case OP_WORD:
            *pdwData = (DWORD)(*((PWORD)&pc->pbDataBuff[1]));
            break;

        case OP_DWORD:
            *pdwData = *((PDWORD)&pc->pbDataBuff[1]);
            break;

        default:
            ERROR(("GetIntData: data object is not integer type"));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    EXIT((1, "GetIntData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetIntData

/***LP  ParseData - Parse ASL data object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseData(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseData(ptoken=%p)\n", ptoken));

    if ((rc = GetToken(ptoken)) == TOKERR_NONE)
    {
        if (ptoken->iTokenType == TOKTYPE_NUMBER)
        {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->iTokenType == TOKTYPE_STRING)
        {
            DWORD dwLen;

            gpcodeScope->dwCodeType = CODETYPE_DATAOBJ;
            dwLen = strlen(ptoken->szToken) + 2;
            if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
            {
                ERROR(("ParseData: failed to allocate string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                gpcodeScope->dwDataLen = dwLen;
                gpcodeScope->dwCodeLen = dwLen;
                gpcodeScope->pbDataBuff[0] = OP_STRING;
                memcpy(&gpcodeScope->pbDataBuff[1], ptoken->szToken,
                       (int)(dwLen - 1));
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
            }
        }
        else if ((ptoken->iTokenType != TOKTYPE_ID) ||
                 (ptoken->llTokenValue < 0) ||
                 ((TermTable[ptoken->llTokenValue].dwfTermClass &
                   (TC_DATA_OBJECT | TC_CONST_NAME)) == 0))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else
        {
            UnGetToken(ptoken);
            rc = ParseASLTerm(ptoken, 0);
        }
    }

    EXIT((1, "ParseData=%d\n", rc));
    return rc;
}       //ParseData

/***LP  ParseInteger - Parse integer data
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - integer type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseInteger(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseInteger(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwCodeValue = 0;
        if ((c == 'B') && ((ptoken->llTokenValue & 0xffffffffffffff00) != 0) ||
            (c == 'W') && ((ptoken->llTokenValue & 0xffffffffffff0000) != 0) ||
            (c == 'D') && ((ptoken->llTokenValue & 0xffffffff00000000) != 0))
        {
            char szMsg[MAX_MSG_LEN + 1];

            sprintf(szMsg, "expecting %s value",
                    (c == 'B')? "byte":
                    (c == 'W')? "word": "dword");
            PrintTokenErr(ptoken, szMsg, TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (c == 'U')
    {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
    else if (c != 'Q')
        {
            gpcodeScope->dwCodeType = CODETYPE_INTEGER;
            gpcodeScope->dwDataLen = (c == 'B')? sizeof(BYTE):
                                     (c == 'W')? sizeof(WORD):
                                     (c == 'D')? sizeof(DWORD):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffffff00) == 0)? sizeof(BYTE):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffff0000) == 0)? sizeof(WORD):
                                     sizeof(DWORD);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->dwCodeValue = (DWORD)ptoken->llTokenValue;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum((PBYTE)&ptoken->llTokenValue,
                                  gpcodeScope->dwDataLen);
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC(gpcodeScope->dwDataLen = sizeof(QWORD))) != NULL)
        {
            gpcodeScope->dwCodeType = CODETYPE_QWORD;
            memcpy(gpcodeScope->pbDataBuff, &ptoken->llTokenValue,
                   gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
        else
        {
            ERROR(("ParseInteger: failed to allocate QWord object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((1, "ParseInteger=%d\n", rc));
    return rc;
}       //ParseInteger

/***LP  ParseOpcode - Parse ASL opcode: MachineCode, FunctionCode, SuperName
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - opcode type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseOpcode(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseOpcode(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            PNSOBJ pns;

            if ((GetNameSpaceObj(ptoken->szToken, gpnsCurrentScope, &pns, 0) ==
                 ASLERR_NONE) &&
                (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
                ((c == 'M') || (c == 'P')))
            {
                DWORD dwValue = 0;

                if (c == 'P')
                {
                    dwValue = pns->ObjData.uipDataValue;
                }
                else if (pns->ObjData.uipDataValue%8 == 0)
                {
                    dwValue = pns->ObjData.uipDataValue/8;
                }
                else
                {
                    PrintTokenErr(ptoken,
                                  "object can only be used in CreateField "
                                  "or CreateBitField statements",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }

                if (rc == ASLERR_NONE)
                {
                    rc = MakeIntData(dwValue, gpcodeScope);
                }
            }
            else
            {
                rc = ParseUserTerm(ptoken, TRUE);
            }
        }
        else
        {
            UnGetToken(ptoken);
            if (TermTable[ptoken->llTokenValue].dwfTermClass & TC_OPCODE)
            {
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                rc = TOKERR_NO_MATCH;
            }
        }
    }
    else
        rc = ParseData(ptoken);

    EXIT((1, "ParseOpcode=%d\n", rc));
    return rc;
}       //ParseOpcode

/***LP  ParseKeyword - Parse ASL keyword
 *
 *  ENTRY
 *      ptoken - token stream
 *      chExpectType - expected keyword type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 *
 *  NOTE
 *      DATATYPE_KEYWORD is a transient type.  It will be lumped together with
 *      other keyword type arguments and be converted into one DATATYPE_INTEGER.
 */

int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType)
{
    int rc;

    ENTER((1, "ParseKeyword(ptoken=%p,ExpectedType=%c)\n",
           ptoken, chExpectType));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if ((ptoken->llTokenValue == ID_USER) ||
            !(TermTable[ptoken->llTokenValue].dwfTermClass & TC_KEYWORD))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else if (TermTable[ptoken->llTokenValue].pszArgActions[0] !=
                 chExpectType)
        {
            PrintTokenErr(ptoken, "incorrect keyword type", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_KEYWORD;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = TOKID(ptoken->llTokenValue);
        }
    }

    EXIT((1, "ParseKeyword=%d\n", rc));
    return rc;
}       //ParseKeyword

/***LP  ParseString - Parse string object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseString(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseString(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
        if (gpcodeScope->dwDataLen > MAX_STRING_LEN + 1)
        {
            ERROR(("ParseString: string too big - %s", ptoken->szToken));
            rc = ASLERR_SYNTAX;
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC((size_t)gpcodeScope->dwDataLen)) == NULL)
        {
            ERROR(("ParseString: failed to allocate string object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_STRING;
            memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                   (int)gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
    }

    EXIT((1, "ParseString=%d\n", rc));
    return rc;
}       //ParseString

/***LP  CreateObject - Create NameSpace object for the term
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *      c - object type to be created
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;

    ENTER((2, "CreateObject(ptoken=%p,Name=%s,Type=%c)\n",
           ptoken, pszName, c));

    if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
         ASLERR_NONE) &&
        (pns->ObjData.dwDataType == OBJTYPE_EXTERNAL) ||
        ((rc = CreateNameSpaceObj(ptoken, pszName, gpnsCurrentScope,
                                  gpnsCurrentOwner, &pns, NSF_EXIST_ERR)) ==
         ASLERR_NONE))
    {
        if (!(gdwfASL & ASLF_UNASM))
        {
            ASSERT(gpcodeScope->pnsObj == NULL);
            gpcodeScope->dwfCode |= CF_CREATED_NSOBJ;
            gpcodeScope->pnsObj = pns;
            pns->Context = gpcodeScope;
        }

        switch (c)
        {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                pns->ObjData.dwDataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                pns->ObjData.dwDataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                pns->ObjData.dwDataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                pns->ObjData.dwDataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                pns->ObjData.dwDataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                pns->ObjData.dwDataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                pns->ObjData.dwDataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                pns->ObjData.dwDataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                pns->ObjData.dwDataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                pns->ObjData.dwDataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                ERROR(("CreateObject: invalid object type %c", c));
                rc = ASLERR_INVALID_OBJTYPE;
        }

        if (ppns != NULL)
        {
            *ppns = pns;
        }
    }

    EXIT((2, "CreateObject=%d\n", rc));
    return rc;
}       //CreateObject

#ifdef __UNASM
/***LP  CreateScopeObj - Create Scope object
 *
 *  ENTRY
 *      pszName -> object name
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pnsScope;
    PSZ psz;

    ENTER((2, "CreateScopeObj(Name=%s)\n", pszName));
    ASSERT(ppns != NULL);

    if ((psz = strrchr(pszName, '.')) != NULL)
    {
        *psz = '\0';
        if ((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pnsScope, 0)) ==
            ASLERR_NSOBJ_NOT_FOUND)
        {
            rc = CreateScopeObj(pszName, &pnsScope);
        }
        *psz = '.';
        psz++;
    }
    else if (pszName[0] == '\\')
    {
        pnsScope = gpnsNameSpaceRoot;
        psz = &pszName[1];
    }
    else
    {
        pnsScope = gpnsCurrentScope;
        psz = pszName;
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = CreateNameSpaceObj(NULL, psz, pnsScope, NULL, ppns,
                                  NSF_EXIST_OK)) == ASLERR_NONE))
    {
        (*ppns)->ObjData.dwDataType = OBJTYPE_EXTERNAL;
    }

    EXIT((2, "CreateScopeObj=%d (pns=%p)\n", rc, *ppns));
    return rc;
}       //CreateScopeObj
#endif  //ifdef __UNASM

/***LP  ValidateObject - Validate the existence and type of the object
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *  chActType - action type
 *      chArgType - argument type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType)
{
    int rc = ASLERR_NONE;
    ULONG dwDataType = OBJTYPE_UNKNOWN;

    ENTER((2, "ValidateObject(ptoken=%p,Name=%s,ActType=%c,ArgType=%c)\n",
           ptoken, pszName, chActType, chArgType));

    switch (chActType)
    {
        case NSTYPE_UNKNOWN:
        case NSTYPE_SCOPE:
            break;

        case NSTYPE_FIELDUNIT:
            dwDataType = OBJTYPE_FIELDUNIT;
            break;

        case NSTYPE_DEVICE:
            dwDataType = OBJTYPE_DEVICE;
            break;

        case NSTYPE_EVENT:
            dwDataType = OBJTYPE_EVENT;
            break;

        case NSTYPE_METHOD:
            dwDataType = OBJTYPE_METHOD;
            break;

        case NSTYPE_MUTEX:
            dwDataType = OBJTYPE_MUTEX;
            break;

        case NSTYPE_OPREGION:
            dwDataType = OBJTYPE_OPREGION;
            break;

        case NSTYPE_POWERRES:
            dwDataType = OBJTYPE_POWERRES;
            break;

        case NSTYPE_PROCESSOR:
            dwDataType = OBJTYPE_PROCESSOR;
            break;

        case NSTYPE_THERMALZONE:
            dwDataType = OBJTYPE_THERMALZONE;
            break;

        case NSTYPE_OBJALIAS:
            dwDataType = OBJTYPE_OBJALIAS;
            break;

        case NSTYPE_BUFFFIELD:
            dwDataType = OBJTYPE_BUFFFIELD;
            break;

        default:
            ERROR(("ValidateObject: invalid object type %c", chActType));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    if (rc == ASLERR_NONE)
    {
        PNSOBJ pns;
        char szMsg[MAX_MSG_LEN + 1];

        if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
             ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == gpnsCurrentOwner)))
        {
        if ((pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
            (chArgType != 'M') && (chArgType != 'P'))
        {
                PrintTokenErr(ptoken,
                              "object can only be used in the index argument "
                              "of CreateXField or Index statements",
                              TRUE);
                rc = ASLERR_SYNTAX;
        }
            else if ((dwDataType != OBJTYPE_UNKNOWN) &&
                (pns->ObjData.dwDataType != dwDataType))
            {
                sprintf(szMsg,
                        "%s has an incorrect type (ObjType=%s, ExpectedType=%s)",
                        pszName, GetObjectTypeName(pns->ObjData.dwDataType),
                        GetObjectTypeName(dwDataType));
                PrintTokenErr(ptoken, szMsg, TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((chActType == NSTYPE_SCOPE) ||
                 (chActType == NSTYPE_OPREGION))
            {
                ASSERT(gpcodeScope->pnsObj == NULL);
                gpcodeScope->pnsObj = pns;
            }
        }
        else if ((rc == ASLERR_NSOBJ_NOT_FOUND) && (gpnsCurrentOwner != NULL))
        {
            //
            // We are in a method referring to something not yet defined.
            // Let's queue it and check it after we are done.
            //
            rc = QueueNSChk(ptoken, pszName, dwDataType, 0);
        }
        else
        {
            sprintf(szMsg, "%s does not exist or not in accessible scope",
                    pszName);
            PrintTokenErr(ptoken, szMsg, FALSE);
            rc = ASLERR_NONE;
        }
    }

    EXIT((2, "ValidateObject=%d\n", rc));
    return rc;
}       //ValidateObject

/***LP  ValidateNSChkList - Validate objects in NSCHK list
 *
 *  ENTRY
 *      pnschkHead -> NSCHK list
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateNSChkList(PNSCHK pnschkHead)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;
    ENTER((2, "ValidateNSChkList(Head=%p)\n", pnschkHead));

    while ((rc == ASLERR_NONE) && (pnschkHead != NULL))
    {
        if ((GetNameSpaceObj(pnschkHead->szObjName, pnschkHead->pnsScope, &pns,
                             0) == ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == pnschkHead->pnsMethod)))
        {
            if (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD)
            {
                ErrPrintf("%s(%d): error: cannot make forward reference to PNP resource object %s\n",
                          pnschkHead->pszFile, pnschkHead->wLineNum,
                          pnschkHead->szObjName);
                rc = ASLERR_SYNTAX;
            }
            else if ((pnschkHead->dwExpectedType != OBJTYPE_UNKNOWN) &&
                     (pns->ObjData.dwDataType != pnschkHead->dwExpectedType))
            {
                ErrPrintf("%s(%d): warning: %s has incorrect type (ObjType=%s, ExpectedType=%s)\n",
                          pnschkHead->pszFile,
                          pnschkHead->wLineNum,
                          pnschkHead->szObjName,
                          GetObjectTypeName(pns->ObjData.dwDataType),
                          GetObjectTypeName(pnschkHead->dwExpectedType));
            }
            else if (pnschkHead->dwExpectedType == OBJTYPE_METHOD)

            {
                if (pns->ObjData.uipDataValue < pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too many arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
                else if (pns->ObjData.uipDataValue > pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too few arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
        else
        {
            ErrPrintf("%s(%d): warning: %s does not exist or not in accessible scope\n",
                      pnschkHead->pszFile,
                      pnschkHead->wLineNum,
                      pnschkHead->szObjName);

        }

        pnschkHead = pnschkHead->pnschkNext;
    }

    EXIT((2, "ValidateNSChkList=%d\n", rc));
    return rc;
}       //ValidateNSChkList

/***LP  QueueNSChk - Queue a NSChk request
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszObjName -> object name
 *      dwExpectedType - expected object type
 *      dwChkData - object specific check data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData)
{
    int rc = ASLERR_NONE;
    PNSCHK pnschk;

    ENTER((2, "QueueNSChk(ptoken=%p,Obj=%s,ExpectedType=%s,ChkData=%x)\n",
           ptoken, pszObjName, GetObjectTypeName(dwExpectedType), dwChkData));

    if ((pnschk = MEMALLOC(sizeof(NSCHK))) == NULL)
    {
        ERROR(("QueueNSChk: failed to allocate NSCHK object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        memset(pnschk, 0, sizeof(NSCHK));
        strcpy(pnschk->szObjName, pszObjName);
        pnschk->pszFile = gpszASLFile;
        pnschk->pnsScope = gpnsCurrentScope;
        pnschk->pnsMethod = gpnsCurrentOwner;
        pnschk->dwExpectedType = dwExpectedType;
        pnschk->dwChkData = dwChkData;
        pnschk->wLineNum = ptoken->pline->wLineNum;
        if (gpnschkTail != NULL)
        {
            gpnschkTail->pnschkNext = pnschk;
            gpnschkTail = pnschk;
        }
        else
        {
            gpnschkHead = gpnschkTail = pnschk;
        }
    }

    EXIT((2, "QueueNSChk=%d\n"));
    return rc;
}       //QueueNSChk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\battc\battc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    battc.c

Abstract:

    Battery Class Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "battcp.h"

#include <initguid.h>
#include <batclass.h>


WMIGUIDREGINFO BattWmiGuidList[BattWmiTotalGuids] =
{
    {
        &BATTERY_STATUS_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_RUNTIME_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_TEMPERATURE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_FULL_CHARGED_CAPACITY_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_CYCLE_COUNT_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_STATIC_DATA_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_STATUS_CHANGE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_TAG_CHANGE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    }
};


//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );





#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,BatteryClassInitializeDevice)
#pragma alloc_text(PAGE,BatteryClassUnload)
#pragma alloc_text(PAGE,BatteryClassIoctl)
#endif


#if DEBUG
    #if DBG
        ULONG       BattDebug = BATT_ERROR|BATT_WARN;
    #else
        ULONG       BattDebug = 0x0;
    #endif

    ULONG           NextDeviceNum = 0;  // Used to assign a unique number to each device for debugging.

#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{

    return STATUS_SUCCESS;
}





NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    )
/*++

Routine Description:

    Initializes a new battery class device.

    N.B. The caller needs to reserve 1 IRP stack location for the
    battery class driver

Arguments:

    MiniportInfo - Pointer to registration structure for driver
                   registering as a battery miniport

    ClassData    - Returned battery class handle for use by the
                   miniport when invoking furture battery class functions

Return Value:

    On sucess the battery has been registered.

--*/
{
    PBATT_NP_INFO           BattNPInfo;
    PBATT_INFO              BattInfo;

    NTSTATUS                status  = STATUS_SUCCESS;

    PAGED_CODE();

#if DEBUG
    if (MiniportInfo->DeviceName && MiniportInfo->DeviceName->Buffer) {
        BattPrint ((BATT_TRACE), ("BattC (%d): InitializeDevice (Pdo = 0x%08lx) (DeviceName = %ws)\n", NextDeviceNum, MiniportInfo->Pdo, MiniportInfo->DeviceName->Buffer));
    } else {
        BattPrint ((BATT_TRACE), ("BattC (%d): InitializeDevice (Pdo = 0x%08lx)\n", NextDeviceNum, MiniportInfo->Pdo));
    }
#endif

    if (MiniportInfo->MajorVersion != BATTERY_CLASS_MAJOR_VERSION) {
        return STATUS_REVISION_MISMATCH;
    }


    //
    // Allocate space for the class info to be kept with this device instance
    //

    BattNPInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(BATT_NP_INFO), 'ttaB');
    if (!BattNPInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    BattInfo = ExAllocatePoolWithTag(PagedPool, sizeof(BATT_INFO), 'ttaB');
    if (!BattInfo) {
        ExFreePool (BattNPInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory (BattNPInfo, sizeof(*BattNPInfo));
    RtlZeroMemory (BattInfo, sizeof(*BattInfo));


    //
    // Capture Miniport info
    //

    RtlCopyMemory (&BattInfo->Mp, MiniportInfo, sizeof(*MiniportInfo));


    //
    // Initilize class driver values
    //

    KeInitializeTimer (&BattNPInfo->WorkerTimer);
    KeInitializeTimer (&BattNPInfo->TagTimer);
    KeInitializeDpc (&BattNPInfo->WorkerDpc, BattCWorkerDpc, BattNPInfo);
    KeInitializeDpc (&BattNPInfo->TagDpc, BattCTagDpc, BattNPInfo);
    ExInitializeWorkItem (&BattNPInfo->WorkerThread, BattCWorkerThread, BattNPInfo);
    ExInitializeFastMutex (&BattNPInfo->Mutex);
    BattNPInfo->TagNotified = TRUE;
    BattNPInfo->StatusNotified = TRUE;

    BattNPInfo->BattInfo = BattInfo;
#if DEBUG
    BattInfo->BattNPInfo = BattNPInfo;
#endif

    BattInfo->Tag = BATTERY_TAG_INVALID;
    InitializeListHead (&BattInfo->IoQueue);
    InitializeListHead (&BattInfo->StatusQueue);
    InitializeListHead (&BattInfo->TagQueue);
    InitializeListHead (&BattInfo->WmiQueue);

    //
    // Removal lock initialization
    //
    BattNPInfo->WantToRemove = FALSE;
    //
    // InUseCount is set to 2.  1 lock is always held until the removal time.
    // 1 additional lock is held for the worker thread which only releases it
    // at removal time.  Rather than aquiring and releasing each time, it just
    // checks WantToRemove to determine if it should release the lock.
    //
    BattNPInfo->InUseCount = 2;
    KeInitializeEvent(&BattNPInfo->ReadyToRemove, SynchronizationEvent, FALSE);

#if DEBUG // Set device Number for debug prints.
    BattNPInfo->DeviceNum = NextDeviceNum;
    NextDeviceNum++;
#endif

    *ClassData = BattNPInfo;


    //
    // Check to see if this is a battery other than the composite
    //

    if (MiniportInfo->Pdo) {

        // Blank UNICODE_STRING so IoRegisterDeviceInterface will allocate space.
        RtlInitUnicodeString (&BattInfo->SymbolicLinkName, NULL);

        //
        //  Create the symbolic link
        //

        status = IoRegisterDeviceInterface(
                            MiniportInfo->Pdo,
                            (LPGUID)&GUID_DEVICE_BATTERY,
                            NULL,
                            &BattInfo->SymbolicLinkName);

        if (NT_SUCCESS(status)) {

            //
            //  Now set the symbolic link for the association and store it..
            //

            BattPrint ((BATT_NOTE), ("BattC (%d): Making SetDeviceInterfaceState call.\n", BattNPInfo->DeviceNum));

            status = IoSetDeviceInterfaceState(&BattInfo->SymbolicLinkName, TRUE);

            if (status == STATUS_OBJECT_NAME_EXISTS) {
                // The device interface was already enabled.  Continue anyway.
                BattPrint ((BATT_WARN), ("BattC (%d): Got STATUS_OBJECT_NAME_EXISTS for SetDeviceInterfaceState\n", BattNPInfo->DeviceNum));

                status = STATUS_SUCCESS;
            }
        }
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassInitializeDevice (status = 0x%08lx).\n", BattNPInfo->DeviceNum, status));

    return status;
}   // BatteryClassInitializeDevice






NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    )
/*++

Routine Description:

    Called by the miniport when it has received a remove request.
    The miniclass driver must syncronize itself so that this API is
    not called while any of the others are not yet completed.

Arguments:

    ClassData   - Handle to class driver

Return Value:

    This routine must not fail.  It returns STATUS_SUCCESS

--*/
{
    NTSTATUS            status;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassUnload called.\n", BattNPInfo->DeviceNum));


    //
    //  Disable the symbolic link
    //

    ASSERT(BattInfo->SymbolicLinkName.Buffer);

    status = IoSetDeviceInterfaceState(&BattInfo->SymbolicLinkName, FALSE);
    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("BattC (%d) Unload: IoSetDeviceInterface returned 0x%08lx\n", BattNPInfo->DeviceNum, status));
    }

    //
    // Syncronization with the worker thread.
    // We can't return because the worker may be in the middle of something.
    // By returning, the battery class driver gives up the right to call miniport routines.
    //
    // This needs to be done before canceling the timers so that the worker
    // thread doesn't reset them.
    //

    BattNPInfo->WantToRemove = TRUE;

    //
    // Cancel timers
    // If a timer had been waiting,we need to release the remove lock that was
    // aquired before the timer was set since it will not be released in the DPC.
    //
    if (KeCancelTimer (&BattNPInfo->WorkerTimer)) {
        // Release Removal Lock
        // "InUseCount can never be 0 after this operation.
        InterlockedDecrement(&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BatteryClassUnload: Released WorkerTimer remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    }
    if (KeCancelTimer (&BattNPInfo->TagTimer)) {
        // Release Removal Lock
        // "InUseCount can never be 0 after this operation.
        InterlockedDecrement(&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BatteryClassUnload: Released TagTimer remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    }

    //
    // Queue the worker thread once more to make sure that the remove lock for
    // the worker thread is released.
    //
    BattCQueueWorker (BattNPInfo, FALSE);

    // Finish syncronization
    if (InterlockedDecrement (&BattNPInfo->InUseCount) > 0) {
        KeWaitForSingleObject (&BattNPInfo->ReadyToRemove,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
    }
    BattPrint ((BATT_LOCK), ("BatteryClassUnload: Done waiting for remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));


    //
    // Free Structures
    //
    ExFreePool (BattInfo->SymbolicLinkName.Buffer);
    ExFreePool (BattInfo);
    ExFreePool (BattNPInfo);


    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassUnload returning.\n", BattNPInfo->DeviceNum));

    return STATUS_SUCCESS;
}




NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called by the miniport to handle battery ioctl requests.  If handled,
    the battery class driver owns the IRP.  If not handled, it belongs to
    the caller.

Arguments:

    ClassData   - Handle to class driver

    Irp         - ICOTL irp to check

Return Value:

    If handled, the battery class driver owns the IRP and will complete it
    once its handled; otherwise, the error STATUS_NOT_SUPPORTED is returned.

--*/
{
    NTSTATUS            status;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;
    PIO_STACK_LOCATION  IrpSp;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassIoctl called.\n", BattNPInfo->DeviceNum));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Assume it's not our IRP
    //

    status = STATUS_NOT_SUPPORTED;

    //
    // Check IOCTL code to see if it's our IRP
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_BATTERY_QUERY_TAG:
        case IOCTL_BATTERY_QUERY_INFORMATION:
        case IOCTL_BATTERY_SET_INFORMATION:
        case IOCTL_BATTERY_QUERY_STATUS:

            //
            // Acquire remove lock.
            // We don't want to queue anything more if we're being removed.
            //

            InterlockedIncrement (&BattNPInfo->InUseCount);
            BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            if (BattNPInfo->WantToRemove == TRUE) {
                if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                    KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

                status = STATUS_DEVICE_REMOVED;

            } else {

                //
                // Irp to handle.  Put it in the queue worker threads list
                //

                status = STATUS_PENDING;
                Irp->IoStatus.Status = STATUS_PENDING;
                IoMarkIrpPending (Irp);
                ExAcquireFastMutex (&BattNPInfo->Mutex);
                InsertTailList (&BattInfo->IoQueue, &Irp->Tail.Overlay.ListEntry);
                ExReleaseFastMutex (&BattNPInfo->Mutex);
                BattCQueueWorker (BattNPInfo, FALSE);

                //
                // Release Remove Lock.
                //

                if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                    KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
            }

            break;

        default:
            BattPrint ((BATT_ERROR|BATT_IOCTL),
                      ("BattC (%d): unknown battery ioctl - %x\n",
                      BattNPInfo->DeviceNum,
                      IrpSp->Parameters.DeviceIoControl.IoControlCode));
            break;
    }

    if ((status != STATUS_PENDING) && (status != STATUS_NOT_SUPPORTED)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassIoctl returning (status = 0x%08lx).\n", BattNPInfo->DeviceNum, status));

    return status;
}



NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    )
/*++

Routine Description:

    Called by the miniport to signify that something interesting concerning
    the battery status has occured.  Calling this function will cause the
    battery class driver to obtain the battery status if there are any pending
    status requests pending.

    If the miniport supports SetNotify from the class driver, then the miniport
    only needs to call this function once when the notification crtierea is
    met.

    If the miniport does not support SetNotify from the class driver, then
    the class driver will poll (at a slow rate) but the miniport should still
    call this function at least when the batteries power status changes such
    that timely updates of at least the power status will occur in the UI.

Arguments:

    ClassData   - Handle to class driver

Return Value:

    Status

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) ClassData;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassStatusNotify called\n", BattNPInfo->DeviceNum));

    InterlockedExchange (&BattNPInfo->StatusNotified, 1);
    InterlockedExchange (&BattNPInfo->TagNotified, 1);
    BattCQueueWorker (BattNPInfo, TRUE);
    return STATUS_SUCCESS;
}


NTSTATUS
BATTERYCLASSAPI
BatteryClassSystemControl (
    IN  PVOID ClassData,
    IN  PWMILIB_CONTEXT WmiLibContext,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP Irp,
    OUT PSYSCTL_IRP_DISPOSITION Disposition
    )
/*++

Routine Description:

    The miniport driver calls this instead of WmiSystemControl.

Arguments:

    ClassData   - Handle to class driver

    The other parameters are the parameters for WmiSystemControl.

Return Value:

    STATUS_SUCCESS or one of the following error codes:

    STATUS_INVALID_DEVICE_REQUEST

    STATUS_WMI_GUID_NOT_FOUND

    STATUS_WMI_INSTANCE_NOT_FOUND

--*/

{
    NTSTATUS            status = STATUS_NOT_SUPPORTED;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;
    PIO_STACK_LOCATION  IrpSp;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;
    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassSystemControl called.\n", BattNPInfo->DeviceNum));

    //
    // Initialize the WmiLibContext structure if this is the first time.
    //
    if (BattInfo->WmiLibContext.GuidCount == 0) {
        RtlCopyMemory(&BattInfo->WmiLibContext,
                      WmiLibContext,
                      sizeof(*WmiLibContext));

        BattInfo->WmiLibContext.GuidCount = WmiLibContext->GuidCount + BattWmiTotalGuids;
        BattInfo->WmiGuidIndex = WmiLibContext->GuidCount;
        BattInfo->WmiLibContext.GuidList = ExAllocatePoolWithTag(PagedPool, BattInfo->WmiLibContext.GuidCount * sizeof(WMIGUIDREGINFO), 'ttaB');
        if (!BattInfo->WmiLibContext.GuidList) {
            //
            // Figure out how to fail gracefully.
            //
        }
        RtlCopyMemory(BattInfo->WmiLibContext.GuidList,
                      WmiLibContext->GuidList,
                      WmiLibContext->GuidCount * sizeof(WMIGUIDREGINFO));
        RtlCopyMemory(&BattInfo->WmiLibContext.GuidList [WmiLibContext->GuidCount],
                      BattWmiGuidList, BattWmiTotalGuids * sizeof(WMIGUIDREGINFO));
    }

    //
    // Acquire remove lock.
    // We don't want to queue anything more if we're being removed.
    //

    InterlockedIncrement (&BattNPInfo->InUseCount);
    BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    if (BattNPInfo->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
            KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        status = STATUS_DEVICE_REMOVED;

    } else {

        status = WmiSystemControl(&BattInfo->WmiLibContext,
                                  DeviceObject,
                                  Irp,
                                  Disposition);

        BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Returned from WmiSystemControl (status = 0x%08x).\n", BattNPInfo->DeviceNum, status));

        //
        // For IRP_MN_REGINFO BattC needs to add additional data to the IRP
        // about the battery class MOF resource.
        //

        if ((*Disposition == IrpNotCompleted) &&
            ((IrpSp->MinorFunction == IRP_MN_REGINFO) ||
            (IrpSp->MinorFunction == IRP_MN_REGINFO_EX)) &&
            (IrpSp->Parameters.WMI.DataPath == WMIREGISTER)) {

            //
            // Original structure
            //
            PWMIREGINFO regInfoPtr = IrpSp->Parameters.WMI.Buffer;

            BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Adding Resource.\n", BattNPInfo->DeviceNum));
            //
            // If WmiSystemControl returned STATUS_BUFFER_TOO_SMALL or entered
            // the correct size as a ULONG in IoStatus.Information.
            // Increase the required size to accomodate battery class data
            // before returning
            //

            if (Irp->IoStatus.Information == sizeof(ULONG) ||
                Irp->IoStatus.Status == STATUS_BUFFER_TOO_SMALL) {

                //
                // Aditional battery class data includes one WMIREGINFO structure
                // Followed strings for the regstry path and resource name.
                // (Plus two WCHARS because these need to be counted strings.)
                // Round this up to the nearest 8 bytes.
                //
                regInfoPtr->BufferSize =
                    (regInfoPtr->BufferSize +
                     sizeof(WMIREGINFO) +
                     sizeof(MOFREGISTRYPATH) +
                     sizeof(MOFRESOURCENAME) + 2 * sizeof(WCHAR) + 7) & 0xFFFFFFF8;

                BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Buffer Too Small:\n"
                                          "    Information = %08x\n"
                                          "    BufferSize = %08x\n"
                                          "    NewSize = %08x\n",
                                          BattNPInfo->DeviceNum,
                                          Irp->IoStatus.Information,
                                          IrpSp->Parameters.WMI.BufferSize,
                                          regInfoPtr->BufferSize));

                //
                // Make sure IRP is set up to fail correctly.
                //
                Irp->IoStatus.Information = sizeof(ULONG);
                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                ULONG size;
                PWCHAR tempString;

                //
                // Assume that there is only one WmiRegInfo Structure so far.
                //
                ASSERT (regInfoPtr->NextWmiRegInfo == 0);

                regInfoPtr->NextWmiRegInfo = (regInfoPtr->BufferSize + 7) & 0xFFFFFFF8;
                size = regInfoPtr->NextWmiRegInfo + sizeof(WMIREGINFO) +
                       sizeof(MOFRESOURCENAME) + sizeof(MOFREGISTRYPATH) + 2 * sizeof(WCHAR);

                //
                // Set BufferSize Whether we succeed or not.
                //
                ((PWMIREGINFO)IrpSp->Parameters.WMI.Buffer)->BufferSize = size;

                if (size > IrpSp->Parameters.WMI.BufferSize) {
                    //
                    // If WmiSystemControl was successful, but there isnt room
                    // for the extra data, this request needs to fail
                    //
                    Irp->IoStatus.Information = sizeof(ULONG);
                    Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                    status = STATUS_BUFFER_TOO_SMALL;
                    BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Buffer Too Small.\n"
                                              "    BufferSize = %08x\n"
                                              "    Size = %08x\n",
                                              BattNPInfo->DeviceNum,
                                              IrpSp->Parameters.WMI.BufferSize,
                                              size));
                } else {
                    Irp->IoStatus.Information = size;

                    BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Munging Structures:\n"
                                              "    Buffer = %08x\n"
                                              "    temp = %08x\n",
                                              BattNPInfo->DeviceNum,
                                              (ULONG_PTR) IrpSp->Parameters.WMI.Buffer,
                                              (ULONG_PTR) regInfoPtr));
                    //
                    // Intialize new structure
                    //

                    // Set teporary pointer to point at data structure we are adding.
                    (ULONG_PTR)regInfoPtr += (ULONG_PTR)regInfoPtr->NextWmiRegInfo;

                    regInfoPtr->BufferSize = sizeof(WMIREGINFO) +
                                             sizeof(MOFRESOURCENAME) +
                                             sizeof(MOFREGISTRYPATH) + 2 * sizeof(WCHAR);
                    regInfoPtr->NextWmiRegInfo = 0;

                    // Initialize RegistryPath counted string.
                    regInfoPtr->RegistryPath = sizeof(WMIREGINFO);
                    tempString = (PWCHAR)((ULONG_PTR)regInfoPtr + sizeof(WMIREGINFO));
                    *tempString++ = sizeof(MOFREGISTRYPATH);
                    RtlCopyMemory(tempString, MOFREGISTRYPATH, sizeof(MOFREGISTRYPATH));

                    // Initialize MofResourceName counted string.
                    regInfoPtr->MofResourceName = sizeof(WMIREGINFO) + sizeof(MOFREGISTRYPATH) + sizeof(WCHAR);
                    tempString = (PWCHAR)((ULONG_PTR)regInfoPtr + regInfoPtr->MofResourceName);
                    *tempString++ = sizeof(MOFRESOURCENAME);
                    RtlCopyMemory(tempString, MOFRESOURCENAME, sizeof(MOFRESOURCENAME));

                    regInfoPtr->GuidCount = 0;

                }
            }
        }

        //
        // Release Remove Lock.
        //

        if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
            KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
    }

    return status;
}


NTSTATUS
BATTERYCLASSAPI
BatteryClassQueryWmiDataBlock(
    IN PVOID ClassData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PBATT_NP_INFO       BattNPInfo = (PBATT_NP_INFO) ClassData;
    PBATT_INFO          BattInfo = BattNPInfo->BattInfo;
    PBATT_WMI_REQUEST   WmiRequest;

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       size = 0;

    PAGED_CODE();

    BattPrint ((BATT_TRACE|BATT_WMI), ("Entered BatteryClassQueryWmiDataBlock\n"));

    //
    // Don't need to acquire remove lock.  It is already head by SystemControl.
    //

    switch (GuidIndex - BattInfo->WmiGuidIndex) {
    case BattWmiStatusId:
        size = sizeof (BATTERY_WMI_STATUS);
        break;
    case BattWmiRuntimeId:
        size = sizeof (BATTERY_WMI_RUNTIME);
        break;
    case BattWmiTemperatureId:
        size = sizeof (BATTERY_WMI_TEMPERATURE);
        break;
    case BattWmiFullChargedCapacityId:
        size = sizeof (BATTERY_WMI_FULL_CHARGED_CAPACITY);
        break;
    case BattWmiCycleCountId:
        size = sizeof (BATTERY_WMI_CYCLE_COUNT);
        break;
    case BattWmiStaticDataId:
        size = sizeof(BATTERY_WMI_STATIC_DATA)+4*MAX_BATTERY_STRING_SIZE*sizeof(WCHAR);
          // data plus 4 strings
        break;
    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    if (status != STATUS_WMI_GUID_NOT_FOUND) {
        if (OutBufferSize < size ) {
            status = STATUS_BUFFER_TOO_SMALL;
            *InstanceLengthArray = size;

            status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);
            return status;
        }

        WmiRequest = ExAllocatePoolWithTag (PagedPool, sizeof(BATT_WMI_REQUEST), 'ttaB');
        if (!WmiRequest) {
            BattPrint((BATT_ERROR), ("Failed to allocate memory for WMI request\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);
            return status;
        }

        WmiRequest->DeviceObject = DeviceObject;
        WmiRequest->Irp = Irp;
        WmiRequest->GuidIndex = GuidIndex - BattInfo->WmiGuidIndex;
        WmiRequest->InstanceLengthArray = InstanceLengthArray;
        WmiRequest->OutBufferSize = OutBufferSize;
        WmiRequest->Buffer = Buffer;

        ExAcquireFastMutex (&BattNPInfo->Mutex);
        InsertTailList (&BattInfo->WmiQueue, &WmiRequest->ListEntry);
        ExReleaseFastMutex (&BattNPInfo->Mutex);
        BattCQueueWorker (BattNPInfo, FALSE);

        status = STATUS_PENDING;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\proto.h ===
/*** proto.h - Local function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PROTO_H
#define _PROTO_H

// asl.c
int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig);
int LOCAL InitNameSpace(VOID);
VOID LOCAL PrintLogo(VOID);
int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT);
VOID LOCAL PrintUsage(VOID);

// parseasl.c
int LOCAL ParseASLFile(PSZ pszFile);
int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel);
BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent);
int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel);
int LOCAL ParseFieldList(PTOKEN ptoken);
int LOCAL ParsePackageList(PTOKEN ptoken);
int LOCAL ParseBuffList(PTOKEN ptoken);
int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize);
int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs);
int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK);
int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode);
int LOCAL ParseSuperName(PTOKEN ptoken);
int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc);
int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData);
int LOCAL ParseData(PTOKEN ptoken);
int LOCAL ParseInteger(PTOKEN ptoken, char c);
int LOCAL ParseOpcode(PTOKEN ptoken, char c);
int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType);
int LOCAL ParseString(PTOKEN ptoken);
int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns);
#ifdef __UNASM
int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns);
#endif
int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType);
int LOCAL ValidateNSChkList(PNSCHK pnschkHead);
int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData);

// aslterms.c
int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Include(PTOKEN ptoken, BOOL fActionFL);
int LOCAL External(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Method(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Alias(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Name(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Scope(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Field(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL);
int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Match(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Else(PTOKEN ptoken, BOOL fActionFL);

// pnpmacro.c
int LOCAL XferCodeToBuff(PBYTE pbBuff, PDWORD pdwcb, PCODEOBJ pcCode);
int LOCAL ResourceTemplate(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AddSmallOffset(PTOKEN ptoken, BOOL fActionFL);
int LOCAL StartDependentFn(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IRQDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DMADesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorDesc(PTOKEN ptoken, DWORD dwMaxSize);
int LOCAL VendorShort(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InsertDescLength(PCODEOBJ pcode, DWORD dwDescLen);
int LOCAL Memory24Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorLong(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Memory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedMemory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL MemSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL IOSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL DWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordBusNumDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InterruptDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL CreateResFields(PTOKEN ptoken, PNSOBJ pnsParent, PRESFIELD prf);

// acpins.c
int LOCAL GetNameSpaceObj(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                          DWORD dwfNS);
int LOCAL CreateNameSpaceObj(PTOKEN ptoken, PSZ pszName, PNSOBJ pnsScope,
                             PNSOBJ pnsOwner, PPNSOBJ ppns, DWORD dwfNS);
VOID LOCAL DumpNameSpacePaths(PNSOBJ pnsObj, FILE *pfileOut);
PSZ LOCAL GetObjectPath(PNSOBJ pns);
PSZ LOCAL GetObjectTypeName(DWORD dwObjType);

// misc.c
BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen);
BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken);
int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen);
int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding);
VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum);
int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen);
int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID);
VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen);
VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild);
VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode);
VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode);
BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen);
int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID);
int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex);
int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset);
VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot);

// unasm.c
int LOCAL UnAsmFile(PSZ pszAMLName, FILE *pfileOut);
int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb);
int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, FILE *pfileOut);
int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh, FILE *pfileOut);
VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, FILE *pfileOut);
VOID LOCAL DumpCode(PBYTE pbOp, FILE *pfileOut);
VOID LOCAL PrintIndent(int iLevel, FILE *pfileOut);
BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(DWORD dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bDate);
int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut);
int LOCAL UnAsmOpcode(PBYTE *ppbOp, FILE *pfileOut);
int LOCAL UnAsmDataObj(PBYTE *ppbOp, FILE *pfileOut);
int LOCAL UnAsmNameObj(PBYTE *ppbOp, FILE *pfileOut, PNSOBJ *ppns, char c);
int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen);
int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, FILE *pfileOut);
int LOCAL UnAsmSuperName(PBYTE *ppbOp, FILE *pfileOut);
int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, FILE *pfileOut);
DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext);
int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut);
int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut);
int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, FILE *pfileOut);
int LOCAL UnAsmField(PBYTE *ppbOp, FILE *pfileOut, PDWORD pdwBitPos);

#ifdef __UNASM
// tables.c
BOOL LOCAL IsWinNT(VOID);
#ifndef WINNT
HANDLE LOCAL OpenVxD(VOID);
VOID LOCAL CloseVxD(HANDLE hVxD);
PBYTE LOCAL VxDGetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL VxDGetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
#endif
PBYTE LOCAL GetNTTable(DWORD dwTabSig);
PBYTE LOCAL GetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL GetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
int LOCAL DumpAllTables(FILE *pfileOut);
int LOCAL DumpTableBySig(FILE *pfileOut, DWORD dwTableSig);
int LOCAL DumpTableByAddr(FILE *pfileOut, DWORD dwTableAddr);
int LOCAL DumpRSDP(FILE *pfileOut, PBYTE pb, DWORD dwAddr);
int LOCAL DumpTable(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                    DWORD dwTableSig);
int LOCAL DumpTableTxt(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                       DWORD dwTableSig);
int LOCAL DumpTableBin(DWORD dwTableSig, DWORD dwAddr, PBYTE pb, DWORD dwLen);
int LOCAL FindTableFmt(DWORD dwTableSig, PFMT *ppfmt, PDWORD pdwFlags);
PSZ LOCAL GetTableSigStr(DWORD dwTableSig);
#endif

// debug.c
VOID CDECL ErrPrintf(char *pszFormat, ...);
#ifdef TRACING
VOID LOCAL OpenTrace(char *pszTraceOut);
VOID LOCAL CloseTrace(VOID);
VOID CDECL EnterProc(int n, char *pszFormat, ...);
VOID CDECL ExitProc(int n, char *pszForamt, ...);
#endif

#endif  //ifndef _PROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\battc\battcp.h ===
#define BATTERYCLASS    1

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <wmistr.h>
#include <wmilib.h>
#include <batclass.h>

//
// Debug
//

#define DEBUG   DBG

#if DEBUG
    extern ULONG BattDebug;
    extern ULONG NextDeviceNum;
    #define BattPrint(l,m)    if(l & BattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BATT_LOW            0x00000001
#define BATT_NOTE           0x00000002
#define BATT_WARN           0x00000004
#define BATT_ERROR          0x00000008
#define BATT_TRACE          0x00000010
#define BATT_MP_ERROR       0x00000100
#define BATT_MP_DATA        0x00000200
#define BATT_IOCTL          0x00001000
#define BATT_IOCTL_DATA     0x00002000
#define BATT_IOCTL_QUEUE    0x00004000
#define BATT_WMI            0x00008000
#define BATT_LOCK           0x00010000
#define BATT_DEBUG          0x80000000


//
// Battery class info
//

#define NTMS    10000L                          // 1 millisecond is ten thousand 100ns
#define NTSEC   (NTMS * 1000L)
#define NTMIN   ((ULONGLONG) 60 * NTSEC)

#define SEC     1000
#define MIN     (60 * SEC)

#define MIN_STATUS_POLL_RATE        (3L * NTMIN)
// This is the slowest rate at which we should ever poll
// the battery when doing polling.

#define MAX_STATUS_POLL_RATE        (20 * NTSEC)
// This is in general the fastest we should ever poll the battery.

#define INVALID_DATA_POLL_RATE      (1 * NTSEC)
// If the battery returned invalid information, we want to poll
// it more frequesntly, since invalid information generally
// indicates that the battery was in a transition state.  The user
// will not want to wait 20 seconds for the UI to update, but we don't
// want to poll too fast and hurt the performance of a machine with a
// poorly designed battery too much.
#define INVALID_DATA_MAX_RETRY      10
// Only retry 20 time before giving up.
// This should be reset on any notifiation from the battery.

#define STATUS_VALID_TIME           (2 * NTSEC)
// If a request is received within STATUS_VALID_TIME of the last request
// time information was read, and there hasn't been a notification from
// the battery, the driver will assume that the cached values are good enough.

//
// WMI info
//

#define MOFRESOURCENAME L"BATTCWMI"
#define MOFREGISTRYPATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\BattC"
//#define MOFREGISTRYPATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{72631E54-78A4-11D0-BCF7-00AA00B7B32A}"

typedef enum {
    BattWmiStatusId,
    BattWmiRuntimeId,
    BattWmiTemperatureId,
    BattWmiFullChargedCapacityId,
    BattWmiCycleCountId,
    BattWmiStaticDataId,
    BattWmiStatusChangeId,
    BattWmiTagChangeId,
    BattWmiTotalGuids
} BATT_WMI_GUID_INDEX;


//
// Non-paged battery class information
//

typedef struct {

    //
    // Pointer to paged information
    //
    struct _BATT_INFO       *BattInfo;          // Pointer to paged portion

    //
    // General
    //

    KTIMER                  WorkerTimer;        // Timer to get worker thread
    KDPC                    WorkerDpc;          // DPC to get worker thread
    KTIMER                  TagTimer;           // Timer for query tag requests
    KDPC                    TagDpc;
    WORK_QUEUE_ITEM         WorkerThread;       // WORK_QUEUE to get worker thread
    ULONG                   WorkerActive;
    ULONG                   CheckStatus;        // Worker to check status
    ULONG                   CheckTag;           // Worker to check for battery tag
    ULONG                   StatusNotified;     // Notification has occured (must re-read)
    ULONG                   TagNotified;

    FAST_MUTEX              Mutex;              // Synchorize with worker thread

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

#if DEBUG
    ULONG                   DeviceNum;          // Device number for debug prints
#endif

} BATT_NP_INFO, *PBATT_NP_INFO;



//
// Paged battery class information
//

typedef struct _BATT_INFO {

    WMILIB_CONTEXT          WmiLibContext;
    ULONG                   WmiGuidIndex;       // Used to ignore miniclass WMI
                                                // GUIDs

    //
    // IO
    //

    ULONG                   Tag;                // Current battery tag

    LIST_ENTRY              IoQueue;            // IRPs waiting to be processed
    LIST_ENTRY              StatusQueue;        // Waiting status requests
    LIST_ENTRY              TagQueue;           // Waiting battery tag requests
    LIST_ENTRY              WmiQueue;

    ULONGLONG               TagTime;            // Time when tag was read
    ULONGLONG               StatusTime;         // Time when status was read
    BATTERY_STATUS          Status;             // The status
    ULONG                   InvalidRetryCount;  // How many times ni a row has the battery returned invalid data?
#if DEBUG
    ULONG                   FullChargedCap;
    PBATT_NP_INFO           BattNPInfo;
#endif
    ULONG                   NotifyTimeout;      // LCD timeout of wat
    BATTERY_MINIPORT_INFO   Mp;                 // Miniport Info

    UNICODE_STRING          SymbolicLinkName;   // Name returned by IoRegisterDeviceInterface

} BATT_INFO, *PBATT_INFO;

//
// WmiQueue entry
//

typedef struct _BATT_WMI_REQUEST {
    LIST_ENTRY              ListEntry;

    PDEVICE_OBJECT          DeviceObject;
    PIRP                    Irp;
    BATT_WMI_GUID_INDEX     GuidIndex;
    IN OUT PULONG           InstanceLengthArray;
    IN ULONG                OutBufferSize;
    OUT PUCHAR              Buffer;

} BATT_WMI_REQUEST, *PBATT_WMI_REQUEST;


//
// Prototypes
//


VOID
BattCWorkerDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BattCWorkerThread (
    IN PVOID Context
    );

VOID
BattCQueueWorker (
    IN PBATT_NP_INFO BattNPInfo,
    IN BOOLEAN       CheckStatus
    );

NTSTATUS
BatteryIoctl(
    IN ULONG            Ioctl,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength,
    IN BOOLEAN          PrivateIoctl
    );

VOID
BattCTagDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BattCCancelTag (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\battc\bsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bsrv.c

Abstract:

    Service battery class device

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "battcp.h"

VOID
BattCIoctl (
    IN PBATT_INFO           BattInfo,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
BattCCheckTagQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    );

VOID
BattCCheckStatusQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    );

VOID
BattCWmi (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo,
    IN PBATT_WMI_REQUEST WmiRequest
    );

VOID
BattCMiniportStatus (
    IN PBATT_INFO   BattInfo,
    IN NTSTATUS     Status
    );

VOID
BattCCompleteIrpQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    );

VOID
BattCCompleteWmiQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BattCCheckStatusQueue)
#pragma alloc_text(PAGE,BattCCheckTagQueue)
#pragma alloc_text(PAGE,BattCWorkerThread)
#pragma alloc_text(PAGE,BattCIoctl)
#endif

VOID
BattCWorkerDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC used to get worker thread when status needs to be checked.

Arguments:

    Dpc     - the worker dpc

Return Value:

    None.

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) DeferredContext;
    BattCQueueWorker (BattNPInfo, TRUE);
    // Release Removal Lock
    if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
        KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }
    BattPrint ((BATT_LOCK), ("BattCWorkerDpc: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

}



VOID
BattCTagDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC used to get worker thread when status needs to be checked.

Arguments:

    Dpc     - the worker dpc

Return Value:

    None.

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) DeferredContext;
    InterlockedExchange(&BattNPInfo->CheckTag, 1);
    BattCQueueWorker (BattNPInfo, FALSE);
    // Release Removal Lock
    if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
        KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }
    BattPrint ((BATT_LOCK), ("BattCTagDpc: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
}



VOID
BattCCancelStatus (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Queued status IRP is being canceled

Arguments:

    DeviceObject    - Device object of the miniport.  Not useful to the
                      class driver - ignored.

    Irp             - Irp being cancelled

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpNextSp;
    PBATT_NP_INFO           BattNPInfo;

    //
    // IRP is flagged as needing cancled, cause a check status which will
    // complete any pending cancled irps
    //

    IrpNextSp = IoGetNextIrpStackLocation(Irp);
    BattNPInfo = (PBATT_NP_INFO) IrpNextSp->Parameters.Others.Argument4;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCCancelStatus. Irp - %08x\n", BattNPInfo->DeviceNum, Irp));

    BattCQueueWorker (BattNPInfo, TRUE);

    //
    // The cancel Spinlock must be released after attempting to queue the
    // worker thread so that there is no timeing problems on remove.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);
}



VOID
BattCCancelTag (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Queued tag IRP is being canceled

Arguments:

    DeviceObject    - Device object of the miniport.  Not useful to the
                      class driver - ignored.

    Irp             - Irp being cancelled

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpNextSp;
    PBATT_NP_INFO           BattNPInfo;

    //
    // IRP is flagged as needing canceled.  Cause a check tag which will
    // complete any pending cancled irps
    //

    IrpNextSp = IoGetNextIrpStackLocation(Irp);
    BattNPInfo = (PBATT_NP_INFO) IrpNextSp->Parameters.Others.Argument4;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCCancelTag. Irp - %08x\n", BattNPInfo->DeviceNum, Irp));

    InterlockedExchange(&BattNPInfo->CheckTag, 1);
    BattCQueueWorker (BattNPInfo, FALSE);

    //
    // The cancel Spinlock must be released after attempting to queue the
    // worker thread so that there is no timeing problems on remove.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);
}



VOID
BattCQueueWorker (
    IN PBATT_NP_INFO BattNPInfo,
    IN BOOLEAN       CheckStatus
    )
/*++

Routine Description:

    Get worker thread to check the battery state (IoQueue).   The
    battery IOs are serialized here as only one worker thread is
    used to process the battery IOs.  If the worker thread is already
    running, it is flagged to loop are re-check the state.  If the
    worker thread is not running, one is queued.

    If CheckStatus is set, the worker thread is informed that the
    batteries current status is read and the pending status queue
    is checked.

Arguments:

    BattNPInfo      - Battery to check

    CheckStatus     - Whether or not the status also needs checked

Return Value:

    None.

--*/
{
    PBATT_INFO      BattInfo = BattNPInfo->BattInfo;

    //
    // Add 1 to the WorkerActive value, if this is the first count
    // queue a worker thread
    //

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCQueueWorker.\n", BattNPInfo->DeviceNum));

    if (CheckStatus) {
        InterlockedExchange(&BattNPInfo->CheckStatus, 1);
        InterlockedExchange (&BattNPInfo->CheckTag, 1);
    }

    //
    // Increment WorkerActive count.  If the worker thread is already running,
    // there is no need to requeue it.
    //
    if (InterlockedIncrement(&BattNPInfo->WorkerActive) == 1) {
        // Removal lock.
        if ((BattNPInfo->WantToRemove == TRUE) && (KeGetCurrentIrql() == PASSIVE_LEVEL)) {
            // Check Irql to make sure this wasn't called by an ISR.  If so,
            // queue the worker rather than complete the requests in this thread.

            //
            // Empty IRP queues.
            //
            BattCCompleteIrpQueue(&(BattInfo->IoQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->TagQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->StatusQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->WmiQueue), STATUS_DEVICE_REMOVED);

            //
            // Remove lock and trigger Remove function if necessary.
            //
            if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
            }
            BattPrint ((BATT_LOCK), ("BattCQueueWorker: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        } else {
            ExQueueWorkItem (&BattNPInfo->WorkerThread, DelayedWorkQueue);
        }
    }
}

VOID
BattCWorkerThread (
    IN PVOID Context
    )
/*++

Routine Description:

    Battery IO worker thread entry point.

    N.B. There is only one worker thread handling the battery at any one time

Arguments:

    Context         - BattInfo.  Battery to check

Return Value:

    None.

--*/
{
    PBATT_INFO              BattInfo;
    PBATT_NP_INFO           BattNPInfo;
    PLIST_ENTRY             Entry;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   i;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) Context;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCWorkerThread entered.\n", BattNPInfo->DeviceNum));


    //
    // Loop while there is work to check
    //

    for (; ;) {
        // Removal code.  This makes sure that the structures aren't freed in the middle of
        // processing.  All Irp Queues will be emptied by BatteryClassUnload.
        if (BattNPInfo->WantToRemove == TRUE) {
            //
            // Empty IRP queues.
            //
            BattCCompleteIrpQueue(&(BattInfo->IoQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->TagQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->StatusQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->WmiQueue), STATUS_DEVICE_REMOVED);
            //
            // Signal BatteryClassUnload that it is safe to return.
            //
            if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
            }
            BattPrint ((BATT_LOCK), ("BattCWorkerThread: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            return;
        }

        //
        // Acquire queue locks
        //

        ExAcquireFastMutex (&BattNPInfo->Mutex);

        //
        // While there are IRPs in the IoQueue handle them
        //

        while (!IsListEmpty(&BattInfo->IoQueue)) {

            //
            // Remove entry from IoQueue and drop device lock
            //

            Entry = RemoveHeadList(&BattInfo->IoQueue);
            ExReleaseFastMutex (&BattNPInfo->Mutex);


            //
            // Handle this entry
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            BattPrint (BATT_IOCTL, ("BattC (%d): WorkerThread, Got Irp - %x\n", BattNPInfo->DeviceNum, Irp));

            IrpSp = IoGetCurrentIrpStackLocation(Irp);


            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_BATTERY_QUERY_STATUS  &&
                IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (BATTERY_WAIT_STATUS) &&
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (BATTERY_STATUS)) {

                BattPrint (BATT_IOCTL,
                          ("BattC (%d): Received QueryStatus Irp - %x, timeout - %x\n",
                          BattNPInfo->DeviceNum,
                          Irp,
                          ((PBATTERY_WAIT_STATUS)Irp->AssociatedIrp.SystemBuffer)->Timeout));

                //
                // Valid query status irp, put it on the StatusQueue and handle later
                //

                InterlockedExchange (&BattNPInfo->CheckStatus, 1);
                IrpSp = IoGetNextIrpStackLocation(Irp);
                IrpSp->Parameters.Others.Argument1 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument2 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument3 = NULL;
                IrpSp->Parameters.Others.Argument4 = BattNPInfo;

                //
                // Set IRPs cancel routine
                //

                IoSetCancelRoutine (Irp, BattCCancelStatus);

                //
                // Queue it
                //

                InsertTailList (
                    &BattInfo->StatusQueue,
                    &Irp->Tail.Overlay.ListEntry
                    );

            } else if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_BATTERY_QUERY_TAG &&
                       (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (ULONG) ||
                       IrpSp->Parameters.DeviceIoControl.InputBufferLength == 0) &&
                       IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {

                BattPrint (BATT_IOCTL,
                          ("BattC (%d): Received QueryTag with timeout %x\n",
                          BattNPInfo->DeviceNum,
                          *((PULONG) Irp->AssociatedIrp.SystemBuffer))
                          );

                //
                // Valid query tag irp, put it on the TagQueue and handle later
                //

                InterlockedExchange (&BattNPInfo->CheckTag, 1);
                IrpSp = IoGetNextIrpStackLocation(Irp);
                IrpSp->Parameters.Others.Argument1 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument2 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument3 = NULL;
                IrpSp->Parameters.Others.Argument4 = BattNPInfo;


                //
                // Set IRPs cancel routine
                //

                IoSetCancelRoutine (Irp, BattCCancelTag);

                InsertTailList (
                    &BattInfo->TagQueue,
                    &Irp->Tail.Overlay.ListEntry
                    );

            } else {
                //
                // Handle IRP now
                //

                BattPrint (BATT_IOCTL, ("BattC (%d): Calling BattCIoctl with irp %x\n", BattNPInfo->DeviceNum, Irp));
                BattCIoctl (BattInfo, Irp, IrpSp);
            }

            //
            // Acquire IoQueue lock and check for anything else in the IoQueueu
            //

            ExAcquireFastMutex (&BattNPInfo->Mutex);
        }

        //
        // Done with the IoQueue
        //

        ExReleaseFastMutex (&BattNPInfo->Mutex);

        //
        // Check pending status queue
        //

        if (BattNPInfo->CheckStatus) {
            BattCCheckStatusQueue (BattNPInfo, BattInfo);
        }


        //
        // Check pending tag queue
        //

        if (BattNPInfo->CheckTag) {
            BattCCheckTagQueue (BattNPInfo, BattInfo);
        }


        //
        // Acquire queue locks
        //

        ExAcquireFastMutex (&BattNPInfo->Mutex);

        //
        // While there are outstanding WMI requests handle them
        //

        while (!IsListEmpty(&BattInfo->WmiQueue)) {
            PBATT_WMI_REQUEST WmiRequest;

            //
            // Remove entry from WmiQueue and drop device lock
            //

            Entry = RemoveHeadList(&BattInfo->WmiQueue);
            ExReleaseFastMutex (&BattNPInfo->Mutex);


            //
            // Handle this entry
            //

            WmiRequest = CONTAINING_RECORD (
                        Entry,
                        BATT_WMI_REQUEST,
                        ListEntry
                        );

            BattPrint (BATT_WMI, ("BattC (%d): WorkerThread, Got WMI Rewest - %x\n", BattNPInfo->DeviceNum, WmiRequest));

            //
            // Process the request here.
            //

            BattCWmi (BattNPInfo, BattInfo, WmiRequest);

            //
            // Acquire IoQueue lock and check for anything else in the IoQueueu
            //

            ExAcquireFastMutex (&BattNPInfo->Mutex);
        }

        //
        // Done with the IoQueue
        //

        ExReleaseFastMutex (&BattNPInfo->Mutex);

        //
        // See if we need to recheck
        //

        i = InterlockedDecrement(&BattNPInfo->WorkerActive);
        BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive count=%x\n", BattNPInfo->DeviceNum, i));


        if (i == 0) {
            // done
            BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive count is zero!\n", BattNPInfo->DeviceNum));
            break;
        }

        //
        // No need to loop multiple times, if count is not one lower it
        //

        if (i != 1) {
            BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive set to 1\n", BattNPInfo->DeviceNum));
            InterlockedExchange(&BattNPInfo->WorkerActive, 1);
        }
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCWorkerThread exiting.\n", BattNPInfo->DeviceNum));

}

VOID
BattCIoctl (
    IN PBATT_INFO           BattInfo,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    )
/*++

Routine Description:

    Completes the battery IOCTL request.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo        - Battery

    Irp             - IOCTL request

    IrpSp           - Current stack location


Return Value:

    IRP has been completed

--*/
{
    ULONG                       InputLen, OutputLen;
    PVOID                       IOBuffer;
    NTSTATUS                    Status;
    PBATTERY_QUERY_INFORMATION  QueryInfo;
    PBATTERY_SET_INFORMATION    SetInformation;
#if DEBUG
    BATTERY_QUERY_INFORMATION_LEVEL inflevel;
#endif

    PAGED_CODE();

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCIoctl called\n", BattInfo->BattNPInfo->DeviceNum));

    IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
    InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Dispatch IOCtl request to proper miniport function
    //

    Status = STATUS_INVALID_BUFFER_SIZE;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_BATTERY_QUERY_TAG:
        //
        // Query tag only gets here if the input or output buffer lengths are
        // wrong.  Return STATUS_INVALID_BUFFER_SIZE
        //
        break;

    case IOCTL_BATTERY_QUERY_INFORMATION:
        if (InputLen != sizeof (BATTERY_QUERY_INFORMATION)) {
            //
            // Don't check size of the output buffer since it is variable size.
            // This is checked in Mp.QueryInformation
            //
            // Return STATUS_INVALID_BUFFER_SIZE
            //
            break;
        }
        QueryInfo = (PBATTERY_QUERY_INFORMATION) IOBuffer;

#if DEBUG
        inflevel = QueryInfo->InformationLevel;
#endif

        Status = BattInfo->Mp.QueryInformation (
                    BattInfo->Mp.Context,
                    QueryInfo->BatteryTag,
                    QueryInfo->InformationLevel,
                    QueryInfo->AtRate,
                    IOBuffer,
                    OutputLen,
                    &OutputLen
                    );
#if DEBUG
        if (inflevel == BatteryInformation) {
            BattInfo->FullChargedCap = ((PBATTERY_INFORMATION)IOBuffer)->FullChargedCapacity;
        }
#endif
        BattPrint ((BATT_MP_DATA), ("BattC (%d): Mp.QueryInformation status = %08x, Level = %d\n",
                   BattInfo->BattNPInfo->DeviceNum, Status, QueryInfo->InformationLevel));
        break;

    case IOCTL_BATTERY_QUERY_STATUS:

        //
        // Query status only gets here if the input or output buffer lengths are
        // wrong.  Return STATUS_INVALID_BUFFER_SIZE
        //
        break;

    case IOCTL_BATTERY_SET_INFORMATION:
        if ((InputLen != sizeof(BATTERY_SET_INFORMATION)) || (OutputLen != 0)) {
            break;
        }

        SetInformation = (PBATTERY_SET_INFORMATION) IOBuffer;
        if (BattInfo->Mp.SetInformation != NULL) {
            Status = BattInfo->Mp.SetInformation (
                        BattInfo->Mp.Context,
                        SetInformation->BatteryTag,
                        SetInformation->InformationLevel,
                        SetInformation->Buffer
                        );
            BattPrint ((BATT_MP_DATA), ("BattC (%d): Mp.SetInformation status = %08x, Level = %d\n",
                       BattInfo->BattNPInfo->DeviceNum, Status, SetInformation->InformationLevel));
        } else {
            Status = STATUS_NOT_SUPPORTED;
        }

        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    BattCMiniportStatus (BattInfo, Status);
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = OutputLen;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

VOID
BattCCheckStatusQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    )
/*++

Routine Description:

    Gets the batteries current status, and checks the pending
    status queue for possible IRP completion.  Resets the miniport
    notification settings if needed.

    N.B. Must be invoked from the non-rentrant worker thread.
         BattNPInfo->CheckStatus must be non-zero.

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

Return Value:

    None

--*/
{
    PLIST_ENTRY             Entry;
    PBATTERY_WAIT_STATUS    BatteryWaitStatus;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp, IrpNextSp;
    BATTERY_NOTIFY          Notify;
    LARGE_INTEGER           NextTime;
    LARGE_INTEGER           CurrentTime;
    LARGE_INTEGER           li;
    ULONG                   TimeIncrement;
    BOOLEAN                 ReturnCurrentStatus;
    NTSTATUS                Status;
    BOOLEAN                 StatusNotified;

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCCheckStatusQueue called\n", BattInfo->BattNPInfo->DeviceNum));

    PAGED_CODE();
    TimeIncrement = KeQueryTimeIncrement();

    //
    // Loop while status needs checked, check pending status IRPs
    //

    while (InterlockedExchange(&BattNPInfo->CheckStatus, 0)) {

        Notify.PowerState   = BattInfo->Status.PowerState;
        Notify.LowCapacity  = 0;
        Notify.HighCapacity = (ULONG) -1;

        //
        // Set to recheck no later than MIN_STATUS_POLL_RATE (3 min) from now.
        //

        NextTime.QuadPart = MIN_STATUS_POLL_RATE;


        //
        // If the StatusQueue is empty, the status doesn't need to be read
        // at this time.  BattNPInfo->StatusNotified is not modified
        // so the next time an IRP comes through, we'll re-read the status.
        // The local value of StatusNotified needs to be set correctly to
        // disable notifications if necessary.
        //

        if (IsListEmpty (&BattInfo->StatusQueue)) {
            StatusNotified = (BOOLEAN)BattNPInfo->StatusNotified;
            break;
        }

        StatusNotified = FALSE;

        //
        // Pickup status notified flag
        //

        if (BattNPInfo->StatusNotified) {

            InterlockedExchange (&BattNPInfo->StatusNotified, 0);
            StatusNotified = TRUE;

            // Reset the invalid data retry count when we get a notification.
#if DEBUG
            if (BattInfo->InvalidRetryCount != 0) {
                BattPrint (BATT_DEBUG, ("BattC (%d) Reset InvalidRetryCount\n", BattNPInfo->DeviceNum));
            }
#endif
            BattInfo->InvalidRetryCount = 0;
        }

        KeQueryTickCount (&CurrentTime);
        CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;

        if (StatusNotified ||
            CurrentTime.QuadPart - BattInfo->StatusTime > STATUS_VALID_TIME) {

            //
            // Get the batteries current status
            //

            Status = BattInfo->Mp.QueryStatus (
                            BattInfo->Mp.Context,
                            BattInfo->Tag,
                            &BattInfo->Status
                            );

            if (!NT_SUCCESS(Status)) {
                //
                // Battery status is not valid, complete all pending status irps
                //

                BattPrint ((BATT_MP_ERROR), ("BattC (%d) CheckStatus: Status read err = %x\n", BattNPInfo->DeviceNum, Status));

                BattCCompleteIrpQueue (&(BattInfo->StatusQueue), Status);
                break;
            }

            BattPrint ((BATT_MP_DATA), ("BattC (%d) MP.QueryStatus: st[%08X] Cap[%08X] V[%08x] R[%08x]\n",
                BattNPInfo->DeviceNum,
                BattInfo->Status.PowerState,
                BattInfo->Status.Capacity,
                BattInfo->Status.Voltage,
                BattInfo->Status.Rate
                ));

            Notify.PowerState = BattInfo->Status.PowerState;

            //
            // Get the current time to compute timeouts on status query requests
            //

            KeQueryTickCount (&CurrentTime);
            CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;
            BattInfo->StatusTime = CurrentTime.QuadPart;
        }

        //
        // Check each pending Status IRP
        //

        BattPrint ((BATT_IOCTL_QUEUE), ("BattC (%d) Processing StatusQueue\n", BattNPInfo->DeviceNum));

        Entry = BattInfo->StatusQueue.Flink;
        while  (Entry != &BattInfo->StatusQueue) {

            //
            // Get IRP to check
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            IrpNextSp = IoGetNextIrpStackLocation(Irp);
            BatteryWaitStatus = (PBATTERY_WAIT_STATUS) Irp->AssociatedIrp.SystemBuffer;

#if DEBUG
    if (BattInfo->FullChargedCap == 0) {
        BattInfo->FullChargedCap = 1000;
    }
#endif
            BattPrint ((BATT_IOCTL_QUEUE), ("BattC (%d) StatusQueue: 0x%08x=%d -- 0x%08x=%d  time=%08x, st=%08x\n",
                       BattNPInfo->DeviceNum,
                       BatteryWaitStatus->HighCapacity, (ULONG) (((LONGLONG) BatteryWaitStatus->HighCapacity * 1000) / BattInfo->FullChargedCap),
                       BatteryWaitStatus->LowCapacity, (ULONG) (((LONGLONG) BatteryWaitStatus->LowCapacity * 1000) / BattInfo->FullChargedCap),
                       BatteryWaitStatus->Timeout,
                       BatteryWaitStatus->PowerState));

            //
            // Get next request
            //

            Entry = Entry->Flink;

            //
            // If status is in error, or tag no longer matches abort the
            // request accordingly
            //

            if (BattInfo->Tag != BatteryWaitStatus->BatteryTag) {
                Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            }

            //
            // If IRP is flagged as cancelled, complete it
            //

            if (Irp->Cancel) {
                Irp->IoStatus.Status = STATUS_CANCELLED;
            }

            //
            // If request is still pending, check it
            //

            if (Irp->IoStatus.Status == STATUS_PENDING) {

                ReturnCurrentStatus = FALSE;

                if (BattInfo->Status.PowerState != BatteryWaitStatus->PowerState ||
                    BattInfo->Status.Capacity   <  BatteryWaitStatus->LowCapacity  ||
                    BattInfo->Status.Capacity   >  BatteryWaitStatus->HighCapacity) {

                    BattPrint((BATT_IOCTL_DATA), ("BattC (%d) CheckStatusQueue, Returning Current Status, Asked For:\n"
                                          "----------- Irp.PowerState      = %x\n"
                                          "----------- Irp.LowCapacity     = %x\n"
                                          "----------- Irp.HighCapacity    = %x\n"
                                          "----------- BattInfo.PowerState = %x\n"
                                          "----------- BattInfo.Capacity   = %x\n",
                                          BattNPInfo->DeviceNum,
                                          BatteryWaitStatus->PowerState,
                                          BatteryWaitStatus->LowCapacity,
                                          BatteryWaitStatus->HighCapacity,
                                          BattInfo->Status.PowerState,
                                          BattInfo->Status.Capacity)
                                          );

                    //
                    // Complete this IRP with the current status
                    //

                    ReturnCurrentStatus = TRUE;

                } else {

                    //
                    // Compute time when the request expires
                    //

                    BattPrint ((BATT_IOCTL_DATA), ("BattC (%d) CheckStatusQueue: Status Request %x Waiting For:\n"
                                            "----------- Timeout          = %x\n"
                                            "----------- Irp.PowerState   = %x\n"
                                            "----------- Irp.LowCapacity  = %x\n"
                                            "----------- Irp.HighCapacity = %x\n",
                                            BattNPInfo->DeviceNum,
                                            Irp,
                                            BatteryWaitStatus->Timeout,
                                            BatteryWaitStatus->PowerState,
                                            BatteryWaitStatus->LowCapacity,
                                            BatteryWaitStatus->HighCapacity)
                                            );

                    if (BatteryWaitStatus->Timeout &&
                        IrpNextSp->Parameters.Others.Argument1 == NULL &&
                        IrpNextSp->Parameters.Others.Argument2 == NULL) {

                        // initialize it
                        li.QuadPart = CurrentTime.QuadPart +
                            ((ULONGLONG) BatteryWaitStatus->Timeout * NTMS);

                        IrpNextSp->Parameters.Others.Argument1 = (PVOID)((ULONG_PTR)li.LowPart);
                        IrpNextSp->Parameters.Others.Argument2 = (PVOID)((ULONG_PTR)li.HighPart);
                    }

                    li.LowPart   = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument1);
                    li.HighPart  = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument2);
                    li.QuadPart -= CurrentTime.QuadPart;

                    if (li.QuadPart <= 0) {

                        //
                        // Time's up, complete it
                        //

                        ReturnCurrentStatus = TRUE;

                    } else {

                        //
                        // If waiting forever, no need to set a timer
                        //
                        if (BatteryWaitStatus->Timeout != 0xFFFFFFFF) {

                            //
                            // Check if this will be the next timeout time -- we will use
                            // the minimum timeout of the pending requests.
                            //

                            if (li.QuadPart < NextTime.QuadPart) {
                                NextTime.QuadPart = li.QuadPart;
                            }
                        }
                    }
                }

                if (!ReturnCurrentStatus) {

                    //
                    // IRP is still pending, calculate LCD of all waiting IRPs
                    //

                    if (BatteryWaitStatus->LowCapacity > Notify.LowCapacity) {
                        Notify.LowCapacity = BatteryWaitStatus->LowCapacity;
                    }

                    if (BatteryWaitStatus->HighCapacity < Notify.HighCapacity) {
                        Notify.HighCapacity = BatteryWaitStatus->HighCapacity;
                    }

                } else {

                    //
                    // Return current battery status
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = sizeof(BattInfo->Status);
                    RtlCopyMemory (
                        Irp->AssociatedIrp.SystemBuffer,
                        &BattInfo->Status,
                        sizeof(BattInfo->Status)
                        );
                }
            }

            //
            // If this request is no longer pending, complete it
            //

            if (Irp->IoStatus.Status != STATUS_PENDING) {
                BattPrint (BATT_IOCTL,
                          ("BattC (%d): completing QueryStatus irp - %x, status - %x\n",
                          BattNPInfo->DeviceNum,
                          Irp,
                          Irp->IoStatus.Status));

                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                IoSetCancelRoutine (Irp, NULL);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
    }

    //
    // Status check complete
    //

    if (IsListEmpty (&BattInfo->StatusQueue)) {

        //
        // Nothing pending, if being notified disable the notifications
        //

        if (StatusNotified) {
            BattInfo->Mp.DisableStatusNotify (BattInfo->Mp.Context);
            BattInfo->StatusTime = 0;
            BattPrint ((BATT_MP_DATA), ("BattC (%d) CheckStatus: called Mp.DisableStatusNotify\n", BattNPInfo->DeviceNum));
        }

    } else {

        //
        // Set notification setting
        //

        Status = BattInfo->Mp.SetStatusNotify (
                        BattInfo->Mp.Context,
                        BattInfo->Tag,
                        &Notify
                        );

        if (NT_SUCCESS(Status)) {

            //
            // New notification set, remember it
            //

            BattPrint (BATT_MP_DATA, ("BattC (%d) Mp.SetStatusNotify: Notify set for: State=%x, Low=%x, High=%x\n",
                BattNPInfo->DeviceNum,
                Notify.PowerState,
                Notify.LowCapacity,
                Notify.HighCapacity
                ));

        } else {

            //
            // Could not set notification, handle error
            //

            BattPrint (BATT_MP_ERROR, ("BattC (%d) Mp.SetStatusNotify: failed (%x), will poll\n", BattNPInfo->DeviceNum, Status));
            BattCMiniportStatus (BattInfo, Status);

            //
            // Compute poll time
            //

            li.QuadPart = MIN_STATUS_POLL_RATE;
            if (BattInfo->Status.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                // Retry 10 times at a polling rate of 1 second.
                // Then revert to the slow polling rate.
                if (BattInfo->InvalidRetryCount < INVALID_DATA_MAX_RETRY) {
                    BattInfo->InvalidRetryCount++;
                    li.QuadPart = INVALID_DATA_POLL_RATE;
                    BattPrint (BATT_DEBUG, ("BattC (%d) InvalidRetryCount = %d\n",
                            BattNPInfo->DeviceNum, BattInfo->InvalidRetryCount));
                } else {
                    BattPrint (BATT_DEBUG, ("BattC (%d) InvalidRetryCount = %d.  Using slow polling rate.\n",
                            BattNPInfo->DeviceNum, BattInfo->InvalidRetryCount));
                    li.QuadPart = MIN_STATUS_POLL_RATE;
                }
            } else if ((BattInfo->Status.Rate != 0) && (BattInfo->Status.Rate != BATTERY_UNKNOWN_RATE)) {

                if (BattInfo->Status.Rate > 0) {

                    li.QuadPart = Notify.HighCapacity - BattInfo->Status.Capacity;

                } else if (BattInfo->Status.Rate < 0) {

                    li.QuadPart = Notify.LowCapacity - BattInfo->Status.Capacity;
                }

                // convert to 3/4 its target time

                li.QuadPart = li.QuadPart * ((ULONGLONG) NTMIN * 45);
                li.QuadPart = li.QuadPart / (LONGLONG)(BattInfo->Status.Rate);

                //
                // Bound it
                //

                if (li.QuadPart > MIN_STATUS_POLL_RATE) {
                    // poll at least this fast
                    li.QuadPart = MIN_STATUS_POLL_RATE;
                } else if (li.QuadPart < MAX_STATUS_POLL_RATE) {
                    // but not faster then this
                    li.QuadPart = MAX_STATUS_POLL_RATE;
                }
            }

            //
            // If sooner then NextTime, adjust NextTime
            //

            if (li.QuadPart < NextTime.QuadPart) {
                NextTime.QuadPart = li.QuadPart;
            }
        }

        //
        // If there's a NextTime, queue the timer to recheck
        //

        if (NextTime.QuadPart) {
            NextTime.QuadPart = -NextTime.QuadPart;

            //
            // Acquire a remove lock.
            //

            InterlockedIncrement (&BattNPInfo->InUseCount);
            BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            if (BattNPInfo->WantToRemove == TRUE) {
                //
                // If BatteryClassUnload is waiting to remove the device:
                //   Don't set the timer.
                //   Release the remove lock just acquired.
                //   No need to notify BatteryclassUnload because
                //    at this point there is at least one other lock held.
                //

                InterlockedDecrement(&BattNPInfo->InUseCount);
                BattPrint (BATT_NOTE,
                        ("BattC (%d) CheckStatus: Poll cancel because of device removal.\n",
                        BattNPInfo->DeviceNum));
                BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            } else {
                if (KeSetTimer (&BattNPInfo->WorkerTimer, NextTime, &BattNPInfo->WorkerDpc)) {
                    //
                    // If the timer was already set, we need to release a remove lock since
                    // there was already one aquired the last time this timer was set.
                    //

                    InterlockedDecrement(&BattNPInfo->InUseCount);
                    BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Released extra remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
                }
#if DEBUG
                NextTime.QuadPart = (-NextTime.QuadPart) / (ULONGLONG) NTSEC;
                BattPrint (BATT_NOTE, ("BattC (%d) CheckStatus: Poll in %d seconds (%d minutes)\n",
                                        BattNPInfo->DeviceNum, NextTime.LowPart, NextTime.LowPart/60));
#endif
            }

        } else {
            //
            // There should always be a NextTime.
            //
            ASSERT(FALSE);
        }
    } // if (IsListEmpty (&BattInfo->StatusQueue)) {...} else
}





VOID
BattCCheckTagQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    )
/*++

Routine Description:

    Gets the batteries current tag, and checks the pending
    tag queue for possible IRP completion.  Resets the miniport
    notification settings if needed.

    N.B. must be invoked from the non-reentrant worker thread

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

Return Value:

    None

--*/
{
    PLIST_ENTRY             Entry;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp, IrpNextSp;
    LARGE_INTEGER           NextTime;
    LARGE_INTEGER           CurrentTime;
    LARGE_INTEGER           li;
    ULONG                   TimeIncrement;
    BOOLEAN                 ReturnCurrentStatus;
    NTSTATUS                Status;
    ULONG                   batteryTimeout;
    BOOLEAN                 TagNotified;

    ULONG                   tmpTag      = BATTERY_TAG_INVALID;

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCCheckTagQueue called\n", BattInfo->BattNPInfo->DeviceNum));

    PAGED_CODE();
    TimeIncrement = KeQueryTimeIncrement();

    //
    // Loop while tag needs checked, check pending tag IRPs
    //

    while (InterlockedExchange(&BattNPInfo->CheckTag, 0)) {
        NextTime.QuadPart = 0;

        //
        // If the Tag Queue is empty, done
        // but we need to make sure that we leave TagNotified set to TRUE
        // so the next time an IRP comes through,we'll re-read the tag.
        //

        if (IsListEmpty (&BattInfo->TagQueue)) {
            break;
        }

        TagNotified = FALSE;

        //
        // Pickup tag notified flag
        //

        if (BattNPInfo->TagNotified) {
            InterlockedExchange (&BattNPInfo->TagNotified, 0);
            TagNotified = TRUE;
        }

        KeQueryTickCount (&CurrentTime);
        CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;

        if (TagNotified ||
            CurrentTime.QuadPart - BattInfo->TagTime > STATUS_VALID_TIME) {

            //
            // Get the battery's current tag
            //

            tmpTag = 0;
            Status = BattInfo->Mp.QueryTag (
                        BattInfo->Mp.Context,
                        &tmpTag
                        );


            if (!NT_SUCCESS(Status) && (Status != STATUS_NO_SUCH_DEVICE)) {
                //
                // Something went wrong, complete all pending tag irps
                //

                BattPrint (BATT_MP_ERROR, ("BattC (%d) CheckTag: Tag read err = %x\n", BattNPInfo->DeviceNum, Status));
                BattCMiniportStatus (BattInfo, Status);
                break;
            }
            BattPrint (BATT_MP_DATA, ("BattC (%d) MP.QueryTag: Status = %08x, Tag = %08x\n",
                    BattNPInfo->DeviceNum, Status, tmpTag));


            if (Status == STATUS_NO_SUCH_DEVICE) {
                //
                // Get the current time to compute timeouts on tag query requests
                //

                KeQueryTickCount (&CurrentTime);
                CurrentTime.QuadPart    = CurrentTime.QuadPart * TimeIncrement;
                BattInfo->TagTime       = CurrentTime.QuadPart;

            }
        }

        //
        // Check each pending Tag IRP
        //

        Entry = BattInfo->TagQueue.Flink;
        while  (Entry != &BattInfo->TagQueue) {

            //
            // Get IRP to check
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            IrpSp           = IoGetCurrentIrpStackLocation(Irp);
            IrpNextSp       = IoGetNextIrpStackLocation(Irp);
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == 0) {
                //
                // If no input was given, then use timeout of 0.
                //
                batteryTimeout  = 0;
            } else {
                batteryTimeout  = *((PULONG) Irp->AssociatedIrp.SystemBuffer);
            }

            //
            // Get next request
            //

            Entry = Entry->Flink;


            //
            // If IRP is flagged as cancelled, complete it
            //

            if (Irp->Cancel) {
                BattPrint (BATT_IOCTL, ("BattC (%d): QueryTag irp cancelled - %x\n", BattNPInfo->DeviceNum, Irp));
                Irp->IoStatus.Status = STATUS_CANCELLED;
            }


            //
            // If request is still pending, check it
            //

            if (Irp->IoStatus.Status == STATUS_PENDING) {

                ReturnCurrentStatus = FALSE;
                if (tmpTag != BATTERY_TAG_INVALID) {

                    //
                    // Complete this IRP with the current tag
                    //

                    ReturnCurrentStatus = TRUE;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {

                    //
                    // Compute time when the request expires, the battery tag
                    // is an input parameter that holds the timeout.
                    //

                    if (batteryTimeout &&
                        IrpNextSp->Parameters.Others.Argument1 == NULL &&
                        IrpNextSp->Parameters.Others.Argument2 == NULL) {

                        // initialize it
                        li.QuadPart = CurrentTime.QuadPart + ((ULONGLONG) batteryTimeout * NTMS);

                        IrpNextSp->Parameters.Others.Argument1 = (PVOID)((ULONG_PTR)li.LowPart);
                        IrpNextSp->Parameters.Others.Argument2 = (PVOID)((ULONG_PTR)li.HighPart);

                    }

                    li.LowPart   = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument1);
                    li.HighPart  = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument2);
                    li.QuadPart -= CurrentTime.QuadPart;

                    if (li.QuadPart <= 0) {

                        //
                        // Time's up, complete it
                        //

                        BattPrint ((BATT_NOTE | BATT_IOCTL), ("BattC (%d): QueryTag irp timeout - %x\n", BattNPInfo->DeviceNum, Irp));
                        ReturnCurrentStatus = TRUE;
                        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                    } else {

                        //
                        // If waiting forever, no need to set a timer
                        //
                        if (batteryTimeout != 0xFFFFFFFF) {

                            //
                            // Check if this is the next timeout time
                            //

                            if (NextTime.QuadPart == 0  ||  li.QuadPart < NextTime.QuadPart) {
                                NextTime.QuadPart = li.QuadPart;
                            }
                        }
                    }
                }

                if (ReturnCurrentStatus) {

                    //
                    // Return current battery status
                    //

                    *((PULONG) Irp->AssociatedIrp.SystemBuffer)     = tmpTag;
                    Irp->IoStatus.Information                       = sizeof(ULONG);
                    if (BattInfo->Tag != tmpTag) {

                        //
                        // This is a new battery tag, capture tag
                        //

                        BattInfo->Tag = tmpTag;
                    }
                }
            }

            //
            // If this request is no longer pending, complete it
            //

            if (Irp->IoStatus.Status != STATUS_PENDING) {
                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                IoSetCancelRoutine (Irp, NULL);

                BattPrint (
                    (BATT_IOCTL),
                    ("BattC (%d): CheckTag completing request, IRP = %x, status = %x\n",
                    BattNPInfo->DeviceNum,
                    Irp,
                    Irp->IoStatus.Status)
                    );

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
    }

    //
    // If there's a NextTime, queue the timer to recheck.
    // This means there is a tag request with a timout other than 0 or -1.
    //

    if (NextTime.QuadPart) {
        NextTime.QuadPart = -NextTime.QuadPart;

        //
        // Acquire a remove lock.
        //

        InterlockedIncrement (&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        if (BattNPInfo->WantToRemove == TRUE) {
            //
            // If BatteryClassUnload is waiting to remove the device:
            //   Don't set the timer.
            //   Release the remove lock just acquired.
            //   No need to notify BatteryclassUnload because
            //    at this point there is at least one other lock held.
            //

            InterlockedDecrement(&BattNPInfo->InUseCount);
            BattPrint (BATT_NOTE,
                    ("BattC (%d) CheckTag: Poll cancel because of device removal.\n",
                    BattNPInfo->DeviceNum));
            BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
        } else {
            if (KeSetTimer (&BattNPInfo->TagTimer, NextTime, &BattNPInfo->TagDpc)){
                //
                // If the timer was already set, we need to release a remove lock since
                // there was already one aquired the last time this timer was set.
                //

                InterlockedDecrement(&BattNPInfo->InUseCount);
                BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Released extra remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
            }
#if DEBUG
            NextTime.QuadPart = NextTime.QuadPart / -NTSEC;
            BattPrint (BATT_NOTE, ("BattC (%d) CheckTag: Poll in %x seconds\n", BattNPInfo->DeviceNum, NextTime.LowPart));
#endif
        }
    }

}



VOID
BattCWmi (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo,
    IN PBATT_WMI_REQUEST WmiRequest
    )
/*++

Routine Description:

    Processes a single WMI request.

    N.B. must be invoked from the non-reentrant worker thread

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

    WmiRequest      - Wmi Request to process

Return Value:

    None

--*/
{

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       size = 0;
    ULONG       OutputLen;
    BATTERY_INFORMATION batteryInformation;
    PWCHAR      tempString;

    BattPrint((BATT_WMI), ("BattCWmi (%d): GuidIndex = 0x%x\n",
               BattNPInfo->DeviceNum, WmiRequest->GuidIndex));

    switch (WmiRequest->GuidIndex) {
    case BattWmiStatusId:
        size = sizeof (BATTERY_WMI_STATUS);
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->RemainingCapacity = BattInfo->Status.Capacity;
        if (BattInfo->Status.Rate < 0) {
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->ChargeRate = 0;
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->DischargeRate = -BattInfo->Status.Rate;
        } else {
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->ChargeRate = BattInfo->Status.Rate;
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->DischargeRate = 0;
        }
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Voltage = BattInfo->Status.Voltage;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->PowerOnline =
            (BattInfo->Status.PowerState & BATTERY_POWER_ON_LINE) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Charging =
            (BattInfo->Status.PowerState & BATTERY_CHARGING) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Discharging =
            (BattInfo->Status.PowerState & BATTERY_DISCHARGING) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Critical =
            (BattInfo->Status.PowerState & BATTERY_CRITICAL) ? TRUE : FALSE;
        BattPrint((BATT_WMI), ("BattCWmi (%d): BatteryStatus\n",
                   BattNPInfo->DeviceNum));
        break;
    case BattWmiRuntimeId:
        size = sizeof (BATTERY_WMI_RUNTIME);
        ((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryEstimatedTime,
            0,
            &((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->EstimatedRuntime,
            sizeof(ULONG),
            &OutputLen
            );

        BattPrint((BATT_WMI), ("BattCWmi (%d): EstimateRuntime = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, &((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->EstimatedRuntime, status));
        break;
    case BattWmiTemperatureId:
        size = sizeof (BATTERY_WMI_TEMPERATURE);
        ((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryTemperature,
            0,
            &((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Temperature,
            sizeof(ULONG),
            &OutputLen
            );

        BattPrint((BATT_WMI), ("BattCWmi (%d): Temperature = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, &((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Temperature, status));
        break;
    case BattWmiFullChargedCapacityId:
        size = sizeof (BATTERY_WMI_FULL_CHARGED_CAPACITY);
        ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );
        ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->FullChargedCapacity =
            batteryInformation.FullChargedCapacity;

        BattPrint((BATT_WMI), ("BattCWmi (%d): FullChargedCapacity = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->FullChargedCapacity, status));
        break;
    case BattWmiCycleCountId:
        size = sizeof (BATTERY_WMI_CYCLE_COUNT);
        ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );
        ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->CycleCount =
            batteryInformation.CycleCount;

        BattPrint((BATT_WMI), ("BattCWmi (%d): CycleCount = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->CycleCount, status));
        break;
    case BattWmiStaticDataId:
        size = sizeof(BATTERY_WMI_STATIC_DATA)+4*MAX_BATTERY_STRING_SIZE*sizeof(WCHAR);
        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Tag = BattInfo->Tag;
//        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->ManufacturerDate[0] =
//        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Granularity =

        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );

        if (NT_SUCCESS(status)) {

            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Capabilities =
                batteryInformation.Capabilities;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Technology =
                batteryInformation.Technology;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Chemistry =
                *(PULONG)batteryInformation.Chemistry;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DesignedCapacity =
                batteryInformation.DesignedCapacity;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DefaultAlert1 =
                batteryInformation.DefaultAlert1;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DefaultAlert2 =
                batteryInformation.DefaultAlert2;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->CriticalBias =
                batteryInformation.CriticalBias;

            tempString = ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Strings;
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryDeviceName,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryManufactureName,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatterySerialNumber,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryUniqueID,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
                status = STATUS_SUCCESS;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            size = (ULONG)(sizeof(BATTERY_WMI_STATIC_DATA)+(tempString - ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Strings));
        }

        break;
    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    *WmiRequest->InstanceLengthArray = size;
    status = WmiCompleteRequest(WmiRequest->DeviceObject,
                          WmiRequest->Irp,
                          status,
                          size,
                          IO_NO_INCREMENT);


}




VOID
BattCMiniportStatus (
    IN PBATT_INFO   BattInfo,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Function to return status from miniport.  If the battery tag has gone
    invalid the pending statuses are aborted.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Status from miniport.

Return Value:

    None

--*/
{
    if (NT_SUCCESS(Status)) {
        return ;
    }

    switch (Status) {
#if DEBUG
        case STATUS_SUCCESS:
        case STATUS_NOT_IMPLEMENTED:
        case STATUS_BUFFER_TOO_SMALL:
        case STATUS_INVALID_BUFFER_SIZE:
        case STATUS_NOT_SUPPORTED:
        case STATUS_INVALID_PARAMETER:
        case STATUS_OBJECT_NAME_NOT_FOUND:
        case STATUS_INVALID_DEVICE_REQUEST:
            // no action
            break;

        default:
            BattPrint (BATT_ERROR, ("BattCMiniportStatus: unknown status from miniport: %x BattInfo %x\n",
                        Status, BattInfo));
            break;

#endif
        case STATUS_NO_SUCH_DEVICE:

            //
            // Our battery tag is wrong.  Cancel any queued status irps
            //

            BattCCompleteIrpQueue (&(BattInfo->StatusQueue), Status);
            break;
    }
}


VOID
BattCCompleteIrpQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Complete all pending Irps in the IoQueue, TagQueue, or StatusQueue.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Error status to complete pending status request with

Return Value:

    None

--*/
{
    PLIST_ENTRY     Entry;
    PIRP            Irp;

    ASSERT (!NT_SUCCESS(Status));

    BattPrint (BATT_TRACE, ("BattC: ENTERING BattCCompleteIrpQueue\n"));

    while  (!IsListEmpty(Queue)) {
        Entry = RemoveHeadList (Queue);

        Irp = CONTAINING_RECORD (
                    Entry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // Use Cancel Spinlock to make sure that Completion routine isn't being called
        //

        IoAcquireCancelSpinLock (&Irp->CancelIrql);
        IoSetCancelRoutine (Irp, NULL);
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        BattPrint (BATT_NOTE, ("BattC: Completing IRP 0x%0lx at IRQL %d.\n", Irp, KeGetCurrentIrql()));
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint (BATT_TRACE, ("BattC: EXITING BattCCompleteIrpQueue\n"));
}


VOID
BattCCompleteWmiQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Complete all pending Irps in the IoQueue, TagQueue, or StatusQueue.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Error status to complete pending status request with

Return Value:

    None

--*/
{
    PLIST_ENTRY         Entry;
    PBATT_WMI_REQUEST   WmiRequest;

    ASSERT (!NT_SUCCESS(Status));

    BattPrint (BATT_TRACE, ("BattC: ENTERING BattCCompleteWmiQueue\n"));

    while  (!IsListEmpty(Queue)) {
        Entry = RemoveHeadList (Queue);

        WmiRequest = CONTAINING_RECORD (
                    Entry,
                    BATT_WMI_REQUEST,
                    ListEntry
                    );

        BattPrint (BATT_NOTE, ("BattC: Completing Wmi Request 0x%0lx at IRQL %d.\n", WmiRequest, KeGetCurrentIrql()));

        *WmiRequest->InstanceLengthArray = 0;
        WmiCompleteRequest(WmiRequest->DeviceObject,
                      WmiRequest->Irp,
                      Status,
                      0,
                      IO_NO_INCREMENT);


    }

    BattPrint (BATT_TRACE, ("BattC: EXITING BattCCompleteWmiQueue\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbdrect.h ===
//
// Direct Access IOCTLs
//

#define IOCTL_CMBATT_UID      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x101, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_STA      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x102, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_PSR      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x103, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_BTP      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x104, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CMBATT_BIF      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x105, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_BST      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x106, METHOD_BUFFERED, FILE_READ_ACCESS)
    

#if (CMB_DIRECT_IOCTL_ONLY != 1)

#define CM_MAX_STRING_LENGTH        256

//
//  This is the static data defined by the ACPI spec for the control method battery
//  It is returned by the _BIF control method
//
typedef struct {
    ULONG                   PowerUnit;                  // units used by interface 0:mWh or 1:mAh
    ULONG                   DesignCapacity;             // Nominal capacity of a new battery
    ULONG                   LastFullChargeCapacity;     // Predicted capacity when fully charged
    ULONG                   BatteryTechnology;          // 0:Primary (not rechargable), 1:Secondary (rechargable)
    ULONG                   DesignVoltage;              // Nominal voltage of a new battery
    ULONG                   DesignCapacityOfWarning;    // OEM-designed battery warning capacity
    ULONG                   DesignCapacityOfLow;        // OEM-designed battery low capacity
    ULONG                   BatteryCapacityGran_1;      // capacity granularity between low and warning
    ULONG                   BatteryCapacityGran_2;      // capacity granularity between warning and full
    UCHAR                   ModelNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   SerialNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   BatteryType[CM_MAX_STRING_LENGTH];
    UCHAR                   OEMInformation[CM_MAX_STRING_LENGTH];
} CM_BIF_BAT_INFO, *PCM_BIF_BAT_INFO;

//
//  This is the battery status data defined by the ACPI spec for a control method battery
//  It is returned by the _BST control method
//
typedef struct {
    ULONG                   BatteryState;       // Charging/Discharging/Critical
    ULONG                   PresentRate;        // Present draw rate in units defined by PowerUnit
                                                // Unsigned value, direction is determined by BatteryState
    ULONG                   RemainingCapacity;  // Estimated remaining capacity, units defined by PowerUnit
    ULONG                   PresentVoltage;     // Present voltage across the battery terminals

} CM_BST_BAT_INFO, *PCM_BST_BAT_INFO;

#endif // (CMB_DIRECT_IOCTL_ONLY != 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cmbpnp.c

Abstract:

    Control Method Battery Plug and Play support

Author:

    Ron Mosgrove

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"
#include <wdmguid.h>
#include <string.h>

//
// Device Names
//
PCWSTR                      CmBattDeviceName    = L"\\Device\\ControlMethodBattery";
PCWSTR                      AcAdapterName       = L"\\Device\\AcAdapter";

//
// Power Source Type registry key
//
PCWSTR                      PowerSourceType     = L"PowerSourceType";
#define POWER_SOURCE_TYPE_BATTERY       0
#define POWER_SOURCE_TYPE_AC_ADAPTER    1

//
// WaitWake registry key
//
PCWSTR                      WaitWakeEnableKey     = L"WaitWakeEnabled";

//
// Globals
//
PDEVICE_OBJECT              AcAdapterPdo = NULL;

//
// Prototypes
//
NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
CmBattGetAcpiInterfaces(
    IN PDEVICE_OBJECT               LowerDevice,
    OUT PACPI_INTERFACE_STANDARD    AcpiInterfaces
    );

NTSTATUS
CmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo,
    IN PWSTR                DeviceName,
    IN ULONG                ExtensionSize,
    OUT PDEVICE_OBJECT      *NewFdo
    );

VOID
CmBattDestroyFdo(
    IN PDEVICE_OBJECT   Fdo
    );



NTSTATUS
CmBattIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pdoIoCompletedEvent
    )
/*++

Routine Description:

    This routine catches completion notifications.

Arguments:

    DeviceObject        - Pointer to class device object.
    Irp                 - Pointer to the request packet.
    pdoIoCompletedEvent - the just completed event

Return Value:

    Status is returned.

--*/
{

    CmBattPrint (CMBATT_TRACE, ("CmBattIoCompletion: Event (%x)\n", pdoIoCompletedEvent));

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each CmBatt controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    NTSTATUS                Status;
    HANDLE                  handle;
    UNICODE_STRING          unicodeString;
    CHAR                    buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG                   unused;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        CmBattPrint((CMBATT_WARN | CMBATT_PNP), ("CmBattAddDevice: Asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Get the software branch.
    //
    Status = IoOpenDeviceRegistryKey (Pdo,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      STANDARD_RIGHTS_READ,
                                      &handle);
    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Could not get the software branch: %x\n", Status));
        return Status;
    }

    //
    // Check if this is for an AC adapter or a battery.
    //
    RtlInitUnicodeString (&unicodeString, PowerSourceType);
    Status = ZwQueryValueKey(
        handle,
        &unicodeString,
        KeyValuePartialInformation,
        &buffer,
        sizeof(buffer),
        &unused
        );

    ZwClose( handle );

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Could not read the power type identifier: %x\n", Status));

    } else {

        switch (*(PULONG)&((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) {

            case POWER_SOURCE_TYPE_BATTERY:
                Status = CmBattAddBattery (DriverObject, Pdo);
                break;

            case POWER_SOURCE_TYPE_AC_ADAPTER:
                Status = CmBattAddAcAdapter (DriverObject, Pdo);
                break;

            default:
                CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Invalid POWER_SOURCE_TYPE == %d \n", *(PULONG)&((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data));
                Status = STATUS_UNSUCCESSFUL;
                break;
        }
    }

    //
    // Return the status.
    //
    return Status;
}



NTSTATUS
CmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine creates a functional device object for a CM battery,  and attache it
    to the physical device object for the battery.

Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo = NULL;
    PCM_BATT                CmBatt;
    NTSTATUS                Status;
    BATTERY_MINIPORT_INFO   BattInit;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddBattery: pdo %x\n", Pdo));

    //
    // Create and initialize the new functional device object
    //
    Status = CmBattCreateFdo(DriverObject, Pdo, (PWSTR) CmBattDeviceName, sizeof(CM_BATT), &Fdo);

    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddBattery: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    CmBatt = (PCM_BATT) Fdo->DeviceExtension;
    CmBatt->Type = CM_BATTERY_TYPE;
    CmBatt->IsStarted = FALSE;
    CmBatt->ReCheckSta = TRUE;
    InterlockedExchange (&CmBatt->CacheState, 0);

    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
    CmBatt->Alarm.Setting = CM_ALARM_INVALID;
    CmBatt->DischargeTime = KeQueryInterruptTime();

    if (CmBattSetTripPpoint (CmBatt, 0) == STATUS_OBJECT_NAME_NOT_FOUND) {
        CmBatt->Info.BtpExists = FALSE;
    } else {
        CmBatt->Info.BtpExists = TRUE;
    }

    //
    //  Attach to the Class Driver
    //

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = CmBatt;
    BattInit.QueryTag            = CmBattQueryTag;
    BattInit.QueryInformation    = CmBattQueryInformation;
    BattInit.SetInformation      = NULL;                  // tbd
    BattInit.QueryStatus         = CmBattQueryStatus;
    BattInit.SetStatusNotify     = CmBattSetStatusNotify;
    BattInit.DisableStatusNotify = CmBattDisableStatusNotify;

    BattInit.Pdo                 = Pdo;
    BattInit.DeviceName          = CmBatt->DeviceName;

    Status = BatteryClassInitializeDevice (&BattInit, &CmBatt->Class);
    if (!NT_SUCCESS(Status)) {
        //
        //  if we can't attach to class driver we're toast
        //
        CmBattPrint(CMBATT_ERROR, ("CmBattAddBattery: error (0x%x) registering with class\n", Status));
        IoDetachDevice (CmBatt->LowerDeviceObject);
        CmBattDestroyFdo (CmBatt->Fdo);
        return Status;
    }

    //
    // Register WMI support.
    //
    Status = CmBattWmiRegistration(CmBatt);

    if (!NT_SUCCESS(Status)) {
        //
        // WMI support is not critical to operation.  Just log an error.
        //

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register as a WMI provider, status = %Lx\n", Status));
    }

    //
    // Register the battery notify handler for this battery with ACPI
    // This registration is performed after registering with the battery
    // class because CmBattNotifyHandler must not be run until the battery
    // class is ready.
    //
    Status = CmBatt->AcpiInterfaces.RegisterForDeviceNotifications (
                CmBatt->AcpiInterfaces.Context,
                CmBattNotifyHandler,
                CmBatt);

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register for battery notify, status = %Lx\n", Status));
        CmBattWmiDeRegistration(CmBatt);
        BatteryClassUnload (CmBatt->Class);
        IoDetachDevice (CmBatt->LowerDeviceObject);
        CmBattDestroyFdo (CmBatt->Fdo);
        return Status;
    }


    return STATUS_SUCCESS;
}


NTSTATUS
CmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine registers a notify handler for the AC Adapter.  And saves the PDO so we can run
    the _STA method against it to get the AC status.

Arguments:

    DriverObject            - a pointer to the object for this driver
    Pdo                     - a pointer to the Pdo

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo;
    NTSTATUS                Status;
    PAC_ADAPTER             acExtension;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddAcAdapter: pdo %x\n", Pdo));

    //
    // Save PDO so we can run _STA method on it later
    //

    if (AcAdapterPdo != NULL) {
        CmBattPrint(CMBATT_ERROR, ("CmBatt: Second AC adapter found.  Current version of driver only supports 1 aadapter.\n"));
    } else {
        AcAdapterPdo = Pdo;
    }

    Status = CmBattCreateFdo(DriverObject, Pdo, (PWSTR) AcAdapterName, sizeof(AC_ADAPTER), &Fdo);

    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddAcAdapter: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    acExtension = (PAC_ADAPTER) Fdo->DeviceExtension;
    acExtension->Type = AC_ADAPTER_TYPE;

    //
    // Register WMI support.
    //
    Status = CmBattWmiRegistration((PCM_BATT)acExtension);

    if (!NT_SUCCESS(Status)) {
        //
        // WMI support is not critical to operation.  Just log an error.
        //

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register as a WMI provider, status = %Lx\n", Status));
    }

    //
    // Register the AC adapter notify handler with ACPI
    //
    Status = acExtension->AcpiInterfaces.RegisterForDeviceNotifications (
                acExtension->AcpiInterfaces.Context,
                CmBattNotifyHandler,
                acExtension);

    //
    // We will ignore errors, since this is not a critical operation
    //

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
        ("CmBattAddAcAdapter: Could not register for power notify, status = %Lx\n", Status));
    }

    //
    // Give one notification, to make sure all batteries get updated.
    //

    CmBattNotifyHandler (acExtension, BATTERY_STATUS_CHANGE);

    return STATUS_SUCCESS;
}



NTSTATUS
CmBattGetAcpiInterfaces(
    IN PDEVICE_OBJECT               LowerDevice,
    OUT PACPI_INTERFACE_STANDARD    AcpiInterfaces
    )

/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.  It does
    this the first time it is called, no more.

Arguments:

    None.

Return Value:

    Status

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    KEVENT                  syncEvent;

    //
    // Allocate an IRP for below
    //
    Irp = IoAllocateIrp (LowerDevice->StackSize, FALSE);      // Get stack size from PDO

    if (!Irp) {
        CmBattPrint((CMBATT_ERROR),
            ("CmBattGetAcpiInterfaces: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);

    //
    // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
    //
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IrpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Version                = 1;
    IrpSp->Parameters.QueryInterface.Size                   = sizeof (*AcpiInterfaces);
    IrpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) AcpiInterfaces;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // Initialize an event so this will be a syncronous call.
    //

    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine (Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

    //
    // Call ACPI
    //

    Status = IoCallDriver (LowerDevice, Irp);

    //
    // Wait if necessary, then clean up.
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }

    IoFreeIrp (Irp);

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
           ("CmBattGetAcpiInterfaces: Could not get ACPI driver interfaces, status = %x\n", Status));
    }

    return Status;
}



NTSTATUS
CmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo,
    IN PWSTR                DeviceName,
    IN ULONG                ExtensionSize,
    OUT PDEVICE_OBJECT      *NewFdo
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Control Method Battery PDO.

Arguments:

    DriverObject    - a pointer to the driver object this is created under
    DeviceName      - The namde of the device to create
    ExtensionSize   - device extension size: sizeof (CM_BATT) or sizeof (AC_ADAPTER)
    NewFdo          - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    PDEVICE_OBJECT          fdo;
    NTSTATUS                status;
    PCM_BATT                cmBatt;
    PUNICODE_STRING         unicodeString;
    ULONG                   uniqueId;
    USHORT                  strLength = 0;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];
    HANDLE                  devInstRegKey;
    UNICODE_STRING          valueName;
    CHAR                    buffer [sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG                   returnSize;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattCreateFdo: Device = %ws\n", DeviceName));

    //
    // Create the PDO device name based on the _UID
    //

    numberString.MaximumLength  = 10;
    numberString.Length         = 0;
    numberString.Buffer         = &numberBuffer[0];

    //
    // Get the unique ID of this device by running the _UID method.
    // If this fails, assume one device.  Append no device number.
    //
    status = CmBattGetUniqueId (Pdo, &uniqueId);

    if (!NT_SUCCESS(status)) {
        CmBattPrint(CMBATT_NOTE, ("CmBattCreateFdo: Error %x from _UID, assuming unit #0\n", status));
        uniqueId = 0;

    } else {
        RtlIntegerToUnicodeString (uniqueId, 10, &numberString);
    }

    //
    // Allocate the UNICODE_STRING for the device name
    //

    strLength = (USHORT) (wcslen (DeviceName) * 2 + numberString.Length);

    unicodeString = ExAllocatePoolWithTag (
                        PagedPool,
                        sizeof (UNICODE_STRING) + strLength,
                        'MtaB'
                        );

    if (!unicodeString) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdo: could not allocate unicode string\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    unicodeString->MaximumLength    = strLength;
    unicodeString->Length           = 0;
    unicodeString->Buffer           = (PWSTR) (unicodeString + 1);

    RtlAppendUnicodeToString  (unicodeString, DeviceName);
    RtlAppendUnicodeStringToString  (unicodeString, &numberString);

    //
    // Create the FDO
    //

    status = IoCreateDevice(
                DriverObject,
                ExtensionSize,
                unicodeString,
                FILE_DEVICE_BATTERY,
                0,
                FALSE,
                &fdo
                );

    if (status != STATUS_SUCCESS) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdo: error (0x%x) creating device object\n", status));
        ExFreePool (unicodeString);
        return(status);
    }

    fdo->Flags |= DO_BUFFERED_IO;
    fdo->Flags |= DO_POWER_PAGABLE;     // Don't want power Irps at irql 2
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Initialize Fdo device extension data
    //

    cmBatt = (PCM_BATT) fdo->DeviceExtension;

    //
    // Note: This is note necessarily a battery.  It could be an AC adapter, so only fields
    // common to both should be initialized here.
    //

    RtlZeroMemory(cmBatt, ExtensionSize);
    //CmBatt->Type must be initialized after this call.
    cmBatt->DeviceObject = fdo;
    cmBatt->Fdo = fdo;
    cmBatt->Pdo = Pdo;

        //
        // Connect to lower device
        //

    cmBatt->LowerDeviceObject = IoAttachDeviceToDeviceStack(fdo, Pdo);
    if (!cmBatt->LowerDeviceObject) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdo: IoAttachDeviceToDeviceStack failed.\n"));
        CmBattDestroyFdo (cmBatt->Fdo);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get the direct-call ACPI interfaces
    //
    status = CmBattGetAcpiInterfaces (cmBatt->LowerDeviceObject, &cmBatt->AcpiInterfaces);
    if (!NT_SUCCESS(status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdor: Could not get ACPI interfaces: %x\n", status));
        IoDetachDevice (cmBatt->LowerDeviceObject);
        CmBattDestroyFdo (cmBatt->Fdo);
        return status;
    }

    //
    // Initializes File handle tracking.
    //
    ExInitializeFastMutex (&cmBatt->OpenCloseMutex);
    cmBatt->OpenCount = 0;

    //
    // Removal lock initialization
    //
    cmBatt->WantToRemove = FALSE;
    cmBatt->InUseCount = 1;
    KeInitializeEvent(&cmBatt->ReadyToRemove, SynchronizationEvent, FALSE);

    cmBatt->DeviceNumber = uniqueId;
    cmBatt->DeviceName = unicodeString;
    cmBatt->Sleeping = FALSE;
    cmBatt->ActionRequired = CMBATT_AR_NO_ACTION;

    //
    // Determine if wake on Battery should be enabled
    //
    cmBatt->WakeEnabled = FALSE;

    status = IoOpenDeviceRegistryKey (Pdo,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
        status = ZwQueryValueKey(
            devInstRegKey,
            &valueName,
            KeyValuePartialInformation,
            &buffer,
            sizeof(buffer),
            &returnSize
            );

        if (NT_SUCCESS (status)) {
            cmBatt->WakeEnabled = (*(PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data ? TRUE : FALSE);
        }
        ZwClose(devInstRegKey);
    }

    *NewFdo = fdo;

    CmBattPrint((CMBATT_TRACE | CMBATT_PNP), ("CmBattCreateFdo: Created FDO %x\n", fdo));
    return STATUS_SUCCESS;
}



VOID
CmBattDestroyFdo(
    IN PDEVICE_OBJECT       Fdo
    )

/*++

Routine Description:

    This routine will deallocate a functional device object.
    This includes deallocating the DeviceName and calling IoDeleteDevice.

Arguments:

    Fdo       - a pointer to the FDO to destroy.

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattDestroyFdo, Battery.\n"));

    //
    // Deallocate the UNICODE_STRING for the device name
    //

    ExFreePool (((PCM_BATT)Fdo->DeviceExtension)->DeviceName);
    ((PCM_BATT)Fdo->DeviceExtension)->DeviceName = NULL;

    IoDeleteDevice (Fdo);

    CmBattPrint((CMBATT_TRACE | CMBATT_PNP), ("CmBattDestroyFdo: done.\n"));
}



NTSTATUS
CmBattPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            CmBatt;
    NTSTATUS            status;
    KEVENT              syncEvent;

    PAGED_CODE();

    status = STATUS_NOT_SUPPORTED;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    CmBatt = DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        //
        // Failed to acquire remove lock.
        //
        status = STATUS_DEVICE_REMOVED;
    } else {
        //
        // Remove lock acquired.
        //

        //
        // Dispatch minor function
        //
        switch (irpStack->MinorFunction) {

            case IRP_MN_START_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_START_DEVICE\n"));

                if (CmBatt->Type == CM_BATTERY_TYPE) {
                    //
                    // We only want to handle batteries, not AC adapters.
                    //

                    CmBatt->IsStarted = TRUE;

                }
                status = STATUS_SUCCESS;

                break;
            }   // IRP_MN_START_DEVICE

            case IRP_MN_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_STOP_DEVICE\n"));

                if (CmBatt->Type == CM_BATTERY_TYPE) {
                    CmBatt->IsStarted = FALSE;
                }
                status = STATUS_SUCCESS;

                break;
            }   // IRP_MN_STOP_DEVICE

            case IRP_MN_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_REMOVE_DEVICE\n"));

                status = CmBattRemoveDevice(DeviceObject, Irp);
                break;
            }   //  IRP_MN_REMOVE_DEVICE

            case IRP_MN_SURPRISE_REMOVAL: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_SURPRISE_REMOVAL\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
                status = STATUS_SUCCESS;

                CmBatt->OpenCount = (ULONG) -1;

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_QUERY_REMOVE_DEVICE

            case IRP_MN_QUERY_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_REMOVE_DEVICE\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
                status = STATUS_SUCCESS;

                if (CmBatt->OpenCount == 0) {
                    CmBatt->OpenCount = (ULONG) -1;
                } else if (CmBatt->OpenCount == (ULONG) -1) {
                    CmBattPrint (CMBATT_WARN, ("CmBattPnpDispatch: Recieved two consecutive QUERY_REMOVE requests.\n"));

                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_QUERY_REMOVE_DEVICE

            case IRP_MN_CANCEL_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);

                if (CmBatt->OpenCount == (ULONG) -1) {
                    CmBatt->OpenCount = 0;
                } else {
                    CmBattPrint (CMBATT_NOTE, ("CmBattPnpDispatch: Received CANCEL_REMOVE when OpenCount == %x\n",
                                 CmBatt->OpenCount));
                }
                status = STATUS_SUCCESS;

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_CANCEL_REMOVE_DEVICE

            case IRP_MN_QUERY_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_STOP_DEVICE\n"));
                status = STATUS_NOT_IMPLEMENTED;
                break;
            }   //  IRP_MN_QUERY_STOP_DEVICE

            case IRP_MN_CANCEL_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_CANCEL_STOP_DEVICE\n"));
                status = STATUS_NOT_IMPLEMENTED;
                break;
            }   //  IRP_MN_CANCEL_STOP_DEVICE

            case IRP_MN_QUERY_PNP_DEVICE_STATE: {

                IoCopyCurrentIrpStackLocationToNext (Irp);

                KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                IoSetCompletionRoutine(Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

                status = IoCallDriver(CmBatt->LowerDeviceObject, Irp);

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                    status = Irp->IoStatus.Status;
                }

                Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
                    KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                return status;

            }

            case IRP_MN_QUERY_CAPABILITIES: {

                IoCopyCurrentIrpStackLocationToNext (Irp);

                KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                IoSetCompletionRoutine(Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

                status = IoCallDriver(CmBatt->LowerDeviceObject, Irp);

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                    status = Irp->IoStatus.Status;
                }

                CmBatt->WakeSupportedState.SystemState = irpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake;
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES %d Capabilities->SystemWake = %x\n", CmBatt->Type, CmBatt->WakeSupportedState.SystemState));
                if (CmBatt->WakeSupportedState.SystemState != PowerSystemUnspecified) {
                    if (CmBatt->WaitWakeIrp == NULL && CmBatt->WakeEnabled) {
                        status = PoRequestPowerIrp(
                                    CmBatt->DeviceObject,
                                    IRP_MN_WAIT_WAKE,
                                    CmBatt->WakeSupportedState,
                                    CmBattWaitWakeLoop,
                                    NULL,
                                    &(CmBatt->WaitWakeIrp)
                                    );

                        CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES wait/Wake irp sent.\n"));
                    }
                } else {
                    CmBatt->WakeEnabled=FALSE;
                    CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES Wake not supported.\n"));
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
                    KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                return status;

            }

            default: {
                //
                // Unimplemented minor, Pass this down
                //
                CmBattPrint (CMBATT_PNP,
                        ("CmBattPnpDispatch: Unimplemented minor %0x\n", \
                        irpStack->MinorFunction));
            }   //  default

            // Fall through...

            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_READ_CONFIG:
            case IRP_MN_WRITE_CONFIG:
            case IRP_MN_EJECT:
            case IRP_MN_SET_LOCK:
            case IRP_MN_QUERY_ID:
            case IRP_MN_QUERY_DEVICE_RELATIONS: {

                break ;
            }
        }
    }

    //
    // Release remove lock
    //

    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }


    //
    // Only set status if we have something to add
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    }

    //
    // Do we need to send it down?
    //
    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        CmBattCallLowerDriver(status, CmBatt->LowerDeviceObject, Irp);
        return status;
    }

    //
    // At this point, it must have been passed down and needs recompletion,
    // or the status is unsuccessful.
    //
    ASSERT(!NT_SUCCESS(status) && (status != STATUS_NOT_SUPPORTED));

    status = Irp->IoStatus.Status ;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
CmBattRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine processes a IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Returns STATUS_SUCCESS.  (This function must not fail.)

--*/

{
    PCM_BATT                cmBatt;
    NTSTATUS                status;

    cmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    CmBattPrint (CMBATT_TRACE, ("CmBattRemoveDevice: CmBatt (%x), Type %d, _UID %d\n",
                 cmBatt, cmBatt->Type, cmBatt->DeviceNumber));


    //
    // Remove device syncronization
    //

    //
    // Prevent more locks from being acquired.
    //

    cmBatt->WantToRemove = TRUE;

    //
    // Release lock acquired at start of CmBattPnpDispatch
    //
    if (InterlockedDecrement (&cmBatt->InUseCount) <= 0) {
        CmBattPrint (CMBATT_ERROR, ("CmBattRemoveDevice: Remove lock error.\n"));
        ASSERT(FALSE);
    }

    //
    // Final release and wait.
    //
    // Note: there will be one more relase at the end of CmBattPnpDispatch
    // but it will decrement the InUseCount to -1 so it won't set the event.
    //
    if (InterlockedDecrement (&cmBatt->InUseCount) > 0) {
        KeWaitForSingleObject (&cmBatt->ReadyToRemove,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
    }

    //
    // Cancel the Wait/wake IRP;
    //
    if (cmBatt->WaitWakeIrp != NULL) {
        IoCancelIrp (cmBatt->WaitWakeIrp);
        cmBatt->WaitWakeIrp = NULL;
    }

    if (cmBatt->Type == CM_BATTERY_TYPE) {
        //
        // This is a control method battery FDO
        //

        //
        // Disconnect from receiving device (battery) notifications
        //

        cmBatt->AcpiInterfaces.UnregisterForDeviceNotifications (
            cmBatt->AcpiInterfaces.Context,
            CmBattNotifyHandler);

        //
        // Unregister as a WMI Provider.
        //
        CmBattWmiDeRegistration(cmBatt);

        //
        //  Tell the class driver we are going away
        //
        status = BatteryClassUnload (cmBatt->Class);
        ASSERT (NT_SUCCESS(status));

    } else {
        //
        // This is an AC adapter FDO
        //

        //
        // Disconnect from receiving device (battery) notifications
        //

        cmBatt->AcpiInterfaces.UnregisterForDeviceNotifications (
            cmBatt->AcpiInterfaces.Context,
            CmBattNotifyHandler);

        //
        // Unregister as a WMI Provider.
        //
        CmBattWmiDeRegistration(cmBatt);

        AcAdapterPdo = NULL;
    }

    //
    //  Clean up, delete the string and the Fdo we created at AddDevice time
    //

    ExFreePool (cmBatt->DeviceName);

    IoDetachDevice (cmBatt->LowerDeviceObject);
    IoDeleteDevice (cmBatt->DeviceObject);

    return STATUS_SUCCESS;

}


NTSTATUS
CmBattPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            CmBatt;
    NTSTATUS            Status;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality
    // was added to this routine, a remove lock might be neccesary.
    //

    CmBattPrint ((CMBATT_TRACE | CMBATT_POWER), ("CmBattPowerDispatch\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    CmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

    case IRP_MN_WAIT_WAKE: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
            break;
        }

    case IRP_MN_POWER_SEQUENCE: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

    case IRP_MN_SET_POWER: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_SET_POWER type: %d, State: %d \n",
                                        irpStack->Parameters.Power.Type,
                                        irpStack->Parameters.Power.State));
            break;
        }

    case IRP_MN_QUERY_POWER: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
            break;
        }

    default: {

            CmBattPrint(CMBATT_LOW, ("CmBattPowerDispatch: minor %d\n",
                    irpStack->MinorFunction));

            break;
        }
    }

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (CmBatt->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        Status = PoCallDriver( CmBatt->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}



NTSTATUS
CmBattForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_BATT    cmBatt = DeviceObject->DeviceExtension;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality was
    // added to this routine, a remove lock might be neccesary.
    //

    if (cmBatt->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( cmBatt->LowerDeviceObject, Irp );

    } else {

        Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
CmBattWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called after the WAIT_WAKE has been completed

Arguments:

    DeviceObject    - The PDO
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The Sleep state that it could wake from
    Context         - NOT USED
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PCM_BATT  cmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    CmBattPrint (CMBATT_PNP, ("CmBattWaitWakeLoop: Entered.\n"));
    if (!NT_SUCCESS(IoStatus->Status) || !cmBatt->WakeEnabled) {

        CmBattPrint (CMBATT_ERROR, ("CmBattWaitWakeLoop: failed: status = 0x%08x.\n", IoStatus->Status));
        cmBatt->WaitWakeIrp = NULL;
        return IoStatus->Status;

    } else {
        CmBattPrint (CMBATT_NOTE, ("CmBattWaitWakeLoop: completed successfully\n"));
    }

    //
    // In this case, we just cause the same thing to happen again
    //
    status = PoRequestPowerIrp(
        DeviceObject,
        MinorFunction,
        PowerState,
        CmBattWaitWakeLoop,
        Context,
        &(cmBatt->WaitWakeIrp)
        );

    CmBattPrint (CMBATT_NOTE, ("CmBattWaitWakeLoop: PoRequestPowerIrp: status = 0x%08x.\n", status));

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmexe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBatt.c

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CmBattSendDownStreamIrp)
#pragma alloc_text(PAGE, CmBattGetUniqueId)
#pragma alloc_text(PAGE, CmBattGetStaData)
#pragma alloc_text(PAGE, CmBattSetTripPpoint)
#endif

#define EXPECTED_DATA_SIZE 512

NTSTATUS
CmBattSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            OutputSize
)
/*++

Routine Description:

    Called to send a request to the Pdo

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioBlock;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;

    PAGED_CODE();

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
        Ioctl,
        Pdo,
        InputBuffer,
        InputSize,
        OutputBuffer,
        OutputSize,
        FALSE,
        &event,
        &ioBlock
        );
    if (!irp) {

        CmBattPrint((CMBATT_ERROR | CMBATT_CM_EXE),
            ("CmBattSendDownStreamIrp: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattSendDownStreamIrp: Irp %x [Tid] %x\n", irp, GetTid() )
        );

    //
    // Pass request to Pdo, always wait for completion routine
    //
    status = IoCallDriver(Pdo, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioBlock.Status;

    }

    //
    // Sanity check the data
    //
    if (OutputBuffer != NULL) {

        if ( ( (PACPI_EVAL_OUTPUT_BUFFER) OutputBuffer)->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
             ( (PACPI_EVAL_OUTPUT_BUFFER) OutputBuffer)->Count == 0) {

            status = STATUS_ACPI_INVALID_DATA;

        }

    }

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattSendDownStreamIrp: Irp %x completed %x! [Tid] %x\n",
         irp, status, GetTid() )
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
CmBattGetUniqueId(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          UniqueId
    )
/*++

Routine Description:

    Obtain the UID (unique ID) for a battery.

Arguments:

    CmBatt          - The extension for this device.
    UniqueId        - Pointer to where the ID is stored.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetUniqueId: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( UniqueId != NULL );
    *UniqueId = 0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_UID_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetUniqueId: Failed _UID method - Status (0x%x)\n", status)
            );
        return status;

    }

    //
    // Grab the argument
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, UniqueId );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetUniqueId: _UID method returned 0x%x\n", *UniqueId)
        );

    return status;
}

NTSTATUS
CmBattGetStaData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    )
/*++

Routine Description:

    Called to get a device status via the _STA method.   Generic, works for
    any device with the _STA method (assuming caller has a Pdo).

Arguments:

    Pdo             - For the device.
    ReturnStatus    - Pointer to where the status data is placed.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetStaData: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( ReturnStatus != NULL );
    *ReturnStatus = 0x0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_STA_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetStaData: Failed _STA method - Status (0x%x)\n", status)
            );
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Grab the argument
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, ReturnStatus );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetStaData: _STA method returned %x \n", *ReturnStatus )
        );
    return status;
}

NTSTATUS
CmBattGetPsrData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    )
/*++

Routine Description:

    Called to get the AC adapter device status via the _PSR method.


Arguments:

    Pdo             - For the device.
    ReturnStatus    - Pointer to where the status data is placed.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetPsrData: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( ReturnStatus != NULL );
    *ReturnStatus = 0x0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_PSR_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetPsrData: Failed _PSR method - Status (0x%x)\n", status)
            );
        return status;

    }

    //
    // Get the value
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, ReturnStatus );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetPsrData: _PSR method returned %x \n", *ReturnStatus )
        );
    return status;
}

NTSTATUS
CmBattSetTripPpoint(
    IN PCM_BATT     CmBatt,
    IN ULONG        TripPoint
)
/*++

Routine Description:

    Called to set the tripPoint via the BTP control method.

Arguments:

    CmBatt          - The extension for this device.
    TripPoint       - The desired alarm value

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER   inputBuffer;
    NTSTATUS                                status;

    PAGED_CODE();

    CmBattPrint(
         (CMBATT_CM_EXE | CMBATT_BIOS),
         ("CmBattSetTripPpoint: _BTP Alarm Value %x Device %x Tid %x\n",
          TripPoint, CmBatt->DeviceNumber, GetTid() )
         );

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_BTP_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer.IntegerArgument = TripPoint;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       CmBatt->LowerDeviceObject,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
       NULL,
       0
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattSetTripPpoint: Failed _BTP method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
CmBattGetBifData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BIF_BAT_INFO    BifBuf
)
/*++

Routine Description:

    Called to read the BIF package from ACPI

Arguments:

    CmBatt          - The extension for this device.
    BifBuf          - Output buffer for the BIF data

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER      inputBuffer;
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       argument;

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetBifData: Buffer (0x%x) Device %x Tid %x\n",
         BifBuf, CmBatt->DeviceNumber, GetTid() )
        );

    //
    //  Allocate a buffer for this
    //
    outputBuffer = ExAllocatePoolWithTag(
        PagedPool,
        EXPECTED_DATA_SIZE,
        'MtaB'
        );
    if (!outputBuffer) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
             ("CmBattGetBifData: Failed to allocate Buffer\n")
            );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Clear the buffers
    //
    RtlZeroMemory(outputBuffer, EXPECTED_DATA_SIZE);
    RtlZeroMemory(BifBuf, sizeof(CM_BIF_BAT_INFO));

    //
    //  Set the request data
    //
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_BIF_METHOD;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
        CmBatt->LowerDeviceObject,
        IOCTL_ACPI_EVAL_METHOD,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        EXPECTED_DATA_SIZE
        );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
             ("CmBattGetBifData: Failed _BIF method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );
        goto CmBattGetBifDataExit;

    }

    //
    // Sanity check the return count
    //
    if (outputBuffer->Count != NUMBER_OF_BIF_ELEMENTS) {

        //
        //  Package did not contain the correct number of elements to be a BIF
        //
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: _BIF returned %d elements. BIF requires %d\n",
             outputBuffer->Count,
             NUMBER_OF_BIF_ELEMENTS)
            );
        status = STATUS_ACPI_INVALID_DATA;
        goto CmBattGetBifDataExit;

    }

    //
    // Look at the return arguments
    //
    argument = outputBuffer->Argument;

    //
    // Parse the package data that is returned.  This should look like:
    //
    status = GetDwordElement (argument, &BifBuf->PowerUnit);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get PowerUnit\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacity\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->LastFullChargeCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get LastFullChargeCapacity\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryTechnology);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryTechnology\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignVoltage);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignVoltage\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacityOfWarning);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacityOfWarning\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacityOfLow);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacityOfLow\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryCapacityGran_1);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryCapacityGran_1\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryCapacityGran_2);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryCapacityGran_2\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->ModelNumber[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->ModelNumber[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get ModelNumber\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->SerialNumber[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->SerialNumber[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get SerialNumber\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->BatteryType[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->BatteryType[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryType\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->OEMInformation[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );

    //
    // This returns an ASCIIZ string normally,
    // but returns integer 0x00 if OEMInformation isn't supported.
    //
    if (argument->Type == ACPI_METHOD_ARGUMENT_INTEGER) {
        if (argument->Argument != 0) {
            CmBattPrint(
                (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
                ("CmBattGetBifData: Failed to get OEMInformation\n")
                );
            goto CmBattGetBifDataExit;
        }
        BifBuf->OEMInformation[0] = 0;
        status = STATUS_SUCCESS;
    } else {
        status = GetStringElement (argument, &BifBuf->OEMInformation[0]);
        if (!NT_SUCCESS (status)) {
            CmBattPrint(
                (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
                ("CmBattGetBifData: OEMInformation not supported\n")
                );
        }
    }

CmBattGetBifDataExit:
    //
    // Done
    //
    ExFreePool (outputBuffer);
    return status;
}



NTSTATUS
CmBattGetBstData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BST_BAT_INFO    BstBuf
)
/*++

Routine Description:

    Called to read the BST package from ACPI

Arguments:

    CmBatt          - The extension for this device.
    BstBuf          - Output buffer for the BST data

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER      inputBuffer;
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       argument;

    CmBattPrint(
         CMBATT_CM_EXE,
         ("CmBattGetBstData: Buffer (0x%x) Device %x Tid %x\n",
          BstBuf, CmBatt->DeviceNumber, GetTid() )
         );

    //
    //  Allocate a buffer for this
    //
    outputBuffer = ExAllocatePoolWithTag(
        PagedPool,
        EXPECTED_DATA_SIZE,
        'MtaB'
        );
    if (!outputBuffer) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
             ("CmBattGetBstData: Failed to allocate Buffer\n")
            );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Clear the buffers
    //
    RtlZeroMemory(outputBuffer, EXPECTED_DATA_SIZE);
    RtlZeroMemory(BstBuf, sizeof(CM_BST_BAT_INFO));

    //
    //  Set the request data
    //
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_BST_METHOD;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
        CmBatt->LowerDeviceObject,
        IOCTL_ACPI_EVAL_METHOD,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        EXPECTED_DATA_SIZE
        );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
             ("CmBattGetBstData: Failed _BST method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );
        goto CmBattGetBstDataExit;

    }

    //
    // Sanity check the return value
    //
    if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer->Count != NUMBER_OF_BST_ELEMENTS) {

        //
        //  Package did not contain the correct number of elements to be a BIF
        //
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: _BST returned %d elements. BIF requires %d\n",
             outputBuffer->Count,
             NUMBER_OF_BST_ELEMENTS)
            );
        status = STATUS_ACPI_INVALID_DATA;
        goto CmBattGetBstDataExit;

    }

    //
    // Look at the return arguments
    //
    argument = outputBuffer->Argument;

    //
    // Parse the package data that is returned.  This should look like:
    //
    status = GetDwordElement (argument, &BstBuf->BatteryState);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get BatteryState\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->PresentRate);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get PresentRate\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->RemainingCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get RemainingCapacity\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->PresentVoltage);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get PresentVoltage\n")
            );
        goto CmBattGetBstDataExit;
    }

    CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
               ("CmBattGetBstData: (BST) State=%x Rate=%x Capacity=%x Volts=%x\n",
                BstBuf->BatteryState, BstBuf->PresentRate,
                BstBuf->RemainingCapacity, BstBuf->PresentVoltage));

    //
    // Done --- cleanup
    //

CmBattGetBstDataExit:
    ExFreePool( outputBuffer );
    return status;
}

NTSTATUS
GetDwordElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PULONG                  PDword
)
/*++

Routine Description:

    This routine cracks the integer value from the argument and stores it
    in the supplied pointer to a ULONG

Arguments:

    Argument    - Points to the argument to parse
    PDword      - Where to store the argument

Return Value:

    NT Status of the operation

--*/
{

    //
    // Check to see if we have the right type of data
    //
    if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetDwordElement: Object contained wrong data type - %d\n",
             Argument->Type)
            );
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Copy the DWORD
    //
    *PDword = Argument->Argument;

    //
    // Success!
    //
    return STATUS_SUCCESS;
}

NTSTATUS
GetStringElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PUCHAR                  PBuffer
)
/*++

Routine Description:

    This routine cracks the string from the argument and stroes it in the
    supplied pointer to a PUCHAR

    Note: A buffer is allowed as well.

Arguments:

    Argument    - Points to the argument to parse
    PBuffer     - Pointer to storage for the string

Return Value:

    NT Status of the operation

--*/
{

    //
    // Check to see if we have the right type of data
    //
    if (Argument->Type != ACPI_METHOD_ARGUMENT_STRING &&
        Argument->Type != ACPI_METHOD_ARGUMENT_BUFFER) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetStringElement: Object contained wrong data type - %d\n",
             Argument->Type)
            );
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Check to see if the return buffer is long enough
    //
    if (Argument->DataLength >= CM_MAX_STRING_LENGTH) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetStringElement: return buffer not big enough - %d\n",
             Argument->DataLength)
            );
        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Copy the string
    //
    RtlCopyMemory (PBuffer, Argument->Data, Argument->DataLength);

    //
    // Success
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbattp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBattp.h

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <wmilib.h>
#include <batclass.h>
#include <devioctl.h>
#include <acpiioct.h>


#define DIRECT_ACCESS DBG
#if DIRECT_ACCESS
    #define CMB_DIRECT_IOCTL_ONLY 1
    #include "cmbdrect.h"
#endif

//
// Debug
//

#define DEBUG   DBG
#if DEBUG
    extern ULONG CmBattDebug;
    #define CmBattPrint(l,m)    if(l & CmBattDebug) DbgPrint m
#else
    #define CmBattPrint(l,m)
#endif

#define CMBATT_LOW          0x00000001
#define CMBATT_NOTE         0x00000002
#define CMBATT_WARN         0x00000004
#define CMBATT_ERROR_ONLY   0x00000008
#define CMBATT_ERROR        (CMBATT_ERROR_ONLY | CMBATT_WARN)
#define CMBATT_POWER        0x00000010
#define CMBATT_PNP          0x00000020
#define CMBATT_CM_EXE       0x00000040
#define CMBATT_DATA         0x00000100
#define CMBATT_TRACE        0x00000200
#define CMBATT_BIOS         0x00000400  // Show message to verify BIOS/HW functionality
#define CMBATT_MINI         0x00000800  // Show message to verify miniport retun data


extern UNICODE_STRING GlobalRegistryPath;

extern PDEVICE_OBJECT               AcAdapterPdo;
extern KDPC CmBattWakeDpcObject;
extern KTIMER CmBattWakeDpcTimerObject;

//
// Delay before notifications on wake = 0 seconds * 10,000,000 (100-ns/s)
//
#define WAKE_DPC_DELAY          {0,0}

//
// Delay on switch to DC before showing estimated time. 
// 15 seconds * 10,000,000 (100-ns/s)
//
#define CM_ESTIMATED_TIME_DELAY 150000000

extern LARGE_INTEGER            CmBattWakeDpcDelay;

#define MAX_DEVICE_NAME_LENGTH  100

//
// WaitWake registry key
//
extern PCWSTR                   WaitWakeEnableKey;

//
// Host Controller Device object extenstion
//

#define CM_MAX_DATA_SIZE            64
#define CM_MAX_STRING_LENGTH        256

//
//  Control Methods defined for the Control Method Batteries
//
#define CM_BIF_METHOD               (ULONG) ('FIB_')
#define CM_BST_METHOD               (ULONG) ('TSB_')
#define CM_BTP_METHOD               (ULONG) ('PTB_')
#define CM_PCL_METHOD               (ULONG) ('LCP_')
#define CM_PSR_METHOD               (ULONG) ('RSP_')
#define CM_STA_METHOD               (ULONG) ('ATS_')
#define CM_UID_METHOD               (ULONG) ('DIU_')

#define CM_OP_TYPE_READ             0
#define CM_OP_TYPE_WRITE            1


#define NUMBER_OF_BIF_ELEMENTS      13
#define NUMBER_OF_BST_ELEMENTS      4


//
// Value to send to _BTP to clear the trip point.
//

#define CM_BATT_CLEAR_TRIP_POINT   0x00000000

//
// Special values retuned from control methods.
//

#define CM_UNKNOWN_VALUE    0xffffffff
#define CM_MAX_VALUE        0x7fffffff

//
// STA control method return values
//

#define STA_DEVICE_PRESENT          0x10
#define STA_DEVICE_FUNCTIONAL       0x80

//
// Control method battery device notification values
//

#define BATTERY_DEVICE_CHECK        0x00
#define BATTERY_EJECT               0x01
#define BATTERY_STATUS_CHANGE       0x80
#define BATTERY_INFO_CHANGE         0x81

//
//  This is the static data defined by the ACPI spec for the control method battery
//  It is returned by the _BIF control method
//
typedef struct {
    ULONG                   PowerUnit;                  // units used by interface 0:mWh or 1:mAh
    ULONG                   DesignCapacity;             // Nominal capacity of a new battery
    ULONG                   LastFullChargeCapacity;     // Predicted capacity when fully charged
    ULONG                   BatteryTechnology;          // 0:Primary (not rechargable), 1:Secondary (rechargable)
    ULONG                   DesignVoltage;              // Nominal voltage of a new battery
    ULONG                   DesignCapacityOfWarning;    // OEM-designed battery warning capacity
    ULONG                   DesignCapacityOfLow;        // OEM-designed battery low capacity
    ULONG                   BatteryCapacityGran_1;      // capacity granularity between low and warning
    ULONG                   BatteryCapacityGran_2;      // capacity granularity between warning and full
    UCHAR                   ModelNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   SerialNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   BatteryType[CM_MAX_STRING_LENGTH];
    UCHAR                   OEMInformation[CM_MAX_STRING_LENGTH];
} CM_BIF_BAT_INFO, *PCM_BIF_BAT_INFO;

//
//  Definitions for the PowerUnit field of CM_BIF_BAT_INFO
//
#define CM_BIF_UNITS_WATTS          0   //  All units are in mWh
#define CM_BIF_UNITS_AMPS           1   //  All units are in mAh

//
//  This is the battery status data defined by the ACPI spec for a control method battery
//  It is returned by the _BST control method
//
typedef struct {
    ULONG                   BatteryState;       // Charging/Discharging/Critical
    ULONG                   PresentRate;        // Present draw rate in units defined by PowerUnit
                                                // Unsigned value, direction is determined by BatteryState
    ULONG                   RemainingCapacity;  // Estimated remaining capacity, units defined by PowerUnit
    ULONG                   PresentVoltage;     // Present voltage across the battery terminals

} CM_BST_BAT_INFO, *PCM_BST_BAT_INFO;

//
//  Bit definitions for the BatteryState field of CM_BST_BAT_INFO
//
#define CM_BST_STATE_DISCHARGING    0x00000001  //  Battery is discharging
#define CM_BST_STATE_CHARGING       0x00000002  //  Battery is charging
#define CM_BST_STATE_CRITICAL       0x00000004  //  Battery is critical

//
// Cached battery info
//

typedef struct {
    ULONG                   Tag;                // Unique tag for this battery,
    ULONG                   ModelNumLen;        // Length of ModelNumber string in StringBuffer
    PUCHAR                  ModelNum;           // Ptr to ModelNumber in StringBuffer
    ULONG                   SerialNumLen;       // Length of SerialNumber string in StringBuffer
    PUCHAR                  SerialNum;          // Ptr to SerialNumber in StringBuffer
    ULONG                   OEMInfoLen;         // Length of OEMInformation string in StringBuffer
    PUCHAR                  OEMInfo;            // Ptr to OEMInformation in StringBuffer

    CM_BST_BAT_INFO         Status;             // Last Status read from battery
    CM_BIF_BAT_INFO         StaticData;         // Last valid data
    ULONG                   StaticDataTag;      // Tag when static data was last read

    BATTERY_STATUS          ApiStatus;          // Status info, class driver structure
    BATTERY_INFORMATION     ApiInfo;            // Battery info, class driver structure
    ULONG                   ApiGranularity_1;
    ULONG                   ApiGranularity_2;

    BOOLEAN                 BtpExists;          // Remeber if _BTP method exists

} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;


typedef struct {
    ULONG                   Granularity;
    ULONG                   Capacity;

} BATTERY_REMAINING_SCALE, *PBATTERY_REMAINING_SCALE;

typedef struct {
    ULONG                   Setting;            // The alarm value
    BOOLEAN                 Supported;          // Set to false when _BTP fails
                                                //  don't bother calling _BTP again
} BAT_ALARM_INFO, *PBAT_ALARM_INFO;

#define CM_ALARM_INVALID 0xffffffff;

//
// Types for the different FDOs created by this driver.
//

#define AC_ADAPTER_TYPE     0x00
#define CM_BATTERY_TYPE     0x01



//
// Pagable device extension for control method battery
//

typedef struct _CM_BATT {

    ULONG                   Type;               // Battery or AC Adapter

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time

    FAST_MUTEX              OpenCloseMutex;
    ULONG                   OpenCount;          // Count open file handles to device

    PIRP                    WaitWakeIrp;        // Pointer to Wait Wake Irp
    POWER_STATE             WakeSupportedState;
    WMILIB_CONTEXT          WmiLibContext;
    BOOLEAN                 WakeEnabled;

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

    ULONG                   DeviceNumber;

    PUNICODE_STRING         DeviceName;

    ACPI_INTERFACE_STANDARD AcpiInterfaces;

    BOOLEAN                 Sleeping;
    UCHAR                   ActionRequired;

    //
    // All fields before this point are common between _CM_BATT and _AC_ADAPTER
    //

    PVOID                   Class;              // Battery Class handle

    BOOLEAN                 IsStarted;          // if non zero, the device is started
    BOOLEAN                 ReCheckSta;
    LONG                    CacheState;         // 0 = invalid
                                                // 1 = updating values
                                                // 2 = valid
    //
    // Battery
    //
    ULONG                   TagCount;           // Tag for next battery
    STATIC_BAT_INFO         Info;
    BAT_ALARM_INFO          Alarm;
    ULONGLONG               DischargeTime;      // Time battery started discharging.

} CM_BATT, *PCM_BATT;


//
// Pagable device extension for AC Adapter
//

typedef struct _AC_ADAPTER {

    ULONG                   Type;               // Battery or AC Adapter

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time

    FAST_MUTEX              OpenCloseMutex;
    ULONG                   OpenCount;          // Count open file handles to device

    PIRP                    WaitWakeIrp;        // Pointer to Wait Wake Irp
    POWER_STATE             WakeSupportedState;
    WMILIB_CONTEXT          WmiLibContext;
    BOOLEAN                 WakeEnabled;

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

    ULONG                   DeviceNumber;

    PUNICODE_STRING         DeviceName;

    ACPI_INTERFACE_STANDARD AcpiInterfaces;

    BOOLEAN                 Sleeping;
    UCHAR                   ActionRequired;

} AC_ADAPTER, *PAC_ADAPTER;

// Action required (AR) flags
#define CMBATT_AR_NO_ACTION 0
#define CMBATT_AR_NOTIFY 1
#define CMBATT_AR_INVALIDATE_CACHE 2
#define CMBATT_AR_INVALIDATE_TAG 4

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//

#define CmBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }

#define GetTid() PsGetCurrentThread()

//
// Prototypes
//

VOID
CmBattAlarm (
    IN PVOID                Context,
    IN UCHAR                Address,
    IN USHORT               Data
    );

NTSTATUS
CmBattVerifyStaticInfo (
    IN PCM_BATT             CmBatt,
    IN ULONG                BatteryTag
    );

NTSTATUS
CmBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CmBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CmBattSystemControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CmBattForwardRequest(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
CmBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
CmBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
CmBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
CmBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
CmBattGetBifData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BIF_BAT_INFO    BifBuf
    );

NTSTATUS
CmBattGetUniqueId(
    IN PDEVICE_OBJECT       Pdo,
    OUT PULONG              UniqueId
    );

NTSTATUS
CmBattGetStaData(
    IN PDEVICE_OBJECT        Pdo,
    OUT PULONG              ReturnStatus
    );

NTSTATUS
CmBattGetPsrData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    );

NTSTATUS
CmBattIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
CmBattSetTripPpoint(
    IN PCM_BATT             CmBatt,
    IN ULONG                TripPoint
    );

NTSTATUS
CmBattGetBstData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BST_BAT_INFO    BstBuf
    );

NTSTATUS
GetDwordElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PULONG                  PDword
    );

NTSTATUS
GetStringElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PUCHAR                  PBuffer
    );

VOID
CmBattPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    );

VOID
CmBattWakeDpc (
    IN  PKDPC   Dpc,
    IN  PVOID   DefferedContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

VOID
CmBattNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

NTSTATUS
CmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

NTSTATUS
CmBattSendDownStreamIrp(
    IN  PDEVICE_OBJECT      Pdo,
    IN  ULONG               Ioctl,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputSize,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputSize
    );

NTSTATUS
CmBattWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
CmBattWmiRegistration(
    PCM_BATT CmBatt
);

NTSTATUS
CmBattWmiDeRegistration(
    PCM_BATT CmBatt
);

#ifndef _WIN32_WINNT

VOID
CmBattNotifyVPOWERDOfPowerChange (
    IN  ULONG PowerSourceChange
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbwmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmbWmi.c

Abstract:

    Wmi section for Control Method Battery Miniport Driver

Author:

    Michael Hills

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

NTSTATUS
CmBattSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
CmBattSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
CmBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
CmBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

#if DEBUG
PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
);
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmBattWmiRegistration)
#pragma alloc_text(PAGE,CmBattWmiDeRegistration)
#pragma alloc_text(PAGE,CmBattSystemControl)
#pragma alloc_text(PAGE,CmBattSetWmiDataItem)
#pragma alloc_text(PAGE,CmBattSetWmiDataBlock)
#pragma alloc_text(PAGE,CmBattQueryWmiDataBlock)
#pragma alloc_text(PAGE,CmBattQueryWmiRegInfo)
#endif


//
// WMI info
//

#define MOFRESOURCENAME L"BATTWMI"

typedef struct _MSPower_DeviceWakeEnable
{
    //
    BOOLEAN Enable;
    #define MSPower_DeviceWakeEnable_Enable_SIZE sizeof(BOOLEAN)
    #define MSPower_DeviceWakeEnable_Enable_ID 1

} MSPower_DeviceWakeEnable, *PMSPower_DeviceWakeEnable;


WMIGUIDREGINFO CmBattWmiGuidList[1] =
{
    {
        &GUID_POWER_DEVICE_WAKE_ENABLE, 1, 0
    }
};


NTSTATUS
CmBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status = STATUS_NOT_SUPPORTED;
    PCM_BATT        CmBatt;
    PIO_STACK_LOCATION      stack;
    SYSCTL_IRP_DISPOSITION  disposition = IrpForward;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);

    CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: %s\n",
                WMIMinorFunctionString(stack->MinorFunction)));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
            KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        status = BatteryClassSystemControl(CmBatt->Class,
                                           &CmBatt->WmiLibContext,
                                           DeviceObject,
                                           Irp,
                                           &disposition);
    } else {
        status = WmiSystemControl(&CmBatt->WmiLibContext,
                                  DeviceObject,
                                  Irp,
                                  &disposition);

    }

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Processed\n"));

            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Not Completed.\n"));
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Forward.\n"));
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);
            break;
        }
    }

    //
    // Release Removal Lock
    //
    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }

    return status;
}


NTSTATUS
CmBattWmiRegistration(
    PCM_BATT CmBatt
)
/*++
Routine Description

    Registers with WMI as a data provider for this
    instance of the device

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    CmBatt->WmiLibContext.GuidCount = sizeof (CmBattWmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
    ASSERT (1 == CmBatt->WmiLibContext.GuidCount);
    CmBatt->WmiLibContext.GuidList = CmBattWmiGuidList;
    CmBatt->WmiLibContext.QueryWmiRegInfo = CmBattQueryWmiRegInfo;
    CmBatt->WmiLibContext.QueryWmiDataBlock = CmBattQueryWmiDataBlock;
    CmBatt->WmiLibContext.SetWmiDataBlock = CmBattSetWmiDataBlock;
    CmBatt->WmiLibContext.SetWmiDataItem = CmBattSetWmiDataItem;
    CmBatt->WmiLibContext.ExecuteWmiMethod = NULL;
    CmBatt->WmiLibContext.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //

    status = IoWMIRegistrationControl(CmBatt->Fdo,
                             WMIREG_ACTION_REGISTER
                             );

    return status;

}

NTSTATUS
CmBattWmiDeRegistration(
    PCM_BATT CmBatt
)
/*++
Routine Description

     Inform WMI to remove this DeviceObject from its
     list of providers. This function also
     decrements the reference count of the deviceobject.

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(CmBatt->Fdo,
                                 WMIREG_ACTION_DEREGISTER
                                 );

}

//
// WMI System Call back functions
//

NTSTATUS
CmBattSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PCM_BATT        CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;
    HANDLE          devInstRegKey;
    UNICODE_STRING  valueName;
    ULONG           tmp;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattSetWmiDataItem\n"));

    switch(GuidIndex) {

    case 0:
        if(DataItemId == 0) {
            if (CmBatt->WakeEnabled != *((PBOOLEAN)Buffer)) {
                CmBatt->WakeEnabled = *((PBOOLEAN)Buffer);

                //
                // Save setting in registry
                //

                if ((NT_SUCCESS(IoOpenDeviceRegistryKey (CmBatt->Pdo,
                                                         PLUGPLAY_REGKEY_DEVICE,
                                                         STANDARD_RIGHTS_ALL,
                                                         &devInstRegKey)))) {
                    RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
                    tmp = (ULONG) CmBatt->WakeEnabled;

                    ZwSetValueKey (devInstRegKey,
                                   &valueName,
                                   0,
                                   REG_DWORD,
                                   &tmp,
                                   sizeof(tmp));

                    ZwClose (devInstRegKey);
                }

                if (CmBatt->WakeEnabled) {
                    if (CmBatt->WakeSupportedState.SystemState == PowerSystemUnspecified) {
                        CmBatt->WakeEnabled = FALSE;
                        status = STATUS_UNSUCCESSFUL;
                    } else if (!CmBatt->WaitWakeIrp) {
                        status = PoRequestPowerIrp(
                            CmBatt->DeviceObject,
                            IRP_MN_WAIT_WAKE,
                            CmBatt->WakeSupportedState,
                            CmBattWaitWakeLoop,
                            NULL,
                            &(CmBatt->WaitWakeIrp)
                            );

                        CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: wait/Wake irp sent.\n"));
                    }

                } else {
                    if (CmBatt->WaitWakeIrp) {
                        status = IoCancelIrp(CmBatt->WaitWakeIrp);
                        CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: Canceled wait/Wake irp.\n"));
                    }
                }
            }
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_READ_ONLY;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CmBattSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PCM_BATT        CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;
    HANDLE          devInstRegKey;
    UNICODE_STRING  valueName;
    ULONG           tmp;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattSetWmiDataBlock\n"));

    switch(GuidIndex) {
    case 0:

        //
        // We will update only writable elements.
        //

        if (CmBatt->WakeEnabled != *((PBOOLEAN)Buffer)) {
            CmBatt->WakeEnabled = *((PBOOLEAN)Buffer);

            //
            // Save setting in registry
            //

            if ((NT_SUCCESS(IoOpenDeviceRegistryKey (CmBatt->Pdo,
                                                     PLUGPLAY_REGKEY_DEVICE,
                                                     STANDARD_RIGHTS_ALL,
                                                     &devInstRegKey)))) {
                RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
                tmp = (ULONG) CmBatt->WakeEnabled;

                ZwSetValueKey (devInstRegKey,
                               &valueName,
                               0,
                               REG_DWORD,
                               &tmp,
                               sizeof(tmp));

                ZwClose (devInstRegKey);
            }

            if (CmBatt->WakeEnabled) {
                if (CmBatt->WakeSupportedState.SystemState == PowerSystemUnspecified) {
                    CmBatt->WakeEnabled = FALSE;
                    status = STATUS_UNSUCCESSFUL;
                } else if (!CmBatt->WaitWakeIrp) {
                    status = PoRequestPowerIrp(
                        CmBatt->DeviceObject,
                        IRP_MN_WAIT_WAKE,
                        CmBatt->WakeSupportedState,
                        CmBattWaitWakeLoop,
                        NULL,
                        &(CmBatt->WaitWakeIrp)
                        );

                    CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: wait/Wake irp sent.\n"));
                }

            } else {
                if (CmBatt->WaitWakeIrp) {
                    status = IoCancelIrp(CmBatt->WaitWakeIrp);
                    CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: Canceled wait/Wake irp.\n"));
                }
            }
        }
        status = STATUS_SUCCESS;

        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
CmBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PCM_BATT    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS    status;
    ULONG       size = 0;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattQueryWmiDataBlock\n"));

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        status = BatteryClassQueryWmiDataBlock(
            CmBatt->Class,
            DeviceObject,
            Irp,
            GuidIndex,
            InstanceLengthArray,
            OutBufferSize,
            Buffer);

        if (status != STATUS_WMI_GUID_NOT_FOUND) {
            CmBattPrint ((CMBATT_TRACE), ("CmBattQueryWmiDataBlock: Handled by Battery Class.\n"));
            return status;
        }
    }

    CmBattPrint ((CMBATT_TRACE), ("CmBattQueryWmiDataBlock: Handling.\n"));

    switch (GuidIndex) {
    case 0:

        if (CmBatt->WakeSupportedState.SystemState != PowerSystemUnspecified) {
            size = sizeof (BOOLEAN);
            if (OutBufferSize < size ) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            (BOOLEAN) (* Buffer) = CmBatt->WakeEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CmBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PCM_BATT CmBatt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("CmBatt: Entered CmBattQueryWmiRegInfo\n"));


    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &GlobalRegistryPath;
    *Pdo = CmBatt->Pdo;
//    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    return STATUS_SUCCESS;
}

#if DEBUG

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE";
        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM";
        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION";
        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS";
        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION";
        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS";
        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD";
        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA";
        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE";
        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO";
        default:
            return "IRP_MN_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBatt.c

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"


#if DEBUG
#if DBG
    ULONG       CmBattDebug     = CMBATT_ERROR;
#else
    // Turn off all debug info by default for free builds.
    ULONG       CmBattDebug     = 0;
#endif //DBG
#endif //DEBUG

#ifndef _WIN32_WINNT
ULONG       CmBattPrevPowerSource = 1;
#endif //_WIN32_WINNT

UNICODE_STRING GlobalRegistryPath;

PVOID CmBattPowerCallBackRegistration;
PCALLBACK_OBJECT CmBattPowerCallBackObject;
KDPC CmBattWakeDpcObject;
KTIMER CmBattWakeDpcTimerObject;

LARGE_INTEGER    CmBattWakeDpcDelay = WAKE_DPC_DELAY;

//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
CmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CmBattIoctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
CmBattUnload(
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
CmBattGetBatteryStatus(
    PCM_BATT            CmBatt,
    IN ULONG            BatteryTag
    );

NTSTATUS
CmBattGetSetAlarm(
    IN PCM_BATT         CmBatt,
    IN OUT PULONG       AlarmPtr,
    IN UCHAR            OpType
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,CmBattQueryTag)
#pragma alloc_text(PAGE,CmBattQueryInformation)
#pragma alloc_text(PAGE,CmBattQueryStatus)
#pragma alloc_text(PAGE,CmBattSetStatusNotify)
#pragma alloc_text(PAGE,CmBattDisableStatusNotify)
#pragma alloc_text(PAGE,CmBattUnload)
#pragma alloc_text(PAGE,CmBattOpenClose)
#pragma alloc_text(PAGE,CmBattIoctl)
#pragma alloc_text(PAGE,CmBattGetBatteryStatus)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttributes;
    UNICODE_STRING      callBackName;


    //
    // Save the RegistryPath.
    //

    GlobalRegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    GlobalRegistryPath.Length = RegistryPath->Length;
    GlobalRegistryPath.Buffer = ExAllocatePoolWithTag (
                                       PagedPool,
                                       GlobalRegistryPath.MaximumLength,
                                       'MtaB');

    if (!GlobalRegistryPath.Buffer) {

        CmBattPrint ((CMBATT_ERROR),("CmBatt: Couldn't allocate pool for registry path."));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&GlobalRegistryPath, RegistryPath);

    CmBattPrint (CMBATT_TRACE, ("CmBatt DriverEntry - Obj (%08x) Path \"%ws\"\n",
                                 DriverObject, RegistryPath->Buffer));
    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverUnload                          = CmBattUnload;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = CmBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = CmBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = CmBattOpenClose;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = CmBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = CmBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = CmBattSystemControl;
    DriverObject->DriverExtension->AddDevice            = CmBattAddDevice;


    //
    // Register a callback that tells us when the system is in the
    // process of sleeping or waking.
    //
    RtlInitUnicodeString( &callBackName, L"\\Callback\\PowerState" );
    InitializeObjectAttributes(
        &objAttributes,
        &callBackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    status = ExCreateCallback(
        &CmBattPowerCallBackObject,
        &objAttributes,
        FALSE,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        CmBattPowerCallBackRegistration = ExRegisterCallback(
            CmBattPowerCallBackObject,
            (PCALLBACK_FUNCTION) CmBattPowerCallBack,
            DriverObject
            );
        if (CmBattPowerCallBackRegistration) {
            KeInitializeDpc (&CmBattWakeDpcObject,
                             (PKDEFERRED_ROUTINE) CmBattWakeDpc,
                             DriverObject);
            KeInitializeTimer (&CmBattWakeDpcTimerObject);
        } else {
            ObDereferenceObject (CmBattPowerCallBackObject);
            CmBattPrint (CMBATT_ERROR, ("CmBattRegisterPowerCallBack: ExRegisterCallback failed.\n"));
        }
    } else {
        CmBattPowerCallBackObject = NULL;
        CmBattPrint (CMBATT_ERROR, ("CmBattRegisterPowerCallBack: failed status=0x%08x\n", status));
    }

    return STATUS_SUCCESS;

}



VOID
CmBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{

    CmBattPrint (CMBATT_TRACE, ("CmBattUnload: \n"));

    if (CmBattPowerCallBackObject) {
        ExUnregisterCallback (CmBattPowerCallBackRegistration);
        ObDereferenceObject (CmBattPowerCallBackObject);
    }

    if (GlobalRegistryPath.Buffer) {
        ExFreePool (GlobalRegistryPath.Buffer);
    }

    if (DriverObject->DeviceObject != NULL) {
        CmBattPrint (CMBATT_ERROR, ("Unload called before all devices removed.\n"));
    }
}



NTSTATUS
CmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This is the routine called as a result of a Open or Close on the device

Arguments:


    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    STATUS_SUCCESS - no way to fail this puppy
    If Device has received a query remove, this will fail.
    STATUS_NO_SUCH_DEVICE

--*/
{
    PCM_BATT            CmBatt;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattOpenClose\n"));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality was
    // added to this routine, a remove lock might be neccesary.
    //

    status = STATUS_SUCCESS;  // Success by default.

    ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
    if (CmBatt->OpenCount == (ULONG) -1) {          // A query remove has come requested
        status = STATUS_NO_SUCH_DEVICE;
        CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Failed (UID = %x)(device being removed).\n", CmBatt->Info.Tag));
    } else {
        irpStack = IoGetCurrentIrpStackLocation(Irp);
        if (irpStack->MajorFunction ==  IRP_MJ_CREATE) {
            CmBatt->OpenCount++;
            CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Open (DeviceNumber = %x)(count = %x).\n",
                         CmBatt->DeviceNumber, CmBatt->OpenCount));
        } else if (irpStack->MajorFunction ==  IRP_MJ_CLOSE) {
            CmBatt->OpenCount--;
            CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Close (DeviceNumber = %x)(count = %x).\n",
                         CmBatt->DeviceNumber, CmBatt->OpenCount));
        }
    }
    ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

    //
    // Complete Irp.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;

}



NTSTATUS
CmBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
{
    NTSTATUS        Status = STATUS_NOT_SUPPORTED;
    PCM_BATT        CmBatt;


#if DIRECT_ACCESS

    PIO_STACK_LOCATION      IrpSp;

#endif //DIRECT_ACCESS

    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattIoctl\n"));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
            KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        Status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return Status;
    }

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        Status = BatteryClassIoctl (CmBatt->Class, Irp);

#if DIRECT_ACCESS
        if (Status == STATUS_NOT_SUPPORTED) {

            //
            // Is it a Direct Access IOCTL?
            //

            IrpSp = IoGetCurrentIrpStackLocation(Irp);

            CmBattPrint((CMBATT_BIOS),
                        ("CmBattIoctl: Received  Direct Access IOCTL %x\n",
                         IrpSp->Parameters.DeviceIoControl.IoControlCode));

            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_CMBATT_UID:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    Status = CmBattGetUniqueId (CmBatt->Pdo, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_STA:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    Status = CmBattGetStaData (CmBatt->Pdo, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_PSR:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    if (AcAdapterPdo != NULL) {
                        Status = CmBattGetPsrData (AcAdapterPdo, Irp->AssociatedIrp.SystemBuffer);
                    } else {
                        Status = STATUS_NO_SUCH_DEVICE;
                    }
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BTP:
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (ULONG)) {
                    Status = CmBattSetTripPpoint (CmBatt, *((PULONG) (Irp->AssociatedIrp.SystemBuffer)));
                    Irp->IoStatus.Information = 0;
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BIF:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (CM_BIF_BAT_INFO)) {
                    Status = CmBattGetBifData (CmBatt, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (CM_BIF_BAT_INFO);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BST:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (CM_BST_BAT_INFO)) {
                    Status = CmBattGetBstData (CmBatt, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (CM_BST_BAT_INFO);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;

            default:
                CmBattPrint((CMBATT_ERROR),
                            ("CmBattIoctl: Unknown IOCTL %x\n",
                             IrpSp->Parameters.DeviceIoControl.IoControlCode));

            }

            if (Status != STATUS_NOT_SUPPORTED) {

                //
                // We just handled this IOCTL.  Complete it.
                //

                Irp->IoStatus.Status = Status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
#endif //DIRECT_ACCESS
    }

    if (Status == STATUS_NOT_SUPPORTED) {

        //
        // Not for the battery.  Pass it down the stack.
        //

        IoSkipCurrentIrpStackLocation (Irp);
        Status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);

    }

    //
    // Release Removal Lock
    //
    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }

    return Status;
}



NTSTATUS
CmBattQueryTag (
    IN  PVOID       Context,
    OUT PULONG      TagPtr
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    TagPtr          - Pointer to return current tag

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS        Status;
    PCM_BATT        CmBatt = (PCM_BATT) Context;
    ULONG           BatteryStatus;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI),
                 ("CmBattQueryTag - Tag (%d), Battery %x, Device %d\n",
                    *TagPtr, CmBatt, CmBatt->DeviceNumber));

    //
    // Check if battery is still there
    //
    CmBatt->ReCheckSta = FALSE;
    Status = CmBattGetStaData (CmBatt->Pdo, &BatteryStatus);

    if (NT_SUCCESS (Status)) {
        if (BatteryStatus & STA_DEVICE_PRESENT) {

            //
            // If the tag isn't assigned, assign a new one
            //

            if (CmBatt->Info.Tag == BATTERY_TAG_INVALID) {

                //
                // See if there is a battery out there.
                //

                CmBatt->TagCount += 1;
                if (CmBatt->TagCount == BATTERY_TAG_INVALID) {
                     CmBatt->TagCount += 1;
                }

                CmBatt->Info.Tag = CmBatt->TagCount;

                RtlZeroMemory (&CmBatt->Alarm, sizeof(BAT_ALARM_INFO));
                CmBatt->Alarm.Setting = CM_ALARM_INVALID;
                CmBattPrint (CMBATT_TRACE, ("CmBattQueryTag - New Tag: (%d)\n", CmBatt->Info.Tag));
                InterlockedExchange (&CmBatt->CacheState, 0);
                CmBatt->DischargeTime = KeQueryInterruptTime();
            }

        } else {

            CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            Status =  STATUS_NO_SUCH_DEVICE;

        }
    }

    //
    // Done
    //

    CmBattPrint ((CMBATT_MINI),
                 ("CmBattQueryTag: Returning Tag: 0x%x, status 0x%x\n",
                    CmBatt->Info.Tag, Status));

    *TagPtr = CmBatt->Info.Tag;
    return Status;
}



NTSTATUS
CmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
/*++

Routine Description:

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Used only when Level==BatteryEstimatedTime
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCM_BATT            CmBatt = (PCM_BATT) Context;
    ULONG               ResultData;
    NTSTATUS            Status;
    PVOID               ReturnBuffer;
    ULONG               ReturnBufferLength;
    WCHAR               scratchBuffer[CM_MAX_STRING_LENGTH];
    WCHAR               buffer2[CM_MAX_STRING_LENGTH];
    UNICODE_STRING      tmpUnicodeString;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;

    BATTERY_REMAINING_SCALE     ScalePtr[2];


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI),
                 ("CmBattQueryInformation - Tag (%d) Device %d, Informationlevel %d\n",
                    BatteryTag, CmBatt->DeviceNumber, Level));

    //
    //  Be sure there's a battery out there
    //  This also checks BatteryTag
    //

    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ResultData = 0;
    ReturnBuffer = NULL;
    ReturnBufferLength = 0;
    Status = STATUS_SUCCESS;

    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            //
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            ReturnBuffer = (PVOID) &CmBatt->Info.ApiInfo;
            ReturnBufferLength = sizeof (CmBatt->Info.ApiInfo);
            break;

        case BatteryGranularityInformation:
            //
            //  Get the granularity from the static info structure
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            {
                ScalePtr[0].Granularity     = CmBatt->Info.ApiGranularity_1;
                ScalePtr[0].Capacity        = CmBatt->Info.ApiInfo.DefaultAlert1;
                ScalePtr[1].Granularity     = CmBatt->Info.ApiGranularity_2;
                ScalePtr[1].Capacity        = CmBatt->Info.ApiInfo.DesignedCapacity;

                ReturnBuffer        = ScalePtr;
                ReturnBufferLength  = 2 * sizeof (BATTERY_REMAINING_SCALE);
            }
            break;

        case BatteryTemperature:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryEstimatedTime:
            
            //
            // Return unknown time if battery has been discharging less than 15 seconds
            //
            if (KeQueryInterruptTime() > (CmBatt->DischargeTime + CM_ESTIMATED_TIME_DELAY)) {

                //
                // The BatteryEstimatedTime for the control method batteries is defined
                // by the following formula:
                //
                // EstimatedTime [min] = RemainingCapacity [mAh|mWh] * 60 [min/hr] * 60 [sec/min]
                //                     ----------------------------------
                //                     PresentRate [mA|mW]
                //

                //
                // Rerun _BST since we don't have a timeout on this data.
                // Also Calculate API status values from CM values
                //

                CmBattGetBatteryStatus (CmBatt, CmBatt->Info.Tag);

                //
                // If AtRate is zero, we need to use the present rate
                //

                if (AtRate == 0) {
                    AtRate = CmBatt->Info.ApiStatus.Rate;
                }

                if (AtRate >= 0) {
                    AtRate = BATTERY_UNKNOWN_RATE;
                }
                if ((AtRate != BATTERY_UNKNOWN_RATE) &&
                    (CmBatt->Info.ApiStatus.Capacity != BATTERY_UNKNOWN_CAPACITY)) {

                    // Calculate estimated time.
#if DEBUG
                    // Make sure we don't overflow...
                    if (CmBatt->Info.ApiStatus.Capacity > (0xffffffff/3600)) {
                        CmBattPrint (CMBATT_ERROR_ONLY, ("CmBattQueryInformation: Data Overflow in calculating Remaining Capacity.\n"));
                    }
#endif //DEBUG
                    ResultData = (ULONG) (CmBatt->Info.ApiStatus.Capacity * 3600) / (-AtRate);

                } else {
                    //
                    // We don't know have enough information to calculate the value.
                    // Return BATTERY_UNKNONW_TIME.
                    //
                    // If this battery is incapable of returning estimated time, return with
                    // STATUS_INVALID_DEVICE_REQUEST
                    //

#if DEBUG
                    if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING) {
                        CmBattPrint (CMBATT_WARN,
                            ("CmBattQueryInformation: Can't calculate EstimatedTime.\n"));
                    }
#endif //DEBUG

                    if (CmBatt->Info.ApiStatus.Rate == BATTERY_UNKNOWN_RATE &&
                        (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING)) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        CmBattPrint (CMBATT_WARN,
                                    ("----------------------   PresentRate = BATTERY_UNKNOWN_RATE\n"));
                    }
                    if (CmBatt->Info.ApiStatus.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        CmBattPrint (CMBATT_WARN,
                                    ("----------------------   RemainingCapacity = BATTERY_UNKNOWN_CAPACITY\n"));
                    }

                    ResultData = BATTERY_UNKNOWN_TIME;
                }
            } else { // if (KeQueryInterruptTime() > CmBatt->DischargeTime + CM_ESTIMATED_TIME_DELAY)
                
                //
                // Return unknown time if battery has been discharging less than 15 seconds
                //
                ResultData = BATTERY_UNKNOWN_TIME;
            }

            ReturnBuffer        = &ResultData;
            ReturnBufferLength  = sizeof(ResultData);
            break;

        case BatteryDeviceName:
            //
            // Model Number must be returned as a wide string
            //
            unicodeString.Buffer        = scratchBuffer;
            unicodeString.MaximumLength = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.ModelNum);
            Status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        case BatteryManufactureDate:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryManufactureName:
            //
            // Oem Info must be returned as wide string
            //
            unicodeString.Buffer        = scratchBuffer;
            unicodeString.MaximumLength = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.OEMInfo);
            Status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        case BatteryUniqueID:
            //
            //  Concatenate the serial #, OEM info, and Model #
            //

            unicodeString.Buffer            = scratchBuffer;
            unicodeString.MaximumLength     = CM_MAX_STRING_LENGTH;

            tmpUnicodeString.Buffer         = buffer2;
            tmpUnicodeString.MaximumLength  = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.SerialNum);
            RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            if (CmBatt->Info.OEMInfo[0]) {
                RtlInitAnsiString (&ansiString, CmBatt->Info.OEMInfo);
                RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
            }

            RtlInitAnsiString (&ansiString, CmBatt->Info.ModelNum);
            RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = ReturnBufferLength;
    if (BufferLength < ReturnBufferLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(Status) && ReturnBuffer) {
        RtlCopyMemory (Buffer, ReturnBuffer, ReturnBufferLength);   // Copy what's needed
    }
    return Status;
}



NTSTATUS
CmBattQueryStatus (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCM_BATT    CmBatt = (PCM_BATT) Context;
    NTSTATUS    Status;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattQueryStatus - Tag (%d) Device %x\n",
                    BatteryTag, CmBatt->DeviceNumber));


    Status = CmBattGetBatteryStatus (CmBatt, BatteryTag);

    if (NT_SUCCESS(Status)) {
        RtlCopyMemory (BatteryStatus, &CmBatt->Info.ApiStatus, sizeof(BATTERY_STATUS));
    }
    CmBattPrint ((CMBATT_MINI), ("CmBattQueryStatus: Returning [%#08lx][%#08lx][%#08lx][%#08lx]\n",
                    BatteryStatus->PowerState, BatteryStatus->Capacity, BatteryStatus->Voltage, BatteryStatus->Rate));

    return Status;
}



NTSTATUS
CmBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY Notify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PCM_BATT    CmBatt;
    NTSTATUS    Status;
    ULONG       Target;
    LONG        ActualAlarm;   // Value after adjusting for limit conditions.
    CM_BST_BAT_INFO bstData;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattSetStatusNotify: Tag (%d) Target(0x%x)\n",
            BatteryTag, Notify->LowCapacity));

    Status = STATUS_SUCCESS;
    CmBatt = (PCM_BATT) Context;

    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If _BTP doesn't exist, don't call it again.
    //

    if (!CmBatt->Info.BtpExists) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if ((Notify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (Notify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Failing request because of BATTERY_UNKNOWN_CAPACITY.\n"));
        return STATUS_NOT_SUPPORTED;
    }

    if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
        Target = Notify->HighCapacity;
    } else if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING) {
        Target = Notify->LowCapacity;
    } else {
        // No trip point needs to be set, the battery will trip as soon as it starts
        // charging or discharging.
        //return STATUS_SUCCESS;
        // but it doesn't hurt to set the trip point just in case the battery
        // system screws up and doesn't send the notification when the status changed.
        Target = Notify->LowCapacity;
    }

    ActualAlarm = Target;

    //
    // If the battery operates on mA we need to convert the trip point from mW
    // to mA.  The formula for doing this is:
    //
    // mA = mW / V      or     mA = (mW / mV) * 1000
    //

    if (CmBatt->Info.StaticData.PowerUnit & CM_BIF_UNITS_AMPS) {
        if ((CmBatt->Info.StaticData.DesignVoltage == CM_UNKNOWN_VALUE) ||
            (CmBatt->Info.StaticData.DesignVoltage == 0)) {

            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("CmBattSetStatusNotify: Can't calculate BTP, DesignVoltage = 0x%08x\n",
                         CmBatt->Info.StaticData.DesignVoltage));
            return STATUS_NOT_SUPPORTED;
        }
            
        //
        // Calculate optimized Ah target
        //
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {

            //
            // (ActualAlarm * 1000 + 500) / DesignVoltage + 1 will generate
            // the correct battery trip point, except in cases when 
            // (ActualAlarm * 1000)+ 500) is evenly  divisible by the 
            // DesignVoltage.  In that case, it will be 1 mAh higher than
            // it should be.
            //
            // This is in the form of a single expression rather than an 
            // "if" statement to encourage the compiler to use the remainder
            // from the original div operation rather than performing div 
            // twice
            //

            ActualAlarm = (ActualAlarm * 1000 + 500) / CmBatt->Info.StaticData.DesignVoltage + 
                ( ((ActualAlarm * 1000 + 500) % CmBatt->Info.StaticData.DesignVoltage == 0)? 0 : 1 );

        } else {

            //
            // (ActualAlarm * 1000 - 500) / DesignVoltage will generate
            // the correct battery trip point, except in cases when 
            // (ActualAlarm * 1000)+ 500) is evenly  divisible by the 
            // DesignVoltage.  In that case, it will be 1 mAh higher than
            // it should be
            //

            ActualAlarm = (ActualAlarm * 1000 - 500) / CmBatt->Info.StaticData.DesignVoltage - 
                ( ((ActualAlarm * 1000 + 500) % CmBatt->Info.StaticData.DesignVoltage == 0)? 1 : 0);

        }

    } else {
        // Increment or decrement the alarm value by 1 since the input to this
        // function is < or >, but _BTP is <= or >=
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
            ActualAlarm++;
        } else {
            if (ActualAlarm > 0) {
                ActualAlarm--;
            }
        }
    }

    if (ActualAlarm == CmBatt->Alarm.Setting) {
        //
        // Don't need to reset the alarm to the same value.
        //
    
        CmBattPrint(CMBATT_LOW,
                ("CmBattSetStatusNotify: Keeping original setting: %X\n",
                CmBatt->Alarm.Setting
                ));
        
        return STATUS_SUCCESS;
    }
    
    //
    // Save current setting, so we won't waste time setting it twice.
    //
    CmBatt->Alarm.Setting = ActualAlarm;

    //
    // Set the alarm
    //
    Status = CmBattSetTripPpoint (CmBatt, ActualAlarm);

    if ((ActualAlarm == 0) && (Target != 0)) {
        // If the driver really wanted to be notified when the capacity
        // reached 0, return STATUS_NOT_SUPPORTED because seting _BTP to zero
        // disables notification.  The battery class will perform polling since
        // STATUS_NOT_SUPPORTED was returned.

        Status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (Status)) {
        //
        //  Something failed in the Trip point call, get out
        //
        CmBattPrint (CMBATT_ERROR, ("CmBattSetStatusNotify: SetTripPoint failed - %x\n",
                                        Status));
        CmBatt->Alarm.Setting = CM_ALARM_INVALID;
        return Status;
    }

    // Make sure that the trip point hasn't been passed already.
    Status = CmBattGetBstData (CmBatt, &bstData);

    if (!NT_SUCCESS (Status)) {
        //
        //  Something failed in the Trip point call, get out
        //
        CmBattPrint (CMBATT_ERROR, ("CmBattSetStatusNotify: GetBstData - %x\n",
                                        Status));
    } else {
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
            if (bstData.RemainingCapacity >= (ULONG)ActualAlarm) {
                CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Trip point already crossed (1): TP = %08x, remaining capacity = %08x\n",
                                           ActualAlarm, bstData.RemainingCapacity));
                CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
            }
        } else {
            if ((bstData.RemainingCapacity <= (ULONG)ActualAlarm) && (Target != 0)) {
                CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Trip point already crossed (1): TP = %08x, remaining capacity = %08x\n",
                                           ActualAlarm, bstData.RemainingCapacity));
                CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
            }
        }

    }

    CmBattPrint(CMBATT_LOW,
            ("CmBattSetStatusNotify: Want %X CurrentCap %X\n",
            Target,
            CmBatt->Info.ApiStatus.Capacity
            ));

    CmBattPrint ((CMBATT_MINI),
                 ("CmBattSetStatusNotify: Set to: [%#08lx][%#08lx][%#08lx] Status %x\n",
                 Notify->PowerState, Notify->LowCapacity, Notify->HighCapacity));

    return Status;
}



NTSTATUS
CmBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to CmBattSetStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    PCM_BATT    CmBatt;
    NTSTATUS    Status;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattDisableStatusNotify\n"));

    CmBatt = (PCM_BATT) Context;

    //
    // If _BTP doesn't exist, don't call it again.
    //

    if (!CmBatt->Info.BtpExists) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (CmBatt->Alarm.Setting != CM_BATT_CLEAR_TRIP_POINT) {
        
        CmBatt->Alarm.Setting = CM_BATT_CLEAR_TRIP_POINT;
        
        //
        // Clear the trip point.
        //

        Status = CmBattSetTripPpoint (CmBatt, CM_BATT_CLEAR_TRIP_POINT);

        if (!NT_SUCCESS (Status)) {
            CmBattPrint ((CMBATT_MINI),
                         ("CmBattDisableStatusNotify: SetTripPoint failed - %x\n",
                                            Status));
            CmBatt->Alarm.Setting = CM_ALARM_INVALID;
        }
    } else {
        //
        // Don't need to disable alarm is it's already been disabled.
        //

        Status = STATUS_SUCCESS;
    }


    return Status;
}



NTSTATUS
CmBattGetBatteryStatus (
    PCM_BATT        CmBatt,
    IN ULONG        BatteryTag
    )
/*++

Routine Description:

    Called to setup the status data required by the IOCTL API defined for
    the battery class.  This is the data defined in the BATTERY_STATUS
    structure.

Arguments:

    CmBatt          - The extension for this device.

Return Value:

    Status

--*/

{
    NTSTATUS            Status = STATUS_SUCCESS;
    PBATTERY_STATUS     ApiStatus;
    PCM_BST_BAT_INFO    CmBattStatus;
    ULONG               AcStatus = 0;
    ULONG               LastPowerState;


    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattGetBatteryStatus - CmBatt (%08x) Tag (%d)\n",
                                CmBatt, BatteryTag));


    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (CmBatt->Sleeping) {
        //
        // Return cached data, and ensure that this gets requeried when we are fully awake.
        //
        CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
        return Status;
    }

    CmBattStatus = &CmBatt->Info.Status;
    Status = CmBattGetBstData(CmBatt, CmBattStatus);
    if (!NT_SUCCESS(Status)) {
        InterlockedExchange (&CmBatt->CacheState, 0);
        return Status;
    }

    ApiStatus = &CmBatt->Info.ApiStatus;
    LastPowerState = ApiStatus->PowerState;
    RtlZeroMemory (ApiStatus, sizeof(BATTERY_STATUS));

    //
    // Decode the state bits
    //
#if DEBUG
    if (((CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) &&
         (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING)   )) {
        CmBattPrint ((CMBATT_ERROR),
                       ("************************ ACPI BIOS BUG ********************\n"
                        "* CmBattGetBatteryStatus: Invalid state: _BST method returned 0x%08x for Battery State.\n"
                        "* One battery cannot be charging and discharging at the same time.\n",
                        CmBattStatus->BatteryState));
    }
//    ASSERT(!((CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) &&
//             (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING)   ));

#endif

    if (CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) {
        ApiStatus->PowerState |= BATTERY_DISCHARGING;
        if (!(LastPowerState & BATTERY_DISCHARGING)) {
            //
            // Keep track of when battery started discharging.
            //
            CmBatt->DischargeTime = KeQueryInterruptTime();
        }
    } else if (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING) {
        ApiStatus->PowerState |= (BATTERY_CHARGING | BATTERY_POWER_ON_LINE);
    }

    if (CmBattStatus->BatteryState & CM_BST_STATE_CRITICAL)
        ApiStatus->PowerState |= BATTERY_CRITICAL;

    ApiStatus->Voltage = CmBattStatus->PresentVoltage;

    //
    // Run the _PSR method on the AC adapter to get the current power status.
    // Otherwise, we don't know if it is connected, unless the battery reports charging.
    // This isn't enough information for the upper software to work properly, so
    // just find out for sure.
    //
    if (AcAdapterPdo != NULL) {

        CmBattGetPsrData (AcAdapterPdo, &AcStatus);

    } else {
        // If the AcAdapterPdo is NULL, then we need to assume the AC status from
        // the battery charging status.
        if (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING) {
            AcStatus = 1;
        } else {
            AcStatus = 0;
        }
    }

    if (AcStatus == 0x01) {
        ApiStatus->PowerState |= BATTERY_POWER_ON_LINE;

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: AC adapter is connected\n"));
    } else {

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: AC adapter is NOT connected\n"));
    }

// The following is an awful hack put into the win98 version that really
// shouldn't be there.  The purpose of this is reduce the delay in notification
// when AC status changes, but this doesn't help the problem of delays when
// other events such as battery insertion or removal happen.  In addition it
// violates the priciple of WDM drivers being binary compatible, and this fix
// does nothing for any other battery driver that may later be added by a third
// party.  This should be handled by the OS maintianing an outstanding long term
// status or tag request to the composite battery at all times.  That would
// involve starting the Irps then recycleing it in the completion routine doing
// what this hack does if there was a change to report.

#ifndef _WIN32_WINNT

    // JASONCL:  check for a power source change and notify vpowerd if there has been one.

    if ( ((AcStatus & 0x01) && (CmBattPrevPowerSource == 0)) ||
            (!(AcStatus & 0x01) && (CmBattPrevPowerSource == 1)) )   {

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: Detected Power Source Change\n"));

        CmBattPrevPowerSource = AcStatus & 0x01;

        CmBattNotifyVPOWERDOfPowerChange (1);

    }

#endif

    //
    //  Decode the power/current
    //
    if (CmBatt->Info.StaticData.PowerUnit == CM_BIF_UNITS_AMPS) {
        //
        //  This battery expresses power in terms of amps.  The system expects
        //  it to be Watts, so we have to do a conversion.  The Conversion is:
        //
        //  mW = mA * Volts     or     mW = mA * mV / 1000
        //

        // Using DesignVoltage for conversions since presentvoltage
        // may vary over time, giving inconsistent results.

        if ((CmBatt->Info.StaticData.DesignVoltage != CM_UNKNOWN_VALUE) &&
            (CmBatt->Info.StaticData.DesignVoltage != 0)) {
            if (CmBattStatus->RemainingCapacity != CM_UNKNOWN_VALUE) {

                ApiStatus->Capacity = (CmBattStatus->RemainingCapacity *
                                       CmBatt->Info.StaticData.DesignVoltage +
                                       500) / 1000;
            } else {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Can't calculate RemainingCapacity \n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   RemainingCapacity = CM_UNKNOWN_VALUE\n"));

                ApiStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;
            }

            if (CmBattStatus->PresentRate != CM_UNKNOWN_VALUE) {

                if (CmBattStatus->PresentRate > ((MAXULONG - 500)/ CmBatt->Info.StaticData.DesignVoltage)) {                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("CmBattGetBatteryStatus - Can't calculate Rate \n"));
                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("----------------------   Overflow: PresentRate = 0x%08x\n", CmBattStatus->PresentRate));

                    ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
                }

                ApiStatus->Rate = (CmBattStatus->PresentRate      *
                                     CmBatt->Info.StaticData.DesignVoltage +
                                     500) / 1000;
            } else {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Can't calculate Rate \n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   Present Rate = CM_UNKNOWN_VALUE\n"));

                ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
            }

        } else {
            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("CmBattGetBatteryStatus - Can't calculate RemainingCapacity and Rate \n"));
            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("----------------------   DesignVoltage = 0x%08x\n", 
                         CmBatt->Info.StaticData.DesignVoltage));
            ApiStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;

            ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
        }

    } else {
        //
        //  This battery expresses power in terms of Watts
        //

        ApiStatus->Capacity = CmBattStatus->RemainingCapacity;
        ApiStatus->Rate  = CmBattStatus->PresentRate;
        if (CmBattStatus->PresentRate > CM_MAX_VALUE) {
            ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
            if (CmBattStatus->PresentRate != CM_UNKNOWN_VALUE) {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Rate is greater than CM_MAX_VALUE\n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   PresentRate = 0x%08x\n", CmBattStatus->PresentRate));
            }
        }
    }

    //
    // If the rate is "unkown" set it to zero
    //
    if (ApiStatus->Rate == BATTERY_UNKNOWN_RATE) {

        //
        // This is only allowed when -c-h-a-r-g-i-n-g- not discharging.
        // Batteries are allowed to return UNKNOWN_RATE when AC is online
        // but they aren't being charged.
        //
        if (CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) {

            CmBattPrint(
                CMBATT_ERROR,
                ("CmBattGetBatteryStatus: battery rate is unkown when battery "
                 "is not charging!\n")
                );

        }

    } else {
        //
        // The OS expects the PresentRate to be a signed value, with positive values
        // indicating a charge and negative values indicating a discharge.  Since the
        // control methods only return unsigned values we need to do the conversion here.
        //

        if (ApiStatus->PowerState & BATTERY_DISCHARGING) {
            ApiStatus->Rate = 0 - ApiStatus->Rate;

        } else if (!(ApiStatus->PowerState & BATTERY_CHARGING) && (ApiStatus->Rate != 0)) {
            CmBattPrint ((CMBATT_BIOS), ("CmBattGetBatteryStatus: battery is not charging or discharging, but rate = %x\n", ApiStatus->Rate));
            ApiStatus->Rate = 0;
        } else {
            // Rate already equals 0.  Battery is not Charging or discharging.
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmBattVerifyStaticInfo (
    IN PCM_BATT         CmBatt,
    IN ULONG            BatteryTag
    )
/*++

Routine Description:

    In order to detect battery changes, we'll check to see if any part of the data
    returned by the cm is different from what we had read in the past.

Arguments:

    CmBatt          - Battery to read
    BatteryTag      - Tag of battery as expected by the caller

Return Value:

    Returns a boolean to indicate to the caller that IO was performed.
    This allows the caller to iterate on changes it may be making until
    the battery state is correct.

--*/
{
    NTSTATUS                Status;
    CM_BIF_BAT_INFO         NewInfo;
    ULONG                   StaResult;
    PBATTERY_INFORMATION    ApiData = &CmBatt->Info.ApiInfo;
    PCM_BIF_BAT_INFO        BIFData = &CmBatt->Info.StaticData;

    PAGED_CODE();


    CmBattPrint (CMBATT_TRACE, ("CmBattVerifyStaticInfo - CmBatt (%08x) Tag (%d) Device %d\n",
                                CmBatt, BatteryTag, CmBatt->DeviceNumber));

    Status = STATUS_SUCCESS;
    if ((CmBatt->Info.Tag == BATTERY_TAG_INVALID) || (BatteryTag != CmBatt->Info.Tag)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((CmBatt->CacheState == 2) && (!CmBatt->ReCheckSta)) {
        return Status;
    }

    if (CmBatt->Sleeping) {
        //
        // Return cached data, and ensure that this gets requeried when we are fully awake.
        //
        CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
        return Status;
    }

    // Check to make sure that the battery does exist
    // before continuing
    if (CmBatt->ReCheckSta) {
        CmBatt->ReCheckSta = FALSE;
        Status = CmBattGetStaData (CmBatt->Pdo, &StaResult);
        if (NT_SUCCESS (Status)) {
            if (!(StaResult & STA_DEVICE_PRESENT)) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                Status = STATUS_NO_SUCH_DEVICE;
                return Status;
            }
        }
    }

    //
    // The first time through the loop, CacheState will be 1
    // If a notification occurs, this will be reset to 0, and the loop will run again.
    // If no notification occurs, it will increment to 2, the "Valid" value.
    //

    while (NT_SUCCESS(Status)  &&  (InterlockedIncrement (&CmBatt->CacheState) == 1)) {

        //
        // Go get fresh data
        // Issue the Control method
        //

        if (CmBatt->ReCheckSta) {
            CmBatt->ReCheckSta = FALSE;
            Status = CmBattGetStaData (CmBatt->Pdo, &StaResult);

            if (NT_SUCCESS (Status)) {
                if (!(StaResult & STA_DEVICE_PRESENT)) {
                    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                    Status = STATUS_NO_SUCH_DEVICE;
                }
            }
        }

        if (NT_SUCCESS (Status)) {
            Status = CmBattGetBifData(CmBatt, &NewInfo);
        }

        if (NT_SUCCESS (Status)) {

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("CmBattGetStaticInfo: _BIF Returned: PowerUnit=%x DesignCapacity=%x LastFull=%x\n",
                            NewInfo.PowerUnit, NewInfo.DesignCapacity, NewInfo.LastFullChargeCapacity ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- Technology=%x Voltage=%x DesignWarning=%x\n",
                            NewInfo.BatteryTechnology, NewInfo.DesignVoltage,
                            NewInfo.DesignCapacityOfWarning ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- DesignLow=%x Gran1=%x Gran2=%x\n",
                            NewInfo.DesignCapacityOfLow, NewInfo.BatteryCapacityGran_1,
                            NewInfo.BatteryCapacityGran_2 ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- ModelNumber=%s \n",
                            NewInfo.ModelNumber));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- SerialNumber=%s \n",
                            NewInfo.SerialNumber));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- BatteryType=%s \n",
                            NewInfo.BatteryType));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- OEMInformation=%s \n",
                            NewInfo.OEMInformation));

            //
            // Update static area with the new data
            //

            if ((CmBatt->Info.Tag == CmBatt->Info.StaticDataTag) && 
                (CmBatt->Info.StaticDataTag != BATTERY_TAG_INVALID)) {
                if (RtlCompareMemory (&NewInfo, BIFData, sizeof(NewInfo)) == sizeof(NewInfo)) {
                    //
                    // Nothing has changed.  Don't need to update anything.
                    //
                    continue;
                } else {
                    //
                    // Something has changed.  The tag should have been invalidated.
                    //
                    CmBattPrint ((CMBATT_BIOS | CMBATT_ERROR),
                                  ("CmBattVerifyStaticInfo: Static data changed without recieving notify 0x81.\n"));

                    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                    Status = STATUS_NO_SUCH_DEVICE;
                    CmBatt->Info.StaticDataTag = BATTERY_TAG_INVALID;

                }

            }
            CmBatt->Info.StaticDataTag = CmBatt->Info.Tag;

            RtlCopyMemory (BIFData, &NewInfo, sizeof(CM_BIF_BAT_INFO));

            RtlZeroMemory (ApiData, sizeof(BATTERY_INFORMATION));
            ApiData->Capabilities           = BATTERY_SYSTEM_BATTERY;
            ApiData->Technology             = (UCHAR) BIFData->BatteryTechnology;

            //
            // Use first four chars of BatteryType as Chemistry string
            //
            ApiData->Chemistry[0]           = BIFData->BatteryType[0];
            ApiData->Chemistry[1]           = BIFData->BatteryType[1];
            ApiData->Chemistry[2]           = BIFData->BatteryType[2];
            ApiData->Chemistry[3]           = BIFData->BatteryType[3];
            
            ApiData->CriticalBias           = 0;
            ApiData->CycleCount             = 0;

            if (BIFData->PowerUnit & CM_BIF_UNITS_AMPS) {

                //
                // This battery reports in mA we need to convert all the capacities to
                // mW because this is what the OS expects.  The algorithm for doing this
                // is:
                //
                //  mW = mA * Volts     or     mW = mA * mV / 1000
                //

                if (BIFData->DesignVoltage != CM_UNKNOWN_VALUE) {

                    //
                    // Convert the DesignCapacity
                    //

                    if (BIFData->DesignCapacity != CM_UNKNOWN_VALUE) {
                        ApiData->DesignedCapacity = (BIFData->DesignCapacity *
                                                     BIFData->DesignVoltage +
                                                     500) / 
                                                    1000;
                    } else {
                        ApiData->DesignedCapacity = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacity \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacity = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the LastFullChargeCapacity
                    //

                    if (BIFData->LastFullChargeCapacity != CM_UNKNOWN_VALUE) {
                        ApiData->FullChargedCapacity = (BIFData->LastFullChargeCapacity *
                                                        BIFData->DesignVoltage +
                                                        500) /
                                                       1000;
                    } else {
                        ApiData->FullChargedCapacity = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate LastFullChargeCapacity \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  LastFullChargeCapacity = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the DesignCapacityOfWarning
                    //

                    if (BIFData->DesignCapacityOfWarning != CM_UNKNOWN_VALUE) {
                        ApiData->DefaultAlert2 = (BIFData->DesignCapacityOfWarning *
                                                  BIFData->DesignVoltage +
                                                  500) /
                                                 1000;
                    } else {
                        ApiData->DefaultAlert2 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacityOfWarning \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacityOfWarning = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the DesignCapacityOfLow
                    //

                    if (BIFData->DesignCapacityOfLow != CM_UNKNOWN_VALUE) {
                        ApiData->DefaultAlert1 = (BIFData->DesignCapacityOfLow *
                                                  BIFData->DesignVoltage +
                                                  500) /
                                                 1000;
                    } else {
                        ApiData->DefaultAlert1 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacityOfLow \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacityOfLow = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the BatteryCapacityGran_1
                    //

                    if (BIFData->BatteryCapacityGran_1 != CM_UNKNOWN_VALUE) {
                        CmBatt->Info.ApiGranularity_1 = (BIFData->BatteryCapacityGran_1 *
                                                         BIFData->DesignVoltage +
                                                         500) /
                                                        1000;
                    } else {
                        CmBatt->Info.ApiGranularity_1 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate BatteryCapacityGran_1 \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  BatteryCapacityGran_1 = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the BatteryCapacityGran_2
                    //

                    if (BIFData->BatteryCapacityGran_2 != CM_UNKNOWN_VALUE) {
                        CmBatt->Info.ApiGranularity_2 = (BIFData->BatteryCapacityGran_2 *
                                                         BIFData->DesignVoltage +
                                                         500) /
                                                        1000;
                    } else {
                        CmBatt->Info.ApiGranularity_2 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate BatteryCapacityGran_2 \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  BatteryCapacityGran_2 = CM_UNKNOWN_VALUE\n"));
                    }
                } else {

                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("CmBattGetStaticInfo - Can't calculate Capacities \n"));
                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("--------------------  DesignVoltage = CM_UNKNOWN_VALUE\n"));

                    ApiData->DesignedCapacity       = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->FullChargedCapacity    = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->DefaultAlert1          = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->DefaultAlert2          = BATTERY_UNKNOWN_CAPACITY;
                    CmBatt->Info.ApiGranularity_1   = BATTERY_UNKNOWN_CAPACITY;
                    CmBatt->Info.ApiGranularity_2   = BATTERY_UNKNOWN_CAPACITY;
                }
            } else {
                ApiData->DesignedCapacity       = BIFData->DesignCapacity;
                ApiData->FullChargedCapacity    = BIFData->LastFullChargeCapacity;
                ApiData->DefaultAlert1          = BIFData->DesignCapacityOfLow;
                ApiData->DefaultAlert2          = BIFData->DesignCapacityOfWarning;
                CmBatt->Info.ApiGranularity_1   = BIFData->BatteryCapacityGran_1;
                CmBatt->Info.ApiGranularity_2   = BIFData->BatteryCapacityGran_2;

            }

            CmBatt->Info.ModelNum       = (PUCHAR) &BIFData->ModelNumber;
            CmBatt->Info.ModelNumLen    = (ULONG) strlen (CmBatt->Info.ModelNum);

            CmBatt->Info.SerialNum      = (PUCHAR) &BIFData->SerialNumber;
            CmBatt->Info.SerialNumLen   = (ULONG) strlen (CmBatt->Info.SerialNum);

            CmBatt->Info.OEMInfo        = (PUCHAR) &BIFData->OEMInformation;
            CmBatt->Info.OEMInfoLen     = (ULONG) strlen (CmBatt->Info.OEMInfo);

        }

    }

    if ((CmBatt->Info.Tag) == BATTERY_TAG_INVALID || (BatteryTag != CmBatt->Info.Tag)) {
        // If the tag has been invalidated since we started, fail the request.
        Status = STATUS_NO_SUCH_DEVICE;
    }

    if (!NT_SUCCESS (Status)) {
        // If somthing failed, make sure the cache is marked as invalid.
        InterlockedExchange (&CmBatt->CacheState, 0);
    }

    CmBattPrint (CMBATT_TRACE ,("CmBattGetStaticInfo: Exit\n"));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\battc\app\compbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <tchar.h>
#include <wchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <initguid.h>
#include <devguid.h>

#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <batclass.h>

#include <setupapi.h>

//
// Misc constants
//
#define RANGE                           1
#define MAX_NUMBER_OF_BATTERIES         8
#define MAX_DEVICE_NAME_LENGTH          100

//
// Battery Device Names
//
PVOID COMPOSITE_NAME    = _T("\\Device\\CompositeBattery");

//
// Globals
//
BOOLEAN                 LongTerm = FALSE;

#pragma pack(1)
typedef struct          _ID_MAP {
    UCHAR                   LocalId;
    UCHAR                   ActualId;
} ID_MAP, *PID_MAP;
#pragma pack()


#pragma pack(1)
typedef struct _MFG_DATE {

    UCHAR               Day;            // 1-31
    UCHAR               Month;          // 1-12
    USHORT          Year;               // 1996 - ?
} MFG_DATE, *PMFG_DATE;
#pragma pack()




/*******************************************************************************
*
*  GetBatteryDriverNames
*
*  DESCRIPTION: Finds all battery class devices
*
*  PARAMETERS:
*      DriverNames - pointer to an array of UNICODE_STRING structures to fill in
*      MaxBatteries - number of elements in DriverNames array
*
*  RETURN VALUE: The number of batteries found
*                Will always find the Composite battery whether it exists or not
*
*******************************************************************************/

UCHAR GetBatteryDriverNames(UNICODE_STRING * DriverNames, UCHAR MaxBatteries)
{
    UCHAR                               driverCount, index;
    DWORD                               reqSize;
    HDEVINFO                            devInfo;
    SP_INTERFACE_DEVICE_DATA            interfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    funcClassDevData;

    if ((MaxBatteries == 0) || (DriverNames == NULL)) {
        return 0;
    }

    driverCount = 0;

    // Hard code the first battery to be the composite battery.

    RtlInitUnicodeString (&DriverNames[driverCount], COMPOSITE_NAME);
    driverCount++;

    // Use the SETUPAPI.DLL interface to get the
    // possible battery driver names.
    devInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);

    if (devInfo != INVALID_HANDLE_VALUE) {
        interfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

        index = 0;
        while (driverCount < MaxBatteries) {
            if (SetupDiEnumInterfaceDevice(devInfo,
                                           0,
                                           (LPGUID)&GUID_DEVICE_BATTERY,
                                           index,
                                           &interfaceDevData)) {

                // Get the required size of the function class device data.
                SetupDiGetInterfaceDeviceDetail(devInfo,
                                                &interfaceDevData,
                                                NULL,
                                                0,
                                                &reqSize,
                                                NULL);

                funcClassDevData = malloc(reqSize);
                if (funcClassDevData != NULL) {
                    funcClassDevData->cbSize =
                        sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                    if (SetupDiGetInterfaceDeviceDetail(devInfo,
                                                        &interfaceDevData,
                                                        funcClassDevData,
                                                        reqSize,
                                                        &reqSize,
                                                        NULL)) {

                        reqSize = (lstrlen(funcClassDevData->DevicePath) + 1)
                                    * sizeof(TCHAR);

                            RtlInitUnicodeString(
                                &DriverNames[driverCount],
                                funcClassDevData->DevicePath
                            );
                            driverCount++;
                    }
                    else {
                        printf("SetupDiGetInterfaceDeviceDetail, failed: %d", GetLastError());
                    }

                    LocalFree(funcClassDevData);
                }
            } else {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                    break;
                }
                else {
                    printf ("SetupDiEnumInterfaceDevice, failed: %d", GetLastError());
                }
            }
            index++;
        }
        SetupDiDestroyDeviceInfoList(devInfo);
    }
    else {
        printf("SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d", GetLastError());
    }
    return driverCount;
}


HANDLE
OpenBattery (PUNICODE_STRING BatteryName)
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   ObjA;
    IO_STATUS_BLOCK     IOSB;
    HANDLE              driverHandle;

    DWORD               lastError;


    // HACK: I can't seems to find the correct device
    // names, so I can't open the composite battery using CreateFile()
    // and I can't open the detected batteries using NtOpenFile(), so I
    // have to use a different method of opening the battery depending on
    // which battery it is.
    if (BatteryName->Buffer == COMPOSITE_NAME) {
        InitializeObjectAttributes(
            &ObjA,
            BatteryName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

        status = NtOpenFile (
            &driverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

        if (!NT_SUCCESS(status)) {
            printf ("Error opening %ws: NTSTATUS = 0x%08lx\n",
                    BatteryName->Buffer, status);
            return NULL;
        }
    } else {
        driverHandle = CreateFile (BatteryName->Buffer,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

        if (INVALID_HANDLE_VALUE == driverHandle) {
            lastError = GetLastError ();
            printf ("Error opening %ws: GetLastError = 0x%08lx \n",
                    BatteryName->Buffer, lastError);
            return NULL;
        }
    }

    printf("Opened %ws \n", BatteryName->Buffer);

    return driverHandle;
}


ULONG
GetBatteryTag (HANDLE DriverHandle)
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;
    ULONG           BatteryTag;
    ULONG           Timeout = 0;

    if (LongTerm) {
        Timeout = (ULONG)-1;
    }

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_TAG,
            &Timeout,                   // input buffer
            sizeof (Timeout),
            &BatteryTag,            // output buffer
            sizeof (BatteryTag)
            );


    if (!NT_SUCCESS(Status)) {
        BatteryTag = BATTERY_TAG_INVALID;
        if (Status == STATUS_NO_SUCH_DEVICE) {
            printf ("(Battery is not physically present or is not connected)\n");
        } else {
            printf ("Query Battery tag failed: Status = %x\n", Status);
        }

    }

    printf("Battery Tag = 0x%08lx.\n", BatteryTag);
    return BatteryTag;
}


BOOLEAN
GetBatteryInfo (
    HANDLE DriverHandle,
    ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    OUT PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;
    BInfo.AtRate = 0;                       // This is needed for reading estimated time correctly.

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_INFORMATION,
            &BInfo,                 // input buffer
            sizeof (BInfo),
            Buffer,                 // output buffer
            BufferLength
            );


    if (!NT_SUCCESS(Status)) {

        if ((Status == STATUS_INVALID_PARAMETER)        ||
            (Status == STATUS_INVALID_DEVICE_REQUEST)   ||
            (Status == STATUS_NOT_SUPPORTED)) {

            printf ("Not Supported by Battery, Level %x, Status: %x\n", Level, Status);
        } else {
            printf ("Query failed: Level %x, Status = %x\n", Level, Status);
        }

        return FALSE;
    }

    return TRUE;
}




VOID
GetBatteryStatus (
    HANDLE DriverHandle,
    IN  PBATTERY_WAIT_STATUS    WaitStatus,
    IN  PBATTERY_INFORMATION    BInfo,
    OUT PBATTERY_STATUS         BatteryStatus
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Volts;


    memset (BatteryStatus, 0xAB, sizeof(BatteryStatus));

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_STATUS,
            WaitStatus,            // input buffer
            sizeof (BATTERY_WAIT_STATUS),
            BatteryStatus,         // output buffer
            sizeof (BATTERY_STATUS)
            );

    //
    // dump battery status
    //
    printf ("[Current Status Information]\n");
    printf ("    Power State...........: ");

    if (!NT_SUCCESS(Status)) {
        printf ("Query failed: Status = %x\n", Status);
        return ;
    }


    //
    // Print the PowerState
    //

    printf ("%08x  ", BatteryStatus->PowerState);

    if (BatteryStatus->PowerState & BATTERY_POWER_ON_LINE) {
        printf ("Power_Online ");
    }

    if (BatteryStatus->PowerState & BATTERY_DISCHARGING) {
        printf ("Discharging ");
    }

    if (BatteryStatus->PowerState & BATTERY_CHARGING) {
        printf ("Charging ");
    }

    if (BatteryStatus->PowerState & BATTERY_CRITICAL) {
        printf ("Critical! ");
    }

    if (BatteryStatus->PowerState == 0) {
        printf ("No flags set.");
    }

    printf ("\n");


    //
    // Print the Voltage
    //

    Volts = BatteryStatus->Voltage;
    if (Volts == BATTERY_UNKNOWN_VOLTAGE) {
        printf ("    Voltage...............: %08x  UNKNOWN\n", Volts);
    } else {
        printf ("    Voltage...............: %08x  %d.%03d V\n", Volts, (Volts/1000), Volts - ((Volts/1000)*1000));
    }


    //
    // Print the Rate
    //

    if (BatteryStatus->Rate == BATTERY_UNKNOWN_RATE) {
        printf ("    Rate..................: %08x  UNKNOWN\n",  BatteryStatus->Rate);
    } else {
        if (BInfo->Capabilities & BATTERY_CAPACITY_RELATIVE) {
            printf ("    Rate..................: %08x  %d % per hour  ",  BatteryStatus->Rate,  BatteryStatus->Rate);
        } else {
            printf ("    Rate..................: %08x  %d mW  ",  BatteryStatus->Rate,  BatteryStatus->Rate);
        }

        if (BatteryStatus->PowerState & BATTERY_CHARGING) {
            printf ("(Charging)\n");
        } else if (BatteryStatus->PowerState & BATTERY_DISCHARGING) {
            printf ("(Discharging)\n");
        } else {
            printf ("(Quiescent)\n");
        }
    }


    //
    // Print the Current Capacity
    //

    if (BatteryStatus->Capacity == BATTERY_UNKNOWN_CAPACITY) {
        printf ("    Current Battery Charge: %08x  UNKNOWN\n");
    } else {
        printf ("    Current Battery Charge: %08x  ",  BatteryStatus->Capacity);

        if (BatteryStatus->Capacity == 0xFFFF) {
            printf ("Invalid");
        } else {
            printf ("%d mWh ", BatteryStatus->Capacity);
        }
        if ((BInfo->FullChargedCapacity != 0) &
            (BInfo->FullChargedCapacity != BATTERY_UNKNOWN_CAPACITY)){
            printf ("(%d%%)",
                    BatteryStatus->Capacity * 100 / BInfo->FullChargedCapacity);
        }
        printf ("\n");
    }

    printf ("\n");
}




void
QueryBattery (PUNICODE_STRING BatteryName)
{
    HANDLE                  driverHandle;
    ULONG                   batteryTag;
    BATTERY_INFORMATION     BInfo;
    ULONG                   BETime;
    UCHAR                   BDeviceName[50];
    MFG_DATE                BManDate;
    UCHAR                   BManName[50];
    ULONG                   BETemp;
    UCHAR                   BEUID[50];
    BATTERY_REPORTING_SCALE BEGran[4];
    BATTERY_WAIT_STATUS     WStat;
    BATTERY_STATUS          BStat;
    ULONG                   i;
    ULONG                   Cent;
    ULONG                   Far;
    UCHAR                   PrivateLevel;
    ULONG                   Bdata;
    UCHAR                   Bblock[50];

    if ((driverHandle = OpenBattery (BatteryName)) == NULL) {
        return;
    }

    printf ("Opened driver w/handle %d\n", driverHandle);

    batteryTag = GetBatteryTag (driverHandle);
    if (batteryTag == BATTERY_TAG_INVALID) {
        NtClose(driverHandle);
        return;
    }

    printf ("[Static Information]\n");
    printf ("    Battery Tag...........: %x\n", batteryTag);

    //
    // Get generic info
    //

    if (GetBatteryInfo (driverHandle, batteryTag, BatteryInformation, &BInfo, sizeof(BInfo))) {

        //
        // Print the Capabilities
        //

        printf ("    Capabilities..........: ");

        printf ("%08x  ",  BInfo.Capabilities);

        if (BInfo.Capabilities & BATTERY_SYSTEM_BATTERY) {
            printf ("System ");
        }

        if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
            printf ("Capacity_Relative ");
        }

        if (BInfo.Capabilities & BATTERY_IS_SHORT_TERM) {
            printf ("Short_Term ");
        }
        printf ("\n");


        //
        // Print the Technology
        //

        printf ("    Technology............: %08x  ",  BInfo.Technology);

        if (BInfo.Technology == 0) {
            printf ("Primary Battery ");
        } else if (BInfo.Technology == 1) {
            printf ("Secondary Battery ");
        } else {
            printf ("Unknown ");
        }
        printf ("\n");


        //
        // Print the Chemistry
        //

        printf ("    Chemistry.............: %4.4s\n", BInfo.Chemistry);


        //
        // Print the Designed Capacity
        //

        printf ("    Designed Capacity.....: ");

        if (BInfo.DesignedCapacity == BATTERY_UNKNOWN_CAPACITY) {
            printf ("%08x  UNKNOWN\n", BInfo.DesignedCapacity);
        } else {
            if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
                printf ("%08x  %d%%\n", BInfo.DesignedCapacity, BInfo.DesignedCapacity);
            } else {
                printf ("%08x  %d mWh\n", BInfo.DesignedCapacity, BInfo.DesignedCapacity);
            }
        }


        //
        // Print the Full Charged Capacity
        //

        printf ("    Full Charged Capacity.: ");

        if (BInfo.FullChargedCapacity == BATTERY_UNKNOWN_CAPACITY) {
            printf ("%08x  UNKNOWN\n", BInfo.FullChargedCapacity);
        } else {
            if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
                printf ("%08x  %d%%\n", BInfo.FullChargedCapacity, BInfo.FullChargedCapacity);
            } else {
                printf ("%08x  %d mWh\n", BInfo.FullChargedCapacity, BInfo.FullChargedCapacity);
            }
        }

        if ((BInfo.FullChargedCapacity == 0) ||
            (BInfo.FullChargedCapacity == BATTERY_UNKNOWN_CAPACITY)){
            //
            // Print Alert 1
            //

            printf ("    Default Alert1 (crit).: %08x  %d mWh\n",
                    BInfo.DefaultAlert1, BInfo.DefaultAlert1);


            //
            // Print Alert 2
            //

            printf ("    Default Alert2 (low)..: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert2, BInfo.DefaultAlert2);

        } else {

            //
            // Print Alert 1
            //

            printf ("    Default Alert1 (crit).: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert1, BInfo.DefaultAlert1,
                    (BInfo.DefaultAlert1*100)/BInfo.FullChargedCapacity);


            //
            // Print Alert 2
            //

            printf ("    Default Alert2 (low)..: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert2, BInfo.DefaultAlert2,
                    (BInfo.DefaultAlert2*100)/BInfo.FullChargedCapacity);
        }

        //
        // Print the Critical Bias
        //

        printf ("    Critical Bias.........: %08x\n", BInfo.CriticalBias);


        //
        // Print the Cycle Count
        //

        printf ("    Cycle Count...........: %08x  %d\n", BInfo.CycleCount, BInfo.CycleCount);
    }


    //
    // Print the battery granularity
    //

    printf ("    Granularity...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryGranularityInformation, BEGran, sizeof(BEGran))) {

        printf ("%08x  Capacity(1) %08x\n", BEGran[0].Granularity, BEGran[0].Capacity);

        for (i = 1; i < 4; i++) {
            if ((BEGran[i].Granularity != -1) && (BEGran[i].Granularity != 0)) {
            printf ("                            %08x  Capacity(%d) %08x\n",
                BEGran[i].Granularity, (i+1), BEGran[i].Capacity);
            }
        }
    }


    //
    // Print the temperature
    //

    printf ("    Temperature...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryTemperature,     &BETemp,      sizeof(BETemp))) {
        printf ("%08x", BETemp);

        //
        // Print temp as something reasonable - Centigrade and Fahrenheit
        //
        if (BETemp > 0) {
            Cent = (BETemp/10) - 273;
            Far = ((Cent*2) - (Cent/5)) + 32;
            printf ("  %d C  %d F", Cent, Far);
        }
        printf ("\n");
    }


    //
    // Print the Unique ID
    //

    printf ("    Unique ID.............: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryUniqueID,        BEUID,       sizeof(BEUID))) {
        printf ("%ws\n",  BEUID);
    }


    //
    // Print the estimated run time
    //

    printf ("    Estimated Runtime.....: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryEstimatedTime,   &BETime,      sizeof(BETime))) {
        printf ("%08x  ", BETime);

        if (BETime != BATTERY_UNKNOWN_TIME) {
            printf ("%d Seconds ", BETime);
            printf ("(%d:%d:%d)", BETime / 3600, (BETime % 3600) / 60, (BETime % 3600) % 60);
        } else {
            printf ("Not Available");
        }
        printf ("\n");
    }


    //
    // Print the device name
    //

    printf ("    Device Name...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryDeviceName,       BDeviceName, sizeof(BDeviceName))) {
        printf ("%ws\n",  BDeviceName);
    }


    //
    // Print the manufacture date
    //

    printf ("    Manufacture Date......: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryManufactureDate,  &BManDate,    sizeof(BManDate))) {
        printf ("%02X%02X%04X  %02d/%02d/%d\n", BManDate.Month, BManDate.Day, BManDate.Year,
                        BManDate.Month, BManDate.Day, BManDate.Year);
    }


    //
    // Print the manufacturer name
    //

    printf ("    Manufacturer Name.....: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryManufactureName,  BManName,    sizeof(BManName))) {
        printf ("%ws\n",  BManName);
    }

    printf ("\n");


    //
    // Get the battery status and print it out
    //

    memset (&WStat, 0, sizeof(WStat));
    WStat.BatteryTag = batteryTag;

    GetBatteryStatus (driverHandle, &WStat, &BInfo, &BStat);

    //
    // If the user requested it perform a long term status change request
    //

    if (LongTerm) {

        printf ("Starting long-term status change request (5 min.)\n");

        WStat.PowerState = BStat.PowerState;
        WStat.LowCapacity = BStat.Capacity - RANGE;
        WStat.HighCapacity = BStat.Capacity + RANGE;
        WStat.Timeout = 50000000;  // 5 min
        GetBatteryStatus (driverHandle, &WStat, &BInfo, &BStat);
    }

    NtClose(driverHandle);
}


int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG           battTag;
    ULONG           battNum;
    ULONG           RetVal;
    UCHAR           param;
    UNICODE_STRING  batteries [MAX_NUMBER_OF_BATTERIES];
    UCHAR           numBatts;


    RtlZeroMemory (batteries, sizeof(UNICODE_STRING)*MAX_NUMBER_OF_BATTERIES);

    _tprintf (_T("Parameters: [L] - Issue Long-term status change request\n"));

    if (argc > 1) {
        param = argv[1][0];

        if ((param == 'l') || param == 'L') {
            LongTerm = TRUE;
        }
    }



    while (1) {

        numBatts = GetBatteryDriverNames (batteries, MAX_NUMBER_OF_BATTERIES);

        printf ("\n");
        for (battNum = 0; battNum < numBatts; battNum++) {
            _tprintf(_T("Batt#%d: %s \n"), battNum, batteries[battNum].Buffer);
        }

        printf ("\nBattery Number: ");
        if (scanf ("%d", &battNum) != 1) {
            return 0;                                   // Program exit
        }
        printf ("\n");

        if (battNum < numBatts) {

            QueryBattery (&batteries [battNum]);

        } else {
            printf ("Invalid Battery Number\n");
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\vxd.c ===
#include "cmbattp.h"
#include <basedef.h>
#include <vmm.h>
#include "vpowerd.h"

VOID CmBattNotifyVPOWERDOfPowerChange (ULONG PowerSourceChange)
{

	POWER_STATUS	powerstatus;
        ULONG		Device;
        
        Device = PowerSourceChange ? 38 : PDI_MANAGED_BY_APM_BIOS;
        
        _asm	{
        
        
        	lea	eax, powerstatus
                push	eax
                mov	eax, Device
                push	eax
                
                VMMCall (_VPOWERD_Get_Power_Status)
                add	esp, 4*2        
        }			
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmhndlr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cmhndlr.c

Abstract:

    Control Method Battery handlers

Author:

    Bob Moore

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"


VOID
CmBattPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called when the system changes power states

Arguments:

    CallBackContext - The device extension for the root device
    Argument1

--*/
{

    PDRIVER_OBJECT  CmBattDriver = (PDRIVER_OBJECT) CallBackContext;
    ULONG           action = PtrToUlong( Argument1 );
    ULONG           value  = PtrToUlong( Argument2 );
    BOOLEAN         timerCanceled;
    PDEVICE_OBJECT  CmBattDevice;
    PCM_BATT        CmBatt;

    CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: action: %d, value: %d \n", action, value));

    //
    // We are looking for a PO_CB_SYSTEM_STATE_LOCK
    //
    if (action != PO_CB_SYSTEM_STATE_LOCK) {
        return;
    }

    switch (value) {
    case 0:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: Delaying Notifications\n"));
        //
        // Get the head of the DeviceObject list
        //

        CmBattDevice = CmBattDriver->DeviceObject;

        while (CmBattDevice) {
            CmBatt = CmBattDevice->DeviceExtension;

            //
            // Cause all notifications to be delayed.
            //
            CmBatt->Sleeping = TRUE;

            CmBattDevice = CmBattDevice->NextDevice;

        }
        break;

    case 1:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: Calling CmBattWakeDpc after 10 seconds.\n"));
        timerCanceled = KeSetTimer (&CmBattWakeDpcTimerObject,
                    CmBattWakeDpcDelay,
                    &CmBattWakeDpcObject);
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: timerCanceled = %d.\n", timerCanceled));
        break;

    default:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: unknown argument2 = %08x\n", value));


    }

}

VOID
CmBattWakeDpc (
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is called X seconds after the system wakes to proces
    all delayed battery notifications.

Arguments:

    CmBattDriver - Driver object

Return Value:

    None

--*/

{
    PDRIVER_OBJECT  CmBattDriver = (PDRIVER_OBJECT) DeferredContext;
    BOOLEAN         notifyAll = FALSE;
    PDEVICE_OBJECT  CmBattDevice;
    PCM_BATT        CmBatt;

    CmBattPrint (CMBATT_TRACE, ("CmBattWakeDpc: Entered.\n"));
    //
    // Get the head of the DeviceObject list
    //

    CmBattDevice = CmBattDriver->DeviceObject;

    while (CmBattDevice) {
        CmBatt = CmBattDevice->DeviceExtension;

        //
        // We will now process all delayed notifications.
        // For effeiciency, we must go through the devices twice:
        // first to see if any AC devices have been notified, and
        // then to send notifications to all battery devices if necessary.
        //
        CmBatt->Sleeping = FALSE;

        if ((CmBatt->Type == AC_ADAPTER_TYPE) &&
            (CmBatt->ActionRequired & CMBATT_AR_NOTIFY)) {

            //
            // If any AC adapter devices have notified,
            // then we need to notify all battery devices
            //
            CmBattPrint (CMBATT_PNP, ("CmBattWakeDpc: AC adapter notified\n"));
            notifyAll = TRUE;
            CmBatt->ActionRequired = CMBATT_AR_NO_ACTION;
        }

        CmBattDevice = CmBattDevice->NextDevice;

    }

    //
    // Get the head of the DeviceObject list
    //

    CmBattDevice = CmBattDriver->DeviceObject;

    // Walk the list
    while (CmBattDevice) {
        CmBatt = CmBattDevice->DeviceExtension;

        if (CmBatt->Type == CM_BATTERY_TYPE) {
            CmBattPrint (CMBATT_PNP, ("CmBattWakeDpc: Performing delayed ARs: %01x\n", CmBatt->ActionRequired));

            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_CACHE) {
                InterlockedExchange (&CmBatt->CacheState, 0);
            }
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_TAG) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            }
            if ((CmBatt->ActionRequired & CMBATT_AR_NOTIFY) || notifyAll) {
                BatteryClassStatusNotify (CmBatt->Class);
            }
        }

        CmBattDevice = CmBattDevice->NextDevice;

    }


}

VOID
CmBattNotifyHandler (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    )
/*++

Routine Description:

    This routine fields battery device notifications from the ACPI driver.

Arguments:


Return Value:

    None

--*/
{
    PCM_BATT            CmBatt = Context;
    PDRIVER_OBJECT      CmBatteryDriver;
    PDEVICE_OBJECT      CmBatteryDevice;
    PCM_BATT            CmBatteryExtension;

    CmBattPrint ((CMBATT_PNP | CMBATT_BIOS), ("CmBattNotifyHandler: CmBatt 0x%08x Type %d Number %d Notify Value: %x\n",
                                CmBatt, CmBatt->Type, CmBatt->DeviceNumber, NotifyValue));

    switch (NotifyValue) {

        case BATTERY_DEVICE_CHECK:
            //
            // A new battery was inserted in the system.
            //

            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;

            //
            // This notification is only received when a battery is inserted.
            // It also occurs after restart from hibernation on some machines.
            // Invalidate battery tag.
            //

            if (CmBatt->Info.Tag != BATTERY_TAG_INVALID) {
                CmBattPrint ((CMBATT_ERROR),
                   ("CmBattNotifyHandler: Received battery #%x insertion, but tag was not invalid.\n",
                    CmBatt->DeviceNumber));
            }

            break;


        case BATTERY_EJECT:
            //
            // A battery was removed from the system
            //

            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;

            //
            // Invalidate the battery tag and all cached informaion
            // whenever this message is received.
            //
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_TAG;

            break;

        case BATTERY_STATUS_CHANGE:                 // Status change only
            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;

            break;

        case BATTERY_INFO_CHANGE:                   // Info & status change
            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_TAG;
            break;

        default:

            CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Unknown Notify Value: %x\n", NotifyValue));
            break;

    }

    if (CmBatt->Sleeping) {
        CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Notification delayed: ARs = %01x\n", CmBatt->ActionRequired));
    } else {
        CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Performing ARs: %01x\n", CmBatt->ActionRequired));
        if (CmBatt->Type == CM_BATTERY_TYPE) {
            
            //
            // Invalidate last trip point set on battery.
            //
            CmBatt->Alarm.Setting = CM_ALARM_INVALID;
            
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_CACHE) {
                InterlockedExchange (&CmBatt->CacheState, 0);
            }
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_TAG) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            }
            if (CmBatt->ActionRequired & CMBATT_AR_NOTIFY) {
                CmBatt->ReCheckSta = TRUE;
                BatteryClassStatusNotify (CmBatt->Class);                
            }

        } else if ((CmBatt->Type == AC_ADAPTER_TYPE) &&
                    (CmBatt->ActionRequired & CMBATT_AR_NOTIFY)) {

            //
            // Get the Driver Object
            //

            CmBatteryDriver = CmBatt->Fdo->DriverObject;

            //
            // Get the head of the DeviceObject list
            //

            CmBatteryDevice = CmBatteryDriver->DeviceObject;

            //
            // Walk the DeviceObject list to notify the class driver on all batteries
            //
            while (CmBatteryDevice) {

                CmBatteryExtension = CmBatteryDevice->DeviceExtension;

                if (CmBatteryExtension->Type == CM_BATTERY_TYPE) {
                    CmBatteryExtension->ReCheckSta = TRUE;
                    BatteryClassStatusNotify (CmBatteryExtension->Class);
                }

                CmBatteryDevice = CmBatteryDevice->NextDevice;
            }
        }

        CmBatt->ActionRequired = CMBATT_AR_NO_ACTION;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\compbatt\compbatt.h ===
#include <wdm.h>
#include <batclass.h>


#ifndef FAR
#define FAR
#endif


//
// Debug
//

#define DEBUG DBG

#if DEBUG
    extern ULONG CompBattDebug;

    #define BattPrint(l,m)    if(l & CompBattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BATT_LOW        0x00000001
#define BATT_NOTE       0x00000002
#define BATT_WARN       0x00000004
#define BATT_ERROR      0x00000008
#define BATT_ERRORS     (BATT_ERROR | BATT_WARN)
#define BATT_MP         0x00000010
#define BATT_DEBUG      0x00000020
#define BATT_TRACE      0x00000100
#define BATT_DATA       0x00000200


//
// Battery class info
//

#define NTMS    10000L                          // 1 millisecond is ten thousand 100ns
#define NTSEC   (NTMS * 1000L)
#define NTMIN   ((ULONGLONG) 60 * NTSEC)

#define SEC     1000
#define MIN     (60 * SEC)

//
// Poll rates for when a notification alarm cannot be set
//
#define MIN_STATUS_POLL_RATE        (3L * NTMIN)
#define MAX_STATUS_POLL_RATE        (20 * NTSEC)
#define STATUS_VALID_TIME           (2 * NTSEC)

#define MAX_HIGH_CAPACITY           0x7fffffff
#define MIN_LOW_CAPACITY            0x0

//
// Charge/Discharge policy values (in percent)
//
#define BATTERY_MIN_SAFE_CAPACITY   2           // Min we will attempt to run on
#define BATTERY_MAX_CHARGE_CAPACITY 90          // Max we will attempt to charge

//
// Cache expiration timeouts -- when the cached battery status/info expires.
//
#define CACHE_STATUS_TIMEOUT        (4 * NTSEC)
#define CACHE_INFO_TIMEOUT          (4 * NTSEC)

//
// Cached battery info
//

typedef struct {
    ULONG                       Tag;
    ULONG                       Valid;
    BATTERY_INFORMATION         Info;
    ULONGLONG                   InfoTimeStamp;
    UCHAR                       ManufacturerNameLength;
    UCHAR                       ManufacturerName[MAX_BATTERY_STRING_SIZE];
    UCHAR                       DeviceNameLength;
    UCHAR                       DeviceName[MAX_BATTERY_STRING_SIZE];
    BATTERY_MANUFACTURE_DATE    ManufacturerDate;
    ULONG                       SerialNumber;
    BATTERY_STATUS              Status;
    ULONGLONG                   StatusTimeStamp;
} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;


#define VALID_TAG_DATA      0x01            // manufacturer, device, serial #
#define VALID_MODE          0x02
#define VALID_INFO          0x04
#define VALID_CYCLE_COUNT   0x08
#define VALID_SANITY_CHECK  0x10

#define VALID_TAG           0x80
#define VALID_NOTIFY        0x100

#define VALID_ALL           0x1F            // (does not include tag)

//
// Locking mechanism for battery nodes so we don't delete out from under
// ourselves.  I would just use an IO_REMOVE_LOCK, but that's NT not WDM...
//

typedef struct _COMPBATT_DELETE_LOCK {
    BOOLEAN     Deleted;
    BOOLEAN     Reserved [3];
    LONG        RefCount;
    KEVENT      DeleteEvent;

} COMPBATT_DELETE_LOCK, *PCOMPBATT_DELETE_LOCK;

VOID
CompbattInitializeDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

NTSTATUS
CompbattAcquireDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

VOID
CompbattReleaseDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

VOID
CompbattReleaseDeleteLockAndWait (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

//
// Battery node in the composite's list of batteries
//

typedef struct {
    LIST_ENTRY              Batteries;          // All batteries in composite
    COMPBATT_DELETE_LOCK    DeleteLock;
    PDEVICE_OBJECT          DeviceObject;       // device object for the battery
    PIRP                    StatusIrp;          // current status irp at device
    WORK_QUEUE_ITEM         WorkItem;           // Used for restarting status Irp
                                                // if it is completed at DPC level
    BOOLEAN                 NewBatt;            // Is this a new battery on the list


    UCHAR                   State;
    BATTERY_WAIT_STATUS     Wait;

    union {
        BATTERY_STATUS          Status;
        BATTERY_WAIT_STATUS     Wait;
        ULONG                   Tag;
    } IrpBuffer;

    //
    // Keep some static information around so we don't have to go out to the
    // batteries all the time.
    //

    STATIC_BAT_INFO         Info;

    //
    // Symbolic link name for the battery.  Since we calculate the length of this
    // structure based on the structure size plus the length of this string, the
    // string must be the last thing declared in the structure.
    //

    UNICODE_STRING          BattName;

} COMPOSITE_ENTRY, *PCOMPOSITE_ENTRY;


#define CB_ST_GET_TAG       0
#define CB_ST_GET_STATUS    1

//
// Composite battery device extension
//

typedef struct {
    PVOID                   Class;              // Class information
    // ULONG                   Tag;                // Current tag of composite battery
    ULONG                   NextTag;            // Next tag

    LIST_ENTRY              Batteries;          // All batteries
    FAST_MUTEX              ListMutex;          // List synchronization

    //
    // Keep some static information around so we don't have to go out to the
    // batteries all the time.
    //

    STATIC_BAT_INFO         Info;
    BATTERY_WAIT_STATUS     Wait;


    PDEVICE_OBJECT          LowerDevice;        // PDO
    PDEVICE_OBJECT          DeviceObject;       // Compbatt Device
    PVOID                   NotificationEntry;  // PnP registration handle
} COMPOSITE_BATTERY, *PCOMPOSITE_BATTERY;


//
// Prototypes
//


NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    );

NTSTATUS
CompBattIoctl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CompBattSystemControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CompBattQueryTag (
    IN  PVOID               Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
CompBattQueryInformation (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG                 AtRate,
    OUT PVOID               Buffer,
    IN  ULONG               BufferLength,
    OUT PULONG              ReturnedLength
    );

NTSTATUS
CompBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
CompBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
CompBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
CompBattDriverEntry (
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      RegistryPath
    );

NTSTATUS
CompBattGetBatteryInformation (
    IN PBATTERY_INFORMATION TotalBattInfo,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetBatteryGranularity (
    IN PBATTERY_REPORTING_SCALE GranularityBuffer,
    IN PCOMPOSITE_BATTERY       CompBatt
   );

NTSTATUS
CompBattPrivateIoctl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CompBattGetEstimatedTime (
    IN PULONG               TimeBuffer,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattAddDevice (
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       PDO
    );

NTSTATUS
CompBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CompBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

VOID
CompBattUnload(
    IN PDRIVER_OBJECT       DriverObject
    );

NTSTATUS
CompBattOpenClose(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
BatteryIoctl(
    IN ULONG                Ioctl,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PVOID                InputBuffer,
    IN ULONG                InputBufferLength,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    IN BOOLEAN              PrivateIoctl
    );

NTSTATUS
CompBattPnpEventHandler(
    IN PVOID                NotificationStructure,
    IN PVOID                Context
    );

NTSTATUS
CompBattAddNewBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattRemoveBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

BOOLEAN
IsBatteryAlreadyOnList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

PCOMPOSITE_ENTRY
RemoveBatteryFromList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetBatteries(
    IN PCOMPOSITE_BATTERY   CompBatt
    );

BOOLEAN
CompBattVerifyStaticInfo (
    IN  PCOMPOSITE_BATTERY  CompBatt
    );

VOID CompBattMonitorIrpCompleteWorker (
    IN PVOID Context
    );

NTSTATUS
CompBattMonitorIrpComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

VOID
CompBattRecalculateTag (
    IN PCOMPOSITE_BATTERY   CompBatt
    );

VOID
CompBattChargeDischarge (
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\compbatt\compmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    battmisc.c

Abstract:

    Miscellaneous functions needed by the composite battery to talk to
    the batteries in the system.

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include "compbatt.h"



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BatteryIoctl)
#pragma alloc_text(PAGE, CompBattGetDeviceObjectPointer)
#endif



NTSTATUS
BattIoctlComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT         Event;

    Event = (PKEVENT) Context;
    KeSetEvent (Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS
BatteryIoctl(
    IN ULONG            Ioctl,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength,
    IN BOOLEAN          PrivateIoctl
    )
/*++

Routine Description:

    The routine Creates an IRP and does Ioctl to the device object passed in.

Arguments:

    Ioctl               - code for the Ioctl

    DeviceObject        - Device object to send the ioctl to

    InputBuffer         - Input buffer for the ioctl

    InputBufferLength   - length of the input buffer

    OutputBuffer        - Buffer for containing the results of the ioctl

    OutputBufferLength  - Length of the output buffer

    PrivateIoctl        - TRUE if this is to be an IRP_MJ_DEVICE_CONTROL, FALSE
                          if this is to be an IRP_MJ_INTERNAL_DEVICE_CONTROL.

Return Value:

    Status returned by the Ioctl

--*/
{
    NTSTATUS                status;
    IO_STATUS_BLOCK         IOSB;
    PIRP                    irp;
    KEVENT                 event;
    // PUCHAR                  buffer;
    // ULONG                   bufferSize;
    // PIO_STACK_LOCATION      irpSp;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING BatteryIoctl\n"));

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
                Ioctl,
                DeviceObject,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength,
                PrivateIoctl,
                &event,
                &IOSB
                   );

    if (irp == NULL) {
        BattPrint (BATT_ERROR, ("BatteryIoctl: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = IOSB.Status;
    }

    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("BatteryIoctl: Irp failed - %x\n", status));
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING BatteryIoctl\n"));

    return status;
}




BOOLEAN
IsBatteryAlreadyOnList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine runs through the list of batteries the composite keeps and checks
    to see if the symbolic link name passed in matches one of them.

Arguments:

    SymbolicLinkName    - Name for battery to check if already on list


Return Value:

    TRUE if the SymbolicLinkName belongs to a battery already on the list, FALSE
    otherwise.
--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING IsBatteryAlreadyOnList\n"));

    //
    // Run through the list of batteries looking for new batteries
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!RtlCompareUnicodeString(SymbolicLinkName, &batt->BattName, TRUE)) {
            //
            // The battery is already on the list
            //

            ExReleaseFastMutex (&CompBatt->ListMutex);
            return TRUE;
        }
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING IsBatteryAlreadyOnList\n"));

    ExReleaseFastMutex (&CompBatt->ListMutex);

    return FALSE;
}

PCOMPOSITE_ENTRY
RemoveBatteryFromList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine runs through the list of batteries the composite keeps and checks
    to see if the symbolic link name passed in matches one of them.  If a match is found,
    the entry is removed from the list of batteries

Arguments:

    SymbolicLinkName    - Name for battery to check if already on list


Return Value:

    TRUE if the SymbolicLinkName was found and deleted. FALSE otherwise.
--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING RemoveBatteryFromList\n"));

    //
    // Run through the list of batteries looking for new batteries
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!RtlCompareUnicodeString(SymbolicLinkName, &batt->BattName, TRUE)) {
            //
            // The battery is on the list, remove
            //

            //
            // Wait until no one else is looking at this battery before removing it.
            //

            CompbattAcquireDeleteLock (&batt->DeleteLock);

            ExReleaseFastMutex (&CompBatt->ListMutex);

            CompbattReleaseDeleteLockAndWait (&batt->DeleteLock);


            ExAcquireFastMutex (&CompBatt->ListMutex);
            RemoveEntryList(entry);
            ExReleaseFastMutex (&CompBatt->ListMutex);

            return batt;
        }
    }

    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING RemoveBatteryFromList\n"));

    return NULL;
}

NTSTATUS
CompBattGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine is essentially a copy from ntos\io\iosubs.c
    The reason for this is that we need to open the device with shared access
    rather than exclusive access.  In addition  ZwCreateFile was used instead of
    ZwOpenFile becuase that didn't seem to complie right when only wdm.h instead
    of ntddk.h was included.

    This routine returns a pointer to the device object specified by the
    object name.  It also returns a pointer to the referenced file object
    that has been opened to the device that ensures that the device cannot
    go away.

    To close access to the device, the caller should dereference the file
    object pointer.

Arguments:

    ObjectName - Name of the device object for which a pointer is to be
        returned.

    DesiredAccess - Access desired to the target device object.

    FileObject - Supplies the address of a variable to receive a pointer
        to the file object for the device.

    DeviceObject - Supplies the address of a variable to receive a pointer
        to the device object for the specified device.

Return Value:

    The function value is a referenced pointer to the specified device
    object, if the device exists.  Otherwise, NULL is returned.

--*/

{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                ObjectName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateFile (
                    &fileHandle,
                    DesiredAccess,     // desired access
                    &objectAttributes,
                    &ioStatus,
                    (PLARGE_INTEGER) NULL,
                    0L,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                    FILE_OPEN,
                    0,
                    NULL,
                    0);

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            *FileObject = fileObject;

            //
            // Get a pointer to the device object for this file.
            //
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
        }

        (VOID) ZwClose( fileHandle );
    }

    return status;
}

//
// Delete Lock routines from io\remlock.c
//

VOID
CompbattInitializeDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    Lock->Deleted = FALSE;
    Lock->RefCount = 1;
    KeInitializeEvent(&Lock->DeleteEvent,
                      SynchronizationEvent,
                      FALSE);

}

NTSTATUS
CompbattAcquireDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    LONG        lockValue;

    lockValue = InterlockedIncrement(&Lock->RefCount);

    if (Lock->Deleted) {
        if (0 == InterlockedDecrement (&Lock->RefCount)) {
            KeSetEvent (&Lock->DeleteEvent, 0, FALSE);
        }

        return STATUS_DELETE_PENDING;
    }

    return STATUS_SUCCESS;

}

VOID
CompbattReleaseDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    if (0 == InterlockedDecrement(&Lock->RefCount)) {

        KeSetEvent(&Lock->DeleteEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
}

VOID
CompbattReleaseDeleteLockAndWait (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    Lock->Deleted = TRUE;

    InterlockedDecrement (&Lock->RefCount);

    if (0 < InterlockedDecrement (&Lock->RefCount)) {
        KeWaitForSingleObject (&Lock->DeleteEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\compbatt\compbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CompBatt.c

Abstract:

    Composite Battery device functions

    The purpose of the composite battery device is to open all batteries
    in the system which supply system power and provide a logical sumation
    of the information under one battery device.

Author:

    Ken Reneris

Environment:

Notes:


Revision History:
    07/02/97:  Local cache timestamps/timeouts

--*/

#include "compbatt.h"

#if DEBUG
    #if DBG
        ULONG   CompBattDebug = BATT_ERRORS;
    #else
        ULONG   CompBattDebug = 0;
    #endif
#endif



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CompBattUnload)
#pragma alloc_text(PAGE, CompBattIoctl)
#pragma alloc_text(PAGE, CompBattQueryTag)
#pragma alloc_text(PAGE, CompBattQueryInformation)
#pragma alloc_text(PAGE, CompBattQueryStatus)
#pragma alloc_text(PAGE, CompBattSetStatusNotify)
#pragma alloc_text(PAGE, CompBattDisableStatusNotify)
#pragma alloc_text(PAGE, CompBattGetBatteryInformation)
#pragma alloc_text(PAGE, CompBattGetBatteryGranularity)
#pragma alloc_text(PAGE, CompBattGetEstimatedTime)
#endif



NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    The first time the battery class driver is loaded it will check to
    see if the composite battery has been created.  If not, it will create
    a driver object with this routine as the DriverEntry.  This routine
    then does the necessary things to initialize the composite battery.

Arguments:

    DriverObject - Driver object for newly created driver

    RegistryPath - Not used

Return Value:

    Status

--*/
{

    // DbgBreakPoint ();

    //
    // Initialize the driver entry points
    //

    //DriverObject->DriverUnload                          = CompBattUnload;
    DriverObject->DriverExtension->AddDevice            = CompBattAddDevice;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = CompBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = CompBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = CompBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = CompBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = CompBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = CompBattSystemControl;
    return STATUS_SUCCESS;
}




NTSTATUS
CompBattAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
    )

/*++

Routine Description:



Arguments:

    DriverObject - Pointer to driver object created by system.

    PDO          - PDO for the new device(s)

Return Value:

    Status

--*/
{
    PDEVICE_OBJECT          fdo;
    BATTERY_MINIPORT_INFO   BattInit;
    UNICODE_STRING          UnicodeString;
    NTSTATUS                Status;
    UNICODE_STRING          DosLinkName;
    PCOMPOSITE_BATTERY      compBatt;


    BattPrint (BATT_NOTE, ("CompBatt: Got an AddDevice - %x\n", PDO));

    //
    // Build the composite battery device and register it to the
    // battery class driver (i.e., ourselves)
    //

    RtlInitUnicodeString(&UnicodeString, L"\\Device\\CompositeBattery");

    Status = IoCreateDevice(
                DriverObject,
                sizeof (COMPOSITE_BATTERY),
                &UnicodeString,
                FILE_DEVICE_BATTERY,    // DeviceType
                0,
                FALSE,
                &fdo
                );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    RtlInitUnicodeString(&DosLinkName, L"\\DosDevices\\CompositeBattery");
    IoCreateSymbolicLink(&DosLinkName, &UnicodeString);

    //
    // Layer our FDO on top of the PDO.
    //

    compBatt                = (PCOMPOSITE_BATTERY) fdo->DeviceExtension;
    RtlZeroMemory (compBatt, sizeof(COMPOSITE_BATTERY));

    compBatt->LowerDevice   = IoAttachDeviceToDeviceStack (fdo,PDO);

    compBatt->DeviceObject = fdo;

    //
    // No status. Do the best we can.
    //

    if (!compBatt->LowerDevice) {
        BattPrint (BATT_ERROR, ("CompBattAddDevice: Could not attach to LowerDevice.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize composite battery info
    //

    fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    InitializeListHead (&compBatt->Batteries);
    ExInitializeFastMutex (&compBatt->ListMutex);

    compBatt->NextTag           = 1;   // first valid battery tag for composite
    compBatt->Info.Valid        = 0;

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = compBatt;
    BattInit.QueryTag            = CompBattQueryTag;
    BattInit.QueryInformation    = CompBattQueryInformation;
    BattInit.SetInformation      = NULL;
    BattInit.QueryStatus         = CompBattQueryStatus;
    BattInit.SetStatusNotify     = CompBattSetStatusNotify;
    BattInit.DisableStatusNotify = CompBattDisableStatusNotify;

    BattInit.Pdo                 = NULL;
    BattInit.DeviceName          = &UnicodeString;

    //
    // Register myself with the battery class driver
    //

    Status = BatteryClassInitializeDevice (&BattInit, &compBatt->Class);
    if (!NT_SUCCESS(Status)) {
        IoDeleteDevice(fdo);
    }
    return Status;
}






VOID
CompBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{
    DbgBreakPoint();

    //
    // Unloading the composite battery is not supported.
    //          If it were implemented, we would
    //          need to call the class driver's unload and then
    //          delete all nodes in the battery list, clean up
    //          then delete our FDO.
    //
}




NTSTATUS
CompBattOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING OpenClose\n"));


    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint (BATT_TRACE, ("CompBatt: Exiting OpenClose\n"));

    return(STATUS_SUCCESS);
}




NTSTATUS
CompBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PCOMPOSITE_BATTERY  compBatt;
    NTSTATUS            status;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING Ioctl\n"));

    compBatt = (PCOMPOSITE_BATTERY) DeviceObject->DeviceExtension;
    status   = BatteryClassIoctl (compBatt->Class, Irp);


    if (status == STATUS_NOT_SUPPORTED) {
        //
        // Not for the battery, pass it down the stack.
        //

        Irp->IoStatus.Status = status;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(compBatt->LowerDevice, Irp);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING Ioctl\n"));

    return status;
}




NTSTATUS
CompBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards System Control requests down the stack

Arguments:

    DeviceObject    - the device object in question
    Irp             - the request to forward

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_BATTERY  compBatt;
    NTSTATUS            status;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING System Control\n"));

    compBatt = (PCOMPOSITE_BATTERY) DeviceObject->DeviceExtension;
    if (compBatt->LowerDevice != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( compBatt->LowerDevice, Irp );

    } else {

        Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;

}

NTSTATUS
CompBattQueryTag (
    IN  PVOID Context,
    OUT PULONG BatteryTag
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Pointer to return current tag


Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCOMPOSITE_BATTERY      compBatt;
    NTSTATUS                status          = STATUS_SUCCESS;


    PAGED_CODE();


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryTag\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if (!(compBatt->Info.Valid & VALID_TAG)) {
        //
        // Recalculate the composite's tag.
        //

        CompBattRecalculateTag(compBatt);

    }

    if ((compBatt->Info.Valid & VALID_TAG) && (compBatt->Info.Tag != BATTERY_TAG_INVALID)) {
        *BatteryTag = compBatt->Info.Tag;
        status      = STATUS_SUCCESS;

    } else {
        *BatteryTag = BATTERY_TAG_INVALID;
        status      = STATUS_NO_SUCH_DEVICE;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryTag\n"));

    return status;
}






NTSTATUS
CompBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
{
    ULONG                       resultData;
    NTSTATUS                    status;
    PVOID                       returnBuffer;
    ULONG                       returnBufferLength;
    PCOMPOSITE_BATTERY          compBatt;
    BATTERY_INFORMATION         totalBattInfo;
    BATTERY_REPORTING_SCALE     granularity[4];
    BATTERY_MANUFACTURE_DATE    date;
    WCHAR                       compositeName[] = L"Composite Battery";

    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryInformation\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }


    returnBuffer        = NULL;
    returnBufferLength  = 0;
    status              = STATUS_SUCCESS;


    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:

            RtlZeroMemory (&totalBattInfo, sizeof(totalBattInfo));
            status = CompBattGetBatteryInformation (&totalBattInfo, compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &totalBattInfo;
                returnBufferLength  = sizeof(totalBattInfo);
            }

            break;


        case BatteryGranularityInformation:

            RtlZeroMemory (&granularity[0], sizeof(granularity));
            status = CompBattGetBatteryGranularity (&granularity[0], compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &granularity[0];
                returnBufferLength  = sizeof(granularity);
            }

            break;


        case BatteryTemperature:
                resultData          = 0;
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof (resultData);
                break;


        case BatteryEstimatedTime:

            RtlZeroMemory (&resultData, sizeof(resultData));
            status = CompBattGetEstimatedTime (&resultData, compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof(resultData);

            }

            break;


        case BatteryDeviceName:
                returnBuffer        = compositeName;
                returnBufferLength  = sizeof (compositeName);
                break;


        case BatteryManufactureDate:
                date.Day            = 26;
                date.Month          = 6;
                date.Year           = 1997;
                returnBuffer        = &date;
                returnBufferLength  = sizeof (date);
                break;


        case BatteryManufactureName:
                returnBuffer        = compositeName;
                returnBufferLength  = sizeof (compositeName);
                break;


        case BatteryUniqueID:
                resultData          = 0;
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof (resultData);
                break;

        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = returnBufferLength;
    if (BufferLength < returnBufferLength) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(status) && returnBuffer) {
        memcpy (Buffer, returnBuffer, returnBufferLength);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryInformation\n"));

    return status;
}






NTSTATUS
CompBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status.  This
    routine loops through all of the batteries in the system and reports a
    composite battery.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS                status      = STATUS_SUCCESS;
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PBATTERY_STATUS         localBatteryStatus;
    PCOMPOSITE_BATTERY      compBatt;
    BATTERY_WAIT_STATUS     batteryWaitStatus;
    ULONGLONG               wallClockTime;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryStatus\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize Composite data structure.
    //

    BatteryStatus->Rate = BATTERY_UNKNOWN_RATE;
    BatteryStatus->Voltage = BATTERY_UNKNOWN_VOLTAGE;
    BatteryStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;

    // Composite battery will only report POWER_ON_LINE if all batteries report
    // this flag.
    BatteryStatus->PowerState = BATTERY_POWER_ON_LINE;

    //
    // Set up the local battery status structure for calls to the batteries
    //

    RtlZeroMemory (&batteryWaitStatus, sizeof (BATTERY_WAIT_STATUS));

    //
    // Get current time for timestamps
    //

    wallClockTime = KeQueryInterruptTime ();

    //
    // If cache is fresh, no need to do anything
    //

    if ((wallClockTime - compBatt->Info.StatusTimeStamp) <= CACHE_STATUS_TIMEOUT) {

        BattPrint (BATT_NOTE, ("CompBattQueryStatus: Composite battery status cache is [valid]\n"));

        //
        // Copy status info to caller's buffer
        //
        RtlCopyMemory (BatteryStatus, &compBatt->Info.Status, sizeof (BATTERY_STATUS));

        return STATUS_SUCCESS;
    }

    BattPrint (BATT_NOTE, ("CompBattQueryStatus: Composite battery status cache is [stale] - refreshing\n"));

    //
    // Walk the list of batteries, getting status of each
    //

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries; entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }
        ExReleaseFastMutex (&compBatt->ListMutex);

        batteryWaitStatus.BatteryTag    = batt->Info.Tag;
        localBatteryStatus              = &batt->Info.Status;

        if (batt->Info.Valid & VALID_TAG) {

            //
            // If cached status for this battery is stale, refresh it
            //

            if ((wallClockTime - batt->Info.StatusTimeStamp) > CACHE_STATUS_TIMEOUT) {

                BattPrint (BATT_NOTE, ("CompBattQueryStatus: Battery status cache is [stale] - refreshing\n"));

                //
                // issue IOCTL to device
                //

                RtlZeroMemory (localBatteryStatus, sizeof(BATTERY_STATUS));

                status = BatteryIoctl (IOCTL_BATTERY_QUERY_STATUS,
                                       batt->DeviceObject,
                                       &batteryWaitStatus,
                                       sizeof (BATTERY_WAIT_STATUS),
                                       localBatteryStatus,
                                       sizeof (BATTERY_STATUS),
                                       FALSE);

                if (!NT_SUCCESS(status)) {

                    //
                    // In case of failure, this function should simply return the
                    // status code.  Invalidating of data is now performed only
                    // in MonitorIrpComplete.
                    //
                    // This raises the slight possibility that the sender of this
                    // request could retry before the data is properly invalidated,
                    // but worst case, they would again get this same error condition
                    // until the data is properly invalidated by MonitorIrpComplete.
                    //

                    if (status == STATUS_DEVICE_REMOVED) {

                        //
                        // This battery is being removed.
                        // The composite battery tag is or will soon be
                        // invalidated by MonitorIrpComplete.
                        //

                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    //
                    // Return failure code.
                    //

                    ExAcquireFastMutex (&compBatt->ListMutex);
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                // Set new timestamp

                batt->Info.StatusTimeStamp = wallClockTime;

            } else {

                BattPrint (BATT_NOTE, ("CompBattQueryStatus: Battery status cache is [valid]\n"));
            }


            //
            // Accumulate data.
            //


            //
            // Combine the power states.
            //

            // Logical OR CHARGING and DISCHARGING
            BatteryStatus->PowerState  |= (localBatteryStatus->PowerState &
                                           (BATTERY_CHARGING |
                                            BATTERY_DISCHARGING));

            // Logical AND POWER_ON_LINE
            BatteryStatus->PowerState  &= (localBatteryStatus->PowerState |
                                           ~BATTERY_POWER_ON_LINE);

            // Compbatt is critical if one battery is critical and discharging
            if ((localBatteryStatus->PowerState & BATTERY_CRITICAL) &&
                (localBatteryStatus->PowerState & BATTERY_DISCHARGING)) {
                BatteryStatus->PowerState |= BATTERY_CRITICAL;
            }

            //
            // The Capacity could possibly be "Unknown" for CMBatt, and if so
            // we should not add it to the total capacity.
            //

            if (BatteryStatus->Capacity == BATTERY_UNKNOWN_CAPACITY) {
                BatteryStatus->Capacity = localBatteryStatus->Capacity;
            } else if (localBatteryStatus->Capacity != BATTERY_UNKNOWN_CAPACITY) {
                BatteryStatus->Capacity += localBatteryStatus->Capacity;
            }

            //
            // The Voltage should just be the greatest one encountered.
            //

            if (BatteryStatus->Voltage == BATTERY_UNKNOWN_VOLTAGE) {
                BatteryStatus->Voltage = localBatteryStatus->Voltage;
            } else if ((localBatteryStatus->Voltage > BatteryStatus->Voltage) &&
                       (localBatteryStatus->Voltage != BATTERY_UNKNOWN_VOLTAGE)) {
                BatteryStatus->Voltage = localBatteryStatus->Voltage;
            }

            //
            // The Current should just be total of all currents encountered.  This could
            // also possibly be "Unknown" for CMBatt, and if so we should not use it
            // in the calculation.
            //

            if (BatteryStatus->Rate == BATTERY_UNKNOWN_RATE) {
                BatteryStatus->Rate = localBatteryStatus->Rate;
            } else if (localBatteryStatus->Rate != BATTERY_UNKNOWN_RATE) {
                BatteryStatus->Rate += localBatteryStatus->Rate;
            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&compBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)

    ExReleaseFastMutex (&compBatt->ListMutex);


    //
    // If one battery was discharging while another was charging
    // Assume that it is discharging.  (This could happen with a UPS attached)
    //
    if ((BatteryStatus->PowerState & BATTERY_CHARGING) &&
        (BatteryStatus->PowerState & BATTERY_DISCHARGING)) {
        BatteryStatus->PowerState &= ~BATTERY_CHARGING;
    }

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Save the status in the composites cache
    //

    if (NT_SUCCESS(status)) {
        RtlCopyMemory (&compBatt->Info.Status, BatteryStatus, sizeof (BATTERY_STATUS));

        compBatt->Info.StatusTimeStamp = wallClockTime;

        BattPrint (BATT_DATA, ("CompBatt: Composite's new Status\n"
                               "--------  PowerState   = %x\n"
                               "--------  Capacity     = %x\n"
                               "--------  Voltage      = %x\n"
                               "--------  Rate         = %x\n",
                               compBatt->Info.Status.PowerState,
                               compBatt->Info.Status.Capacity,
                               compBatt->Info.Status.Voltage,
                               compBatt->Info.Status.Rate)
                               );

    }



    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryStatus\n"));

    return status;
}






NTSTATUS
CompBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.


Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PCOMPOSITE_BATTERY      compBatt;
    BATTERY_STATUS          batteryStatus;
    LONG                    totalRate = 0;
    ULONG                   delta;
    ULONG                   highCapacityDelta;
    ULONG                   lowCapacityDelta;
    NTSTATUS                status;
    BOOLEAN                 inconsistent = FALSE;
    ULONG                   battCount = 0;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING SetStatusNotify\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    //
    // Check to see if this is the right battery
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Refresh the composite battery status cache if necessary.
    //

    status = CompBattQueryStatus (compBatt, BatteryTag, &batteryStatus);

    if (!NT_SUCCESS(status)) {
        return status;
    }


    //
    // Save away the composite notification parameters for future reference
    //

    compBatt->Wait.PowerState   = BatteryNotify->PowerState;
    compBatt->Wait.LowCapacity  = BatteryNotify->LowCapacity;
    compBatt->Wait.HighCapacity = BatteryNotify->HighCapacity;
    compBatt->Info.Valid |= VALID_NOTIFY;

    BattPrint (BATT_DATA, ("CompBatt: Got SetStatusNotify\n"
                           "--------  PowerState   = %x\n"
                           "--------  LowCapacity  = %x\n"
                           "--------  HighCapacity = %x\n",
                           compBatt->Wait.PowerState,
                           compBatt->Wait.LowCapacity,
                           compBatt->Wait.HighCapacity)
                           );

    //
    // Compute capacity deltas based on the total system capacity
    //

    lowCapacityDelta    = compBatt->Info.Status.Capacity - BatteryNotify->LowCapacity;
    highCapacityDelta   = BatteryNotify->HighCapacity - compBatt->Info.Status.Capacity;

    //
    // Run through the list of batteries and add up the total rate
    //

    //
    // Hold Mutex for this entire loop, since this loop doesn't call any drivers, etc
    //
    ExAcquireFastMutex (&compBatt->ListMutex);

    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        if (!(batt->Info.Valid & VALID_TAG) || (batt->Info.Status.Rate == BATTERY_UNKNOWN_RATE)) {
            CompbattReleaseDeleteLock(&batt->DeleteLock);
            continue;
        }

        battCount++;

        if (((batt->Info.Status.PowerState & BATTERY_DISCHARGING) && (batt->Info.Status.Rate >= 0)) ||
            ((batt->Info.Status.PowerState & BATTERY_CHARGING) && (batt->Info.Status.Rate <= 0)) ||
            (((batt->Info.Status.PowerState & (BATTERY_CHARGING | BATTERY_DISCHARGING)) == 0) && (batt->Info.Status.Rate != 0))) {
            inconsistent = TRUE;
            BattPrint (BATT_ERROR, ("CompBatt: PowerState 0x%08x does not match Rate 0x%08x\n",
                       batt->Info.Status.PowerState,
                       batt->Info.Status.Rate));
        }

        if (((batt->Info.Status.Rate < 0) ^ (totalRate < 0)) && (batt->Info.Status.Rate != 0) && (totalRate != 0)) {
            inconsistent = TRUE;
            BattPrint (BATT_ERROR, ("CompBatt: It appears that one battery is charging while another is discharging.\n"
                                    "     This situation is not handled correctly.\n"));
        }

        totalRate += batt->Info.Status.Rate;

        CompbattReleaseDeleteLock(&batt->DeleteLock);

    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    //
    // Run through the list of batteries and update the new wait status params
    //

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&compBatt->ListMutex);

        if (!(batt->Info.Valid & VALID_TAG) ||
            (batt->Info.Status.Capacity == BATTERY_UNKNOWN_CAPACITY)) {
            batt->Wait.LowCapacity  = BATTERY_UNKNOWN_CAPACITY;
            batt->Wait.HighCapacity = BATTERY_UNKNOWN_CAPACITY;

#if DEBUG
            if (batt->Info.Status.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                BattPrint (BATT_DEBUG, ("CompBattSetStatusNotify: Unknown Capacity encountered.\n"));
            }
#endif

            ExAcquireFastMutex (&compBatt->ListMutex);
            CompbattReleaseDeleteLock(&batt->DeleteLock);
            continue;
        }

        //
        // Adjust the LowCapacity alarm
        //

        //
        // Calculate the portion of the composite battery delta that belongs to
        // this battery.
        //

        if (inconsistent) {
            //
            // If data returned from batteries was inconsistent, don't do anything intelligent.
            // Just divide the notifications evenly between the batteries as if they were
            // draining at the same rate.  This will most likely result in early notification,
            // but by that time the data on the batteries ought to have settled down.
            //
            delta = lowCapacityDelta/battCount;
        } else if (totalRate != 0) {
            delta = (ULONG) (((LONGLONG) lowCapacityDelta * batt->Info.Status.Rate) / totalRate);
        } else {

            //
            // If total rate is zero, we would expect no change in battery
            // capacity, so we should get notified of any.
            //

            delta = 0;
        }

        //
        // Check for underflow on low capacity
        //


        if (batt->Info.Status.Capacity > delta) {
            batt->Wait.LowCapacity  = batt->Info.Status.Capacity - delta;

        } else {
            //
            // If there is still some charge in the battery set the LowCapacity
            // alarm to 1, else to 0.
            //
            // No need to do that.  If this battery runs out, it doesn't
            // need to notify.  One of the other batteries will be notifying
            // right away.  If there isn't another battery, this shouldn't
            // happen.

            BattPrint (BATT_NOTE, ("CompBatt: Unexpectedly huge delta encountered.  \n"
                                    "    Capacity = %08x\n"
                                    "    LowCapcityDelta = %08x\n"
                                    "    Rate = %08x\n"
                                    "    TotalRate = %08x\n",
                                    batt->Info.Status.Capacity,
                                    lowCapacityDelta,
                                    batt->Info.Status.Rate,
                                    totalRate));
            batt->Wait.LowCapacity  = 0;
        }


        //
        // Adjust the HighCapacity alarm for charging batteries only
        //

        //
        // Calculate the portion of the composite battery delta that belongs to
        // this battery.
        //

        if (inconsistent) {
            delta = highCapacityDelta/battCount;
        } else if (totalRate != 0) {
            delta = (ULONG) (((LONGLONG) highCapacityDelta * batt->Info.Status.Rate) / totalRate);
        } else {

            //
            // If total rate is zero, we would expect no change in battery
            // capacity, so we should get notified of any.
            //

            delta = 0;
        }

        //
        // Check for overflow on high capacity.
        // Allow setting the percentage above full charged capacity
        // since some batteries do that when new.
        //

        if ((MAX_HIGH_CAPACITY - delta) < batt->Wait.HighCapacity) {
            batt->Wait.HighCapacity = MAX_HIGH_CAPACITY;
        } else {
            batt->Wait.HighCapacity = batt->Info.Status.Capacity + delta;
        }

        //
        // If we're currently waiting, and the parameters are in
        // conflict, get the irp back to reset it
        //

        if (batt->State == CB_ST_GET_STATUS &&
            (batt->Wait.PowerState != batt->IrpBuffer.Wait.PowerState       ||
            batt->Wait.LowCapacity != batt->IrpBuffer.Wait.LowCapacity       ||
            batt->Wait.HighCapacity != batt->IrpBuffer.Wait.HighCapacity)) {

            IoCancelIrp (batt->StatusIrp);
        }

        ExAcquireFastMutex (&compBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING SetStatusNotify\n"));

    return STATUS_SUCCESS;
}





NTSTATUS
CompBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to SmbBattSetStatusNotify.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PCOMPOSITE_BATTERY      compBatt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING DisableStatusNotify\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    //
    // Run through the list of batteries and disable the wait status params
    // Hold mutex for entire loop, since loop doesn't make any calls.

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        batt->Wait.LowCapacity  = MIN_LOW_CAPACITY;
        batt->Wait.HighCapacity = MAX_HIGH_CAPACITY;
    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING DisableStatusNotify\n"));

    return STATUS_SUCCESS;
}






NTSTATUS
CompBattGetBatteryInformation (
    IN PBATTERY_INFORMATION TotalBattInfo,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine loops through the batteries in the system and queries them
    for information. It then forms a composite representation of this
    information to send back to the caller.

Arguments:

    TotalBattInfo   - Buffer to place the composite battery information in

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    PBATTERY_INFORMATION        battInfo;
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    BATTERY_QUERY_INFORMATION   bInfo;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteryInformation\n"));

    TotalBattInfo->DefaultAlert1 = 0;
    TotalBattInfo->DefaultAlert2 = 0;
    TotalBattInfo->CriticalBias  = 0;

    status = STATUS_SUCCESS;

    //
    // Run through the list of batteries getting the information
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryInformation;
        bInfo.AtRate            = 0;
        battInfo                = &batt->Info.Info;

        if (batt->Info.Tag != BATTERY_TAG_INVALID) {
            if (!(batt->Info.Valid & VALID_INFO)) {

                //
                // issue IOCTL to device
                //

                RtlZeroMemory (battInfo, sizeof(BATTERY_INFORMATION));

                status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                       batt->DeviceObject,
                                       &bInfo,
                                       sizeof (bInfo),
                                       battInfo,
                                       sizeof (BATTERY_INFORMATION),
                                       FALSE);

                if (!NT_SUCCESS(status)) {
                    if (status == STATUS_DEVICE_REMOVED) {
                        //
                        // If one device is removed, that invalidates the tag.
                        //
                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    ExAcquireFastMutex (&CompBatt->ListMutex);
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                BattPrint (BATT_DATA, ("CompBattGetBatteryInformation: Read individual BATTERY_INFORMATION\n"
                                        "--------  Capabilities = %x\n"
                                        "--------  Technology = %x\n"
                                        "--------  Chemistry[4] = %x\n"
                                        "--------  DesignedCapacity = %x\n"
                                        "--------  FullChargedCapacity = %x\n"
                                        "--------  DefaultAlert1 = %x\n"
                                        "--------  DefaultAlert2 = %x\n"
                                        "--------  CriticalBias = %x\n"
                                        "--------  CycleCount = %x\n",
                                        battInfo->Capabilities,
                                        battInfo->Technology,
                                        battInfo->Chemistry[4],
                                        battInfo->DesignedCapacity,
                                        battInfo->FullChargedCapacity,
                                        battInfo->DefaultAlert1,
                                        battInfo->DefaultAlert2,
                                        battInfo->CriticalBias,
                                        battInfo->CycleCount)
                                       );

                batt->Info.Valid |= VALID_INFO;

            }   // if (!(batt->Info.Valid & VALID_INFO))

            //
            // Logically OR the capabilities
            //

            TotalBattInfo->Capabilities |= battInfo->Capabilities;


            //
            // Add the designed capacities.  If this is UNKNOWN (possible
            // with the control method batteries, don't add them in.
            //

            if (battInfo->DesignedCapacity != BATTERY_UNKNOWN_CAPACITY) {
                TotalBattInfo->DesignedCapacity    += battInfo->DesignedCapacity;
            }

            if (battInfo->FullChargedCapacity != BATTERY_UNKNOWN_CAPACITY) {
                TotalBattInfo->FullChargedCapacity += battInfo->FullChargedCapacity;
            }

            if (TotalBattInfo->DefaultAlert1 < battInfo->DefaultAlert1) {
                TotalBattInfo->DefaultAlert1 = battInfo->DefaultAlert1;
            }

            if (TotalBattInfo->DefaultAlert2 < battInfo->DefaultAlert2) {
                TotalBattInfo->DefaultAlert2 = battInfo->DefaultAlert2;
            }

            if (TotalBattInfo->CriticalBias  < battInfo->CriticalBias) {
                TotalBattInfo->CriticalBias  = battInfo->CriticalBias;
            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);

    //
    // Save the battery information in the composite battery cache
    //

    if (NT_SUCCESS(status)) {
        //
        // Check to see if we have an UNKNOWN full charge capacity.  If so, set this
        // to the design capacity.
        //

        if (TotalBattInfo->FullChargedCapacity == 0) {
            TotalBattInfo->FullChargedCapacity = TotalBattInfo->DesignedCapacity;
        }

        BattPrint (BATT_DATA, ("CompBattGetBatteryInformation: Returning BATTERY_INFORMATION\n"
                                "--------  Capabilities = %x\n"
                                "--------  Technology = %x\n"
                                "--------  Chemistry[4] = %x\n"
                                "--------  DesignedCapacity = %x\n"
                                "--------  FullChargedCapacity = %x\n"
                                "--------  DefaultAlert1 = %x\n"
                                "--------  DefaultAlert2 = %x\n"
                                "--------  CriticalBias = %x\n"
                                "--------  CycleCount = %x\n",
                                TotalBattInfo->Capabilities,
                                TotalBattInfo->Technology,
                                TotalBattInfo->Chemistry[4],
                                TotalBattInfo->DesignedCapacity,
                                TotalBattInfo->FullChargedCapacity,
                                TotalBattInfo->DefaultAlert1,
                                TotalBattInfo->DefaultAlert2,
                                TotalBattInfo->CriticalBias,
                                TotalBattInfo->CycleCount)
                               );

        RtlCopyMemory (&CompBatt->Info.Info, TotalBattInfo, sizeof(BATTERY_INFORMATION));
        CompBatt->Info.Valid |= VALID_INFO;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteryInformation\n"));

    return status;
}





NTSTATUS
CompBattGetBatteryGranularity (
    IN PBATTERY_REPORTING_SCALE GranularityBuffer,
    IN PCOMPOSITE_BATTERY        CompBatt
    )
/*++

Routine Description:

    The routine queries all the batteries in the system to get their granularity
    settings.  It then returns the setting that has the finest granularity in each range.

Arguments:

    GranularityBuffer   - Buffer for containing the results of the query

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    BATTERY_REPORTING_SCALE     localGranularity[4];
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    ULONG                       i;
    BATTERY_QUERY_INFORMATION   bInfo;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteryGranularity\n"));

    GranularityBuffer[0].Granularity = 0xFFFFFFFF;
    GranularityBuffer[1].Granularity = 0xFFFFFFFF;
    GranularityBuffer[2].Granularity = 0xFFFFFFFF;
    GranularityBuffer[3].Granularity = 0xFFFFFFFF;

    //
    // Run through the list of batteries getting the granularity
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt                    = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryGranularityInformation;

        if (batt->Info.Tag != BATTERY_TAG_INVALID) {
            //
            // issue IOCTL to device
            //

            RtlZeroMemory (&localGranularity[0], sizeof(localGranularity));

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   &localGranularity,
                                   sizeof (localGranularity),
                                   FALSE);

            if (!NT_SUCCESS(status)) {
                if (status == STATUS_DEVICE_REMOVED) {
                    //
                    // If one device is removed, that invalidates the tag.
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                }

                ExAcquireFastMutex (&CompBatt->ListMutex);
                CompbattReleaseDeleteLock(&batt->DeleteLock);
                break;
            }


            //
            // Check for the best granularity in each range.
            //

            for (i = 0; i < 4; i++) {

                if (localGranularity[i].Granularity) {

                    if (localGranularity[i].Granularity < GranularityBuffer[i].Granularity) {
                        GranularityBuffer[i].Granularity = localGranularity[i].Granularity;
                    }

                    GranularityBuffer[i].Capacity = localGranularity[i].Capacity;
                }

            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteryGranularity\n"));

    return STATUS_SUCCESS;
}





NTSTATUS
CompBattGetEstimatedTime (
    IN PULONG               TimeBuffer,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine queries all the batteries in the system to get their estimated time left.
    If one of the batteries in the system does not support this function then an error
    is returned.

Arguments:

    TimeBuffer   - Buffer for containing cumulative time left

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    LONG                        localBuffer = 0;
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    BATTERY_QUERY_INFORMATION   bInfo;
    BATTERY_STATUS              batteryStatus;
    LONG                        atRate = 0;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetEstimatedTime\n"));

    *TimeBuffer = BATTERY_UNKNOWN_TIME;

    //
    // Refresh the composite battery status cache if necessary.
    //

    status = CompBattQueryStatus (CompBatt, CompBatt->Info.Tag, &batteryStatus);

    if (!NT_SUCCESS(status)) {
        return status;
    }


    //
    // If we're on AC then our estimated run time is invalid.
    //

    if (CompBatt->Info.Status.PowerState & BATTERY_POWER_ON_LINE) {
        return STATUS_SUCCESS;
    }

    //
    // We are on battery power and may have more than one battery in the system.
    //
    // We need to find the total rate of power being drawn from all batteries
    // then we need to ask how long each battery would last at that rate (as
    // if they were being discharged one at a time).  This should give us a fairly
    // good measure of how long it will last.
    //
    // To find the power being drawn we read the devide the remaining capacity by
    // the estimated time rather than simply reading the rate.  This is because the
    // rate is theoretically the instantanious current wereas the estimated time
    // should be based on average usage.  This isn't the case for control method
    // batteries, but it is for smart batteries, and could be for others as well.
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        if (batt->Info.Valid & VALID_TAG) {

            bInfo.BatteryTag        = batt->Info.Tag;
            bInfo.InformationLevel  = BatteryEstimatedTime;
            bInfo.AtRate = 0;

            //
            // issue IOCTL to device
            //

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   &localBuffer,
                                   sizeof (localBuffer),
                                   FALSE);


            if ((localBuffer != BATTERY_UNKNOWN_TIME) &&
                (localBuffer != 0) &&
                (NT_SUCCESS(status))) {
                atRate -= ((long)batt->Info.Status.Capacity)*3600 / localBuffer;
                BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: EstTime: %08x, Capacity: %08x, cumulative AtRate: %08x\n", localBuffer, batt->Info.Status.Capacity, atRate));
            } else {
                BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: Bad Estimated time.  Status: %08x, localBuffer: %08x, Capacity: %08x, cumulative AtRate: %08x\n",
                        status, localBuffer, batt->Info.Status.Capacity, atRate));
            }
        }

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);

    }
    ExReleaseFastMutex (&CompBatt->ListMutex);


    BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: using atRate - %x\n", atRate));

    //
    // Did we find a battery?
    //
    if (atRate == 0) {
        // Code could be added to here to handle batteries that return
        // estimated runtime, but not rate information.

        return STATUS_SUCCESS;

    }

    //
    // Run through the list of batteries getting their estimated time
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryEstimatedTime;

        bInfo.AtRate = atRate;

        if (batt->Info.Valid & VALID_TAG) {
            //
            // issue IOCTL to device
            //

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   &localBuffer,
                                   sizeof (localBuffer),
                                   FALSE);

            BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: Status: %08x, EstTime: %08x\n", status, localBuffer));
            if (!NT_SUCCESS(status)) {

                //
                // This could be an invalid device request for this battery.
                // Continue with thte next battery.
                //

                if (status == STATUS_DEVICE_REMOVED) {
                    //
                    // If one device is removed, that invalidates the tag.
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                }

                ExAcquireFastMutex (&CompBatt->ListMutex);
                CompbattReleaseDeleteLock(&batt->DeleteLock);
                continue;

            }

            //
            // Add the estimated time.
            //
            if (localBuffer != BATTERY_UNKNOWN_TIME) {
                if (*TimeBuffer == BATTERY_UNKNOWN_TIME) {
                    *TimeBuffer = localBuffer;
                } else {
                    *TimeBuffer += localBuffer;
                }
            }
            BattPrint (BATT_DATA, ("CompBattGetEstimatedTime: cumulative time: %08x\n", *TimeBuffer));

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);


    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetEstimatedTime\n"));

    return STATUS_SUCCESS;
}




NTSTATUS
CompBattMonitorIrpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Constantly keeps an irp at the battery either querying for the tag or the
    status.  This routine fills in the irp, sets itself up as the completion
    routine, and then resends the irp.

Arguments:

    DeviceObject        - Device object for the battery sent the irp.
    Note: In this case DeviceObject is always NULL, so don't use it.

    Irp                 - Current irp to work with

    Context             - Currently unused

Return Value:

    TRUE if there are no changes, FALSE otherwise.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PCOMPOSITE_ENTRY        Batt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING MonitorIrpComplete\n"));

    IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    Batt            = IrpSp->Parameters.Others.Argument2;

    //
    // We always want to queue a work item to recycle the IRP.  There were too many
    // problems that could happen trying to recycle in the completion routine.
    //
    // If this driver ever gets reworked, it could be done that way, but it would take
    // more time to get right than I have now.  Queueing a work item is the safe thing
    // to do.
    //

    ExQueueWorkItem (&Batt->WorkItem, DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

VOID CompBattMonitorIrpCompleteWorker (
    IN PVOID Context
    )
/*++

Routine Description:

    This is either queued, or called by the completion routine.

    Constantly keeps an irp at the battery either querying for the tag or the
    status.  This routine fills in the irp, sets itself up as the completion
    routine, and then resends the irp.

Arguments:

    Context             - Composite battery entry.

Return Value:

    TRUE if there are no changes, FALSE otherwise.

--*/
{
    PCOMPOSITE_ENTRY        Batt = (PCOMPOSITE_ENTRY) Context;
    PDEVICE_OBJECT          DeviceObject = Batt->DeviceObject;
    PIRP                    Irp = Batt->StatusIrp;
    PIO_STACK_LOCATION      IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PCOMPOSITE_BATTERY      compBatt = IrpSp->Parameters.Others.Argument1;
    BATTERY_STATUS          battStatus;
    ULONG                   oldPowerState;
    NTSTATUS                status;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING MonitorIrpCompleteWorker\n"));

    IrpSp           = IoGetNextIrpStackLocation(Irp);

    //
    // Reissue irp to battery to wait for a status change
    //

    if (NT_SUCCESS(Irp->IoStatus.Status) || Irp->IoStatus.Status == STATUS_CANCELLED) {
        switch (Batt->State) {
            case CB_ST_GET_TAG:
                //
                // A battery was just inserted, so the IOCTL_BATTERY_Query_TAG completed.
                //

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: got tag for %x\n", Batt->DeviceObject));

                //
                // Update the tag, and wait on status
                //
                Batt->Wait.BatteryTag   = Batt->IrpBuffer.Tag;
                Batt->Info.Tag          = Batt->IrpBuffer.Tag;
                Batt->Info.Valid        = VALID_TAG;

                // Invalidate all cached info.
                compBatt->Info.Valid    = 0;

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                BatteryClassStatusNotify (compBatt->Class);
                break;


            case CB_ST_GET_STATUS:
                //
                // IOCTL_BATTERY_QUERY_STATUS just completed.  This could mean that the
                // battery state changed, or the charge has left the acceptable range.
                // If the battery was removed, it would not get here.
                //

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: got status for %x\n", Batt->DeviceObject));

                if (!(Irp->IoStatus.Status == STATUS_CANCELLED)) {

                    BattPrint (BATT_NOTE, ("Battery's state is\n"
                               "--------  PowerState   = %x\n"
                               "--------  Capacity     = %x\n"
                               "--------  Voltage      = %x\n"
                               "--------  Rate         = %x\n",
                               Batt->IrpBuffer.Status.PowerState,
                               Batt->IrpBuffer.Status.Capacity,
                               Batt->IrpBuffer.Status.Voltage,
                               Batt->IrpBuffer.Status.Rate)
                               );


                    //
                    // Battery status completed sucessfully.
                    // Update our wait, and wait some more
                    //

                    Batt->Wait.PowerState = Batt->IrpBuffer.Status.PowerState;

                    if (Batt->IrpBuffer.Status.Capacity != BATTERY_UNKNOWN_CAPACITY) {
                        if (Batt->Wait.HighCapacity < Batt->IrpBuffer.Status.Capacity) {
                            Batt->Wait.HighCapacity = Batt->IrpBuffer.Status.Capacity;
                        }

                        if (Batt->Wait.LowCapacity > Batt->IrpBuffer.Status.Capacity) {
                            Batt->Wait.LowCapacity = Batt->IrpBuffer.Status.Capacity;
                        }
                    } else {
                        BattPrint (BATT_DEBUG, ("CompBattMonitorIrpCompleteWorker: Unknown Capacity encountered.\n"));
                        Batt->Wait.LowCapacity = BATTERY_UNKNOWN_CAPACITY;
                        Batt->Wait.HighCapacity = BATTERY_UNKNOWN_CAPACITY;
                    }

                    RtlCopyMemory (&Batt->Info.Status, &Batt->IrpBuffer.Status, sizeof(BATTERY_STATUS));

                    //
                    // Set timestamp to Now.
                    //

                    Batt->Info.StatusTimeStamp = KeQueryInterruptTime ();

                    //
                    // Recalculate the charge/discharge policy and change if needed
                    //

                    // Don't change default BIOS policy for discharge.
                    // CompBattChargeDischarge (compBatt);

                    //
                    // Save the composite's old PowerState and recalculate the composites
                    // overall status.
                    //

                    oldPowerState                   = compBatt->Info.Status.PowerState;
                    compBatt->Info.StatusTimeStamp  = 0; // -CACHE_STATUS_TIMEOUT;        // Invalidate cache
                    CompBattQueryStatus (compBatt, compBatt->Info.Tag, &battStatus);

                    //
                    // Check to see if we need to send a notification on the composite
                    // battery.  This will be done in a couple of different cases:
                    //
                    //  -   There is a VALID_NOTIFY and there was a change in the composite's
                    //      PowerState, or it went below the Notify.LowCapacity, or it went
                    //      above the Notify.HighCapacity.
                    //
                    //  -   There is no VALID_NOTIFY (SetStatusNotify) and there was a change
                    //      in the composite's PowerState.
                    //

                    if (compBatt->Info.Valid & VALID_NOTIFY) {
                        if ((compBatt->Info.Status.PowerState != compBatt->Wait.PowerState)    ||
                            (compBatt->Info.Status.Capacity < compBatt->Wait.LowCapacity)      ||
                            (compBatt->Info.Status.Capacity > compBatt->Wait.HighCapacity)) {

                            BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                            BatteryClassStatusNotify (compBatt->Class);
                        }
                    } else {
                        if (compBatt->Info.Status.PowerState != oldPowerState) {
                            BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                            BatteryClassStatusNotify (compBatt->Class);
                        }
                    }

                } else {

                    BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: recycling cancelled status irp\n"));
                }
                break;

            default:
                BattPrint (BATT_ERROR, ("CompBatt: internal error - bad state\n"));
                break;
        }

        //
        // Set irp to issue query
        //

#if DEBUG
        if ((Batt->Wait.LowCapacity > 0xf0000000) && (Batt->Wait.LowCapacity != BATTERY_UNKNOWN_CAPACITY)) {
            BattPrint (BATT_ERROR, ("CompBattMonitorIrpCompleteWorker: LowCapacity < 0, LowCapacity =%x\n",
                       Batt->Wait.LowCapacity));
            ASSERT(FALSE);
        }
#endif

        Batt->State         = CB_ST_GET_STATUS;
        Batt->Wait.Timeout  = (ULONG) -1;
        RtlCopyMemory (&Batt->IrpBuffer.Wait, &Batt->Wait, sizeof (Batt->Wait));

        IrpSp->Parameters.DeviceIoControl.IoControlCode         = IOCTL_BATTERY_QUERY_STATUS;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength     = sizeof(Batt->IrpBuffer.Wait);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength    = sizeof(Batt->IrpBuffer.Status);

        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: waiting for status, Irp - %x\n", Irp));
        BattPrint (BATT_NOTE, ("--------  PowerState   = %x\n"
                               "--------  LowCapacity  = %x\n"
                               "--------  HighCapacity = %x\n",
                               Batt->Wait.PowerState,
                               Batt->Wait.LowCapacity,
                               Batt->Wait.HighCapacity)
                               );

    } else if (Irp->IoStatus.Status == STATUS_DEVICE_REMOVED) {

        //
        // If the Battery class driver returned STATUS_DEVICE_REMOVED, then the
        // device has been removed, so we need to quit sending IRPs.
        //

        BattPrint (BATT_NOTE, ("Compbatt: MonitorIrpCompleteWorker detected device removal.\n"));
        CompBattRemoveBattery (&Batt->BattName, compBatt);
        IoFreeIrp (Irp);

        return;

    } else {
        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: battery disappeared (status:%08x)\n",
                                Irp->IoStatus.Status));

        //
        // Invalidate the battery's tag, and the individual battery's cache, and
        // recalculate the composite's tag
        //

        Batt->Info.Tag          = BATTERY_TAG_INVALID;
        Batt->Info.Valid        = 0;
        compBatt->Info.Valid    = 0;
        compBatt->Info.StatusTimeStamp  = 0;        // Invalidate cache

        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
        BatteryClassStatusNotify (compBatt->Class);

        Batt->State = CB_ST_GET_TAG;
        IrpSp->Parameters.DeviceIoControl.IoControlCode         = IOCTL_BATTERY_QUERY_TAG;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength     = sizeof(ULONG);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength    = sizeof(ULONG);
        Batt->IrpBuffer.Tag = (ULONG) -1;


        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: getting tag (last error %x)\n",
                Irp->IoStatus.Status));

    }


    IrpSp->MajorFunction            = IRP_MJ_DEVICE_CONTROL;
    Irp->AssociatedIrp.SystemBuffer = &Batt->IrpBuffer;
    Irp->PendingReturned            = FALSE;
    Irp->Cancel                     = FALSE;

    IoSetCompletionRoutine (Irp, CompBattMonitorIrpComplete, NULL, TRUE, TRUE, TRUE);
    status = IoCallDriver (Batt->DeviceObject, Irp);
    BattPrint (BATT_NOTE, ("Compbatt: MonitorIrpCompleteWorker: CallDriver returned 0x%lx.\n", status));

    BattPrint (BATT_TRACE, ("CompBatt: EXITING MonitorIrpCompleteWorker\n"));

    return;
}






VOID
CompBattRecalculateTag (
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine checks to see if there is still a valid battery in the
    composite's list.  If so, the composite tag is bumped.  This also
    invalidates all but the composite's tag.

Arguments:

    CompBatt    - Composite device extension

Return Value:

    none

--*/
{
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING CompBattRecalculateTag\n"));


    //
    // Run through the list of batteries looking for one that is still good
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);


        if (batt->Info.Valid & VALID_TAG) {
            CompBatt->Info.Valid   |= VALID_TAG;
            CompBatt->Info.Tag      = CompBatt->NextTag++;
            break;
        }

        CompBatt->Info.Tag = BATTERY_TAG_INVALID;
    }
    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING CompBattRecalculateTag\n"));
}






VOID
CompBattChargeDischarge (
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine calculates which battery should be charging/discharging
    and attempts to make it so.  Policy is summarized below:

    CHARGING POLICY:
        The most charged battery that is also less than 90% of maximum capacity
        is charged first.

    DISCHARGING POLICY:
        The most discharged battery that is also more than 2% of empty is discharged
        first, until it is empty.

Arguments:

    CompBatt    - Composite device extension

Return Value:

    NONE.  Nobody really cares if this works or not, since it won't work on all batteries.

--*/
{
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    ULONG                       capacity;
    ULONG                       percentCapacity;
    ULONG                       targetCapacity;
    PCOMPOSITE_ENTRY            targetBattery;
    BATTERY_SET_INFORMATION     battSetInfo;
    NTSTATUS                    status;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING CompBattChargeDischarge\n"));

    targetBattery = NULL;

    //
    // Check if AC is present in the system.
    //

    if (CompBatt->Info.Status.PowerState & BATTERY_POWER_ON_LINE) {

        //
        // AC is present.  Examine all batteries, looking for the most
        // charged one that is less than 90% full.
        //

        targetCapacity = 0;
        battSetInfo.InformationLevel = BatteryCharge;

        ExAcquireFastMutex (&CompBatt->ListMutex);
        for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

            batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

            if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
                continue;
            }

            if (batt->Info.Valid & VALID_TAG) {

                //
                // Get the battery max capacity and current % of capacity
                //

                capacity = batt->Info.Info.FullChargedCapacity;
                if (capacity == 0) {
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                percentCapacity = (batt->Info.Status.Capacity * 100) / capacity;

                //
                // Is this the most charged battery AND < 90% full?
                //

                if ((capacity > targetCapacity) && (percentCapacity < BATTERY_MAX_CHARGE_CAPACITY)) {

                    //
                    // Yes, this one is in the running for the one to charge
                    //

                    targetCapacity = capacity;
                    targetBattery = batt;
                }
            }

            CompbattReleaseDeleteLock(&batt->DeleteLock);

        }
        ExReleaseFastMutex (&CompBatt->ListMutex);

        BattPrint (BATT_NOTE, ("CompBattChargeDischarge: Setting battery %x to CHARGE (AC present)\n",
                                targetBattery));

    } else {

        //
        // We are running on battery power.  Examine all batteries, looking
        // for the one with the least capacity that is greater than some small
        // safety margin (say 2%).
        //

        targetCapacity = -1;
        battSetInfo.InformationLevel = BatteryDischarge;

        ExAcquireFastMutex (&CompBatt->ListMutex);
        for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

            batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

            if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
                continue;
            }

            if (batt->Info.Valid & VALID_TAG) {

                //
                // Get the battery max capacity and current % of capacity
                //

                capacity = batt->Info.Info.FullChargedCapacity;
                if (capacity == 0) {
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                percentCapacity = (batt->Info.Status.Capacity * 100) / capacity;

                //
                // Is this the least charged battery AND has a safety margin?
                //

                if ((capacity < targetCapacity) && (percentCapacity > BATTERY_MIN_SAFE_CAPACITY)) {

                    //
                    // Yes, this one is in the running for the one to discharge
                    //

                    targetCapacity = capacity;
                    targetBattery = batt;
                }
            }

            CompbattReleaseDeleteLock(&batt->DeleteLock);

        }
        ExReleaseFastMutex (&CompBatt->ListMutex);

        BattPrint (BATT_NOTE, ("CompBattChargeDischarge: Setting battery %x to DISCHARGE (no AC)\n",
                                targetBattery));

    }

    //
    // If we have found a suitable battery, complete the setup and send off the Ioctl
    //

    if (targetBattery != NULL) {

        battSetInfo.BatteryTag = targetBattery->Info.Tag;

        //
        // Make the Ioctl to the battery.  This won't always be successful, since some
        // batteries don't support it.  For example, no control-method batteries support
        // software charging decisions.  Some smart batteries do, however.
        //

        status = BatteryIoctl (IOCTL_BATTERY_SET_INFORMATION,
                                batt->DeviceObject,
                                &battSetInfo,
                                sizeof (BATTERY_SET_INFORMATION),
                                NULL,
                                0,
                                FALSE);

    }


    BattPrint (BATT_TRACE, ("CompBatt: EXITING CompBattChargeDischarge\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\cmbtest\cmbtest.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <ntpoapi.h>

#include "..\cmbdrect.h"

//
// Prototypes
//

HANDLE InitDriver ( CHAR *NamePtr );



void Call_UID (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    UINT                Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_UID,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_UID Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_UID returned: 0x%08lx\n", Data);
    };

}


void Call_STA (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_STA,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_STA Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_STA returned: 0x%08lx\n", Data);
    };

}


void Call_PSR (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_PSR,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_PSR Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_PSR returned: 0x%08lx\n", Data);
    };

}


void Call_BTP (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    printf ("Enter the Trip Point value (Hex): ");
    scanf ("%x", &Data);
    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BTP,
                    &Data,                  // input buffer
                    sizeof (Data),
                    (PVOID) NULL,           // output buffer
                    0
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("\n_BTP Method failed.  Status = 0x%08lx\n", Status);
        printf("\nSet trip point to 0x%08lx failed.\n", Data);
    } else {
        printf("\nTrip point set to 0x%08lx\n", Data);
    };

}


void Call_BIF (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    CM_BIF_BAT_INFO             Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BIF,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_BIF Metod failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_BIF returned:\n");
        printf("  Power Unit = 0x%08lx\n", Data.PowerUnit);
        printf("  Design Capacity = 0x%08lx\n", Data.DesignCapacity);
        printf("  Last Full Charge Capacity = 0x%08lx\n", Data.LastFullChargeCapacity);
        printf("  Battery Technology = 0x%08lx\n", Data.BatteryTechnology);
        printf("  Design Voltage = 0x%08lx\n", Data.DesignVoltage);
        printf("  Design Capacity Of Warning = 0x%08lx\n", Data.DesignCapacityOfWarning);
        printf("  Design Capacity Of Low = 0x%08lx\n", Data.DesignCapacityOfLow);
        printf("  Battery Capacity Granularity 1 (low -> warning) = 0x%08lx\n", Data.BatteryCapacityGran_1);
        printf("  Battery Capacity Granularity 2 (warning -> full) = 0x%08lx\n", Data.BatteryCapacityGran_2);
        printf("  Model number = \"%s\"\n", Data.ModelNumber);
        printf("  Serial number = \"%s\"\n", Data.SerialNumber);
        printf("  Battery Type = \"%s\"\n", Data.BatteryType);
        printf("  OEM Information = \"%s\"\n", Data.OEMInformation);
    };

}


void Call_BST (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    CM_BST_BAT_INFO             Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BST,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_BST Metod failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_BST returned:\n");
        printf("  Battery Status = 0x%08lx\n", Data.BatteryState);
        printf("  Present Rate = 0x%08lx\n", Data.PresentRate);
        printf("  Remaining Capacity = 0x%08lx\n", Data.RemainingCapacity);
        printf("  Present Voltage = 0x%08lx\n", Data.PresentVoltage);
    };

}


int
__cdecl
main(USHORT argc, CHAR **argv)
{
    CHAR *NamePtr;
    ULONG cmd;
    HANDLE DriverHandle;

    if (argc > 1) {
        NamePtr=argv[1];
    } else {
        NamePtr = "ControlMethodBattery1";
    }

    //
    // Locate driver
    //

    if (!(DriverHandle = InitDriver (NamePtr))) {
        printf ("CmBatt not found\n");
        exit (1);
    }


    while (1) {
        printf("\n\nOptions: (1)_UID  (2)_STA  (3)_PSR  (4)_BTP  (5)_BIF  (6)_BST\n");
        printf(    ">>>>>>>> ");
        if (scanf ("%d", &cmd) != 1) {
            return (0);
            printf("\n\n");
        };
        printf("\n");
        switch (cmd) {
        case 1 :
            Call_UID (DriverHandle);
            break;
        case 2 :
            Call_STA (DriverHandle);
            break;
        case 3 :
            Call_PSR (DriverHandle);
            break;
        case 4 :
            Call_BTP (DriverHandle);
            break;
        case 5 :
            Call_BIF (DriverHandle);
            break;
        case 6 :
            Call_BST (DriverHandle);
            break;
        }
    }


}



HANDLE
InitDriver (
    CHAR *NamePtr
)
{
    UNICODE_STRING              DriverName;
    ANSI_STRING                 AnsiName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       strbuf[100];
    HANDLE DriverHandle;

    SYSTEM_POWER_CAPABILITIES   powerCapabilities;

    if (NT_SUCCESS (NtPowerInformation (SystemPowerCapabilities, 
                                        NULL, 
                                        0, 
                                        &powerCapabilities, 
                                        sizeof (SYSTEM_POWER_CAPABILITIES)
                                        ))) {
        printf("NtPowerInformation returned: \n"
               "  SystemBatteriesPresent = %d\n"
               "  BatteriesAreShortTerm = %d\n",
               powerCapabilities.SystemBatteriesPresent,
               powerCapabilities.BatteriesAreShortTerm);
    }


    
    sprintf (strbuf, "\\Device\\%s",NamePtr);

    RtlInitAnsiString(&AnsiName, strbuf);

    RtlAnsiStringToUnicodeString(&DriverName, &AnsiName, TRUE);

    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        printf ("Device name %s Error 0x%08lx\n", strbuf, status);
        return NULL;
    } else {
        printf ("Opened Device name %s\n", strbuf);
        return DriverHandle;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\cmbatt\testapp\cmbattst.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <poclass.h>

//
// global handles
//

UCHAR           Usage[] = "batt: \n";
HANDLE          DriverHandle;
ULONG           BatteryTag;
#define RANGE   1

//
// Prototypes
//

BOOLEAN
InitDriver ( CHAR *NamePtr );


int
Nib (
    UCHAR   c
    )
{
    if (c >= '0' &&  c <= '9') {
        return c - '0';
    }

    if (c >= 'A' &&  c <= 'F') {
        return c - 'A' + 10;
    }

    if (c >= 'a' &&  c <= 'f') {
        return c - 'a' + 10;
    }

    printf ("Invalid hex value\n");
    return 0;
}



int
htoi (
    PUCHAR  s
    )
{
    ULONG   i;
    UCHAR   c;

    i = Nib(s[0]);
    if (s[1]) {
        i = i << 4 | Nib(s[1]);
    }
    return i;
}

VOID
GetBatteryTag (
    VOID
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;


    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_TAG,
                    NULL,                   // input buffer
                    0,
                    &BatteryTag,            // output buffer
                    sizeof (BatteryTag)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Battery tag not available. Status = %x\n", Status);
        BatteryTag = 0xffffffff;
    }
}


VOID
GetBatteryInfo (
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;

    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_INFORMATION,
                    &BInfo,                 // input buffer
                    sizeof (BInfo),
                    Buffer,                 // output buffer
                    BufferLength
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Query battery information failed. Level %x. Status = %x\n", Level, Status);
    }
}

VOID
GetBatteryStatus (
    IN  PBATTERY_WAIT_STATUS    WaitStatus,
    OUT PBATTERY_STATUS         BatteryStatus
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;

    memset (BatteryStatus, 0xAB, sizeof(BatteryStatus));

    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_STATUS,
                    WaitStatus,            // input buffer
                    sizeof (BATTERY_WAIT_STATUS),
                    BatteryStatus,         // output buffer
                    sizeof (BATTERY_STATUS)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Query battery status failed. Status = %x\n", Status);
        return ;
    }

    // dump battery status

    printf ("Power State.........: %08x\n",      BatteryStatus->PowerState);
    printf ("Capacity............: %08x  %d\n",  BatteryStatus->Capacity, BatteryStatus->Capacity);
    printf ("Voltage.............: %08x  %d\n",  BatteryStatus->Voltage,  BatteryStatus->Voltage);
    printf ("Current.,,,,,,,,,...: %08x  %d\n",  BatteryStatus->Current,  BatteryStatus->Current);
    printf ("\n");
}




int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG                   BattTag;
    BATTERY_INFORMATION     BInfo;
    ULONG                   BETime;
    WCHAR                   BDeviceName[50];
    UCHAR                   BManDate[50];
    WCHAR                   BManName[50];
    ULONG                   BETemp;
    WCHAR                   BEUID [50];
    ULONG                   BEGran[4];
    BATTERY_WAIT_STATUS     WStat;
    BATTERY_STATUS          BStat;
    CHAR *NamePtr;

    if (argc > 1) {
        NamePtr=argv[1];
    } else {
        NamePtr = "CmBatt";
    }

    //
    // Locate pentium perf driver
    //

    if (!InitDriver (NamePtr)) {
        printf ("CmBatt not found\n");
        exit (1);
    }


    GetBatteryTag ();
    printf ("Battery Tag.........: %x\n", BatteryTag);

    //
    // Get generic info
    //

    GetBatteryInfo (BatteryInformation,     &BInfo,       sizeof(BInfo));
    GetBatteryInfo (BatteryEstimatedTime,   &BETime,      sizeof(BETime));
    GetBatteryInfo (BatteryDeviceName,       BDeviceName, sizeof(BDeviceName));
    GetBatteryInfo (BatteryManufactureDate,  BManDate,    sizeof(BManDate));
    GetBatteryInfo (BatteryManufactureName,  BManName,    sizeof(BManName));
    GetBatteryInfo (BatteryTemperature,     &BETemp,      sizeof(BETemp));
    GetBatteryInfo (BatteryUniqueID,         BEUID,       sizeof(BEUID));
    GetBatteryInfo (BatteryGranularityInformation, BEGran, sizeof(BEGran));

    // dump it...
    printf ("Capabilities........: %08x\n",  BInfo.Capabilities);
    printf ("Technology..........: %02x\n",  BInfo.Technology);
    printf ("Chemisttry..........: %4.4s\n", BInfo.Chemistry);
    printf ("Designed Capacity...: %08x\n",  BInfo.DesignedCapacity);
    printf ("FullCharged Capacity: %08x\n",  BInfo.FullChargedCapacity);
    printf ("Default Alert1......: %08x\n",  BInfo.DefaultAlert1);
    printf ("Default Alert2......: %08x\n",  BInfo.DefaultAlert2);
    printf ("Critical Bias.......: %08x\n",  BInfo.CriticalBias);
    printf ("Cycle Count.........: %08x\n",  BInfo.CycleCount);
    printf ("Granularity.........: %x %x %x %x\n", BEGran[0], BEGran[1], BEGran[2], BEGran[3]);
    printf ("Temapture...........: %08x\n",  BETemp);
    wprintf (L"Unique ID...........: %s\n",    BEUID);

    printf ("Estimated Time......: %08x\n",  BETime);
    wprintf (L"Device Name.........: %s\n",  BDeviceName);
    printf ("Manufacture Date....: %d %d %d %d\n",  BManDate[0], BManDate[1], BManDate[2], BManDate[3]);
    wprintf (L"Manufacture Name....: %s\n",  BManName);

    printf ("\n");

    memset (&WStat, 0, sizeof(WStat));
    WStat.BatteryTag = BatteryTag;

    GetBatteryStatus (&WStat, &BStat);

    // Now that we've got the state, let's perform a long term status change request
    WStat.PowerState = BStat.PowerState;
    WStat.LowCapacity = BStat.Capacity - RANGE;
    WStat.HighCapacity = BStat.Capacity + RANGE;
    WStat.Timeout = 50000000;  // 5 min
    GetBatteryStatus (&WStat, &BStat);
}



BOOLEAN
InitDriver (
    CHAR *NamePtr
)
{
    UNICODE_STRING              DriverName;
    ANSI_STRING                 AnsiName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       strbuf[100];

    sprintf (strbuf, "\\Device\\%s",NamePtr);

    RtlInitAnsiString(&AnsiName, strbuf);

    RtlAnsiStringToUnicodeString(&DriverName, &AnsiName, TRUE);

    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        printf ("Device name %s Error %x\n", strbuf, status);
        return FALSE;
    } else {
        printf ("Opened Device name %s\n", strbuf);
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\compbatt\comppnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Comppnp.c

Abstract:

    Composite Battery PnP and power functions

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include "compbatt.h"

#include <initguid.h>
#include <wdmguid.h>
#include <batclass.h>




NTSTATUS
CompBattPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler for the plug and play irps.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    PCOMPOSITE_BATTERY      compBatt        = (PCOMPOSITE_BATTERY)DeviceObject->DeviceExtension;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING PnpDispatch\n"));

    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE: {
            //
            // Register for Pnp notification of batteries coming and going
            //

            status = IoRegisterPlugPlayNotification(
                            EventCategoryDeviceInterfaceChange,
                            0,
                            (LPGUID)&GUID_DEVICE_BATTERY,
                            DeviceObject->DriverObject,
                            CompBattPnpEventHandler,
                            compBatt,
                            &compBatt->NotificationEntry
                            );

            if (!NT_SUCCESS(status)) {
                BattPrint (BATT_ERROR, ("CompBatt: Couldn't register for PnP notification - %x\n", status));

            } else {
                BattPrint (BATT_NOTE, ("CompBatt: Successfully registered for PnP notification\n"));

                //
                // Get the batteries that are already present in the system
                //

                status = CompBattGetBatteries (compBatt);
            }

            break;
        }

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            //
            // Prevent device from being manually uninstalled.
            //
            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE: {
		    status = STATUS_INVALID_DEVICE_REQUEST;
    		break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL: {
    		status = STATUS_SUCCESS;
	    	break;
        }
    }

    //
    // Rules for handling PnP IRPs:
    // 1) Don't change the status of any IRP we don't handle. We identify
    //    IRPs we don't handle via the code STATUS_NOT_SUPPORTED. This is
    //    the same code all PNP irps start out with, and as we are not allowed
    //    to fail IRPs with that code, it is the perfect choice to use this
    //    way.
    // 2) Pass down all IRPs that we succeed or do not touch. Immediately
    //    complete any failures (excepting STATUS_NOT_SUPPORTED of course).
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver(compBatt->LowerDevice, Irp) ;

    } else {

        status = Irp->IoStatus.Status ;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING PnpDispatch\n"));

    return status;
}





NTSTATUS
CompBattPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler for the power irps.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PCOMPOSITE_BATTERY compBatt = (PCOMPOSITE_BATTERY)DeviceObject->DeviceExtension;

    BattPrint (BATT_TRACE, ("CompBatt: PowerDispatch recieved power IRP.\n"));

    Irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);

    return PoCallDriver(compBatt->LowerDevice, Irp) ;
}






NTSTATUS
CompBattPnpEventHandler(
    IN PVOID NotificationStructure,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles Plug and Play event notifications.  The only ones that
    have been asked for are device interface changes associated with batteries,
    so we will only receive notifications when batteries come and go (provided
    they register their device interface).

Arguments:

    NotificationStructure   - This will be type PDEVICE_INTERFACE_CHANGE_NOTIFICATION

    Context                 - The composite battery device extension

Return Value:

    STATUS_SUCCESS

--*/
{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   changeNotification;
    PCOMPOSITE_BATTERY                      compBatt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING PnpEventHandler\n"));

    compBatt            = (PCOMPOSITE_BATTERY) Context;
    changeNotification  = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;


    BattPrint(BATT_NOTE, ("CompBatt: Received device interface change notification\n"));

    if (IsEqualGUID(&changeNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        BattPrint(BATT_NOTE, ("CompBatt: Received notification of battery arrival\n"));
        CompBattAddNewBattery (changeNotification->SymbolicLinkName, compBatt);

    } else if (IsEqualGUID(&changeNotification->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {

        BattPrint (BATT_NOTE, ("CompBatt: Received notification of battery removal\n"));

        //
        // Nothing to do here.  MonitorIrpComplete will do cleanup when it's requests fail
        // with STATUS_DEVICE_REMOVED.
        //

    } else {

        BattPrint (BATT_NOTE, ("CompBatt: Received unhandled PnP event\n"));
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING PnpEventHandler\n"));

    return STATUS_SUCCESS;

}

NTSTATUS
CompBattRemoveBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine removes an existing battery from the list of batteries kept by the
    composite battery.

Arguments:

    SymbolicLinkName    - Name used to check if battery is on list
                          and to close the battery if so.

    CompBatt            - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_ENTRY        Battery;

    // NonPaged code.  This is called by an Irp completion routine.

    BattPrint (BATT_TRACE, ("CompBatt: RemoveBattery\n"));

    //
    // Remove the battery from the list if it is there.
    //

    Battery = RemoveBatteryFromList (SymbolicLinkName, CompBatt);

    if(!Battery) {

        //
        // removed ok if not on list
        //

        return STATUS_SUCCESS;
    }

    //
    // Deallocate the Work Item.
    //

    ObDereferenceObject(Battery->DeviceObject);

    ExFreePool (Battery);

    // Invalidate cached Battery info and send notification
    CompBatt->Info.Valid = 0;
    BatteryClassStatusNotify (CompBatt->Class);

    return STATUS_SUCCESS;
}


NTSTATUS
CompBattAddNewBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine adds a new battery to the list of batteries kept by the
    composite battery.

Arguments:

    SymbolicLinkName    - Name used to check if battery is already on list
                          and to open the battery if not.

    CompBatt            - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_ENTRY        newBattery;
    PUNICODE_STRING         battName;
    PFILE_OBJECT            fileObject;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    newIrp;
    BOOLEAN                 onList;

    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING AddNewBattery \"%w\" \n", SymbolicLinkName->Buffer));

    //
    // Lock the list and see if this new battery is on it
    //

    onList = IsBatteryAlreadyOnList (SymbolicLinkName, CompBatt);

    if (!onList) {

        //
        // Create the node for the new battery
        //

        newBattery = ExAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof (COMPOSITE_ENTRY) + SymbolicLinkName->Length,
                            'CtaB'
                            );

        if (!newBattery) {
            BattPrint (BATT_ERROR, ("CompBatt: Couldn't allocate new battery node\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AddNewBatteryClean1;
        }


        //
        // Initialize the new battery
        //

        RtlZeroMemory (newBattery, sizeof (COMPOSITE_ENTRY));

        newBattery->Info.Tag    = BATTERY_TAG_INVALID;
        newBattery->NewBatt     = TRUE;

        battName                = &newBattery->BattName;
        battName->MaximumLength = SymbolicLinkName->Length;
        battName->Buffer        = (PWCHAR)(battName + 1);

        RtlCopyUnicodeString (battName, SymbolicLinkName);


        //
        // Get the device object.
        //

        status = CompBattGetDeviceObjectPointer(SymbolicLinkName,
                                                FILE_ALL_ACCESS,
                                                &fileObject,
                                                &newBattery->DeviceObject
                                                );

        if (!NT_SUCCESS(status)) {
            BattPrint (BATT_ERROR, ("CompBattAddNewBattery: Failed to get device Object. status = %lx\n", status));
            goto AddNewBatteryClean2;
        }

        //
        // Increment the reference count to the device object of the battery
        //

        ObReferenceObject(newBattery->DeviceObject);

        //
        // Decrement reference count to file handle,
        // so batteries will not refuse removal requests.
        //

        ObDereferenceObject(fileObject);

        //
        // Allocate a status Irp for the new battery
        //

        newIrp = IoAllocateIrp ((UCHAR)(newBattery->DeviceObject->StackSize + 1), FALSE);

        if (!newIrp) {
            BattPrint (BATT_ERROR, ("CompBatt: Couldn't allocate new battery Irp\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AddNewBatteryClean3;
        }

        newBattery->StatusIrp = newIrp;


        //
        // Setup control data on irp
        //

        irpSp = IoGetNextIrpStackLocation(newIrp);
        irpSp->Parameters.Others.Argument1 = (PVOID) CompBatt;
        irpSp->Parameters.Others.Argument2 = (PVOID) newBattery;

        //
        // Fill in irp so irp handler will re-dispatch it
        //

        IoSetNextIrpStackLocation (newIrp);

        irpSp                   = IoGetNextIrpStackLocation(newIrp);
        newIrp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        newBattery->State       = CB_ST_GET_TAG;

        CompbattInitializeDeleteLock (&newBattery->DeleteLock);

        //
        // Put Battery onthe battery list before starting the
        // MonitorIrpComplete loop.
        //

        ExAcquireFastMutex (&CompBatt->ListMutex);
        InsertTailList (&CompBatt->Batteries, &newBattery->Batteries);
        ExReleaseFastMutex (&CompBatt->ListMutex);

        //
        // Initialize Work Item
        //

         ExInitializeWorkItem (&newBattery->WorkItem, CompBattMonitorIrpCompleteWorker, newBattery);

        //
        // Start Monitoring Battery
        //

        CompBattMonitorIrpComplete (newBattery->DeviceObject, newIrp, NULL);

        status = STATUS_SUCCESS;
    }

    goto AddNewBatteryClean1;

AddNewBatteryClean3:
    ObReferenceObject(newBattery->DeviceObject);

AddNewBatteryClean2:
    ExFreePool (newBattery);

AddNewBatteryClean1:

    BattPrint (BATT_TRACE, ("CompBatt: EXITING AddNewBattery\n"));

    return status;
}





NTSTATUS
CompBattGetBatteries(
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine uses the PnP manager to get all the batteries that have already
    registered their interfaces (that we won't get notifications for) and then
    adds them to the list of batteries.

Arguments:

    CompBatt        - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      tmpString;
    PWSTR               stringPointer;
    int                 i;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteries\n"));

    //
    // Call the PnP manager to get the list of devices already register for the
    // battery class.
    //

    status = IoGetDeviceInterfaces(
                    &GUID_DEVICE_BATTERY,
                    NULL,
                    0,
                    &stringPointer
                    );


    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("CompBatt: Couldn't get list of batteries\n"));

    } else {
        //
        // Now parse the list and try to add them to the composite battery list
        //

        i = 0;
        RtlInitUnicodeString (&tmpString, &stringPointer[i]);

        while (tmpString.Length) {

            status = CompBattAddNewBattery (&tmpString, CompBatt);
            i += (tmpString.Length / sizeof(WCHAR)) + 1;
            RtlInitUnicodeString (&tmpString, &stringPointer[i]);
        }

        ExFreePool (stringPointer);

    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteries\n"));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\acpisym\acpisym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    acpisym.c

--*/

#include <ntos.h>
#include <pci.h>
#include <dockintf.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>
#include <ntacpi.h>
#include <arbiter.h>
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "amlipriv.h"
#include "ctxt.h"
#include "amldebug.h"
#include "acpios.h"
#include "ospower.h"
#include "callback.h"
#include "acpi.h"
#include "acpidbg.h"
#include "acpiregs.h"
#include "devioctl.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpictl.h"
#include "acpienbl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpiterm.h"
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "..\nt\irqarb.h"

DESCRIPTION_HEADER                  descriptionheader;
FADT                                fadt;
RSDP                                rsdp;
FACS                                facs;
RSDT                                rsdt;
ACPIInformation                     acpiinformation;
RSDTELEMENT                         rsdtelem;
OBJDATA                             objdata;
PACKAGEOBJ                          packageobj;
FIELDUNITOBJ                        fieldunitobj;
METHODOBJ                           methodobj;
POWERRESOBJ                         powerresobj;
PROCESSOROBJ                        processorobj;
BUFFFIELDOBJ                        bufferfieldobj;
NSOBJ                               nsobj;
OPREGIONOBJ                         opregionobj;
DEVICE_EXTENSION                    deviceextension;
RSDTINFORMATION                     rsdtinformation;
ULONG                               ulong;
VECTOR_BLOCK                        vectorblock;
ARBITER_EXTENSION                   arbiterextension;
LINK_NODE                           linknode;
LINK_NODE_ATTACHED_DEVICES          linknodeattacheddevices;
PROCLOCALAPIC                       proclocalapic;
DBGR                                dbgr;
LIST                                list;
CTXTQ                               ctxtq;
ULONG                               gdwfAMLIInit;
BRKPT                               brkpt;
CALL                                call;
RESOURCE                            resource;
HEAP                                heap;
HEAPOBJHDR                          heapobjhdr;

int cdecl main() {
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\acpisym\makefile.inc ===
$(O)\acpi.c : acpisym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amldebug.c ===
/*** amldebug.c - AML Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"
#include <stdio.h>
#include <stdarg.h>

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DebugHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                     PPNSOBJ ppns, PULONG pdwOffset);
BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue);
LONG LOCAL AddBrkPt(PUCHAR pbBrkPt);
LONG LOCAL ClearBrkPt(int iBrkPt);
LONG LOCAL SetBrkPtState(int iBrkPt, BOOLEAN fEnable);
LONG LOCAL EnableDisableBP(PSZ pszArg, BOOLEAN fEnable);
LONG LOCAL DebugBC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugBD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugBE(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugBL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugBP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugClearLog(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                         ULONG dwNonSWArgs);
LONG LOCAL DumpData(ULONG_PTR uipAddr, ULONG dwfUnitSize, ULONG dwLen,
                    BOOLEAN fPhysical);
LONG LOCAL DebugDumpData(PCMDARG pArg, PSZ pszArg, ULONG dwfDataSize);
LONG LOCAL DebugD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDB(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDA(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
#ifdef DEBUG
LONG LOCAL DebugDC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDumpHeap(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                         ULONG dwNonSWArgs);
VOID LOCAL DumpHeap(PHEAP pheap);
#endif
LONG LOCAL DebugDumpLog(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs);
LONG LOCAL DebugDumpStack(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs);
VOID LOCAL DumpStack(PCTXT pctxt, BOOLEAN fVerbose);
LONG LOCAL DebugDumpNameSpace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                              ULONG dwNonSWArgs);
LONG LOCAL DebugDumpObject(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
LONG LOCAL DebugEditMem(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs);
LONG LOCAL DebugFindNSObj(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs);
BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PNSOBJ pnsRoot);
LONG LOCAL InPort(ULONG dwPort, ULONG dwSize, PULONG pdwData);
LONG LOCAL DebugInPort(PSZ pszArg, ULONG dwSize);
LONG LOCAL DebugI(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugIW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugID(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugQuit(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugListCtxts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs);
LONG LOCAL DebugLN(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugNotify(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs);
LONG LOCAL OutPort(ULONG dwPort, ULONG dwSize, ULONG dwData);
LONG LOCAL DebugOutPort(PSZ pszArg, ULONG dwSize);
LONG LOCAL DebugO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugOW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugOD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
VOID LOCAL PrintSymbol(PUCHAR pb);
LONG LOCAL DebugTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugStep(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
VOID LOCAL DumpContext(PCTXT pctxt);
LONG LOCAL DebugDumpContext(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                            ULONG dwNonSWArgs);
LONG LOCAL DebugSet(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs);
LONG LOCAL DebugSetLogSize(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
LONG LOCAL DebugUnAsm(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs);
LONG LOCAL DebugRunMethod(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs);
VOID EXPORT RunMethodCallBack(PNSOBJ pns, NTSTATUS rc, POBJDATA pdata,
                              PVOID pvContext);
VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj);
BOOLEAN LOCAL FindObjSymbol(PUCHAR pbOp, PPNSOBJ ppns, PULONG pdwOffset);

/*** Exported data
 */

DBGR gDebugger = {0};


/*** Local data
 */

ULONG dwCmdArg = 0;

CMDARG ArgsHelp[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugHelp,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBC[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugBC,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBD[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugBD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBE[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugBE,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBP[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugBP,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsD[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugD,
    NULL, AT_ACTION, 0, NULL, 0, DebugD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDB[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDB,
    NULL, AT_ACTION, 0, NULL, 0, DebugDB,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDW[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDW,
    NULL, AT_ACTION, 0, NULL, 0, DebugDW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDD[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDD,
    NULL, AT_ACTION, 0, NULL, 0, DebugDD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDA[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDA,
    NULL, AT_ACTION, 0, NULL, 0, DebugDA,
    NULL, AT_END, 0, NULL, 0, NULL
};

#ifdef DEBUG
CMDARG ArgsDumpHeap[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugDumpHeap,
    NULL, AT_END, 0, NULL, 0, NULL
};
#endif

CMDARG ArgsDumpStack[] =
{
  #ifdef DEBUG
    "v", AT_ENABLE, 0, &dwCmdArg, DSF_VERBOSE, NULL,
  #endif
    NULL, AT_ACTION, 0, NULL, 0, DebugDumpStack,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDNS[] =
{
    "s", AT_ENABLE, 0, &dwCmdArg, DNSF_RECURSE, NULL,
    NULL, AT_ACTION, 0, NULL, 0, DebugDumpNameSpace,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDumpObject[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugDumpObject,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsEditMem[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugEditMem,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsFindNS[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugFindNSObj,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsI[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugI,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsIW[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugIW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsID[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugID,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsLN[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugLN,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsNotify[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugNotify,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsO[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugO,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsOW[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugOW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsOD[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugOD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDumpCtxt[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugDumpContext,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsRunMethod[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugRunMethod,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsSetOptions[] =
{
    "traceon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_AMLTRACE_ON, NULL,
    "traceoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_AMLTRACE_ON, NULL,
    "spewon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_DEBUG_SPEW_ON, NULL,
    "spewoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_DEBUG_SPEW_ON, NULL,
    "nesttraceon", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_TRACE_NONEST, NULL,
    "nesttraceoff", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_TRACE_NONEST, NULL,
    "lbrkon", AT_ENABLE, 0, &gdwfAMLIInit, AMLIIF_LOADDDB_BREAK, NULL,
    "lbrkoff", AT_DISABLE, 0, &gdwfAMLIInit, AMLIIF_LOADDDB_BREAK, NULL,
    "errbrkon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_ERRBREAK_ON, NULL,
    "errbrkoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_ERRBREAK_ON, NULL,
    "verboseon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_VERBOSE_ON, NULL,
    "verboseoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_VERBOSE_ON, NULL,
    "logon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_LOGEVENT_ON, NULL,
    "logoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_LOGEVENT_ON, NULL,
    "logmuton", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_LOGEVENT_MUTEX, NULL,
    "logmutoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_LOGEVENT_MUTEX, NULL,
    "logsize", AT_NUM, AF_SEP, &dwCmdArg, 10, DebugSetLogSize,
    NULL, AT_END, 0, NULL, 0, NULL
};

#ifdef TRACING
CMDARG ArgsSetTrace[] =
{
    "trigon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_TRIGGER_MODE, NULL,
    "trigoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_TRIGGER_MODE, NULL,
    "level", AT_NUM, AF_SEP, &giTraceLevel, 0, NULL,
    "add", AT_STRING, AF_SEP, &gpszTrigPts, 0, AddTraceTrigPts,
    "zap", AT_STRING, AF_SEP, &gpszTrigPts, 0, ZapTraceTrigPts,
    NULL, AT_END, 0, NULL, 0, NULL
};
#endif

CMDARG ArgsUnAsm[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugUnAsm,
    NULL, AT_END, 0, NULL, 0, NULL
};

DBGCMD DbgCmds[] =
{
    "?", 0, ArgsHelp, DebugHelp,
    "bc", 0, ArgsBC, DebugBC,
    "bd", 0, ArgsBD, DebugBD,
    "be", 0, ArgsBE, DebugBE,
    "bl", 0, NULL, DebugBL,
    "bp", 0, ArgsBP, DebugBP,
    "cl", 0, NULL, DebugClearLog,
    "d", 0, ArgsD, DebugD,
    "db", 0, ArgsDB, DebugDB,
    "dw", 0, ArgsDW, DebugDW,
    "dd", 0, ArgsDD, DebugDD,
    "da", 0, ArgsDA, DebugDA,
  #ifdef DEBUG
    "dc", 0, NULL, DebugDC,
    "dh", 0, ArgsDumpHeap, DebugDumpHeap,
  #endif
    "dl", 0, NULL, DebugDumpLog,
    "ds", 0, ArgsDumpStack, DebugDumpStack,
    "dns", 0, ArgsDNS, DebugDumpNameSpace,
    "do", 0, ArgsDumpObject, DebugDumpObject,
    "e", 0, ArgsEditMem, DebugEditMem,
    "find", 0, ArgsFindNS, DebugFindNSObj,
    "g", CMDF_QUIT, NULL, NULL,
    "i", 0, ArgsI, DebugI,
    "iw", 0, ArgsIW, DebugIW,
    "id", 0, ArgsID, DebugID,
    "lc", 0, NULL, DebugListCtxts,
    "ln", 0, ArgsLN, DebugLN,
    "notify", 0, ArgsNotify, DebugNotify,
    "o", 0, ArgsO, DebugO,
    "ow", 0, ArgsOW, DebugOW,
    "od", 0, ArgsOD, DebugOD,
    "p", 0, NULL, DebugStep,
    "q", 0, NULL, DebugQuit,
    "r", 0, ArgsDumpCtxt, DebugDumpContext,
    "run", 0, ArgsRunMethod, DebugRunMethod,
    "set", 0, ArgsSetOptions, DebugSet,
    "t", 0, NULL, DebugTrace,
  #ifdef TRACING
    "trace", 0, ArgsSetTrace, SetTrace,
  #endif
    "u", 0, ArgsUnAsm, DebugUnAsm,
    NULL, 0, NULL, NULL
};

/***EP  AMLIDebugger - AMLI Debugger
 *
 *  ENTRY
 *      fCallFromVxD - debugger is invoked by the VxD .. command.
 *
 *  EXIT
 *      None
 */

VOID STDCALL AMLIDebugger(BOOLEAN fCallFromVxD)
{
    if (!(gDebugger.dwfDebugger & DBGF_IN_KDSHELL))
    {
        if (fCallFromVxD)
        {
            gDebugger.dwfDebugger |= DBGF_IN_VXDMODE;
        }
        else
        {
            gDebugger.dwfDebugger &= ~DBGF_IN_VXDMODE;
        }

        gDebugger.dwfDebugger |= DBGF_IN_DEBUGGER;
        Debugger(DbgCmds, "\n" MODNAME "(? for help)-> ");
        gDebugger.dwfDebugger &= ~(DBGF_IN_DEBUGGER | DBGF_IN_VXDMODE);
    }
    else
    {
        PRINTF("\nRe-entering AML debugger is not allowed.\n"
               "Type 'g' to go back to the AML debugger.\n");
    }
}       //AMLIDebugger

/***LP  DebugHelp - help
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User typed ? <cmd>
    //
    if (pszArg != NULL)
    {
        if (STRCMP(pszArg, "?") == 0)
        {
            PRINTF("\nHelp:\n");
            PRINTF("Usage: ? [<Cmd>]\n");
            PRINTF("<Cmd> - command to get help on\n");
        }
        else if (STRCMP(pszArg, "bc") == 0)
        {
            PRINTF("\nClear Breakpoints:\n");
            PRINTF("Usage: bc <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bd") == 0)
        {
            PRINTF("\nDisable Breakpoints:\n");
            PRINTF("Usage: bd <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "be") == 0)
        {
            PRINTF("\nEnable Breakpoints:\n");
            PRINTF("Usage: be <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bl") == 0)
        {
            PRINTF("\nList All Breakpoints:\n");
            PRINTF("Usage: bl\n");
        }
        else if (STRCMP(pszArg, "bp") == 0)
        {
            PRINTF("\nSet BreakPoints:\n");
            PRINTF("Usage: bp <MethodName> | <CodeAddr> ...\n");
            PRINTF("<MethodName> - full path of method name to have breakpoint set at\n");
            PRINTF("<CodeAddr>   - address of AML code to have breakpoint set at\n");
        }
        else if (STRCMP(pszArg, "cl") == 0)
        {
            PRINTF("\nClear Event Log:\n");
            PRINTF("Usage: cl\n");
        }
        else if (STRCMP(pszArg, "d") == 0)
        {
            PRINTF("\nDump Data:\n");
            PRINTF("Usage: d [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "db") == 0)
        {
            PRINTF("\nDump Data Bytes:\n");
            PRINTF("Usage: db [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "dw") == 0)
        {
            PRINTF("\nDump Data Words:\n");
            PRINTF("Usage: dw [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "dd") == 0)
        {
            PRINTF("\nDump Data DWords:\n");
            PRINTF("Usage: dd [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address rangein hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "da") == 0)
        {
            PRINTF("\nDump Data String:\n");
            PRINTF("Usage: da [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
      #ifdef DEBUG
        else if (STRCMP(pszArg, "dc") == 0)
        {
            PRINTF("\nDump Memory Object Count Table:\n");
            PRINTF("Usage: dc\n");
        }
        else if (STRCMP(pszArg, "dh") == 0)
        {
            PRINTF("\nDump Heap:\n");
            PRINTF("Usage: dh [<Addr>]\n");
            PRINTF("<Addr> - address of the heap block, global heap if missing\n");
        }
      #endif
        else if (STRCMP(pszArg, "dl") == 0)
        {
            PRINTF("\nDump Event Log:\n");
            PRINTF("Usage: dl\n");
        }
        else if (STRCMP(pszArg, "ds") == 0)
        {
            PRINTF("\nDump Stack:\n");
          #ifdef DEBUG
            PRINTF("Usage: ds [/v] [<Addr>]\n");
            PRINTF("v - enable versbos mode\n");
          #else
            PRINTF("Usage: ds [<Addr>]\n");
          #endif
            PRINTF("<Addr> - address of the context block, use current context if missing\n");
        }
        else if (STRCMP(pszArg, "dns") == 0)
        {
            PRINTF("\nDump Name Space Object:\n");
            PRINTF("Usage: dns [[/s] [<NameStr> | <Addr>]]\n");
            PRINTF("s         - recursively dump the name space subtree\n");
            PRINTF("<NameStr> - name space path (dump whole name space if absent)\n");
            PRINTF("<Addr>    - specify address of the name space object\n");
        }
        else if (STRCMP(pszArg, "do") == 0)
        {
            PRINTF("\nDump Data Object:\n");
            PRINTF("Usage: do <Addr>\n");
            PRINTF("<Addr> - address of the data object\n");
        }
        else if (STRCMP(pszArg, "e") == 0)
        {
            PRINTF("\nEdit Memory:\n");
            PRINTF("Usage: e [<Addr> [<DataList>]]\n");
            PRINTF("<Addr>     - memory address (physical address if prefixed by \"%%\")\n");
            PRINTF("<DataList> - list of data separated by spaces, "
                   "data can be a byte or a string\n");
        }
        else if (STRCMP(pszArg, "find") == 0)
        {
            PRINTF("\nFind NameSpace Object:\n");
            PRINTF("Usage: find <NameSeg>\n");
            PRINTF("<NameSeg> - Name of the NameSpace object without path\n");
        }
        else if (STRCMP(pszArg, "g") == 0)
        {
            PRINTF("\nQuit debugger, continue normal execution.\n");
        }
        else if (STRCMP(pszArg, "i") == 0)
        {
            PRINTF("\nRead Data From a Byte Port:\n");
            PRINTF("Usage: i <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "iw") == 0)
        {
            PRINTF("\nRead Data From a Word Port:\n");
            PRINTF("Usage: iw <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "id") == 0)
        {
            PRINTF("\nRead Data From a DWord Port:\n");
            PRINTF("Usage: id <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "lc") == 0)
        {
            PRINTF("\nList All Contexts:\n");
            PRINTF("Usage: lc\n");
        }
        else if (STRCMP(pszArg, "ln") == 0)
        {
            PRINTF("\nDisplay Nearest Method Name:\n");
            PRINTF("Usage: ln [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else if (STRCMP(pszArg, "notify") == 0)
        {
            PRINTF("\nNotify a NameSpace Object:\n");
            PRINTF("Usage: notify <Obj> <Value>\n");
            PRINTF("<Obj>   - full NameSpace path of object or its address\n");
            PRINTF("<Value> - notification value\n");
        }
        else if (STRCMP(pszArg, "o") == 0)
        {
            PRINTF("\nWrite Data to a Byte Port:\n");
            PRINTF("Usage: o <Port> <Byte>\n");
            PRINTF("<Port> - port address\n");
            PRINTF("<Byte> - data to be written\n");
        }
        else if (STRCMP(pszArg, "ow") == 0)
        {
            PRINTF("\nWrite Data to a Word Port:\n");
            PRINTF("Usage: ow <Port> <Word>\n");
            PRINTF("<Port> - port address\n");
            PRINTF("<Word> - data to be written\n");
        }
        else if (STRCMP(pszArg, "od") == 0)
        {
            PRINTF("\nWrite Data to a DWord Port:\n");
            PRINTF("Usage: o <Port> <DWord>\n");
            PRINTF("<Port>  - port address\n");
            PRINTF("<DWord> - data to be written\n");
        }
        else if (STRCMP(pszArg, "p") == 0)
        {
            PRINTF("\nStep over AML Code\n");
            PRINTF("Usage: p\n");
        }
        else if (STRCMP(pszArg, "q") == 0)
        {
            PRINTF("\nQuit to kernel debugger:\n");
            PRINTF("Usage: q\n");
        }
        else if (STRCMP(pszArg, "r") == 0)
        {
            PRINTF("\nDisplay Context Information:\n");
            PRINTF("Usage: r\n");
        }
        else if (STRCMP(pszArg, "run") == 0)
        {
            PRINTF("\nRun a Method:\n");
            PRINTF("Usage: run <MethodName> | <CodeAddr> [<ArgList>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of method\n");
            PRINTF("<ArgList>    - list of integer arguments\n");
        }
        else if (STRCMP(pszArg, "set") == 0)
        {
            PRINTF("\nSet Debugger Options:\n");
            PRINTF("Usage: set [traceon | traceoff] [nesttraceon | nesttraceoff] [spewon | spewoff]\n"
                   "           [lbrkon | lbrkoff] [errbrkon | errbrkoff] [verboseon | verboseoff]\n"
                   "           [logon | logoff] [logmuton | logmutoff] [logsize=<MaxNumEvents>]\n");
            PRINTF("traceon      - turn on AML tracing\n");
            PRINTF("traceoff     - turn off AML tracing\n");
            PRINTF("nesttraceon  - turn on nest tracing (only valid with traceon)\n");
            PRINTF("nesttraceoff - turn off nest tracing (only valid with traceon)\n");
            PRINTF("spewon       - turn on debug spew\n");
            PRINTF("spewoff      - turn off debug spew\n");
            PRINTF("lbrkon       - enable load DDB completion break\n");
            PRINTF("lbrkoff      - disable load DDB completion break\n");
            PRINTF("errbrkon     - enable break on error\n");
            PRINTF("errbrkoff    - disable break on error\n");
            PRINTF("verboseon    - enable verbose mode\n");
            PRINTF("verboseoff   - disable verbose mode\n");
            PRINTF("logon        - enable event logging\n");
            PRINTF("logoff       - disable event logging\n");
            PRINTF("logmuton     - enable mutex event logging\n");
            PRINTF("logmutoff    - disable mutex event logging\n");
            PRINTF("logsize      - set event log size (default 128)\n");
        }
        else if (STRCMP(pszArg, "t") == 0)
        {
            PRINTF("\nTrace Into AML Code:\n");
            PRINTF("Usage: t\n");
        }
      #ifdef TRACING
        else if (STRCMP(pszArg, "trace") == 0)
        {
            PRINTF("\nInterpreter Trace Mode:\n");
            PRINTF("Usage: trace [trigon] [trigoff] [level=<n>] [add=<TrigPtStr>] [zap=<TrigPtList>]\n");
            PRINTF("trigon       - turn on trace trigger mode\n");
            PRINTF("trigoff      - turn off trace trigger mode\n");
            PRINTF("level        - set trace level to <n>\n");
            PRINTF("add          - add trace trigger points\n");
            PRINTF("<TrigPtStr>  - list of trigger point strings separated by commas\n");
            PRINTF("zap          - zap trace trigger points\n");
            PRINTF("<TrigPtList> - list of trigger point numbers separated by commas\n");
        }
      #endif
        else if (STRCMP(pszArg, "u") == 0)
        {
            PRINTF("\nUnassemble AML code:\n");
            PRINTF("Usage: u [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else
        {
            DBG_ERROR(("invalid help command - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    //
    // User typed just a "?" without any arguments
    //
    else if (dwArgNum == 0)
    {
        PRINTF("\n");
        PRINTF("Help                     - ? [<Cmd>]\n");
        PRINTF("Clear Breakpoints        - bc <bp list> | *\n");
        PRINTF("Disable Breakpoints      - bd <bp list> | *\n");
        PRINTF("Enable Breakpoints       - be <bp list> | *\n");
        PRINTF("List Breakpoints         - bl\n");
        PRINTF("Set Breakpoints          - bp <MethodName> | <CodeAddr> ...\n");
        PRINTF("Clear Event Log          - cl\n");
        PRINTF("Dump Data                - d [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data Bytes          - db [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data Words          - dw [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data DWords         - dd [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data String         - da [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Event Log           - dl\n");
      #ifdef DEBUG
        PRINTF("Dump Object Count Table  - dc\n");
        PRINTF("Dump Heap                - dh [<Addr>]\n");
        PRINTF("Dump Stack               - ds [/v] [<Addr>]\n");
      #else
        PRINTF("Dump Stack               - ds [<Addr>]\n");
      #endif
        PRINTF("Dump Name Space Object   - dns [[/s] [<NameStr> | <Addr>]]\n");
        PRINTF("Dump Data Object         - do <Addr>\n");
        PRINTF("Edit Memory              - e [<Addr> [<DataList>]]\n");
        PRINTF("Find NameSpace Object    - find <NameSeg>\n");
        PRINTF("Continue Execution       - g\n");
        PRINTF("Read Byte from Port      - i <Port>\n");
        PRINTF("Read Word from Port      - iw <Port>\n");
        PRINTF("Read DWord from Port     - id <Port>\n");
        PRINTF("List All Contexts        - lc\n");
        PRINTF("Display Nearest Method   - ln [<MethodName> | <CodeAddr>]\n");
        PRINTF("Notify NameSpace Object  - notify <Obj> <Value>\n");
        PRINTF("Write Byte to Port       - o <Port> <Byte>\n");
        PRINTF("Write Word to Port       - ow <Port> <Word>\n");
        PRINTF("Write DWord to Port      - od <Port> <DWord>\n");
        PRINTF("Step Over AML Code       - p\n");
        PRINTF("Quit to Kernel Debugger  - q\n");
        PRINTF("Display Context Info.    - r\n");
        PRINTF("Run Method               - run <MethodName> | <CodeAddr> [<ArgList>]\n");
        PRINTF("Set Debugger Options     - set [traceon | traceoff] [nesttraceon | nesttraceoff]\n"
               "                               [spewon | spewoff] [lbrkon | lbrkoff] \n"
               "                               [errbrkon | errbrkoff] [verboseon | verboseoff] \n"
               "                               [logon | logoff] [logmuton | logmutoff] \n"
               "                               [logsize=<MaxNumEvents>]\n");
        PRINTF("Trace Into AML Code      - t\n");
      #ifdef TRACING
        PRINTF("Interpreter Trace Mode   - trace [trigon] [trigoff] [level=<n>]\n"
               "                                 [add=<TrigPtStr] [zap=<TrigPtList>]\n");
      #endif
        PRINTF("Unassemble AML code      - u [<MethodName> | <CodeAddr>]\n");
    }

    return rc;
}       //DebugHelp

/***LP  DebugExpr - Parse debugger expression
 *
 *  ENTRY
 *      pszArg -> expression argument
 *      puipValue -> to hold the result of expression
 *      pfPhysical -> set to TRUE if the expression is a physical address
 *                    (NULL if don't allow physical address)
 *      ppns -> to hold the pointer of the nearest pns object
 *      pdwOffset -> to hold the offset of the address to the nearest pns object
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL DebugExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                     PPNSOBJ ppns, PULONG pdwOffset)
{
    LONG rc = DBGERR_NONE;
    PNSOBJ pns = NULL;
    ULONG dwOffset = 0;

    if (pfPhysical != NULL)
        *pfPhysical = FALSE;

    if ((pfPhysical != NULL) && (pszArg[0] == '%') && (pszArg[1] == '%'))
    {
        if (IsNumber(&pszArg[2], 16, puipValue))
        {
            *pfPhysical = TRUE;
        }
        else
        {
            DBG_ERROR(("invalid physical address - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (!IsNumber(pszArg, 16, puipValue))
    {
        STRUPR(pszArg);
        if ((GetNameSpaceObject(pszArg, NULL, &pns, NSF_LOCAL_SCOPE) ==
             STATUS_SUCCESS) &&
            (pns->ObjData.dwDataType == OBJTYPE_METHOD))
        {
            *puipValue = (ULONG_PTR)
                        (((PMETHODOBJ)pns->ObjData.pbDataBuff)->abCodeBuff);
        }
        else
        {
            DBG_ERROR(("object not found or object is not a method - %s",
                       pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (FindObjSymbol((PUCHAR)*puipValue, &pns, &dwOffset))
    {
        if ((pns->ObjData.dwDataType != OBJTYPE_METHOD) ||
            (dwOffset >= pns->ObjData.dwDataLen -
                         FIELD_OFFSET(METHODOBJ, abCodeBuff)))
        {
            pns = NULL;
            dwOffset = 0;
        }
    }

    if (rc == DBGERR_NONE)
    {
        if (ppns != NULL)
            *ppns = pns;

        if (pdwOffset != NULL)
            *pdwOffset = dwOffset;
    }

    return rc;
}       //DebugExpr

/***LP  IsNumber - Check if string is a number, if so return the number
 *
 *  ENTRY
 *      pszStr -> string
 *      dwBase - base
 *      puipValue -> to hold the number
 *
 *  EXIT-SUCCESS
 *      returns TRUE - the string is a number
 *  EXIT-FAILURE
 *      returns FALSE - the string is not a number
 */

BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue)
{
    BOOLEAN rc;
    PSZ psz;

    *puipValue = (ULONG_PTR)STRTOUL(pszStr, &psz, dwBase);
    if ((psz != pszStr) && (*psz == '\0'))
        rc = TRUE;
    else
        rc = FALSE;

    return rc;
}       //IsNumber

/***LP  AddBrkPt - Add breakpoint
 *
 *  ENTRY
 *      pbBrkPt - breakpoint
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL AddBrkPt(PUCHAR pbBrkPt)
{
    LONG rc = DBGERR_NONE;
    int i, iBrkPt;

    for (i = 0, iBrkPt = -1; i < MAX_BRK_PTS; ++i)
    {
        if ((pbBrkPt == gDebugger.BrkPts[i].pbBrkPt) ||
            (iBrkPt == -1) && (gDebugger.BrkPts[i].pbBrkPt == NULL))
        {
            iBrkPt = i;
        }
    }

    if (iBrkPt == -1)
    {
        DBG_ERROR(("no free breakpoint"));
        rc = DBGERR_CMD_FAILED;
    }
    else if (gDebugger.BrkPts[iBrkPt].pbBrkPt == NULL)
    {
        gDebugger.BrkPts[iBrkPt].pbBrkPt = pbBrkPt;
        gDebugger.BrkPts[iBrkPt].dwfBrkPt = BPF_ENABLED;
    }

    return rc;
}       //AddBrkPt

/***LP  ClearBrkPt - Clear breakpoint
 *
 *  ENTRY
 *      iBrkPt - breakpoint number
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL ClearBrkPt(int iBrkPt)
{
    LONG rc;

    if (iBrkPt < MAX_BRK_PTS)
    {
        MEMZERO(&gDebugger.BrkPts[iBrkPt], sizeof(BRKPT));
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid breakpoint number"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //ClearBrkPt

/***LP  SetBrkPtState - Enable/Disable breakpoint
 *
 *  ENTRY
 *      iBrkPt - breakpoint number
 *      fEnable - enable breakpoint
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL SetBrkPtState(int iBrkPt, BOOLEAN fEnable)
{
    LONG rc;

    if (iBrkPt < MAX_BRK_PTS)
    {
        if (gDebugger.BrkPts[iBrkPt].pbBrkPt != NULL)
        {
            if (fEnable)
                gDebugger.BrkPts[iBrkPt].dwfBrkPt |= BPF_ENABLED;
            else
                gDebugger.BrkPts[iBrkPt].dwfBrkPt &= ~BPF_ENABLED;
        }
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid breakpoint number"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //SetBrkPtState

/***LP  EnableDisableBP - Enable/Disable BreakPoints
 *
 *  ENTRY
 *      pszArg -> argument string
 *      fEnable - TRUE if enable breakpoints
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL EnableDisableBP(PSZ pszArg, BOOLEAN fEnable)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    if (pszArg != NULL)
    {
        ULONG dwBrkPt;

        if (STRCMP(pszArg, "*") == 0)
        {
            for (dwBrkPt = 0; dwBrkPt < MAX_BRK_PTS; ++dwBrkPt)
            {
                if ((rc = SetBrkPtState((int)dwBrkPt, fEnable)) != DBGERR_NONE)
                    break;
            }
        }
        else if (IsNumber(pszArg, 10, (PULONG_PTR)&dwBrkPt))
        {
            rc = SetBrkPtState((int)dwBrkPt, fEnable);
        }
        else
        {
            DBG_ERROR(("invalid breakpoint number"));
            rc = DBGERR_INVALID_CMD;
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid breakpoint command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //EnableDisableBP

/***LP  DebugBC - Clear BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugBC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG dwBrkPt;

        if (STRCMP(pszArg, "*") == 0)
        {
            for (dwBrkPt = 0; dwBrkPt < MAX_BRK_PTS; ++dwBrkPt)
            {
                if ((rc = ClearBrkPt((int)dwBrkPt)) != DBGERR_NONE)
                    break;
            }
        }
        else if (IsNumber(pszArg, 10, (PULONG_PTR)&dwBrkPt))
        {
            rc = ClearBrkPt((int)dwBrkPt);
        }
        else
        {
            DBG_ERROR(("invalid breakpoint number"));
            rc = DBGERR_INVALID_CMD;
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid breakpoint command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugBC

/***LP  DebugBD - Disable BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugBD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = EnableDisableBP(pszArg, FALSE);

    return rc;
}       //DebugBD

/***LP  DebugBE - Enable BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugBE(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = EnableDisableBP(pszArg, TRUE);

    return rc;
}       //DebugBE

/***LP  DebugBL - List BreakPoints
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugBL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        int i;
        PNSOBJ pns;
        ULONG dwOffset;

        for (i = 0; i < MAX_BRK_PTS; ++i)
        {
            if (gDebugger.BrkPts[i].pbBrkPt != NULL)
            {
                PRINTF("%2d: <%c> %08x",
                       i,
                       (gDebugger.BrkPts[i].dwfBrkPt & BPF_ENABLED)? 'e': 'd',
                       gDebugger.BrkPts[i].pbBrkPt);
                if (FindObjSymbol(gDebugger.BrkPts[i].pbBrkPt, &pns, &dwOffset))
                {
                    PRINTF(" [%s", GetObjectPath(pns));
                    if (dwOffset != 0)
                    {
                        PRINTF(" + %x]\n", dwOffset);
                    }
                    else
                    {
                        PRINTF("]\n");
                    }
                }
                else
                {
                    PRINTF("\n");
                }
            }
        }
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid breakpoint command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugBL

/***LP  DebugBP - Set BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugBP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        PUCHAR pbBrkPt;

        if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pbBrkPt, NULL, NULL, NULL)) ==
            DBGERR_NONE)
        {
            rc = AddBrkPt(pbBrkPt);
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid breakpoint command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugBP

/***LP  DebugClearLog - Clear event log
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugClearLog(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                         ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        if (gDebugger.pEventLog != NULL)
        {
            MEMZERO(gDebugger.pEventLog, sizeof(EVENTLOG)*gDebugger.dwLogSize);
            gDebugger.dwLogIndex = 0;
            rc = DBGERR_NONE;
        }
        else
        {
            DBG_ERROR(("no event log allocated"));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid CL command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugClearLog

/***LP  DumpData - Dump data
 *
 *  ENTRY
 *      uipAddr - data address
 *      dwfUnitSize - DBGF_DUMPDATA_MASK flags
 *      dwLen - length of data range
 *      fPhysical - TRUE if uipAddr is a physical address
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DumpData(ULONG_PTR uipAddr, ULONG dwfUnitSize, ULONG dwLen,
                    BOOLEAN fPhysical)
{
    LONG rc = DBGERR_NONE;
    PUCHAR pbData = NULL;
    PSZ pszPrefix = "";

    gDebugger.dwfDebugger &= ~(DBGF_DUMPDATA_MASK | DBGF_DUMPDATA_PHYADDR);
    gDebugger.dwfDebugger |= dwfUnitSize;
    if (fPhysical)
    {
        gDebugger.dwfDebugger |= DBGF_DUMPDATA_PHYADDR;
        pszPrefix = "%%";
        if (MapUnmapPhysMem(NULL, uipAddr, dwLen, (PULONG_PTR)&pbData) !=
            STATUS_SUCCESS)
        {
            DBG_ERROR(("Failed to map physical address %x", uipAddr));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
        pbData = (PUCHAR)uipAddr;

    if (ASSERTRANGE(pbData, dwLen))
    {
        if (dwfUnitSize == DBGF_DUMPDATA_STRING)
        {
            gDebugger.uipDumpDataAddr = uipAddr;
            PRINTF("%s%08x: ", pszPrefix, uipAddr);
            while ((dwLen > 0) && (*pbData != '\0'))
            {
                PRINTF("%c",
                       ((*pbData >= ' ') && (*pbData <= '~'))? *pbData: '.');
                pbData++;
                dwLen--;
            }
            PRINTF("\n");
        }
        else
        {
            PUCHAR pbEnd = pbData + dwLen;
            ULONG dwDataSize = DATASIZE(dwfUnitSize);
            int i;

            for (i = 0; pbData < pbEnd;)
            {
                if (i == 0)
                    PRINTF("%s%08x: ", pszPrefix, uipAddr);
                else if ((i == 8) && (dwDataSize == sizeof(UCHAR)))
                    PRINTF("-");
                else
                    PRINTF(" ");

                switch (dwDataSize)
                {
                    case sizeof(UCHAR):
                        PRINTF("%02x", *pbData);
                        break;

                    case sizeof(USHORT):
                        PRINTF("%04x", *((PUSHORT)pbData));
                        break;

                    case sizeof(ULONG):
                        PRINTF("%08x", *((PULONG)pbData));
                }

                pbData += dwDataSize;
                uipAddr += (ULONG_PTR)dwDataSize;
                i += (int)dwDataSize;
                if (i == 0x10)
                {
                    if (dwDataSize == sizeof(UCHAR))
                    {
                        UCHAR b;

                        PRINTF(" ");
                        for (i = 0x10; i > 0; --i)
                        {
                            b = *(pbData - i);
                            PRINTF("%c", ((b >= ' ') && (b <= '~'))? b: '.');
                        }
                    }
                    i = 0;
                    PRINTF("\n");
                }
            }
            gDebugger.uipDumpDataAddr = uipAddr;
        }
    }
    else
    {
        DBG_ERROR(("invalid address %08x", uipAddr));
        rc = DBGERR_INVALID_CMD;
    }

    if (fPhysical && (pbData != NULL))
    {
        MapUnmapPhysMem(NULL, (ULONG_PTR)pbData, dwLen, NULL);
    }

    return rc;
}       //DumpData

/***LP  DebugDumpData - Dump data to debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpData(PCMDARG pArg, PSZ pszArg, ULONG dwfDataSize)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;
    #define DEF_LEN 0x80
    static ULONG dwLen = DEF_LEN;

    if (pszArg != NULL)
    {
        if ((pArg != NULL) && (pArg->dwArgType == AT_NUM))
        {
            dwLen = dwCmdArg;
        }
        else
        {
            ULONG_PTR uipAddr;
            BOOLEAN fPhysical;

            if (((rc = DebugExpr(pszArg, &uipAddr, &fPhysical, NULL, NULL)) ==
                 DBGERR_NONE) &&
                ((rc = DumpData(uipAddr, dwfDataSize, dwLen, fPhysical)) ==
                 DBGERR_NONE))
            {
                fProcessed = TRUE;
            }
        }
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            rc = DumpData(gDebugger.uipDumpDataAddr, dwfDataSize, dwLen,
                          (BOOLEAN)((gDebugger.dwfDebugger &
                                     DBGF_DUMPDATA_PHYADDR) != 0));
        }
        dwLen = DEF_LEN;
    }

    return rc;
}       //DebugDumpData

/***LP  DebugD - Dump data
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg,
                       gDebugger.dwfDebugger & DBGF_DUMPDATA_MASK);

    return rc;
}       //DebugD

/***LP  DebugDB - Dump data bytes
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDB(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_BYTE);

    return rc;
}       //DebugDB

/***LP  DebugDW - Dump data words
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_WORD);

    return rc;
}       //DebugDW

/***LP  DebugDD - Dump data dwords
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_DWORD);

    return rc;
}       //DebugDD

/***LP  DebugDA - Dump data string
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDA(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_STRING);

    return rc;
}       //DebugDA

#ifdef DEBUG
/***LP  DebugDC - Dump memory object count table
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        DumpMemObjCounts();
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid dump object count command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugDC

/***LP  DebugDumpHeap - Dump heap
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpHeap(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                         ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fAddr = FALSE;
    static PHEAP pheap = NULL;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if (!fAddr)
        {
            if (IsNumber(pszArg, 16, (PULONG_PTR)&pheap) &&
                ASSERTRANGE(pheap, sizeof(HEAP)))
            {
                fAddr = TRUE;
            }
            else
            {
                DBG_ERROR(("invalid heap block address - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("invalid dump heap command"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        if (!fAddr)
        {
            pheap = gpheapGlobal;
        }

        if (pheap->dwSig != SIG_HEAP)
        {
            DBG_ERROR(("invalid heap block at %x", pheap));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            for (pheap = pheap->pheapHead;
                 pheap != NULL;
                 pheap = pheap->pheapNext)
            {
                DumpHeap(pheap);
            }
        }

        fAddr = FALSE;
    }

    return rc;
}       //DebugDumpHeap

/***LP  DumpHeap - Dump heap block
 *
 *  ENTRY
 *      pheap -> HEAP
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpHeap(PHEAP pheap)
{
    PHEAPOBJHDR phobj;

    ASSERT(pheap->dwSig == SIG_HEAP);
    PRINTF("HeapBlock=%08x, HeapEnd=%08x, HeapHead=%08x, HeapNext=%08x\n",
           pheap, pheap->pbHeapEnd, pheap->pheapHead, pheap->pheapNext);
    PRINTF("HeapTop=%08x, HeapFreeList=%08x, UsedHeapSize=%d bytes\n",
           pheap->pbHeapTop, pheap->plistFreeHeap,
           pheap->pbHeapTop - (PUCHAR)&pheap->Heap);

    for (phobj = &pheap->Heap;
         (PUCHAR)phobj < pheap->pbHeapTop;
         phobj = (PHEAPOBJHDR)((PUCHAR)phobj + phobj->dwLen))
    {
        PRINTF("%08x: %s, Len=%08d, Prev=%08x, Next=%08x\n",
               phobj, (phobj->dwSig == 0)? "free": NameSegString(phobj->dwSig),
               phobj->dwLen, (phobj->dwSig == 0)? phobj->list.plistPrev: 0,
               (phobj->dwSig == 0)? phobj->list.plistNext: 0);
    }
}       //DumpHeap
#endif

/***LP  DebugDumpStack - Dump stack
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpStack(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fAddr = FALSE;
    static PCTXT pctxt = NULL;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if (!fAddr)
        {
            if (IsNumber(pszArg, 16, (PULONG_PTR)&pctxt) &&
                ASSERTRANGE(pctxt, sizeof(CTXT)))
            {
                fAddr = TRUE;
            }
            else
            {
                DBG_ERROR(("invalid context block address %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("invalid dump stack command"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        if (!fAddr)
        {
            pctxt = gReadyQueue.pctxtCurrent;
        }

        if ((pctxt == NULL) || (pctxt->dwSig != SIG_CTXT))
        {
            DBG_ERROR(("no current context or invalid context block at %x",
                       pctxt));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            DumpStack(pctxt, (BOOLEAN)((dwCmdArg & DSF_VERBOSE) != 0));
        }

        dwCmdArg = 0;
        fAddr = FALSE;
    }

    return rc;
}       //DebugDumpStack

/***LP  DebugDumpLog - Dump event log
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpLog(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs)
{
    LONG         rc;
    TIME_FIELDS  eventTime;
    LARGE_INTEGER eventTimeInt;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        DBG_ERROR(("invalid DL command"));
        rc = DBGERR_INVALID_CMD;
    }
    else if (gDebugger.pEventLog == NULL)
    {
        DBG_ERROR(("no event log allocated"));
        rc = DBGERR_CMD_FAILED;
    }
    else
    {
        ULONG i;
        PEVENTLOG plog;
        PNSOBJ pns;
        ULONG dwOffset;

        PRINTF("\n");
        for (i = gDebugger.dwLogIndex;;) {

            if (gDebugger.pEventLog[i].dwEvent != 0) {
                plog = &gDebugger.pEventLog[i];

                eventTimeInt.QuadPart = plog->ullTime;
                RtlTimeToTimeFields( &eventTimeInt, &eventTime );
                PRINTF(
                    "%d:%02d:%02d.%03d: [%8x]",
                    eventTime.Hour,
                    eventTime.Minute,
                    eventTime.Second,
                    eventTime.Milliseconds,
                    plog->uipData1
                    );
                switch (plog->dwEvent) {
                    case 'AMUT':
                        PRINTF("AcquireMutext         ");
                        break;
                    case 'RMUT':
                        PRINTF("ReleaseMutext         ");
                        break;
                    case 'INSQ':
                        PRINTF("InsertReadyQueue      ");
                        break;
                    case 'NEST':
                        PRINTF("NestContext           ");
                        break;
                    case 'EVAL':
                        PRINTF("EvaluateContext       ");
                        break;
                    case 'QCTX':
                        PRINTF("QueueContext          ");
                        break;
                    case 'REST':
                        PRINTF("RestartContext        ");
                        break;
                    case 'KICK':
                        PRINTF("QueueWorkItem         ");
                        break;
                    case 'PAUS':
                        PRINTF("PauseInterpreter      ");
                        break;
                    case 'RSCB':
                        PRINTF("RestartCtxtCallback   ");
                        break;
                    case 'DONE':
                        PRINTF("EvalMethodComplete    ");
                        break;
                    case 'ASCB':
                        PRINTF("AsyncCallBack         ");
                        break;
                    case 'NSYN':
                        PRINTF("NestedSyncEvalObject  ");
                        break;
                    case 'SYNC':
                        PRINTF("SyncEvalObject        ");
                        break;
                    case 'ASYN':
                        PRINTF("AsyncEvalObject       ");
                        break;
                    case 'NASY':
                        PRINTF("NestedAsyncEvalObject ");
                        break;
                    case 'RUNC':
                        PRINTF("RunContext            ");
                        break;
                    case 'PACB':
                        PRINTF("PauseAsyncCallback    ");
                        break;
                    case 'RUN!':
                        PRINTF("FinishedContext       ");
                        break;
                    case 'RSUM':
                        PRINTF("ResumeInterpreter     ");
                        break;
                    case 'RSTQ':
                        PRINTF("ResumeQueueWorkItem   ");
                        break;
                    default:
                        break;
                }
                switch (plog->dwEvent)
                {
                    case 'AMUT':
                    case 'RMUT':
                        PRINTF("\n    Mut=%08x Owner=%08x dwcOwned=%d rc=%x\n",
                               plog->uipData2, plog->uipData3,
                               plog->uipData4, plog->uipData5);
                        break;

                    case 'INSQ':
                    case 'NEST':
                    case 'EVAL':
                    case 'QCTX':
                    case 'REST':
                        PRINTF("Context=%08x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x",
                               plog->uipData5,
                               GetObjectPath((PNSOBJ)plog->uipData6),
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );


                        if (FindObjSymbol((PUCHAR)plog->uipData7, &pns,
                                          &dwOffset)) {

                            PRINTF(" pbOp=%s", GetObjectPath(pns));
                            if (dwOffset != 0) {

                                PRINTF("+%x", dwOffset);

                            }

                        }
                        PRINTF("\n");
                        break;

                    case 'KICK':
                    case 'PAUS':
                        PRINTF("\n    QTh=%08x QCt=%08x QFg=%08x rc=%x\n",
                               plog->uipData2, plog->uipData3,
                               plog->uipData4, plog->uipData5);
                        break;

                    case 'RSCB':
                        PRINTF("Context=%08x\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData5, plog->uipData2,
                               plog->uipData3, plog->uipData4);
                        break;

                    case 'DONE':
                    case 'ASCB':
                        PRINTF("rc=%x pEvent=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData6, plog->uipData7,
                               GetObjectPath((PNSOBJ)plog->uipData5),
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );
                        break;

                    case 'NSYN':
                    case 'SYNC':
                    case 'ASYN':
                        PRINTF("IRQL=%2x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData5 & 0xff,
                               GetObjectPath((PNSOBJ)plog->uipData6),
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );
                        break;

                    case 'NASY':
                        PRINTF("Context=%x CallBack=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData6, plog->uipData7,
                               GetObjectPath((PNSOBJ)plog->uipData5),
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );
                        break;

                    case 'RUNC':
                        PRINTF("Context=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData5, GetObjectPath((PNSOBJ)plog->uipData6),
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );
                        break;

                    case 'PACB':
                    case 'RUN!':
                        PRINTF("Context=%x rc=%x\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData5, plog->uipData6,
                               plog->uipData2, plog->uipData3,
                               plog->uipData4
                               );
                        break;

                    case 'RSUM':
                    case 'RSTQ':
                        PRINTF("\n    QTh=%08x QCt=%08x QFg=%08x\n",
                               plog->uipData2, plog->uipData3,
                               plog->uipData4);
                        break;

                    default:
                        PRINTF("D1=%08x,D2=%08x,D3=%08x,D4=%08x,D5=%08x,D6=%08x,D7=%08x\n",
                               plog->uipData1, plog->uipData2, plog->uipData3,
                               plog->uipData4, plog->uipData5, plog->uipData6,
                               plog->uipData7);
                }
            }
            PRINTF("\n");

            if (++i >= gDebugger.dwLogSize)
            {
                i = 0;
            }

            if (i == gDebugger.dwLogIndex)
            {
                break;
            }
        }

        rc = DBGERR_NONE;
    }

    return rc;
}       //DebugDumpLog

/***LP  DumpStack - Dump stack of a context block
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      fVerbose - TRUE if verbose mode on
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpStack(PCTXT pctxt, BOOLEAN fVerbose)
{
    PFRAMEHDR pfh;
    PUCHAR pbOp = NULL;

    ASSERT(pctxt->dwSig == SIG_CTXT);

    if (fVerbose)
    {
        PRINTF("CtxtBlock=%x, StackTop=%x, StackEnd=%x\n\n",
               pctxt, pctxt->LocalHeap.pbHeapEnd, pctxt->pbCtxtEnd);
    }

    for (pfh = (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd;
         (PUCHAR)pfh < pctxt->pbCtxtEnd;
         pfh = (PFRAMEHDR)((PUCHAR)pfh + pfh->dwLen))
    {
        if (fVerbose)
        {
            PRINTF("%08x: %s, Len=%08d, FrameFlags=%08x, ParseFunc=%08x\n",
                   pfh, NameSegString(pfh->dwSig), pfh->dwLen, pfh->dwfFrame,
                   pfh->pfnParse);
        }

        if (pfh->dwSig == SIG_CALL)
        {
            PCALL pcall = (PCALL)pfh;
            int i;

            //
            // This is a call frame, dump it.
            //
            PRINTF("%08x: %s(", pbOp, GetObjectPath(pcall->pnsMethod));
            for (i = 0; i < pcall->icArgs; ++i)
            {
                DumpObject(&pcall->pdataArgs[i], NULL, -1);
                if (i + 1 < pcall->icArgs)
                {
                    PRINTF(",");
                }
            }

            PRINTF(")\n");

            if (fVerbose)
            {
                for (i = 0; i < MAX_NUM_LOCALS; ++i)
                {
                    PRINTF("Local%d: ", i);
                    DumpObject(&pcall->Locals[i], NULL, 0);
                }
            }
        }
        else if (pfh->dwSig == SIG_SCOPE)
        {
            pbOp = ((PSCOPE)pfh)->pbOpRet;
        }
    }
}       //DumpStack

/***LP  DebugDumpNameSpace - Dump Name Space
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpNameSpace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                              ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);
    //
    // User specified name space path or name space node address
    //
    if (pszArg != NULL)
    {
        PNSOBJ pns;
        PSZ psz;

        pns = (PNSOBJ)UlongToPtr(STRTOUL(pszArg, &psz, 16));
        if ((psz == pszArg) || (*psz != '\0'))
        {
            //
            // The argument is not an address, could be a name space path.
            //
            STRUPR(pszArg);
            rc = DumpNameSpaceObject(pszArg,
                                     (BOOLEAN)((dwCmdArg & DNSF_RECURSE) != 0));
        }
        else if (ASSERTRANGE(pns, sizeof(NSOBJ)))
        {
            PRINTF("\nACPI Name Space: %s (%x)\n", GetObjectPath(pns), pns);
            if (dwCmdArg & DNSF_RECURSE)
                DumpNameSpaceTree(pns, 0);
            else
                DumpObject(&pns->ObjData, NameSegString(pns->dwNameSeg), 0);
        }
        else
        {
            DBG_ERROR(("invalid name space address - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {   //
        // User typed "dns" but did not specify any name space path or address
        //
        if (!fProcessed)
        {
            rc = DumpNameSpaceObject(NAMESTR_ROOT, TRUE);
        }

        dwCmdArg = 0;
        fProcessed = FALSE;
    }

    return rc;
}       //DebugDumpNameSpace

/***LP  DebugDumpObject - Dump data object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpObject(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);
    //
    // User specified object address
    //
    if (pszArg != NULL)
    {
        POBJDATA pdata;
        PSZ psz;

        pdata = (POBJDATA)UlongToPtr(STRTOUL(pszArg, &psz, 16));
        if ((psz != pszArg) && (*psz == '\0') &&
            ASSERTRANGE(pdata, sizeof(OBJDATA)))
        {
            DumpObject(pdata, NULL, 0);
        }
        else
        {
            DBG_ERROR(("invalid name space object or object is not a method - %s",
                       pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugDumpObject

/***LP  DebugEditMem - Edit memory
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugEditMem(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;
    static BOOLEAN fPhysical = FALSE;
    static ULONG_PTR uipAddr = 0;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG_PTR uipData;
        PUCHAR pbMemAddr;

        if (dwArgNum == 1)
        {
            if ((pszArg[0] == '%') && (pszArg[0] == '%'))
            {
                if (IsNumber(&pszArg[2], 16, &uipData))
                {
                    fPhysical = TRUE;
                    uipAddr = uipData;
                }
                else
                {
                    DBG_ERROR(("invalid physical address - %s", pszArg));
                    rc = DBGERR_INVALID_CMD;
                }
            }
            else if (IsNumber(pszArg, 16, &uipData))
            {
                uipAddr = uipData;
            }
            else
            {
                DBG_ERROR(("invalid address - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else if (IsNumber(pszArg, 16, &uipData))
        {
            if (uipData <= MAX_BYTE)
            {
                if (fPhysical)
                {
                    if (MapUnmapPhysMem(NULL, uipAddr, 1,
                                        (PULONG_PTR)&pbMemAddr) !=
                        STATUS_SUCCESS)
                    {
                        DBG_ERROR(("Failed to map physical address %p",
                                   uipAddr));
                        rc = DBGERR_CMD_FAILED;
                    }
                }
                else
                    pbMemAddr = (PUCHAR)uipAddr;

                if (ASSERTRANGE(pbMemAddr, 1))
                {
                    *pbMemAddr = (UCHAR)uipData;
                    uipAddr++;
                }
                else
                {
                    DBG_ERROR(("invalid address - %s", uipAddr));
                    rc = DBGERR_INVALID_CMD;
                }

                if (fPhysical)
                {
                    MapUnmapPhysMem(NULL, (ULONG_PTR)pbMemAddr, 1, NULL);
                }
            }
            else
            {
                DBG_ERROR(("data must be a byte value - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else if ((pszArg[0] == '"') && (pszArg[STRLEN(pszArg) - 1] == '"'))
        {
            int i, icLen;

            icLen = STRLEN(pszArg);
            if (fPhysical)
            {
                if (MapUnmapPhysMem(NULL, uipAddr, icLen,
                                    (PULONG_PTR)&pbMemAddr) != STATUS_SUCCESS)
                {
                    DBG_ERROR(("Failed to map physical address %p", uipAddr));
                    rc = DBGERR_CMD_FAILED;
                }
            }
            else
                pbMemAddr = (PUCHAR)uipAddr;

            if (ASSERTRANGE(pbMemAddr, icLen))
            {
                for (i = 1; i < icLen - 1; ++i)
                {
                    *pbMemAddr = pszArg[i];
                    pbMemAddr++;
                    uipAddr++;
                }
            }
            else
            {
                DBG_ERROR(("invalid address - %s", uipAddr));
                rc = DBGERR_INVALID_CMD;
            }

            if (fPhysical)
            {
                MapUnmapPhysMem(NULL, (ULONG_PTR)pbMemAddr, icLen, NULL);
            }
        }
        else
        {
            DBG_ERROR(("invalid data - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }

        if ((rc == DBGERR_NONE) && (dwArgNum > 1))
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid EditMemory command"));
            rc = DBGERR_INVALID_CMD;
        }
        fPhysical = FALSE;
    }

    return rc;
}       //DebugEditMem

/***LP  DebugFindNSObj - Find NameSpace Object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugFindNSObj(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG dwLen;

        dwLen = STRLEN(pszArg);
        STRUPR(pszArg);
        if (dwLen > sizeof(NAMESEG))
        {
            DBG_ERROR(("invalid NameSeg - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            NAMESEG dwName;

            dwName = NAMESEG_BLANK;
            MEMCPY(&dwName, pszArg, dwLen);

            if (!FindNSObj(dwName, gpnsNameSpaceRoot))
            {
                PRINTF("No such NameSpace object - %s\n", pszArg);
            }

            fProcessed = TRUE;
        }
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid Find command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugFindNSObj

/***LP  FindNSObj - Find and print the full path of a name space object
 *
 *  ENTRY
 *      dwName - NameSeg of the name space object
 *      pnsRoot -> root of NameSpace node to start the search
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found at least one match
 *  EXIT-FAILURE
 *      returns FALSE - found no match
 */

BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PNSOBJ pnsRoot)
{
    BOOLEAN rc = FALSE;

    if (pnsRoot != NULL)
    {
        if (dwName == pnsRoot->dwNameSeg)
        {
            PRINTF("%s\n", GetObjectPath(pnsRoot));
            rc = TRUE;
        }

        if (pnsRoot->pnsFirstChild != NULL)
        {
            PNSOBJ pns, pnsNext;

            for (pns = pnsRoot->pnsFirstChild; pns != NULL; pns = pnsNext)
            {
                pnsNext = ((PNSOBJ)pns->list.plistNext ==
                           pnsRoot->pnsFirstChild)?
                          NULL: (PNSOBJ)pns->list.plistNext;

                rc |= FindNSObj(dwName, pns);
            }
        }
    }

    return rc;
}       //FindNSObj

/***LP  InPort - Read from an I/O port
 *
 *  dwPort - port address
 *  dwSize - port size
 *  pdwData -> to hold data read
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL InPort(ULONG dwPort, ULONG dwSize, PULONG pdwData)
{
    LONG rc = DBGERR_NONE;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    phyaddr.LowPart = dwPort;
    dwAddrSpace = 1;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        dwPort = XlatedAddr.LowPart;
        *pdwData = ReadSystemIO(dwPort, dwSize, 0xffffffff);
    }
    else
    {
        DBG_ERROR(("failed to translate port address"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //InPort

/***LP  DebugInPort - Port input
 *
 *  ENTRY
 *      pszArg -> argument string
 *      dwSize - port size
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugInPort(PSZ pszArg, ULONG dwSize)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    if (pszArg != NULL)
    {
        ULONG_PTR uipPort;

        if (fProcessed || !IsNumber(pszArg, 16, &uipPort))
        {
            DBG_ERROR(("invalid inport command"));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            ULONG dwData;

            if ((rc = InPort((ULONG)uipPort, dwSize, &dwData)) == DBGERR_NONE)
            {
                PRINTF("%04x: ", (ULONG)uipPort);
                switch (dwSize)
                {
                    case sizeof(UCHAR):
                        PRINTF("%02x", (UCHAR)dwData);
                        break;

                    case sizeof(USHORT):
                        PRINTF("%04x", (USHORT)dwData);
                        break;

                    case sizeof(ULONG):
                        PRINTF("%08x", dwData);
                }
                PRINTF("\n");
            }
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid inport command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugInPort

/***LP  DebugI - Byte port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugI(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(UCHAR));

    return rc;
}       //DebugI

/***LP  DebugIW - Word port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugIW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(USHORT));

    return rc;
}       //DebugIW

/***LP  DebugID - DWord port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugID(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(ULONG));

    return rc;
}       //DebugID

/***LP  DebugQuit - Quit to kernel debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugQuit(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        if (gDebugger.dwfDebugger & DBGF_IN_VXDMODE)
        {
            rc = DBGERR_QUIT;
        }
        else
        {
            PRINTF("\nShell to Kernel Debugger.\n"
                   "Type 'g' to go back to the AML debugger.\n\n");
            gDebugger.dwfDebugger |= DBGF_IN_KDSHELL;
            KdBreakPoint();
            gDebugger.dwfDebugger &= ~DBGF_IN_KDSHELL;
            rc = DBGERR_NONE;
        }
    }
    else
    {
        DBG_ERROR(("invalid Quit command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugQuit

/***LP  DebugListCtxts - List all contexts
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugListCtxts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        PLIST plist, plistNext;
        PCTXT pctxt;

        for (plist = gplistCtxtHead; plist != NULL; plist = plistNext)
        {
            plistNext = (plist->plistNext == gplistCtxtHead)?
                        NULL: plist->plistNext;
            pctxt = CONTAINING_RECORD(plist, CTXT, listCtxt);
            PRINTF("%cCtxt=%08x, ThID=%08x, Flgs=%c%c%c%c%c%c%c%c%c, pbOp=%08x, Obj=%s\n",
                   (pctxt == gReadyQueue.pctxtCurrent)? '*': ' ', pctxt,
                   (pctxt == gReadyQueue.pctxtCurrent)?
                       gReadyQueue.pkthCurrent: 0,
                   (pctxt->dwfCtxt & CTXTF_ASYNC_EVAL)? 'A': '-',
                   (pctxt->dwfCtxt & CTXTF_NEST_EVAL)? 'N': '-',
                   (pctxt->dwfCtxt & CTXTF_IN_READYQ)? 'Q': '-',
                   (pctxt->dwfCtxt & CTXTF_NEED_CALLBACK)? 'C': '-',
                   (pctxt->dwfCtxt & CTXTF_RUNNING)? 'R': '-',
                   (pctxt->dwfCtxt & CTXTF_READY)? 'W': '-',
                   (pctxt->dwfCtxt & CTXTF_TIMEOUT)? 'T': '-',
                   (pctxt->dwfCtxt & CTXTF_TIMER_DISPATCH)? 'D': '-',
                   (pctxt->dwfCtxt & CTXTF_TIMER_PENDING)? 'P': '-',
                   pctxt->pbOp, GetObjectPath(pctxt->pnsObj));
        }
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid LC command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugListCtxts

/***LP  DebugLN - Display nearest symbol
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugLN(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        PUCHAR pb;

        if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pb, NULL, NULL, NULL)) ==
            DBGERR_NONE)
        {
            PrintSymbol(pb);
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else if (gReadyQueue.pctxtCurrent == NULL)
        {
            DBG_ERROR(("no current context"));
            rc = DBGERR_CMD_FAILED;
        }
        else
            PrintSymbol(gReadyQueue.pctxtCurrent->pbOp);
    }

    return rc;
}       //DebugLN

/***LP  DummyCallBack - Callback that does absolutely nothing
 *
 *  ENTRY
 *      pv - not used
 *
 *  EXIT
 *      None
 */

VOID LOCAL DummyCallBack(PVOID pv)
{
    DEREF(pv);
}       //DummyCallBack

/***LP  DebugNotify - Notify object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugNotify(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static PNSOBJ pns = NULL;
    static ULONG_PTR uipValue = 0;

    DEREF(pArg);

    if (pszArg != NULL)
    {
        switch (dwArgNum)
        {
            case 1:
                if (!IsNumber(pszArg, 16, (PULONG_PTR)&pns))
                {
                    STRUPR(pszArg);
                    if (GetNameSpaceObject(pszArg, NULL, &pns, NSF_LOCAL_SCOPE)
                        != STATUS_SUCCESS)
                    {
                        DBG_ERROR(("object not found - %s", pszArg));
                        rc = DBGERR_INVALID_CMD;
                    }
                }
                break;

            case 2:
                if (!IsNumber(pszArg, 16, &uipValue))
                {
                    DBG_ERROR(("invalid notification value - %s", pszArg));
                    rc = DBGERR_INVALID_CMD;
                }
                break;

            default:
                DBG_ERROR(("invalid notify command"));
                rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        if (dwNonSWArgs != 2)
        {
            DBG_ERROR(("invalid notify command"));
            rc = DBGERR_INVALID_CMD;
        }
        else if (!ASSERTRANGE(pns, sizeof(NSOBJ)))
        {
            DBG_ERROR(("invalid object"));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            PRINTF("Queuing: Notify(%s, %x) ...\n",
                   GetObjectPath(pns), uipValue);

            ((PFNNH)ghNotify.pfnHandler)(EVTYPE_NOTIFY, (ULONG)uipValue, pns,
                                         (ULONG)ghNotify.uipParam,
                                         DummyCallBack, NULL);
        }
    }

    return rc;
}       //DebugNotify

/***LP  OutPort - Write to an I/O port
 *
 *  dwPort - port address
 *  dwSize - port size
 *  dwData - data to be written
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL OutPort(ULONG dwPort, ULONG dwSize, ULONG dwData)
{
    LONG rc = DBGERR_NONE;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    phyaddr.LowPart = dwPort;
    dwAddrSpace = 1;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        dwPort = XlatedAddr.LowPart;
        WriteSystemIO(dwPort, dwSize, dwData);
    }
    else
    {
        DBG_ERROR(("failed to translate port address"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //OutPort

/***LP  DebugOutPort - Port output
 *
 *  ENTRY
 *      pszArg -> argument string
 *      dwSize - port size
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOutPort(PSZ pszArg, ULONG dwSize)
{
    LONG rc = DBGERR_NONE;
    static int icArgs = 0;
    static ULONG dwPort = 0;

    if (pszArg != NULL)
    {
        ULONG_PTR uipData;

        icArgs++;
        if ((icArgs > 2) || !IsNumber(pszArg, 16, &uipData))
        {
            DBG_ERROR(("invalid outport command"));
            rc = DBGERR_INVALID_CMD;
        }
        else if (icArgs == 1)
        {
            dwPort = (ULONG)uipData;
        }
        else
        {
            OutPort(dwPort, dwSize, (ULONG)uipData);
        }

        if (rc != DBGERR_NONE)
            icArgs = 0;
    }
    else
    {
        if (icArgs != 2)
        {
            DBG_ERROR(("invalid outport command"));
            rc = DBGERR_INVALID_CMD;
        }
        icArgs = 0;
    }

    return rc;
}       //DebugOutPort

/***LP  DebugO - Byte port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(UCHAR));

    return rc;
}       //DebugO

/***LP  DebugOW - Word port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(USHORT));

    return rc;
}       //DebugOW

/***LP  DebugOD - DWord port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(ULONG));

    return rc;
}       //DebugOD

/***LP  PrintSymbol - Print the nearest symbol of a given address
 *
 *  ENTRY
 *      pb - address
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintSymbol(PUCHAR pb)
{
    PNSOBJ pns;
    ULONG dwOffset;

    if (FindObjSymbol(pb, &pns, &dwOffset))
    {
        PRINTF("%x: %s", pb, GetObjectPath(pns));
        if (dwOffset != 0)
            PRINTF(" + %x\n", dwOffset);
        else
            PRINTF("\n");
    }
    else
    {
        PRINTF("%x: no symbols found", pb);
    }
}       //PrintSymbol

/***LP  DebugStep - Trace and step over an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugStep(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        gDebugger.dwfDebugger |= DBGF_STEP_OVER;
        rc = DBGERR_QUIT;
    }
    else
    {
        DBG_ERROR(("invalid step command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugStep

/***LP  DumpContext - Dump context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpContext(PCTXT pctxt)
{
    PNSOBJ pns = NULL;
    ULONG dwOffset = 0;
    int i;
    PLIST plist, plistNext;
    PRESOURCE pres;
    PUCHAR pbBegin = NULL, pbEnd = NULL;

  #ifdef DEBUG
    PRINTF("\nContext=%08x%c, Queue=%08x, ResList=%08x\n",
           pctxt, (pctxt == gReadyQueue.pctxtCurrent)? '*': ' ',
           pctxt->pplistCtxtQueue, pctxt->plistResources);
    PRINTF("ThreadID=%08x, Flags=%08x\n",
           (pctxt == gReadyQueue.pctxtCurrent)? gReadyQueue.pkthCurrent: 0,
           pctxt->dwfCtxt);
    PRINTF("StackTop=%08x, UsedStackSize=%d bytes, FreeStackSize=%d bytes\n",
           pctxt->LocalHeap.pbHeapEnd,
           pctxt->pbCtxtEnd - pctxt->LocalHeap.pbHeapEnd,
           pctxt->LocalHeap.pbHeapEnd - pctxt->LocalHeap.pbHeapTop);
    PRINTF("LocalHeap=%08x, CurrentHeap=%08x, UsedHeapSize=%d bytes\n",
           &pctxt->LocalHeap, pctxt->pheapCurrent,
           pctxt->LocalHeap.pbHeapTop - (PUCHAR)&pctxt->LocalHeap);
    PRINTF("Object=%s, Scope=%s, ObjectOwner=%x, SyncLevel=%x\n",
           pctxt->pnsObj? GetObjectPath(pctxt->pnsObj): "<none>",
           pctxt->pnsScope? GetObjectPath(pctxt->pnsScope): "<none>",
           pctxt->powner, pctxt->dwSyncLevel);
    PRINTF("AsyncCallBack=%x, CallBackData=%x, CallBackContext=%x\n",
           pctxt->pfnAsyncCallBack, pctxt->pdataCallBack,
           pctxt->pvContext);
  #endif

    if (pctxt->pcall != NULL)
    {
        PRINTF("\nMethodObject=%s\n",
               pctxt->pcall->pnsMethod?
                   GetObjectPath(pctxt->pcall->pnsMethod): "<none>");
        for (i = 0; i < pctxt->pcall->icArgs; ++i)
        {
            PRINTF("%08x: Arg%d=", &pctxt->pcall->pdataArgs[i], i);
            DumpObject(&pctxt->pcall->pdataArgs[i], NULL, 0);
        }

        for (i = 0; i < MAX_NUM_LOCALS; ++i)
        {
            PRINTF("%08x: Local%d=", &pctxt->pcall->Locals[i], i);
            DumpObject(&pctxt->pcall->Locals[i], NULL, 0);
        }
    }

    PRINTF("%08x: RetObj=", &pctxt->Result);
    DumpObject(&pctxt->Result, NULL, 0);

    if (pctxt->plistResources != NULL)
    {
        PRINTF("\nResources Owned:\n");
        for (plist = pctxt->plistResources; plist != NULL; plist = plistNext)
        {
            plistNext = (plist->plistNext != pctxt->plistResources)?
                        plist->plistNext: NULL;

            pres = CONTAINING_RECORD(plist, RESOURCE, list);
            ASSERT(pctxt == pres->pctxtOwner);
            PRINTF("  ResType=%s, ResObj=%x\n",
                   pres->dwResType == RESTYPE_MUTEX? "Mutex": "Unknown",
                   pres->pvResObj);
        }
    }

    PRINTF("\nNext AML Pointer: %08x", pctxt->pbOp);
    if (FindObjSymbol(pctxt->pbOp, &pns, &dwOffset))
    {
        PRINTF(" [%s", GetObjectPath(pns));
        if (dwOffset != 0)
            PRINTF(" + %x]", dwOffset);
        else
            PRINTF("]");
    }

    pbBegin = pctxt->pbOp;
    gpnsCurUnAsmScope = NULL;
    if (pns != NULL)
    {
        pbEnd = pns->ObjData.pbDataBuff + pns->ObjData.dwDataLen;
        gpnsCurUnAsmScope = pns;
    }
    else if ((pbBegin >= gDebugger.pbBlkBegin) &&
             (pbBegin < gDebugger.pbBlkEnd))
    {
        pbEnd = gDebugger.pbBlkEnd;
    }

    if (pbEnd != NULL)
    {
        UnAsmScope(&pbBegin, pbEnd, 0, 1);
        PRINTF("\n");
    }

    PRINTF("\n");
}       //DumpContext

/***LP  DebugDumpContext - Dump debugger context
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpContext(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                            ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        PCTXT pctxt;

        if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pctxt, NULL, NULL, NULL)) ==
            DBGERR_NONE)
        {
            if (pctxt->dwSig == SIG_CTXT)
            {
                DumpContext(pctxt);
                fProcessed = TRUE;
            }
            else
            {
                DBG_ERROR(("invalid context address - %x", pctxt));
                rc = DBGERR_CMD_FAILED;
            }
        }
    }
    else
    {
        if (fProcessed)
        {
            fProcessed = FALSE;
        }
        else if (gReadyQueue.pctxtCurrent == NULL)
        {
            DBG_ERROR(("no current context"));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            DumpContext(gReadyQueue.pctxtCurrent);
        }
    }

    return rc;
}       //DebugDumpContext

/***LP  DebugSet - Set debugger options
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugSet(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if ((pszArg == NULL) && (dwArgNum == 0))
    {
        PRINTF("AMLTrace        =%s\n",
               (gDebugger.dwfDebugger & DBGF_AMLTRACE_ON)? "on": "off");
        PRINTF("AMLDebugSpew    =%s\n",
               (gDebugger.dwfDebugger & DBGF_DEBUG_SPEW_ON)? "on": "off");
        PRINTF("LoadDDBBreak    =%s\n",
               (gdwfAMLIInit & AMLIIF_LOADDDB_BREAK)? "on": "off");
        PRINTF("ErrorBreak      =%s\n",
               (gDebugger.dwfDebugger & DBGF_ERRBREAK_ON)? "on": "off");
        PRINTF("VerboseMode     =%s\n",
               (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)? "on": "off");
        PRINTF("LogEvent        =%s\n",
               (gDebugger.dwfDebugger & DBGF_LOGEVENT_ON)? "on": "off");
        PRINTF("LogSize         =%d\n", gDebugger.dwLogSize);
    }
    else
    {
        if(gDebugger.dwfDebugger & DBGF_DEBUG_SPEW_ON)
        {
            if(!CheckAndEnableDebugSpew(TRUE))
                gDebugger.dwfDebugger &= ~DBGF_DEBUG_SPEW_ON; 
        }
        else if(gDebugger.dwfDebugger & ~DBGF_DEBUG_SPEW_ON)
        {
            if(!CheckAndEnableDebugSpew(FALSE))
                gDebugger.dwfDebugger |= DBGF_DEBUG_SPEW_ON;
        }

    }

    return rc;
}       //DebugSet

/***LP  DebugSetLogSize - Set EventLog size
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugSetLogSize(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(pszArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (!SetLogSize(dwCmdArg))
    {
        DBG_ERROR(("failed to set EventLog size to %d", dwCmdArg));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //DebugSetLogSize

/***LP  SetLogSize - Set EventLog size
 *
 *  ENTRY
 *      dwLogSize - EventLog size
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL SetLogSize(ULONG dwLogSize)
{
    BOOLEAN rc = FALSE;

    if (gDebugger.pEventLog != NULL)
    {
        MFREE(gDebugger.pEventLog);
        gDebugger.pEventLog = NULL;
        gDebugger.dwLogSize = 0;
        gDebugger.dwLogIndex = 0;
    }

    if ((gDebugger.pEventLog = MALLOC_LOCKED(sizeof(EVENTLOG)*dwLogSize,
                                             'GOLE')) != NULL)
    {
        gDebugger.dwLogSize = dwLogSize;
        gDebugger.dwLogIndex = 0;
        MEMZERO(gDebugger.pEventLog, sizeof(EVENTLOG)*dwLogSize);
        rc = TRUE;
    }

    return rc;
}       //SetLogSize

/***LP  DebugTrace - Single-step an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        gDebugger.dwfDebugger |= DBGF_SINGLE_STEP;
        rc = DBGERR_QUIT;
    }
    else
    {
        DBG_ERROR(("invalid trace command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugTrace

/***LP  DebugUnAsm - Unassemble AML code
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugUnAsm(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fParsedAddr = FALSE;
    PNSOBJ pns = NULL;

    DEREF(pArg);
    DEREF(dwArgNum);

    //
    // User specified name space path or memory address
    //
    if (pszArg != NULL)
    {
        if (fParsedAddr && (dwNonSWArgs == 1))
        {
            //
            // Impossible, it must be abort value from last time, clear it.
            //
            fParsedAddr = FALSE;
        }

        if (!fParsedAddr)
        {
            PUCHAR pbAddr;

            gpnsCurUnAsmScope = NULL;
            if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pbAddr, NULL, &pns, NULL))
                == DBGERR_NONE)
            {
                gDebugger.pbUnAsm = pbAddr;
                gDebugger.pbUnAsmEnd = NULL;
                fParsedAddr = TRUE;
                if (pns != NULL)
                {
                    gDebugger.pbUnAsmEnd = pns->ObjData.pbDataBuff +
                                           pns->ObjData.dwDataLen;
                    gpnsCurUnAsmScope = pns;
                }
            }
        }
        else
        {
            DBG_ERROR(("invalid unassemble command"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        if (!fParsedAddr && (gDebugger.pbUnAsm == NULL) &&
            (gReadyQueue.pctxtCurrent != NULL))
        {
            ULONG dwOffset;

            gDebugger.pbUnAsm = gReadyQueue.pctxtCurrent->pbOp;
            gDebugger.pbUnAsmEnd = NULL;
        gpnsCurUnAsmScope = NULL;
            if (FindObjSymbol(gDebugger.pbUnAsm, &pns, &dwOffset))
            {
                gDebugger.pbUnAsmEnd = pns->ObjData.pbDataBuff +
                                       pns->ObjData.dwDataLen;
                gpnsCurUnAsmScope = pns;
            }
        }

        if (gDebugger.pbUnAsmEnd == NULL)
        {
            if ((gDebugger.pbUnAsm >= gDebugger.pbBlkBegin) &&
                (gDebugger.pbUnAsm < gDebugger.pbBlkEnd))
            {
                gDebugger.pbUnAsmEnd = gDebugger.pbBlkEnd;
            }
            else
            {
                ULONG dwLen;
                //
                // don't know code len, start with 64K
                //
                for (dwLen = 64*1024; dwLen > 0; dwLen >>= 1)
                {
                    if (ASSERTRANGE(gDebugger.pbUnAsm, dwLen))
                    {
                        gDebugger.pbUnAsmEnd = gDebugger.pbUnAsm + dwLen;
                        break;
                    }
                }

                if (dwLen == 0)
                {
                    DBG_ERROR(("invalid address %x", gDebugger.pbUnAsm));
                    rc = DBGERR_INVALID_CMD;
                }
            }
        }

        if ((rc == DBGERR_NONE) && (gDebugger.pbUnAsm != NULL) &&
            (gDebugger.pbUnAsmEnd > gDebugger.pbUnAsm))
        {
            rc = UnAsmScope(&gDebugger.pbUnAsm, gDebugger.pbUnAsmEnd,
                            fParsedAddr? 0: -1, 0);
            PRINTF("\n");
            if (rc == UNASMERR_ABORT)
            {
                rc = DBGERR_NONE;
            }
        }
        else
        {
            gDebugger.pbUnAsm = gDebugger.pbUnAsmEnd = NULL;
        }

        fParsedAddr = FALSE;
    }

    return rc;
}       //DebugUnAsm

BOOLEAN fRunningMethod = FALSE;

/***LP  DebugRunMethod - Run Method
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugRunMethod(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static int icArgs = -1;
    static PNSOBJ pns = NULL;
    static OBJDATA Args[MAX_NUM_ARGS] = {0};
    static OBJDATA Result;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (fRunningMethod)
    {
        DBG_ERROR(("Cannot run method while previous method is still pending"));
        rc = DBGERR_CMD_FAILED;
    }
    else if (pszArg != NULL)
    {
        if (icArgs == -1)
        {
            PUCHAR pbAddr;

            if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pbAddr, NULL, &pns, NULL))
                == DBGERR_NONE)
            {
                if (pns != NULL)
                {
                    pns = GetBaseObject(pns);
                    icArgs = 0;
                }
                else
                {
                    DBG_ERROR(("invalid method or method not found"));
                    rc = DBGERR_CMD_FAILED;
                }
            }
        }
        else if (icArgs < MAX_NUM_ARGS)
        {
            MEMZERO(&Args[icArgs], sizeof(OBJDATA));
            if (IsNumber(pszArg, 0, &Args[icArgs].uipDataValue))
            {
                Args[icArgs].dwDataType = OBJTYPE_INTDATA;
                icArgs++;
            }
            else
            {
                DBG_ERROR(("invalid argument %s (can only be integer)",
                           pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("too many arguments"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (icArgs >= 0)
    {
        NTSTATUS rcAMLI;

        MEMZERO(&Result, sizeof(OBJDATA));
        fRunningMethod = TRUE;
        if ((rcAMLI = AsyncEvalObject(pns, &Result, icArgs, Args,
                                      RunMethodCallBack, NULL, TRUE)) !=
            AMLISTA_PENDING)
        {
            RunMethodCallBack(pns, rcAMLI, &Result, NULL);
            if (rcAMLI != STATUS_SUCCESS)
            {
                rc = DBGERR_CMD_FAILED;
            }
        }
        else
        {
            PRINTF("\n%s returned PENDING\n", GetObjectPath(pns));
        }

        icArgs = -1;
    }
    else
    {
        DBG_ERROR(("invalid run command"));
        rc = DBGERR_CMD_FAILED;
    }

    if (rc != DBGERR_NONE)
    {
        icArgs = -1;
    }

    return rc;
}       //DebugRunMethod

/***LP  RunMethodCallBack - RunMethod completion callback
 *
 *  ENTRY
 *      pns -> method object
 *      rc - execution status code
 *      pdata -> result data
 *      pvContext -> context data
 *
 *  EXIT
 *      None
 */

VOID EXPORT RunMethodCallBack(PNSOBJ pns, NTSTATUS rc, POBJDATA pdata,
                              PVOID pvContext)
{
    DEREF(pvContext);

    if (rc == STATUS_SUCCESS)
    {
        PRINTF("\n%s completed successfully with object data:\n",
               GetObjectPath(pns));
        DumpObject(pdata, NULL, 0);
    }
    else
    {
        PSZ pszErr;

        AMLIGetLastError(&pszErr);
        PRINTF("\n%s failed with the following error:\n%s\n",
               GetObjectPath(pns), pszErr);
    }
    fRunningMethod = FALSE;
}       //RunMethodCallBack

/***LP  AddObjSymbol - Add object to symbol table
 *
 *  ENTRY
 *      pbOp -> code address
 *      pnsObj -> object
 *
 *  EXIT
 *      None
 */

VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj)
{
    POBJSYM pos, p;

    if ((pos = NEWSYOBJ(sizeof(OBJSYM))) == NULL)
    {
        AMLI_ERROR(("AddObjSymbol: failed to allocate symbol buffer"));
    }
    else
    {
        MEMZERO(pos, sizeof(OBJSYM));
        pos->pbOp = pbOp;
        pos->pnsObj = pnsObj;

        if (gDebugger.posSymbolList == NULL)
        {
            gDebugger.posSymbolList = pos;
        }
        else if (pbOp < gDebugger.posSymbolList->pbOp)
        {
            pos->posNext = gDebugger.posSymbolList;
            gDebugger.posSymbolList->posPrev = pos;
            gDebugger.posSymbolList = pos;
        }
        else
        {
            for (p = gDebugger.posSymbolList; p != NULL; p = p->posNext)
            {
                if (pbOp < p->pbOp)
                {
                    pos->posNext = p;
                    pos->posPrev = p->posPrev;
                    p->posPrev->posNext = pos;
                    p->posPrev = pos;
                    break;
                }
                else if (p->posNext == NULL)
                {
                    pos->posPrev = p;
                    p->posNext = pos;
                    break;
                }
            }
        }
    }
}       //AddObjSymbol

/***LP  FreeSymList - Free all object symbols
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeSymList(VOID)
{
    POBJSYM pos, posNext;

    for (pos = gDebugger.posSymbolList; pos != NULL; pos = posNext)
    {
        posNext = pos->posNext;
        FREESYOBJ(pos);
    }
}       //FreeSymList

/***LP  FindObjSymbol - Find nearest object with given address
 *
 *  ENTRY
 *      pbOp - address
 *      ppns -> to hold the nearest object
 *      pdwOffset - to hold offset from the nearest object
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found a nearest object
 *  EXIT-FAILURE
 *      returns FALSE - cannot found nearest object
 */

BOOLEAN LOCAL FindObjSymbol(PUCHAR pbOp, PPNSOBJ ppns, PULONG pdwOffset)
{
    BOOLEAN rc = FALSE;
    POBJSYM pos;

    for (pos = gDebugger.posSymbolList; pos != NULL; pos = pos->posNext)
    {
        if (pbOp <= pos->pbOp)
        {
            if ((pbOp < pos->pbOp) && (pos->posPrev != NULL))
                pos = pos->posPrev;

            if (pbOp >= pos->pbOp)
            {
                *ppns = pos->pnsObj;
                *pdwOffset = (ULONG)(pbOp - pos->pbOp);
                rc = TRUE;
            }
            break;
        }
    }

    return rc;
}       //FindObjSymbol

/***LP  CheckBP - Check given address is in the breakpoint list
 *
 *  ENTRY
 *      pbOp - address
 *
 *  EXIT-SUCCESS
 *      returns breakpoint number
 *  EXIT-FAILURE
 *      returns -1
 */

int LOCAL CheckBP(PUCHAR pbOp)
{
    int i;

    for (i = 0; i < MAX_BRK_PTS; ++i)
    {
        if (pbOp == gDebugger.BrkPts[i].pbBrkPt)
        {
            break;
        }
    }

    if ((i == MAX_BRK_PTS) ||
        !(gDebugger.BrkPts[i].dwfBrkPt & BPF_ENABLED))
    {
        i = -1;
    }

    return i;
}       //CheckBP

/***LP  PrintfBuffData - Print buffer data
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen)
{
    TRACENAME("PRINTBUFFDATA")
    int i, j;

    ENTER(4, ("PrintBuffData(pb=%x,Len=%d)\n", pb, dwLen));

    PRINTF("{");
    for (i = j = 0; i < (int)dwLen; ++i)
    {
        if (j == 0)
            PRINTF("\n\t0x%02x", pb[i]);
        else
            PRINTF(",0x%02x", pb[i]);

        j++;
        if (j >= 14)
            j = 0;
    }
    PRINTF("}");

    EXIT(4, ("PrintBuffData!\n"));
}       //PrintBuffData

/***LP  PrintIndent - Print indentation
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintIndent(PCTXT pctxt)
{
    TRACENAME("PRINTINDENT")
    int i;

    ENTER(4, ("PrintIndent(pctxt=%x,pbOp=%x)\n", pctxt, pctxt->pbOp));

    PRINTF("\n%08x: ", pctxt->pbOp);
    for (i = 0; i < gDebugger.iPrintLevel; ++i)
    {
        PRINTF("| ");
    }

    EXIT(4, ("PrintIndent!\n"));
}       //PrintIndent

/***LP  PrintObject - Print object content
 *
 *  ENTRY
 *      pdata -> object
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintObject(POBJDATA pdata)
{
    TRACENAME("PRINTOBJECT")
    int i;

    ENTER(4, ("PrintObject(pdata=%x)\n", pdata));

    switch (pdata->dwDataType)
    {
        case OBJTYPE_INTDATA:
            PRINTF("0x%x", pdata->uipDataValue);
            break;

        case OBJTYPE_STRDATA:
            PRINTF("\"%s\"", pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            PRINTF("Buffer(0x%x)", pdata->dwDataLen);
            PrintBuffData(pdata->pbDataBuff, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            PRINTF("Package(%d){",
                   ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements);
            for (i = 0;
                 i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                 ++i)
            {
                PRINTF("\n\t");
                PrintObject(&((PPACKAGEOBJ)pdata->pbDataBuff)->adata[i]);
                if (i + 1 < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements)
                    PRINTF(",");
            }
            PRINTF("}");
            break;

        default:
            PRINTF("<Obj=%x,Type=%s,Value=0x%x,Buff=%x,Len=%d>",
                   pdata, GetObjectTypeName(pdata->dwDataType),
                   pdata->uipDataValue, pdata->pbDataBuff, pdata->dwDataLen);
    }

    EXIT(4, ("PrintObject!\n"));
}       //PrintObject

/***LP  LogEvent - Log an event in the log buffer
 *
 *  ENTRY
 *      dwEvent - event type
 *      uipData1 - log data 1
 *      uipData2 - log data 2
 *      uipData3 - log data 3
 *      uipData4 - log data 4
 *      uipData5 - log data 5
 *      uipData6 - log data 6
 *      uipData7 - log data 7
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                    ULONG_PTR uipData3, ULONG_PTR uipData4, ULONG_PTR uipData5,
                    ULONG_PTR uipData6, ULONG_PTR uipData7)
{
    if ((gDebugger.dwfDebugger & DBGF_LOGEVENT_ON) &&
        (gDebugger.pEventLog != NULL))
    {
        ULONG i = gDebugger.dwLogIndex;

        gDebugger.pEventLog[i].ullTime = KeQueryInterruptTime();
        gDebugger.pEventLog[i].dwEvent = dwEvent;
        gDebugger.pEventLog[i].uipData1 = uipData1;
        gDebugger.pEventLog[i].uipData2 = uipData2;
        gDebugger.pEventLog[i].uipData3 = uipData3;
        gDebugger.pEventLog[i].uipData4 = uipData4;
        gDebugger.pEventLog[i].uipData5 = uipData5;
        gDebugger.pEventLog[i].uipData6 = uipData6;
        gDebugger.pEventLog[i].uipData7 = uipData7;
        gDebugger.dwLogIndex++;
        if (gDebugger.dwLogIndex >= gDebugger.dwLogSize)
        {
            gDebugger.dwLogIndex = 0;
        }
    }
}       //LogEvent;

/***LP  LogSchedEvent - Log a scheduler event in the log buffer
 *
 *  ENTRY
 *      dwEvent - event type
 *      uipData1 - log data 1
 *      uipData2 - log data 2
 *      uipData3 - log data 3
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogSchedEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                         ULONG_PTR uipData3)
{
    if ((gDebugger.dwfDebugger & DBGF_LOGEVENT_ON) &&
        (gDebugger.pEventLog != NULL))
    {
        ULONG i = gDebugger.dwLogIndex;

        gDebugger.pEventLog[i].ullTime = KeQueryInterruptTime();
        gDebugger.pEventLog[i].dwEvent = dwEvent;
        gDebugger.pEventLog[i].uipData1 = (ULONG_PTR)KeGetCurrentThread();
        gDebugger.pEventLog[i].uipData2 = (ULONG_PTR)gReadyQueue.pkthCurrent;
        gDebugger.pEventLog[i].uipData3 = (ULONG_PTR)gReadyQueue.pctxtCurrent;
        gDebugger.pEventLog[i].uipData4 = (ULONG_PTR)gReadyQueue.dwfCtxtQ;
        gDebugger.pEventLog[i].uipData5 = uipData1;
        gDebugger.pEventLog[i].uipData6 = uipData2;
        gDebugger.pEventLog[i].uipData7 = uipData3;
        gDebugger.dwLogIndex++;
        if (gDebugger.dwLogIndex >= gDebugger.dwLogSize)
        {
            gDebugger.dwLogIndex = 0;
        }
    }
}       //LogSchedEvent

/***LP  LogError - Log error code and message
 *
 *  ENTRY
 *      rcErr - error code
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogError(NTSTATUS rcErr)
{
    static struct _ErrMsg
    {
        NTSTATUS rcErr;
        PSZ      pszMsg;
    } ErrMsgTable[] =
    {
        AMLIERR_NONE,                   "Success",
        AMLIERR_OUT_OF_MEM,             "Failed to allocate memory",
        AMLIERR_INVALID_OPCODE,         "Invalid AML Opcode",
        AMLIERR_NAME_TOO_LONG,          "Object name is too long",
        AMLIERR_ASSERT_FAILED,          "Assertion failure",
        AMLIERR_INVALID_NAME,           "Invalid object name",
        AMLIERR_OBJ_NOT_FOUND,          "Object not found",
        AMLIERR_OBJ_ALREADY_EXIST,      "Object already exist",
        AMLIERR_INDEX_TOO_BIG,          "Index is too big",
        AMLIERR_ARG_NOT_EXIST,          "Argument does not exist",
        AMLIERR_FATAL,                  "Fatal error",
        AMLIERR_INVALID_SUPERNAME,      "Invalid SuperName",
        AMLIERR_UNEXPECTED_ARGTYPE,     "Unexpected argument type",
        AMLIERR_UNEXPECTED_OBJTYPE,     "Unexpected object type",
        AMLIERR_UNEXPECTED_TARGETTYPE,  "Unexpected target type",
        AMLIERR_INCORRECT_NUMARG,       "Incorrect number of arguments",
        AMLIERR_FAILED_ADDR_XLATE,      "Failed address translation",
        AMLIERR_INVALID_EVENTTYPE,      "Invalid event type",
        AMLIERR_REGHANDLER_FAILED,      "Failed to register event handler",
        AMLIERR_HANDLER_EXIST,          "Event handler already exist",
        AMLIERR_INVALID_DATA,           "Invalid data",
        AMLIERR_INVALID_REGIONSPACE,    "Invalid RegionSpace",
        AMLIERR_INVALID_ACCSIZE,        "Invalid AccessSize",
        AMLIERR_INVALID_TABLE,          "Invalid table",
        AMLIERR_ACQUIREGL_FAILED,       "Failed to acquire global lock",
        AMLIERR_ALREADY_INITIALIZED,    "AML Interpreter is already initialized",
        AMLIERR_NOT_INITIALIZED,        "AML Interpreter is not initialized",
        AMLIERR_MUTEX_INVALID_LEVEL,    "Invalid mutex sync level",
        AMLIERR_MUTEX_NOT_OWNED,        "Mutex object has no owner",
        AMLIERR_MUTEX_NOT_OWNER,        "Mutex object is owned by a different owner",
        AMLIERR_RS_ACCESS,              "RegionSpace handler error",
        AMLIERR_STACK_OVERFLOW,         "AML Stack overflow",
        AMLIERR_INVALID_BUFFSIZE,       "Invalid buffer size",
        AMLIERR_BUFF_TOOSMALL,          "Buffer is too small",
        AMLIERR_NOTIFY_FAILED,          "Notify handler failed",
        0,                              NULL
    };
    int i;

    gDebugger.rcLastError = rcErr;
    for (i = 0; ErrMsgTable[i].pszMsg != NULL; ++i)
    {
        if (rcErr == ErrMsgTable[i].rcErr)
        {
            sprintf(gDebugger.szLastError, MODNAME "_ERROR(%08x): %s",
                    rcErr, ErrMsgTable[i].pszMsg);
            break;
        }
    }

    ASSERT(ErrMsgTable[i].pszMsg != NULL);
}       //LogError

/***LP  CatError - Concat to error buffer
 *
 *  ENTRY
 *      pszFormat -> message format string
 *      ... - variable parameters according to format string
 *
 *  EXIT
 *      None
 */

VOID LOCAL CatError(PSZ pszFormat, ...)
{
    va_list marker;

    STRCAT(gDebugger.szLastError, "\n");
    va_start(marker, pszFormat);

    if(_vsnprintf(&gDebugger.szLastError[STRLEN(gDebugger.szLastError)],
             sizeof(gDebugger.szLastError) - STRLEN(gDebugger.szLastError),
             pszFormat, marker) == -1)
    {
        gDebugger.szLastError[sizeof(gDebugger.szLastError) - 1] = '\0';
    }
    
    va_end(marker);

    ConPrintf(gDebugger.szLastError);
    ConPrintf("\n");

    if (gDebugger.dwfDebugger & DBGF_ERRBREAK_ON)
    {
        AMLIDebugger(FALSE);
    }
}       //CatError

/***LP  ConPrintf - Console printf
 *
 *  ENTRY
 *      pszFormat -> format string
 *      ... - variable parameters according to format string
 *
 *  EXIT
 *      None
 */

VOID LOCAL ConPrintf(PSZ pszFormat, ...)
{
    static char szBuff[1024];
    va_list marker;

    va_start(marker, pszFormat);
    vsprintf(szBuff, pszFormat, marker);
    va_end(marker);
    if (gDebugger.hConMessage.pfnHandler != NULL) {

        ((PFNCM)gDebugger.hConMessage.pfnHandler)(
            szBuff,
            gDebugger.hConMessage.uipParam
            );

    } else {

        _PRINTF(szBuff);

    }
}       //ConPrintf

/***LP  ConPrompt - Console prompted input
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> input buffer
 *      dwcbBuff - buffer size
 */

VOID LOCAL ConPrompt(PSZ pszPrompt, PSZ pszBuff, ULONG dwcbBuff)
{

    if(gDebugger.dwfDebugger & ~DBGF_DEBUG_SPEW_ON)
    {
        CheckAndEnableDebugSpew(TRUE);
    }

    if (gDebugger.hConPrompt.pfnHandler != NULL)
    {
        ((PFNCP)gDebugger.hConPrompt.pfnHandler)(pszPrompt, pszBuff, dwcbBuff,
                                                 gDebugger.hConPrompt.uipParam);
    }
    else
    {
        DbgPrompt(pszPrompt, pszBuff, dwcbBuff);
    }
}       //ConPrompt


/***LP  CheckAndEnableDebugSpew - Enable debug spew if it is not already turned on.
 *
 *  ENTRY
 *      BOOLEAN fEnable - Enable iff TRUE.
 *
 *  EXIT
 *      BOOLEAN - TRUE on success.
 */
BOOLEAN LOCAL CheckAndEnableDebugSpew(BOOLEAN fEnable)
{
    BOOLEAN bRet = FALSE;
    
    if(KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        if(fEnable)
        {
            gDebugger.dwfDebugger |= DBGF_DEBUG_SPEW_ON;
            DbgSetDebugFilterState( DPFLTR_AMLI_ID, -1, TRUE);
        }
        else
        {
            DbgSetDebugFilterState( DPFLTR_AMLI_ID, -1, FALSE);
            gDebugger.dwfDebugger &= ~DBGF_DEBUG_SPEW_ON;
        }

        bRet = TRUE;
    }
    return bRet;
}

#endif  //ifdef DEBUGGER

#ifdef DEBUG
/***LP  DumpMemObjCounts - display memory object counts
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpMemObjCounts(VOID)
{
    static char szFormat[] = "Number of %s = %d\n";

    PRINTF("CurGlobalHeapSize=%d bytes\n", gdwGlobalHeapSize);
    PRINTF("RefGlobalHeapSize=%d bytes\n", gdwGHeapSnapshot);
    PRINTF("MaxLocalHeapSize =%d bytes\n", gdwLocalHeapMax);
    PRINTF("MaxLocalStackSize=%d bytes\n", gdwLocalStackMax);
    PRINTF(szFormat, "CtxtObj      ", gdwcCTObjs);
    PRINTF(szFormat, "HeapObj      ", gdwcHPObjs);
    PRINTF(szFormat, "SymbolObj    ", gdwcSYObjs);
    PRINTF(szFormat, "RSAccessObj  ", gdwcRSObjs);
    PRINTF(szFormat, "PassHookObj  ", gdwcPHObjs);
    PRINTF(szFormat, "DataObj      ", gdwcODObjs);
    PRINTF(szFormat, "NSObj        ", gdwcNSObjs);
    PRINTF(szFormat, "OwnerObj     ", gdwcOOObjs);
    PRINTF(szFormat, "BuffFieldObj ", gdwcBFObjs);
    PRINTF(szFormat, "StrDataObj   ", gdwcSDObjs);
    PRINTF(szFormat, "BuffDataObj  ", gdwcBDObjs);
    PRINTF(szFormat, "PackageObj   ", gdwcPKObjs);
    PRINTF(szFormat, "FieldUnitObj ", gdwcFUObjs);
    PRINTF(szFormat, "BankFieldObj ", gdwcKFObjs);
    PRINTF(szFormat, "FieldObj     ", gdwcFObjs);
    PRINTF(szFormat, "IndexFieldObj", gdwcIFObjs);
    PRINTF(szFormat, "OpRegion     ", gdwcORObjs);
    PRINTF(szFormat, "MutexObj     ", gdwcMTObjs);
    PRINTF(szFormat, "EventObj     ", gdwcEVObjs);
    PRINTF(szFormat, "MethodObj    ", gdwcMEObjs);
    PRINTF(szFormat, "PowerResObj  ", gdwcPRObjs);
    PRINTF(szFormat, "ProcessorObj ", gdwcPCObjs);
    PRINTF(szFormat, "CtxtResObj   ", gdwcCRObjs);
    PRINTF(szFormat, "MiscObj      ",
           gdwcMemObjs - gdwcCTObjs - gdwcHPObjs - gdwcSYObjs - gdwcRSObjs -
           gdwcPHObjs - gdwcCRObjs);
}       //DumpMemObjCounts
#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\acpins.c ===
/*** acpins.c - ACPI Name Space functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  GetNameSpaceObject - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> object path string
 *      pnsScope - object scope to start the search (NULL means root)
 *      ppnsObj -> to hold the object found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL GetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                                  ULONG dwfNS)
{
    TRACENAME("GETNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PSZ psz;

    ENTER(3, ("GetNameSpaceObject(ObjPath=%s,Scope=%s,ppns=%x,Flags=%x)\n",
              pszObjPath, GetObjectPath(pnsScope), ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = gpnsNameSpaceRoot;
    }
    else
    {
        psz = pszObjPath;

        while ((*psz == '^') && (pnsScope != NULL))
        {
            psz++;
            pnsScope = pnsScope->pnsParent;
        }
    }

    *ppns = pnsScope;

    if (pnsScope == NULL)
        rc = AMLIERR_OBJ_NOT_FOUND;
    else if (*psz != '\0')
    {
        BOOLEAN fSearchUp;
        PNSOBJ pns;

        fSearchUp = (BOOLEAN)(!(dwfNS & NSF_LOCAL_SCOPE) &&
                              (pszObjPath[0] != '\\') &&
                              (pszObjPath[0] != '^') &&
                              (STRLEN(pszObjPath) <= sizeof(NAMESEG)));
        for (;;)
        {
            do
            {
                if ((pns = pnsScope->pnsFirstChild) == NULL)
                    rc = AMLIERR_OBJ_NOT_FOUND;
                else
                {
                    BOOLEAN fFound;
                    PSZ pszEnd;
                    ULONG dwLen;
                    NAMESEG dwName;

                    if ((pszEnd = STRCHR(psz, '.')) != NULL)
                        dwLen = (ULONG)(pszEnd - psz);
                    else
                        dwLen = STRLEN(psz);

                    if (dwLen > sizeof(NAMESEG))
                    {
                        rc = AMLI_LOGERR(AMLIERR_INVALID_NAME,
                                         ("GetNameSpaceObject: invalid name - %s",
                                          pszObjPath));

                        // Satisfy the compiler...
                        fFound = FALSE;
                    }
                    else
                    {
                        dwName = NAMESEG_BLANK;
                        MEMCPY(&dwName, psz, dwLen);
                        //
                        // Search all siblings for a matching NameSeg.
                        //
                        fFound = FALSE;
                        do
                        {
                            if (pns->dwNameSeg == dwName)
                            {
                                pnsScope = pns;
                                fFound = TRUE;
                                break;
                            }
                            pns = (PNSOBJ)pns->list.plistNext;
                        } while (pns != pns->pnsParent->pnsFirstChild);
                    }

                    if (rc == STATUS_SUCCESS)
                    {
                        if (!fFound)
                            rc = AMLIERR_OBJ_NOT_FOUND;
                        else
                        {
                            psz += dwLen;
                            if (*psz == '.')
                            {
                                psz++;
                            }
                else if (*psz == '\0')
                            {
                                *ppns = pnsScope;
                                break;
                            }
                        }
                    }
                }
            } while (rc == STATUS_SUCCESS);

            if ((rc == AMLIERR_OBJ_NOT_FOUND) && fSearchUp &&
                (pnsScope != NULL) && (pnsScope->pnsParent != NULL))
            {
                pnsScope = pnsScope->pnsParent;
                rc = STATUS_SUCCESS;
            }
            else
            {
                break;
            }
        }
    }

    if ((dwfNS & NSF_WARN_NOTFOUND) && (rc == AMLIERR_OBJ_NOT_FOUND))
    {
        rc = AMLI_LOGERR(rc, ("GetNameSpaceObject: object %s not found",
                              pszObjPath));
    }

    if (rc != STATUS_SUCCESS)
    {
        *ppns = NULL;
    }

    EXIT(3, ("GetNameSpaceObject=%x (pns=%x)\n", rc, *ppns));
    return rc;
}       //GetNameSpaceObject

/***LP  CreateNameSpaceObject - Create a name space object under current scope
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pszName -> name string of the object (NULL if creating noname object)
 *      pnsScope - scope to create object under (NULL means root)
 *      powner -> object owner
 *      ppns -> to hold the pointer to the new object (can be NULL)
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateNameSpaceObject(PHEAP pheap, PSZ pszName, PNSOBJ pnsScope,
                                     POBJOWNER powner, PPNSOBJ ppns,
                                     ULONG dwfNS)
{
    TRACENAME("CREATENAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns = NULL;

    ENTER(3, ("CreateNameSpaceObject(pheap=%x,Name=%s,pnsScope=%x,powner=%x,ppns=%x,Flags=%x)\n",
              pheap, pszName? pszName: "<null>", pnsScope, powner, ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (pszName == NULL)
    {
        if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ))) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("CreateNameSpaceObject: fail to allocate name space object"));
        }
        else
        {
            ASSERT(gpnsNameSpaceRoot != NULL);
            MEMZERO(pns, sizeof(NSOBJ));
            pns->pnsParent = pnsScope;
            InsertOwnerObjList(powner, pns);
            ListInsertTail(&pns->list,
                           (PPLIST)&pnsScope->pnsFirstChild);
        }
    }
    else if ((*pszName != '\0') &&
             ((rc = GetNameSpaceObject(pszName, pnsScope, &pns,
                                       NSF_LOCAL_SCOPE)) == STATUS_SUCCESS))
    {
        if (!(dwfNS & NSF_EXIST_OK))
        {
            rc = AMLI_LOGERR(AMLIERR_OBJ_ALREADY_EXIST,
                             ("CreateNameSpaceObject: object already exist - %s",
                              pszName));
        }
    }
    else if ((*pszName == '\0') || (rc == AMLIERR_OBJ_NOT_FOUND))
    {
        rc = STATUS_SUCCESS;
        //
        // Are we creating root?
        //
        if (STRCMP(pszName, "\\") == 0)
        {
            ASSERT(gpnsNameSpaceRoot == NULL);
            ASSERT(powner == NULL);
            if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ))) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("CreateNameSpaceObject: fail to allocate name space object"));
            }
            else
            {
                MEMZERO(pns, sizeof(NSOBJ));
                pns->dwNameSeg = NAMESEG_ROOT;
                gpnsNameSpaceRoot = pns;
                InsertOwnerObjList(powner, pns);
            }
        }
        else
        {
            PSZ psz;
            PNSOBJ pnsParent;

            if ((psz = STRRCHR(pszName, '.')) != NULL)
            {
                *psz = '\0';
                psz++;
                rc = GetNameSpaceObject(pszName, pnsScope, &pnsParent,
                                        NSF_LOCAL_SCOPE | NSF_WARN_NOTFOUND);
            }
            else if (*pszName == '\\')
            {
                psz = &pszName[1];
                //
                // By this time, we'd better created root already.
                //
                ASSERT(gpnsNameSpaceRoot != NULL);
                pnsParent = gpnsNameSpaceRoot;
            }
            else if (*pszName == '^')
            {
                psz = pszName;
                pnsParent = pnsScope;
                while ((*psz == '^') && (pnsParent != NULL))
                {
                    pnsParent = pnsParent->pnsParent;
                    psz++;
                }
            }
            else
            {
                ASSERT(pnsScope != NULL);
                psz = pszName;
                pnsParent = pnsScope;
            }

            if (rc == STATUS_SUCCESS)
            {
                int iLen = STRLEN(psz);

                if ((*psz != '\0') && (iLen > sizeof(NAMESEG)))
                {
                    rc = AMLI_LOGERR(AMLIERR_INVALID_NAME,
                                     ("CreateNameSpaceObject: invalid name - %s",
                                      psz));
                }
                else if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ)))
                         == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("CreateNameSpaceObject: fail to allocate name space object"));
                }
                else
                {
                    MEMZERO(pns, sizeof(NSOBJ));

                    if (*pszName == '\0')
                        pns->dwNameSeg = NAMESEG_NONE;
                    else
                    {
                        pns->dwNameSeg = NAMESEG_BLANK;
                        MEMCPY(&pns->dwNameSeg, psz, iLen);
                    }

                    pns->pnsParent = pnsParent;
                    InsertOwnerObjList(powner, pns);
                    ListInsertTail(&pns->list,
                                   (PPLIST)&pnsParent->pnsFirstChild);
                }
            }
        }
    }

    if ((rc == STATUS_SUCCESS) && (ppns != NULL))
        *ppns = pns;

    EXIT(3, ("CreateNameSpaceObject=%x (pns=%x)\n", rc, pns));
    return rc;
}       //CreateNameSpaceObject

/***LP  FreeNameSpaceObjects - Free Name Space object and its children
 *
 *  ENTRY
 *      pnsObj -> name space object
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeNameSpaceObjects(PNSOBJ pnsObj)
{
    TRACENAME("FREENAMESPACEOBJECTS")
    PNSOBJ pns, pnsSibling, pnsParent;
  #ifdef DEBUGGER
    POBJSYM pos;
  #endif

    ENTER(3, ("FreeNameSpaceObjects(Obj=%s)\n", GetObjectPath(pnsObj)));

    ASSERT(pnsObj != NULL);

    for (pns = pnsObj; pns != NULL;)
    {
        while (pns->pnsFirstChild != NULL)
        {
            pns = pns->pnsFirstChild;
        }

        pnsSibling = NSGETNEXTSIBLING(pns);
        pnsParent = NSGETPARENT(pns);

        ENTER(4, ("FreeNSObj(Obj=%s)\n", GetObjectPath(pns)));
      #ifdef DEBUGGER
        //
        // If I am in the symbol list, get rid of it before I die.
        //
        for (pos = gDebugger.posSymbolList; pos != NULL; pos = pos->posNext)
        {
            if (pns == pos->pnsObj)
            {
                if (pos->posPrev != NULL)
                    pos->posPrev->posNext = pos->posNext;

                if (pos->posNext != NULL)
                    pos->posNext->posPrev = pos->posPrev;

                if (pos == gDebugger.posSymbolList)
                    gDebugger.posSymbolList = pos->posNext;

                FREESYOBJ(pos);
                break;
            }
        }
      #endif

        //
        // All my children are gone, I must die now.
        //
        ASSERT(pns->pnsFirstChild == NULL);

        if ((pns->ObjData.dwDataType == OBJTYPE_OPREGION) &&
            (((POPREGIONOBJ)pns->ObjData.pbDataBuff)->bRegionSpace ==
             REGSPACE_MEM))
        {
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
            MmUnmapIoSpace((PVOID)
                           ((POPREGIONOBJ)pns->ObjData.pbDataBuff)->uipOffset,
                           ((POPREGIONOBJ)pns->ObjData.pbDataBuff)->dwLen);
        }

        if (pns->pnsParent == NULL)
        {
            //
            // I am root!
            //
            ASSERT(pns == gpnsNameSpaceRoot);
            gpnsNameSpaceRoot = NULL;
        }
        else
        {
            ListRemoveEntry(&pns->list,
                            (PPLIST)&pns->pnsParent->pnsFirstChild);
        }
        //
        // Free any attached data buffer if any
        //
        FreeDataBuffs(&pns->ObjData, 1);
        //
        // Free myself
        //
        if (pns->dwRefCount == 0)
        {
            FREENSOBJ(pns);
        }
        else
        {
            pns->ObjData.dwfData |= DATAF_NSOBJ_DEFUNC;
            ListInsertTail(&pns->list, &gplistDefuncNSObjs);
        }
        EXIT(4, ("FreeNSObj!\n"));

        if (pns == pnsObj)
        {
            //
            // I was the last one, done!
            //
            pns = NULL;
        }
        else if (pnsSibling != NULL)
        {
            //
            // I have siblings, go kill them.
            //
            pns = pnsSibling;
        }
        else
        {
            ASSERT(pnsParent != NULL);
            pns = pnsParent;
        }
    }

    EXIT(3, ("FreeNameSpaceObjects!\n"));
}       //FreeNameSpaceObjects

/***LP  LoadDDB - Load and parse Differentiated Definition Block
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdsdt -> DSDT block
 *      pnsScope -> current scope
 *      ppowner -> to hold new object owner
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS
LOCAL
LoadDDB(
    PCTXT pctxt,
    PDSDT pdsdt,
    PNSOBJ pnsScope,
    POBJOWNER *ppowner
    )
{
    BOOLEAN freeTable = FALSE;
    NTSTATUS rc = STATUS_SUCCESS;

    if (!ValidateTable(pdsdt)) {

        rc = AMLI_LOGERR(
            AMLIERR_INVALID_TABLE,
            ("LoadDDB: invalid table %s at 0x%08x",
             NameSegString(pdsdt->Header.Signature), pdsdt)
            );
        freeTable = TRUE;

    } else {

        rc = NewObjOwner( gpheapGlobal, ppowner);
        if (rc == STATUS_SUCCESS) {

            if (pctxt->pcall == NULL) {

                rc = PushCall(pctxt, NULL, &pctxt->Result);

            }
            if (rc == STATUS_SUCCESS) {

              #ifdef DEBUGGER
                gDebugger.pbBlkBegin = pdsdt->DiffDefBlock;
                gDebugger.pbBlkEnd = (PUCHAR)pdsdt + pdsdt->Header.Length;
              #endif

                rc = PushScope(
                    pctxt,
                    pdsdt->DiffDefBlock,
                    (PUCHAR)pdsdt + pdsdt->Header.Length, pctxt->pbOp,
                    pnsScope, *ppowner, gpheapGlobal, &pctxt->Result
                    );

            }

        } else {

            freeTable = TRUE;

        }

    }

    if (freeTable) {

        pctxt->powner = NULL;
        FreeContext(pctxt);

    }
    return rc;
}       //LoadDDB

/***LP  LoadMemDDB - Load DDB from physical memory
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pDDB -> beginning of DDB
 *      ppowner -> to hold owner handle
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LoadMemDDB(PCTXT pctxt, PDSDT pDDB, POBJOWNER *ppowner)
{
    TRACENAME("LOADMEMDDB")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("LoadMemDDB(pctxt=%x,Addr=%x,ppowner=%x)\n",
              pctxt, pDDB, ppowner));

    if ((ghValidateTable.pfnHandler != NULL) &&
        ((rc = ((PFNVT)ghValidateTable.pfnHandler)(pDDB,
                                                   ghValidateTable.uipParam)) !=
         STATUS_SUCCESS))
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_TABLE,
                         ("LoadMemDDB: table validation failed (rc=%x)",
                          rc));
    }
    else
    {
        rc = LoadDDB(pctxt, pDDB, pctxt->pnsScope, ppowner);
    }

    EXIT(3, ("LoadMemDDB=%x (powner=%x)\n", rc, *ppowner));
    return rc;
}       //LoadMemDDB

/***LP  LoadFieldUnitDDB - Load DDB from a FieldUnit object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> FieldUnit object
 *      ppowner -> to hold owner handle
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LoadFieldUnitDDB(PCTXT pctxt, POBJDATA pdataObj,
                                POBJOWNER *ppowner)
{
    TRACENAME("LOADFIELDUNITDDB")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdataTmp;
    DESCRIPTION_HEADER *pdh;

    ENTER(3, ("LoadFieldUnitDDB(pctxt=%x,pdataObj=%x,ppowner=%x)\n",
              pctxt, pdataObj, ppowner));

    if ((pdataTmp = NEWODOBJ(pctxt->pheapCurrent, sizeof(OBJDATA))) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("LoadFieldUnitDDB: failed to allocate temp. object data"));
    }
    else if ((pdh = NEWBDOBJ(gpheapGlobal, sizeof(DESCRIPTION_HEADER))) == NULL)
    {
        FREEODOBJ(pdataTmp);
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("LoadFieldUnitDDB: failed to allocate description header"));
    }
    else
    {
        PUCHAR pbTable;

        MEMZERO(pdataTmp, sizeof(OBJDATA));
        pdataTmp->dwDataType = OBJTYPE_BUFFDATA;
        pdataTmp->dwDataLen = sizeof(DESCRIPTION_HEADER);
        pdataTmp->pbDataBuff = (PUCHAR)pdh;

        if ((rc = ReadObject(pctxt, pdataObj, pdataTmp)) == STATUS_SUCCESS)
        {
            if ((pbTable = NEWBDOBJ(gpheapGlobal, pdh->Length)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("LoadFieldUnitDDB: failed to allocate buffer"));
            }
            else
            {
                MEMCPY(pbTable, pdh, sizeof(DESCRIPTION_HEADER));
                pdataTmp->dwDataLen = pdh->Length - sizeof(DESCRIPTION_HEADER);
                pdataTmp->pbDataBuff = pbTable + sizeof(DESCRIPTION_HEADER);

                if ((rc = ReadObject(pctxt, pdataObj, pdataTmp)) ==
                    STATUS_SUCCESS)
                {
                    if ((ghValidateTable.pfnHandler != NULL) &&
                        ((rc = ((PFNVT)ghValidateTable.pfnHandler)(
                                   (PDSDT)pbTable, ghValidateTable.uipParam)) !=
                         STATUS_SUCCESS))
                    {
                        rc = AMLI_LOGERR(AMLIERR_INVALID_TABLE,
                                         ("LoadFieldUnitDDB: table validation failed (rc=%x)",
                                          rc));
                    }
                    else
                    {
                        rc = LoadDDB(pctxt, (PDSDT)pbTable, pctxt->pnsScope,
                                     ppowner);
                    }
                }
                else if (rc == AMLISTA_PENDING)
                {
                    rc = AMLI_LOGERR(AMLIERR_FATAL,
                                     ("LoadFieldUnitDDB: definition block loading cannot block"));
                }

                FREEBDOBJ(pbTable);
            }
        }
        else if (rc == AMLISTA_PENDING)
        {
            rc = AMLI_LOGERR(AMLIERR_FATAL,
                             ("LoadFieldUnitDDB: definition block loading cannot block"));
        }

        FREEBDOBJ(pdh);
        FREEODOBJ(pdataTmp);
    }

    EXIT(3, ("LoadFieldUnitDDB=%x (powner=%x)\n", rc, *ppowner));
    return rc;
}       //LoadFieldUnitDDB

/***LP  UnloadDDB - Unload Differentiated Definition Block
 *
 *  ENTRY
 *      powner -> OBJOWNER
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

VOID LOCAL UnloadDDB(POBJOWNER powner)
{
    TRACENAME("UNLOADDDB")

    ENTER(3, ("UnloadDDB(powner=%x)\n", powner));
    //
    // Walk name space and remove all objects belongs to this DDB.
    //
    FreeObjOwner(powner, TRUE);
  #ifdef DEBUG
    {
        KIRQL   oldIrql;

        KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
        gdwGHeapSnapshot = gdwGlobalHeapSize;
        KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
    }
  #endif

    EXIT(3, ("UnloadDDB!\n"));
}       //UnloadDDB

/***LP  EvalPackageElement - Evaluate a package element
 *
 *  ENTRY
 *      ppkg -> package object
 *      iPkgIndex - package index (0-based)
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL EvalPackageElement(PPACKAGEOBJ ppkg, int iPkgIndex,
                                  POBJDATA pdataResult)
{
    TRACENAME("EVALPACKAGEELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("EvalPackageElement(ppkg=%x,Index=%d,pdataResult=%x)\n",
              ppkg, iPkgIndex, pdataResult));

    ASSERT(pdataResult != NULL);
    if (iPkgIndex >= (int)ppkg->dwcElements)
    {
        rc = AMLIERR_INDEX_TOO_BIG;
    }
    else
    {
        rc = DupObjData(gpheapGlobal, pdataResult, &ppkg->adata[iPkgIndex]);
    }

    EXIT(3, ("EvalPackageElement=%x (Type=%s,Value=%x,Len=%d,Buff=%x)\n",
             rc, GetObjectTypeName(pdataResult->dwDataType),
             pdataResult->uipDataValue, pdataResult->dwDataLen,
             pdataResult->pbDataBuff));
    return rc;
}       //EvalPackageElement

#ifdef DEBUGGER
/***LP  DumpNameSpaceObject - Dump name space object
 *
 *  ENTRY
 *      pszPath -> name space path string
 *      fRecursive - TRUE if also dump the subtree recursively
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

LONG LOCAL DumpNameSpaceObject(PSZ pszPath, BOOLEAN fRecursive)
{
    TRACENAME("DUMPNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpNameSpaceObject(Path=%s,fRecursive=%x)\n",
              pszPath, fRecursive));

    if ((rc = GetNameSpaceObject(pszPath, NULL, &pns,
                                 NSF_LOCAL_SCOPE)) == STATUS_SUCCESS)
    {
        PRINTF("\nACPI Name Space: %s (%x)\n", pszPath, pns);
        if (!fRecursive)
        {
            STRCPYN(szName, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
            DumpObject(&pns->ObjData, szName, 0);
        }
        else
            DumpNameSpaceTree(pns, 0);
    }
    else if (rc == AMLIERR_OBJ_NOT_FOUND)
    {
        PRINTF(MODNAME "_ERROR: object %s not found\n", pszPath);
    }

    EXIT(3, ("DumpNameSpaceObject=%x\n", rc));
    return rc;
}       //DumpNameSpaceObject

/***LP  DumpNameSpaceTree - Dump all the name space objects in the subtree
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      dwLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNameSpaceTree(PNSOBJ pnsObj, ULONG dwLevel)
{
    TRACENAME("DUMPNAMESPACETREE")
    PNSOBJ pns, pnsNext;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpNameSpaceTree(pns=%x,level=%d)\n", pnsObj, dwLevel));
    //
    // First, dump myself
    //
    STRCPYN(szName, (PSZ)&pnsObj->dwNameSeg, sizeof(NAMESEG));
    DumpObject(&pnsObj->ObjData, szName, dwLevel);
    //
    // Then, recursively dump each of my children
    //
    for (pns = pnsObj->pnsFirstChild; pns != NULL; pns = pnsNext)
    {
        //
        // If this is the last child, we have no more.
        //
        if ((pnsNext = (PNSOBJ)pns->list.plistNext) == pnsObj->pnsFirstChild)
            pnsNext = NULL;
        //
        // Dump a child
        //
        DumpNameSpaceTree(pns, dwLevel + 1);
    }

    EXIT(3, ("DumpNameSpaceTree!\n"));
}       //DumpNameSpaceTree

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amldebug.h ===
/*** amldebug.h - AML Debugger Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLDEBUG_H
#define _AMLDEBUG_H

#ifdef DEBUGGER

/*** Constants
 */

// DNS flags
#define DNSF_RECURSE            0x00000001

// DS flags
#define DSF_VERBOSE             0x00000001

// dwfDebug flags
#define DBGF_IN_DEBUGGER    0x00000001
#define DBGF_IN_VXDMODE         0x00000002
#define DBGF_IN_KDSHELL         0x00000004
#define DBGF_VERBOSE_ON         0x00000008
#define DBGF_AMLTRACE_ON        0x00000010
#define DBGF_TRIGGER_MODE       0x00000020
#define DBGF_SINGLE_STEP        0x00000040
#define DBGF_STEP_OVER          0x00000080
#define DBGF_STEP_MODES         (DBGF_SINGLE_STEP | DBGF_STEP_OVER)
#define DBGF_TRACE_NONEST       0x00000100
#define DBGF_DUMPDATA_PHYADDR   0x00000200
//
// Important! Don't move the DBGF_DUMPDATA_* bits unless you update the
// following DATASIZE() macro.
//
#define DBGF_DUMPDATA_MASK      0x00000c00
#define DBGF_DUMPDATA_BYTE      0x00000000
#define DBGF_DUMPDATA_WORD      0x00000400
#define DBGF_DUMPDATA_DWORD     0x00000800
#define DBGF_DUMPDATA_STRING    0x00000c00
#define DATASIZE(f)             (((f) == DBGF_DUMPDATA_STRING)? 0:      \
                                 (1L << ((f) >> 10)))

#define DBGF_DEBUGGER_REQ       0x00001000
#define DBGF_CHECKING_TRACE     0x00002000
#define DBGF_ERRBREAK_ON        0x00004000
#define DBGF_LOGEVENT_ON        0x00008000
#define DBGF_LOGEVENT_MUTEX     0x00010000
#define DBGF_DEBUG_SPEW_ON      0x00020000

#define MAX_TRIG_PTS            10
#define MAX_TRIGPT_LEN          31
#endif
#define MAX_ERRBUFF_LEN         255
#define MAX_BRK_PTS             10

#ifdef DEBUGGER
#define MAX_UNASM_CODES         0x10

#define DEF_MAXLOG_ENTRIES      204     //8K buffer

/*** Macros
 */

#define ASSERTRANGE(p,n)      (TRUE)

#endif
/*** Type definitions
 */

#define BPF_ENABLED             0x00000001

typedef struct _brkpt
{
    ULONG  dwfBrkPt;
    PUCHAR pbBrkPt;
} BRKPT, *PBRKPT;

typedef struct _objsym
{
    struct _objsym *posPrev;
    struct _objsym *posNext;
    PUCHAR pbOp;
    PNSOBJ pnsObj;
} OBJSYM, *POBJSYM;

typedef struct _eventlog
{
    ULONG         dwEvent;
    ULONGLONG     ullTime;
    ULONG_PTR     uipData1;
    ULONG_PTR     uipData2;
    ULONG_PTR     uipData3;
    ULONG_PTR     uipData4;
    ULONG_PTR     uipData5;
    ULONG_PTR     uipData6;
    ULONG_PTR     uipData7;
} EVENTLOG, *PEVENTLOG;


typedef struct _dbgr
{
    ULONG     dwfDebugger;
    int       iPrintLevel;
    ULONG_PTR uipDumpDataAddr;
    PUCHAR    pbUnAsm;
    PUCHAR    pbUnAsmEnd;
    PUCHAR    pbBlkBegin;
    PUCHAR    pbBlkEnd;
    POBJSYM   posSymbolList;
    BRKPT     BrkPts[MAX_BRK_PTS];
    ULONG     dwLogSize;
    ULONG     dwLogIndex;
    PEVENTLOG pEventLog;
    EVHANDLE  hConMessage;
    EVHANDLE  hConPrompt;
    NTSTATUS  rcLastError;
    char      szLastError[MAX_ERRBUFF_LEN + 1];
} DBGR, *PDBGR;

/*** Exported Data
 */

extern DBGR gDebugger;
#ifdef DEBUGGER
/*** Exported function prototypes
 */

VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj);
VOID LOCAL FreeSymList(VOID);
int LOCAL CheckBP(PUCHAR pbOp);
VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen);
VOID LOCAL PrintIndent(PCTXT pctxt);
VOID LOCAL PrintObject(POBJDATA pdata);
VOID LOCAL LogEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                    ULONG_PTR uipData3, ULONG_PTR uipData4, ULONG_PTR uipData5,
                    ULONG_PTR uipData6, ULONG_PTR uipData7);
VOID LOCAL LogSchedEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                         ULONG_PTR uipData3);
BOOLEAN LOCAL SetLogSize(ULONG dwLogSize);
VOID LOCAL LogError(NTSTATUS rcErr);
VOID LOCAL CatError(PSZ pszFormat, ...);
VOID LOCAL ConPrintf(PSZ pszFormat, ...);
VOID LOCAL ConPrompt(PSZ pszPrompt, PSZ pszBuff, ULONG dwcbBuff);
BOOLEAN LOCAL CheckAndEnableDebugSpew(BOOLEAN fEnable);

#endif  //ifdef DEBUGGER

#ifdef DEBUG
VOID LOCAL DumpMemObjCounts(VOID);
#endif  //ifdef DEBUG

#endif  //ifndef _AMLDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amliapi.c ===
/*** amliapi.c - AMLI APIs
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
//#include "amlihook.h"
//#include "amlitest.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/*++
OSIAML contains the AML for the _OSI Method. This AML is generated from the following ASL:

Method(_OSI, 0x1, NotSerialized)
{
    Return(OSI(Arg0))
}
--*/

UCHAR OSIAML[] = {
                    0xa4, 0xca, 0x68
                  };


/***EP  AMLIInitialize - Initialize AML interpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIInitialize | AML Interpreter initialization.
 *
 *          This function must be called before any AML interpreter functions
 *          can be called.  This function will typically allocate and
 *          initialize global resources, create the ACPI name space etc.
 *          It is typically called in the initialization of the ACPI core
 *          driver.
 *
 *  @PARM   ULONG | dwCtxtBlkSize | Specifies the size of Context blocks.  If
 *          zero, use default context block size.
 *
 *  @PARM   ULONG | dwGlobalHeapBlkSize | Specifies the size of Global heap.
 *          If zero, use default global heap size.
 *
 *  @PARM   ULONG | dwfAMLIInit | AMLI initialization flags.
 *
 *  @FLAG   AMLIIF_INIT_BREAK | Break into the debugger at initialization
 *          completion.
 *
 *  @FLAG   AMLIIF_LOADDDB_BREAK | Break into the debugger at load definition
 *          block completion.
 *
 *  @PARM   ULONG | dwmsTimeSliceLength | Time slice length in msec.
 *
 *  @PARM   ULONG | dwmsTimeSliceInterval | Time slice interval in msec.
 *
 *  @PARM   ULONG | dwmsMaxCTObjs | Number of context to allocate
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIInitialize(ULONG dwCtxtBlkSize, ULONG dwGlobalHeapBlkSize,
                                ULONG dwfAMLIInit, ULONG dwmsTimeSliceLength,
                                ULONG dwmsTimeSliceInterval, ULONG dwmsMaxCTObjs)
{
    TRACENAME("AMLIINITIALIZE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLIInitialize(InitFlags=%x,CtxtBlkSize=%d,GlobalHeapBlkSize=%d,TimeSliceLen=%d,TimeSliceInterval=%d)\n",
              dwfAMLIInit, dwCtxtBlkSize, dwGlobalHeapBlkSize,
              dwmsTimeSliceLength, dwmsTimeSliceInterval));

  #ifndef DEBUGGER
    DEREF(dwfAMLIInit);
  #endif

    RESETERR();
    if (gpnsNameSpaceRoot != NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_ALREADY_INITIALIZED,
                         ("AMLIInitialize: interpreter already initialized"));
    }
    else
    {
        gdwCtxtBlkSize = dwCtxtBlkSize ? dwCtxtBlkSize: DEF_CTXTBLK_SIZE;
        gdwGlobalHeapBlkSize = dwGlobalHeapBlkSize? dwGlobalHeapBlkSize:
                                                    DEF_GLOBALHEAPBLK_SIZE;
        gdwfAMLIInit = dwfAMLIInit;
        gdwfHacks = GetHackFlags(NULL);

        //
        // Sanity Check
        //
        if (dwmsMaxCTObjs > 1024) {

            dwmsMaxCTObjs = 1024;

        }
        gdwcCTObjsMax = (dwmsMaxCTObjs > DEF_CTXTMAX_SIZE) ? dwmsMaxCTObjs :
                                                             DEF_CTXTMAX_SIZE;

      #ifdef DEBUGGER
        //   gDebugger.dwfDebugger |= (DBGF_LOGEVENT_ON | DBGF_ERRBREAK_ON);
        gDebugger.dwfDebugger |= DBGF_LOGEVENT_ON;
        SetLogSize(DEF_MAXLOG_ENTRIES);
        KeInitializeSpinLock( &gdwGHeapSpinLock );
      #endif
        KeInitializeSpinLock( &gdwGContextSpinLock );

        //
        // Initialize the LookAside lists.
        //
        ExInitializeNPagedLookasideList(
            &AMLIContextLookAsideList,
            NULL,
            NULL,
            0,
            gdwCtxtBlkSize,
            CTOBJ_TAG,
            (USHORT) gdwcCTObjsMax
            );

        if ((rc = NewHeap(gdwGlobalHeapBlkSize, &gpheapGlobal)) ==
            STATUS_SUCCESS)
        {
            int i;
            PNSOBJ pns;
            static PSZ apszDefinedRootObjs[] =
            {
                "_GPE", "_PR", "_SB", "_SI", "_TZ"
            };
            #define NUM_DEFINED_ROOT_OBJS (sizeof(apszDefinedRootObjs)/sizeof(PSZ))

            gpheapGlobal->pheapHead = gpheapGlobal;
            if ((rc = CreateNameSpaceObject(gpheapGlobal, NAMESTR_ROOT, NULL,
                                            NULL, NULL, 0)) == STATUS_SUCCESS)
            {
                for (i = 0; i < NUM_DEFINED_ROOT_OBJS; ++i)
                {
                    if ((rc = CreateNameSpaceObject(gpheapGlobal,
                                                    apszDefinedRootObjs[i],
                                                    NULL, NULL, NULL, 0)) !=
                        STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_REV", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwDataType = OBJTYPE_INTDATA;
                pns->ObjData.uipDataValue = AMLI_REVISION;
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_OS", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwDataType = OBJTYPE_STRDATA;
                pns->ObjData.dwDataLen = STRLEN(gpszOSName) + 1;
                if ((pns->ObjData.pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                        pns->ObjData.dwDataLen))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("AMLIInitialize: failed to allocate \\_OS name object"));
                }
                else
                {
                    MEMCPY(pns->ObjData.pbDataBuff, gpszOSName,
                           pns->ObjData.dwDataLen);
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal,"_OSI", NULL, NULL,
                                              &pns, 0)) == STATUS_SUCCESS))
            {

                pns->ObjData.dwDataType = OBJTYPE_METHOD;
                pns->ObjData.dwDataLen = sizeof(METHODOBJ) + sizeof(OSIAML) - sizeof(UCHAR);
                if ((pns->ObjData.pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                        pns->ObjData.dwDataLen))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("AMLIInitiaize: failed to allocate \\_OSI name object"));
                }
                else
                {
                    MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
                    //This method has one argument
                    ((PMETHODOBJ)(pns->ObjData.pbDataBuff))->bMethodFlags |=  0x1; 
                    
                    MEMCPY(((PMETHODOBJ)(pns->ObjData.pbDataBuff))->abCodeBuff, (PUCHAR)OSIAML,
                           sizeof(OSIAML));
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_GL", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwfData = DATAF_GLOBAL_LOCK;
                rc = InitMutex(gpheapGlobal, pns, 0);
            }

            if (rc == STATUS_SUCCESS)
            {
                gReadyQueue.dwmsTimeSliceLength = dwmsTimeSliceLength?
                                                    dwmsTimeSliceLength:
                                                    DEF_TIMESLICE_LENGTH;
                gReadyQueue.dwmsTimeSliceInterval = dwmsTimeSliceInterval?
                                                      dwmsTimeSliceInterval:
                                                      DEF_TIMESLICE_INTERVAL;
                KeInitializeTimer(&gReadyQueue.Timer);
                InitializeMutex(&gReadyQueue.mutCtxtQ);
                ExInitializeWorkItem(&gReadyQueue.WorkItem,
                                     StartTimeSlicePassive, &gReadyQueue);
                InitializeMutex(&gmutCtxtList);
                InitializeMutex(&gmutOwnerList);
                InitializeMutex(&gmutHeap);
                InitializeMutex(&gmutSleep);
                KeInitializeDpc(&gReadyQueue.DpcStartTimeSlice,
                                StartTimeSlice,
                                &gReadyQueue);
                KeInitializeDpc(&gReadyQueue.DpcExpireTimeSlice,
                                ExpireTimeSlice,
                                &gReadyQueue);
                KeInitializeDpc(&SleepDpc, SleepQueueDpc, NULL);
                KeInitializeTimer(&SleepTimer);
                InitializeListHead(&SleepQueue);
                InitializeRegOverrideFlags();
                InitIllegalIOAddressListFromHAL();
            }
        }
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

  #ifdef DEBUGGER
    if (gdwfAMLIInit & AMLIIF_INIT_BREAK)
    {
        PRINTF("\n" MODNAME ": Break at AMLI Initialization Completion.\n");
        AMLIDebugger(FALSE);
    }
  #endif

    EXIT(1, ("AMLIInitialize=%x\n", rc));
    return rc;
}       //AMLIInitialize

/***EP  AMLITerminate - Terminate AML interpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLITerminate | AML Interpreter termination.
 *
 *          This function is called to clean up all the global resources used
 *          by the AML interpreter.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLITerminate(VOID)
{
    TRACENAME("AMLITERMINATE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLITerminate()\n"));

    RESETERR();
    if (gpnsNameSpaceRoot == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_NOT_INITIALIZED,
                         ("AMLITerminate: interpreter not initialized"));
    }
    else
    {
        PLIST plist;
        PHEAP pheap;

      #ifdef DEBUGGER
        FreeSymList();
        if (gDebugger.pEventLog != NULL)
        {
            MFREE(gDebugger.pEventLog);
        }
        MEMZERO(&gDebugger, sizeof(DBGR));
      #endif

        ASSERT(gReadyQueue.pkthCurrent == NULL);
        ASSERT(gReadyQueue.pctxtCurrent == NULL);
        FreeNameSpaceObjects(gpnsNameSpaceRoot);
        gpnsNameSpaceRoot = NULL;
        MEMZERO(&gReadyQueue, sizeof(CTXTQ));

        while ((plist = ListRemoveTail(&gplistCtxtHead)) != NULL)
        {
            FreeContext(CONTAINING_RECORD(plist, CTXT, listCtxt));
        }

        while ((plist = ListRemoveTail(&gplistObjOwners)) != NULL)
        {
            FreeObjOwner((POBJOWNER)plist, FALSE);
        }

        while ((plist = ListRemoveTail(&gplistDefuncNSObjs)) != NULL)
        {
            FREENSOBJ(CONTAINING_RECORD(plist, NSOBJ, list));
        }

        FreeRSAccessList(gpRSAccessHead);
        gpRSAccessHead = NULL;
        MEMZERO(&ghNotify, sizeof(EVHANDLE));
        MEMZERO(&ghValidateTable, sizeof(EVHANDLE));
        MEMZERO(&ghFatal, sizeof(EVHANDLE));
        MEMZERO(&ghGlobalLock, sizeof(EVHANDLE));
        MEMZERO(&ghCreate, sizeof(EVHANDLE));
        MEMZERO(&ghDestroyObj,sizeof(EVHANDLE));
        for (pheap = gpheapGlobal; pheap != NULL; pheap = gpheapGlobal)
        {
            gpheapGlobal = pheap->pheapNext;
            FreeHeap(pheap);
        }

        FreellegalIOAddressList();

        gdwfAMLI = 0;

      #ifdef DEBUG
        if (gdwcMemObjs != 0)
        {
            DumpMemObjCounts();
            ASSERT(gdwcMemObjs == 0);
        }
      #endif
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    EXIT(1, ("AMLITerminate=%x\n", rc));
    return rc;
}       //AMLITerminate

/***EP  AMLILoadDDB - Load and parse Differentiated Definition Block
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLILoadDDB | Load Differentiated Definition Block.
 *
 *          This function loads and parses the given Differentiated System
 *          Description Table as well as any dynamic Differentiated Definition
 *          Block.  It will parse the DDB and populate the ACPI name space
 *          accordingly.
 *
 *  @PARM   PDSDT | pDSDT | Pointer to a DSDT block.
 *
 *  @PARM   HANDLE * | phDDB | Pointer to the variable that will receive
 *          the DDB handle (can be NULL).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code if encountering parse error.
 *
 *  @DEVNOTE If an error occurs in the middle of loading a DDB, the loading
 *          will be aborted but the objects created prior to the error remain
 *          in the name space.  Therefore, it is the responsibility of the
 *          caller to call AMLIUnLoadDDB to destroy the created objects if
 *          desired and the return handle is not NULL.
 */

NTSTATUS AMLIAPI AMLILoadDDB(PDSDT pDSDT, HANDLE *phDDB)
{
    TRACENAME("AMLILOADDDB")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;
    POBJOWNER powner = NULL;

    ENTER(1, ("AMLILoadDDB(pDSDT=%x,phDDB=%x)\n", pDSDT, phDDB));

    ASSERT(pDSDT != NULL);
    RESETERR();
    CHKDEBUGGERREQ();

    gInitTime = TRUE;
    
  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
    {
        PRINTF(MODNAME ": %08x: Loading Definition Block %s at 0x%08x.\n",
               KeGetCurrentThread(), NameSegString(pDSDT->Header.Signature),
               pDSDT);
    }
  #endif

    gdwfHacks |= GetHackFlags(pDSDT);

    if ((rc = NewContext(&pctxt)) == STATUS_SUCCESS)
    {
        ASSERT(gpheapGlobal != NULL);
        pctxt->pheapCurrent = gpheapGlobal;

      #ifdef DEBUG
        gdwfAMLI |= AMLIF_LOADING_DDB;
      #endif

        if (atLoad.pfnCallBack != NULL && atLoad.dwfOpcode & OF_CALLBACK_EX) {

            ((PFNOPEX)atLoad.pfnCallBack)(
                EVTYPE_OPCODE_EX,
                OPEXF_NOTIFY_PRE,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        }

        rc = LoadDDB(pctxt,pDSDT, gpnsNameSpaceRoot, &powner);
        if (rc == STATUS_SUCCESS)
        {
            rc = SyncLoadDDB(pctxt);
        }

      #ifdef DEBUG
        {
            KIRQL   oldIrql;

            gdwfAMLI &= ~AMLIF_LOADING_DDB;
            KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
            gdwGHeapSnapshot = gdwGlobalHeapSize;
            KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
        }
      #endif
    }

    if (phDDB != NULL)
    {
        *phDDB = (HANDLE)powner;
    }

    if ((powner != NULL) && (atLoad.pfnCallBack != NULL))
    {
        if (atLoad.dwfOpcode & OF_CALLBACK_EX) {

            ((PFNOPEX)atLoad.pfnCallBack)(
                EVTYPE_OPCODE_EX,
                OPEXF_NOTIFY_POST,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        } else {

            atLoad.pfnCallBack(
                EVTYPE_OPCODE,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        }
    }

  #ifdef DEBUGGER
    if (gdwfAMLIInit & AMLIIF_LOADDDB_BREAK)
    {
        PRINTF("\n" MODNAME ": Break at Load Definition Block Completion.\n");
        AMLIDebugger(FALSE);
    }
  #endif

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    gInitTime = FALSE;
    
    EXIT(1, ("AMLILoadDDB=%x (powner=%x)\n", rc, powner));
    return rc;
}       //AMLILoadDDB

/***EP  AMLIUnloadDDB - Unload Differentiated Definition Block
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIUnloadDDB | Unload the Differentiated Definition Block.
 *
 *          This function is called to unload the given dynamic DDB object and
 *          clean it out of the name space.  Note that this function does not
 *          differentiate between a DSDT from a dynamic DDB, so it is the
 *          caller's responsibility to not freeing the DSDT accidentally.
 *
 *  @PARM   HANDLE | hDDB | handle to the definition block context to be
 *          unloaded.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIUnloadDDB(HANDLE hDDB)
{
    TRACENAME("AMLIUNLOADDDB")

    ENTER(1, ("AMLIUnloadDDB(hDDB=%x)\n", hDDB));

    RESETERR();
    if (hDDB != NULL)
    {
        ASSERT(((POBJOWNER)hDDB)->dwSig == SIG_OBJOWNER);
        UnloadDDB((POBJOWNER)hDDB);
    }

    EXIT(1, ("AMLIUnloadDDB!\n"));
}       //AMLIUnloadDDB

/***EP  AMLIGetNameSpaceObject - Find a name space object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetNameSpaceObject | Find an object in the ACPI
 *          name space.
 *
 *          This function accepts an absolute object path as well as a
 *          relative object path in the form of an ASCIIZ string.
 *          It will search through the name space in the appropriate
 *          scope for the given object path and returns the object
 *          pointer when it is found.
 *
 *  @PARM   PSZ | pszObjPath | Pointer to an ASCIIZ string specifying the
 *          object path.
 *
 *  @PARM   PNSOBJ | pnsScope | If not NULL, this points to the object scope
 *          where the search starts.  If pszObjPath is specifying an absolute
 *          path, this parameter is ignored.
 *
 *  @PARM   PPNSOBJ | ppns | Pointer to a variable to hold the object
 *          point.
 *
 *  @PARM   ULONG | dwfFlags | Option flags.
 *
 *  @FLAG   NSF_LOCAL_SCOPE | Search local scope only.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIGetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope,
                                        PPNSOBJ ppns, ULONG dwfFlags)
{
    TRACENAME("AMLIGETNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIGetNameSpaceObject(ObjPath=%s,Scope=%s,ppns=%p,Flags=%x)\n",
              pszObjPath, GetObjectPath(pnsScope), ppns, dwfFlags));

    ASSERT(pszObjPath != NULL);
    ASSERT(*pszObjPath != '\0');
    ASSERT(ppns != NULL);
    RESETERR();
    CHKDEBUGGERREQ();


    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Pre_GetNameSpaceObject(
         pszObjPath,pnsScope,ppns,dwfFlags,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }

    if ((pnsScope != NULL) && (pnsScope->ObjData.dwfData & DATAF_NSOBJ_DEFUNC))
    {
        AMLI_WARN(("AMLIGetNameSpaceObject: pnsScope is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        ASSERT((pnsScope == NULL) || !(pnsScope->ObjData.dwfData & DATAF_NSOBJ_DEFUNC));
        rc = GetNameSpaceObject(pszObjPath, pnsScope, ppns, dwfFlags);
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {
      rc = AMLITest_Post_GetNameSpaceObject(
         &pHData,rc);
      }


    EXIT(1, ("AMLIGetNameSpaceObject=%x (pns=%p)\n", rc, *ppns));
    return rc;
}       //AMLIGetNameSpaceObject

/***EP  AMLIGetFieldUnitRegionObj - Get OpRegion associated with FieldUnit
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetFieldUnitRegionObj | Get the OperationRegion
 *          object associated with the FieldUnit object.
 *
 *  @PARM   PFIELDUNITOBJ | pfu | Pointer to a FieldUnit object.
 *
 *  @PARM   PPNSOBJ | ppns | Pointer to a variable to hold the OperationRegion
 *          object.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIGetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns)
{
    TRACENAME("AMLIGETFIELDUNITREGIONOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;


    ENTER(1, ("AMLIGetFieldUnitRegionObj(pfu=%x,ppns=%x)\n", pfu, ppns));

    ASSERT(pfu != NULL);
    ASSERT(ppns != NULL);
    RESETERR();

    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Pre_GetFieldUnitRegionObj(
         pfu,ppns,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }

    rc = GetFieldUnitRegionObj(pfu, ppns);

    if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Post_GetFieldUnitRegionObj(
          &pHData,rc);
      }

    EXIT(1, ("AMLIGetFieldUnitRegionObj=%x (pns=%x)\n", rc, *ppns));
    return rc;
}       //AMLIGetFieldUnitRegionObj

/***EP  AMLIEvalNameSpaceObject - Evaluate a name space object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalNameSpaceObject | Evaluate a name space object.
 *
 *          This function evaluate a given object.  If the given object is a
 *          control method, it will execute it.  If the given object is a data
 *          object, the data value is returned in a given buffer.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalNameSpaceObject(PNSOBJ pns, POBJDATA pdataResult,
                                         int icArgs, POBJDATA pdataArgs)
{
    TRACENAME("AMLIEVALNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIEvalNameSpaceObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalNameSpaceObject(
         pns,pdataResult,icArgs,pdataArgs,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }


    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIEvalNameSpaceObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %08x: EvalNameSpaceObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = SyncEvalObject(pns, pdataResult, icArgs, pdataArgs);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalNameSpaceObject(
          &pHData,rc);
      }


    EXIT(1, ("AMLIEvalNameSpaceObject=%x\n", rc));
    return rc;
}       //AMLIEvalNameSpaceObject

/***EP  AMLIAsyncEvalObject - Evaluate an object asynchronously
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIAsyncEvalObject | Evaluate an object asynchronously.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @PARM   PFNACB | pfnAsyncCallBack | Pointer to the asynchronous callback
 *          function in case the control method is blocked and has to be
 *          completed asynchronously (can be NULL if no Callback required).
 *
 *  @PARM   PVOID | pvContext | Pointer to some context data that the
 *          interpreter will pass to the Async callback handler.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                     int icArgs, POBJDATA pdataArgs,
                                     PFNACB pfnAsyncCallBack, PVOID pvContext)
{
    TRACENAME("AMLIASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_AsyncEvalObject(
         pns,pdataResult,icArgs,pdataArgs,
         &pfnAsyncCallBack,&pvContext,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }



    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIAsyncEvalObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %08x: AsyncEvalObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = AsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                             pfnAsyncCallBack, pvContext, TRUE);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_AsyncEvalObject(
          &pHData,rc);
      }


    EXIT(1, ("AMLIAsyncEvalObject=%x\n", rc));
    return rc;
}       //AMLIAsyncEvalObject

/***EP  AMLINestAsyncEvalObject - Evaluate an object asynchronously from within
 *                                the current context
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLINestAsyncEvalObject | Evaluate an object
 *          asynchronously from within the current context.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @PARM   PFNACB | pfnAsyncCallBack | Pointer to the asynchronous callback
 *          function in case the control method is blocked and has to be
 *          completed asynchronously (can be NULL if no Callback required).
 *
 *  @PARM   PVOID | pvContext | Pointer to some context data that the
 *          interpreter will pass to the Async callback handler.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLINestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                         int icArgs, POBJDATA pdataArgs,
                                         PFNACB pfnAsyncCallBack,
                                         PVOID pvContext)
{
    TRACENAME("AMLINESTASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;


    ENTER(1, ("AMLINestAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_NestAsyncEvalObject(
         pns,pdataResult,icArgs,pdataArgs,
         &pfnAsyncCallBack,&pvContext,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);


      }


    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLINestAsyncEvalObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %08x: AsyncNestEvalObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = NestAsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                                 pfnAsyncCallBack, pvContext, TRUE);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_NestAsyncEvalObject(
          &pHData,rc);
      }

    EXIT(1, ("AMLINestAsyncEvalObject=%x\n", rc));
    return rc;
}       //AMLINestAsyncEvalObject

/***EP  AMLIEvalPackageElement - Evaluate a package element
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalPackageElement | Evaluate a package element.
 *
 *          This function evaluate an element of a given package object.
 *          A package is essentially an array of objects.  This API provides
 *          a way to evaluate individual element object inside a package.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the package object to be evaluated.  If
 *          the object is a method, then the method is evaluated first before
 *          the resulting package object is evaluated.  It is an error if the
 *          resulting object is not of package type.
 *
 *  @PARM   int | iPkgIndex | Package index (0-based).
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalPackageElement(PNSOBJ pns, int iPkgIndex,
                                        POBJDATA pdataResult)
{
    TRACENAME("AMLIEVALPACKAGEELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;
    OBJDATA data;
    POBJDATA pdata = NULL;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIEvalPackageElement(Obj=%s,Index=%d,pdataResult=%x)\n",
              GetObjectPath(pns), iPkgIndex, pdataResult));

    ASSERT(pns != NULL);
    ASSERT(pdataResult != NULL);
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();


    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalPackageElement(
         pns,iPkgIndex,pdataResult,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }



    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIEvalPackageElement: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        MEMZERO(pdataResult, sizeof(OBJDATA));
        MEMZERO(&data, sizeof(data));
        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %08x: EvalPackageElement(%s,%d)\n",
                   KeGetCurrentThread(), GetObjectPath(pns), iPkgIndex);
        }
      #endif

        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            if ((rc = SyncEvalObject(pns, &data, 0, NULL)) == STATUS_SUCCESS)
            {
                if (data.dwDataType == OBJTYPE_PKGDATA)
                    pdata = &data;
                else
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("AMLIEvalPackageElement: result object of the method is not package (ObjType=%s)",
                                      GetObjectTypeName(data.dwDataType)));
                }
            }
        }
        else if (pns->ObjData.dwDataType == OBJTYPE_PKGDATA)
        {
            pdata = &pns->ObjData;
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("AMLIEvalPackageElement: object is not a method or package (ObjType=%s)",
                              GetObjectTypeName(pns->ObjData.dwDataType)));
        }

        if (rc == STATUS_SUCCESS)
        {
            rc = EvalPackageElement((PPACKAGEOBJ)pdata->pbDataBuff, iPkgIndex,
                                    pdataResult);
        }
        FreeDataBuffs(&data, 1);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
        else
        {
            ASSERT((pdataResult->pbDataBuff == NULL) ||
                   !(pdataResult->dwfData & DATAF_BUFF_ALIAS));
        }
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalPackageElement(
          &pHData,rc);
      }




    EXIT(1, ("AMLIEvalPackageElement=%x\n", rc));
    return rc;
}       //AMLIEvalPackageElement

/***EP  AMLIEvalPkgDataElement - Evaluate an element of a package data
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalPkgDataElement | Evaluate a package data element.
 *
 *          This function evaluate an element of a given package data object.
 *          A package is essentially an array of objects.  This API provides
 *          a way to evaluate individual element object inside a package.
 *
 *  @PARM   POBJDATA | pdataPkg | Pointer to the package data object to be
 *          evaluated.  It is an error if the data object is not of package
 *          type.
 *
 *  @PARM   int | iPkgIndex | Package index (0-based).
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalPkgDataElement(POBJDATA pdataPkg, int iPkgIndex,
                                        POBJDATA pdataResult)
{
    TRACENAME("AMLIEVALPKGDATAELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIEvalPkgDataElement(pdataPkg=%x,Index=%d,pdataResult=%x)\n",
              pdataPkg, iPkgIndex, pdataResult));

    ASSERT(pdataResult != NULL);
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    MEMZERO(pdataResult, sizeof(OBJDATA));


    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalPkgDataElement(
         pdataPkg,iPkgIndex,pdataResult,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }


  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
    {
        PRINTF(MODNAME ": %08x: EvalPkgDataElement(%x,%d)\n",
               KeGetCurrentThread(), pdataPkg, iPkgIndex);
    }
  #endif

    if (pdataPkg->dwDataType != OBJTYPE_PKGDATA)
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                         ("AMLIEvalPkgDataElement: object is not a package (ObjType=%s)",
                          GetObjectTypeName(pdataPkg->dwDataType)));
    }
    else
    {
        rc = EvalPackageElement((PPACKAGEOBJ)pdataPkg->pbDataBuff, iPkgIndex,
                                pdataResult);
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);
    else
    {
        ASSERT((pdataResult->pbDataBuff == NULL) ||
               !(pdataResult->dwfData & DATAF_BUFF_ALIAS));
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalPkgDataElement(
          &pHData,rc);
      }


    EXIT(1, ("AMLIEvalPkgDataElement=%x\n", rc));
    return rc;
}       //AMLIEvalPkgDataElement

/***EP  AMLIFreeDataBuffs - Free data buffers of an object array
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIFreeDataBuffs | Free data buffers of a data object
 *          array.
 *
 *          This function is typically called after evaluating an object to
 *          free the result object buffers.
 *
 *  @PARM   POBJDATA | pdata | Pointer to the object array.
 *
 *  @PARM   int | icData | Specifies the number of objects in the array.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIFreeDataBuffs(POBJDATA pdata, int icData)
{
    TRACENAME("AMLIFREEDATABUFFS")
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIFreeDataBuffs(pdata=%x,icData=%d)\n", pdata, icData));

    ASSERT(pdata != NULL);
    ASSERT(icData > 0);
    RESETERR();

    if(IsAmliHookEnabled())
      {

      AMLITest_Pre_FreeDataBuffs(
         pdata,icData,&pHData);

      }

    FreeDataBuffs(pdata, icData);

    if(IsAmliHookEnabled())
      {

      AMLITest_Post_FreeDataBuffs(
          &pHData,STATUS_SUCCESS);
      }

    EXIT(1, ("AMLIFreeDataBuffs!\n"));
}       //AMLIFreeDataBuffs

/***EP  AMLIRegEventHandler - Register an event handler
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIRegEventHandler | Register an event handler.
 *          handler.
 *
 *          This function allows the caller to hook a callback handler for some
 *          AMLI events.
 *
 *  @PARM   ULONG | dwEventType | Event type the handler will handle.
 *
 *  @PARM   ULONG_PTR | uipEventData | Event specific data the handler will
 *          handle.
 *
 *  @PARM   PFNHND | pfnHandler | Callback handler entry point (can be NULL
 *          if deregistering previous handler).
 *
 *  @PARM   ULONG_PTR | uipParam | Parameter Data (will be passed to the
 *          callback handler).
 *
 *  @RDESC  None.
 */

NTSTATUS AMLIAPI AMLIRegEventHandler(ULONG dwEventType, ULONG_PTR uipEventData,
                                     PFNHND pfnHandler, ULONG_PTR uipParam)
{
    TRACENAME("AMLIREGEVENTHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIRegEventHandler(EventType=%x,EventData=%x,pfnHandler=%x,Param=%x)\n",
              dwEventType, uipEventData, pfnHandler, uipParam));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      rc = AMLIHook_Pre_RegEventHandler(
         dwEventType,uipEventData,&pfnHandler,&uipParam,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);


      }

    switch (dwEventType)
    {
        case EVTYPE_OPCODE:
            rc = RegOpcodeHandler((ULONG)uipEventData, (PFNOH)pfnHandler,
                                  uipParam, 0);
            break;

        case EVTYPE_OPCODE_EX:
            rc = RegOpcodeHandler((ULONG)uipEventData, (PFNOH)pfnHandler,
                                  uipParam, OF_CALLBACK_EX);
            break;

        case EVTYPE_NOTIFY:
            rc = RegEventHandler(&ghNotify, pfnHandler, uipParam);
            break;

        case EVTYPE_FATAL:
            rc = RegEventHandler(&ghFatal, pfnHandler, uipParam);
            break;

        case EVTYPE_VALIDATE_TABLE:
            rc = RegEventHandler(&ghValidateTable, pfnHandler, uipParam);
            break;

        case EVTYPE_ACQREL_GLOBALLOCK:
            rc = RegEventHandler(&ghGlobalLock, pfnHandler, uipParam);
            break;

        case EVTYPE_RS_COOKACCESS:
            rc = RegRSAccess((ULONG)uipEventData, pfnHandler, uipParam, FALSE);
            break;

        case EVTYPE_RS_RAWACCESS:
            rc = RegRSAccess((ULONG)uipEventData, pfnHandler, uipParam, TRUE);
            break;

        case EVTYPE_CREATE:
            rc = RegEventHandler(&ghCreate, pfnHandler, uipParam);
            break;

        case EVTYPE_DESTROYOBJ:
            rc =RegEventHandler(&ghDestroyObj, pfnHandler, uipParam);
            break;

      #ifdef DEBUGGER
        case EVTYPE_CON_MESSAGE:
            rc = RegEventHandler(&gDebugger.hConMessage, pfnHandler, uipParam);
            break;

        case EVTYPE_CON_PROMPT:
            rc = RegEventHandler(&gDebugger.hConPrompt, pfnHandler, uipParam);
            break;
      #endif

        default:
            rc = AMLI_LOGERR(AMLIERR_INVALID_EVENTTYPE,
                             ("AMLIRegEventHandler: invalid event type %x",
                              dwEventType));
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

      rc = AMLIHook_Post_RegEventHandler(
          &pHData,rc);
      }


    EXIT(1, ("AMLIRegEventHandler=%x\n", rc));
    return rc;
}       //AMLIRegEventHandler

/***EP  AMLIPauseInterpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIPauseInterpreter | Flush the interpreter queue
 *          and pause the interpreter so that all subsequent new method
 *          execution requests will be queued.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIPauseInterpreter(PFNAA pfnCallback, PVOID Context)
{
    TRACENAME("AMLIPAUSEINTERPRETER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;


    ENTER(1, ("AMLIPauseInterpreter(Callback=%p,Context=%p)\n",
              pfnCallback, Context));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_PauseInterpreter(
         &pfnCallback,&Context,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }



    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if (!(gReadyQueue.dwfCtxtQ & (CQF_PAUSED | CQF_FLUSHING)))
    {
        if (gplistCtxtHead == NULL)
        {
            //
            // There is no pending ctxt.
            //
            gReadyQueue.dwfCtxtQ |= CQF_PAUSED;
        }
        else
        {
            //
            // There are pending ctxts, so we go into flushing mode.
            //
            gReadyQueue.dwfCtxtQ |= CQF_FLUSHING;
            gReadyQueue.pfnPauseCallback = pfnCallback;
            gReadyQueue.PauseCBContext = Context;
            rc = AMLISTA_PENDING;
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("AMLIPauseInterpreter: interpreter already entered paused state"));
    }
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    LOGSCHEDEVENT('PAUS', (ULONG_PTR)rc, 0, 0);

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_PauseInterpreter(
          &pHData,rc);
      }

    EXIT(1, ("AMLIPauseInterpreter=%x\n", rc));
    return rc;
}       //AMLIPauseInterpreter

/***EP  AMLIResumeInterpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIResumeInterpreter | Resume the interpreter from
 *          paused state.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIResumeInterpreter(VOID)
{

    PAMLIHOOK_DATA pHData = NULL;

    TRACENAME("AMLIRESUMEINTERPRETER")

    ENTER(1, ("AMLIResumeInterpreter()\n"));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      AMLITest_Pre_ResumeInterpreter(
         &pHData);
      }

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if (gReadyQueue.dwfCtxtQ & (CQF_PAUSED | CQF_FLUSHING))
    {
        gReadyQueue.dwfCtxtQ &= ~(CQF_PAUSED | CQF_FLUSHING);
        gReadyQueue.pfnPauseCallback = NULL;
        gReadyQueue.PauseCBContext = NULL;
        LOGSCHEDEVENT('RSUM', 0, 0, 0);
        if ((gReadyQueue.plistCtxtQ != NULL) &&
            !(gReadyQueue.dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
        {
            OSQueueWorkItem(&gReadyQueue.WorkItem);
            gReadyQueue.dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
            LOGSCHEDEVENT('RSTQ', 0, 0, 0);
        }
    }
    else
    {
        AMLI_WARN(("AMLIResumeInterpreter: not in paused state"));
    }
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    if(IsAmliHookEnabled())
      {

      AMLITest_Post_ResumeInterpreter(
          &pHData,STATUS_SUCCESS);
      }



    EXIT(1, ("AMLIResumeInterpreter!\n"));
}       //AMLIResumeInterpreter

/***EP  AMLIReferenceObject - Bump up the reference count of the object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIReferenceObject | Bump up the reference count of the
 *          name space object.
 *
 *  @PARM   PNSOBJ | pnsObj | Points to the name space object.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIReferenceObject(PNSOBJ pnsObj)
{
    TRACENAME("AMLIREFERENCEOBJECT")

    ENTER(1, ("AMLIReferenceObject(pnsObj=%x)\n", pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);
    pnsObj->dwRefCount++;
    EXIT(1, ("AMLIReferenceObj!\n"));
}       //AMLIReferenceObject

/***EP  AMLIDereferenceObject - Bump down the reference count of the object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIDereferenceObject | Bump down the reference count of the
 *          name space object.  If it reaches zero and it is in defunc state,
 *          deallocate the object.
 *
 *  @PARM   PNSOBJ | pnsObj | Points to the name space object.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIDereferenceObject(PNSOBJ pnsObj)
{
    TRACENAME("AMLIDEREFERENCEOBJECT")

    ENTER(1, ("AMLIDereferenceObject(pnsObj=%x)\n", pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);
    ASSERT(pnsObj->dwRefCount > 0);

    if (pnsObj->dwRefCount > 0)
    {
        pnsObj->dwRefCount--;
        if ((pnsObj->dwRefCount == 0) && (pnsObj->ObjData.dwfData & DATAF_NSOBJ_DEFUNC))
        {
            ListRemoveEntry(&pnsObj->list, &gplistDefuncNSObjs);
            FREENSOBJ(pnsObj);
        }
    }

    EXIT(1, ("AMLIDereferenceObj!\n"));
}       //AMLIDereferenceObject

/***EP  AMLIDestroyFreedObjs - Destroy freed objects during an unload
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIDestroyFreedObjs | Destroy freed objects from a
 *          previous unload.
 *
 *  @PARM   PNSOBJ | pnsObj | The object in the freed list to be destroyed.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIDestroyFreedObjs(PNSOBJ pnsObj)
{
    TRACENAME("AMLIDESTROYFREEDOBJS")

    ENTER(1, ("AMLIDestroyFreedObjs(pnsObj=%x)\n",pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);

    //
    // Destroy the namespace object
    //
    FreeNameSpaceObjects(pnsObj);

    EXIT(1, ("AMLIDestroyFreedObjs=%x \n",STATUS_SUCCESS));
    return STATUS_SUCCESS;
}       //AMLIDestroyFreedObjs

#ifdef DEBUGGER
/***EP  AMLIGetLastError - Get last error code and message
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetLastError | Get last error code and associated
 *          error message.
 *
 *  @PARM   PSZ * | ppszErrMsg | Point to a variable to hold the error message
 *          buffer pointer.  If there is no error, the variable is set to NULL.
 *
 *  @RDESC  Returns the last error code.
 */

NTSTATUS AMLIAPI AMLIGetLastError(PSZ *ppszErrMsg)
{
    TRACENAME("AMLIGETLASTERROR")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLIGetLastError(ppszErrMsg=%x)\n", ppszErrMsg));

    ASSERT(ppszErrMsg != NULL);

    if ((rc = gDebugger.rcLastError) != STATUS_SUCCESS)
        *ppszErrMsg = gDebugger.szLastError;
    else
        *ppszErrMsg = NULL;

    EXIT(1, ("AMLIGetLastError=%x (Msg=%s)\n",
             rc, *ppszErrMsg? *ppszErrMsg: "<null>"));
    return rc;
}       //AMLIGetLastError
#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amlihook.c ===
/*++
Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    acpitl.c

Abstract:

    

Environment:

    kernel mode only

Notes:

  
    Things acpi.sys needs to do.

   1) Call  AmliHook_InitTestHookInterface() in its DriverEntry() very early.  

   This functyion will hook the amli functions if acpiver.sys is installed.

   2) Call AmliHook_UnInitTestHookInterface() on driver unload.
      This is not inteded to be called to disable Amli Hooking at runtime.


  

--*/


/*
#include "wdm.h"
#include "ntdddisk.h"
#include "stdarg.h"
#include "stdio.h"   */
//#include "wdm.h"

#include "pch.h"

//#include "amlihook.h" 

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ihVA')
#endif

//
//  Globals
//

PCALLBACK_OBJECT g_AmliHookCallbackObject = NULL;
ULONG g_AmliHookTestFlags=0;
ULONG g_AmliHookIdCounter=0;
ULONG g_AmliHookEnabled = 0;


//
// -- Get dbg flags
//

extern NTSTATUS OSGetRegistryValue( 
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information);

extern NTSTATUS OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle);

extern NTSTATUS
OSCloseHandle(
    HANDLE  Key);

//
//  Internal function defines.
//
ULONG
AmliHook_GetUniqueId(
   VOID);

//
//  Functions
//


ULONG 
AmliHook_GetDbgFlags(
   VOID)
   {

   UNICODE_STRING DriverKey;
   HANDLE DriverKeyHandle;
   NTSTATUS        status;
   PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  RegValue=NULL;
   ULONG DebugFlags;


   RtlInitUnicodeString( &DriverKey, 
      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\acpiver");


   status = OSOpenUnicodeHandle( 
     &DriverKey,
     NULL,
     &DriverKeyHandle);
   
   if (!NT_SUCCESS(status)) 
      {
      return(0);
      }


   status = OSGetRegistryValue(
      DriverKeyHandle,
      L"AcpiCtrl",
      &RegValue);

   if (!NT_SUCCESS(status)) 
      {
      OSCloseHandle(DriverKeyHandle);
      return(0);
      }

   if(RegValue->DataLength == 0  ||
      RegValue->Type != REG_DWORD) 
      {
      ExFreePool(RegValue);
      return(0);
      }

   DebugFlags = 
      *((ULONG*)( ((PUCHAR)RegValue->Data)));

   ExFreePool(RegValue);

   return(DebugFlags); 
   }

ULONG
AmliHook_GetUniqueId(
   VOID)
   {

   //  BUGBUG For some reason acpi.sys 
   //  will not link with this.
   //  Acpiver doesn't use the ID yet.
   //
   //return(InterlockedIncrement(
   //    &g_AmliHookIdCounter));

   g_AmliHookIdCounter++;
   return(g_AmliHookIdCounter);
   }

VOID
AmliHook_InitTestData(
   PAMLIHOOK_DATA Data)
   {
   RtlZeroMemory(Data,sizeof(AMLIHOOK_DATA));

   Data->Id = AmliHook_GetUniqueId();
   }

PAMLIHOOK_DATA
AmliHook_AllocAndInitTestData(
   VOID)
   {

   PAMLIHOOK_DATA Data = ExAllocatePool(NonPagedPool,sizeof(AMLIHOOK_DATA));
   if(!Data)
      {
      AmliHook_ProcessInternalError();
      return(NULL);
      }
   AmliHook_InitTestData(Data);
   return(Data);
   }

//
//  AmliHook_UnInitTestHookInterface
//

VOID
AmliHook_UnInitTestHookInterface(
   VOID)
   {

   if(g_AmliHookCallbackObject) 
      ObDereferenceObject(g_AmliHookCallbackObject);

   

   }

//
//  AmliHook_InitTestHookInterface
//

NTSTATUS
AmliHook_InitTestHookInterface(
   VOID)
   {
   NTSTATUS  status = STATUS_SUCCESS;
   
   g_AmliHookCallbackObject = NULL;
   g_AmliHookIdCounter = 0;
   g_AmliHookEnabled = 0;

   g_AmliHookTestFlags = AmliHook_GetDbgFlags();
 
   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_HOOK_MASK)
      {

      //
      //--- We want to hook the AMLI.api interface.
      //--- So create the notify interface.
      //

      OBJECT_ATTRIBUTES   objectAttributes;
      UNICODE_STRING CallBackName;
    
      RtlInitUnicodeString(&CallBackName,AMLIHOOK_CALLBACK_NAME);

      InitializeObjectAttributes (
          &objectAttributes,
         &CallBackName,
         OBJ_CASE_INSENSITIVE | OBJ_PERMANENT ,
         NULL,       
         NULL);
    
      status = ExCreateCallback(
          &g_AmliHookCallbackObject,
         &objectAttributes,
         TRUE, 
         TRUE);

      if(!NT_SUCCESS(status)) 
         {
         //
         //--- Failed 
         //
         AmliHook_ProcessInternalError();

         g_AmliHookCallbackObject = NULL;

         return(status);
         }
      else
         {

         //
         //--- Functions are hooked.
         //

         g_AmliHookEnabled = AMLIHOOK_ENABLED_VALUE;

         }
      }

   return(status);
   }


//
//  AmliHook_TestNotify
//

NTSTATUS
AmliHook_TestNotify(
   PAMLIHOOK_DATA Data)
   {

   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_NO_NOTIFY_ON_CALL)
      {
      //
      //--- do not notify on call, 
      //
      if(Data->State & AMLIHOOK_TEST_DATA_CALL_STATE_MASK)
         return(STATUS_SUCCESS);
      }

   if(!g_AmliHookCallbackObject)
      {
      AmliHook_ProcessInternalError();
      return(STATUS_UNSUCCESSFUL);
      }

    ExNotifyCallback(
      g_AmliHookCallbackObject,
      Data,
      NULL);

   return(STATUS_SUCCESS);
   }

NTSTATUS
AmliHook_TestNotifyRet(
   PAMLIHOOK_DATA Data,
   NTSTATUS Status)
   {

     
   if(!g_AmliHookCallbackObject)
      {
      AmliHook_ProcessInternalError();
      return(STATUS_UNSUCCESSFUL);
      }

   Data->State = AMLIHOOK_TEST_DATA_STATE_RETURN;
   Data->Ret = Status;

   ExNotifyCallback(
      g_AmliHookCallbackObject,
      Data,
      NULL);

   return(Data->Ret);
   }



VOID
AmliHook_ProcessInternalError(
   VOID)
   {

   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_DBG_ON_ERROR)
      DbgBreakPoint();

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amlihook.h ===
#ifndef _AMLI_HOOK_
#define _AMLI_HOOK_


extern ULONG g_AmliHookEnabled;

#define AMLIHOOK_ENABLED_VALUE       608

//
//  AcpitlTestFlags
//

#define AMLIHOOK_TEST_FLAGS_HOOK_API  1
#define AMLIHOOK_TEST_FLAGS_DBG_ON_ERROR   2
#define AMLIHOOK_TEST_FLAGS_NO_NOTIFY_ON_CALL  4

#define AMLIHOOK_TEST_FLAGS_HOOK_MASK  ((ULONG)(AMLIHOOK_TEST_FLAGS_HOOK_API))

//
//  AMLIHOOK_DATA call back data struct
//


typedef struct _AMLIHOOK_DATA
{
 UCHAR Type;
 UCHAR SubType;
 ULONG State;
 ULONG Id;
 ULONG_PTR Arg1;
 ULONG_PTR Arg2;
 ULONG_PTR Arg3;
 ULONG_PTR Arg4;
 ULONG_PTR Arg5;
 ULONG_PTR Arg6;
 ULONG_PTR Arg7;
 NTSTATUS Ret;
} AMLIHOOK_DATA , *PAMLIHOOK_DATA;

//
//--- state member
//
#define AMLIHOOK_TEST_DATA_STATE_CALL        1
#define AMLIHOOK_TEST_DATA_STATE_RETURN      2
#define AMLIHOOK_TEST_DATA_STATE_ASYNC_CALL  3
#define AMLIHOOK_TEST_DATA_STATE_QUERY       4

#define AMLIHOOK_TEST_DATA_CALL_STATE_MASK (AMLIHOOK_TEST_DATA_STATE_CALL | AMLIHOOK_TEST_DATA_STATE_ASYNC_CALL)


#define AMLIHOOK_CALLBACK_NAME  L"\\Callback\\AMLIHOOK"

#define IsAmliHookEnabled()  g_AmliHookEnabled

ULONG 
AmliHook_GetDbgFlags(
   VOID);

VOID
AmliHook_InitTestData(
   PAMLIHOOK_DATA Data);

PAMLIHOOK_DATA
AmliHook_AllocAndInitTestData(
   VOID);

NTSTATUS
AmliHook_InitTestHookInterface(
   VOID);

VOID
AmliHook_UnInitTestHookInterface(
   VOID);

NTSTATUS
AmliHook_TestNotify(
   PAMLIHOOK_DATA Data);

NTSTATUS
AmliHook_TestNotifyRet(
   PAMLIHOOK_DATA Data,
   NTSTATUS Status);

VOID
AmliHook_ProcessInternalError(
   VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amlipriv.h ===
/*** amlipriv.h - AML Interpreter Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLIPRIV_H
#define _AMLIPRIV_H

/*** Macros
 */

/*XLATOFF*/

#define MODNAME         "AMLI"

#ifndef DEBUG
  #define AMLI_WARN(x)
  #define AMLI_ERROR(x)
  #define CHKGLOBALHEAP()
#else
  #define AMLI_WARN(x)          ConPrintf(MODNAME "_WARN: ");           \
                                ConPrintf x;                            \
                                ConPrintf("\n");
  #define AMLI_ERROR(x)         ConPrintf(MODNAME "_ERROR: ");          \
                                ConPrintf x;                            \
                                ConPrintf("\n");                        \
                                KdBreakPoint();                         \
                                CHKDEBUGGERREQ();
  #define CHKGLOBALHEAP() 

#endif

#ifndef DEBUGGER
  #define PRINTF
  #define AMLI_LOGERR(rc,p)     (rc)
  #define RESETERR()
  #define CHKDEBUGGERREQ()
  #define LOGSCHEDEVENT(ev,d1,d2,d3)
  #define LOGEVENT(ev,d1,d2,d3,d4,d5,d6,d7)
  #define LOGMUTEXEVENT(ev,d1,d2,d3,d4,d5,d6,d7)
#else
  #define PRINTF                ConPrintf
  #define AMLI_LOGERR(rc,p)     (LogError(rc), CatError p, (rc))
  #define RESETERR()            {gDebugger.rcLastError = STATUS_SUCCESS;\
                                 gDebugger.szLastError[0] = '\0';       \
                                }
  #define CHKDEBUGGERREQ()      if (gDebugger.dwfDebugger & DBGF_DEBUGGER_REQ) \
                                {                                              \
                                    ConPrintf("\nProcess AML Debugger Request.\n");\
                                    gDebugger.dwfDebugger &=                   \
                                        ~DBGF_DEBUGGER_REQ;                    \
                                    AMLIDebugger(FALSE);                       \
                                }
  #define LOGEVENT              LogEvent
  #define LOGSCHEDEVENT         LogSchedEvent
  #define LOGMUTEXEVENT(ev,d1,d2,d3,d4,d5,d6,d7)                        \
                                if (gDebugger.dwfDebugger & DBGF_LOGEVENT_MUTEX)\
                                {                                       \
                                    LogEvent(ev,d1,d2,d3,d4,d5,d6,d7);  \
                                }
#endif

#define LOCAL           __cdecl
#define DEREF(x)        ((x) = (x))
#define BYTEOF(d,i)     (((PUCHAR)&d)[i])
#define WORDOF(d,i)     (((PUSHORT)&d)[i])

//
// NTRAID#60804-2000/06/20-splante Remove dependence on static translation
//
#define HalTranslateBusAddress(InterfaceType,BusNumber,BusAddress,AddressSpace,TranslatedAddress) \
                              (*(TranslatedAddress) = (BusAddress), TRUE)

//
// The various tags
//
#define CTOBJ_TAG       'ClmA'
#define HPOBJ_TAG       'HlmA'
#define PRIV_TAG        'IlmA'
#define PHOBJ_TAG       'PlmA'
#define RSOBJ_TAG       'RlmA'
#define SYOBJ_TAG       'SlmA'
#define RTOBJ_TAG       'TlmA'

// Memory management macros
#define ALLOCPOOL               ExAllocatePool
#define ALLOCPOOLWITHTAG        ExAllocatePoolWithTag
#ifdef DEBUG
  #ifndef MAXWINNT_DEBUG
    #define MALLOC_PAGED(n,t)   (++gdwcMemObjs,                         \
                                 ALLOCPOOLWITHTAG(                      \
                                   (gdwfAMLI & AMLIF_LOCKED)?           \
                                   NonPagedPool: PagedPool, n, t))
    #define MALLOC_LOCKED(n,t)  (++gdwcMemObjs,                         \
                                 ALLOCPOOLWITHTAG(                      \
                                   NonPagedPool, n, t))
  #else
    #define MALLOC_PAGED(n,t)   (++gdwcMemObjs,                         \
                                 ExAllocatePoolWithTagPriority(         \
                                   (gdwfAMLI & AMLIF_LOCKED)?           \
                                   NonPagedPool: PagedPool, n, t,       \
                                   HighPoolPrioritySpecialPoolOverrun))
    #define MALLOC_LOCKED(n,t)  (++gdwcMemObjs,                         \
                                 ExAllocatePoolWithTagPriority(         \
                                   NonPagedPool, n, t,                  \
                                   HighPoolPrioritySpecialPoolOverrun))
  #endif

  #define MALLOC                MALLOC_LOCKED

  #define MFREE(p)              FreeMem(p, &gdwcMemObjs)

  #define NEWHPOBJ(n)           (++gdwcHPObjs, MALLOC(n, HPOBJ_TAG))
  #define FREEHPOBJ(p)          {MFREE(p); --gdwcHPObjs;}

  #define NEWSYOBJ(n)           (++gdwcSYObjs, MALLOC_LOCKED(n, SYOBJ_TAG))
  #define FREESYOBJ(p)          {MFREE(p); --gdwcSYObjs;}

  #define NEWRSOBJ(n)           (++gdwcRSObjs, MALLOC_LOCKED(n, RSOBJ_TAG))
  #define FREERSOBJ(p)          {MFREE(p); --gdwcRSObjs;}

  #define NEWPHOBJ(n)           (++gdwcPHObjs, MALLOC_LOCKED(n, PHOBJ_TAG))
  #define FREEPHOBJ(p)          {MFREE(p); --gdwcPHObjs;}

  #define NEWRESTOBJ(n)         (MALLOC_LOCKED(n, RTOBJ_TAG))
  #define FREERESTOBJ(p)        (MFREE(p))

  #define NEWOBJDATA(h,p)       NewObjData(h, p)
  #define FREEOBJDATA(p)        FreeObjData(p)

  #define NEWODOBJ(h,n)         (++gdwcODObjs, HeapAlloc(h, 'TADH', n))
  #define FREEODOBJ(p)          {HeapFree(p); --gdwcODObjs;}

  #define NEWNSOBJ(h,n)         (++gdwcNSObjs, HeapAlloc(h, 'OSNH', n))
  #define FREENSOBJ(p)          {HeapFree(p); --gdwcNSObjs;}

  #define NEWOOOBJ(h,n)         (++gdwcOOObjs, HeapAlloc(h, 'NWOH', n))
  #define FREEOOOBJ(p)          {HeapFree(p); --gdwcOOObjs;}

  #define NEWSDOBJ(h,n)         (++gdwcSDObjs, HeapAlloc(h, 'RTSH', n))
  #define FREESDOBJ(p)          {HeapFree(p); --gdwcSDObjs;}

  #define NEWBDOBJ(h,n)         (++gdwcBDObjs, HeapAlloc(h, 'FUBH', n))
  #define FREEBDOBJ(p)          {HeapFree(p); --gdwcBDObjs;}

  #define NEWPKOBJ(h,n)         (++gdwcPKObjs, HeapAlloc(h, 'GKPH', n))
  #define FREEPKOBJ(p)          {HeapFree(p); --gdwcPKObjs;}

  #define NEWBFOBJ(h,n)         (++gdwcBFObjs, HeapAlloc(h, 'DFBH', n))
  #define FREEBFOBJ(p)          {HeapFree(p); --gdwcBFObjs;}

  #define NEWFUOBJ(h,n)         (++gdwcFUObjs, HeapAlloc(h, 'UDFH', n))
  #define FREEFUOBJ(p)          {HeapFree(p); --gdwcFUObjs;}

  #define NEWKFOBJ(h,n)         (++gdwcKFObjs, HeapAlloc(h, 'FKBH', n))
  #define FREEKFOBJ(p)          {HeapFree(p); --gdwcKFObjs;}

  #define NEWFOBJ(h,n)          (++gdwcFObjs, HeapAlloc(h, 'ODFH', n))
  #define FREEFOBJ(p)           {HeapFree(p); --gdwcFObjs;}

  #define NEWIFOBJ(h,n)         (++gdwcIFObjs, HeapAlloc(h, 'FXIH', n))
  #define FREEIFOBJ(p)          {HeapFree(p); --gdwcIFObjs;}

  #define NEWOROBJ(h,n)         (++gdwcORObjs, HeapAlloc(h, 'GROH', n))
  #define FREEOROBJ(p)          {HeapFree(p); --gdwcORObjs;}

  #define NEWMTOBJ(h,n)         (++gdwcMTObjs, HeapAlloc(h, 'TUMH', n))
  #define FREEMTOBJ(p)          {HeapFree(p); --gdwcMTObjs;}

  #define NEWEVOBJ(h,n)         (++gdwcEVObjs, HeapAlloc(h, 'NVEH', n))
  #define FREEEVOBJ(p)          {HeapFree(p); --gdwcEVObjs;}

  #define NEWMEOBJ(h,n)         (++gdwcMEObjs, HeapAlloc(h, 'TEMH', n))
  #define FREEMEOBJ(p)          {HeapFree(p); --gdwcMEObjs;}

  #define NEWPROBJ(h,n)         (++gdwcPRObjs, HeapAlloc(h, 'SRPH', n))
  #define FREEPROBJ(p)          {HeapFree(p); --gdwcPRObjs;}

  #define NEWPCOBJ(h,n)         (++gdwcPCObjs, HeapAlloc(h, 'ORPH', n))
  #define FREEPCOBJ(p)          {HeapFree(p); --gdwcPCObjs;}

  #define NEWCROBJ(h,n)         (++gdwcCRObjs, HeapAlloc(h, 'RNWO', n))
  #define FREECROBJ(p)          {HeapFree(p); --gdwcCRObjs;}
#else
  #define MALLOC_PAGED(n,t)     ALLOCPOOLWITHTAG(PagedPool, n, t)
  #define MALLOC_LOCKED(n,t)    ALLOCPOOLWITHTAG(NonPagedPool, n, t)
  #define MALLOC                MALLOC_LOCKED
  #define MFREE(p)              ExFreePool(p)

  #define NEWHPOBJ(n)           MALLOC(n, HPOBJ_TAG)
  #define FREEHPOBJ(p)          MFREE(p)

  #define NEWSYOBJ(n)           MALLOC_LOCKED(n, SYOBJ_TAG)
  #define FREESYOBJ(p)          MFREE(p)

  #define NEWRSOBJ(n)           MALLOC_LOCKED(n, RSOBJ_TAG)
  #define FREERSOBJ(p)          MFREE(p)

  #define NEWPHOBJ(n)           MALLOC_LOCKED(n, PHOBJ_TAG)
  #define FREEPHOBJ(p)          MFREE(p)

  #define NEWRESTOBJ(n)         MALLOC_LOCKED(n, RTOBJ_TAG)
  #define FREERESTOBJ(p)        MFREE(p)

  #define NEWOBJDATA(h,p)       NewObjData(h,p)
  #define FREEOBJDATA(p)        FreeObjData(p)

  #define NEWODOBJ(h,n)         HeapAlloc(h, 'TADH', n)
  #define FREEODOBJ(p)          HeapFree(p)

  #define NEWNSOBJ(h,n)         HeapAlloc(h, 'OSNH', n)
  #define FREENSOBJ(p)          HeapFree(p)

  #define NEWOOOBJ(h,n)         HeapAlloc(h, 'NWOH', n)
  #define FREEOOOBJ(p)          HeapFree(p)

  #define NEWSDOBJ(h,n)         HeapAlloc(h, 'RTSH', n)
  #define FREESDOBJ(p)          HeapFree(p)

  #define NEWBDOBJ(h,n)         HeapAlloc(h, 'FUBH', n)
  #define FREEBDOBJ(p)          HeapFree(p)

  #define NEWPKOBJ(h,n)         HeapAlloc(h, 'GKPH', n)
  #define FREEPKOBJ(p)          HeapFree(p)

  #define NEWBFOBJ(h,n)         HeapAlloc(h, 'DFBH', n)
  #define FREEBFOBJ(p)          HeapFree(p)

  #define NEWFUOBJ(h,n)         HeapAlloc(h, 'UDFH', n)
  #define FREEFUOBJ(p)          HeapFree(p)

  #define NEWKFOBJ(h,n)         HeapAlloc(h, 'FKBH', n)
  #define FREEKFOBJ(p)          HeapFree(p)

  #define NEWFOBJ(h,n)          HeapAlloc(h, 'ODFH', n)
  #define FREEFOBJ(p)           HeapFree(p)

  #define NEWIFOBJ(h,n)         HeapAlloc(h, 'FXIH', n)
  #define FREEIFOBJ(p)          HeapFree(p)

  #define NEWOROBJ(h,n)         HeapAlloc(h, 'GROH', n)
  #define FREEOROBJ(p)          HeapFree(p)

  #define NEWMTOBJ(h,n)         HeapAlloc(h, 'TUMH', n)
  #define FREEMTOBJ(p)          HeapFree(p)

  #define NEWEVOBJ(h,n)         HeapAlloc(h, 'NVEH', n)
  #define FREEEVOBJ(p)          HeapFree(p)

  #define NEWMEOBJ(h,n)         HeapAlloc(h, 'TEMH', n)
  #define FREEMEOBJ(p)          HeapFree(p)

  #define NEWPROBJ(h,n)         HeapAlloc(h, 'SRPH', n)
  #define FREEPROBJ(p)          HeapFree(p)

  #define NEWPCOBJ(h,n)         HeapAlloc(h, 'ORPH', n)
  #define FREEPCOBJ(p)          HeapFree(p)

  #define NEWCROBJ(h,n)         HeapAlloc(h, 'RNWO', n)
  #define FREECROBJ(p)          HeapFree(p)
#endif
#define MEMCPY                  RtlCopyMemory
#define MEMZERO                 RtlZeroMemory

#define ISLEADNAMECHAR(c)       (((c) >= 'A') && ((c) <= 'Z') || ((c) == '_'))
#define ISNAMECHAR(c)           (ISLEADNAMECHAR(c) || ((c) >= '0') && ((c) <= '9'))
#define SHIFTLEFT(d,c)          (((c) >= 32)? 0: (d) << (c))
#define SHIFTRIGHT(d,c)         (((c) >= 32)? 0: (d) >> (c))
#define MIN(a,b)                (((a) > (b))? (b): (a))
#define MAX(a,b)                (((a) > (b))? (a): (b))

/*XLATON*/

/*** Constants
 */

// These are internal error codes which aren't really errors
#define AMLISTA_DONE            0x00008000
#define AMLISTA_BREAK           0x00008001
#define AMLISTA_RETURN          0x00008002
#define AMLISTA_CONTINUE        0x00008003
#define AMLISTA_PENDING         0x00008004
#define AMLISTA_TIMEOUT         0x00008005

// Global AMLI flags
#define AMLIF_LOCKED            0x00000001
#define AMLIF_IN_LOCKPHASE      0x00000002
#define AMLIF_LOADING_DDB       0x80000000

// Error Log
#define READ_ERROR_NOTED        0x00000001
#define WRITE_ERROR_NOTED       0x00000002

//
// AMLI Override FLAGS
//
#define AMLI_OVERRIDE_IO_ADDRESS_CHECK  0x00000001

// Global Hack flags
#define HACKF_OLDSLEEP          0x00000001

//
// AMLI Reg Attributes key
//
#define AMLI_ATTRIBUTES "AMLIAttributes"


#define ARGTYPE_NAME            'N'             //name argument
#define ARGTYPE_DATAOBJ         'O'             //data argument
#define ARGTYPE_DWORD           'D'             //numeric dword argument
#define ARGTYPE_WORD            'W'             //numeric word argument
#define ARGTYPE_BYTE            'B'             //numeric byte argument
#define ARGTYPE_SNAME           'S'             //supername argument
#define ARGTYPE_SNAME2          's'             //supername argument
                                                //  object can be non-existing
#define ARGTYPE_OPCODE          'C'             //opcode argument

// Argument object type (used for type validation)
#define ARGOBJ_UNKNOWN          'U'             //OBJTYPE_UNKNOWN - don't care
#define ARGOBJ_INTDATA          'I'             //OBJTYPE_INTDATA
#define ARGOBJ_STRDATA          'Z'             //OBJTYPE_STRDATA
#define ARGOBJ_BUFFDATA         'B'             //OBJTYPE_BUFFDATA
#define ARGOBJ_PKGDATA          'P'             //OBJTYPE_PKGDATA
#define ARGOBJ_FIELDUNIT        'F'             //OBJTYPE_FIELDUNIT
#define ARGOBJ_OBJALIAS         'O'             //OBJTYPE_OBJALIAS
#define ARGOBJ_DATAALIAS        'A'             //OBJTYPE_DATAALIAS
#define ARGOBJ_BASICDATA        'D'             //INTDATA,STRDATA,BUFFDATA
#define ARGOBJ_COMPLEXDATA      'C'             //BUFFDATA,PKGDATA
#define ARGOBJ_REFERENCE        'R'             //OBJALIAS,DATAALIAS,BUFFFIELD

#define MAX_BYTE                0xff
#define MAX_WORD                0xffff
#define MAX_DWORD               0xffffffff
#define MAX_NUM_LOCALS          8
#define MAX_NUM_ARGS            7
#define MAX_NAME_LEN            255
#if defined (_WIN64)
#define DEF_CTXTBLK_SIZE        (4096*4)        //16K context block
#else
#define DEF_CTXTBLK_SIZE        (4096*2)        //8K context block
#endif
#define DEF_CTXTMAX_SIZE        16              //16 Contexts
#define DEF_GLOBALHEAPBLK_SIZE  (4096*16)       //64K global heap block
#define DEF_TIMESLICE_LENGTH    100             //100ms
#define DEF_TIMESLICE_INTERVAL  100             //100ms
#if defined(_WIN64)
  #define DEF_HEAP_ALIGNMENT    8               //QWord aligned
#else
  #define DEF_HEAP_ALIGNMENT    4               //DWord aligned
#endif

#define AMLI_REVISION           1
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_NONE            0x00000000      // ""
#define NAMESTR_ROOT            "\\"
#define CREATORID_MSFT          "MSFT"
#define MIN_CREATOR_REV         0x01000000

// dwfNS local flags
#define NSF_EXIST_OK            0x00010000      //for CreateNameSpaceObject
#define NSF_WARN_NOTFOUND       0x80000000      //for GetNameSpaceObject

/*** Type and Structure definitions
 */

typedef NTSTATUS (LOCAL *PFNOP)(PFRAME, PPNSOBJ);

typedef struct _amlterm
{
    PSZ   pszTermName;
    ULONG dwOpcode;
    PSZ   pszArgTypes;
    ULONG dwTermClass;
    ULONG dwfOpcode;
    PFNOH pfnCallBack;
    ULONG dwCBData;
    PFNOP pfnOpcode;
} AMLTERM, *PAMLTERM;

// dwfOpcode flags
#define OF_VARIABLE_LIST        0x00000001
#define OF_ARG_OBJECT           0x00000002
#define OF_LOCAL_OBJECT         0x00000004
#define OF_DATA_OBJECT          0x00000008
#define OF_STRING_OBJECT        0x00000010
#define OF_NAME_OBJECT          0x00000020
#define OF_DEBUG_OBJECT         0x00000040
#define OF_REF_OBJECT           0x00000080
#define OF_CALLBACK_EX          0x80000000

// dwTermClass
#define TC_NAMESPACE_MODIFIER   0x00000001
#define TC_NAMED_OBJECT         0x00000002
#define TC_OPCODE_TYPE1         0x00000003
#define TC_OPCODE_TYPE2         0x00000004
#define TC_OTHER                0x00000005

typedef struct _opcodemap
{
    ULONG    dwOpcode;
    PAMLTERM pamlterm;
} OPCODEMAP, *POPCODEMAP;

typedef struct _objowner
{
    LIST   list;
    ULONG  dwSig;
    PNSOBJ pnsObjList;
} OBJOWNER, *POBJOWNER;

#define SIG_OBJOWNER            'RNWO'

typedef struct _evhandle
{
    PFNHND    pfnHandler;
    ULONG_PTR uipParam;
} EVHANDLE, *PEVHANDLE;

typedef struct _rsaccess
{
    struct _rsaccess *prsaNext;
    ULONG     dwRegionSpace;
    PFNCA     pfnCookAccess;
    ULONG_PTR uipCookParam;
    PFNRA     pfnRawAccess;
    ULONG_PTR uipRawParam;
} RSACCESS, *PRSACCESS;

typedef struct _passivehook
{
    struct _ctxt *pctxt;
    ULONG_PTR    uipAddr;
    ULONG        dwLen;
    PULONG_PTR   puipMappedAddr;
    WORK_QUEUE_ITEM WorkItem;
} PASSIVEHOOK, *PPASSIVEHOOK;

typedef struct _mutex
{
    KSPIN_LOCK SpinLock;
    KIRQL      OldIrql;
} MUTEX, *PMUTEX;

typedef struct _badioaddr
{
    ULONG BadAddrBegin;
    ULONG BadAddrSize;
    ULONG OSVersionTrigger;
} BADIOADDR, *PBADIOADDR;

typedef struct _AMLI_Log_WorkItem_Context
{
    BOOLEAN         fRead;
    ULONG           Address;
    ULONG           Index;
    PIO_WORKITEM    pIOWorkItem;
} AMLI_LOG_WORKITEM_CONTEXT, *PAMLI_LOG_WORKITEM_CONTEXT; 

#endif  //ifndef _AMLIPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amlitest.c ===
/*++
Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    amlitest

Abstract:

    

Environment:

    kernel mode only

Notes:

--*/


/*
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"  */


#include "pch.h"
//#include "amlihook.h"
//#include "amlitest.h" 

#define AMLIHOOK_DEBUG_ASYNC_AMLI ((ULONG)0x1)

#ifdef DBG


ULONG AmliTestDebugFlags=0x00;


#define AmliTest_DebugPrint(x)   AmliTestDebugPrintFunc x

CHAR AmliTestDebugBuffer[200];

//
//   Internal functions.
//


VOID
AmliTestDebugPrintFunc(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...)
   {
   va_list ap;
   va_start(ap, DebugMessage);


   if(DebugPrintLevel & AmliTestDebugFlags)
      {

       
       
      if(_vsnprintf(AmliTestDebugBuffer,
         200,
         DebugMessage, 
         ap) == -1)
      {
         AmliTestDebugBuffer[199] = '\0';
      }

      DbgPrint(AmliTestDebugBuffer);
      }
   }

#endif

//
//  AMLITest_Post_Generic
//

NTSTATUS 
AMLITest_Post_Generic(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status)
   {

   //
   //--- Notify test driver off call status 
   //

   NTSTATUS  Status = 
      AmliHook_TestNotifyRet(
               *ppData,
               _Status);


   ExFreePool(*ppData);
   *ppData = NULL;
   return(Status);
   }

//
//  Exported functions.
//


//
//  Pre/Post GetNameSpaceObject
// 

NTSTATUS 
AMLITest_Pre_GetNameSpaceObject(
   IN PSZ pszObjPath, 
   IN PNSOBJ pnsScope,
   OUT PPNSOBJ ppns, 
   IN ULONG dwfFlags,
   PAMLIHOOK_DATA  * ppData)
   {
  
   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      {
      AmliHook_ProcessInternalError();
      return(STATUS_INSUFFICIENT_RESOURCES);
      }
   
   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_GET_NAME_SPACE_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pszObjPath;
   (*ppData)->Arg2 = (ULONG_PTR)pnsScope;
   (*ppData)->Arg3 = (ULONG_PTR)ppns;
   (*ppData)->Arg4 = (ULONG_PTR)dwfFlags;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_GetNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  Pre/Post GetFieldUnitRegionObj
//


NTSTATUS 
AMLITest_Pre_GetFieldUnitRegionObj(
   IN PFIELDUNITOBJ pfu,
   OUT PPNSOBJ ppns,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Allocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_GET_FIELD_UNIT_REGION_OP;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pfu;
   (*ppData)->Arg2 = (ULONG_PTR)ppns;

   return(AmliHook_TestNotify(*ppData));
   }



NTSTATUS 
AMLITest_Post_GetFieldUnitRegionObj(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status)
   {
   return(AMLITest_Post_Generic(ppData,_Status));
   }



//
//  Pre/Post EvalNameSpaceObject
//



NTSTATUS 
AMLITest_Pre_EvalNameSpaceObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_NAME_SPACE_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pns;
   (*ppData)->Arg2 = (ULONG_PTR)pdataResult;
   (*ppData)->Arg3 = (ULONG_PTR)icArgs;
   (*ppData)->Arg4 = (ULONG_PTR)pdataArgs;

   return(AmliHook_TestNotify(*ppData));
   }
   
NTSTATUS 
AMLITest_Post_EvalNameSpaceObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS _Status)
   {
   return(AMLITest_Post_Generic(Data,_Status));
   }





//
//  CallBack Pre/Post AsyncEvalObject
//


VOID EXPORT
AMLITest_AsyncEvalObjectCallBack(
   IN PNSOBJ pns, 
   IN NTSTATUS status, 
   IN POBJDATA pdataResult, 
   IN PVOID Context)
   {

   PAMLIHOOK_DATA   pData = (PAMLIHOOK_DATA)Context;
   NTSTATUS RetStatus ; 
   PFNACB AcpiAsyncCallBack;
   PVOID AcpiContext;


   AcpiAsyncCallBack = (PFNACB)pData->Arg5;
   AcpiContext = (PVOID)pData->Arg6;


   if( (VOID*)(pData->Arg2) != (VOID*)pdataResult)
      AmliHook_ProcessInternalError();


   //
   //--- Notify test driver off call status 
   //

   RetStatus = AmliHook_TestNotifyRet(
               pData,
               status);


   AmliTest_DebugPrint((
      AMLIHOOK_DEBUG_ASYNC_AMLI,
      "DEBUG:  AMLITest_AsyncEvalObjectCallBack Data=%lx\n",
      pData));


   ExFreePool(pData);

   if(AcpiAsyncCallBack)
      {
   
      AcpiAsyncCallBack(
            pns,
            RetStatus,
            pdataResult,
            AcpiContext);
      }
  
   }



NTSTATUS 
AMLITest_Pre_AsyncEvalObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PFNACB * pfnAsyncCallBack,
   IN PVOID * pvContext,
   PAMLIHOOK_DATA  * Data)
   {


   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *Data = 
      AmliHook_AllocAndInitTestData();
   if(!Data)
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //
   
   (*Data)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*Data)->SubType = ACPIVER_DATA_SUBTYPE_ASYNC_EVAL_OBJECT;
   (*Data)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*Data)->Arg1 = (ULONG_PTR)pns;
   (*Data)->Arg2 = (ULONG_PTR)pdataResult;
   (*Data)->Arg3 = (ULONG_PTR)icArgs;
   (*Data)->Arg4 = (ULONG_PTR)pdataArgs;
   (*Data)->Arg5 = (ULONG_PTR)*pfnAsyncCallBack;
   (*Data)->Arg6 = (ULONG_PTR)*pvContext;

   //
   //  Hook my callback function , and conext.
   //

   *pfnAsyncCallBack = AMLITest_AsyncEvalObjectCallBack;
   *pvContext = *Data;


   return(AmliHook_TestNotify(*Data));
   }
   
   


NTSTATUS 
AMLITest_Post_AsyncEvalObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {


   AmliTest_DebugPrint((
      AMLIHOOK_DEBUG_ASYNC_AMLI,
      "DEBUG:  AMLITest_Post_AsyncEvalObject Data=%lx Pending=%s\n",
      *ppData,
      (Status == STATUS_PENDING)? "TRUE" : "FALSE"));

   
   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Call back will not be called.
   //

   return(AMLITest_Post_Generic(ppData,Status));
   }


//
//  Pre/Post NestAsyncEvalObject
// 



NTSTATUS 
AMLITest_Pre_NestAsyncEvalObject(
   PNSOBJ pns,
   POBJDATA pdataResult,
   int icArgs,
   POBJDATA pdataArgs,
   PFNACB * pfnAsyncCallBack,
   PVOID * pvContext,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   
   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_NEST_ASYNC_EVAL_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pns;
   (*ppData)->Arg2 = (ULONG_PTR)pdataResult;
   (*ppData)->Arg3 = (ULONG_PTR)icArgs;
   (*ppData)->Arg4 = (ULONG_PTR)pdataArgs;
   (*ppData)->Arg5 = (ULONG_PTR)pfnAsyncCallBack;
   (*ppData)->Arg6 = (ULONG_PTR)pvContext;

   //
   //  Hook my callback function , and conext.
   //

   *pfnAsyncCallBack = AMLITest_AsyncEvalObjectCallBack;
   *pvContext = *ppData;

   

   return(AmliHook_TestNotify(*ppData));
   }
   

NTSTATUS 
AMLITest_Post_NestAsyncEvalObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {

   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Work is done.
   //--- AMLITest_AsyncEvalObjectCallBack will not be called.
   //
   
   return(AMLITest_Post_Generic(ppData,Status));
   }

//
// Pre/Post EvalPackageElement
//


NTSTATUS 
AMLITest_Pre_EvalPackageElement(
   PNSOBJ pns,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_PACKAGE_ELEMENT;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pns;
   (*ppData)->Arg2    = (ULONG_PTR)iPkgIndex;
   (*ppData)->Arg3    = (ULONG_PTR)pdataResult;

   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_EvalPackageElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(Data,Status));
   }


//
//  Pre/Post EvalPkgDataElement
//


NTSTATUS 
AMLITest_Pre_EvalPkgDataElement(
   POBJDATA pdataPkg,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_PKG_DATA_ELEMENT;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pdataPkg;
   (*ppData)->Arg2    = (ULONG_PTR)iPkgIndex;
   (*ppData)->Arg3    = (ULONG_PTR)pdataResult;

   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_EvalPkgDataElement(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }


//
//  Pre/Post FreeDataBuffs
//


NTSTATUS
AMLITest_Pre_FreeDataBuffs(
   POBJDATA pdata, 
   int icData,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);
   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_FREE_DATA_BUFFS;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pdata;
   (*ppData)->Arg2    = (ULONG_PTR)icData;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_FreeDataBuffs(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  Pre/Post RegEventHandler.
//

NTSTATUS 
AMLIHook_Pre_RegEventHandler(
   ULONG dwEventType, 
   ULONG_PTR uipEventData,
   PFNHND * pfnHandler, 
   ULONG_PTR * uipParam,
   PAMLIHOOK_DATA  * ppData)
   {
   NTSTATUS Status;
   PFNHND EventHandler;
   ULONG_PTR EventParam;


   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);



   //
   //--- Querry the test driver for Event handler to
   //--- register.
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_QUERY;
   (*ppData)->Arg1    = (ULONG_PTR)dwEventType;
   (*ppData)->Arg2    = (ULONG_PTR)uipEventData;
   (*ppData)->Arg3    = (ULONG_PTR)*pfnHandler;
   (*ppData)->Arg4    = (ULONG_PTR)*uipParam;


   AmliHook_TestNotify(*ppData);


   if((*ppData)->Ret != STATUS_SUCCESS)
      DbgBreakPoint();

   EventHandler = (PFNHND)(*ppData)->Arg3;
   EventParam = (ULONG_PTR)(*ppData)->Arg4;


   if(EventHandler != *pfnHandler)
      {
      //
      // Test driver will hook this call
      // I will need values for both
      // params.
      //

      if(!EventHandler)
         AmliHook_ProcessInternalError();

      if(!EventParam)
         AmliHook_ProcessInternalError();

      *pfnHandler = EventHandler;
      *uipParam = EventParam;



      }

   //
   //--- Notify test driver off call 
   //

   AmliHook_InitTestData(*ppData);


   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)dwEventType;
   (*ppData)->Arg2    = (ULONG_PTR)uipEventData;

   return(AmliHook_TestNotify(*ppData));
   }

 

NTSTATUS 
AMLIHook_Post_RegEventHandler(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  CallBack , Pre/Post PauseInterpreter
//

VOID EXPORT
AMLITest_PauseInterpreterCallBack(
   PVOID Context)
   {
   NTSTATUS Status;
   PFNAA AcpiCallBack=NULL;
   PVOID AcpiContext=NULL;
   PAMLIHOOK_DATA  Data = (PAMLIHOOK_DATA)Context;

   //
   //--- Notify test driver off call status 
   //

   Status = AmliHook_TestNotifyRet(
               Data,
               STATUS_SUCCESS);

   AcpiCallBack = (PFNAA)Data->Arg1;
   AcpiContext  = (PVOID)Data->Arg2;


   ExFreePool(Data);


   if(AcpiCallBack)
      {
      AcpiCallBack(AcpiContext);
      }

   }


NTSTATUS 
AMLITest_Pre_PauseInterpreter(
   PFNAA * pfnCallBack, 
   PVOID * Context,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //
 
   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_PAUSE_INTERPRETER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)*pfnCallBack;
   (*ppData)->Arg2    = (ULONG_PTR)*Context;


   //
   //  Hook my Callback context
   //

   *pfnCallBack = AMLITest_PauseInterpreterCallBack;
   *Context = *ppData;


   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_PauseInterpreter(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {

   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Call back will not be called.
   //
   
   Status = AmliHook_TestNotifyRet(
      *ppData,
      Status);

   ExFreePool(*ppData);
   *ppData = NULL;

   return(Status);
   }



//
//  Pre/Post ResumeInterpreter
//

NTSTATUS 
AMLITest_Pre_ResumeInterpreter(
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //
 
   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_RESUME_INTERPRETER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_ResumeInterpreter(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\amlitest.h ===
/*#include "acpitabl.h"
#include "amli.h"*/


#define ACPIVER_DATA_TYPE_AMLI                            ((UCHAR)1)
#define ACPIVER_DATA_TYPE_END                             2

#define ACPIVER_DATA_SUBTYPE_GET_NAME_SPACE_OBJECT        ((UCHAR)1)
#define ACPIVER_DATA_SUBTYPE_GET_FIELD_UNIT_REGION_OP     ((UCHAR)2)
#define ACPIVER_DATA_SUBTYPE_EVAL_NAME_SPACE_OBJECT       ((UCHAR)3)
#define ACPIVER_DATA_SUBTYPE_ASYNC_EVAL_OBJECT            ((UCHAR)4)
#define ACPIVER_DATA_SUBTYPE_NEST_ASYNC_EVAL_OBJECT       ((UCHAR)5)
#define ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER            ((UCHAR)6)
#define ACPIVER_DATA_SUBTYPE_EVAL_PACKAGE_ELEMENT         ((UCHAR)7)
#define ACPIVER_DATA_SUBTYPE_EVAL_PKG_DATA_ELEMENT        ((UCHAR)8)
#define ACPIVER_DATA_SUBTYPE_FREE_DATA_BUFFS              ((UCHAR)9)
#define ACPIVER_DATA_SUBTYPE_PAUSE_INTERPRETER            ((UCHAR)10)
#define ACPIVER_DATA_SUBTYPE_RESUME_INTERPRETER           ((UCHAR)11)
#define ACPIVER_DATA_SUBTYPE_END                          ((UCHAR)12)

//
//  Pre/Post GetNameSpaceObject
// 
NTSTATUS 
AMLITest_Pre_GetNameSpaceObject(
   IN PSZ pszObjPath,   
   IN PNSOBJ pnsScope,
   OUT PPNSOBJ ppns, 
   IN ULONG dwfFlags,
   IN PAMLIHOOK_DATA  * ppData);



NTSTATUS 
AMLITest_Post_GetNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);


//
//  Pre/Post GetFieldUnitRegionObj
//

NTSTATUS 
AMLITest_Pre_GetFieldUnitRegionObj(
   IN PFIELDUNITOBJ pfu,
   OUT PPNSOBJ ppns,
   PAMLIHOOK_DATA  * ppData);




NTSTATUS 
AMLITest_Post_GetFieldUnitRegionObj(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);

//
//  Pre/Post EvalNameSpaceObject
//

NTSTATUS 
AMLITest_Pre_EvalNameSpaceObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PAMLIHOOK_DATA  * ppData);

NTSTATUS 
AMLITest_Post_EvalNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);

//
//  CallBack Pre/Post AsyncEvalObject
//


VOID EXPORT
AMLITest_AsyncEvalObjectCallBack(
   IN PNSOBJ pns, 
   IN NTSTATUS status, 
   IN POBJDATA pdataResult, 
   IN PVOID Context);



NTSTATUS 
AMLITest_Pre_AsyncEvalObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PFNACB * nAsyncCallBack,
   IN PVOID * Context,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_AsyncEvalObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);




//
//  Pre/Post NestAsyncEvalObject
//

NTSTATUS 
AMLITest_Pre_NestAsyncEvalObject(
   PNSOBJ pns,
   POBJDATA pdataResult,
   int icArgs,
   POBJDATA pdataArgs,
   PFNACB * pfnAsyncCallBack,
   PVOID * pvContext,
   PAMLIHOOK_DATA  * Data);


NTSTATUS 
AMLITest_Post_NestAsyncEvalObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post EvalPackageElement
//

NTSTATUS 
AMLITest_Pre_EvalPackageElement(
   PNSOBJ pns,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_EvalPackageElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post EvalPkgDataElement
//

NTSTATUS 
AMLITest_Pre_EvalPkgDataElement(
   POBJDATA pdataPkg,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_EvalPkgDataElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);


//
//  Pre/Post FreeDataBuffs
//

NTSTATUS
AMLITest_Pre_FreeDataBuffs(
   POBJDATA pdata, 
   int icData,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_FreeDataBuffs(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);



//
//  Pre/Post RegEventHandler
//


NTSTATUS 
AMLIHook_Pre_RegEventHandler(
   ULONG dwEventType, 
   ULONG_PTR uipEventData,
   PFNHND * pfnHandler, 
   ULONG_PTR * uipParam,
   PAMLIHOOK_DATA  * Data);


NTSTATUS 
AMLIHook_Post_RegEventHandler(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);





//
//  CallBack , Pre/Post PauseInterpreter
//

VOID EXPORT
AMLITest_PauseInterpreterCallBack(
   PVOID Context);

NTSTATUS 
AMLITest_Pre_PauseInterpreter(
   PFNAA * pfnCallBack, 
   PVOID * Context,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_PauseInterpreter(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post ResumeInterpreter
//

NTSTATUS 
AMLITest_Pre_ResumeInterpreter(
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_ResumeInterpreter(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\cmdarg.c ===
/*** cmdarg.c - Command argument parsing functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */


#include "pch.h"

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs);
PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs);

/*** Local data
 */

PSZ pszSwitchChars = "-/";
PSZ pszOptionSeps = "=:";

/***EP  DbgParseArgs - parse command arguments
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      pdwNumArgs -> to hold the number of arguments parsed
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *      pszTokenSeps -> token separator characters string
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps)
{
    LONG rc = ARGERR_NONE;
    PSZ psz;

    *pdwNumArgs = 0;
    *pdwNonSWArgs = 0;
    while ((psz = STRTOK(NULL, pszTokenSeps)) != NULL)
    {
        (*pdwNumArgs)++;
        if ((rc = DbgParseOneArg(ArgTable, psz, *pdwNumArgs, pdwNonSWArgs)) !=
            ARGERR_NONE)
        {
            break;
        }
    }

    return rc;
}       //DbgParseArgs

/***LP  DbgParseOneArg - parse one command argument
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      psz -> argument string
 *      dwArgNum - argument number
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs)
{
    LONG rc = ARGERR_NONE;
    PCMDARG pArg;
    PSZ pszEnd;

    if ((pArg = DbgMatchArg(ArgTable, &psz, pdwNonSWArgs)) != NULL)
    {
        switch (pArg->dwArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pArg->dwfArg & AF_SEP)
                {
                    if ((*psz != '\0') &&
                        (STRCHR(pszOptionSeps, *psz) != NULL))
                    {
                        psz++;
                    }
                    else
                    {
                        ARG_ERROR(("argument missing option separator - %s",
                                   psz));
                        rc = ARGERR_SEP_NOT_FOUND;
                        break;
                    }
                }

                if (pArg->dwArgType == AT_STRING)
                {
                    *((PSZ *)pArg->pvArgData) = psz;
                }
                else
                {
                    *((PLONG)pArg->pvArgData) =
                        STRTOL(psz, &pszEnd, pArg->dwArgParam);
                    if (psz == pszEnd)
                    {
                        ARG_ERROR(("invalid numeric argument - %s", psz));
                        rc = ARGERR_INVALID_NUMBER;
                        break;
                    }
                }

                if (pArg->pfnArg != NULL)
                {
                    rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pArg->dwArgType == AT_ENABLE)
                    *((PULONG)pArg->pvArgData) |= pArg->dwArgParam;
                else
                    *((PULONG)pArg->pvArgData) &= ~pArg->dwArgParam;

                if ((pArg->pfnArg != NULL) &&
                    (pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (*psz != '\0')
                {
                    rc = DbgParseOneArg(ArgTable, psz, dwArgNum, pdwNonSWArgs);
                }
                break;

            case AT_ACTION:
                ASSERT(pArg->pfnArg != NULL);
                rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                break;

            default:
                ARG_ERROR(("invalid argument table"));
                rc = ARGERR_ASSERT_FAILED;
        }
    }
    else
    {
        ARG_ERROR(("invalid command argument - %s", psz));
        rc = ARGERR_INVALID_ARG;
    }

    return rc;
}       //DbgParseOneArg

/***LP  DbgMatchArg - match argument type from argument table
 *
 *  ENTRY
 *      ArgTable -> argument table
 *      ppsz -> argument string pointer
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns pointer to argument entry matched
 *  EXIT-FAILURE
 *      returns NULL
 */

PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs)
{
    PCMDARG pArg;

    for (pArg = ArgTable; pArg->dwArgType != AT_END; pArg++)
    {
        if (pArg->pszArgID == NULL)     //NULL means match anything.
        {
            (*pdwNonSWArgs)++;
            break;
        }
        else
        {
            ULONG dwLen;

            if (STRCHR(pszSwitchChars, **ppsz) != NULL)
                (*ppsz)++;

            dwLen = STRLEN(pArg->pszArgID);
            if (StrCmp(pArg->pszArgID, *ppsz, dwLen,
                       (BOOLEAN)((pArg->dwfArg & AF_NOI) != 0)) == 0)
            {
                (*ppsz) += dwLen;
                break;
            }
        }
    }

    if (pArg->dwArgType == AT_END)
        pArg = NULL;

    return pArg;
}       //DbgMatchArg

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\data.h ===
/*** data.h - Global Data Definitions
 *
 *  This module contains global data definitions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DATA_H
#define _DATA_H

#ifdef DEBUG
extern ULONG gdwcMemObjs;
extern ULONG gdwcHPObjs;
extern ULONG gdwcODObjs;
extern ULONG gdwcNSObjs;
extern ULONG gdwcOOObjs;
extern ULONG gdwcBFObjs;
extern ULONG gdwcSDObjs;
extern ULONG gdwcBDObjs;
extern ULONG gdwcPKObjs;
extern ULONG gdwcFUObjs;
extern ULONG gdwcKFObjs;
extern ULONG gdwcFObjs;
extern ULONG gdwcIFObjs;
extern ULONG gdwcORObjs;
extern ULONG gdwcMTObjs;
extern ULONG gdwcEVObjs;
extern ULONG gdwcMEObjs;
extern ULONG gdwcPRObjs;
extern ULONG gdwcPCObjs;
extern ULONG gdwcRSObjs;
extern ULONG gdwcSYObjs;
extern ULONG gdwcPHObjs;
extern ULONG gdwcCRObjs;
extern ULONG gdwGlobalHeapSize;
extern ULONG gdwLocalHeapMax;
extern ULONG gdwLocalStackMax;
extern ULONG gdwGHeapSnapshot;
extern KSPIN_LOCK gdwGHeapSpinLock;
#endif
extern LONG             gdwcCTObjs;
extern ULONG            gdwcCTObjsMax;
extern KSPIN_LOCK       gdwGContextSpinLock;
extern NPAGED_LOOKASIDE_LIST   AMLIContextLookAsideList;
#ifdef TRACING
extern PSZ gpszTrigPts;
#endif
extern ULONG gdwfAMLI;
extern ULONG gdwfAMLIInit;
extern ULONG gdwfHacks;
extern ULONG gdwCtxtBlkSize;
extern ULONG gdwGlobalHeapBlkSize;
extern PNSOBJ gpnsNameSpaceRoot;
extern PHEAP gpheapGlobal;
extern PLIST gplistCtxtHead;
extern PLIST gplistObjOwners;
extern PLIST gplistDefuncNSObjs;
extern PRSACCESS gpRSAccessHead;
extern EVHANDLE ghNotify;
extern EVHANDLE ghValidateTable;
extern EVHANDLE ghFatal;
extern EVHANDLE ghGlobalLock;
extern EVHANDLE ghCreate;
extern EVHANDLE ghDestroyObj;
extern CTXTQ gReadyQueue;
extern MUTEX gmutCtxtList;
extern MUTEX gmutOwnerList;
extern MUTEX gmutHeap;
extern ULONG gdwHighestOSVerQueried;
extern PHAL_AMLI_BAD_IO_ADDRESS_LIST gpBadIOAddressList;
extern PULONG gpBadIOErrorLogDoneList;
extern ULONG gOverrideFlags;
extern BOOLEAN gInitTime;

//
// Sleep specific data structures
//
extern MUTEX      gmutSleep;
extern KDPC       SleepDpc;
extern KTIMER     SleepTimer;
extern LIST_ENTRY SleepQueue;

extern PAMLTERM OpcodeTable[256];
extern OPCODEMAP ExOpcodeTable[];
extern AMLTERM atIf, atWhile;
extern AMLTERM atLoad;

/*** Import data
 */

extern PCHAR gpszOSName;

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\debugger.h ===
/*** debugger.h - Debugger Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DEBUGGER_H
#define _DEBUGGER_H

#ifdef DEBUGGER

/*** Macros
 */

#ifndef _PRINTF
  #define _PRINTF(x) DbgPrintEx(DPFLTR_AMLI_ID, DPFLTR_INFO_LEVEL,x)
#endif


#define DBG_ERROR(x)            ConPrintf(MODNAME "_DBGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");

/*** Constants
 */

// Debugger error codes
#define DBGERR_NONE             0
#define DBGERR_QUIT             -1
#define DBGERR_INVALID_CMD      -2
#define DBGERR_PARSE_ARGS       -3
#define DBGERR_CMD_FAILED       -4
#define DBGERR_INTERNAL_ERR -5

// Command flags
#define CMDF_QUIT               0x00000001

/*** Type definitions
 */

typedef struct _dbgcmd
{
    PSZ     pszCmd;
    ULONG   dwfCmd;
    PCMDARG pArgTable;
    PFNARG  pfnCmd;
} DBGCMD, *PDBGCMD;

/*** Exported function prototypes
 */

VOID LOCAL Debugger(PDBGCMD pDbgCmds, PSZ pszPrompt);

#endif  //ifdef DEBUGGER
#endif  //ifndef _DEBUGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\debugger.c ===
/*** debugger.c - Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUGGER

/*** Miscellaneous Constants
 */

#define MAX_CMDLINE_LEN         255

/*** Local function prototypes
 */

LONG LOCAL DbgExecuteCmd(PDBGCMD pDbgCmds, PSZ pszCmd);

/*** Local data
 */

PSZ pszTokenSeps = " \t\n";

/***LP  Debugger - generic debugger entry point
 *
 *  ENTRY
 *      pDbgCmds -> debugger command table
 *      pszPrompt -> prompt string
 *
 *  EXIT
 *      None
 */

VOID LOCAL Debugger(PDBGCMD pDbgCmds, PSZ pszPrompt)
{
    char szCmdLine[MAX_CMDLINE_LEN + 1];
    PSZ psz;

    for (;;)
    {
        ConPrompt(pszPrompt, szCmdLine, sizeof(szCmdLine));

        if ((psz = STRTOK(szCmdLine, pszTokenSeps)) != NULL)
        {
            if (DbgExecuteCmd(pDbgCmds, psz) == DBGERR_QUIT)
                break;
        }
    }

}       //Debugger

/***LP  DbgExecuteCmd - execute a debugger command
 *
 *  ENTRY
 *      pDbgCmds -> debugger command table
 *      pszCmd -> command string
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE or DBGERR_QUIT
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgExecuteCmd(PDBGCMD pDbgCmds, PSZ pszCmd)
{
    LONG rc = DBGERR_NONE;
    int i;
    ULONG dwNumArgs = 0, dwNonSWArgs = 0;

    for (i = 0; pDbgCmds[i].pszCmd != NULL; i++)
    {
        if (STRCMP(pszCmd, pDbgCmds[i].pszCmd) == 0)
        {
            if (pDbgCmds[i].dwfCmd & CMDF_QUIT)
            {
                rc = DBGERR_QUIT;
            }
            else if ((pDbgCmds[i].pArgTable == NULL) ||
                     ((rc = DbgParseArgs(pDbgCmds[i].pArgTable, &dwNumArgs,
                                         &dwNonSWArgs, pszTokenSeps)) ==
                      ARGERR_NONE))
            {
                if (pDbgCmds[i].pfnCmd != NULL)
                    rc = pDbgCmds[i].pfnCmd(NULL, NULL, dwNumArgs, dwNonSWArgs);
            }
            else
                rc = DBGERR_PARSE_ARGS;

            break;
        }
    }

    if (pDbgCmds[i].pszCmd == NULL)
    {
        DBG_ERROR(("invalid command - %s", pszCmd));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DbgExecuteCmd

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\cmdarg.h ===
/*** cmdarg.h - Command argument parsing Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _CMDARG_H
#define _CMDARG_H

#ifdef DEBUGGER

/*** Macros
 */

#define ARG_ERROR(x)            ConPrintf(MODNAME "_ARGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");

/*** Constants
 */

// Error codes
#define ARGERR_NONE             0
#define ARGERR_SEP_NOT_FOUND    -1
#define ARGERR_INVALID_NUMBER   -2
#define ARGERR_INVALID_ARG      -3
#define ARGERR_ASSERT_FAILED    -4

// Command argument flags
#define AF_NOI                  0x00000001      //NoIgnoreCase
#define AF_SEP                  0x00000002      //require separator

// Command argument types
#define AT_END                  0               //end marker of arg table
#define AT_STRING               1
#define AT_NUM                  2
#define AT_ENABLE               3
#define AT_DISABLE              4
#define AT_ACTION               5

/*** Type definitions
 */

typedef struct _cmdarg CMDARG;
typedef CMDARG *PCMDARG;
typedef LONG (LOCAL *PFNARG)(PCMDARG, PSZ, ULONG, ULONG);

struct _cmdarg
{
    PSZ    pszArgID;            //argument ID string
    ULONG  dwArgType;           //AT_*
    ULONG  dwfArg;              //AF_*
    PVOID  pvArgData;           //AT_END: none
                                //AT_STRING: PPSZ - ptr. to string ptr.
                                //AT_NUM: PLONG - ptr. to number
                                //AT_ENABLE: PULONG - ptr. to flags
                                //AT_DISABLE: PULONG - ptr. to flags
                                //AT_ACTION: none
    ULONG  dwArgParam;          //AT_END: none
                                //AT_STRING: none
                                //AT_NUM: base
                                //AT_ENABLE: flag bit mask
                                //AT_DISABLE: flag bit mask
                                //AT_ACTION: none
    PFNARG pfnArg;              //ptr. to argument verification function or
                                //  action function if AT_ACTION
};

/*** Exported function prototypes
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps);

#endif  //ifdef DEBUGGER
#endif  //ifndef _CMDARG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\heap.c ===
/*** heap.c - Heap memory management functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     07/14/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  NewHeap - create a new heap block
 *
 *  ENTRY
 *      dwLen - heap length
 *      ppheap -> to hold the newly created heap
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL NewHeap(ULONG dwLen, PHEAP *ppheap)
{
    TRACENAME("NEWHEAP")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("NewHeap(HeapLen=%d,ppheap=%x)\n", dwLen, ppheap));

    if ((*ppheap = NEWHPOBJ(dwLen)) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("NewHeap: failed to allocate new heap block"));
    }
    else
    {
        InitHeap(*ppheap, dwLen);
    }

    EXIT(3, ("NewHeap=%x (pheap=%x)\n", rc, *ppheap));
    return rc;
}       //NewHeap

/***LP  FreeHeap - free the heap block
 *
 *  ENTRY
 *      pheap -> HEAP
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeHeap(PHEAP pheap)
{
    TRACENAME("FREEHEAP")
    ENTER(2, ("FreeHeap(pheap=%x)\n", pheap));

    FREEHPOBJ(pheap);

    EXIT(2, ("FreeHeap!\n"));
}       //FreeHeap

/***LP  InitHeap - initialize a given heap block
 *
 *  ENTRY
 *      pheap -> HEAP
 *      dwLen - length of heap block
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitHeap(PHEAP pheap, ULONG dwLen)
{
    TRACENAME("INITHEAP")

    ENTER(3, ("InitHeap(pheap=%x,Len=%d)\n", pheap, dwLen));

    MEMZERO(pheap, dwLen);
    pheap->dwSig = SIG_HEAP;
    pheap->pbHeapEnd = (PUCHAR)pheap + dwLen;
    pheap->pbHeapTop = (PUCHAR)&pheap->Heap;

    EXIT(3, ("InitHeap!\n"));
}       //InitHeap

/***LP  HeapAlloc - allocate a memory block from a given heap
 *
 *  ENTRY
 *      pheapHead -> HEAP
 *      dwSig - signature of the block to be allocated
 *      dwLen - length of block to be allocated
 *
 *  EXIT-SUCCESS
 *      returns pointer to allocated memory
 *  EXIT-FAILURE
 *      returns NULL
 */

PVOID LOCAL HeapAlloc(PHEAP pheapHead, ULONG dwSig, ULONG dwLen)
{
    TRACENAME("HEAPALLOC")
    PHEAPOBJHDR phobj = NULL;
    PHEAP pheapPrev = NULL, pheap = NULL;

    ENTER(3, ("HeapAlloc(pheapHead=%x,Sig=%s,Len=%d)\n",
              pheapHead, NameSegString(dwSig), dwLen));

    ASSERT(pheapHead != NULL);
    ASSERT(pheapHead->dwSig == SIG_HEAP);
    ASSERT(pheapHead->pheapHead != NULL);
    ASSERT(pheapHead == pheapHead->pheapHead);

    dwLen += sizeof(HEAPOBJHDR) - sizeof(LIST);
    if (dwLen < sizeof(HEAPOBJHDR))
    {
        //
        // Minimum allocated size has to be HEAPOBJHDR size.
        //
        dwLen = sizeof(HEAPOBJHDR);
    }
    //
    // Round it up to the proper alignment.
    //
    dwLen += DEF_HEAP_ALIGNMENT - 1;
    dwLen &= ~(DEF_HEAP_ALIGNMENT - 1);

    AcquireMutex(&gmutHeap);
    if (dwLen <= PtrToUlong(pheapHead->pbHeapEnd) - PtrToUlong(&pheapHead->Heap))
    {
        for (pheap = pheapHead; pheap != NULL; pheap = pheap->pheapNext)
        {
            if ((phobj = HeapFindFirstFit(pheap, dwLen)) != NULL)
            {
                ASSERT(phobj->dwSig == 0);
                ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);

                if (phobj->dwLen >= dwLen + sizeof(HEAPOBJHDR))
                {
                    PHEAPOBJHDR phobjNext = (PHEAPOBJHDR)((PUCHAR)phobj + dwLen);

                    phobjNext->dwSig = 0;
                    phobjNext->dwLen = phobj->dwLen - dwLen;
                    phobjNext->pheap = pheap;
                    phobj->dwLen = dwLen;
                    HeapInsertFreeList(pheap, phobjNext);
                }
                break;
            }
            else if (dwLen <= (ULONG)(pheap->pbHeapEnd - pheap->pbHeapTop))
            {
                phobj = (PHEAPOBJHDR)pheap->pbHeapTop;
                pheap->pbHeapTop += dwLen;
                phobj->dwLen = dwLen;
                break;
            }
            else
            {
                pheapPrev = pheap;
            }
        }
        //
        // If we are running out of Global Heap space, we will dynamically
        // extend it.
        //
        if ((phobj == NULL) && (pheapHead == gpheapGlobal) &&
            (NewHeap(gdwGlobalHeapBlkSize, &pheap) == STATUS_SUCCESS))
        {
            pheap->pheapHead = pheapHead;
            pheapPrev->pheapNext = pheap;
            ASSERT(dwLen <= PtrToUlong(pheap->pbHeapEnd) - PtrToUlong(&pheap->Heap));

            phobj = (PHEAPOBJHDR)pheap->pbHeapTop;
            pheap->pbHeapTop += dwLen;
            phobj->dwLen = dwLen;
        }

        if (phobj != NULL)
        {
          #ifdef DEBUG
            if (pheapHead == gpheapGlobal)
            {
                KIRQL   oldIrql;

                KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
                gdwGlobalHeapSize += phobj->dwLen;
                KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
            }
            else
            {
                ULONG dwTotalHeap = 0;
                PHEAP ph;

                for (ph = pheapHead; ph != NULL; ph = ph->pheapNext)
                {
                    dwTotalHeap += (ULONG)((ULONG_PTR)ph->pbHeapTop -
                                           (ULONG_PTR)&ph->Heap);
                }

                if (dwTotalHeap > gdwLocalHeapMax)
                {
                    gdwLocalHeapMax = dwTotalHeap;
                }
            }
          #endif

            phobj->dwSig = dwSig;
            phobj->pheap = pheap;
            MEMZERO(&phobj->list, dwLen - (sizeof(HEAPOBJHDR) - sizeof(LIST)));
        }
    }
    ReleaseMutex(&gmutHeap);

    EXIT(3, ("HeapAlloc=%x (pheap=%x)\n", phobj? &phobj->list: NULL, pheap));
    return phobj? &phobj->list: NULL;
}       //HeapAlloc

/***LP  HeapFree - free a memory block
 *
 *  ENTRY
 *      pb -> memory block
 *
 *  EXIT
 *      None
 */

VOID LOCAL HeapFree(PVOID pb)
{
    TRACENAME("HEAPFREE")
    PHEAPOBJHDR phobj;

    ASSERT(pb != NULL);
    phobj = CONTAINING_RECORD(pb, HEAPOBJHDR, list);

    ENTER(3, ("HeapFree(pheap=%x,pb=%x,Sig=%s,Len=%d)\n",
              phobj->pheap, pb, NameSegString(phobj->dwSig), phobj->dwLen));

    ASSERT((phobj >= &phobj->pheap->Heap) &&
           ((PUCHAR)phobj + phobj->dwLen <= phobj->pheap->pbHeapEnd));
    ASSERT(phobj->dwSig != 0);

    if ((pb != NULL) && (phobj->dwSig != 0))
    {
      #ifdef DEBUG
        if (phobj->pheap->pheapHead == gpheapGlobal)
        {
            KIRQL   oldIrql;

            KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
            gdwGlobalHeapSize -= phobj->dwLen;
            KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
        }
      #endif

        phobj->dwSig = 0;
        AcquireMutex(&gmutHeap);
        HeapInsertFreeList(phobj->pheap, phobj);
        ReleaseMutex(&gmutHeap);
    }

    EXIT(3, ("HeapFree!\n"));
}       //HeapFree

/***LP  HeapFindFirstFit - find first fit free object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      dwLen - size of object
 *
 *  EXIT-SUCCESS
 *      returns the object
 *  EXIT-FAILURE
 *      returns NULL
 */

PHEAPOBJHDR LOCAL HeapFindFirstFit(PHEAP pheap, ULONG dwLen)
{
    TRACENAME("HEAPFINDFIRSTFIT")
    PHEAPOBJHDR phobj = NULL;

    ENTER(3, ("HeapFindFirstFit(pheap=%x,Len=%d)\n", pheap, dwLen));

    if (pheap->plistFreeHeap != NULL)
    {
        PLIST plist = pheap->plistFreeHeap;

        do
        {
            phobj = CONTAINING_RECORD(plist, HEAPOBJHDR, list);

            if (dwLen <= phobj->dwLen)
            {
                break;
            }
            else
            {
                plist = plist->plistNext;
            }
        } while (plist != pheap->plistFreeHeap);

        if (dwLen > phobj->dwLen)
        {
            phobj = NULL;
        }
    }

    EXIT(3, ("HeapFindFirstFit=%x (Len=%d)\n", phobj, phobj? phobj->dwLen: 0));
    return phobj;
}       //HeapFindFirstFit

/***LP  HeapInsertFreeList - insert heap object into free list
 *
 *  ENTRY
 *      pheap -> HEAP
 *      phobj -> heap object
 *
 *  EXIT
 *      None
 */

VOID LOCAL HeapInsertFreeList(PHEAP pheap, PHEAPOBJHDR phobj)
{
    TRACENAME("HEAPINSERTFREELIST")
    PHEAPOBJHDR phobj1;

    ENTER(3, ("HeapInsertFreeList(pheap=%x,phobj=%x)\n", pheap, phobj))

    ASSERT(phobj->dwLen >= sizeof(HEAPOBJHDR));
    if (pheap->plistFreeHeap != NULL)
    {
        PLIST plist = pheap->plistFreeHeap;

        do
        {
            if (&phobj->list < plist)
            {
                break;
            }
            else
            {
                plist = plist->plistNext;
            }
        } while (plist != pheap->plistFreeHeap);

        if (&phobj->list < plist)
        {
            phobj->list.plistNext = plist;
            phobj->list.plistPrev = plist->plistPrev;
            phobj->list.plistPrev->plistNext = &phobj->list;
            phobj->list.plistNext->plistPrev = &phobj->list;
            if (pheap->plistFreeHeap == plist)
            {
                pheap->plistFreeHeap = &phobj->list;
            }
        }
        else
        {
            ListInsertTail(&phobj->list, &pheap->plistFreeHeap);
        }
    }
    else
    {
        ListInsertHead(&phobj->list, &pheap->plistFreeHeap);
    }

    //
    // Check if the next adjacent block is free.  If so, coalesce it.
    //
    phobj1 = (PHEAPOBJHDR)((PUCHAR)phobj + phobj->dwLen);
    if (phobj->list.plistNext == &phobj1->list)
    {
        ASSERT(phobj1->dwSig == 0);
        phobj->dwLen += phobj1->dwLen;
        ListRemoveEntry(&phobj1->list, &pheap->plistFreeHeap);
    }

    //
    // Check if the previous adjacent block is free.  If so, coalesce it.
    //
    phobj1 = CONTAINING_RECORD(phobj->list.plistPrev, HEAPOBJHDR, list);
    if ((PUCHAR)phobj1 + phobj1->dwLen == (PUCHAR)phobj)
    {
        ASSERT(phobj1->dwSig == 0);
        phobj1->dwLen += phobj->dwLen;
        ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);
        phobj = phobj1;
    }

    if ((PUCHAR)phobj + phobj->dwLen >= pheap->pbHeapTop)
    {
        pheap->pbHeapTop = (PUCHAR)phobj;
        ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);
    }

    EXIT(3, ("HeapInsertFreeList!\n"));
}       //HeapInsertFreeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\ctxt.c ===
/*** ctxt.c - Context Block handling functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

NTSTATUS
LOCAL
NewContext(
    PPCTXT ppctxt
    )
/*++

Routine Description:

    Allocate a new context structure from tne NonPaged Lookaside
    List. Also keep track of the high water marks so that the OS
    can intelligently decide what the "appropriate" number of
    contexts that it should allocate.

    Note that this code raises the possibility that if we detect
    an out-of-memory error, we might be able to save a registry
    key that includes a new larger number (to prevent this problem
    in the first place). Adaptive recovery?

Arguments:

    ppctxt  - address of to hold the newly created context

Return Value:

    NTSTATUS

--*/
{
    TRACENAME("NEWCONTEXT")
    KIRQL       oldIrql;
    NTSTATUS    rc = STATUS_SUCCESS;

    ENTER(2, ("NewContext(ppctxt=%x)\n", ppctxt));

    *ppctxt = ExAllocateFromNPagedLookasideList(
        &AMLIContextLookAsideList
        );
    if (*ppctxt == NULL) {

        AMLI_WARN(("NewContext: Could not Allocate New Context"));
        rc = AMLIERR_OUT_OF_MEM;

    } else {

        //
        // Bookkeeping for memory resources to determine the high
        // water mark
        //
        KeAcquireSpinLock(&gdwGContextSpinLock, &oldIrql );
        gdwcCTObjs++;
        if (gdwcCTObjs > 0 &&
            (ULONG) gdwcCTObjs > gdwcCTObjsMax) {

            gdwcCTObjsMax = gdwcCTObjs;

        }
        KeReleaseSpinLock(&gdwGContextSpinLock, oldIrql );

        //
        // Context Initialization
        //
        InitContext(*ppctxt, gdwCtxtBlkSize);
        AcquireMutex(&gmutCtxtList);
        ListInsertTail(&(*ppctxt)->listCtxt, &gplistCtxtHead);
        ReleaseMutex(&gmutCtxtList);

    }

    EXIT(2, ("NewContext=%x (pctxt=%x)\n", rc, *ppctxt));
    return rc;
}  //NewContext

VOID
LOCAL
FreeContext(
    PCTXT pctxt
    )
/*++

Routine Description:

    This is routine is called when a context is no longer required
    and should be returned to the system's LookAside list

Arguments:

    pctxt   - Address of the context to be freed

Return Value:

    None

--*/
{
    TRACENAME("FREECONTEXT")
    KIRQL   oldIrql;

    ENTER(2, ("FreeContext(pctxt=%x)\n", pctxt));
    ASSERT(pctxt->powner == NULL);

    //
    // Need to hold the proper mutex to touch the global ctxt list
    //
    AcquireMutex(&gmutCtxtList);
    ListRemoveEntry(&pctxt->listCtxt, &gplistCtxtHead);

    if (pctxt->pplistCtxtQueue != NULL) {

        ListRemoveEntry(&pctxt->listQueue, pctxt->pplistCtxtQueue);

    }

    //
    // Done with the global mutex
    //
    ReleaseMutex(&gmutCtxtList);

    //
    // Release any allocated storage that might not have been cleaned up
    //
    FreeDataBuffs(&pctxt->Result, 1);

    //
    // Bookkeeping for memory resources to determine the high
    // water mark
    //
    KeAcquireSpinLock(&gdwGContextSpinLock, &oldIrql );
    gdwcCTObjs--;
    ASSERT(gdwcCTObjs >= 0);
    KeReleaseSpinLock(&gdwGContextSpinLock, oldIrql );

    //
    // Log the end of a method
    //
    ACPIWMILOGEVENT((1,
                EVENT_TRACE_TYPE_END,
                GUID_List[AMLI_LOG_GUID],
                "Object = %s",
                GetObjectPath(pctxt->pnsObj)
               ));


    //
    // Return the context to the nonpaged lookaside list
    //
    ExFreeToNPagedLookasideList(&AMLIContextLookAsideList, pctxt);
    EXIT(2, ("FreeContext!\n"));
} //FreeContext

/***LP  InitContext - initialize a given context block
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwLen - length of context block
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitContext(PCTXT pctxt, ULONG dwLen)
{
    TRACENAME("INITCONTEXT")

    ENTER(2, ("InitContext(pctxt=%x,Len=%d)\n", pctxt, dwLen));

    MEMZERO(pctxt, sizeof(CTXT) - sizeof(HEAP));
    pctxt->dwSig = SIG_CTXT;
    pctxt->pbCtxtEnd = (PUCHAR)pctxt + dwLen;
    pctxt->pheapCurrent = &pctxt->LocalHeap;
//  #ifdef DEBUGGER
//    KeQuerySystemTime(&pctxt->Timestamp);
//  #endif
    KeInitializeDpc(&pctxt->Dpc, TimeoutCallback, pctxt);
    KeInitializeTimer(&pctxt->Timer);
    InitHeap(&pctxt->LocalHeap,
             (ULONG)(pctxt->pbCtxtEnd - (PUCHAR)&pctxt->LocalHeap));
    pctxt->LocalHeap.pheapHead = &pctxt->LocalHeap;

    EXIT(2, ("InitContext!\n"));
}       //InitContext

/***LP  IsStackEmpty - determine if the stack is empty
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns TRUE - stack is empty
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL IsStackEmpty(PCTXT pctxt)
{
    TRACENAME("ISSTACKEMPTY")
    BOOLEAN rc;

    ENTER(2, ("IsStackEmpty(pctxt=%p)\n", pctxt));

    rc = (BOOLEAN)(pctxt->LocalHeap.pbHeapEnd == pctxt->pbCtxtEnd);

    EXIT(2, ("IsStackEmpty=%x\n", rc));
    return rc;
}       //IsStackEmpty

/***LP  PushFrame - Push a new frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwSig - frame object signature
 *      dwLen - size of the frame object
 *      pfnParse -> frame object parse function
 *      ppvFrame -> to hold pointer to the newly pushed frame (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushFrame(PCTXT pctxt, ULONG dwSig, ULONG dwLen,
                         PFNPARSE pfnParse, PVOID *ppvFrame)
{
    TRACENAME("PUSHFRAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("PushFrame(pctxt=%p,Sig=%s,Len=%d,pfnParse=%p,ppvFrame=%p)\n",
              pctxt, NameSegString(dwSig), dwLen, pfnParse, ppvFrame));
    //
    // Check to see if we have enough space, make sure it doesn't run into the
    // heap.
    //
    if (pctxt->LocalHeap.pbHeapEnd - dwLen >= pctxt->LocalHeap.pbHeapTop)
    {
        PFRAMEHDR pfh;

        pctxt->LocalHeap.pbHeapEnd -= dwLen;
        pfh = (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd;
        MEMZERO(pfh, dwLen);
        pfh->dwSig = dwSig;
        pfh->dwLen = dwLen;
        pfh->pfnParse = pfnParse;

        if (ppvFrame != NULL)
        {
            *ppvFrame = pfh;
        }

      #ifdef DEBUG
        if ((ULONG)(pctxt->pbCtxtEnd - pctxt->LocalHeap.pbHeapEnd) >
            gdwLocalStackMax)
        {
            gdwLocalStackMax = (ULONG)(pctxt->pbCtxtEnd -
                                       pctxt->LocalHeap.pbHeapEnd);
        }
      #endif
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_STACK_OVERFLOW,
                         ("PushFrame: stack ran out of space"));
    }

    EXIT(2, ("PushFrame=%x (StackTop=%x)\n", rc, pctxt->LocalHeap.pbHeapEnd));
    return rc;
}       //PushFrame

/***LP  PopFrame - Pop a frame off the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT
 *      None
 */

VOID LOCAL PopFrame(PCTXT pctxt)
{
    TRACENAME("POPFRAME")

    ENTER(2, ("PopFrame(pctxt=%p)\n", pctxt));

    ASSERT(!IsStackEmpty(pctxt));
    ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig != 0);
    pctxt->LocalHeap.pbHeapEnd +=
        ((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwLen;

    EXIT(2, ("PopFrame! (StackTop=%p)\n", pctxt->LocalHeap.pbHeapEnd));
}       //PopFrame

/***LP  PushPost - Push a Post frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pfnPost -> post processing function
 *      uipData1 - data1
 *      uipData2 - data2
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushPost(PCTXT pctxt, PFNPARSE pfnPost, ULONG_PTR uipData1,
                        ULONG_PTR uipData2, POBJDATA pdataResult)
{
    TRACENAME("PUSHPOST")
    NTSTATUS rc = STATUS_SUCCESS;
    PPOST ppost;

    ENTER(2, ("PushPost(pctxt=%x,pfnPost=%x,Data1=%x,Data2=%x,pdataResult=%x)\n",
              pctxt, pfnPost, uipData1, uipData2, pdataResult));

    if ((rc = PushFrame(pctxt, SIG_POST, sizeof(POST), pfnPost, &ppost)) ==
        STATUS_SUCCESS)
    {
        ppost->uipData1 = uipData1;
        ppost->uipData2 = uipData2;
        ppost->pdataResult = pdataResult;
    }

    EXIT(2, ("PushPost=%x (ppost=%x)\n", rc, ppost));
    return rc;
}       //PushPost

/***LP  PushScope - Push a ParseScope frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpBegin -> beginning of scope
 *      pbOpEnd -> end of scope
 *      pbOpRet -> return address after end of scope (NULL if continue on)
 *      pnsScope -> new scope
 *      powner -> new owner
 *      pheap -> new heap
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushScope(PCTXT pctxt, PUCHAR pbOpBegin, PUCHAR pbOpEnd,
                         PUCHAR pbOpRet, PNSOBJ pnsScope, POBJOWNER powner,
                         PHEAP pheap, POBJDATA pdataResult)
{
    TRACENAME("PUSHSCOPE")
    NTSTATUS rc = STATUS_SUCCESS;
    PSCOPE pscope;

    ENTER(2, ("PushScope(pctxt=%x,pbOpBegin=%x,pbOpEnd=%x,pbOpRet=%x,pnsScope=%x,pheap=%x,pdataResult=%x)\n",
              pctxt, pbOpBegin, pbOpEnd, pbOpRet, pnsScope, pheap,
              pdataResult));

    if ((rc = PushFrame(pctxt, SIG_SCOPE, sizeof(SCOPE), ParseScope, &pscope))
        == STATUS_SUCCESS)
    {
        pctxt->pbOp = pbOpBegin;
        pscope->pbOpEnd = pbOpEnd;
        pscope->pbOpRet = pbOpRet;
        pscope->pnsPrevScope = pctxt->pnsScope;
        pctxt->pnsScope = pnsScope;
        pscope->pownerPrev = pctxt->powner;
        pctxt->powner = powner;
        pscope->pheapPrev = pctxt->pheapCurrent;
        pctxt->pheapCurrent = pheap;
        pscope->pdataResult = pdataResult;
    }

    EXIT(2, ("PushScope=%x (pscope=%x)\n", rc, pscope));
    return rc;
}       //PushScope

/***LP  PushCall - Push a Call frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsMethod -> method object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushCall(PCTXT pctxt, PNSOBJ pnsMethod, POBJDATA pdataResult)
{
    TRACENAME("PUSHCALL")
    NTSTATUS rc = STATUS_SUCCESS;
    PCALL pcall;

    ENTER(2, ("PushCall(pctxt=%x,pnsMethod=%s,pdataResult=%x)\n",
              pctxt, GetObjectPath(pnsMethod), pdataResult));

    ASSERT((pnsMethod == NULL) ||
           (pnsMethod->ObjData.dwDataType == OBJTYPE_METHOD));

    if ((rc = PushFrame(pctxt, SIG_CALL, sizeof(CALL), ParseCall, &pcall))
        == STATUS_SUCCESS)
    {
        if (pnsMethod != NULL)
        {
            PMETHODOBJ pm = (PMETHODOBJ)pnsMethod->ObjData.pbDataBuff;

            pcall->pnsMethod = pnsMethod;
            if (pm->bMethodFlags & METHOD_SERIALIZED)
            {
                pcall->FrameHdr.dwfFrame |= CALLF_NEED_MUTEX;
            }
            pcall->icArgs = (int)(pm->bMethodFlags & METHOD_NUMARG_MASK);
            if (pcall->icArgs > 0)
            {
                if ((pcall->pdataArgs = NEWODOBJ(pctxt->pheapCurrent,
                                                 sizeof(OBJDATA)*pcall->icArgs))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("PushCall: failed to allocate argument objects"));
                }
                else
                {
                    MEMZERO(pcall->pdataArgs, sizeof(OBJDATA)*pcall->icArgs);
                }
            }
        }
        else
        {
            //
            // This is a dummy call frame for AMLILoadDDB.  We just need it
            // for its Locals array in case there is ASL referencing them.
            // But we don't really want to parse a call frame, so let's set
            // it to final clean up stage.
            //
            ASSERT(pctxt->pcall == NULL);
            pctxt->pcall = pcall;
            pcall->FrameHdr.dwfFrame = 4;
        }

        pcall->pdataResult = pdataResult;
    }

    EXIT(2, ("PushCall=%x (pcall=%x)\n", rc, pcall));
    return rc;
}       //PushCall

/***LP  PushTerm - Push a Term frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpTerm -> term opcode
 *      pbScopeEnd -> end of current scope
 *      pamlterm -> AMLTERM
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushTerm(PCTXT pctxt, PUCHAR pbOpTerm, PUCHAR pbScopeEnd,
                        PAMLTERM pamlterm, POBJDATA pdataResult)
{
    TRACENAME("PUSHTERM")
    NTSTATUS rc = STATUS_SUCCESS;
    PTERM pterm;

    ENTER(2, ("PushTerm(pctxt=%x,pbOpTerm=%x,pbScopeEnd=%x,pamlterm=%x,pdataResult=%x)\n",
              pctxt, pbOpTerm, pbScopeEnd, pamlterm, pdataResult));

    if ((rc = PushFrame(pctxt, SIG_TERM, sizeof(TERM), ParseTerm, &pterm)) ==
        STATUS_SUCCESS)
    {
        pterm->pbOpTerm = pbOpTerm;
        pterm->pbScopeEnd = pbScopeEnd;
        pterm->pamlterm = pamlterm;
        pterm->pdataResult = pdataResult;
        pterm->icArgs = pamlterm->pszArgTypes? STRLEN(pamlterm->pszArgTypes): 0;
        if (pterm->icArgs > 0)
        {
            if ((pterm->pdataArgs = NEWODOBJ(pctxt->pheapCurrent,
                                             sizeof(OBJDATA)*pterm->icArgs)) ==
                NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("PushTerm: failed to allocate argument objects"));
            }
            else
            {
                MEMZERO(pterm->pdataArgs, sizeof(OBJDATA)*pterm->icArgs);
            }
        }
    }

    EXIT(2, ("PushTerm=%x (pterm=%x)\n", rc, pterm));
    return rc;
}       //PushTerm

/***LP  RunContext - Run a context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      Caller must own the scheduler lock such that the context flags can
 *      be updated properly.  The lock is dropped and re-obtain around
 *      execution of the target context.
 */

NTSTATUS LOCAL RunContext(PCTXT pctxt)
{
    TRACENAME("RUNCONTEXT")
    NTSTATUS rc;
    PFRAMEHDR pfh;
    PKTHREAD pkthSave = gReadyQueue.pkthCurrent;
    PCTXT pctxtSave = gReadyQueue.pctxtCurrent;

    ENTER(2, ("RunContext(pctxt=%x)\n", pctxt));

    //
    // Better be a Ready Context structure.
    //
    ASSERT(pctxt->dwSig == SIG_CTXT);
    ASSERT(pctxt->dwfCtxt & CTXTF_READY);

    //
    // Remember previous context and thread.
    //
    gReadyQueue.pctxtCurrent = pctxt;
    gReadyQueue.pkthCurrent = KeGetCurrentThread();

    LOGSCHEDEVENT('RUNC', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->dwfCtxt);

    //
    // As long as the context is ready, execute it.
    //
    for (;;)
    {
        //
        // Transistion context from Ready to Running.
        //
        rc = STATUS_SUCCESS;
        pctxt->dwfCtxt &= ~CTXTF_READY;
        pctxt->dwfCtxt |= CTXTF_RUNNING;

        //
        // Drop scheduler lock and execute context.
        //
        ReleaseMutex(&gReadyQueue.mutCtxtQ);

        //
        // Go for as long as there's work to perform.
        //
        while (!IsStackEmpty(pctxt))
        {
            CHKDEBUGGERREQ();
            pfh = (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd;
            ASSERT(pfh->pfnParse != NULL);

            rc = pfh->pfnParse(pctxt, pfh, rc);
            if ((rc == AMLISTA_PENDING) || (rc == AMLISTA_DONE))
            {
                break;
            }
        }

        //
        // Get the scheduler lock, and clear the running flag.
        //
        AcquireMutex(&gReadyQueue.mutCtxtQ);

        //
        // If we are in nested eval and the nested context is done,
        // we must not clear the running flag because the parent thread
        // is still running.
        //
        if (!(pctxt->dwfCtxt & CTXTF_NEST_EVAL) || (rc != AMLISTA_DONE))
        {
            pctxt->dwfCtxt &= ~CTXTF_RUNNING;
        }

        //
        // If the context is no longer ready, we're done.
        //
        if (!(pctxt->dwfCtxt & CTXTF_READY))
        {
            break;
        }

        //
        // Context became Ready during a pending operation, keep
        // dispatching.
        //
        ASSERT (rc == AMLISTA_PENDING);
    }

    if (rc == AMLISTA_PENDING)
    {
        pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
    }
    else if (rc == AMLISTA_DONE)
    {
        if (pctxt->pnctxt == NULL)
        {
            pctxt->dwfCtxt &= ~CTXTF_NEST_EVAL;
        }
        rc = STATUS_SUCCESS;
    }
    else
    {
        ReleaseMutex(&gReadyQueue.mutCtxtQ);
        if ((rc == STATUS_SUCCESS) && (pctxt->pdataCallBack != NULL))
        {
            rc = DupObjData(gpheapGlobal, pctxt->pdataCallBack, &pctxt->Result);
        }

        if (pctxt->dwfCtxt & CTXTF_NEED_CALLBACK)
        {
            AsyncCallBack(pctxt, rc);

            if(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL)
            {    
                rc = AMLISTA_PENDING;
            }
        }

        //
        // Free any owned resources the context may not have freed.
        //
        while (pctxt->plistResources != NULL)
        {
            PRESOURCE pres;

            pres = CONTAINING_RECORD(pctxt->plistResources, RESOURCE, list);
            ASSERT (pres->pctxtOwner == pctxt);

            //
            // Note that it is the responsibility of the corresponding
            // resource release functions (e.g. ReleaseASLMutex) to dequeue
            // the resource from the list and free it.
            //
            switch (pres->dwResType)
            {
                case RESTYPE_MUTEX:
                    ReleaseASLMutex(pctxt, pres->pvResObj);
                    break;

                default:
                    //
                    // We should never come here.  In case we do, we need to
                    // dequeue the unknown resource object and free it.
                    //
                    pres = CONTAINING_RECORD(
                               ListRemoveHead(&pctxt->plistResources),
                               RESOURCE, list);
                    ASSERT(pres == NULL);
                    FREECROBJ(pres);
            }
        }

        FreeContext(pctxt);

        AcquireMutex(&gReadyQueue.mutCtxtQ);
    }

    //
    // Restore previous context and thread.
    //
    gReadyQueue.pkthCurrent = pkthSave;
    gReadyQueue.pctxtCurrent = pctxtSave;

    if ((gReadyQueue.dwfCtxtQ & CQF_FLUSHING) && (gplistCtxtHead == NULL))
    {
        //
        // We just flushed the last pending ctxt, let's go into paused state.
        //
        gReadyQueue.dwfCtxtQ &= ~CQF_FLUSHING;
        gReadyQueue.dwfCtxtQ |= CQF_PAUSED;
        if (gReadyQueue.pfnPauseCallback != NULL)
        {
            //
            // We are in paused state and all pending contexts are flushed,
            // tell core driver that we are done flushing.
            //
            gReadyQueue.pfnPauseCallback(gReadyQueue.PauseCBContext);
            LOGSCHEDEVENT('PACB', (ULONG_PTR)pctxt, (ULONG_PTR)rc, 0);
        }
    }

    LOGSCHEDEVENT('RUN!', (ULONG_PTR)pctxt, (ULONG_PTR)rc, 0);

    EXIT(2, ("RunContext=%x\n", rc));
    return rc;
}       //RunContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\data.c ===
/*** data.c - Global Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

#ifdef DEBUG
ULONG gdwcMemObjs = 0;
ULONG gdwcHPObjs = 0;
ULONG gdwcODObjs = 0;
ULONG gdwcNSObjs = 0;
ULONG gdwcOOObjs = 0;
ULONG gdwcBFObjs = 0;
ULONG gdwcSDObjs = 0;
ULONG gdwcBDObjs = 0;
ULONG gdwcPKObjs = 0;
ULONG gdwcFUObjs = 0;
ULONG gdwcKFObjs = 0;
ULONG gdwcFObjs = 0;
ULONG gdwcIFObjs = 0;
ULONG gdwcORObjs = 0;
ULONG gdwcMTObjs = 0;
ULONG gdwcEVObjs = 0;
ULONG gdwcMEObjs = 0;
ULONG gdwcPRObjs = 0;
ULONG gdwcPCObjs = 0;
ULONG gdwcRSObjs = 0;
ULONG gdwcSYObjs = 0;
ULONG gdwcPHObjs = 0;
ULONG gdwcCRObjs = 0;
ULONG gdwGlobalHeapSize = 0;
ULONG gdwLocalHeapMax = 0;
ULONG gdwLocalStackMax = 0;
ULONG gdwGHeapSnapshot = 0;
KSPIN_LOCK gdwGHeapSpinLock;
#endif
LONG  gdwcCTObjs = 0;
ULONG gdwcCTObjsMax = 0;
KSPIN_LOCK gdwGContextSpinLock;
NPAGED_LOOKASIDE_LIST   AMLIContextLookAsideList;
#ifdef TRACING
PSZ gpszTrigPts = NULL;
#endif
ULONG gdwfAMLI = 0;
ULONG gdwfAMLIInit = 0;
ULONG gdwfHacks = 0;
ULONG gdwCtxtBlkSize = DEF_CTXTBLK_SIZE;
ULONG gdwGlobalHeapBlkSize = DEF_GLOBALHEAPBLK_SIZE;
PNSOBJ gpnsNameSpaceRoot = NULL;
PHEAP gpheapGlobal = NULL;
PLIST gplistCtxtHead = NULL;
PLIST gplistObjOwners = NULL;
PLIST gplistDefuncNSObjs = NULL;
PRSACCESS gpRSAccessHead = NULL;
EVHANDLE ghNotify = {0};
EVHANDLE ghValidateTable = {0};
EVHANDLE ghFatal = {0};
EVHANDLE ghGlobalLock = {0};
EVHANDLE ghCreate = {0};
EVHANDLE ghDestroyObj = {0};
CTXTQ gReadyQueue = {0};
MUTEX gmutCtxtList = {0};
MUTEX gmutOwnerList = {0};
MUTEX gmutHeap = {0};
ULONG gdwHighestOSVerQueried = 0;
PHAL_AMLI_BAD_IO_ADDRESS_LIST gpBadIOAddressList = NULL;
PULONG gpBadIOErrorLogDoneList = NULL;
ULONG gOverrideFlags = 0;
BOOLEAN gInitTime = FALSE;
//
// Sleep specific data structures
//
MUTEX      gmutSleep = {0};
KDPC       SleepDpc = {0};
KTIMER     SleepTimer = {0};
LIST_ENTRY SleepQueue = {0};

#define VL      OF_VARIABLE_LIST
#define AO      OF_ARG_OBJECT
#define LO      OF_LOCAL_OBJECT
#define DO      OF_DATA_OBJECT
#define SO      OF_STRING_OBJECT
#define BO      OF_DEBUG_OBJECT
#define NO      OF_NAME_OBJECT
#define RO      OF_REF_OBJECT

#define NS      TC_NAMESPACE_MODIFIER
#define OB      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define OT      TC_OTHER

AMLTERM
    //
    // Name Space Modifiers
    //
    atAlias         = {"Alias", OP_ALIAS, "NN", NS, 0,  NULL, 0, Alias},
    atName          = {"Name",  OP_NAME,  "NO", NS, 0,  NULL, 0, Name},
    atScope         = {"Scope", OP_SCOPE, "N",  NS, VL, NULL, 0, Scope},
    //
    // Named Object Creators
    //
    atBankField     = {"BankField",       OP_BANKFIELD,   "NNCB", OB, VL, NULL, 0, BankField},
    atBitField      = {"CreateBitField",  OP_BITFIELD,    "CCN",  OB, 0,  NULL, 0, CreateBitField},
    atByteField     = {"CreateByteField", OP_BYTEFIELD,   "CCN",  OB, 0,  NULL, 0, CreateByteField},
    atDWordField    = {"CreateDWordField",OP_DWORDFIELD,  "CCN",  OB, 0,  NULL, 0, CreateDWordField},
    atCreateField   = {"CreateField",     OP_CREATEFIELD, "CCCN", OB, 0,  NULL, 0, CreateField},
    atWordField     = {"CreateWordField", OP_WORDFIELD,   "CCN",  OB, 0,  NULL, 0, CreateWordField},
    atDevice        = {"Device",          OP_DEVICE,      "N",    OB, VL, NULL, 0, Device},
    atEvent         = {"Event",           OP_EVENT,       "N",    OB, 0,  NULL, 0, Event},
    atField         = {"Field",           OP_FIELD,       "NB",   OB, VL, NULL, 0, Field},
    atIndexField    = {"IndexField",      OP_IDXFIELD,    "NNB",  OB, VL, NULL, 0, IndexField},
    atMethod        = {"Method",          OP_METHOD,      "NB",   OB, VL, NULL, 0, Method},
    atMutex         = {"Mutex",           OP_MUTEX,       "NB",   OB, 0,  NULL, 0, Mutex},
    atOpRegion      = {"OperationRegion", OP_OPREGION,    "NBCC", OB, 0,  NULL, 0, OpRegion},
    atPowerRes      = {"PowerResource",   OP_POWERRES,    "NBW",  OB, VL, NULL, 0, PowerRes},
    atProcessor     = {"Processor",       OP_PROCESSOR,   "NBDB", OB, VL, NULL, 0, Processor},
    atThermalZone   = {"ThermalZone",     OP_THERMALZONE, "N",    OB, VL, NULL, 0, ThermalZone},
    //
    // Type 1 Opcodes
    //
    atBreak         = {"Break",            OP_BREAK,       NULL,   C1, 0,  NULL, 0, Break},
    atBreakPoint    = {"BreakPoint",       OP_BREAKPOINT,  NULL,   C1, 0,  NULL, 0, BreakPoint},
    atElse          = {"Else",             OP_ELSE,        NULL,   C1, VL, NULL, 0, IfElse},
    atFatal         = {"Fatal",            OP_FATAL,       "BDC",  C1, 0,  NULL, 0, Fatal},
    atIf            = {"If",               OP_IF,          "C",    C1, VL, NULL, 0, IfElse},
    atLoad          = {"Load",             OP_LOAD,        "NS",   C1, 0,  NULL, 0, Load},
    atNOP           = {"NoOp",             OP_NOP,         NULL,   C1, 0,  NULL, 0, NULL},
    atNotify        = {"Notify",           OP_NOTIFY,      "SC",   C1, 0,  NULL, 0, Notify},
    atRelease       = {"Release",          OP_RELEASE,     "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atReset         = {"Reset",            OP_RESET,       "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atReturn        = {"Return",           OP_RETURN,      "C",    C1, 0,  NULL, 0, Return},
    atSignal        = {"Signal",           OP_SIGNAL,      "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atSleep         = {"Sleep",            OP_SLEEP,       "C",    C1, 0,  NULL, 0, SleepStall},
    atStall         = {"Stall",            OP_STALL,       "C",    C1, 0,  NULL, 0, SleepStall},
    atUnload        = {"Unload",           OP_UNLOAD,      "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atWhile         = {"While",            OP_WHILE,       "C",    C1, VL, NULL, 0, While},
    //
    // Type 2 Opcodes
    //
    atAcquire       = {"Acquire",         OP_ACQUIRE,     "SW",    C2, 0,  NULL, 0, Acquire},
    atAdd           = {"Add",             OP_ADD,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atAnd           = {"And",             OP_AND,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atBuffer        = {"Buffer",          OP_BUFFER,      "C",     C2, VL, NULL, 0, Buffer},
    atConcat        = {"Concatenate",     OP_CONCAT,      "CCS",   C2, 0,  NULL, 0, Concat},
    atCondRefOf     = {"CondRefOf",       OP_CONDREFOF,   "sS",    C1, 0,  NULL, 0, CondRefOf},
    atDecrement     = {"Decrement",       OP_DECREMENT,   "S",     C2, 0,  NULL, 0, IncDec},
    atDerefOf       = {"DerefOf",         OP_DEREFOF,     "C",     C2, 0,  NULL, 0, DerefOf},
    atDivide        = {"Divide",          OP_DIVIDE,      "CCSS",  C2, 0,  NULL, 0, Divide},
    atFindSetLBit   = {"FindSetLeftBit",  OP_FINDSETLBIT, "CS",    C2, 0,  NULL, 0, ExprOp1},
    atFindSetRBit   = {"FindSetRightBit", OP_FINDSETRBIT, "CS",    C2, 0,  NULL, 0, ExprOp1},
    atFromBCD       = {"FromBCD",         OP_FROMBCD,     "CS",    C2, 0,  NULL, 0, ExprOp1},
    atIncrement     = {"Increment",       OP_INCREMENT,   "S",     C2, 0,  NULL, 0, IncDec},
    atIndex         = {"Index",           OP_INDEX,       "CCS",   C2, RO, NULL, 0, Index},
    atLAnd          = {"LAnd",            OP_LAND,        "CC",    C2, 0,  NULL, 0, LogOp2},
    atLEq           = {"LEqual",          OP_LEQ,         "CC",    C2, 0,  NULL, 0, LogOp2},
    atLG            = {"LGreater",        OP_LG,          "CC",    C2, 0,  NULL, 0, LogOp2},
    atLL            = {"LLess",           OP_LL,          "CC",    C2, 0,  NULL, 0, LogOp2},
    atLNot          = {"LNot",            OP_LNOT,        "C",     C2, 0,  NULL, 0, LNot},
    atLOr           = {"LOr",             OP_LOR,         "CC",    C2, 0,  NULL, 0, LogOp2},
    atMatch         = {"Match",           OP_MATCH,       "CBCBCC",C2, 0,  NULL, 0, Match},
    atMultiply      = {"Multiply",        OP_MULTIPLY,    "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNAnd          = {"NAnd",            OP_NAND,        "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNOr           = {"NOr",             OP_NOR,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNot           = {"Not",             OP_NOT,         "CS",    C2, 0,  NULL, 0, ExprOp1},
    atObjType       = {"ObjectType",      OP_OBJTYPE,     "S",     C2, 0,  NULL, 0, ObjTypeSizeOf},
    atOr            = {"Or",              OP_OR,          "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atOSI           = {"OSI",             OP_OSI,         "S",     C2, 0,  NULL, 0, OSInterface},
    atPackage       = {"Package",         OP_PACKAGE,     "B",     C2, VL, NULL, 0, Package},
    atRefOf         = {"RefOf",           OP_REFOF,       "S",     C2, 0,  NULL, 0, RefOf},
    atShiftLeft     = {"ShiftLeft",       OP_SHIFTL,      "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atShiftRight    = {"ShiftRight",      OP_SHIFTR,      "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atSizeOf        = {"SizeOf",          OP_SIZEOF,      "S",     C2, 0,  NULL, 0, ObjTypeSizeOf},
    atStore         = {"Store",           OP_STORE,       "CS",    C2, 0,  NULL, 0, Store},
    atSubtract      = {"Subtract",        OP_SUBTRACT,    "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atToBCD         = {"ToBCD",           OP_TOBCD,       "CS",    C2, 0,  NULL, 0, ExprOp1},
    atWait          = {"Wait",            OP_WAIT,        "SC",    C2, 0,  NULL, 0, Wait},
    atXOr           = {"XOr",             OP_XOR,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    //
    // Misc. Opcodes
    //
    atNameObj       = {NULL,              OP_NONE,         NULL,   OT, NO, NULL, 0, NULL},
    atDataObj       = {NULL,              OP_NONE,         NULL,   OT, DO, NULL, 0, NULL},
    atString        = {NULL,              OP_STRING,       NULL,   OT, SO, NULL, 0, NULL},
    atArgObj        = {NULL,              OP_NONE,         NULL,   OT, AO, NULL, 0, NULL},
    atLocalObj      = {NULL,              OP_NONE,         NULL,   OT, LO, NULL, 0, NULL},
    atDebugObj      = {"Debug",           OP_DEBUG,        NULL,   OT, BO, NULL, 0, NULL};

PAMLTERM OpcodeTable[256] =
{ //0x00                   0x01                  0x02                  0x03
    &atDataObj,         &atDataObj,         NULL,               NULL,
  //0x04                0x05                0x06                0x07
    NULL,               NULL,               &atAlias,           NULL,
  //0x08                0x09                0x0a                0x0b
    &atName,            NULL,               &atDataObj,         &atDataObj,
  //0x0c                0x0d                0x0e                0x0f
    &atDataObj,         &atString,          NULL,               NULL,
  //0x10                0x11                0x12                0x13
    &atScope,           &atBuffer,          &atPackage,         NULL,
  //0x14                0x15                0x16                0x17
    &atMethod,          NULL,               NULL,               NULL,
  //0x18                0x19                0x1a                0x1b
    NULL,               NULL,               NULL,               NULL,
  //0x1c                0x1d                0x1e                0x1f
    NULL,               NULL,               NULL,               NULL,
  //0x20                0x21                0x22                0x23
    NULL,               NULL,               NULL,               NULL,
  //0x24                0x25                0x26                0x27
    NULL,               NULL,               NULL,               NULL,
  //0x28                0x29                0x2a                0x2b
    NULL,               NULL,               NULL,               NULL,
  //0x2c                0x2d                0x2e                0x2f
    NULL,               NULL,               &atNameObj,         &atNameObj,
  //0x30                0x31                0x32                0x33
    NULL,               NULL,               NULL,               NULL,
  //0x34                0x35                0x36                0x37
    NULL,               NULL,               NULL,               NULL,
  //0x38                0x39                0x3a                0x3b
    NULL,               NULL,               NULL,               NULL,
  //0x3c                0x3d                0x3e                0x3f
    NULL,               NULL,               NULL,               NULL,
  //0x40                0x41                0x42                0x43
    NULL,               &atNameObj,         &atNameObj,         &atNameObj,
  //0x44                0x45                0x46                0x47
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x48                0x49                0x4a                0x4b
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x4c                0x4d                0x4e                0x4f
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x50                0x51                0x52                0x53
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x54                0x55                0x56                0x57
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x58                0x59                0x5a                0x5b
    &atNameObj,         &atNameObj,         &atNameObj,         NULL,
  //0x5c                0x5d                0x5e                0x5f
    &atNameObj,         NULL,               &atNameObj,         &atNameObj,
  //0x60                0x61                0x62                0x63
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x64                0x65                0x66                0x67
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x68                0x69                0x6a                0x6b
    &atArgObj,          &atArgObj,          &atArgObj,          &atArgObj,
  //0x6c                0x6d                0x6e                0x6f
    &atArgObj,          &atArgObj,          &atArgObj,          NULL,
  //0x70                0x71                0x72                0x73
    &atStore,           &atRefOf,           &atAdd,             &atConcat,
  //0x74                0x75                0x76                0x77
    &atSubtract,        &atIncrement,       &atDecrement,       &atMultiply,
  //0x78                0x79                0x7a                0x7b
    &atDivide,          &atShiftLeft,       &atShiftRight,      &atAnd,
  //0x7c                0x7d                0x7e                0x7f
    &atNAnd,            &atOr,              &atNOr,             &atXOr,
  //0x80                0x81                0x82                0x83
    &atNot,             &atFindSetLBit,     &atFindSetRBit,     &atDerefOf,
  //0x84                0x85                0x86                0x87
    NULL,               NULL,               &atNotify,          &atSizeOf,
  //0x88                0x89                0x8a                0x8b
    &atIndex,           &atMatch,           &atDWordField,      &atWordField,
  //0x8c                0x8d                0x8e                0x8f
    &atByteField,       &atBitField,        &atObjType,         NULL,
  //0x90                0x91                0x92                0x93
    &atLAnd,            &atLOr,             &atLNot,            &atLEq,
  //0x94                0x95                0x96                0x97
    &atLG,              &atLL,              NULL,               NULL,
  //0x98                0x99                0x9a                0x9b
    NULL,               NULL,               NULL,               NULL,
  //0x9c                0x9d                0x9e                0x9f
    NULL,               NULL,               NULL,               NULL,
  //0xa0                0xa1                0xa2                0xa3
    &atIf,              &atElse,            &atWhile,           &atNOP,
  //0xa4                0xa5                0xa6                0xa7
    &atReturn,          &atBreak,           NULL,               NULL,
  //0xa8                0xa9                0xaa                0xab
    NULL,               NULL,               NULL,               NULL,
  //0xac                0xad                0xae                0xaf
    NULL,               NULL,               NULL,               NULL,
  //0xb0                0xb1                0xb2                0xb3
    NULL,               NULL,               NULL,               NULL,
  //0xb4                0xb5                0xb6                0xb7
    NULL,               NULL,               NULL,               NULL,
  //0xb8                0xb9                0xba                0xbb
    NULL,               NULL,               NULL,               NULL,
  //0xbc                0xbd                0xbe                0xbf
    NULL,               NULL,               NULL,               NULL,
  //0xc0                0xc1                0xc2                0xc3
    NULL,               NULL,               NULL,               NULL,
  //0xc4                0xc5                0xc6                0xc7
    NULL,               NULL,               NULL,               NULL,
  //0xc8                0xc9                0xca                0xcb
    NULL,               NULL,               &atOSI,             NULL,
  //0xcc                0xcd                0xce                0xcf
    &atBreakPoint,      NULL,               NULL,               NULL,
  //0xd0                0xd1                0xd2                0xd3
    NULL,               NULL,               NULL,               NULL,
  //0xd4                0xd5                0xd6                0xd7
    NULL,               NULL,               NULL,               NULL,
  //0xd8                0xd9                0xda                0xdb
    NULL,               NULL,               NULL,               NULL,
  //0xdc                0xdd                0xde                0xdf
    NULL,               NULL,               NULL,               NULL,
  //0xe0                0xe1                0xe2                0xe3
    NULL,               NULL,               NULL,               NULL,
  //0xe4                0xe5                0xe6                0xe7
    NULL,               NULL,               NULL,               NULL,
  //0xe8                0xe9                0xea                0xeb
    NULL,               NULL,               NULL,               NULL,
  //0xec                0xed                0xee                0xef
    NULL,               NULL,               NULL,               NULL,
  //0xf0                0xf1                0xf2                0xf3
    NULL,               NULL,               NULL,               NULL,
  //0xf4                0xf5                0xf6                0xf7
    NULL,               NULL,               NULL,               NULL,
  //0xf8                0xf9                0xfa                0xfb
    NULL,               NULL,               NULL,               NULL,
  //0xfc                0xfd                0xfe                0xff
    NULL,               NULL,               NULL,               &atDataObj
};

OPCODEMAP ExOpcodeTable[] =
{
    EXOP_MUTEX,         &atMutex,
    EXOP_EVENT,         &atEvent,
    EXOP_CONDREFOF,     &atCondRefOf,
    EXOP_CREATEFIELD,   &atCreateField,
    EXOP_LOAD,          &atLoad,
    EXOP_STALL,         &atStall,
    EXOP_SLEEP,         &atSleep,
    EXOP_ACQUIRE,       &atAcquire,
    EXOP_SIGNAL,        &atSignal,
    EXOP_WAIT,          &atWait,
    EXOP_RESET,         &atReset,
    EXOP_RELEASE,       &atRelease,
    EXOP_FROMBCD,       &atFromBCD,
    EXOP_TOBCD,         &atToBCD,
    EXOP_UNLOAD,        &atUnload,
    EXOP_REVISION,      &atDataObj,
    EXOP_DEBUG,         &atDebugObj,
    EXOP_FATAL,         &atFatal,
    EXOP_OPREGION,      &atOpRegion,
    EXOP_FIELD,         &atField,
    EXOP_DEVICE,        &atDevice,
    EXOP_PROCESSOR,     &atProcessor,
    EXOP_POWERRES,      &atPowerRes,
    EXOP_THERMALZONE,   &atThermalZone,
    EXOP_IDXFIELD,      &atIndexField,
    EXOP_BANKFIELD,     &atBankField,
    0,                  NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\ctxt.h ===
/*** ctxt.h - AML context structures and definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#ifndef _CTXT_H
#define _CTXT_H

/*** Type and Structure definitions
 */
typedef struct _ctxt CTXT, *PCTXT, **PPCTXT;
typedef struct _heap HEAP, *PHEAP;
typedef NTSTATUS (LOCAL *PFNPARSE)(PCTXT, PVOID, NTSTATUS);
typedef NTSTATUS (LOCAL *PFN)();

typedef struct _framehdr
{
    ULONG    dwSig;                     //frame object signature
    ULONG    dwLen;                     //frame object length
    ULONG    dwfFrame;                  //frame flags
    PFNPARSE pfnParse;                  //frame object parse function
} FRAMEHDR, *PFRAMEHDR;

#define FRAMEF_STAGE_MASK       0x0000000f
#define FRAMEF_CONTEXT_MASK     0xffff0000

typedef struct _post
{
    FRAMEHDR  FrameHdr;                 //frame header
    ULONG_PTR uipData1;                 //data1
    ULONG_PTR uipData2;                 //data2
    POBJDATA pdataResult;               //points to result object
} POST, *PPOST;

#define SIG_POST                'TSOP'

typedef struct _scope
{
    FRAMEHDR  FrameHdr;                 //frame header
    PUCHAR    pbOpEnd;                  //points to the end of scope
    PUCHAR    pbOpRet;                  //points to return address of scope
    PNSOBJ    pnsPrevScope;             //points to previous scope
    POBJOWNER pownerPrev;               //points to previous object owner
    PHEAP     pheapPrev;                //points to previous heap
    POBJDATA  pdataResult;              //points to result object
} SCOPE, *PSCOPE;

#define SIG_SCOPE               'POCS'
#define SCOPEF_FIRST_TERM       0x00010000

typedef struct _call
{
    FRAMEHDR  FrameHdr;                 //frame header
    struct _call *pcallPrev;            //points to previous call frame
    POBJOWNER pownerPrev;               //points to previous object owner
    PNSOBJ    pnsMethod;                //points to method object
    int       iArg;                     //next argument to be parsed
    int       icArgs;                   //number of arguments
    POBJDATA  pdataArgs;                //points to the argument array
    OBJDATA   Locals[MAX_NUM_LOCALS];   //arrays of locals
    POBJDATA  pdataResult;              //points to result object
} CALL, *PCALL;

#define SIG_CALL                'LLAC'
#define CALLF_NEED_MUTEX        0x00010000
#define CALLF_ACQ_MUTEX         0x00020000
#define CALLF_INVOKE_CALL       0x00040000

typedef struct _nestedctxt
{
    FRAMEHDR    FrameHdr;               //frame header
    PNSOBJ      pnsObj;                 //points to current object of evaluation
    PNSOBJ      pnsScope;               //points to current scope
    OBJDATA     Result;                 //to hold result data
    PFNACB      pfnAsyncCallBack;       //async completion callback function
    POBJDATA    pdataCallBack;          //points to return data of eval.
    PVOID       pvContext;              //context data for async callback
    ULONG       dwfPrevCtxt;            //save previous context flags
    struct _nestedctxt *pnctxtPrev;     //save previous nested context frame
} NESTEDCTXT, *PNESTEDCTXT;

#define SIG_NESTEDCTXT          'XTCN'

typedef struct _term
{
    FRAMEHDR FrameHdr;                  //frame header
    PUCHAR   pbOpTerm;                  //points to opcode of this term
    PUCHAR   pbOpEnd;                   //points to the end of the term
    PUCHAR   pbScopeEnd;                //points to the end of the scope
    PAMLTERM pamlterm;                  //points to AMLTERM for this term
    PNSOBJ   pnsObj;                    //to store object created by this term
    int      iArg;                      //next argument to be parsed
    int      icArgs;                    //number of arguments
    POBJDATA pdataArgs;                 //points to the argument array
    POBJDATA pdataResult;               //points to result object
} TERM, *PTERM;

#define SIG_TERM                'MRET'

typedef struct _package
{
    FRAMEHDR    FrameHdr;               //frame header
    PPACKAGEOBJ ppkgobj;                //points to the package object
    int         iElement;               //next element to parse
    PUCHAR      pbOpEnd;                //points to package end
} PACKAGE, *PPACKAGE;

#define SIG_PACKAGE             'FGKP'

typedef struct _acquire
{
    FRAMEHDR  FrameHdr;                 //frame header
    PMUTEXOBJ pmutex;                   //points to the mutex object data
    USHORT    wTimeout;                 //timeout value
    POBJDATA  pdataResult;              //points to result object
} ACQUIRE, *PACQUIRE;

#define SIG_ACQUIRE             'FQCA'
#define ACQF_NEED_GLOBALLOCK    0x00010000
#define ACQF_HAVE_GLOBALLOCK    0x00020000
#define ACQF_SET_RESULT         0x00040000

typedef struct _accfieldunit
{
    FRAMEHDR FrameHdr;                  //frame header
    POBJDATA pdataObj;                  //points to field unit object data
    POBJDATA pdata;                     //points to source/result object
} ACCFIELDUNIT, *PACCFIELDUNIT;

#define SIG_ACCFIELDUNIT        'UFCA'
#define AFUF_READFIELDUNIT      0x00010000
#define AFUF_HAVE_GLOBALLOCK    0x00020000

typedef struct _wrfieldloop
{
    FRAMEHDR   FrameHdr;                //frame header
    POBJDATA   pdataObj;                //points to object to be written
    PFIELDDESC pfd;                     //points to FieldDesc
    PUCHAR     pbBuff;                  //points to source buffer
    ULONG      dwBuffSize;              //source buffer size
    ULONG      dwDataInc;               //data write increment
} WRFIELDLOOP, *PWRFIELDLOOP;

#define SIG_WRFIELDLOOP         'LFRW'

typedef struct _accfieldobj
{
    FRAMEHDR  FrameHdr;                 //frame header
    POBJDATA  pdataObj;                 //object to be read
    PUCHAR    pbBuff;                   //points to target buffer
    PUCHAR    pbBuffEnd;                //points to target buffer end
    ULONG     dwAccSize;                //access size
    ULONG     dwcAccesses;              //number of accesses
    ULONG     dwDataMask;               //data mask
    int       iLBits;                   //number of left bits
    int       iRBits;                   //number of right bits
    int       iAccess;                  //index to number of accesses
    ULONG     dwData;                   //temp. data
    FIELDDESC fd;
} ACCFIELDOBJ, *PACCFIELDOBJ;

#define SIG_ACCFIELDOBJ         'OFCA'

typedef struct _preservewrobj
{
    FRAMEHDR FrameHdr;                  //frame header
    POBJDATA pdataObj;                  //object to be read
    ULONG    dwWriteData;               //data to be written
    ULONG    dwPreserveMask;            //preserve bit mask
    ULONG    dwReadData;                //temp data read
} PRESERVEWROBJ, *PPRESERVEWROBJ;

#define SIG_PRESERVEWROBJ       'ORWP'

typedef struct _wrcookacc
{
    FRAMEHDR  FrameHdr;                 //frame header
    PNSOBJ    pnsBase;                  //points to opregion object
    PRSACCESS prsa;                     //points to RSACCESS
    ULONG     dwAddr;                   //region space address
    ULONG     dwSize;                   //size of access
    ULONG     dwData;                   //data to be written
    ULONG     dwDataMask;               //data mask
    ULONG     dwDataTmp;                //temp. data
    BOOLEAN   fPreserve;                //TRUE if need preserve bits
} WRCOOKACC, *PWRCOOKACC;

#define SIG_WRCOOKACC           'ACRW'

typedef struct _sleep
{
    FRAMEHDR      FrameHdr;             //frame header
    LIST_ENTRY    ListEntry;            //to link the sleep requests together
    LARGE_INTEGER SleepTime;            //wake up time
    PCTXT         Context;              //points to current context
} SLEEP, *PSLEEP;

#define SIG_SLEEP               'PELS'

typedef struct _resource
{
    ULONG         dwResType;
    struct _ctxt  *pctxtOwner;
    PVOID         pvResObj;
    LIST          list;
} RESOURCE, *PRESOURCE;

#define RESTYPE_MUTEX           1

typedef struct _heapobjhdr
{
    ULONG   dwSig;                      //heap object signature
    ULONG   dwLen;                      //heap object length;
    PHEAP   pheap;                      //points to beginning of heap
    LIST    list;                       //links all free heap blocks
} HEAPOBJHDR, *PHEAPOBJHDR;

struct _heap
{
    ULONG       dwSig;                  //heap signature
    PUCHAR      pbHeapEnd;              //points to end of heap block
    PHEAP       pheapHead;              //points to head of heap chain
    PHEAP       pheapNext;              //points to next heap block
    PUCHAR      pbHeapTop;              //points to the last free heap block
    PLIST       plistFreeHeap;          //points to the free heap block list
    HEAPOBJHDR  Heap;                   //beginning of heap memory
};

#define SIG_HEAP                'PAEH'

struct _ctxt
{
    ULONG       dwSig;                  //signature "CTXT"
    PUCHAR      pbCtxtEnd;              //points to end of context block
    LIST        listCtxt;               //links all allocated context
    LIST        listQueue;              //links for queuing context
    PPLIST      pplistCtxtQueue;        //points to queue head pointer
    PLIST       plistResources;         //links all owned resources
    ULONG       dwfCtxt;                //context flags
    PNSOBJ      pnsObj;                 //points to current object of evaluation
    PNSOBJ      pnsScope;               //points to current scope
    POBJOWNER   powner;                 //points to current object owner
    PCALL       pcall;                  //points to current call frame
    PNESTEDCTXT pnctxt;                 //points to current nest ctxt frame
    ULONG       dwSyncLevel;            //current sync level for mutexs
    PUCHAR      pbOp;                   //AML code pointer
    OBJDATA     Result;                 //to hold result data
    PFNACB      pfnAsyncCallBack;       //async completion callback function
    POBJDATA    pdataCallBack;          //points to return data of eval.
    PVOID       pvContext;              //context data for async callback
//  #ifdef DEBUGGER
//    LARGE_INTEGER Timestamp;
//  #endif
    KTIMER      Timer;                  //timeout timer if context is blocked
    KDPC        Dpc;                    //DPC hook for the context
    PHEAP       pheapCurrent;           //current heap
    CTXTDATA    CtxtData;               //context data
    HEAP        LocalHeap;              //Local heap
};

#define SIG_CTXT                'TXTC'
#define CTXTF_TIMER_PENDING     0x00000001
#define CTXTF_TIMER_DISPATCH    0x00000002
#define CTXTF_TIMEOUT           0x00000004
#define CTXTF_READY             0x00000008
#define CTXTF_RUNNING           0x00000010
#define CTXTF_NEED_CALLBACK     0x00000020
#define CTXTF_IN_READYQ         0x00000040
#define CTXTF_NEST_EVAL         0x00000080
#define CTXTF_ASYNC_EVAL        0x00000100

typedef struct _ctxtq
{
    ULONG    dwfCtxtQ;
    PKTHREAD pkthCurrent;
    PCTXT    pctxtCurrent;
    PLIST    plistCtxtQ;
    ULONG    dwmsTimeSliceLength;
    ULONG    dwmsTimeSliceInterval;
    PFNAA    pfnPauseCallback;
    PVOID    PauseCBContext;
    MUTEX    mutCtxtQ;
    KTIMER   Timer;
    KDPC     DpcStartTimeSlice;
    KDPC     DpcExpireTimeSlice;
    WORK_QUEUE_ITEM WorkItem;
} CTXTQ, *PCTXTQ;

#define CQF_TIMESLICE_EXPIRED   0x00000001
#define CQF_WORKITEM_SCHEDULED  0x00000002
#define CQF_FLUSHING            0x00000004
#define CQF_PAUSED              0x00000008

typedef struct _syncevent
{
    NTSTATUS rcCompleted;
    PCTXT    pctxt;
    KEVENT   Event;
} SYNCEVENT, *PSYNCEVENT;

typedef struct _restart
{
    PCTXT pctxt;
    WORK_QUEUE_ITEM WorkItem;
} RESTART, *PRESTART;

#endif  //ifndef _CTXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\nsmod.c ===
/*** nsmod.c - Parse name space modifier instructions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/12/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  Alias - Parse and execute the Alias instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Alias(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ALIAS")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsSrc;

    ENTER(2, ("Alias(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    ASSERT(pterm->pdataArgs[1].dwDataType == OBJTYPE_STRDATA);
    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsSrc, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                     (PSZ)pterm->pdataArgs[1].pbDataBuff,
                                     pctxt->pnsScope, pctxt->powner,
                                     &pterm->pnsObj, 0)) == STATUS_SUCCESS))
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_OBJALIAS;
        pterm->pnsObj->ObjData.uipDataValue = (ULONG_PTR)pnsSrc;
    }

    EXIT(2, ("Alias=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Alias

/***LP  Name - Parse and execute the Name instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Name(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("NAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Name(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        MoveObjData(&pterm->pnsObj->ObjData, &pterm->pdataArgs[1]);
    }

    EXIT(2, ("Name=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Name

/***LP  Scope - Parse and execute the Scope instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Scope(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("SCOPE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Scope(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                 pctxt->pnsScope, &pterm->pnsObj,
                                 NSF_WARN_NOTFOUND)) == STATUS_SUCCESS)
    {
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("Scope=%x\n", rc));
    return rc;
}       //Scope
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\object.c ===
/*** object.c - Object access functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     01/27/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ReadObject - Read object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataResult)
{
    TRACENAME("READOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDUNIT pafu;

    ENTER(3, ("ReadObject(pctxt=%x,pdataObj=%x,pdataResult=%x)\n",
              pctxt, pdataObj, pdataResult));

    pdataObj = GetBaseData(pdataObj);

    switch (pdataObj->dwDataType)
    {
        case OBJTYPE_FIELDUNIT:
            if ((rc = PushFrame(pctxt, SIG_ACCFIELDUNIT, sizeof(ACCFIELDUNIT),
                                AccFieldUnit, &pafu)) == STATUS_SUCCESS)
            {
                pafu->pdataObj = pdataObj;
                pafu->FrameHdr.dwfFrame = AFUF_READFIELDUNIT;
                pafu->pdata = pdataResult;
            }
            break;

        case OBJTYPE_BUFFFIELD:
            rc = ReadField(pctxt, pdataObj,
                           &((PBUFFFIELDOBJ)pdataObj->pbDataBuff)->FieldDesc,
                           pdataResult);
            break;

        default:
            ASSERT(pdataResult->dwDataType == OBJTYPE_UNKNOWN);
            CopyObjData(pdataResult, pdataObj);

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("=");
                PrintObject(pdataResult);
            }
          #endif
    }

    EXIT(3, ("ReadObject=%x (Type=%s,Value=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pdataResult->dwDataType),
             pdataResult->uipDataValue, pdataResult->pbDataBuff));
    return rc;
}       //ReadObject

/***LP  WriteObject - Write object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pdataSrc -> source data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataSrc)
{
    TRACENAME("WRITEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDUNIT pafu;

    ENTER(3, ("WriteObject(pctxt=%x,pdataObj=%x,pdataSrc=%x)\n",
              pctxt, pdataObj, pdataSrc));

    pdataObj = GetBaseData(pdataObj);

    switch (pdataObj->dwDataType)
    {
        case OBJTYPE_FIELDUNIT:
            if ((rc = PushFrame(pctxt, SIG_ACCFIELDUNIT, sizeof(ACCFIELDUNIT),
                                AccFieldUnit, &pafu)) == STATUS_SUCCESS)
            {
                pafu->pdataObj = pdataObj;
                pafu->pdata = pdataSrc;
            }
            break;

        case OBJTYPE_BUFFFIELD:
            rc = WriteField(pctxt, pdataObj,
                            &((PBUFFFIELDOBJ)pdataObj->pbDataBuff)->FieldDesc,
                            pdataSrc);
            break;

        case OBJTYPE_DEBUG:
#ifdef  DEBUGGER
            if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
            {
                DumpObject(pdataSrc, NULL, 0);
            }
#endif
            rc = STATUS_SUCCESS;
            break;

        case OBJTYPE_UNKNOWN:
            //
            // Since the target object could be a global NameSpace object,
            // allocate memory from the global heap just to be safe.
            //
            rc = DupObjData(gpheapGlobal, pdataObj, pdataSrc);
            break;

        case OBJTYPE_INTDATA:
            rc = CopyObjBuffer((PUCHAR)&pdataObj->uipDataValue, sizeof(ULONG),
                               pdataSrc);
            break;

        case OBJTYPE_STRDATA:
            rc = CopyObjBuffer(pdataObj->pbDataBuff, pdataObj->dwDataLen - 1,
                               pdataSrc);
            break;

        case OBJTYPE_BUFFDATA:
            rc = CopyObjBuffer(pdataObj->pbDataBuff, pdataObj->dwDataLen,
                               pdataSrc);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("WriteObject: unexpected target object type (type=%s)",
                              GetObjectTypeName(pdataObj->dwDataType)));
    }

    EXIT(3, ("WriteObject=%x (ObjType=%s,DataType=%x,Value=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pdataObj->dwDataType), pdataSrc->dwDataType,
             pdataSrc->uipDataValue, pdataSrc->pbDataBuff));
    return rc;
}       //WriteObject

/***LP  AccFieldUnit - Access a FieldUnit object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafu -> ACCFIELDUNIT
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AccFieldUnit(PCTXT pctxt, PACCFIELDUNIT pafu, NTSTATUS rc)
{
    TRACENAME("ACCFIELDUNIT")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafu->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    PFIELDUNITOBJ pfu;
    POBJDATA pdataParent, pdataBank;
    PBANKFIELDOBJ pbf;

    ENTER(3, ("AccFieldUnit(Stage=%d,pctxt=%x,pafu=%x,rc=%x)\n",
              dwStage, pctxt, pafu, rc));

    ASSERT(pafu->FrameHdr.dwSig == SIG_ACCFIELDUNIT);

    pfu = (PFIELDUNITOBJ)pafu->pdataObj->pbDataBuff;
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Set bank if necessary.
            //
            pafu->FrameHdr.dwfFrame++;
            pdataParent = &pfu->pnsFieldParent->ObjData;
            if (pdataParent->dwDataType == OBJTYPE_BANKFIELD)
            {
                pbf = (PBANKFIELDOBJ)pdataParent->pbDataBuff;
                pdataBank = &pbf->pnsBank->ObjData;
                rc = PushAccFieldObj(pctxt, WriteFieldObj, pdataBank,
                             &((PFIELDUNITOBJ)pdataBank->pbDataBuff)->FieldDesc,
                                     (PUCHAR)&pbf->dwBankValue,
                                     sizeof(ULONG));
                break;
            }

        case 1:
            //
            // Stage 1: Acquire GlobalLock if necessary.
            //
            pafu->FrameHdr.dwfFrame++;
            if (NeedGlobalLock(pfu))
            {
                if ((rc = AcquireGL(pctxt)) != STATUS_SUCCESS)
                {
                    break;
                }
            }

        case 2:
            //
            // Stage 2: Read/Write the field.
            //
            pafu->FrameHdr.dwfFrame++;
            //
            // If we come here and we need global lock, we must have got it.
            //
            if (pfu->FieldDesc.dwFieldFlags & FDF_NEEDLOCK)
            {
                pafu->FrameHdr.dwfFrame |= AFUF_HAVE_GLOBALLOCK;
            }

            if (pafu->FrameHdr.dwfFrame & AFUF_READFIELDUNIT)
            {
                rc = ReadField(pctxt, pafu->pdataObj, &pfu->FieldDesc,
                               pafu->pdata);
            }
            else
            {
                rc = WriteField(pctxt, pafu->pdataObj, &pfu->FieldDesc,
                                pafu->pdata);
            }

            if ((rc == AMLISTA_PENDING) ||
                (&pafu->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 3:
            //
            // Stage 3: Clean up.
            //
            if (pafu->FrameHdr.dwfFrame & AFUF_HAVE_GLOBALLOCK)
            {
                ReleaseGL(pctxt);
            }

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pafu->FrameHdr.dwfFrame & AFUF_READFIELDUNIT)
                {
                    PRINTF("=");
                    PrintObject(pafu->pdata);
                }
            }
          #endif
            PopFrame(pctxt);
    }

    EXIT(3, ("AccFieldUnit=%x\n", rc));
    return rc;
}       //AccFieldUnit

/***LP  ReadField - Read data from a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                         POBJDATA pdataResult)
{
    TRACENAME("READFIELD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ReadField(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdataResult=%x)\n",
              pctxt, pdataObj, pfd, pdataResult));

    if ((pfd->dwFieldFlags & ACCTYPE_MASK) <= ACCTYPE_DWORD)
    {
        PUCHAR pb;
        ULONG dwcb;

        switch (pdataResult->dwDataType)
        {
            case OBJTYPE_UNKNOWN:
                if (!(pfd->dwFieldFlags & FDF_BUFFER_TYPE) &&
                    (pfd->dwNumBits <= sizeof(ULONG)*8))
                {
                    pdataResult->dwDataType = OBJTYPE_INTDATA;
                    pb = (PUCHAR)&pdataResult->uipDataValue;
                    dwcb = sizeof(ULONG);
                }
                else
                {
                    pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                    pdataResult->dwDataLen = (pfd->dwNumBits + 7)/8;
                    if ((pdataResult->pbDataBuff =
                         NEWBDOBJ(gpheapGlobal, pdataResult->dwDataLen))
                        == NULL)
                    {
                        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                         ("ReadField: failed to allocate target buffer (size=%d)",
                                          pdataResult->dwDataLen));
                        pb = NULL;
                        dwcb = 0;
                    }
                    else
                    {
                        MEMZERO(pdataResult->pbDataBuff,
                                pdataResult->dwDataLen);
                        pb = pdataResult->pbDataBuff;
                        dwcb = pdataResult->dwDataLen;
                    }
                }
                break;

            case OBJTYPE_INTDATA:
                pb = (PUCHAR)&pdataResult->uipDataValue;
                dwcb = sizeof(ULONG);
                break;

            case OBJTYPE_STRDATA:
                pb = pdataResult->pbDataBuff;
                dwcb = pdataResult->dwDataLen - 1;
                break;

            case OBJTYPE_BUFFDATA:
                pb = pdataResult->pbDataBuff;
                dwcb = pdataResult->dwDataLen;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("ReadField: invalid target data type (type=%s)",
                                  GetObjectTypeName(pdataResult->dwDataType)));
                pb = NULL;
                dwcb = 0;
        }

        if (rc == STATUS_SUCCESS)
            rc = PushAccFieldObj(pctxt, ReadFieldObj, pdataObj, pfd, pb, dwcb);
    }
    else if (pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
    {
        //
        // This is an access type we don't know how to handle, so try to find
        // a raw access handler to handle it.
        //
        rc = RawFieldAccess(pctxt, RSACCESS_READ, pdataObj, pdataResult);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_ACCSIZE,
                         ("ReadField: invalid access size for buffer field (FieldFlags=%x)",
                          pfd->dwFieldFlags));
    }

    EXIT(3, ("ReadField=%x\n", rc));
    return rc;
}       //ReadField

/***LP  WriteField - Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdataSrc -> source data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                          POBJDATA pdataSrc)
{
    TRACENAME("WRITEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwDataInc = (pfd->dwNumBits + 7)/8;
    PUCHAR pbBuff;
    ULONG dwBuffSize;

    ENTER(3, ("WriteField(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdataSrc=%x)\n",
              pctxt, pdataObj, pfd, pdataSrc));

    if ((pfd->dwFieldFlags & ACCTYPE_MASK) <= ACCTYPE_DWORD)
    {
        PWRFIELDLOOP pwfl;

        switch (pdataSrc->dwDataType)
        {
            case OBJTYPE_INTDATA:
                dwBuffSize = MIN(sizeof(ULONG), dwDataInc);
                pbBuff = (PUCHAR)&pdataSrc->uipDataValue;
                break;

            case OBJTYPE_STRDATA:
                dwBuffSize = pdataSrc->dwDataLen - 1;
                pbBuff = pdataSrc->pbDataBuff;
                break;

            case OBJTYPE_BUFFDATA:
                dwBuffSize = pdataSrc->dwDataLen;
                pbBuff = pdataSrc->pbDataBuff;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("WriteField: invalid source data type (type=%s)\n",
                                  GetObjectTypeName(pdataSrc->dwDataType)));
                dwBuffSize = 0;
                pbBuff = NULL;
        }

        if ((rc == STATUS_SUCCESS) &&
            ((rc = PushFrame(pctxt, SIG_WRFIELDLOOP, sizeof(WRFIELDLOOP),
                             WriteFieldLoop, &pwfl)) == STATUS_SUCCESS))
        {
            pwfl->pdataObj = pdataObj;
            pwfl->pfd = pfd;
            pwfl->pbBuff = pbBuff;
            pwfl->dwBuffSize = dwBuffSize;
            pwfl->dwDataInc = dwDataInc;
        }
    }
    else if (pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
    {
        //
        // This is an access type we don't know how to handle, so try to find
        // a raw access handler to handle it.
        //
        rc = RawFieldAccess(pctxt, RSACCESS_WRITE, pdataObj, pdataSrc);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_ACCSIZE,
                         ("WriteField: invalid access size for buffer field (FieldFlags=%x)",
                          pfd->dwFieldFlags));
    }

    EXIT(3, ("WriteField=%x\n", rc));
    return rc;
}       //WriteField

/***LP  WriteFieldLoop - executing the loop for the WriteField operation
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pwfl -> WRFIELDLOOP
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteFieldLoop(PCTXT pctxt, PWRFIELDLOOP pwfl, NTSTATUS rc)
{
    TRACENAME("WRITEFIELDLOOP")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pwfl->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;
    ULONG dwXactionSize;

    ENTER(3, ("WriteFieldLoop(Stage=%d,pctxt=%x,pwfl=%x,rc=%x)\n",
              dwStage, pctxt, pwfl, rc));

    ASSERT(pwfl->FrameHdr.dwSig == SIG_WRFIELDLOOP);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do loop.
            //
            if (pwfl->dwBuffSize > 0)
            {
                dwXactionSize = MIN(pwfl->dwDataInc, pwfl->dwBuffSize);
                rc = PushAccFieldObj(pctxt, WriteFieldObj, pwfl->pdataObj,
                                     pwfl->pfd, pwfl->pbBuff, dwXactionSize);
                pwfl->dwBuffSize -= dwXactionSize;
                pwfl->pbBuff += dwXactionSize;
                break;
            }

            pwfl->FrameHdr.dwfFrame++;

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteFieldLoop=%x\n", rc));
    return rc;
}       //WriteFieldLoop

/***LP  PushAccFieldObj - Push a AccFieldObj frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pfnAcc -> access function
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pb -> data buffer
 *      dwcb - buffer size
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushAccFieldObj(PCTXT pctxt, PFNPARSE pfnAcc, POBJDATA pdataObj,
                               PFIELDDESC pfd, PUCHAR pb, ULONG dwcb)
{
    TRACENAME("PUSHACCFIELDOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDOBJ pafo;

    ENTER(3, ("PushAccFieldObj(pctxt=%x,pfnAcc=%x,pdataObj=%x,FieldDesc=%x,pb=%x,Size=%d)\n",
              pctxt, pfnAcc, pdataObj, pfd, pb, dwcb));

    if ((rc = PushFrame(pctxt, SIG_ACCFIELDOBJ, sizeof(ACCFIELDOBJ), pfnAcc,
                        &pafo)) == STATUS_SUCCESS)
    {
        pafo->pdataObj = pdataObj;
        pafo->pbBuff = pb;
        pafo->pbBuffEnd = pb + dwcb;
        pafo->dwAccSize = ACCSIZE(pfd->dwFieldFlags);
        ASSERT((pafo->dwAccSize == sizeof(UCHAR)) ||
               (pafo->dwAccSize == sizeof(USHORT)) ||
               (pafo->dwAccSize == sizeof(ULONG)));
        pafo->dwcAccesses = (pfd->dwStartBitPos + pfd->dwNumBits +
                             pafo->dwAccSize*8 - 1)/(pafo->dwAccSize*8);
        pafo->dwDataMask = SHIFTLEFT(1L, pafo->dwAccSize*8) - 1;
        pafo->iLBits = pafo->dwAccSize*8 - pfd->dwStartBitPos;
        pafo->iRBits = (int)pfd->dwStartBitPos;
        MEMCPY(&pafo->fd, pfd, sizeof(FIELDDESC));
    }

    EXIT(3, ("PushAccFieldObj=%x\n", rc));
    return rc;
}       //PushAccFieldObj

/***LP  ReadFieldObj - Read data from a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafo -> ACCFIELDOBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadFieldObj(PCTXT pctxt, PACCFIELDOBJ pafo, NTSTATUS rc)
{
    TRACENAME("READFIELDOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafo->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    POBJDATA pdataParent;

    ENTER(3, ("ReadFieldObj(Stage=%d,pctxt=%x,pafo=%x,rc=%x)\n",
              dwStage, pctxt, pafo, rc));

    ASSERT(pafo->FrameHdr.dwSig == SIG_ACCFIELDOBJ);

    switch (dwStage)
    {
        case 0:
        Stage0:
            //
            // Stage 0: Set Index if necessary.
            //
            if (pafo->iAccess >= (int)pafo->dwcAccesses)
            {
                //
                // No access necessary, go straight to clean up.
                //
                pafo->FrameHdr.dwfFrame += 3;
                goto Stage3;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
                if (pafo->pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
                {
                    pdataParent =
                        &((PFIELDUNITOBJ)pafo->pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

                    if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
                    {
                        PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

                        rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                             &pif->pnsIndex->ObjData,
                                             &((PFIELDUNITOBJ)pif->pnsIndex->ObjData.pbDataBuff)->FieldDesc,
                                             (PUCHAR)&pafo->fd.dwByteOffset,
                                             sizeof(ULONG));
                        break;
                    }
                }
            }

        case 1:
            //
            // Stage 1: Access field data.
            //
            pafo->FrameHdr.dwfFrame++;
            rc = AccessFieldData(pctxt, pafo->pdataObj, &pafo->fd,
                                 &pafo->dwData, TRUE);

            if ((rc != STATUS_SUCCESS) ||
                (&pafo->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 2:
            //
            // Stage 2: Massage data into the right bit position.
            //
            if (pafo->iAccess > 0)
            {
                WriteSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                               SHIFTLEFT(pafo->dwData, pafo->iLBits) &
                                   pafo->dwDataMask,
                               (SHIFTLEFT(1L, pafo->iRBits) - 1) << pafo->iLBits);

                pafo->pbBuff += pafo->dwAccSize;
                if (pafo->pbBuff >= pafo->pbBuffEnd)
                {
                    //
                    // We ran out of buffer, so we are done (go to clean up).
                    //
                    pafo->FrameHdr.dwfFrame++;
                    goto Stage3;
                }
            }

            pafo->dwData >>= pafo->iRBits;
            if ((int)pafo->fd.dwNumBits < pafo->iLBits)
            {
                pafo->dwData &= SHIFTLEFT(1L, pafo->fd.dwNumBits) - 1;
            }

            WriteSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                           pafo->dwData,
                           (SHIFTLEFT(1L, pafo->iLBits) - 1) >> pafo->iRBits);

            pafo->fd.dwByteOffset += pafo->dwAccSize;
            pafo->fd.dwNumBits -= pafo->dwAccSize*8 - pafo->fd.dwStartBitPos;
            pafo->fd.dwStartBitPos = 0;
            pafo->iAccess++;
            if (pafo->iAccess < (int)pafo->dwcAccesses)
            {
                //
                // Still more accesses to go, back to stage 0.
                //
                pafo->FrameHdr.dwfFrame -= 2;
                goto Stage0;
            }
            else
            {
                //
                // No more accesses, continue to clean up.
                //
                pafo->FrameHdr.dwfFrame++;
            }

        case 3:
        Stage3:
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("ReadFieldObj=%x\n", rc));
    return rc;
}       //ReadFieldObj

/***LP  WriteFieldObj - Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafo -> ACCFIELDOBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteFieldObj(PCTXT pctxt, PACCFIELDOBJ pafo, NTSTATUS rc)
{
    TRACENAME("WRITEFIELDOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafo->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    POBJDATA pdataParent;
    ULONG dwData1;

    ENTER(3, ("WriteFieldObj(Stage=%d,pctxt=%x,pafo=%x,rc=%x)\n",
              dwStage, pctxt, pafo, rc));

    ASSERT(pafo->FrameHdr.dwSig == SIG_ACCFIELDOBJ);

    switch (dwStage)
    {
        case 0:
        Stage0:
            //
            // Stage 0: Set Index if necessary.
            //
            if (pafo->iAccess >= (int)pafo->dwcAccesses)
            {
                //
                // No access necessary, go straight to clean up.
                //
                pafo->FrameHdr.dwfFrame += 3;
                goto Stage3;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
                if (pafo->pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
                {
                    pdataParent =
                        &((PFIELDUNITOBJ)pafo->pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

                    if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
                    {
                        PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

                        rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                             &pif->pnsIndex->ObjData,
                                             &((PFIELDUNITOBJ)pif->pnsIndex->ObjData.pbDataBuff)->FieldDesc,
                                             (PUCHAR)&pafo->fd.dwByteOffset,
                                             sizeof(ULONG));
                        break;
                    }
                }
            }

        case 1:
            //
            // Stage 1: Massage data into the right bit position and write it.
            //
            pafo->FrameHdr.dwfFrame++;
            dwData1 = ReadSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                                    pafo->dwDataMask);
            if (pafo->iAccess > 0)
            {
                pafo->dwData = dwData1 >> pafo->iLBits;
                pafo->pbBuff += pafo->dwAccSize;
                if (pafo->pbBuff >= pafo->pbBuffEnd)
                {
                    dwData1 = 0;
                }
                else
                {
                    dwData1 = ReadSystemMem((ULONG_PTR)pafo->pbBuff,
                                            pafo->dwAccSize, pafo->dwDataMask);
                }
            }
            else
            {
                pafo->dwData = 0;
            }

            pafo->dwData |= (dwData1 << pafo->iRBits) & pafo->dwDataMask;

            rc = AccessFieldData(pctxt, pafo->pdataObj, &pafo->fd,
                                 &pafo->dwData, FALSE);

            if ((rc == AMLISTA_PENDING) ||
                (&pafo->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 2:
            //
            // Stage 2: Check for more iterations.
            //
            pafo->fd.dwByteOffset += pafo->dwAccSize;
            pafo->fd.dwNumBits -= pafo->dwAccSize*8 - pafo->fd.dwStartBitPos;
            pafo->fd.dwStartBitPos = 0;
            pafo->iAccess++;
            if (pafo->iAccess < (int)pafo->dwcAccesses)
            {
                //
                // Still more accesses to go, back to stage 0.
                //
                pafo->FrameHdr.dwfFrame -= 2;
                goto Stage0;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
            }

        case 3:
        Stage3:
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteFieldObj=%x\n", rc));
    return rc;
}       //WriteFieldObj


/***LP  RawFieldAccess - Find and call the RawAccess handler for the RegionSpace
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwAccType - read/write
 *      pdataObj -> field unit object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RawFieldAccess(PCTXT pctxt, ULONG dwAccType, POBJDATA pdataObj,
                              POBJDATA pdataResult)
{
    TRACENAME("RAWFIELDACCESS")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdataParent;
    POPREGIONOBJ pop;
    PRSACCESS prsa;
    PFIELDUNITOBJ pfuFieldUnit;

    ENTER(3, ("RawFieldAccess(pctxt=%x,AccType=%x,pdataObj=%x,pdata=%x)\n",
              pctxt, dwAccType, pdataObj, pdataResult));

    pdataParent =
        &((PFIELDUNITOBJ)pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

    switch (pdataParent->dwDataType)
    {
        case OBJTYPE_FIELD:
            pop = (POPREGIONOBJ)
                  ((PFIELDOBJ)pdataParent->pbDataBuff)->pnsBase->ObjData.pbDataBuff;
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("RawFieldAccess: invalid field parent type (type=%s)",
                              pdataParent->dwDataType));
            pop = NULL;
    }

    if (rc == STATUS_SUCCESS)
    {
        if (((prsa = FindRSAccess(pop->bRegionSpace)) != NULL) &&
            (prsa->pfnRawAccess != NULL))
        {
          #ifdef DEBUGGER
            ULONG dwOldFlags = gDebugger.dwfDebugger;

            if (dwOldFlags & DBGF_AMLTRACE_ON)
            {
                gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
            }
          #endif
            ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));

            if ((pfuFieldUnit = NEWFUOBJ(pctxt->pheapCurrent, sizeof (FIELDUNITOBJ))) == NULL) {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("RawFieldAccess: failed to allocate Field unit"));
            } else {
                RtlCopyMemory (pfuFieldUnit, (PFIELDUNITOBJ)pdataObj->pbDataBuff, sizeof (FIELDUNITOBJ));
                pfuFieldUnit->FieldDesc.dwByteOffset += (ULONG) pop->uipOffset;
                rc = prsa->pfnRawAccess(dwAccType,
                                        pfuFieldUnit,
                                        pdataResult, prsa->uipRawParam,
                                        RestartCtxtCallback, &pctxt->CtxtData);
                if (rc == STATUS_BUFFER_TOO_SMALL) {
                    //
                    // When opregion handler returns STATUS_BUFFER_TOO_SMALL, this indicates that it 
                    // needs to have a buffer alloocated for it.  The buffer size is returned in 
                    // pdataResult->dwDataValue
                    //

                    ASSERT(pdataResult->dwDataType == OBJTYPE_INTDATA);
                    if ((pdataResult->pbDataBuff = NEWBDOBJ(gpheapGlobal, pdataResult->dwDataValue)) == NULL) {
                        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                         ("Buffer: failed to allocate data buffer (size=%d)",
                                         pdataResult->dwDataValue));
                    } else {
                        pdataResult->dwDataLen = pdataResult->dwDataValue;
                        pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                        rc = prsa->pfnRawAccess(dwAccType,
                                                pfuFieldUnit,
                                                pdataResult, prsa->uipRawParam,
                                                RestartCtxtCallback, &pctxt->CtxtData);
                    }
                }
            }
          #ifdef DEBUGGER
            gDebugger.dwfDebugger = dwOldFlags;
          #endif

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                 ("RawFieldAccess: RegionSpace %x handler returned error %x",
                                  pop->bRegionSpace, rc));
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                             ("RawFieldAccess: no handler for RegionSpace %x",
                              pop->bRegionSpace));
        }
    }

    EXIT(3, ("RawFieldAccess=%x\n", rc));
    return rc;
}       //RawFieldAccess

/***LP  AccessFieldData - Read/Write field object data
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdwData -> to hold data read or data to be written
 *      fRead - TRUE if read access
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AccessFieldData(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead)
{
    TRACENAME("ACCESSFIELDDATA")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("AccessFieldData(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdwData=%x,fRead=%x)\n",
              pctxt, pdataObj, pfd, pdwData, fRead));

    if (pdataObj->dwDataType == OBJTYPE_BUFFFIELD)
    {
        if (fRead)
        {
            rc = ReadBuffField((PBUFFFIELDOBJ)pdataObj->pbDataBuff, pfd,
                               pdwData);
        }
        else
        {
            rc = WriteBuffField((PBUFFFIELDOBJ)pdataObj->pbDataBuff, pfd,
                                *pdwData);
        }
    }
    else        //must be OBJTYPE_FIELDUNIT
    {
        POBJDATA pdataParent;
        PNSOBJ pnsBase = NULL;

        pdataParent = &((PFIELDUNITOBJ)pdataObj->pbDataBuff)->pnsFieldParent->ObjData;
        if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
        {
            PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

            if (fRead)
            {
                rc = PushAccFieldObj(pctxt, ReadFieldObj,
                                     &pif->pnsData->ObjData,
                                     &((PFIELDUNITOBJ)pif->pnsData->ObjData.pbDataBuff)->FieldDesc,
                                     (PUCHAR)pdwData, sizeof(ULONG));
            }
            else
            {
                ULONG dwPreserveMask, dwAccMask;

                dwPreserveMask = ~((SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                                   pfd->dwStartBitPos);
                dwAccMask = SHIFTLEFT(1L, ACCSIZE(pfd->dwFieldFlags)*8) - 1;
                if (((pfd->dwFieldFlags & UPDATERULE_MASK) ==
                     UPDATERULE_PRESERVE) &&
                    ((dwPreserveMask & dwAccMask) != 0))
                {
                    rc = PushPreserveWriteObj(pctxt, &pif->pnsData->ObjData,
                                              *pdwData, dwPreserveMask);
                }
                else
                {
                    rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                         &pif->pnsData->ObjData,
                                         &((PFIELDUNITOBJ)pif->pnsData->ObjData.pbDataBuff)->FieldDesc,
                                         (PUCHAR)pdwData, sizeof(ULONG));
                }
            }
        }
        else if ((rc = GetFieldUnitRegionObj(
                            (PFIELDUNITOBJ)pdataObj->pbDataBuff, &pnsBase)) ==
                 STATUS_SUCCESS && pnsBase != NULL)
        {
            rc = AccessBaseField(pctxt, pnsBase, pfd, pdwData, fRead);
        }
    }

    EXIT(3, ("AccessFieldData=%x (Data=%x)\n", rc, pdwData? *pdwData: 0));
    return rc;
}       //AccessFieldData

/***LP  PushPreserveWriteObj - Push a PreserveWrObj frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      dwData - data to be written
 *      dwPreserveMask - preserve bit mask
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushPreserveWriteObj(PCTXT pctxt, POBJDATA pdataObj,
                                    ULONG dwData, ULONG dwPreserveMask)
{
    TRACENAME("PUSHPRESERVEWRITEOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PPRESERVEWROBJ ppwro;

    ENTER(3, ("PushPreserveWriteObj(pctxt=%x,pdataObj=%x,Data=%x,PreserveMask=%x)\n",
              pctxt, pdataObj, dwData, dwPreserveMask));

    if ((rc = PushFrame(pctxt, SIG_PRESERVEWROBJ, sizeof(PRESERVEWROBJ),
                        PreserveWriteObj, &ppwro)) == STATUS_SUCCESS)
    {
        ppwro->pdataObj = pdataObj;
        ppwro->dwWriteData = dwData;
        ppwro->dwPreserveMask = dwPreserveMask;
    }

    EXIT(3, ("PushPreserveWriteObj=%x\n", rc));
    return rc;
}       //PushPreserveWriteObj

/***LP  PreserveWriteObj - Preserve Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppwro -> PRESERVEWROBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PreserveWriteObj(PCTXT pctxt, PPRESERVEWROBJ ppwro, NTSTATUS rc)
{
    TRACENAME("PRESERVEWRITEOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppwro->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(3, ("PreserveWriteObj(Stage=%d,pctxt=%x,ppwro=%x,rc=%x)\n",
              dwStage, pctxt, ppwro, rc));

    ASSERT(ppwro->FrameHdr.dwSig == SIG_PRESERVEWROBJ);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Read the object first.
            //
            ppwro->FrameHdr.dwfFrame++;
            rc = PushAccFieldObj(pctxt, ReadFieldObj, ppwro->pdataObj,
                                 &((PFIELDUNITOBJ)ppwro->pdataObj->pbDataBuff)->FieldDesc,
                                 (PUCHAR)&ppwro->dwReadData, sizeof(ULONG));
            break;

        case 1:
            //
            // Stage 1: OR the preserve bits to the data to be written and
            // write it.
            //
            ppwro->FrameHdr.dwfFrame++;
            ppwro->dwWriteData |= ppwro->dwReadData & ppwro->dwPreserveMask;
            rc = PushAccFieldObj(pctxt, WriteFieldObj, ppwro->pdataObj,
                                 &((PFIELDUNITOBJ)ppwro->pdataObj->pbDataBuff)->FieldDesc,
                                 (PUCHAR)&ppwro->dwWriteData, sizeof(ULONG));
            break;

        case 2:
            //
            // Stage 2: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("PreserveWriteObj=%x\n", rc));
    return rc;
}       //PreserveWriteObj

/***LP  AccessBaseField - Access the base field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsBase -> OpRegion object
 *      pfd -> FIELDDESC
 *      pdwData -> result data (for read access) or data to be written
 *      fRead - TRUE if read access
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      If pdwData is NULL, it implies a read access.
 */

NTSTATUS LOCAL AccessBaseField(PCTXT pctxt, PNSOBJ pnsBase, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead)
{
    TRACENAME("ACCESSBASEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    POPREGIONOBJ pop;
    ULONG_PTR uipAddr;
    ULONG dwSize, dwDataMask, dwAccMask;
    PRSACCESS prsa;
    BOOLEAN fPreserve;

    ENTER(3, ("AccessBaseField(pctxt=%x,pnsBase=%x,pfd=%x,pdwData=%x,fRead=%x)\n",
              pctxt, pnsBase, pfd, pdwData, fRead));

    ASSERT(pnsBase->ObjData.dwDataType == OBJTYPE_OPREGION);
    pop = (POPREGIONOBJ)pnsBase->ObjData.pbDataBuff;
    uipAddr = (ULONG_PTR)(pop->uipOffset + pfd->dwByteOffset);
    dwSize = ACCSIZE(pfd->dwFieldFlags);
    dwDataMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) << pfd->dwStartBitPos;
    dwAccMask = SHIFTLEFT(1L, dwSize*8) - 1;
    fPreserve = (BOOLEAN)(((pfd->dwFieldFlags & UPDATERULE_MASK) ==
                           UPDATERULE_PRESERVE) &&
                          ((~dwDataMask & dwAccMask) != 0));

    if (!fRead &&
        ((pfd->dwFieldFlags & UPDATERULE_MASK) == UPDATERULE_WRITEASONES))
    {
        *pdwData |= ~dwDataMask;
    }

    switch (pop->bRegionSpace)
    {
        case REGSPACE_MEM:
            if (fRead)
            {
                *pdwData = ReadSystemMem(uipAddr, dwSize, dwDataMask);
            }
            else
            {
                if (fPreserve)
                {
                    *pdwData |= ReadSystemMem(uipAddr, dwSize, ~dwDataMask);
                }

                WriteSystemMem(uipAddr, dwSize, *pdwData, dwAccMask);
            }
            break;

        case REGSPACE_IO:
            if (fRead)
            {
                *pdwData = ReadSystemIO((ULONG)uipAddr, dwSize, dwDataMask);
            }
            else
            {
                if (fPreserve)
                {
                    *pdwData |= ReadSystemIO((ULONG)uipAddr, dwSize,
                                             ~dwDataMask);
                }

                WriteSystemIO((ULONG)uipAddr, dwSize, *pdwData);
            }
            break;

        default:
            if (((prsa = FindRSAccess(pop->bRegionSpace)) != NULL) &&
                (prsa->pfnCookAccess != NULL))
            {
                if (fRead)
                {
                  #ifdef DEBUGGER
                    ULONG dwOldFlags = gDebugger.dwfDebugger;

                    if (dwOldFlags & DBGF_TRACE_NONEST)
                    {
                        gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                    }
                  #endif
                    //
                    // Read access.
                    //
                    ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
                    rc = prsa->pfnCookAccess(RSACCESS_READ, pnsBase, uipAddr,
                                             dwSize, pdwData, prsa->uipCookParam,
                                             RestartCtxtCallback,
                                             &pctxt->CtxtData);
                  #ifdef DEBUGGER
                    gDebugger.dwfDebugger = dwOldFlags;
                  #endif

                    if (rc == STATUS_PENDING)
                    {
                        rc = AMLISTA_PENDING;
                    }
                    else if (rc != STATUS_SUCCESS)
                    {
                        rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                         ("AccessBaseField: RegionSpace %x read handler returned error %x",
                                          pop->bRegionSpace, rc));
                    }
                }
                else
                {
                    PWRCOOKACC pwca;
                    //
                    // Write access.
                    //
                    if ((rc = PushFrame(pctxt, SIG_WRCOOKACC, sizeof(WRCOOKACC),
                                        WriteCookAccess, &pwca)) ==
                        STATUS_SUCCESS)
                    {
                        pwca->pnsBase = pnsBase;
                        pwca->prsa = prsa;
                        pwca->dwAddr = (ULONG)uipAddr;
                        pwca->dwSize = dwSize;
                        pwca->dwData = *pdwData;
                        pwca->dwDataMask = dwDataMask;
                        pwca->fPreserve = fPreserve;
                    }
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                                 ("AccessBaseField: no handler for RegionSpace %x",
                                  pop->bRegionSpace));
            }
    }

    EXIT(3, ("AccessBaseField=%x (Value=%x,Addr=%x,Size=%d,DataMask=%x,AccMask=%x)\n",
             rc, *pdwData, uipAddr, dwSize, dwDataMask, dwAccMask));
    return rc;
}       //AccessBaseField

/***LP  WriteCookAccess - do a region space write cook access
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pwca -> WRCOOKACC
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteCookAccess(PCTXT pctxt, PWRCOOKACC pwca, NTSTATUS rc)
{
    TRACENAME("WRCOOKACCESS")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pwca->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    KIRQL   oldIrql;
    LONG    busy;
    POPREGIONOBJ pop = (POPREGIONOBJ)pwca->pnsBase->ObjData.pbDataBuff;

    ENTER(3, ("WriteCookAccess(Stage=%d,pctxt=%x,pwca=%x,rc=%x)\n",
              dwStage, pctxt, pwca, rc));

    ASSERT(pwca->FrameHdr.dwSig == SIG_WRCOOKACC);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: if PRESERVE, do read first.
            //
            if (pwca->fPreserve)
            {
              #ifdef DEBUGGER
                ULONG dwOldFlags = gDebugger.dwfDebugger;

                if (dwOldFlags & DBGF_TRACE_NONEST)
                {
                    gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                }
              #endif
              
                KeAcquireSpinLock(&pop->listLock, &oldIrql);
                if (busy = InterlockedExchange(&pop->RegionBusy, TRUE)) {

                    //
                    // Somebody is currently using this operation region.
                    // Queue this context so that it can be re-started later.
                    //

                    QueueContext(pctxt, 
                                 0xffff,
                                 &pop->plistWaiters);

                }
                KeReleaseSpinLock(&pop->listLock, oldIrql);

                if (busy) {
                    rc = AMLISTA_PENDING;
                    break;
                }

                pwca->FrameHdr.dwfFrame++;
                ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
                rc = pwca->prsa->pfnCookAccess(RSACCESS_READ, pwca->pnsBase,
                                               (ULONG_PTR)pwca->dwAddr,
                                               pwca->dwSize,
                                               &pwca->dwDataTmp,
                                               pwca->prsa->uipCookParam,
                                               RestartCtxtCallback,
                                               &pctxt->CtxtData);
              #ifdef DEBUGGER
                gDebugger.dwfDebugger = dwOldFlags;
              #endif

                if (rc == STATUS_PENDING)
                {
                    rc = AMLISTA_PENDING;
                }
                else if (rc != STATUS_SUCCESS)
                {
                    rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                     ("WriteCookAccess: RegionSpace %x read handler returned error %x",
                                      pop->bRegionSpace, rc));
                }

                if (rc != STATUS_SUCCESS)
                {
                    break;
                }
            }
            else
            {
                //
                // No preserve, we can skip the ORing.
                //
                pwca->FrameHdr.dwfFrame += 2;
                goto Stage2;
            }

        case 1:
            //
            // Stage 1: OR the preserved bits.
            //
            pwca->dwData |= pwca->dwDataTmp & ~pwca->dwDataMask;
            pwca->FrameHdr.dwfFrame++;

        case 2:
        Stage2:
            //
            // Stage 2: Write the data.
            //
          #ifdef DEBUGGER
            {
                ULONG dwOldFlags = gDebugger.dwfDebugger;

                if (dwOldFlags & DBGF_TRACE_NONEST)
                {
                    gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                }
          #endif
            pwca->FrameHdr.dwfFrame++;
            ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
            rc = pwca->prsa->pfnCookAccess(RSACCESS_WRITE, pwca->pnsBase,
                                           (ULONG_PTR)pwca->dwAddr,
                                           pwca->dwSize,
                                           &pwca->dwData,
                                           pwca->prsa->uipCookParam,
                                           RestartCtxtCallback,
                                           &pctxt->CtxtData);
          #ifdef DEBUGGER
                gDebugger.dwfDebugger = dwOldFlags;
            }
          #endif

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                 ("WriteCookAccess: RegionSpace %x read handler returned error %x",
                                  pop->bRegionSpace, rc));
            }

            if (rc != STATUS_SUCCESS)
            {
                break;
            }

        case 3:
            
            if (pwca->fPreserve) {
            
                KeAcquireSpinLock(&pop->listLock, &oldIrql);

                //
                // Restart anybody who blocked while we were in here.
                //

                DequeueAndReadyContext(&pop->plistWaiters);

                //
                // Release the lock on this op-region.
                //

                InterlockedExchange(&pop->RegionBusy, FALSE);

                KeReleaseSpinLock(&pop->listLock, oldIrql);
            }
            
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteCookAccess=%x\n", rc));
    return rc;
}       //WriteCookAccess

/***LP  ReadBuffField - Read data from a buffer field
 *
 *  ENTRY
 *      pbf -> buffer field object
 *      pfd -> field descriptor
 *      pdwData -> to hold result data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, PULONG pdwData)
{
    TRACENAME("READBUFFFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwAccSize = ACCSIZE(pfd->dwFieldFlags);

    ENTER(3, ("ReadBuffField(pbf=%x,pfd=%x,pdwData=%x)\n", pbf, pfd, pdwData));

    if (pfd->dwByteOffset + dwAccSize <= pbf->dwBuffLen)
    {
        ULONG dwMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                       pfd->dwStartBitPos;

        *pdwData = ReadSystemMem((ULONG_PTR)(pbf->pbDataBuff +
                                             pfd->dwByteOffset),
                                 dwAccSize, dwMask);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                         ("ReadBuffField: offset exceeding buffer size (Offset=%x,BuffSize=%x,AccSize)",
                          pfd->dwByteOffset, pbf->dwBuffLen, dwAccSize));
    }

    EXIT(3, ("ReadBuffField=%x (Data=%x)\n", rc, *pdwData));
    return rc;
}       //ReadBuffField

/***LP  WriteBuffField - Write data to a buffer field
 *
 *  ENTRY
 *      pbf -> buffer field object
 *      pfd -> field descriptor
 *      dwData - data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, ULONG dwData)
{
    TRACENAME("WRITEBUFFFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwAccSize = ACCSIZE(pfd->dwFieldFlags);

    ENTER(3, ("WriteBuffField(pbf=%x,pfd=%x,dwData=%x)\n", pbf, pfd, dwData));

    if (pfd->dwByteOffset + dwAccSize <= pbf->dwBuffLen)
    {
        ULONG dwMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                       pfd->dwStartBitPos;

        WriteSystemMem((ULONG_PTR)(pbf->pbDataBuff + pfd->dwByteOffset),
                       dwAccSize, dwData & dwMask, dwMask);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                         ("WriteBuffField: offset exceeding buffer size (Offset=%x,BuffSize=%x,AccSize=%x)",
                          pfd->dwByteOffset, pbf->dwBuffLen, dwAccSize));
    }

    EXIT(3, ("WriteBuffField=%x\n", rc));
    return rc;
}       //WriteBuffField


/***LP  ReadSystemMem - Read system memory
 *
 *  ENTRY
 *      uipAddr - memory address
 *      dwSize - size to read
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

ULONG LOCAL ReadSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwMask)
{
    TRACENAME("READSYSTEMMEM")
    ULONG dwData = 0;

    ENTER(3, ("ReadSystemMem(Addr=%x,Size=%d,Mask=%x)\n",
              uipAddr, dwSize, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    MEMCPY(&dwData, (PVOID)uipAddr, dwSize);
    
    dwData &= dwMask;

    EXIT(3, ("ReadSystemMem=%x\n", dwData));
    return dwData;
}       //ReadSystemMem

/***LP  WriteSystemMem - Write system memory
 *
 *  ENTRY
 *      uipAddr - memory address
 *      dwSize - size to write
 *      dwData - data to write
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

VOID LOCAL WriteSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwData,
                          ULONG dwMask)
{
    TRACENAME("WRITESYSTEMMEM")
    ULONG dwTmpData = 0;

    ENTER(3, ("WriteSystemMem(Addr=%x,Size=%d,Data=%x,Mask=%x)\n",
              uipAddr, dwSize, dwData, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    MEMCPY(&dwTmpData, (PVOID)uipAddr, dwSize);
        dwTmpData &= ~dwMask;
        dwTmpData |= dwData;
        MEMCPY((PVOID)uipAddr, &dwTmpData, dwSize);

    EXIT(3, ("WriteSystemMem!\n"));
}       //WriteSystemMem



/***LP  ReadSystemIO - Read system IO
 *
 *  ENTRY
 *      dwAddr - memory address
 *      dwSize - size to read
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

ULONG LOCAL ReadSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwMask)
{
    TRACENAME("READSYSTEMIO")
    ULONG dwData = 0;

    ENTER(3, ("ReadSystemIO(Addr=%x,Size=%d,Mask=%x)\n",
              dwAddr, dwSize, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    if(CheckSystemIOAddressValidity(TRUE, dwAddr, dwSize, &dwData))
    {

        //
        // HACKHACK: We are adding this here because Dell Latitude laptops with Older
        //           BIOS (A07 and older) hang in SMI because there is a non zero value\
        //           in CH. We now clear CX to work around their bug.
        //
        #ifdef _X86_
        __asm
            {
                xor cx,cx
            }
        #endif //_X86_

        switch (dwSize)
        {
            case sizeof(UCHAR):
                dwData = (ULONG)READ_PORT_UCHAR((PUCHAR)UlongToPtr(dwAddr));
                break;

            case sizeof(USHORT):
                dwData = (ULONG)READ_PORT_USHORT((PUSHORT)UlongToPtr(dwAddr));
                break;

            case sizeof(ULONG):
                dwData = READ_PORT_ULONG((PULONG)UlongToPtr(dwAddr));
                break;
        }
    }
    
    dwData &= dwMask;

    EXIT(3, ("ReadSystemIO=%x\n", dwData));
    return dwData;
}       //ReadSystemIO

/***LP  WriteSystemIO - Write system IO
 *
 *  ENTRY
 *      dwAddr - memory address
 *      dwSize - size to write
 *      dwData - data to write
 *
 *  EXIT
 *      return memory content
 */

VOID LOCAL WriteSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwData)
{
    TRACENAME("WRITESYSTEMIO")
    
    ENTER(3, ("WriteSystemIO(Addr=%x,Size=%d,Data=%x)\n",
              dwAddr, dwSize, dwData));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    if(CheckSystemIOAddressValidity(FALSE, dwAddr, dwSize, &dwData))
    {
        //
        // HACKHACK: We are adding this here because Dell Latitude laptops with Older
        //           BIOS (A07 and older) hang in SMI because there is a non zero value\
        //           in CH. We now clear CX to work around their bug.
        //
        #ifdef _X86_
        __asm
            {
                xor cx,cx
            }
        #endif //_X86_
        
        switch (dwSize)
        {
            case sizeof(UCHAR):
                WRITE_PORT_UCHAR((PUCHAR)UlongToPtr(dwAddr), (UCHAR)dwData);
                break;

            case sizeof(USHORT):
                WRITE_PORT_USHORT((PUSHORT)UlongToPtr(dwAddr), (USHORT)dwData);
                break;

            case sizeof(ULONG):
                WRITE_PORT_ULONG((PULONG)UlongToPtr(dwAddr), dwData);
                break;
        }
    }
    
    EXIT(3, ("WriteSystemIO!\n"));
}       //WriteSystemIO

#ifdef DEBUGGER
/***LP  DumpObject - Dump object info.
 *
 *  ENTRY
 *      pdata -> data
 *      pszName -> object name
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      If iLevel is negative, no indentation and newline are printed.
 */

VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel)
{
    TRACENAME("DUMPOBJECT")
    BOOLEAN fPrintNewLine;
    int i;
    char szName1[sizeof(NAMESEG) + 1],
         szName2[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpObject(pdata=%x,Name=%s,Level=%d)\n",
              pdata, pszName, iLevel));

    fPrintNewLine = (BOOLEAN)(iLevel >= 0);

    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }

    if (pszName == NULL)
    {
        pszName = "";
    }

    switch (pdata->dwDataType)
    {
        case OBJTYPE_UNKNOWN:
            PRINTF("Unknown(%s)", pszName);
            break;

        case OBJTYPE_INTDATA:
            PRINTF("Integer(%s:Value=0x%08x[%d])",
                   pszName, pdata->uipDataValue, pdata->uipDataValue);
            break;

        case OBJTYPE_STRDATA:
            PRINTF("String(%s:Str=\"%s\")", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            PRINTF("Buffer(%s:Ptr=%x,Len=%d)",
                   pszName, pdata->pbDataBuff, pdata->dwDataLen);
            PrintBuffData(pdata->pbDataBuff, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            PRINTF("Package(%s:NumElements=%d){",
                   pszName, ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements);

            if (fPrintNewLine)
            {
                PRINTF("\n");
            }

            for (i = 0;
                 i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                 ++i)
            {
                DumpObject(&((PPACKAGEOBJ)pdata->pbDataBuff)->adata[i], NULL,
               fPrintNewLine? iLevel + 1: -1);

                if (!fPrintNewLine &&
                    (i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements))
                {
                    PRINTF(",");
                }
            }

            for (i = 0; i < iLevel; ++i)
            {
                PRINTF("| ");
            }

        PRINTF("}");
            break;

        case OBJTYPE_FIELDUNIT:
            PRINTF("FieldUnit(%s:FieldParent=%p,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->pnsFieldParent,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwByteOffset,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwStartBitPos,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwNumBits,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwFieldFlags);
            break;

        case OBJTYPE_DEVICE:
            PRINTF("Device(%s)", pszName);
            break;

        case OBJTYPE_EVENT:
            PRINTF("Event(%s:pKEvent=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_METHOD:
            PRINTF("Method(%s:Flags=0x%x,CodeBuff=%p,Len=%d)",
                   pszName, ((PMETHODOBJ)pdata->pbDataBuff)->bMethodFlags,
                   ((PMETHODOBJ)pdata->pbDataBuff)->abCodeBuff,
                   pdata->dwDataLen - FIELD_OFFSET(METHODOBJ, abCodeBuff));
            break;

        case OBJTYPE_MUTEX:
            PRINTF("Mutex(%s:pKMutex=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OPREGION:
            PRINTF("OpRegion(%s:RegionSpace=%s,Offset=0x%x,Len=%d)",
                   pszName,
                   GetRegionSpaceName(((POPREGIONOBJ)pdata->pbDataBuff)->bRegionSpace),
                   ((POPREGIONOBJ)pdata->pbDataBuff)->uipOffset,
                   ((POPREGIONOBJ)pdata->pbDataBuff)->dwLen);
            break;

        case OBJTYPE_POWERRES:
            PRINTF("PowerResource(%s:SystemLevel=0x%x,ResOrder=%d)",
                   pszName, ((PPOWERRESOBJ)pdata->pbDataBuff)->bSystemLevel,
                   ((PPOWERRESOBJ)pdata->pbDataBuff)->bResOrder);
            break;

        case OBJTYPE_PROCESSOR:
            PRINTF("Processor(%s:ApicID=0x%x,PBlk=0x%x,PBlkLen=%d)",
                   pszName, ((PPROCESSOROBJ)pdata->pbDataBuff)->bApicID,
                   ((PPROCESSOROBJ)pdata->pbDataBuff)->dwPBlk,
                   ((PPROCESSOROBJ)pdata->pbDataBuff)->dwPBlkLen);
            break;

        case OBJTYPE_THERMALZONE:
            PRINTF("ThermalZone(%s)", pszName);
            break;

        case OBJTYPE_BUFFFIELD:
            PRINTF("BufferField(%s:Ptr=%x,Len=%d,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName, ((PBUFFFIELDOBJ)pdata->pbDataBuff)->pbDataBuff,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->dwBuffLen,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwByteOffset,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwStartBitPos,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwNumBits,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwFieldFlags);
            break;

        case OBJTYPE_DDBHANDLE:
            PRINTF("DDBHandle(%s:Handle=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OBJALIAS:
            PRINTF("ObjectAlias(%s:Alias=%s,Type=%s)",
                   pszName, GetObjectPath(pdata->pnsAlias),
                   GetObjectTypeName(pdata->pnsAlias->ObjData.dwDataType));
            break;

        case OBJTYPE_DATAALIAS:
            PRINTF("DataAlias(%s:Link=%x)", pszName, pdata->pdataAlias);
            if (fPrintNewLine)
            {
                DumpObject(pdata->pdataAlias, NULL, iLevel + 1);
        fPrintNewLine = FALSE;
            }
            break;

        case OBJTYPE_BANKFIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PBANKFIELDOBJ)pdata->pbDataBuff)->pnsBase->dwNameSeg),
                    sizeof(NAMESEG));
            STRCPYN(szName2,
                    (PSZ)(&((PBANKFIELDOBJ)pdata->pbDataBuff)->pnsBank->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("BankField(%s:Base=%s,BankName=%s,BankValue=0x%x)",
                   pszName, szName1, szName2,
                   ((PBANKFIELDOBJ)pdata->pbDataBuff)->dwBankValue);
            break;

        case OBJTYPE_FIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PFIELDOBJ)pdata->pbDataBuff)->pnsBase->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("Field(%s:Base=%s)", pszName, szName1);
            break;

        case OBJTYPE_INDEXFIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PINDEXFIELDOBJ)pdata->pbDataBuff)->pnsIndex->dwNameSeg),
                    sizeof(NAMESEG));
            STRCPYN(szName2,
                    (PSZ)(&((PINDEXFIELDOBJ)pdata->pbDataBuff)->pnsData->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("IndexField(%s:IndexName=%s,DataName=%s)",
                   pszName, szName1, szName2);
            break;

        default:
            AMLI_ERROR(("DumpObject: unexpected data object type (type=%x)",
                        pdata->dwDataType));
    }

    if (fPrintNewLine)
    {
        PRINTF("\n");
    }

    EXIT(3, ("DumpObject!\n"));
}       //DumpObject
#endif

/***LP  NeedGlobalLock - check if global lock is required
 *
 *  ENTRY
 *      pfu - FIELDUNITOBJ
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL NeedGlobalLock(PFIELDUNITOBJ pfu)
{
    TRACENAME("NEEDGLOBALLOCK")
    BOOLEAN rc = FALSE;

    ENTER(3, ("NeedGlobalLock(pfu=%x)\n", pfu));

    if ((pfu->FieldDesc.dwFieldFlags & FDF_NEEDLOCK) ||
        (pfu->FieldDesc.dwFieldFlags & LOCKRULE_LOCK))
    {
        rc = TRUE;
    }
    else
    {
        POBJDATA pdataParent = &pfu->pnsFieldParent->ObjData;
        PFIELDUNITOBJ pfuParent;

        if (pdataParent->dwDataType == OBJTYPE_BANKFIELD)
        {
            pfuParent = (PFIELDUNITOBJ)
                ((PBANKFIELDOBJ)pdataParent->pbDataBuff)->pnsBank->ObjData.pbDataBuff;
            if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
            {
                rc = TRUE;
            }
        }
        else if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
        {
            pfuParent = (PFIELDUNITOBJ)
                ((PINDEXFIELDOBJ)pdataParent->pbDataBuff)->pnsIndex->ObjData.pbDataBuff;
            if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
            {
                rc = TRUE;
            }
            else
            {
                pfuParent = (PFIELDUNITOBJ)
                    ((PINDEXFIELDOBJ)pdataParent->pbDataBuff)->pnsData->ObjData.pbDataBuff;
                if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
                {
                    rc = TRUE;
                }
            }
        }
    }

    if (rc == TRUE)
    {
        pfu->FieldDesc.dwFieldFlags |= FDF_NEEDLOCK;
    }

    EXIT(3, ("NeedGlobalLock=%x\n", rc));
    return rc;
}       //NeedGlobalLock

/***LP  CheckSystemIOAddressValidity - Check if the address is a legal IO address
 *
 *  ENTRY
 *      fRead  - TRUE iff access is a read. FALSE on write
 *      dwAddr - memory address
 *      ULONG   dwSize  - Size of data
 *      PULONG  pdwData - Pointer to the data buffer.
 *
 *  EXIT
 *      return TRUE on Valid address
 */

BOOLEAN LOCAL CheckSystemIOAddressValidity( BOOLEAN fRead, 
                                                     ULONG   dwAddr, 
                                                     ULONG   dwSize, 
                                                     PULONG  pdwData
                                                   )
{
    TRACENAME("CHECKSYSTEMIOADDRESSVALIDITY")
    ULONG i = 0;
    BOOLEAN bRet = TRUE;
    
    ENTER(3, ("CheckSystemIOAddressValidity(fRead=%s, dwAddr=%x, dwSize=%x, pdwData=%x)\n", (fRead?"TRUE":"FALSE"),dwAddr, dwSize, pdwData));

    //
    // check if list exists on this platform.
    //
    if(gpBadIOAddressList)
    {
        //
        // Walk the list till we hit the end.
        //
        for(i=0; gpBadIOAddressList[i].BadAddrSize != 0 ; i++)
        {
            //
            // Check if the incoming address is in the range
            //
            if((dwAddr >= (gpBadIOAddressList[i].BadAddrBegin)) && (dwAddr < ((gpBadIOAddressList[i].BadAddrBegin) + (gpBadIOAddressList[i].BadAddrSize))))
            {
            
                //
                // Check if we need to ignore this address for legacy reasons.
                //
                if(gpBadIOAddressList[i].OSVersionTrigger <= gdwHighestOSVerQueried)
                {
                    bRet = FALSE;
                    PRINTF("CheckSystemIOAddressValidity: failing illegal IO address (0x%x).\n", dwAddr); 
                }
                else
                {
                    PRINTF("CheckSystemIOAddressValidity: Passing for compatibility reasons on illegal IO address (0x%x).\n", dwAddr);                

                    if(gpBadIOAddressList[i].IOHandler)
                    {
                        //
                        // Since we are handeling this here we can return FALSE. This way the
                        // calling function will not process this request.
                        //
                        bRet = FALSE;

                        //
                        // Call HAL and let it handle this IO request
                        //
                        (gpBadIOAddressList[i].IOHandler)(fRead, dwAddr, dwSize, pdwData);

                        PRINTF("CheckSystemIOAddressValidity: HAL IO handler called to %s address (0x%x). %s 0x%8lx\n", 
                                fRead ? "read" : "write",
                                dwAddr,
                                fRead ? "Read" : "Wrote",
                                *pdwData
                              );                
                    }
                }

                //
                // Log the illegal access to the event log.
                //
                if (KeGetCurrentIrql() < DISPATCH_LEVEL)
                {
                
                    LogInErrorLog(fRead,
                                    dwAddr, 
                                    i
                                   );
                }
                else
                {
                    PIO_WORKITEM	Log_WorkItem = NULL;
                    PDEVICE_OBJECT	pACPIDeviceObject = ACPIGetRootDeviceObject();

                    if(pACPIDeviceObject)
                    {
                        Log_WorkItem = IoAllocateWorkItem(pACPIDeviceObject);

                        if(Log_WorkItem)
                        {
                            PAMLI_LOG_WORKITEM_CONTEXT pWorkItemContext = NULL;

                            
                            pWorkItemContext = (PAMLI_LOG_WORKITEM_CONTEXT) ExAllocatePoolWithTag(NonPagedPool,  
                                                                                                                                                        sizeof(AMLI_LOG_WORKITEM_CONTEXT),
                                                                                                                                                        PRIV_TAG
                                                                                            );
                            if(pWorkItemContext)
                            {
                                pWorkItemContext->fRead = fRead;
                                pWorkItemContext->Address = dwAddr;
                                pWorkItemContext->Index = i;
                                pWorkItemContext->pIOWorkItem = Log_WorkItem;
                                
                                IoQueueWorkItem(
                                                  Log_WorkItem,
                                                  DelayedLogInErrorLog,
                                                  DelayedWorkQueue,
                                                  (VOID*)pWorkItemContext
                                                 );
                            }
                            else
                            {
                                //
                                // not enough free pool exists to satisfy the request.
                                //
                                PRINTF("CheckSystemIOAddressValidity: Failed to allocate contxt block from pool to spin off a logging work item.\n");                
                                IoFreeWorkItem(Log_WorkItem);
                            }
                        }
                        else
                        {
                            //
                            // insufficient resources
                            //
                            PRINTF("CheckSystemIOAddressValidity: Failed to allocate a workitem to spin off delayed logging.\n");                

                        }
                    }
                    else
                    {
                        //
                        // Failed to get ACPI root DeviceObject
                        //
                        PRINTF("CheckSystemIOAddressValidity: Failed to get ACPI root DeviceObject.\n");                
                    }
                }
                break;
            }        
        }
    }

    EXIT(3, ("CheckSystemIOAddressValidity!\n"));
           
    return bRet;
}

/***LP  DelayedLogInErrorLog - Call LogInErrorLog
 *
 *  ENTRY
 *      PDEVICE_OBJECT DeviceObject - Device Object.
 *      PVOID Context - Context pointer with data to call LogInErrorLog with.
 *
 *  EXIT
 *      VOID
 */
VOID DelayedLogInErrorLog(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PVOID Context
                                )
{
    
    LogInErrorLog(((PAMLI_LOG_WORKITEM_CONTEXT)Context)->fRead,
                    ((PAMLI_LOG_WORKITEM_CONTEXT)Context)->Address,
                    ((PAMLI_LOG_WORKITEM_CONTEXT)Context)->Index
                   );


    IoFreeWorkItem((PIO_WORKITEM)((PAMLI_LOG_WORKITEM_CONTEXT)Context)->pIOWorkItem);
    ExFreePool(Context);
}


/***LP  LogInErrorLog - Log illegal IO access to event log
 *
 *  ENTRY
 *      fRead  -        TRUE iff access is a read. FALSE on write
 *      dwAddr -        Memory address
 *      ArrayIndex -    Index into BadIOAddressList array. 
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL LogInErrorLog(BOOLEAN fRead, ULONG dwAddr, ULONG ArrayIndex)
{
    TRACENAME("LOGERROR")
    PWCHAR illegalIOPortAddress[3];
    WCHAR AMLIName[6];
    WCHAR addressBuffer[13];
    WCHAR addressRangeBuffer[16];

    ENTER(3, ("LogInErrorLog(fRead=%s, Addr=%x, ArrayIndex=%x)\n", (fRead?"TRUE":"FALSE"),dwAddr, ArrayIndex));

    //
    // Check to see if we need to log this address.
    //
    if(gpBadIOErrorLogDoneList)
    {
        //
        // Check to see if we need to log this address.
        //
        if (!(gpBadIOErrorLogDoneList[ArrayIndex] & (fRead?READ_ERROR_NOTED:WRITE_ERROR_NOTED)))
        {
            gpBadIOErrorLogDoneList[ArrayIndex] |= (fRead?READ_ERROR_NOTED:WRITE_ERROR_NOTED);

            //
            // Turn the address into a string
            //
            swprintf( AMLIName, L"AMLI");
            swprintf( addressBuffer, L"0x%x", dwAddr );
            swprintf( addressRangeBuffer, L"0x%x - 0x%x", 
                      gpBadIOAddressList[ArrayIndex].BadAddrBegin,
                      (gpBadIOAddressList[ArrayIndex].BadAddrBegin + (gpBadIOAddressList[ArrayIndex].BadAddrSize - 1)));
                        
            //
            // Build the list of arguments to pass to the function that will write the
            // error log to the registry
            //
            illegalIOPortAddress[0] = AMLIName;
            illegalIOPortAddress[1] = addressBuffer;
            illegalIOPortAddress[2] = addressRangeBuffer;

            //
            // Log error to event log
            //
            ACPIWriteEventLogEntry((fRead ? ACPI_ERR_AMLI_ILLEGAL_IO_READ_FATAL : ACPI_ERR_AMLI_ILLEGAL_IO_WRITE_FATAL),
                               &illegalIOPortAddress,
                               3,
                               NULL,
                               0);        

        }
    }
    
    EXIT(3, ("LogInErrorLog!\n"));

    return;
}

/***LP  InitIllegalIOAddressListFromHAL - Initialize the Illegal IO 
 *                                        address List from the HAL.
 *
 *  ENTRY
 *      None.
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL InitIllegalIOAddressListFromHAL(VOID)
{
    TRACENAME("InitIllegalIOAddressListFromHAL")
    ULONG       Length = 0;
    NTSTATUS    status;

    ENTER(3, ("InitIllegalIOAddressListFromHAL\n"));
    
    if(!gpBadIOAddressList)
    {
        //
        // Query HAL to get the amount of memory to allocate
        //
        status = HalQuerySystemInformation (
                                    HalQueryAMLIIllegalIOPortAddresses,
                                    0,
                                    NULL,
                                    &Length
                                           );

        if(status == STATUS_INFO_LENGTH_MISMATCH)
        {
            if(Length)
            {
                //
                // Allocate memory.
                //
                if ((gpBadIOAddressList = (PHAL_AMLI_BAD_IO_ADDRESS_LIST) MALLOC(Length, PRIV_TAG)) == NULL)
                {
                    AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                ("InitIllegalIOAddressListFromHAL: failed to allocate Bad IO address list."));
                }
                else
                {
                    //
                    // Get bad IO address list from HAL.
                    //
                    status = HalQuerySystemInformation(
                                                HalQueryAMLIIllegalIOPortAddresses,
                                                Length,
                                                gpBadIOAddressList,
                                                &Length
                                                       );
                    //
                    // Cleanup on failure.
                    //
                    if(status != STATUS_SUCCESS)
                    {
                        PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation failed to get list from HAL. Returned(%x).\n", status);             
                        FreellegalIOAddressList();
                    }
                    
                    // Allocate the errorlogdone list. this helps us track if we have logged
                    // a certain address.
                    //
                    else
                    {
                        //
                        // Calculate array length
                        //
                        ULONG ArrayLength = (Length / sizeof(HAL_AMLI_BAD_IO_ADDRESS_LIST)) - 1;

                        if(ArrayLength >= 1)
                        {
                            if ((gpBadIOErrorLogDoneList = (PULONG) MALLOC((ArrayLength * sizeof(ULONG)), PRIV_TAG)) == NULL)
                            {
                                AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                            ("InitIllegalIOAddressListFromHAL: failed to allocate ErrorLogDone list."));
                            }
                            else
                            {
                                RtlZeroMemory(gpBadIOErrorLogDoneList, (ArrayLength * sizeof(ULONG)));

                            }
                        }
                    }
                    
                }

            }
            else
            {
                PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation (HalQueryIllegalIOPortAddresses) returned 0 Length.\n"); 
            }
        }
        else if(status == STATUS_INVALID_LEVEL)
        {
            PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation does not support HalQueryIllegalIOPortAddresses returned (STATUS_INVALID_LEVEL).\n"); 
        }
        else
        {
            PRINTF("InitIllegalIOAddressListFromHAL: failed. Returned(0x%08lx).\n", status); 
        }
    }

    EXIT(3, ("InitIllegalIOAddressListFromHAL!\n"));
    return;
}

/***LP  FreellegalIOAddressList - Free the Illegal IO 
 *                                address List.
 *
 *  ENTRY
 *      None.
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL FreellegalIOAddressList(VOID)
{
    TRACENAME("FreellegalIOAddressList")
    ENTER(3, ("FreellegalIOAddressList\n"));
    
    if(gpBadIOAddressList)
    {
        MFREE(gpBadIOAddressList);
        gpBadIOAddressList = NULL;
    }

    if(gpBadIOErrorLogDoneList)
    {
        MFREE(gpBadIOErrorLogDoneList);
        gpBadIOErrorLogDoneList = NULL;
    }
    
    EXIT(3, ("FreellegalIOAddressList!\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\namedobj.c ===
/*** namedobj.c - Parse named object instructions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/10/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  BankField - Parse and execute the BankField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL BankField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BANKFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsBase, pnsBank;

    ENTER(2, ("BankField(pctxt=%x,pterm=%x,pbOp=%x)\n",
              pctxt, pterm, pctxt->pbOp));

    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsBase, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[1].pbDataBuff,
                                  pctxt->pnsScope, &pnsBank, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS))
    {
        if (pnsBase->ObjData.dwDataType != OBJTYPE_OPREGION)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("BankField: %s is not an operation region",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if (pnsBank->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("BankField: %s is not a field unit",
                              pterm->pdataArgs[1].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_BANKFIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(BANKFIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWKFOBJ(pctxt->pheapCurrent,
                          pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("BankField: failed to allocate BankField object"));
            }
            else
            {
                PBANKFIELDOBJ pbf;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pbf = (PBANKFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pbf->pnsBase = pnsBase;
                pbf->pnsBank = pnsBank;
                pbf->dwBankValue = (ULONG)pterm->pdataArgs[2].uipDataValue;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[3].uipDataValue,
                                    ((POPREGIONOBJ)pnsBase->ObjData.pbDataBuff)->dwLen);
            }
        }
    }

    EXIT(2, ("BankField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //BankField

/***LP  CreateXField - Parse and execute the CreateXField instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *      pdataTarget -> Target object data
 *      ppbf -> to hold created target BuffField object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateXField(PCTXT pctxt, PTERM pterm, POBJDATA pdataTarget,
                            PBUFFFIELDOBJ *ppbf)
{
    TRACENAME("CREATEXFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata = NULL;

    ENTER(2, ("CreateXField(pctxt=%x,pbOp=%x,pterm=%x,pdataTarget=%x,ppbf=%x)\n",
              pctxt, pctxt->pbOp, pterm, pdataTarget, ppbf));

    ASSERT(pdataTarget != NULL);
    ASSERT(pdataTarget->dwDataType == OBJTYPE_STRDATA);
    if (((rc = ValidateArgTypes(pterm->pdataArgs, "BI")) == STATUS_SUCCESS) &&
        ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                     (PSZ)pdataTarget->pbDataBuff,
                                     pctxt->pnsScope, pctxt->powner,
                                     &pterm->pnsObj, 0)) == STATUS_SUCCESS))
    {
        pdata = &pterm->pnsObj->ObjData;
        pdata->dwDataType = OBJTYPE_BUFFFIELD;
        pdata->dwDataLen = sizeof(BUFFFIELDOBJ);
        if ((pdata->pbDataBuff = NEWBFOBJ(pctxt->pheapCurrent,
                                          pdata->dwDataLen)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("CreateXField: failed to allocate BuffField object"));
        }
        else
        {
            MEMZERO(pdata->pbDataBuff, pdata->dwDataLen);
            *ppbf = (PBUFFFIELDOBJ)pdata->pbDataBuff;
            (*ppbf)->pbDataBuff = pterm->pdataArgs[0].pbDataBuff;
            (*ppbf)->dwBuffLen = pterm->pdataArgs[0].dwDataLen;
        }
    }

    EXIT(2, ("CreateXField=%x (pdata=%x)\n", rc, pdata));
    return rc;
}       //CreateXField

/***LP  CreateBitField - Parse and execute the CreateBitField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateBitField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEBITFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateBitField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)
                                      (pterm->pdataArgs[1].uipDataValue/8);
        pbf->FieldDesc.dwStartBitPos = (ULONG)
                                       (pterm->pdataArgs[1].uipDataValue -
                                        pbf->FieldDesc.dwByteOffset*8);
        pbf->FieldDesc.dwNumBits = 1;
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE;
    }

    EXIT(2, ("CreateBitField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateBitField

/***LP  CreateByteField - Parse and execute the CreateByteField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateByteField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEBYTEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateByteField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(UCHAR);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE;
    }

    EXIT(2, ("CreateByteField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateByteField

/***LP  CreateWordField - Parse and execute the CreateWordField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateWordField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEWORDFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateWordField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(USHORT);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_WORD;
    }

    EXIT(2, ("CreateWordField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateWordField

/***LP  CreateDWordField - Parse and execute the CreateDWordField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateDWordField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEDWORDFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateDWordField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(ULONG);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_DWORD;
    }

    EXIT(2, ("CreateDWordField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateDWordField

/***LP  CreateField - Parse and execute the CreateField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (pterm->pdataArgs[2].dwDataType == OBJTYPE_INTDATA)
    {
        if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[3], &pbf)) ==
            STATUS_SUCCESS)
        {
            pbf->FieldDesc.dwByteOffset = (ULONG)
                                          (pterm->pdataArgs[1].uipDataValue/8);
            pbf->FieldDesc.dwStartBitPos = (ULONG)
                                           (pterm->pdataArgs[1].uipDataValue -
                                            pbf->FieldDesc.dwByteOffset*8);
            pbf->FieldDesc.dwNumBits = (ULONG)pterm->pdataArgs[2].uipDataValue;
            pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE | FDF_BUFFER_TYPE;
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                         ("CreateField: NoBits must be evaluated to integer type"));
    }

    EXIT(2, ("CreateField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateField

/***LP  Device - Parse and execute the Scope instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Device(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DEVICE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Device(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_DEVICE;
        if (ghCreate.pfnHandler != NULL)
        {
            ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_DEVICE, pterm->pnsObj);
        }
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("Device=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Device

/***LP  InitEvent - Initialize an event object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pns -> event object to be initialized
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL InitEvent(PHEAP pheap, PNSOBJ pns)
{
    TRACENAME("INITEVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InitEvent(pheap=%x,pns=%x)\n", pheap, pns));

    pns->ObjData.dwDataType = OBJTYPE_EVENT;
    pns->ObjData.dwDataLen = sizeof(EVENTOBJ);

    if ((pns->ObjData.pbDataBuff = NEWEVOBJ(pheap, pns->ObjData.dwDataLen)) ==
        NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("InitEvent: failed to allocate Event object"));
    }
    else
    {
        MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
    }

    EXIT(2, ("InitEvent=%x\n", rc));
    return rc;
}       //InitEvent

/***LP  Event - Parse and execute the Event instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Event(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Event(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        rc = InitEvent(pctxt->pheapCurrent, pterm->pnsObj);
    }

    EXIT(2, ("Event=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Event

/***LP  Field - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Field(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("FIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsBase;

    ENTER(2, ("Field(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                 pctxt->pnsScope, &pnsBase, NSF_WARN_NOTFOUND))
        == STATUS_SUCCESS)
    {
        if (pnsBase->ObjData.dwDataType != OBJTYPE_OPREGION)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Field: %s is not an operation region",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_FIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(FIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWFOBJ(pctxt->pheapCurrent,
                         pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("Field: failed to allocate Field object"));
            }
            else
            {
                PFIELDOBJ pfd;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pfd = (PFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pfd->pnsBase = pnsBase;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[1].uipDataValue,
                                    ((POPREGIONOBJ)pnsBase->ObjData.pbDataBuff)->dwLen);
            }
        }
    }

    EXIT(2, ("Field=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Field

/***LP  IndexField - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IndexField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INDEXFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsIdx, pnsData;

    ENTER(2, ("IndexField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsIdx, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[1].pbDataBuff,
                                  pctxt->pnsScope, &pnsData, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS))
    {
        if (pnsIdx->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("IndexField: Index (%s) is not a field unit",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if (pnsData->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("IndexField: Data (%s) is not a field unit",
                              pterm->pdataArgs[1].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_INDEXFIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(INDEXFIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWIFOBJ(pctxt->pheapCurrent,
                          pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("IndexField: failed to allocate IndexField object"));
            }
            else
            {
                PINDEXFIELDOBJ pif;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pif = (PINDEXFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pif->pnsIndex = pnsIdx;
                pif->pnsData = pnsData;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[2].uipDataValue,
                                    0xffffffff);
            }
        }
    }

    EXIT(2, ("IndexField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //IndexField

/***LP  Method - Parse and execute the Method instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Method(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("METHOD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Method(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_METHOD;
        pterm->pnsObj->ObjData.dwDataLen = (ULONG)(FIELD_OFFSET(METHODOBJ,
                                                                abCodeBuff) +
                                                   pterm->pbOpEnd -
                                                   pctxt->pbOp);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWMEOBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Method: failed to allocate method buffer"));
        }
        else
        {
            PMETHODOBJ pm = (PMETHODOBJ)pterm->pnsObj->ObjData.pbDataBuff;

          #ifdef DEBUGGER
            AddObjSymbol(pm->abCodeBuff, pterm->pnsObj);
          #endif
            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pm->bMethodFlags = *(pctxt->pbOp - 1);
            MEMCPY(&pm->abCodeBuff, pctxt->pbOp, pterm->pbOpEnd - pctxt->pbOp);
            pctxt->pbOp = pterm->pbOpEnd;
        }
    }

    EXIT(2, ("Method=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Method

/***LP  InitMutex - Initialize a mutex object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pns -> mutex object to be initialized
 *      dwLevel - sync level
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL InitMutex(PHEAP pheap, PNSOBJ pns, ULONG dwLevel)
{
    TRACENAME("INITMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InitMutex(pheap=%x,pns=%x,Level=%x)\n", pheap, pns, dwLevel));

    pns->ObjData.dwDataType = OBJTYPE_MUTEX;
    pns->ObjData.dwDataLen = sizeof(MUTEXOBJ);

    if ((pns->ObjData.pbDataBuff = NEWMTOBJ(pheap, pns->ObjData.dwDataLen)) ==
        NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("InitMutex: failed to allocate Mutex object"));
    }
    else
    {
        MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
        ((PMUTEXOBJ)pns->ObjData.pbDataBuff)->dwSyncLevel = dwLevel;
    }

    EXIT(2, ("InitMutex=%x\n", rc));
    return rc;
}       //InitMutex

/***LP  Mutex - Parse and execute the Mutex instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Mutex(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("MUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Mutex(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        rc = InitMutex(pctxt->pheapCurrent, pterm->pnsObj,
                       (ULONG)pterm->pdataArgs[1].uipDataValue);
    }

    EXIT(2, ("Mutex=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Mutex

/***LP  OpRegion - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL OpRegion(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("OPREGION")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("OpRegion(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));
    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_OPREGION;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(OPREGIONOBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWOROBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("OpRegion: failed to allocate OpRegion object"));
        }
        else
        {
            POPREGIONOBJ pop;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pop = (POPREGIONOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pop->bRegionSpace = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            pop->uipOffset = pterm->pdataArgs[2].uipDataValue;
            pop->dwLen = (ULONG)pterm->pdataArgs[3].uipDataValue;
            KeInitializeSpinLock(&pop->listLock);
            if (pop->bRegionSpace == REGSPACE_MEM)
            {
                if(gInitTime)
                {
                    ValidateMemoryOpregionRange(pop->uipOffset, pop->dwLen);
                }

                rc = MapUnmapPhysMem(pctxt, pop->uipOffset, pop->dwLen,
                                     &pop->uipOffset);
            }
            else if (pop->bRegionSpace == REGSPACE_IO)
            {
                PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
                ULONG dwAddrSpace;

                phyaddr.LowPart = (ULONG)pop->uipOffset;
                dwAddrSpace = 1;
                if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace,
                                           &XlatedAddr))
                {
                    pop->uipOffset = (ULONG_PTR)XlatedAddr.LowPart;
                }
                else
                {
                    rc = AMLI_LOGERR(AMLIERR_FAILED_ADDR_XLATE,
                                     ("OpRegion: failed to translate IO address %x",
                                      pop->uipOffset));
                }

            }
            else if (pop->bRegionSpace == REGSPACE_PCIBARTARGET)
            {
                if (ghCreate.pfnHandler != NULL)
                {
                    ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_OPREGION, pterm->pnsObj);
                }
            }
        }
    }
    EXIT(2, ("OpRegion=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //OpRegion

/***LP  PowerRes - Parse and execute the PowerRes instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PowerRes(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("POWERRES")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("PowerRes(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_POWERRES;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(POWERRESOBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWPROBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("PowerRes: failed to allocate PowerRes object"));
        }
        else
        {
            PPOWERRESOBJ ppr;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            ppr = (PPOWERRESOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            ppr->bSystemLevel = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            ppr->bResOrder = (UCHAR)pterm->pdataArgs[2].uipDataValue;
            if (ghCreate.pfnHandler != NULL)
            {
                ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_POWERRES, pterm->pnsObj);
            }
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                           pterm->pnsObj, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("PowerRes=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //PowerRes

/***LP  Processor - Parse and execute the Processor instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Processor(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("PROCESSOR")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Processor(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {

        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_PROCESSOR;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(PROCESSOROBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWPCOBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Processor: failed to allocate processor object"));
        }
        else
        {
            PPROCESSOROBJ pproc;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pproc = (PPROCESSOROBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pproc->bApicID = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            pproc->dwPBlk = (ULONG)pterm->pdataArgs[2].uipDataValue;
            pproc->dwPBlkLen = (ULONG)pterm->pdataArgs[3].uipDataValue;
            if (ghCreate.pfnHandler != NULL)
            {
                ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_PROCESSOR, pterm->pnsObj);
            }
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                           pterm->pnsObj, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("Processor=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Processor

/***LP  ThermalZone - Parse and execute the ThermalZone instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ThermalZone(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ThermalZone")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ThermalZone(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_THERMALZONE;
        if (ghCreate.pfnHandler != NULL)
        {
            ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_THERMALZONE, pterm->pnsObj);
        }
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("ThermalZone=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //ThermalZone
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\pch.h ===
#pragma warning (disable: 4201 4206 4214 4220 4115 4514)
#define SPEC_VER 99

#define _NTDRIVER_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <acpitabl.h>
#include <amli.h>
#include <aml.h>
#include <acpios.h>
#include <strlib.h>

//
// This is the header for interfacing with the HAL
//
#include <ntacpi.h>


#include "amlipriv.h"
#include "ctxt.h"
#include "data.h"
#include "proto.h"
#include "cmdarg.h"
#include "debugger.h"
#include "amldebug.h"
#include "trace.h"
#include "amlihook.h"
#include "amlitest.h"
#include "errlog.h"
#include "acpilog.h"
#include "wmilog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\list.c ===
/*** list.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  ListRemoveEntry - Remove an entry from the list
 *
 *  ENTRY
 *      plist -> list object to be removed
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEENTRY")

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveEntry(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (plist->plistNext == plist)
    {
        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(plist == *pplistHead);
        *pplistHead = NULL;
    }
    else
    {
        if (plist == *pplistHead)
        {
            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *pplistHead = (*pplistHead)->plistNext;
        }

        plist->plistNext->plistPrev = plist->plistPrev;
        plist->plistPrev->plistNext = plist->plistNext;
    }

    EXIT(4, ("ListRemoveEntry! (plistHead=%x)\n", *pplistHead));
}       //ListRemoveEntry

/***LP  ListRemoveHead - Remove the head entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveHead(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEHEAD")
    PLIST plist;

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveHead(plistHead=%x)\n", *pplistHead));

    if ((plist = *pplistHead) != NULL)
        ListRemoveEntry(plist, pplistHead);

    EXIT(4, ("ListRemoveHead=%x (plistHead=%x)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveHead

/***LP  ListRemoveTail - Remove the tail entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveTail(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVETAIL")
    PLIST plist;

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveTail(plistHead=%x)\n", *pplistHead));

    if (*pplistHead == NULL)
        plist = NULL;
    else
    {
        //
        // List is not empty, so find the tail.
        //
        plist = (*pplistHead)->plistPrev;
        ListRemoveEntry(plist, pplistHead);
    }

    EXIT(4, ("ListRemoveTail=%x (plistHead=%x)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveTail

/***LP  ListRemoveAll - Remove all elements in the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveAll(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEALL")

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveAll(plistHead=%x)\n", *pplistHead));

    while (*pplistHead != NULL)
    {
        ListRemoveTail(pplistHead);
    }

    EXIT(4, ("ListRemoveAll! (plistHead=%x)\n", *pplistHead));
}       //ListRemoveAll

/***LP  ListInsertHead - Insert an entry at the head of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTINSERTHEAD")

    ASSERT(pplistHead != NULL);
    ENTER(4, ("ListInsertHead(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    ListInsertTail(plist, pplistHead);
    *pplistHead = plist;

    EXIT(4, ("ListInsertHead! (plistHead=%x)\n", *pplistHead));
}       //ListInsertHead

/***LP  ListInsertTail - Insert an entry at the tail of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTINSERTTAIL")

    ASSERT(pplistHead != NULL);
    ENTER(4, ("ListInsertTail(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (*pplistHead == NULL)
    {
        //
        // List is empty, so this becomes the head.
        //
        *pplistHead = plist;
        plist->plistPrev = plist->plistNext = plist;
    }
    else
    {
        plist->plistNext = *pplistHead;
        plist->plistPrev = (*pplistHead)->plistPrev;
        (*pplistHead)->plistPrev->plistNext = plist;
        (*pplistHead)->plistPrev = plist;
    }

    EXIT(4, ("ListInsertTail! (plistHead=%x)\n", *pplistHead));
}       //ListInsertTail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\parser.c ===
/*** parser.c - AML Parser
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ParseScope - Parse a scope
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pscope -> SCOPE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseScope(PCTXT pctxt, PSCOPE pscope, NTSTATUS rc)
{
    TRACENAME("PARSESCOPE")
    ULONG dwStage = ((rc == STATUS_SUCCESS) || (rc == AMLISTA_BREAK))?
                    (pscope->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(2, ("ParseScope(Stage=%d,pctxt=%p,pbOp=%p,pscope=%p,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pscope, rc));

    ASSERT(pscope->FrameHdr.dwSig == SIG_SCOPE);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do debug print if necessary.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PrintIndent(pctxt);
                PRINTF("{");
                gDebugger.iPrintLevel++;
                pscope->FrameHdr.dwfFrame |= SCOPEF_FIRST_TERM;
            }
          #endif
            //
            // There is nothing blockable, so continue to next stage.
            //
            pscope->FrameHdr.dwfFrame++;

        case 1:
        Stage1:
            //
            // Stage 1: Parse next opcode.
            //
            if (rc == AMLISTA_BREAK)
            {
                pctxt->pbOp = pscope->pbOpEnd;
                rc = STATUS_SUCCESS;
            }
            else
            {
                while (pctxt->pbOp < pscope->pbOpEnd)
                {
                  #ifdef DEBUGGER
                    gDebugger.pbUnAsm = pctxt->pbOp;
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        if (pscope->FrameHdr.dwfFrame & SCOPEF_FIRST_TERM)
                        {
                            pscope->FrameHdr.dwfFrame &= ~SCOPEF_FIRST_TERM;
                        }
                        else if (gDebugger.dwfDebugger & DBGF_STEP_OVER)
                        {
                            gDebugger.dwfDebugger &= ~DBGF_STEP_OVER;
                            AMLIDebugger(FALSE);
                        }
                    }

                    if ((gDebugger.dwfDebugger &
                         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
                        (*pctxt->pbOp != OP_PACKAGE))
                    {
                        PrintIndent(pctxt);
                    }
                  #endif
                    //
                    // Discard result of previous term if any.
                    //
                    FreeDataBuffs(pscope->pdataResult, 1);
                    if (((rc = ParseOpcode(pctxt, pscope->pbOpEnd,
                                           pscope->pdataResult)) !=
                         STATUS_SUCCESS) ||
                        (&pscope->FrameHdr !=
                         (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                    {
                        break;
                    }
                }

                if (rc == AMLISTA_BREAK)
                {
                    pctxt->pbOp = pscope->pbOpEnd;
                    rc = STATUS_SUCCESS;
                }
                else if ((rc == AMLISTA_PENDING) ||
                         (&pscope->FrameHdr !=
                          (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
                else if ((rc == STATUS_SUCCESS) &&
                         (pctxt->pbOp < pscope->pbOpEnd))
                {
                    goto Stage1;
                }
            }
            //
            // If we come here, there was no more opcode in this scope, so
            // continue to next stage.
            //
            pscope->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                gDebugger.iPrintLevel--;
                PrintIndent(pctxt);
                PRINTF("}");
            }
          #endif

            pctxt->pnsScope = pscope->pnsPrevScope;
            pctxt->powner = pscope->pownerPrev;
            pctxt->pheapCurrent = pscope->pheapPrev;
            if (pscope->pbOpRet != NULL)
            {
                pctxt->pbOp = pscope->pbOpRet;
            }
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseScope=%x\n", rc));
    return rc;
}       //ParseScope

/***LP  ParseNestedContext - Parse and evaluate a nested context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pcall -> CALL
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */
NTSTATUS LOCAL ParseNestedContext(PCTXT pctxt, PNESTEDCTXT pnctxt, NTSTATUS rc)
{
    TRACENAME("PARSENESTEDCONTEXT")

    ENTER(2, ("ParseNestedContext(pctxt=%x,pnctxt=%x,rc=%x)\n",
              pctxt, pnctxt, rc));

    ASSERT(pctxt->dwfCtxt & CTXTF_NEST_EVAL);

    if ((rc == STATUS_SUCCESS) && (pnctxt->pdataCallBack != NULL))
    {
        rc = DupObjData(gpheapGlobal, pnctxt->pdataCallBack, &pnctxt->Result);
    }

    AsyncCallBack(pctxt, rc);

    FreeDataBuffs(&pnctxt->Result, 1);
    pctxt->dwfCtxt &= ~CTXTF_ASYNC_EVAL;
    pctxt->dwfCtxt |= pnctxt->dwfPrevCtxt & CTXTF_ASYNC_EVAL;
    pctxt->pnctxt = pnctxt->pnctxtPrev;

    PopFrame(pctxt);

    EXIT(2, ("ParseNestedContext=%x (rcEval=%x)\n", AMLISTA_DONE, rc));
    return AMLISTA_DONE;
}       //ParseNestedContext

/***LP  ParseCall - Parse and evaluate a method call
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pcall -> CALL
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseCall(PCTXT pctxt, PCALL pcall, NTSTATUS rc)
{
    TRACENAME("PARSECALL")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pcall->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 4;
    PMETHODOBJ pm;
    POBJOWNER powner;

    ENTER(2, ("ParseCall(Stage=%d,pctxt=%x,pbOp=%x,pcall=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pcall, rc));

    ASSERT(pcall->FrameHdr.dwSig == SIG_CALL);
    pm = (pcall->pnsMethod != NULL)?
         (PMETHODOBJ)pcall->pnsMethod->ObjData.pbDataBuff: NULL;

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Print debug stuff if necessary.
            //
            pcall->FrameHdr.dwfFrame++;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("(");
            }
          #endif

        case 1:
        Stage1:
            //
            // Stage 1: Parse arguments.
            //
            while (pcall->iArg < pcall->icArgs)
            {
                //
                // There are still arguments, parse it.
                //
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (pcall->iArg > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                rc = ParseArg(pctxt, 'C', &pcall->pdataArgs[pcall->iArg++]);

                if ((rc != STATUS_SUCCESS) ||
                    (&pcall->FrameHdr !=
                     (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

            if ((rc != STATUS_SUCCESS) ||
                (&pcall->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if (pcall->iArg < pcall->icArgs)
            {
                goto Stage1;
            }
            //
            // If we come here, there is no more argument, so we can fall
            // through to the next stage.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF(")");
            }
          #endif

            pcall->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Acquire mutex if necessary
            //
            pcall->FrameHdr.dwfFrame++;

            if(pm)
            {
                if (pm->bMethodFlags & METHOD_SERIALIZED)
                {
                    PACQUIRE pacq;

                    if ((rc = PushFrame(pctxt, SIG_ACQUIRE, sizeof(ACQUIRE),
                                        ParseAcquire, &pacq)) == STATUS_SUCCESS)
                    {
                        pacq->pmutex = &pm->Mutex;
                        pacq->wTimeout = 0xffff;
                        pacq->pdataResult = pcall->pdataResult;
                    }
                    break;
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED, ("ParseCall: pcall->pnsMethod == NULL"));
                break;
            }

            case 3:
            //
            // Stage 3: Invoke the method.
            //
            pcall->FrameHdr.dwfFrame++;
            //
            // If we come here, we must have acquired the serialization mutex.
            //
            if (pcall->FrameHdr.dwfFrame & CALLF_NEED_MUTEX)
            {
                pcall->FrameHdr.dwfFrame |= CALLF_ACQ_MUTEX;
            }

            if ((rc = NewObjOwner(pctxt->pheapCurrent, &powner)) ==
                STATUS_SUCCESS)
            {
                pcall->pownerPrev = pctxt->powner;
                pctxt->powner = powner;
                pcall->pcallPrev = pctxt->pcall;
                pctxt->pcall = pcall;
                pcall->FrameHdr.dwfFrame |= CALLF_INVOKE_CALL;
                rc = PushScope(pctxt, pm->abCodeBuff,
                               pcall->pnsMethod->ObjData.pbDataBuff +
                               pcall->pnsMethod->ObjData.dwDataLen,
                               pctxt->pbOp,
                               pcall->pnsMethod,
                               powner,
                               pctxt->pheapCurrent,
                               pcall->pdataResult);
                break;
            }

        case 4:
            //
            // Stage 4: Clean up.
            //
            pcall->FrameHdr.dwfFrame++;
            if (rc == AMLISTA_RETURN)
            {
                rc = STATUS_SUCCESS;
            }

            if (pcall->pdataResult->dwfData & DATAF_BUFF_ALIAS)
            {
                OBJDATA data;
                //
                // The result object is an alias.  It could be an alias of
                // ArgX or LocalX.  We better dup it because we are going
                // to blow ArgX and LocalX away.
                //
                DupObjData(pctxt->pheapCurrent, &data, pcall->pdataResult);
                FreeDataBuffs(pcall->pdataResult, 1);
                MoveObjData(pcall->pdataResult, &data);
            }

            FreeDataBuffs(pcall->Locals, MAX_NUM_LOCALS);

            if (pcall->FrameHdr.dwfFrame & CALLF_INVOKE_CALL)
            {
                FreeObjOwner(pctxt->powner, FALSE);
                pctxt->powner = pcall->pownerPrev;
                pctxt->pcall = pcall->pcallPrev;
            }
            else if (pcall->pnsMethod == NULL)
            {
                //
                // This is the dummy call frame for LoadDDB.  All NameSpace
                // objects created by LoadDDB are persistent (i.e. don't
                // destroy them).
                //
                pctxt->powner = pcall->pownerPrev;
                pctxt->pcall = pcall->pcallPrev;
            }

            if (pcall->pdataArgs != NULL)
            {
                FreeDataBuffs(pcall->pdataArgs, pcall->icArgs);
                FREEODOBJ(pcall->pdataArgs);
            }

            if (pcall->FrameHdr.dwfFrame & CALLF_ACQ_MUTEX)
            {
                ReleaseASLMutex(pctxt, &pm->Mutex);
            }

        case 5:
            //
            // Stage 5: This stage is for the dummy call frame to exit.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseCall=%x\n", rc));
    return rc;
}       //ParseCall

/***LP  ParseTerm - Parse and evaluate an ASL term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseTerm(PCTXT pctxt, PTERM pterm, NTSTATUS rc)
{
    TRACENAME("PARSETERM")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pterm->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 4;
    int i;

    ENTER(2, ("ParseTerm(Term=%s,Stage=%d,pctxt=%x,pbOp=%x,pterm=%x,rc=%x)\n",
              pterm->pamlterm->pszTermName, dwStage, pctxt, pctxt->pbOp, pterm,
              rc));

    ASSERT(pterm->FrameHdr.dwSig == SIG_TERM);
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Parse package length if any.
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->pamlterm->dwOpcode == OP_PACKAGE)
                {
                    gDebugger.iPrintLevel++;
                    PrintIndent(pctxt);
                }
                PRINTF("%s", pterm->pamlterm->pszTermName);
                if (pterm->icArgs > 0)
                {
                    PRINTF("(");
                }
            }
          #endif

            if (pterm->pamlterm->dwfOpcode & OF_VARIABLE_LIST)
            {
                ParsePackageLen(&pctxt->pbOp, &pterm->pbOpEnd);
            }

        case 1:
        Stage1:
            //
            // Stage 1: Parse arguments.
            //
            while (pterm->iArg < pterm->icArgs)
            {
                i = pterm->iArg++;
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (i > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                rc = ParseArg(pctxt, pterm->pamlterm->pszArgTypes[i],
                              &pterm->pdataArgs[i]);

                if ((rc != STATUS_SUCCESS) ||
                    (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

            if ((rc != STATUS_SUCCESS) ||
                (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if (pterm->iArg < pterm->icArgs)
            {
                goto Stage1;
            }
            //
            // If we come here, there is no more argument, so we can fall
            // through to the next stage.
            //
            pterm->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Execute the term and prepare to go to the next stage.
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->icArgs > 0)
                {
                    PRINTF(")");
                }
            }
          #endif

            if ((pterm->pamlterm->dwfOpcode & OF_CALLBACK_EX) &&
                (pterm->pamlterm->pfnCallBack != NULL))
            {
                ((PFNOPEX)pterm->pamlterm->pfnCallBack)(
                                EVTYPE_OPCODE_EX,
                                OPEXF_NOTIFY_PRE,
                                pterm->pamlterm->dwOpcode,
                                pterm->pnsObj,
                                pterm->pamlterm->dwCBData);
            }

            if (pterm->pamlterm->pfnOpcode != NULL)
            {
                if (((rc = pterm->pamlterm->pfnOpcode(pctxt, pterm)) !=
                     STATUS_SUCCESS) ||
                    (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

        case 3:
            //
            // Stage 3: Do Opcode Callback if any
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if ((pterm->pamlterm->dwOpcode != OP_BUFFER) &&
                    (pterm->pamlterm->dwOpcode != OP_PACKAGE))
                {
                    if (pterm->pamlterm->dwTermClass == TC_OPCODE_TYPE2)
                    {
                        PRINTF("=");
                        PrintObject(pterm->pdataResult);
                    }
                }
            }

            if (gDebugger.dwfDebugger & DBGF_SINGLE_STEP)
            {
                gDebugger.dwfDebugger &= ~DBGF_SINGLE_STEP;
                AMLIDebugger(FALSE);
            }
            else
            {
          #endif

            if (pterm->pamlterm->pfnCallBack != NULL)
            {
                if (pterm->pamlterm->dwfOpcode & OF_CALLBACK_EX)
                {
                    ((PFNOPEX)pterm->pamlterm->pfnCallBack)(
                        EVTYPE_OPCODE_EX,
                        OPEXF_NOTIFY_POST,
                        pterm->pamlterm->dwOpcode,
                        pterm->pnsObj,
                        pterm->pamlterm->dwCBData);
                }
                else
                {
                    pterm->pamlterm->pfnCallBack(
                        EVTYPE_OPCODE,
                        pterm->pamlterm->dwOpcode,
                        pterm->pnsObj,
                        pterm->pamlterm->dwCBData
                        );
                }
            }
          #ifdef DEBUGGER
            }
          #endif

        case 4:
            //
            // Stage 4: Clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->pamlterm->dwOpcode == OP_PACKAGE)
                {
                    gDebugger.iPrintLevel--;
                }
            }
          #endif

            if (pterm->pdataArgs != NULL)
            {
                FreeDataBuffs(pterm->pdataArgs, pterm->icArgs);
                FREEODOBJ(pterm->pdataArgs);
            }
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseTerm=%x\n", rc));
    return rc;
}       //ParseTerm

/***LP  ParseAcquire - Parse and evaluate an Acquire term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pacq - ACQUIRE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseAcquire(PCTXT pctxt, PACQUIRE pacq, NTSTATUS rc)
{
    TRACENAME("PARSEACQUIRE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pacq->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(2, ("ParseAcquire(Stage=%d,pctxt=%x,pbOp=%x,pacq=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pacq, rc));

    ASSERT(pacq->FrameHdr.dwSig == SIG_ACQUIRE);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Acquire GlobalLock if necessary.
            //
            pacq->FrameHdr.dwfFrame++;
            if (pacq->FrameHdr.dwfFrame & ACQF_NEED_GLOBALLOCK)
            {
                if ((rc = AcquireGL(pctxt)) != STATUS_SUCCESS)
                {
                    break;
                }
            }

        case 1:
            //
            // Stage 1: Acquire the mutex.
            //
            if (pacq->FrameHdr.dwfFrame & ACQF_NEED_GLOBALLOCK)
            {
                //
                // If we come here, we must have acquired the global lock.
                //
                pacq->FrameHdr.dwfFrame |= ACQF_HAVE_GLOBALLOCK;
            }

            rc = AcquireASLMutex(pctxt, pacq->pmutex, pacq->wTimeout);

            if (rc == AMLISTA_PENDING)
            {
                //
                // If it is pending, we must release the global lock and
                // retry the whole operation.
                //
                if (pacq->FrameHdr.dwfFrame & ACQF_HAVE_GLOBALLOCK)
                {
                    pacq->FrameHdr.dwfFrame &= ~ACQF_HAVE_GLOBALLOCK;
                    if ((rc = ReleaseGL(pctxt)) == STATUS_SUCCESS)
                    {
                        pacq->FrameHdr.dwfFrame--;
                    }
                    else
                    {
                        pacq->FrameHdr.dwfFrame++;
                        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                         ("ParseAcquire: failed to release global lock (rc=%x)",
                                          rc));
                    }
                }
                break;
            }
            else
            {
                if (pacq->FrameHdr.dwfFrame & ACQF_SET_RESULT)
                {
                    pacq->pdataResult->dwDataType = OBJTYPE_INTDATA;
                    if (rc == AMLISTA_TIMEOUT)
                    {
                        pacq->pdataResult->uipDataValue = DATAVALUE_ONES;
                        rc = STATUS_SUCCESS;
                    }
                    else
                    {
                        pacq->pdataResult->uipDataValue = DATAVALUE_ZERO;
                    }
                }
            }
            pacq->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseAcquire=%x\n", rc));
    return rc;
}       //ParseAcquire

/***LP  ParseOpcode - Parse AML opcode
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbScopeEnd -> end of current scope
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseOpcode(PCTXT pctxt, PUCHAR pbScopeEnd, POBJDATA pdataResult)
{
    TRACENAME("PARSEOPCODE")
    NTSTATUS rc = STATUS_SUCCESS;
    PUCHAR pbOpTerm;
    PAMLTERM pamlterm;
  #ifdef DEBUGGER
    int iBrkPt;
  #endif

    ENTER(2, ("ParseOpcode(pctxt=%x,pbOp=%x,pbScopeEnd=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pbScopeEnd, pdataResult));

    ASSERT(pdataResult != NULL);
  #ifdef DEBUGGER
    if ((iBrkPt = CheckBP(pctxt->pbOp)) != -1)
    {
        PRINTF("\nHit Breakpoint %d.\n", iBrkPt);
        AMLIDebugger(FALSE);
    }
  #endif
    pbOpTerm = pctxt->pbOp;
    if (*pctxt->pbOp == OP_EXT_PREFIX)
    {
        pctxt->pbOp++;
        pamlterm = FindOpcodeTerm(*pctxt->pbOp, ExOpcodeTable);
    }
    else
    {
        pamlterm = OpcodeTable[*pctxt->pbOp];
    }

    if (pamlterm == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("ParseOpcode: invalid opcode 0x%02x at 0x%08x",
                         *pctxt->pbOp, pctxt->pbOp));
    }
    else if (pamlterm->dwfOpcode & OF_DATA_OBJECT)
    {
        rc = ParseIntObj(&pctxt->pbOp, pdataResult, FALSE);
    }
    else if (pamlterm->dwfOpcode & OF_STRING_OBJECT)
    {
        rc = ParseString(&pctxt->pbOp, pdataResult, FALSE);
    }
    else if (pamlterm->dwfOpcode & OF_ARG_OBJECT)
    {
        rc = ParseArgObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_LOCAL_OBJECT)
    {
        rc = ParseLocalObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_NAME_OBJECT)
    {
        rc = ParseNameObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_DEBUG_OBJECT)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("ParseOpcode: debug object cannot be evaluated"));
    }
    else
    {
        //
        // Must be an ASL Term.
        //
        pctxt->pbOp++;
        rc = PushTerm(pctxt, pbOpTerm, pbScopeEnd, pamlterm, pdataResult);
    }

    EXIT(2, ("ParseOpcode=%x (pbOp=%x,pamlterm=%x)\n",
             rc, pctxt->pbOp, pamlterm));
    return rc;
}       //ParseOpcode

/***LP  ParseArgObj - Parse and execute the ArgX instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseArgObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSEARGOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    int i;

    ENTER(2, ("ParseArgObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);
    i = *pctxt->pbOp - OP_ARG0;

    if (i >= pctxt->pcall->icArgs)
    {
        rc = AMLI_LOGERR(AMLIERR_ARG_NOT_EXIST,
                         ("ParseArgObj: Arg%d does not exist", i));
    }
    else
    {
        CopyObjData(pdataResult, &pctxt->pcall->pdataArgs[i]);
        pctxt->pbOp++;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Arg%d=", i);
            PrintObject(pdataResult);
        }
      #endif
    }

    EXIT(2, ("ParseArgObj=%x (pbOp=%x)\n", rc, pctxt->pbOp));
    return rc;
}       //ParseArgObj

/***LP  ParseLocalObj - Parse and execute the LocalX instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> Result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseLocalObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSELOCALOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    int i;

    ENTER(2, ("ParseLocalObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);
    i = *pctxt->pbOp - OP_LOCAL0;
    CopyObjData(pdataResult, &pctxt->pcall->Locals[i]);

  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        PRINTF("Local%d=", i);
        PrintObject(pdataResult);
    }
  #endif

    pctxt->pbOp++;

    EXIT(2, ("ParseLocalObj=%x (pbOp=%x)\n", rc, pctxt->pbOp));
    return rc;
}       //ParseLocalObj

/***LP  ParseNameObj - Parse and evaluate an AML name object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseNameObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSENAMEOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns = NULL;

    ENTER(2, ("ParseNameObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);

    rc = ParseAndGetNameSpaceObject(&pctxt->pbOp, pctxt->pnsScope, &pns, FALSE);

    if (rc == STATUS_SUCCESS)
    {
        pns = GetBaseObject(pns);
        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            rc = PushCall(pctxt, pns, pdataResult);
        }
        else
        {
            rc = ReadObject(pctxt, &pns->ObjData, pdataResult);
        }
    }

    EXIT(2, ("ParseNameObj=%x\n", rc));
    return rc;
}       //ParseNameObj

/***LP  ParseAndGetNameSpaceObject - Parse NameSpace path and get the object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pnsScope - current scope
 *      ppns -> to hold the object found
 *      fAbsentOK - if TRUE, do not print error message when object is not
 *                  found
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseAndGetNameSpaceObject(PUCHAR *ppbOp, PNSOBJ pnsScope,
                                          PPNSOBJ ppns, BOOLEAN fAbsentOK)
{
    TRACENAME("PARSEANDGETNAMESPACEOBJECT")
    NTSTATUS rc;
    char szNameBuff[MAX_NAME_LEN + 1];

    ENTER(2, ("ParseAndGetNameSpaceObject(pbOp=%x,Scope=%s,ppns=%x,fAbsentOK=%x)\n",
              *ppbOp, GetObjectPath(pnsScope), ppns, fAbsentOK));

    if ((rc = ParseName(ppbOp, szNameBuff, sizeof(szNameBuff))) ==
        STATUS_SUCCESS)
    {
        rc = GetNameSpaceObject(szNameBuff, pnsScope, ppns, 0);
        if (rc == AMLIERR_OBJ_NOT_FOUND)
        {
            if (fAbsentOK)
            {
                rc = STATUS_SUCCESS;
                *ppns = NULL;
            }
            else
            {
                rc = AMLI_LOGERR(rc,
                                 ("ParseAndGetNameSpaceObject: object %s not found",
                                  szNameBuff));
            }
        }
    }

    EXIT(2, ("ParseAndGetNameSpaceObject=%x (Name=%s)\n", rc, szNameBuff));
    return rc;
}       //ParseAndGetNameSpaceObject

/***LP  ParseArg - Parse and evaluate an argument
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      chArgType - expected argument type
 *      pdataArg -> argument object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseArg(PCTXT pctxt, char chArgType, POBJDATA pdataArg)
{
    TRACENAME("PARSEARG")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseArg(pctxt=%x,pbOp=%x,ArgType=%c,pdataArg=%x)\n",
              pctxt, pctxt->pbOp, chArgType, pdataArg));

    ASSERT(pdataArg != NULL);
    switch (chArgType)
    {
        case ARGTYPE_NAME:
            rc = ParseObjName(&pctxt->pbOp, pdataArg, FALSE);
            break;

        case ARGTYPE_DATAOBJ:
            if (((rc = ParseIntObj(&pctxt->pbOp, pdataArg, TRUE)) ==
                 AMLIERR_INVALID_OPCODE) &&
                ((rc = ParseString(&pctxt->pbOp, pdataArg, TRUE)) ==
                 AMLIERR_INVALID_OPCODE) &&
                ((*pctxt->pbOp == OP_BUFFER) || (*pctxt->pbOp == OP_PACKAGE)))
            {
                rc = PushTerm(pctxt, pctxt->pbOp, NULL,
                              OpcodeTable[*pctxt->pbOp], pdataArg);
                pctxt->pbOp++;
            }
            break;

        case ARGTYPE_BYTE:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(UCHAR));
            break;

        case ARGTYPE_WORD:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(USHORT));
            break;

        case ARGTYPE_DWORD:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(ULONG));
            break;

        case ARGTYPE_SNAME:
            rc = ParseSuperName(pctxt, pdataArg, FALSE);
            break;

        case ARGTYPE_SNAME2:
            rc = ParseSuperName(pctxt, pdataArg, TRUE);
            break;

        case ARGTYPE_OPCODE:
            rc = ParseOpcode(pctxt, NULL, pdataArg);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("ParseArg: unexpected arguemnt type (%c)",
                              chArgType));
    }

    EXIT(2, ("ParseArg=%x\n", rc));
    return rc;
}       //ParseArg

/***LP  ParseSuperName - Parse AML SuperName
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdata -> object data
 *      fAbsentOK - If TRUE, it is not an error for the object to be absent
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseSuperName(PCTXT pctxt, POBJDATA pdata, BOOLEAN fAbsentOK)
{
    TRACENAME("PARSESUPERNAME")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm;
    PNSOBJ pns = NULL;
    int i;

    ENTER(2, ("ParseSuperName(pctxt=%x,pbOp=%x,pdata=%x,fAbsentOK=%x)\n",
              pctxt, pctxt->pbOp, pdata, fAbsentOK));

    ASSERT(pdata != NULL);
    if (*pctxt->pbOp == 0)
    {
        ASSERT(pdata->dwDataType == OBJTYPE_UNKNOWN);
        pctxt->pbOp++;
    }
    else if ((*pctxt->pbOp == OP_EXT_PREFIX) &&
             (*(pctxt->pbOp + 1) == EXOP_DEBUG))
    {
        pctxt->pbOp += 2;
        pdata->dwDataType = OBJTYPE_DEBUG;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Debug");
        }
      #endif
    }
    else if ((pamlterm = OpcodeTable[*pctxt->pbOp]) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_SUPERNAME,
                         ("ParseSuperName: invalid SuperName - 0x%02x at 0x%08x",
                          *pctxt->pbOp, pctxt->pbOp));
    }
    else if (pamlterm->dwfOpcode & OF_NAME_OBJECT)
    {
        rc = ParseAndGetNameSpaceObject(&pctxt->pbOp, pctxt->pnsScope, &pns,
                                        fAbsentOK);

        if (rc == STATUS_SUCCESS)
        {
            if (pns != NULL)
            {
                pdata->dwDataType = OBJTYPE_OBJALIAS;
                pdata->pnsAlias = GetBaseObject(pns);
            }
            else
            {
                ASSERT(pdata->dwDataType == OBJTYPE_UNKNOWN);
            }
        }
    }
    else if (pamlterm->dwfOpcode & OF_ARG_OBJECT)
    {
        i = *pctxt->pbOp - OP_ARG0;
        pctxt->pbOp++;

        if (i < pctxt->pcall->icArgs)
        {
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Arg%d", i);
            }
          #endif
            pdata->dwDataType = OBJTYPE_DATAALIAS;
            pdata->pdataAlias = GetBaseData(&pctxt->pcall->pdataArgs[i]);
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_ARG_NOT_EXIST,
                             ("ParseSuperName: Arg%d does not exist", i));
        }
    }
    else if (pamlterm->dwfOpcode & OF_LOCAL_OBJECT)
    {
        i = *pctxt->pbOp - OP_LOCAL0;
        pctxt->pbOp++;

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Local%d", i);
        }
      #endif
        pdata->dwDataType = OBJTYPE_DATAALIAS;
        pdata->pdataAlias = &pctxt->pcall->Locals[i];
    }
    else if (pamlterm->dwfOpcode & OF_REF_OBJECT)
    {
        rc = PushTerm(pctxt, pctxt->pbOp, NULL, pamlterm, pdata);
        pctxt->pbOp++;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_SUPERNAME,
                         ("ParseSuperName: invalid SuperName %x at %x",
                          *pctxt->pbOp, pctxt->pbOp));
    }

    EXIT(2, ("ParseSuperName=%x\n", rc));
    return rc;
}       //ParseSuperName

/***LP  ParseIntObj - Parse AML integer object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdataResult -> result object
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseIntObj(PUCHAR *ppbOp, POBJDATA pdataResult, BOOLEAN fErrOK)
{
    TRACENAME("PARSEINTOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    UCHAR bOp;

    ENTER(2, ("ParseIntObj(pbOp=%x,pdataResult=%x,fErrOK=%x)\n",
              *ppbOp, pdataResult, fErrOK));

    ASSERT(pdataResult != NULL);
    bOp = **ppbOp;
    (*ppbOp)++;
    pdataResult->dwDataType = OBJTYPE_INTDATA;
    pdataResult->uipDataValue = 0;

    switch (bOp)
    {
        case OP_ZERO:
            pdataResult->uipDataValue = DATAVALUE_ZERO;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Zero");
            }
          #endif
            break;

        case OP_ONE:
            pdataResult->uipDataValue = DATAVALUE_ONE;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("One");
            }
          #endif
            break;

        case OP_ONES:
            pdataResult->uipDataValue = DATAVALUE_ONES;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Ones");
            }
          #endif
            break;

        case OP_REVISION:
            pdataResult->uipDataValue = AMLI_REVISION;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Revision");
            }
          #endif
            break;

        case OP_BYTE:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(UCHAR));
            (*ppbOp) += sizeof(UCHAR);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        case OP_WORD:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(USHORT));
            (*ppbOp) += sizeof(USHORT);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        case OP_DWORD:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(ULONG));
            (*ppbOp) += sizeof(ULONG);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        default:
            (*ppbOp)--;
            if (fErrOK)
            {
                rc = AMLIERR_INVALID_OPCODE;
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                                 ("ParseIntObj: invalid opcode 0x%02x at 0x%08x",
                                  **ppbOp, *ppbOp));
            }
    }

    EXIT(2, ("ParseIntObj=%x (pbOp=%x,Value=%x)\n",
             rc, *ppbOp, pdataResult->uipDataValue));
    return rc;
}       //ParseIntObj

/***LP  ParseString - Parse AML string object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdataResult -> result object
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseString(PUCHAR *ppbOp, POBJDATA pdataResult, BOOLEAN fErrOK)
{
    TRACENAME("PARSESTRING")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseString(pbOp=%x,pdataResult=%x,fErrOK=%x)\n",
              *ppbOp, pdataResult, fErrOK));

    ASSERT(pdataResult != NULL);
    if (**ppbOp == OP_STRING)
    {
        (*ppbOp)++;
        pdataResult->dwDataType = OBJTYPE_STRDATA;
        pdataResult->dwDataLen = STRLEN((PSZ)*ppbOp) + 1;

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("\"%s\"", *ppbOp);
        }
      #endif

        if ((pdataResult->pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                pdataResult->dwDataLen)) ==
            NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("ParseString: failed to allocate string buffer"));
        }
        else
        {
            MEMCPY(pdataResult->pbDataBuff, *ppbOp, pdataResult->dwDataLen);
        }

        (*ppbOp) += pdataResult->dwDataLen;
    }
    else if (fErrOK)
    {
        rc = AMLIERR_INVALID_OPCODE;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("ParseStrObj: invalid opcode 0x%02x at 0x%08x",
                          **ppbOp, *ppbOp));
    }

    EXIT(2, ("ParseString=%x (Value=%s)\n",
             rc, pdataResult->pbDataBuff? (PSZ)pdataResult->pbDataBuff:
                                          "<null>"));
    return rc;
}       //ParseString

/***LP  ParseObjName - Parse AML object name
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdata -> to hold name data
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseObjName(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK)
{
    TRACENAME("PARSEOBJNAME")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm = OpcodeTable[**ppbOp];
    char szNameBuff[MAX_NAME_LEN+1];

    ENTER(2, ("ParseObjName(pbOp=%x,pdata=%x,fErrOK=%x)\n",
              *ppbOp, pdata, fErrOK));

    ASSERT(pdata != NULL);

    if ((pamlterm == NULL) || !(pamlterm->dwfOpcode & OF_NAME_OBJECT))
    {
        if (fErrOK)
        {
            rc = AMLIERR_INVALID_OPCODE;
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                             ("ParseObjName: invalid opcode 0x%02x at 0x%08x",
                              **ppbOp, *ppbOp));
        }
    }
    else if ((rc = ParseName(ppbOp, szNameBuff, sizeof(szNameBuff))) ==
             STATUS_SUCCESS)
    {
        pdata->dwDataType = OBJTYPE_STRDATA;
        pdata->dwDataLen = STRLEN(szNameBuff) + 1;
        if ((pdata->pbDataBuff = (PUCHAR)NEWSDOBJ(gpheapGlobal,
                                                  pdata->dwDataLen)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("ParseObjName: failed to allocate name buffer - %s",
                              szNameBuff));
        }
        else
        {
            MEMCPY(pdata->pbDataBuff, szNameBuff, pdata->dwDataLen);
        }
    }

    EXIT(2, ("ParseObjName=%x (Name=%s)\n", rc, szNameBuff));
    return rc;
}       //ParseObjName

/***LP  ParseName - Parse AML name
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      dwLen - buffer length
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseName(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen)
{
    TRACENAME("PARSENAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseName(pbOp=%x,pszBuff=%x,Len=%d)\n",
              *ppbOp, pszBuff, dwLen));

    if (**ppbOp == OP_ROOT_PREFIX)
    {
        if (dwLen > 1)
        {
            STRCPY(pszBuff, "\\");
            (*ppbOp)++;
            rc = ParseNameTail(ppbOp, pszBuff, dwLen);
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                             ("ParseName: name too long - \"%s\"", pszBuff));
        }
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        if (dwLen > 1)
        {
            int i;

            STRCPY(pszBuff, "^");
            for ((*ppbOp)++, i = 1;
                 (i < (int)dwLen) && (**ppbOp == OP_PARENT_PREFIX);
                 (*ppbOp)++, i++)
            {
                pszBuff[i] = '^';
            }
            pszBuff[i] = '\0';

            if (**ppbOp == OP_PARENT_PREFIX)
            {
                rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                                 ("ParseName: name too long - \"%s\"",
                                  pszBuff));
            }
            else
            {
                rc = ParseNameTail(ppbOp, pszBuff, dwLen);
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                             ("ParseName: name too long - \"%s\"", pszBuff));
        }
    }
    else if (dwLen > 0)
    {
        pszBuff[0] = '\0';
        rc = ParseNameTail(ppbOp, pszBuff, dwLen);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                         ("ParseName: name too long - \"%s\"", pszBuff));
    }

  #ifdef DEBUGGER
    if ((rc == STATUS_SUCCESS) &&
        (gDebugger.dwfDebugger &
         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)))
    {
        PRINTF("%s", pszBuff);
    }
  #endif

    EXIT(2, ("ParseName=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseName

/***LP  ParseNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      dwLen - buffer length
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseNameTail(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen)
{
    TRACENAME("PARSENAMETAIL")
    NTSTATUS rc = STATUS_SUCCESS;
    int iLen;
    int icNameSegs = 0;

    ENTER(2, ("ParseNameTail(pbOp=%x,Name=%s,Len=%d)\n",
              *ppbOp, pszBuff, dwLen));

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    iLen = STRLEN(pszBuff);
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < dwLen))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        (*ppbOp) += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < (int)dwLen))
        {
            STRCPY(&pszBuff[iLen], ".");
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                         ("ParseNameTail: name too long - %s", pszBuff));
    }

    EXIT(2, ("ParseNameTail=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseNameTail

/***LP  ParseInteger - Parse AML integer object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdata -> to hold data
 *      dwDataLen - data length in bytes
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseInteger(PUCHAR *ppbOp, POBJDATA pdata, ULONG dwDataLen)
{
    TRACENAME("PARSEINTEGER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseInteger(pbOp=%x,pdata=%x,DataLen=%d)\n",
              *ppbOp, pdata, dwDataLen));

    ASSERT(pdata != NULL);
    pdata->dwDataType = OBJTYPE_INTDATA;
    pdata->uipDataValue = 0;
    MEMCPY(&pdata->uipDataValue, *ppbOp, dwDataLen);
    (*ppbOp) += dwDataLen;

  #ifdef DEBUGGER
    if ((rc == STATUS_SUCCESS) &&
        (gDebugger.dwfDebugger &
         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)))

    {
        PRINTF("0x%x", pdata->uipDataValue);
    }
  #endif

    EXIT(2, ("ParseInteger=%x (Value=%x,pbOp=%x)\n",
             rc, pdata->uipDataValue, *ppbOp));
    return rc;
}       //ParseInteger

/***LP  ParseField - Parse AML field data
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsParent -> parent
 *      pdwFieldFlags -> field flags
 *      pdwBitPos -> to hold the bit position parsed
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseField(PCTXT pctxt, PNSOBJ pnsParent, PULONG pdwFieldFlags,
                          PULONG pdwBitPos)
{
    TRACENAME("PARSEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(2, ("ParseField(pctxt=%x,pbOp=%x,pnsParent=%x,FieldFlags=%x,BitPos=%x)\n",
              pctxt, pctxt->pbOp, pnsParent, *pdwFieldFlags, *pdwBitPos));

    if (*pctxt->pbOp == 0x01)
    {
        pctxt->pbOp++;
        *pdwFieldFlags &= ~ACCTYPE_MASK;
        *pdwFieldFlags |= *pctxt->pbOp & ACCTYPE_MASK;
        pctxt->pbOp++;
        *pdwFieldFlags &= ~ACCATTRIB_MASK;
        *pdwFieldFlags |= (ULONG)*pctxt->pbOp << 8;
        pctxt->pbOp++;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintIndent(pctxt);
            PRINTF("AccessAs(0x%x,0x%x)",
                   *pdwFieldFlags & 0xff, (*pdwFieldFlags >> 8) & 0xff);
        }
      #endif
    }
    else
    {
        ULONG dwcbBits, dwAccSize = ACCSIZE(*pdwFieldFlags);
        PNSOBJ pns;

        if (*pctxt->pbOp == 0)
        {
            szName[0] = '\0';
            pctxt->pbOp++;
        }
        else
        {
            STRCPYN(szName, (PSZ)pctxt->pbOp, sizeof(NAMESEG));
            pctxt->pbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(&pctxt->pbOp, NULL);
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintIndent(pctxt);
            if (szName[0] == '\0')
            {
                if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
                {
                    PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
                }
                else
                {
                    PRINTF(",%d", dwcbBits);
                }
            }
            else
            {
                PRINTF("%s,%d", szName, dwcbBits);
            }
        }
      #endif

        if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, szName,
                                        pctxt->pnsScope, pctxt->powner, &pns,
                                        0)) == STATUS_SUCCESS)
        {
            pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
            pns->ObjData.dwDataLen = sizeof(FIELDUNITOBJ);

            if ((pns->ObjData.pbDataBuff = NEWFUOBJ(pctxt->pheapCurrent,
                                                    pns->ObjData.dwDataLen)) ==
                NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("ParseField: failed to allocate FieldUnit object"));
            }
            else
            {
                PFIELDUNITOBJ pfu;

                MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
                pfu = (PFIELDUNITOBJ)pns->ObjData.pbDataBuff;
                pfu->pnsFieldParent = pnsParent;
                pfu->FieldDesc.dwFieldFlags = *pdwFieldFlags;
                pfu->FieldDesc.dwByteOffset = (*pdwBitPos / (dwAccSize*8))*
                                              dwAccSize;
                pfu->FieldDesc.dwStartBitPos = *pdwBitPos -
                                               pfu->FieldDesc.dwByteOffset*8;
                pfu->FieldDesc.dwNumBits = dwcbBits;
                (*pdwBitPos) += dwcbBits;
            }
        }
    }

    EXIT(2, ("ParseField=%x (Field=%s,BitPos=%x)\n", rc, szName, *pdwBitPos));
    return rc;
}       //ParseField

/***LP  ParseFieldList - Parse the FieldUnit list
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpEnd -> end of field list
 *      pnsParent -> parent
 *      dwFieldFlags - field flags
 *      dwRegionLen - length of operation region (0xffffffff if no length limit)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseFieldList(PCTXT pctxt, PUCHAR pbOpEnd, PNSOBJ pnsParent,
                              ULONG dwFieldFlags, ULONG dwRegionLen)
{
    TRACENAME("PARSESFIELDLIST")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwBitPos = 0;

    ENTER(2, ("ParseFieldList(pctxt=%x,pbOp=%x,pnsParent=%x,FieldFlags=%x,RegionLen=%x)\n",
              pctxt, pctxt->pbOp, pnsParent, dwFieldFlags, dwRegionLen));

  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger &
        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        PrintIndent(pctxt);
        PRINTF("{");
        gDebugger.iPrintLevel++;
    }
  #endif

    while ((rc == STATUS_SUCCESS) && (pctxt->pbOp < pbOpEnd))
    {
        if ((rc = ParseField(pctxt, pnsParent, &dwFieldFlags, &dwBitPos)) ==
            STATUS_SUCCESS)
        {
          #ifdef DEBUGGER
            if ((gDebugger.dwfDebugger &
                 (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
                (rc == STATUS_SUCCESS) &&
                (pctxt->pbOp < pbOpEnd))
            {
                PRINTF(",");
            }
          #endif

            if ((dwRegionLen != 0xffffffff) && ((dwBitPos + 7)/8 > dwRegionLen))
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("ParseFieldList: offset exceeds OpRegion range (Offset=0x%x, RegionLen=0x%x)",
                                  (dwBitPos + 7)/8, dwRegionLen));
            }
        }
    }
  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger &
        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        gDebugger.iPrintLevel--;
        PrintIndent(pctxt);
        PRINTF("}");
    }
  #endif

    EXIT(2, ("ParseFieldList=%x\n", rc));
    return rc;
}       //ParseFieldList

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext)
{
    TRACENAME("PARSEPACKAGELEN")
    ULONG dwLen;
    UCHAR bFollowCnt, i;

    ENTER(2, ("ParsePackageLen(pbOp=%x,ppbOpNext=%x)\n", *ppbOp, ppbOpNext));

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (ULONG)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (UCHAR)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (ULONG)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    EXIT(2, ("ParsePackageLen=%x (pbOp=%x,pbOpNext=%x)\n",
             dwLen, *ppbOp, ppbOpNext? *ppbOpNext: 0));
    return dwLen;
}       //ParsePackageLen
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\misc.c ===
/*** misc.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  InitializeMutex - initialize mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitializeMutex(PMUTEX pmut)
{
    TRACENAME("INITIALIZEMUTEX")

    ENTER(3, ("InitializeMutex(pmut=%x)\n", pmut));

    KeInitializeSpinLock(&pmut->SpinLock);
    pmut->OldIrql = PASSIVE_LEVEL;

    EXIT(3, ("InitializeMutex!\n"));
}       //InitializeMutex

/***LP  AcquireMutex - acquire mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 *
 *  NOTE
 *      AcquireMutex can be called at DISPATCH_LEVEL as long as the mutex
 *      is unowned or owned by the same thread.  If the mutex is owned by
 *      some other thread, this thread cannot block if we are at
 *      DISPATCH_LEVEL and therefore would fail to acquire the mutex.
 */

BOOLEAN LOCAL AcquireMutex(PMUTEX pmut)
{
    TRACENAME("ACQUIREMUTEX")
    BOOLEAN rc = TRUE;

    ENTER(3, ("AcquireMutex(pmut=%x)\n", pmut));

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    KeAcquireSpinLock(&pmut->SpinLock, &pmut->OldIrql);

    EXIT(3, ("AcquireMutex=%x\n", rc));
    return rc;
}       //AcquireMutex

/***LP  ReleaseMutex - release mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL ReleaseMutex(PMUTEX pmut)
{
    TRACENAME("RELEASEMUTEX")
    BOOLEAN rc = TRUE;

    ENTER(3, ("ReleaseMutex(pmut=%x)\n", pmut));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeReleaseSpinLock(&pmut->SpinLock, pmut->OldIrql);

    EXIT(3, ("ReleaseMutex!\n"));
    return rc;
}       //ReleaseMutex

/***LP  FindOpcodeTerm - find the AMLTERM for the given opcode
 *
 *  ENTRY
 *      dwOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns pointer to the opcode's AMLTERM
 *  EXIT-FAILURE
 *      returns NULL
 */

PAMLTERM LOCAL FindOpcodeTerm(ULONG dwOp, POPCODEMAP pOpTable)
{
    TRACENAME("FINDOPCODETERM")
    PAMLTERM pamlterm = NULL;

    ENTER(3, ("FindOpcodeTerm(Op=%x,pOpTable=%x)\n", dwOp, pOpTable));

    while (pOpTable->pamlterm != NULL)
    {
        if (dwOp == pOpTable->dwOpcode)
        {
            pamlterm = pOpTable->pamlterm;
            break;
        }
        else
            pOpTable++;
    }

    EXIT(3, ("FindOpcodeTerm=%x\n", pamlterm));
    return pamlterm;
}       //FindOpcodeTerm

/***LP  GetHackFlags - Get the hack flags from the registry
 *
 *  ENTRY
 *      pdsdt -> AML table
 *
 *  EXIT-SUCCESS
 *      returns the hack flags read
 *  EXIT-FAILURE
 *      returns zero
 */

ULONG LOCAL GetHackFlags(PDSDT pdsdt)
{
    TRACENAME("GETHACKFLAGS")
    ULONG dwfHacks = 0, dwcb;
    static PSZ pszHackFlags = "AMLIHackFlags";

    ENTER(3, ("GetHackFlags(pdsdt=%x)\n", pdsdt));

    if (pdsdt == NULL)
    {
        dwcb = sizeof(dwfHacks);
        OSReadRegValue(pszHackFlags, (HANDLE)NULL, &dwfHacks, &dwcb);
    }
    else
    {
        ULONG dwLen, i;
        PSZ pszRegPath;
        HANDLE hRegKey;
        NTSTATUS status;

        dwLen = STRLEN(ACPI_PARAMETERS_REGISTRY_KEY) +
                ACPI_MAX_TABLE_STRINGS +
                8 + 5;

        if ((pszRegPath = ExAllocatePool(PagedPool, dwLen)) != NULL)
        {
            STRCPY(pszRegPath, ACPI_PARAMETERS_REGISTRY_KEY);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)&pdsdt->Header.Signature,
                    ACPI_MAX_SIGNATURE);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)pdsdt->Header.OEMID, ACPI_MAX_OEM_ID);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)pdsdt->Header.OEMTableID, ACPI_MAX_TABLE_ID);
            STRCAT(pszRegPath, "\\");
            ULTOA(pdsdt->Header.OEMRevision, &pszRegPath[STRLEN(pszRegPath)],
                  16);
            dwLen = STRLEN(pszRegPath);
            for (i = 0; i < dwLen; i++)
            {
                if (pszRegPath[i] == ' ')
                {
                    pszRegPath[i] = '_';
                }
            }

            status = OSOpenHandle(pszRegPath, NULL, &hRegKey);
            if (NT_SUCCESS(status))
            {
                dwcb = sizeof(dwfHacks);
                OSReadRegValue(pszHackFlags, hRegKey, &dwfHacks, &dwcb);
            }
            ExFreePool(pszRegPath);
        }
    }

    EXIT(3, ("GetHackFlags=%x\n", dwfHacks));
    return dwfHacks;
}       //GetHackFlags

/***LP  GetBaseObject - If object type is OBJALIAS, follow the chain to the base
 *
 *  ENTRY
 *      pnsObj -> object
 *
 *  EXIT
 *      returns the base object
 */

PNSOBJ LOCAL GetBaseObject(PNSOBJ pnsObj)
{
    TRACENAME("GETBASEOBJECT")

    ENTER(3, ("GetBaseObject(pnsObj=%s)\n", GetObjectPath(pnsObj)));

    while (pnsObj->ObjData.dwDataType == OBJTYPE_OBJALIAS)
    {
        pnsObj = pnsObj->ObjData.pnsAlias;
    }

    EXIT(3, ("GetBaseObject=%s\n", GetObjectPath(pnsObj)));
    return pnsObj;
}       //GetBaseObject

/***LP  GetBaseData - If object type is DATAALIAS, follow the chain to the base
 *
 *  ENTRY
 *      pdataObj -> object
 *
 *  EXIT
 *      returns the base object
 */

POBJDATA LOCAL GetBaseData(POBJDATA pdataObj)
{
    TRACENAME("GETBASEDATA")

    ENTER(3, ("GetBaseData(pdataObj=%x)\n", pdataObj));

    ASSERT(pdataObj != NULL);
    for (;;)
    {
        if (pdataObj->dwDataType == OBJTYPE_OBJALIAS)
        {
            pdataObj = &pdataObj->pnsAlias->ObjData;
        }
        else if (pdataObj->dwDataType == OBJTYPE_DATAALIAS)
        {
            pdataObj = pdataObj->pdataAlias;
        }
        else
        {
            break;
        }
    }

    EXIT(3, ("GetBaseData=%x\n", pdataObj));
    return pdataObj;
}       //GetBaseData

/***LP  NewObjOwner - create a new object owner
 *
 *  ENTRY
 *      pheap -> HEAP
 *      ppowner -> to hold new owner pointer
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL NewObjOwner(PHEAP pheap, POBJOWNER *ppowner)
{
    TRACENAME("NEWOBJOWNER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("NewObjOwner(pheap=%x,ppowner=%x)\n", pheap, ppowner));

    if ((*ppowner = NEWOOOBJ(pheap, sizeof(OBJOWNER))) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("NewObjOwner: failed to allocate object owner"));
    }
    else
    {

        MEMZERO(*ppowner, sizeof(OBJOWNER));
        (*ppowner)->dwSig = SIG_OBJOWNER;

        AcquireMutex(&gmutOwnerList);
        ListInsertTail(&(*ppowner)->list, &gplistObjOwners);
        ReleaseMutex(&gmutOwnerList);

    }

    EXIT(3, ("NewObjOwner=%x (powern=%x)\n", rc, *ppowner));
    return rc;
}       //NewObjOwner

/***LP  FreeObjOwner - free object owner
 *
 *  ENTRY
 *      powner -> OBJOWNER
 *      fUnload - if TRUE, the caller is unloading a DDB
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeObjOwner(POBJOWNER powner, BOOLEAN fUnload)
{
    TRACENAME("FREEOBJOWNER")
    KIRQL   oldIrql;
    PNSOBJ  pns;
    PNSOBJ  pnsNext       = NULL;
    PNSOBJ  pnsPrev       = NULL;
    PNSOBJ  pnsDeviceList = NULL;
    PNSOBJ  pnsChild      = NULL;

    ENTER(3, ("FreeObjOwner(powner=%x,fUnload=%x)\n", powner,fUnload));

    ASSERT(powner != NULL);

    AcquireMutex(&gmutOwnerList);
    ListRemoveEntry(&powner->list, &gplistObjOwners);
    ReleaseMutex(&gmutOwnerList);

    if (fUnload && (ghDestroyObj.pfnHandler != NULL))
    {

        //
        // First we have to tell the driver that we are about to
        // do walk the owner list so that we can seek and destroy
        // the objects
        //
        ((PFNDOBJ)ghDestroyObj.pfnHandler)(DESTROYOBJ_START, &oldIrql, 0);

        //
        // First pass, mark the objects defunc'd.
        //
        for (pns = powner->pnsObjList; pns != NULL; pns = pns->pnsOwnedNext) {

            pns->ObjData.dwfData |= DATAF_NSOBJ_DEFUNC;

        }

        //
        // Second pass, find the device in the list to be removed
        //
        for (pns = powner->pnsObjList; pns != NULL; pns = pnsNext) {

            pnsNext = pns->pnsOwnedNext;
            if (pns->ObjData.dwDataType == OBJTYPE_DEVICE ||
                pns->ObjData.dwDataType == OBJTYPE_POWERRES ||
                pns->ObjData.dwDataType == OBJTYPE_THERMALZONE ||
                pns->ObjData.dwDataType == OBJTYPE_PROCESSOR) {

                if (pnsPrev) {

                    pnsPrev->pnsOwnedNext = pns->pnsOwnedNext;

                } else {

                    powner->pnsObjList = pns->pnsOwnedNext;

                }
                pns->pnsOwnedNext = pnsDeviceList;
                pnsDeviceList = pns;

                //
                // Detach the device from its parent
                //
                if (pns->pnsParent != NULL) {

                    ListRemoveEntry(
                        &pns->list,
                        (PPLIST)&pns->pnsParent->pnsFirstChild
                        );
                    pns->pnsParent = NULL;

                }

                //
                // Make sure that all of the device's children have been
                // marked as being unloaded
                //
                if (pns->pnsFirstChild) {

                    pnsChild = pns->pnsFirstChild;
                    do {

                        if (!(pnsChild->ObjData.dwfData & DATAF_NSOBJ_DEFUNC) ) {

                            ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                                DESTROYOBJ_CHILD_NOT_FREED,
                                pnsChild,
                                0
                                );

                        }
                        pnsChild = (PNSOBJ) pnsChild->list.plistNext;

                    } while (pnsChild != pns->pnsFirstChild);

                }
                //
                // Not that if we don't put this continue in here, then
                // it becomes possible for pnsPrev to point to a device,
                // which would corrupt the list
                continue;

            } else if (pns->pnsParent == NULL ||
                !(pns->pnsParent->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)) {

                ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                    DESTROYOBJ_BOGUS_PARENT,
                    pns,
                    0
                    );

            }
            pnsPrev = pns;

        }

        //
        // Chain the two lists back together
        //
        if (powner->pnsObjList == NULL) {

            powner->pnsObjList = pnsDeviceList;

        } else {

            //
            // Find a pointer to the last element in the list
            //
            pns = powner->pnsObjList;

            while ( pns->pnsOwnedNext != NULL )
            {

                //
                // Next element in the list
                //
                pns = pns->pnsOwnedNext;

            } 

            pns->pnsOwnedNext = pnsDeviceList;
        }

        //        //
        // Third pass pass, do callback for each device that is going away
        //
        for (pns = pnsDeviceList; pns != NULL; pns = pnsNext) {

            //
            // Remember what the next point is because we might nuke
            // the current object in the callback (if there is no
            // device extension associated with it
            //
            pnsNext = pns->pnsOwnedNext;

            //
            // Issue the callback. This might nuke the pnsObject
            //
            ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                DESTROYOBJ_REMOVE_OBJECT,
                pns,
                pns->ObjData.dwDataType
                );

        }

        //
        // We end by tell the ACPI driver that we have finished looking
        // at the list
        //
        ((PFNDOBJ)ghDestroyObj.pfnHandler)(DESTROYOBJ_END, &oldIrql, 0 );

    }
    else
    {
        for (pns = powner->pnsObjList; pns != NULL; pns = pnsNext)
        {
            pnsNext = pns->pnsOwnedNext;
            FreeNameSpaceObjects(pns);
        }
    }
    powner->pnsObjList = NULL;
    FREEOOOBJ(powner);

    EXIT(3, ("FreeObjOwner!\n"));
}       //FreeObjOwner

/***LP  InsertOwnerObjList - Insert the new object into the owner's object list
 *
 *  ENTRY
 *      powner -> owner
 *      pnsObj -> new object
 *
 *  EXIT
 *      None
 */

VOID LOCAL InsertOwnerObjList(POBJOWNER powner, PNSOBJ pnsObj)
{
    TRACENAME("INSERTOWNEROBJLIST")

    ENTER(3, ("InsertOwnerObjList(powner=%x,pnsObj=%x)\n",
              powner, pnsObj));

    pnsObj->hOwner = (HANDLE)powner;
    if (powner != NULL)
    {
        pnsObj->pnsOwnedNext = powner->pnsObjList;
        powner->pnsObjList = pnsObj;
    }

    EXIT(3, ("InsertOwnerObjList!\n"));
}       //InsertOwnerObjList

/***LP  FreeDataBuffs - Free any buffers attached to OBJDATA array
 *
 *  ENTRY
 *      adata -> OBJDATA array
 *      icData - number of data object in array
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeDataBuffs(POBJDATA adata, int icData)
{
    TRACENAME("FREEDATABUFFS")
    int i;

    ENTER(3, ("FreeDataBuffs(adata=%x,icData=%d)\n", adata, icData));

    for (i = 0; i < icData; ++i)
    {
        if (adata[i].pbDataBuff != NULL)
        {
            if (adata[i].dwfData & DATAF_BUFF_ALIAS)
            {
                //
                // decrement the base object's reference count.
                //
                adata[i].pdataBase->dwRefCount--;
            }
            else
            {
                //
                // We cannot free a base object buffer that has aliases on it.
                //
                ASSERT(adata[i].dwRefCount == 0);
                if (adata[i].dwDataType == OBJTYPE_PKGDATA)
                {
                    PPACKAGEOBJ ppkg = (PPACKAGEOBJ)adata[i].pbDataBuff;

                    FreeDataBuffs(ppkg->adata, ppkg->dwcElements);
                }
                ENTER(4, ("FreeData(i=%d,Buff=%x,Flags=%x)\n",
                          i, adata[i].pbDataBuff, adata[i].dwfData));
                FREEOBJDATA(&adata[i]);
                EXIT(4, ("FreeData!\n"));
            }
        }

        MEMZERO(&adata[i], sizeof(OBJDATA));
    }

    EXIT(3, ("FreeDataBuff!\n"));
}       //FreeDataBuffs

/***LP  PutIntObjData - put integer data into data object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> data object
 *      dwData -> data to be written
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PutIntObjData(PCTXT pctxt, POBJDATA pdataObj, ULONG dwData)
{
    TRACENAME("PUTINTOBJDATA")
    NTSTATUS rc = STATUS_SUCCESS;
    OBJDATA data;

    ENTER(3, ("PutIntObjData(pctxt=%x,pdataObj=%x,dwData=%x)\n",
              pctxt, pdataObj, dwData));

    MEMZERO(&data, sizeof(OBJDATA));
    data.dwDataType = OBJTYPE_INTDATA;
    data.uipDataValue = (ULONG_PTR)dwData;

    rc = WriteObject(pctxt, pdataObj, &data);

    EXIT(3, ("PutIntObjData=%x\n", rc));
    return rc;
}       //PutIntObjData

/***LP  GetFieldUnitRegionObj - Get the OperationRegion object of FieldUnit
 *
 *  ENTRY
 *      pfu -> FIELDUNITOBJ
 *      ppns -> to hold OperationRegion object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL GetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns)
{
    TRACENAME("GETFIELDUNITREGIONOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns;

    ENTER(3, ("GetFieldUnitRegionObj(pfu=%x,ppns=%x)\n", pfu, ppns));

    pns = pfu->pnsFieldParent;
    switch (pns->ObjData.dwDataType)
    {
        case OBJTYPE_BANKFIELD:
            *ppns = ((PBANKFIELDOBJ)pns->ObjData.pbDataBuff)->pnsBase;
            break;

        case OBJTYPE_FIELD:
            *ppns = ((PFIELDOBJ)pns->ObjData.pbDataBuff)->pnsBase;
            break;

        case OBJTYPE_INDEXFIELD:
            pns = ((PINDEXFIELDOBJ)pns->ObjData.pbDataBuff)->pnsData;
            ASSERT(pns->ObjData.dwDataType == OBJTYPE_FIELDUNIT);
            rc = GetFieldUnitRegionObj((PFIELDUNITOBJ)pns->ObjData.pbDataBuff,
                                       ppns);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("GetFieldUnitRegionObj: unknown field unit parent object type - %x",
                              (*ppns)->ObjData.dwDataType));
    }

    if ((*ppns != NULL) && ((*ppns)->ObjData.dwDataType != OBJTYPE_OPREGION))
    {
        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                         ("GetFieldUnitRegionObj: base object of field unit is not OperationRegion (BaseObj=%s,Type=%x)",
                          GetObjectPath(*ppns), (*ppns)->ObjData.dwDataType));
    }

    EXIT(3, ("GetFieldUnitRegionObj=%x (RegionObj=%x:%s)\n",
             rc, *ppns, GetObjectPath(*ppns)));
    return rc;
}       //GetFieldUnitRegionObj

/***LP  CopyObjData - Copy object data
 *
 *  ENTRY
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT
 *      None
 */

VOID LOCAL CopyObjData(POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("COPYOBJDATA")

    ENTER(3, ("CopyObjData(Dest=%x,Src=%x)\n", pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        if (pdataSrc->dwfData & DATAF_BUFF_ALIAS)
        {
            //
            // Source is an alias, so we need to increment the base object
            // reference count.
            //
            ASSERT(pdataSrc->pdataBase != NULL);
            pdataSrc->pdataBase->dwRefCount++;
        }
        else if (pdataSrc->pbDataBuff != NULL)
        {
            //
            // Source is a base object with buffer, increment its reference
            // count.
            //
            pdataSrc->dwRefCount++;
            pdataDst->dwfData |= DATAF_BUFF_ALIAS;
            pdataDst->pdataBase = pdataSrc;
        }
    }

    EXIT(3, ("CopyObjData!\n"));
}       //CopyObjData

/***LP  MoveObjData - Move object data
 *
 *  ENTRY
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT
 *      None
 */

VOID LOCAL MoveObjData(POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("MOVEOBJDATA")

    ENTER(3, ("MoveObjData(Dest=%x,Src=%x)\n", pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        //
        // We can only move an alias object or a base object with zero
        // reference count or a base object with no data buffer.
        //
        ASSERT((pdataSrc->dwfData & DATAF_BUFF_ALIAS) ||
               (pdataSrc->pbDataBuff == NULL) ||
               (pdataSrc->dwRefCount == 0));

        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        MEMZERO(pdataSrc, sizeof(OBJDATA));
    }

    EXIT(3, ("MoveObjData!\n"));
}       //MoveObjData

/***LP  DupObjData - Duplicate object data
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL DupObjData(PHEAP pheap, POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("DUPOBJDATA")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("DupObjData(pheap=%x,Dest=%x,Src=%x)\n",
              pheap, pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        if (pdataSrc->pbDataBuff != NULL)
        {
            if ((pdataDst->pbDataBuff = NEWOBJDATA(pheap, pdataSrc)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("DupObjData: failed to allocate destination buffer"));
            }
            else if (pdataSrc->dwDataType == OBJTYPE_PKGDATA)
            {
                PPACKAGEOBJ ppkgSrc = (PPACKAGEOBJ)pdataSrc->pbDataBuff,
                            ppkgDst = (PPACKAGEOBJ)pdataDst->pbDataBuff;
                int i;

                ppkgDst->dwcElements = ppkgSrc->dwcElements;
                for (i = 0; i < (int)ppkgSrc->dwcElements; ++i)
                {
                    if ((rc = DupObjData(pheap, &ppkgDst->adata[i],
                                         &ppkgSrc->adata[i])) != STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }
            else
            {
                MEMCPY(pdataDst->pbDataBuff, pdataSrc->pbDataBuff,
                       pdataSrc->dwDataLen);
            }
            pdataDst->dwfData &= ~DATAF_BUFF_ALIAS;
            pdataDst->dwRefCount = 0;
        }
    }

    EXIT(3, ("DupObjData=%x\n", rc));
    return rc;
}       //DupObjData

/***LP  CopyObjBuffer - Copy object data to a buffer
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      dwLen - buffer size
 *      pdata -> object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata)
{
    TRACENAME("COPYOBJBUFFER")
    NTSTATUS rc = STATUS_SUCCESS;
    PUCHAR pb = NULL;
    ULONG dwcb = 0;

    ENTER(3, ("CopyObjBuffer(pbBuff=%x,Len=%d,pdata=%x)\n",
              pbBuff, dwLen, pdata));

    switch (pdata->dwDataType)
    {
        case OBJTYPE_INTDATA:
            pb = (PUCHAR)&pdata->uipDataValue;
            dwcb = sizeof(ULONG);
            break;

        case OBJTYPE_STRDATA:
            pb = pdata->pbDataBuff;
            dwcb = pdata->dwDataLen - 1;
            break;

        case OBJTYPE_BUFFDATA:
            pb = pdata->pbDataBuff;
            dwcb = pdata->dwDataLen;
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("CopyObjBuffer: invalid source object type (type=%s)",
                              GetObjectTypeName(pdata->dwDataType)));
    }

    if ((rc == STATUS_SUCCESS) && (pbBuff != pb))
    {
        MEMZERO(pbBuff, dwLen);
        dwcb = MIN(dwLen, dwcb);
        MEMCPY(pbBuff, pb, dwcb);
    }

    EXIT(3, ("CopyObjBuffer=%x (CopyLen=%d)\n", rc, dwcb));
    return rc;
}       //CopyObjBuffer

/***LP  AcquireGL - acquire global lock
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AcquireGL(PCTXT pctxt)
{
    TRACENAME("ACQUIREGL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("AcquireGL(pctxt=%x)\n", pctxt));

    if (ghGlobalLock.pfnHandler != NULL)
    {
        ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
        rc = ((PFNGL)ghGlobalLock.pfnHandler)(EVTYPE_ACQREL_GLOBALLOCK,
                                              GLOBALLOCK_ACQUIRE,
                                              ghGlobalLock.uipParam,
                                              RestartCtxtCallback,
                                              &pctxt->CtxtData);
        if (rc == STATUS_PENDING)
        {
            rc = AMLISTA_PENDING;
        }
        else if (rc != STATUS_SUCCESS)
        {
            rc = AMLI_LOGERR(AMLIERR_ACQUIREGL_FAILED,
                             ("AcquireGL: failed to acquire global lock"));
        }
    }

    EXIT(3, ("AcquireGL=%x\n", rc));
    return rc;
}       //AcquireGL

/***LP  ReleaseGL - release global lock if acquired
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseGL(PCTXT pctxt)
{
    TRACENAME("RELEASEGL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ReleaseGL(pctxt=%x)\n", pctxt));

    if (ghGlobalLock.pfnHandler != NULL)
    {
        rc = ((PFNGL)ghGlobalLock.pfnHandler)(EVTYPE_ACQREL_GLOBALLOCK,
                                              GLOBALLOCK_RELEASE,
                                              ghGlobalLock.uipParam, NULL,
                                              &pctxt->CtxtData);
    }

    EXIT(3, ("ReleaseGL=%x\n", rc));
    return rc;
}       //ReleaseGL

/***LP  MapUnmapPhysMem - Map/Unmap physical memory
 *
 *  ENTRY
 *      pctxt -> CTXT (can be NULL if cannot handle STATUS_PENDING)
 *      uipAddr - physical address
 *      dwLen - length of memory range
 *      puipMappedAddr -> to hold memory address mapped (NULL if unmap)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL MapUnmapPhysMem(PCTXT pctxt, ULONG_PTR uipAddr, ULONG dwLen,
                               PULONG_PTR puipMappedAddr)
{
    TRACENAME("MAPUNMAPPHYSMEM")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("MapUnmapPhysMem(pctxt=%x,Addr=%x,Len=%d,pMappedAddr=%x)\n",
              pctxt, uipAddr, dwLen, puipMappedAddr));

    if (KeGetCurrentIrql() == PASSIVE_LEVEL)
    {
        if (puipMappedAddr != NULL)
        {
            *puipMappedAddr = MapPhysMem(uipAddr, dwLen);
        }
        else
        {
            MmUnmapIoSpace((PVOID)uipAddr, dwLen);
        }
    }
    else if (pctxt != NULL)
    {
        PPASSIVEHOOK pph;

        if ((pph = NEWPHOBJ(sizeof(PASSIVEHOOK))) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("MapUnmapPhysMem: failed to allocate passive hook"));
        }
        else
        {
            pph->pctxt = pctxt;
            pph->uipAddr = uipAddr;
            pph->dwLen = dwLen;
            pph->puipMappedAddr = puipMappedAddr;
            ExInitializeWorkItem(&pph->WorkItem, MapUnmapCallBack, pph);
            OSQueueWorkItem(&pph->WorkItem);

            rc = AMLISTA_PENDING;
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("MapUnmapPhysMem: IRQL is not at PASSIVE (IRQL=%x)",
                          KeGetCurrentIrql()));
    }

    EXIT(3, ("MapUnmapPhysMem=%x (MappedAddr=%x)\n",
             rc, puipMappedAddr? *puipMappedAddr: 0));
    return rc;
}       //MapUnmapPhysMem

/***LP  MapPhysMem - Map physical memory
 *
 *  ENTRY
 *      uipAddr - physical memory address
 *      dwLen - length of memory block
 *
 *  EXIT
 *      returns mapped address
 */

ULONG_PTR LOCAL MapPhysMem(ULONG_PTR uipAddr, ULONG dwLen)
{
    TRACENAME("MAPPHYSMEM")
    ULONG_PTR uipMappedAddr = 0;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    ENTER(3, ("MapPhysMem(Addr=%x,Len=%d)\n", uipAddr, dwLen));

    phyaddr.HighPart = 0;
    phyaddr.QuadPart = uipAddr;
    dwAddrSpace = 0;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        uipMappedAddr = (ULONG_PTR)MmMapIoSpace(XlatedAddr, dwLen, FALSE);
    }

    EXIT(3, ("MapPhysMem=%x", uipMappedAddr));
    return uipMappedAddr;
}       //MapPhysMem

/***LP  MapUnmapCallBack - Map/Unmap physical memory callback
 *
 *  ENTRY
 *      pph -> PASSIVEHOOK
 *
 *  EXIT
 *      None
 */

VOID MapUnmapCallBack(PPASSIVEHOOK pph)
{
    TRACENAME("MAPUNMAPCALLBACK")

    ENTER(3, ("MapUnmapCallBack(pph=%x,pctxt=%x,Addr=%x,Len=%d,pdwMappedAddr=%x)\n",
              pph, pph->pctxt, pph->uipAddr, pph->dwLen, pph->puipMappedAddr));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if (pph->puipMappedAddr != NULL)
    {
        *pph->puipMappedAddr = MapPhysMem(pph->uipAddr, pph->dwLen);
    }
    else
    {
        MmUnmapIoSpace((PVOID)pph->uipAddr, pph->dwLen);
    }

    RestartContext(pph->pctxt,
                   (BOOLEAN)((pph->pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));

    FREEPHOBJ(pph);

    EXIT(3, ("MapUnmapCallBack!\n"));
}       //MapUnmapCallBack

/***LP  MatchObjType - match object type
 *
 *  ENTRY
 *      dwObjType - object type
 *      dwExpected - expected type
 *
 *  EXIT-SUCCESS
 *      returns TRUE - type matched
 *  EXIT-FAILURE
 *      returns FALSE - type mismatch
 */

BOOLEAN LOCAL MatchObjType(ULONG dwObjType, ULONG dwExpectedType)
{
    TRACENAME("MATCHOBJTYPE")
    BOOLEAN rc = FALSE;

    ENTER(3, ("MatchObjType(ObjType=%s,Expected=%s)\n",
              GetObjectTypeName(dwObjType), GetObjectTypeName(dwExpectedType)));
    //
    // OBJTYPE_BUFFFIELD is essentially OBJTYPE_INTDATA, so we'll let
    // it pass the check.
    //
    if ((dwObjType == OBJTYPE_BUFFFIELD) &&
        (dwExpectedType == OBJTYPE_INTDATA))
    {
        rc = TRUE;
    }
    else if ((dwExpectedType == OBJTYPE_UNKNOWN) ||
             (dwObjType == OBJTYPE_UNKNOWN) ||
             (dwObjType == dwExpectedType))
    {
        rc = TRUE;
    }
    else
    {
        if ((dwObjType == OBJTYPE_INTDATA) ||
            (dwObjType == OBJTYPE_STRDATA) ||
            (dwObjType == OBJTYPE_BUFFDATA) ||
            (dwObjType == OBJTYPE_PKGDATA))
        {
            dwObjType = OBJTYPE_DATA;
        }
        else if ((dwObjType == OBJTYPE_FIELDUNIT) ||
                 (dwObjType == OBJTYPE_BUFFFIELD))
        {
            dwObjType = OBJTYPE_DATAFIELD;
        }

        if ((dwObjType == dwExpectedType) ||
            (dwExpectedType == OBJTYPE_DATAOBJ) &&
            ((dwObjType == OBJTYPE_DATA) || (dwObjType == OBJTYPE_DATAFIELD)))
        {
            rc = TRUE;
        }
    }

    EXIT(3, ("MatchObjType=%x\n", rc));
    return rc;
}       //MatchObjType

/***LP  ValidateTarget - Validate target object type
 *
 *  ENTRY
 *      pdataTarget -> target object data
 *      dwExpectedType - expected target object type
 *      ppdata -> to hold base target object data pointer
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ValidateTarget(POBJDATA pdataTarget, ULONG dwExpectedType,
                              POBJDATA *ppdata)
{
    TRACENAME("VALIDATETARGET")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ValidateTarget(pdataTarget=%x,ExpectedType=%s,ppdata=%x)\n",
              pdataTarget, GetObjectTypeName(dwExpectedType), ppdata));

    ASSERT(pdataTarget != NULL);
    if (pdataTarget->dwDataType == OBJTYPE_OBJALIAS)
    {
        *ppdata = &pdataTarget->pnsAlias->ObjData;
    }
    else if (pdataTarget->dwDataType == OBJTYPE_DATAALIAS)
    {
        *ppdata = pdataTarget->pdataAlias;
    }
    else if ((pdataTarget->dwDataType == OBJTYPE_UNKNOWN) ||
             (pdataTarget->dwDataType == OBJTYPE_BUFFFIELD) ||
             (pdataTarget->dwDataType == OBJTYPE_DEBUG))
    {
        *ppdata = pdataTarget;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_TARGETTYPE,
                         ("ValidateTarget: target is not a supername (Type=%s)",
                          GetObjectTypeName(pdataTarget->dwDataType)));
    }

    if ((rc == STATUS_SUCCESS) &&
        (pdataTarget->dwDataType == OBJTYPE_OBJALIAS) &&
        !MatchObjType((*ppdata)->dwDataType, dwExpectedType))
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_TARGETTYPE,
                         ("ValidateTarget: unexpected target type (Type=%s,Expected=%s)",
                          GetObjectTypeName((*ppdata)->dwDataType),
                          GetObjectTypeName(dwExpectedType)));
    }

    if ((rc == STATUS_SUCCESS) &&
        (pdataTarget->dwDataType != OBJTYPE_OBJALIAS) &&
        MatchObjType((*ppdata)->dwDataType, OBJTYPE_DATA))
    {
        FreeDataBuffs(*ppdata, 1);
    }

    EXIT(3, ("ValidateTarget=%x (pdataTarget=%x)\n", rc, *ppdata));
    return rc;
}       //ValidateTarget

/***LP  ValidateArgTypes - Validate argument types
 *
 *  ENTRY
 *      pArgs -> argument array
 *      pszExpectedTypes -> expected argument types string
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ValidateArgTypes(POBJDATA pArgs, PSZ pszExpectedTypes)
{
    TRACENAME("VALIDATEARGTYPES")
    NTSTATUS rc = STATUS_SUCCESS;
    int icArgs, i;

    ENTER(3, ("ValidateArgTypes(pArgs=%x,ExpectedTypes=%s)\n",
              pArgs, pszExpectedTypes));

    ASSERT(pszExpectedTypes != NULL);

    icArgs = STRLEN(pszExpectedTypes);
    for (i = 0; (rc == STATUS_SUCCESS) && (i < icArgs); ++i)
    {
        switch (pszExpectedTypes[i])
        {
            case ARGOBJ_UNKNOWN:
                break;

            case ARGOBJ_INTDATA:
                if (pArgs[i].dwDataType != OBJTYPE_INTDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Integer (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_STRDATA:
                if (pArgs[i].dwDataType != OBJTYPE_STRDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type String (Type-%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_BUFFDATA:
                if (pArgs[i].dwDataType != OBJTYPE_BUFFDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Buffer (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_PKGDATA:
                if (pArgs[i].dwDataType != OBJTYPE_PKGDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Package (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_FIELDUNIT:
                if (pArgs[i].dwDataType != OBJTYPE_FIELDUNIT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type FieldUnit (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_OBJALIAS:
                if (pArgs[i].dwDataType != OBJTYPE_OBJALIAS)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type ObjAlias (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_DATAALIAS:
                if (pArgs[i].dwDataType != OBJTYPE_DATAALIAS)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type DataAlias (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_BASICDATA:
                if ((pArgs[i].dwDataType != OBJTYPE_INTDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_STRDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_BUFFDATA))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type int/str/buff (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_COMPLEXDATA:
                if ((pArgs[i].dwDataType != OBJTYPE_BUFFDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_PKGDATA))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type buff/pkg (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_REFERENCE:
                if ((pArgs[i].dwDataType != OBJTYPE_OBJALIAS) &&
                    (pArgs[i].dwDataType != OBJTYPE_DATAALIAS) &&
                    (pArgs[i].dwDataType != OBJTYPE_BUFFFIELD))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type reference (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                 ("ValidateArgTypes: internal error (invalid type - %c)",
                                  pszExpectedTypes[i]));
        }
    }

    EXIT(3, ("ValidateArgTypes=%x\n", rc));
    return rc;
}       //ValidateArgTypes

/***LP  RegEventHandler - register event handler
 *
 *  ENTRY
 *      peh -> EVHANDLE
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegEventHandler(PEVHANDLE peh, PFNHND pfnHandler,
                               ULONG_PTR uipParam)
{
    TRACENAME("REGEVENTHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("RegEventHandler(peh=%x,pfnHandler=%x,Param=%x)\n",
              peh, pfnHandler, uipParam));

    if ((peh->pfnHandler != NULL) && (pfnHandler != NULL))
    {
        rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                         ("RegEventHandler: event handler already exist"));
    }
    else
    {
        peh->pfnHandler = pfnHandler;
        peh->uipParam = uipParam;
    }

    EXIT(3, ("RegEventHandler=%x\n", rc));
    return rc;
}       //RegEventHandler

/***LP  RegOpcodeHandler - register an opcode callback handler
 *
 *  The callback handler will be called after the opcode finishes its
 *  execution.  If an opcode has a variable list, the opcode handler
 *  will be called at the point of processing the closing brace.
 *
 *  ENTRY
 *      dwOpcode - opcode event to hook
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *      dwfOpcode - opcode flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegOpcodeHandler(ULONG dwOpcode, PFNOH pfnHandler,
                                ULONG_PTR uipParam, ULONG dwfOpcode)
{
    TRACENAME("REGOPCODEHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm;

    ENTER(3, ("RegOpcodeHandler(Opcode=%x,pfnHandler=%x,Param=%x,dwfOpcode=%x)\n",
              dwOpcode, pfnHandler, uipParam, dwfOpcode));

    if ((dwOpcode & 0xff) == OP_EXT_PREFIX)
        pamlterm = FindOpcodeTerm(dwOpcode >> 8, ExOpcodeTable);
    else
        pamlterm = OpcodeTable[dwOpcode];

    if (pamlterm == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_REGHANDLER_FAILED,
                         ("RegOpcodeHandler: either invalid opcode or "
                          "opcode does not allow callback"));
    }
    else if ((pamlterm->pfnCallBack != NULL) && (pfnHandler != NULL))
    {
        rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                         ("RegOpcodeHandler: opcode or opcode class already "
                          "has a handler"));
    }
    else
    {
        pamlterm->pfnCallBack = pfnHandler;
        pamlterm->dwCBData = (ULONG)uipParam;
        pamlterm->dwfOpcode |= dwfOpcode;
    }

    EXIT(3, ("RegOpcodeHandler=%x\n", rc));
    return rc;
}       //RegOpcodeHandler

/***LP  RegRSAccess - register region space cook/raw access handler
 *
 *  ENTRY
 *      dwRegionSpace - specifying the region space to handle
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *      fRaw - TRUE if registering raw access handler
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegRSAccess(ULONG dwRegionSpace, PFNHND pfnHandler,
                           ULONG_PTR uipParam, BOOLEAN fRaw)
{
    TRACENAME("REGRSACCESS")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("RegRSAccess(RegionSpace=%x,pfnHandler=%x,Param=%x,fRaw=%x)\n",
              dwRegionSpace, pfnHandler, uipParam, fRaw));

    if ((dwRegionSpace != REGSPACE_MEM) && (dwRegionSpace != REGSPACE_IO))
    {
        PRSACCESS prsa;

        if ((prsa = FindRSAccess(dwRegionSpace)) == NULL)
        {
            if ((prsa = NEWRSOBJ(sizeof(RSACCESS))) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("RegRSAccess: failed to allocate handler structure"));
            }
            else
            {
                MEMZERO(prsa, sizeof(RSACCESS));
                prsa->dwRegionSpace = dwRegionSpace;
                prsa->prsaNext = gpRSAccessHead;
                gpRSAccessHead = prsa;
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            if (fRaw)
            {
                if ((prsa->pfnRawAccess != NULL) && (pfnHandler != NULL))
                {
                    rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                                     ("RegRSAccess: RawAccess for RegionSpace %x "
                                      "already have a handler", dwRegionSpace));
                }
                else
                {
                    prsa->pfnRawAccess = (PFNRA)pfnHandler;
                    prsa->uipRawParam = uipParam;
                }
            }
            else
            {
                if ((prsa->pfnCookAccess != NULL) && (pfnHandler != NULL))
                {
                    rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                                     ("RegRSAccess: CookAccess for RegionSpace %x "
                                      "already have a handler", dwRegionSpace));
                }
                else
                {
                    prsa->pfnCookAccess = (PFNCA)pfnHandler;
                    prsa->uipCookParam = uipParam;
                }
            }
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                         ("RegRSAccess: illegal region space - %x",
                          dwRegionSpace));
    }

    EXIT(3, ("RegRSAccess=%x\n", rc));
    return rc;
}       //RegRSAccess

/***LP  FindRSAccess - Find RSACCESS structure with a given RegionSpace
 *
 *  ENTRY
 *      dwRegionSpace - region space
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the structure found
 *  EXIT-FAILURE
 *      returns NULL
 */

PRSACCESS LOCAL FindRSAccess(ULONG dwRegionSpace)
{
    TRACENAME("FINDRSACCESS")
    PRSACCESS prsa;

    ENTER(3, ("FindRSAccess(RegionSpace=%x)\n", dwRegionSpace));

    for (prsa = gpRSAccessHead; prsa != NULL; prsa = prsa->prsaNext)
    {
        if (prsa->dwRegionSpace == dwRegionSpace)
            break;
    }

    EXIT(3, ("FindRSAccess=%x\n", prsa));
    return prsa;
}       //FindRSAccess

/***LP  FreeRSAccessList - free the RSACCESS structure list
 *
 *  ENTRY
 *      prsa -> RSACCESS list
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeRSAccessList(PRSACCESS prsa)
{
    TRACENAME("FREERSACCESSLIST")
    PRSACCESS prsaNext;

    ENTER(3, ("FreeRSAccessList(prsa=%x)\n", prsa));

    while (prsa != NULL)
    {
        prsaNext = prsa->prsaNext;
        FREERSOBJ(prsa);
        prsa = prsaNext;
    }

    EXIT(3, ("FreeRSAccessList!\n"));
}       //FreeRSAccessList

/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PNSOBJ pns)
{
    TRACENAME("GETOBJECTPATH")
    static char szPath[MAX_NAME_LEN + 1] = {0};
    int i;

    ENTER(4, ("GetObjectPath(pns=%x)\n", pns));

    if (pns != NULL)
    {
        if (pns->pnsParent == NULL)
            STRCPY(szPath, "\\");
        else
        {
            GetObjectPath(pns->pnsParent);
            if (pns->pnsParent->pnsParent != NULL)
                STRCAT(szPath, ".");
            STRCATN(szPath, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
        }


        for (i = STRLEN(szPath) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }

    EXIT(4, ("GetObjectPath=%s\n", szPath));
    return szPath;
}       //GetObjectPath

#ifdef DEBUGGER

/***LP  NameSegString - convert a NameSeg to an ASCIIZ string
 *
 *  ENTRY
 *      dwNameSeg - NameSeg
 *
 *  EXIT
 *      returns string
 */

PSZ LOCAL NameSegString(ULONG dwNameSeg)
{
    TRACENAME("NAMESEGSTRING")
    static char szNameSeg[sizeof(NAMESEG) + 1] = {0};

    ENTER(5, ("NameSegString(dwNameSeg=%x)\n", dwNameSeg));

    STRCPYN(szNameSeg, (PSZ)&dwNameSeg, sizeof(NAMESEG));

    EXIT(5, ("NameSegString=%s\n", szNameSeg));
    return szNameSeg;
}       //NameSegString


/***LP  GetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetObjectTypeName(ULONG dwObjType)
{
    TRACENAME("GETOBJECTTYPENAME")
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            0,                  NULL
        };

    ENTER(4, ("GetObjectTypeName(Type=%x)\n", dwObjType));

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    EXIT(4, ("GetObjectTypeName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetObjectTypeName

/***LP  GetRegionSpaceName - get region space name
 *
 *  ENTRY
 *      bRegionSpace - region space
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace)
{
    TRACENAME("GETREGIONSPACENAME")
    PSZ psz = NULL;
    int i;
    static PSZ pszVendorDefined = "VendorDefined";
    static struct
    {
        UCHAR bRegionSpace;
        PSZ   pszRegionSpaceName;
    } RegionNameTable[] =
        {
            REGSPACE_MEM,       "SystemMemory",
            REGSPACE_IO,        "SystemIO",
            REGSPACE_PCICFG,    "PCIConfigSpace",
            REGSPACE_EC,        "EmbeddedController",
            REGSPACE_SMB,       "SMBus",
            0,                  NULL
        };

    ENTER(4, ("GetRegionSpaceName(RegionSpace=%x)\n", bRegionSpace));

    for (i = 0; RegionNameTable[i].pszRegionSpaceName != NULL; ++i)
    {
        if (bRegionSpace == RegionNameTable[i].bRegionSpace)
        {
            psz = RegionNameTable[i].pszRegionSpaceName;
            break;
        }
    }

    if (psz == NULL)
    {
        psz = pszVendorDefined;
    }

    EXIT(4, ("GetRegionSpaceName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetRegionSpaceName
#endif  //ifdef DEBUGGER

/***LP  ValidateTable - Validate the table creator and revision
 *
 *  ENTRY
 *      pdsdt -> DSDT
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL ValidateTable(PDSDT pdsdt)
{
    TRACENAME("VALIDATETABLE")
    BOOLEAN rc = TRUE;

    ENTER(3, ("ValidateTable(pdsdt=%x)\n", pdsdt));

    if (!(gdwfAMLIInit & AMLIIF_NOCHK_TABLEVER) &&
        (STRCMPN((PSZ)pdsdt->Header.CreatorID, CREATORID_MSFT,
                 sizeof(pdsdt->Header.CreatorID)) == 0))
    {
        if (pdsdt->Header.CreatorRev < MIN_CREATOR_REV)
        {
            rc = FALSE;
        }
    }

    EXIT(3, ("ValidateTable=%x\n", rc));
    return rc;
}       //ValidateTable

/***LP  NewObjData - allocate new object data identical to a given old object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pdata -> old object
 *
 *  EXIT-SUCCESS
 *      returns pointer to the new data
 *  EXIT-FAILURE
 *      returns NULL
 */

PVOID LOCAL NewObjData(PHEAP pheap, POBJDATA pdata)
{
    PVOID pv = NULL;

    switch (pdata->dwDataType)
    {
        case OBJTYPE_STRDATA:
            pv = NEWSDOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_BUFFDATA:
            pv = NEWBDOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            pv = NEWPKOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_FIELDUNIT:
            pv = NEWFUOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_EVENT:
            pv = NEWEVOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_METHOD:
            pv = NEWMEOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_MUTEX:
            pv = NEWMTOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_OPREGION:
            pv = NEWOROBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_POWERRES:
            pv = NEWPROBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_PROCESSOR:
            pv = NEWPCOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_BUFFFIELD:
            pv = NEWBFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_BANKFIELD:
            pv = NEWKFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_FIELD:
            pv = NEWFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_INDEXFIELD:
            pv = NEWIFOBJ(pheap, pdata->dwDataLen);
            break;

        default:
            AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                        ("NewObjData: invalid object type %s",
                         GetObjectTypeName(pdata->dwDataType)));
    }

    return pv;
}       //NewObjData

/***LP  FreeObjData - Free object data
 *
 *  ENTRY
 *      pdata -> object which its data is to be freed
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeObjData(POBJDATA pdata)
{
    switch (pdata->dwDataType)
    {
        case OBJTYPE_STRDATA:
            FREESDOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            FREEBDOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_PKGDATA:
            FREEPKOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_FIELDUNIT:
            FREEFUOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_EVENT:
            FREEEVOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_METHOD:
            FREEMEOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_MUTEX:
            FREEMTOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_OPREGION:
            FREEOROBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_POWERRES:
            FREEPROBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_PROCESSOR:
            FREEPCOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFFIELD:
            FREEBFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BANKFIELD:
            FREEKFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_FIELD:
            FREEFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_INDEXFIELD:
            FREEIFOBJ(pdata->pbDataBuff);
            break;

        default:
            AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                        ("FreeObjData: invalid object type %s",
                         GetObjectTypeName(pdata->dwDataType)));
    }
}       //FreeObjData

/*** LP InitializeRegOverrideFlags - Get override flags from
 *                                   the registry.
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */
VOID LOCAL InitializeRegOverrideFlags(VOID)
{
    TRACENAME("InitializeRegOverrideFlags")
    HANDLE hRegKey=NULL;
    NTSTATUS status;
    ULONG argSize;

    ENTER(3, ("InitializeRegOverrideFlags\n"));
        
    status = OSOpenHandle(ACPI_PARAMETERS_REGISTRY_KEY, NULL, &hRegKey);
    if (NT_SUCCESS(status))
    {
        argSize = sizeof(gOverrideFlags);
        OSReadRegValue(AMLI_ATTRIBUTES, hRegKey, &gOverrideFlags, &argSize);
    }
    else
    {
        gOverrideFlags = 0;
    }
    
    EXIT(3, ("InitializeRegOverrideFlags\n"));
    return;
}


/*** LP ValidateMemoryOpregionRange - Validate the memory range that is
 *                                    required for the memory opregion.
 *
 *  ENTRY
 *      uipAddr - physical memory address
 *      dwLen - length of memory block
 *
 *  EXIT
 *      returns TRUE iff the memory is in the legal range.
 */
BOOLEAN LOCAL ValidateMemoryOpregionRange(ULONG_PTR uipAddr, ULONG dwLen)
{
    BOOLEAN                                 Ret = FALSE;
    NTSTATUS                                status;
    PACPI_BIOS_MULTI_NODE                   e820Info;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR         cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST               cmPartialList;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    ULONGLONG                               i;
    ULONGLONG                               absMin;
    ULONGLONG                               absMax;
    
    
    //
    // Read the key for the AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );

    if (!NT_SUCCESS(status)) 
    {
        PRINTF("ValidateMemoryOpregionRange: Cannot get E820 Information %08lx\n",
                status
              );
        Ret = TRUE;
    }
    else
    {
        //
        // Crack the structure to get the E820Table entry
        //
        cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
        cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
        e820Info = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc + sizeof(CM_PARTIAL_RESOURCE_LIST) );

        //
        // Calculate absmin and absmax for the incoming address
        //
        absMin = (ULONGLONG)uipAddr;
        absMax = absMin + dwLen;
        
        //
        // walk the E820 list
        //
        for(i = 0; i < e820Info->Count; i++) 
        {
            if (e820Info->E820Entry[i].Type == AcpiAddressRangeMemory) 
            {
                if(absMax < (ULONGLONG)PAGE_SIZE)
                {
                    Ret = TRUE;
                    PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is in first physical page, skipping check.\n",
                           absMin,
                           dwLen
                           );
                }
                else
                {
                    if((absMax < (ULONGLONG) e820Info->E820Entry[i].Base.QuadPart)
                      ||(absMin >= (ULONGLONG) (e820Info->E820Entry[i].Base.QuadPart + e820Info->E820Entry[i].Length.QuadPart)))
                    {
                        Ret = TRUE;
                        PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is not in AcpiAddressRangeMemory (Base = 0x%I64x, Length = 0x%I64x)\n",
                               absMin,
                               dwLen,
                               e820Info->E820Entry[i].Base.QuadPart,
                               e820Info->E820Entry[i].Length.QuadPart
                               );
                    }
                    else
                    {
                        //
                        // This opregion is mapping memory that belongs to the OS.
                        // Log a error in the event log.
                        //

                        PWCHAR illegalMemoryAddress[5];
                        WCHAR AMLIName[6];
                        WCHAR addressBuffer[64];
                        WCHAR addressLengthBuffer[64];
                        WCHAR OSaddressBufferRangeMin[64];
                        WCHAR OSaddressBufferRangeMax[64];
                                           
                        //
                        // Turn the address into a string
                        //
                        swprintf( AMLIName, L"AMLI");
                        swprintf( addressBuffer, L"0x%I64x", absMin );
                        swprintf( addressLengthBuffer, L"0x%lx", dwLen );
                        swprintf( OSaddressBufferRangeMin, L"0x%I64x", e820Info->E820Entry[i].Base.QuadPart );
                        swprintf( OSaddressBufferRangeMax, L"0x%I64x", e820Info->E820Entry[i].Base.QuadPart +  e820Info->E820Entry[i].Length.QuadPart);

                        
                        //
                        // Build the list of arguments to pass to the function that will write the
                        // error log to the registry
                        //
                        illegalMemoryAddress[0] = AMLIName;
                        illegalMemoryAddress[1] = addressBuffer;
                        illegalMemoryAddress[2] = addressLengthBuffer;
                        illegalMemoryAddress[3] = OSaddressBufferRangeMin;
                        illegalMemoryAddress[4] = OSaddressBufferRangeMax;

                        //
                        // Log error to event log
                        //
                        ACPIWriteEventLogEntry(ACPI_ERR_AMLI_ILLEGAL_MEMORY_OPREGION_FATAL,
                                           &illegalMemoryAddress,
                                           5,
                                           NULL,
                                           0);        


                        PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is in AcpiAddressRangeMemory (Base = 0x%I64x, Length = 0x%I64x)\n",
                               absMin,
                               dwLen,
                               e820Info->E820Entry[i].Base.QuadPart,
                               e820Info->E820Entry[i].Length.QuadPart
                               );
                        Ret = FALSE;
                        break;
                    }
                }
            }
        }
    }

    //
    // Free the E820 info
    //
    ExFreePool( keyInfo );
  
    return Ret;
}

#ifdef DEBUG
/*** LP FreeMem - Free memory object
 *
 *  ENTRY
 *      pv -> memory object to be freed
 *      pdwcObjs -> object counter to be decremented
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeMem(PVOID pv, PULONG pdwcObjs)
{
    if (*pdwcObjs != 0)
    {
        ExFreePool(pv);
        (*pdwcObjs)--;
    }
    else
    {
        AMLI_ERROR(("FreeMem: Unbalanced MemFree"));
    }
}       //FreeMem

/*** LP CheckGlobalHeap - Make sure that the global heap has not become
 *                        corrupted
 *
 *  ENTRY
 *      None
 *
 *  Exit
 *      None
 */
VOID LOCAL CheckGlobalHeap()
{
    KIRQL oldIrql;

    //
    // We don't care about this is we are loading a DDB
    //
    if (gdwfAMLI & AMLIF_LOADING_DDB) {

        return;

    }

    //
    // Must have spinlock protection...
    //
    KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );

    //
    // We only care if they don't match...
    //
    if (gdwGlobalHeapSize == gdwGHeapSnapshot) {

        goto CheckGlobalHeapExit;

    }

    //
    // If the new heap size is smaller than the current size, then
    // we shrunk the heap and that is good...
    //
    if (gdwGlobalHeapSize < gdwGHeapSnapshot) {

        //
        // Remember the new "snapshot size"
        //
        gdwGHeapSnapshot = gdwGlobalHeapSize;
        goto CheckGlobalHeapExit;

    }

    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON) {

        AMLI_WARN(("CheckGlobalHeap: "
                   "potential memory leak "
                   "detected (CurrentHeapSize=%d,"
                   "ReferenceSize=%d)",
                   gdwGlobalHeapSize,
                   gdwGHeapSnapshot));

    }
    if (gdwGlobalHeapSize - gdwGHeapSnapshot > 8192) {

        AMLI_WARN(("CheckGlobalHeap: detected memory leak"));
        KdBreakPoint();

    }

CheckGlobalHeapExit:

    //
    // Release the lock and we are done
    //
    KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
}
#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\proto.h ===
/*** proto.h - Local function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PROTO_H
#define _PROTO_H

//parser.c
NTSTATUS LOCAL ParseScope(PCTXT pctxt, PSCOPE pscope, NTSTATUS rc);
NTSTATUS LOCAL ParseCall(PCTXT pctxt, PCALL pcall, NTSTATUS rc);
NTSTATUS LOCAL ParseNestedContext(PCTXT pctxt, PNESTEDCTXT pnctxt, NTSTATUS rc);
NTSTATUS LOCAL ParseTerm(PCTXT pctxt, PTERM pterm, NTSTATUS rc);
NTSTATUS LOCAL ParseAcquire(PCTXT pctxt, PACQUIRE pacq, NTSTATUS rc);
NTSTATUS LOCAL ParseOpcode(PCTXT pctxt, PUCHAR pbScopeEnd,
                           POBJDATA pdataResult);
NTSTATUS LOCAL ParseArgObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseLocalObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseNameObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseArg(PCTXT pctxt, char chArgType, POBJDATA pdataArg);
NTSTATUS LOCAL ParseAndGetNameSpaceObject(PUCHAR *ppbOp, PNSOBJ pnsScope,
                                          PPNSOBJ ppns, BOOLEAN fAbsentOK);
NTSTATUS LOCAL ParseSuperName(PCTXT pctxt, POBJDATA pdata, BOOLEAN fAbsentOK);
NTSTATUS LOCAL ParseIntObj(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseString(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseObjName(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseName(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen);
NTSTATUS LOCAL ParseNameTail(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen);
NTSTATUS LOCAL ParseInteger(PUCHAR *ppbOp, POBJDATA pdata, ULONG dwDataLen);
NTSTATUS LOCAL ParseField(PCTXT pctxt, PNSOBJ pnsParent, PULONG pdwFieldFlags,
                          PULONG pdwBitPos);
NTSTATUS LOCAL ParseFieldList(PCTXT pctxt, PUCHAR pbOpEnd, PNSOBJ pnsParent,
                              ULONG dwFieldFlags, ULONG dwRegionLen);
ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext);

//ctxt.c
NTSTATUS LOCAL NewContext(PPCTXT ppctxt);
VOID LOCAL FreeContext(PCTXT pctxt);
VOID LOCAL InitContext(PCTXT pctxt, ULONG dwLen);
BOOLEAN LOCAL IsStackEmpty(PCTXT pctxt);
NTSTATUS LOCAL PushFrame(PCTXT pctxt, ULONG dwSig, ULONG dwLen,
                         PFNPARSE pfnParse, PVOID *ppvFrame);
VOID LOCAL PopFrame(PCTXT pctxt);
NTSTATUS LOCAL PushPost(PCTXT pctxt, PFNPARSE pfnPost, ULONG_PTR uipData1,
                        ULONG_PTR uipData2, POBJDATA pdataResult);
NTSTATUS LOCAL PushScope(PCTXT pctxt, PUCHAR pbOpBegin, PUCHAR pbOpEnd,
                         PUCHAR pbOpRet, PNSOBJ pnsScope, POBJOWNER powner,
                         PHEAP pheap, POBJDATA pdataResult);
NTSTATUS LOCAL PushCall(PCTXT pctxt, PNSOBJ pnsMethod, POBJDATA pdataResult);
NTSTATUS LOCAL PushTerm(PCTXT pctxt, PUCHAR pbOpTerm, PUCHAR pbScopeEnd,
                        PAMLTERM pamlterm, POBJDATA pdataResult);
NTSTATUS LOCAL RunContext(PCTXT pctxt);

//heap.c
NTSTATUS LOCAL NewHeap(ULONG dwLen, PHEAP *ppheap);
VOID LOCAL FreeHeap(PHEAP pheap);
VOID LOCAL InitHeap(PHEAP pheap, ULONG dwLen);
PVOID LOCAL HeapAlloc(PHEAP pheap, ULONG dwSig, ULONG dwLen);
VOID LOCAL HeapFree(PVOID pb);
PHEAPOBJHDR LOCAL HeapFindFirstFit(PHEAP pheap, ULONG dwLen);
VOID LOCAL HeapInsertFreeList(PHEAP pheap, PHEAPOBJHDR phobj);

//acpins.c
NTSTATUS LOCAL GetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                                  ULONG dwfNS);
NTSTATUS LOCAL CreateNameSpaceObject(PHEAP pheap, PSZ pszName, PNSOBJ pnsScope,
                                     POBJOWNER powner, PPNSOBJ ppns,
                                     ULONG dwfNS);
VOID LOCAL FreeNameSpaceObjects(PNSOBJ pnsObj);
NTSTATUS LOCAL LoadDDB(PCTXT pctxt, PDSDT pdsdt, PNSOBJ pnsScope,
                       POBJOWNER *ppowner);
NTSTATUS LOCAL LoadMemDDB(PCTXT pctxt, PDSDT pDDB, POBJOWNER *ppowner);
NTSTATUS LOCAL LoadFieldUnitDDB(PCTXT pctxt, POBJDATA pdataObj,
                                POBJOWNER *ppowner);
VOID LOCAL UnloadDDB(POBJOWNER powner);
NTSTATUS LOCAL EvalPackageElement(PPACKAGEOBJ ppkg, int iPkgIndex,
                                  POBJDATA pdataResult);
#ifdef DEBUGGER
LONG LOCAL DumpNameSpaceObject(PSZ pszPath, BOOLEAN fRecursive);
VOID LOCAL DumpNameSpaceTree(PNSOBJ pnsObj, ULONG dwLevel);
#endif

//nsmod.c
NTSTATUS LOCAL Alias(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Name(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Scope(PCTXT pctxt, PTERM pterm);

//namedobj.c
NTSTATUS LOCAL BankField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateXField(PCTXT pctxt, PTERM pterm, POBJDATA pdataTarget,
                            PBUFFFIELDOBJ *ppbf);
NTSTATUS LOCAL CreateBitField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateByteField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateWordField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateDWordField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Device(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL InitEvent(PHEAP pheap, PNSOBJ pns);
NTSTATUS LOCAL Event(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Field(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL IndexField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Method(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL InitMutex(PHEAP pheap, PNSOBJ pns, ULONG dwLevel);
NTSTATUS LOCAL Mutex(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL OpRegion(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL PowerRes(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Processor(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ThermalZone(PCTXT pctxt, PTERM pterm);

//type1op.c
NTSTATUS LOCAL Break(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL BreakPoint(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Fatal(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL IfElse(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Load(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Notify(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ReleaseResetSignalUnload(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Return(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL SleepStall(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL While(PCTXT pctxt, PTERM pterm);

//type2op.c
NTSTATUS LOCAL Buffer(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Package(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ParsePackage(PCTXT pctxt, PPACKAGE ppkg, NTSTATUS rc);
NTSTATUS LOCAL Acquire(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Concat(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL DerefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ExprOp1(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ExprOp2(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Divide(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessDivide(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL IncDec(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessIncDec(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL Index(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL LNot(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL LogOp2(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ObjTypeSizeOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL RefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CondRefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Store(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Wait(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessWait(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL Match(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL StoreRef(PCTXT pctxt, PTERM pterm);
BOOLEAN LOCAL MatchData(ULONG dwPkgData, ULONG dwOp, ULONG dwData);
NTSTATUS LOCAL OSInterface(PCTXT pctxt, PTERM pterm);

//object.c
NTSTATUS LOCAL ReadObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataResult);
NTSTATUS LOCAL WriteObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataSrc);
NTSTATUS LOCAL AccFieldUnit(PCTXT pctxt, PACCFIELDUNIT pafu, NTSTATUS rc);
NTSTATUS LOCAL ReadField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                         POBJDATA pdataResult);
NTSTATUS LOCAL WriteField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                          POBJDATA pdataSrc);
NTSTATUS LOCAL WriteFieldLoop(PCTXT pctxt, PWRFIELDLOOP pwfl, NTSTATUS rc);
NTSTATUS LOCAL PushAccFieldObj(PCTXT pctxt, PFNPARSE pfnAcc, POBJDATA pdataObj,
                               PFIELDDESC pfd, PUCHAR pb, ULONG dwcb);
NTSTATUS LOCAL ReadFieldObj(PCTXT pctxt, PVOID pafo, NTSTATUS rc);
NTSTATUS LOCAL WriteFieldObj(PCTXT pctxt, PVOID pafo, NTSTATUS rc);
NTSTATUS LOCAL RawFieldAccess(PCTXT pctxt, ULONG dwAccType, POBJDATA pdataObj,
                              POBJDATA pdataResult);
NTSTATUS LOCAL AccessFieldData(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead);
NTSTATUS LOCAL PushPreserveWriteObj(PCTXT pctxt, POBJDATA pdataObj,
                                    ULONG dwData, ULONG dwPreserveMask);
NTSTATUS LOCAL PreserveWriteObj(PCTXT pctxt, PPRESERVEWROBJ ppwro, NTSTATUS rc);
NTSTATUS LOCAL AccessBaseField(PCTXT pctxt, PNSOBJ pnsBase, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead);
NTSTATUS LOCAL WriteCookAccess(PCTXT pctxt, PWRCOOKACC pwca, NTSTATUS rc);
NTSTATUS LOCAL ReadBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd,
                             PULONG pdwData);
NTSTATUS LOCAL WriteBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, ULONG dwData);
ULONG LOCAL ReadSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwMask);
VOID LOCAL WriteSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwData,
                          ULONG dwMask);
ULONG LOCAL ReadSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwMask);
VOID LOCAL WriteSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwData);
#ifdef DEBUGGER
VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel);
#endif
BOOLEAN LOCAL NeedGlobalLock(PFIELDUNITOBJ pfu);
NTSTATUS LOCAL QueueCookAccess(PCTXT pctxt, PRSACCESS prsa, ULONG dwAccType,
                               PNSOBJ pnsBase, ULONG dwAddr, ULONG dwSize);
BOOLEAN LOCAL CheckSystemIOAddressValidity( BOOLEAN fRead, ULONG dwAddr, ULONG dwSize, PULONG pdwData);
VOID DelayedLogInErrorLog( IN PDEVICE_OBJECT DeviceObject, IN PVOID Context);
VOID LOCAL LogInErrorLog(BOOLEAN fRead, ULONG dwAddr, ULONG ArrayIndex);
VOID LOCAL InitIllegalIOAddressListFromHAL(VOID);
VOID LOCAL FreellegalIOAddressList(VOID);

//sleep.c
NTSTATUS LOCAL SleepQueueRequest(IN PCTXT Context, IN ULONG SleepTime);
VOID SleepQueueDpc(PKDPC Dpc, PVOID Context, PVOID Argument1, PVOID Argument2);
NTSTATUS LOCAL ProcessSleep(PCTXT pctxt, PSLEEP psleep, NTSTATUS rc);

//sync.c
VOID LOCAL AsyncCallBack(PCTXT pctxt, NTSTATUS rcCtxt);
VOID EXPORT EvalMethodComplete(PCTXT pctxt, NTSTATUS rc, PSYNCEVENT pse);
NTSTATUS LOCAL SyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                              POBJDATA pArgs);
NTSTATUS LOCAL AsyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                               POBJDATA pArgs, PFNACB pfnAsyncCallBack,
                               PVOID pvContext, BOOLEAN fAsync);
NTSTATUS LOCAL NestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                   int icArgs, POBJDATA pdataArgs,
                                   PFNACB pfnAsyncCallBack, PVOID pvContext,
                                   BOOLEAN fAsync);
NTSTATUS LOCAL ProcessEvalObj(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
VOID TimeoutCallback(PKDPC pkdpc, PVOID pctxt, PVOID SysArg1, PVOID SysArg2);
VOID LOCAL QueueContext(PCTXT pctxt, USHORT wTimeout, PPLIST pplist);
PCTXT LOCAL DequeueAndReadyContext(PPLIST pplist);
NTSTATUS LOCAL AcquireASLMutex(PCTXT pctxt, PMUTEXOBJ pm, USHORT wTimeout);
NTSTATUS LOCAL ReleaseASLMutex(PCTXT pctxt, PMUTEXOBJ pm);
NTSTATUS LOCAL WaitASLEvent(PCTXT pctxt, PEVENTOBJ pe, USHORT wTimeout);
VOID LOCAL ResetASLEvent(PEVENTOBJ pe);
VOID LOCAL SignalASLEvent(PEVENTOBJ pe);
NTSTATUS LOCAL SyncLoadDDB(PCTXT pctxt);

//sched.c
VOID ExpireTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2);
VOID StartTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2);
VOID StartTimeSlicePassive(PCTXTQ pctxtq);
VOID LOCAL DispatchCtxtQueue(PCTXTQ pctxtq);
NTSTATUS LOCAL InsertReadyQueue(PCTXT pctxt, BOOLEAN fDelayExecute);
NTSTATUS LOCAL RestartContext(PCTXT pctxt, BOOLEAN fDelayExecute);
VOID RestartCtxtPassive(PRESTART prest);
VOID EXPORT RestartCtxtCallback(PCTXTDATA pctxtdata);

//misc.c
VOID LOCAL InitializeMutex(PMUTEX pmut);
BOOLEAN LOCAL AcquireMutex(PMUTEX pmut);
BOOLEAN LOCAL ReleaseMutex(PMUTEX pmut);
PAMLTERM LOCAL FindOpcodeTerm(ULONG dwOp, POPCODEMAP pOpTable);
ULONG LOCAL GetHackFlags(PDSDT pdsdt);
PNSOBJ LOCAL GetBaseObject(PNSOBJ pnsObj);
POBJDATA LOCAL GetBaseData(POBJDATA pdataObj);
NTSTATUS LOCAL NewObjOwner(PHEAP pheap, POBJOWNER *ppowner);
VOID LOCAL FreeObjOwner(POBJOWNER powner, BOOLEAN fUnload);
VOID LOCAL InsertOwnerObjList(POBJOWNER powner, PNSOBJ pnsObj);
VOID LOCAL FreeDataBuffs(POBJDATA adata, int icData);
NTSTATUS LOCAL PutIntObjData(PCTXT pctxt, POBJDATA pdataObj, ULONG dwData);
NTSTATUS LOCAL GetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns);
NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata);
VOID LOCAL CopyObjData(POBJDATA pdataDst, POBJDATA pdataSrc);
VOID LOCAL MoveObjData(POBJDATA pdataDst, POBJDATA pdataSrc);
NTSTATUS LOCAL DupObjData(PHEAP pheap, POBJDATA pdataDst, POBJDATA pdataSrc);
NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata);
NTSTATUS LOCAL AcquireGL(PCTXT pctxt);
NTSTATUS LOCAL ReleaseGL(PCTXT pctxt);
NTSTATUS LOCAL MapUnmapPhysMem(PCTXT pctxt, ULONG_PTR uipAddr, ULONG dwLen,
                               PULONG_PTR puipMappedAddr);
ULONG_PTR LOCAL MapPhysMem(ULONG_PTR uipAddr, ULONG dwLen);
VOID MapUnmapCallBack(PPASSIVEHOOK pph);
BOOLEAN LOCAL MatchObjType(ULONG dwObjType, ULONG dwExpectedType);
NTSTATUS LOCAL ValidateTarget(POBJDATA pdataTarget, ULONG dwExpectedType,
                              POBJDATA *ppdata);
NTSTATUS LOCAL ValidateArgTypes(POBJDATA pArgs, PSZ pszExpectedTypes);
NTSTATUS LOCAL RegEventHandler(PEVHANDLE peh, PFNHND pfnHandler,
                               ULONG_PTR uipParam);
NTSTATUS LOCAL RegOpcodeHandler(ULONG dwOpcode, PFNOH pfnHandler,
                                ULONG_PTR uipParam, ULONG dwfOpcode);
NTSTATUS LOCAL RegRSAccess(ULONG dwRegionSpace, PFNHND pfnHandler,
                           ULONG_PTR uipParam, BOOLEAN fRaw);
PRSACCESS LOCAL FindRSAccess(ULONG dwRegionSpace);
VOID LOCAL FreeRSAccessList(PRSACCESS prsa);
PSZ LOCAL GetObjectPath(PNSOBJ pns);

#ifdef DEBUGGER
PSZ LOCAL NameSegString(ULONG dwNameSeg);
PSZ LOCAL GetObjectTypeName(ULONG dwObjType);
PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace);
#endif
BOOLEAN LOCAL ValidateTable(PDSDT pdsdt);
PVOID LOCAL NewObjData(PHEAP pheap, POBJDATA pdata);
VOID LOCAL FreeObjData(POBJDATA pdata);
VOID LOCAL InitializeRegOverrideFlags(VOID);
BOOLEAN LOCAL ValidateMemoryOpregionRange(ULONG_PTR uipAddr, ULONG dwLen);

#ifdef DEBUG
VOID LOCAL FreeMem(PVOID pv, PULONG pdwcObjs);
VOID LOCAL CheckGlobalHeap();
#endif

#endif  //ifndef _PROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\sched.c ===
/*** sched.c - AML thread scheduler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ExpireTimeSlice - DPC callback for time slice expiration
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxtq -> CTXTQ
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID ExpireTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("EXPIRETIMESLICE")

    ENTER(2, ("ExpireTimeSlice(pkdpc=%x,pctxtq=%x,SysArg1=%x,SysArg2=%x\n",
              pkdpc, pctxtq, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    pctxtq->dwfCtxtQ |= CQF_TIMESLICE_EXPIRED;

    EXIT(2, ("ExpireTimeSlice!\n"));
}       //ExpireTimeSlice

/***LP  StartTimeSlice - Timer callback to start a new time slice
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxtq -> CTXTQ
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID StartTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("STARTTIMESLICE")

    ENTER(2, ("StartTimeSlice(pkdpc=%x,pctxtq=%x,SysArg1=%x,SysArg2=%x\n",
              pkdpc, pctxtq, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    //
    // If somebody has restarted the queue, we don't have do anything.
    //
    ASSERT(pctxtq->plistCtxtQ != NULL);

    if ((pctxtq->plistCtxtQ != NULL) &&
        !(pctxtq->dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
    {
        OSQueueWorkItem(&pctxtq->WorkItem);
        pctxtq->dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
    }

    EXIT(2, ("StartTimeSlice!\n"));
}       //StartTimeSlice

/***LP  StartTimeSlicePassive - Start a time slice at PASSIVE_LEVEL
 *
 *  ENTRY
 *      pctxtq -> CTXTQ
 *
 *  EXIT
 *      None
 */

VOID StartTimeSlicePassive(PCTXTQ pctxtq)
{
    TRACENAME("STARTTIMESLICEPASSIVE")

    ENTER(2, ("StartTimeSlicePassive(pctxtq=%x)\n", pctxtq));

    AcquireMutex(&pctxtq->mutCtxtQ);

    pctxtq->dwfCtxtQ &= ~CQF_WORKITEM_SCHEDULED;
    //
    // Make sure there is something in the queue and no current active context.
    //
    if ((pctxtq->plistCtxtQ != NULL) && (pctxtq->pkthCurrent == NULL) &&
        !(pctxtq->dwfCtxtQ & CQF_PAUSED))
    {
        DispatchCtxtQueue(pctxtq);
    }

    ReleaseMutex(&pctxtq->mutCtxtQ);

    EXIT(2, ("StartTimeSlicePassive!\n"));
}       //StartTimeSlicePassive

/***LP  DispatchCtxtQueue - Dispatch context from ready queue
 *
 *  ENTRY
 *      pctxtq -> CTXTQ
 *
 *  EXIT
 *      None
 *
 *  Note
 *      The caller must acquire CtxtQ mutex before entering this routine.
 */

VOID LOCAL DispatchCtxtQueue(PCTXTQ pctxtq)
{
    TRACENAME("DISPATCHCTXTQUEUE")
    LARGE_INTEGER liTimeout;
    PLIST plist;
    PCTXT pctxt;

    ENTER(2, ("DispatchCtxtQueue(pctxtq=%x)\n", pctxtq));

    ASSERT((pctxtq->plistCtxtQ != NULL) && (pctxtq->pkthCurrent == NULL));

    liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)pctxtq->dwmsTimeSliceLength);
    pctxtq->dwfCtxtQ &= ~CQF_TIMESLICE_EXPIRED;
    KeSetTimer(&pctxtq->Timer, liTimeout, &pctxtq->DpcExpireTimeSlice);

    while ((plist = ListRemoveHead(&pctxtq->plistCtxtQ)) != NULL)
    {
        pctxt = CONTAINING_RECORD(plist, CTXT, listQueue);

        ASSERT(pctxt->pplistCtxtQueue == &pctxtq->plistCtxtQ);

        pctxt->pplistCtxtQueue = NULL;
        pctxt->dwfCtxt &= ~CTXTF_IN_READYQ;
        RunContext(pctxt);
    }

    if (pctxtq->plistCtxtQ == NULL)
    {
        KeCancelTimer(&pctxtq->Timer);
        pctxtq->dwfCtxtQ &= ~CQF_TIMESLICE_EXPIRED;
    }
    else if (!(pctxtq->dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
    {
        //
        // Our time slice has expired, reschedule another time slice if not
        // already done so.
        //
        liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)pctxtq->dwmsTimeSliceInterval);
        KeSetTimer(&pctxtq->Timer, liTimeout, &pctxtq->DpcStartTimeSlice);
    }

    EXIT(2, ("DispatchCtxtQueue!\n"));
}       //DispatchCtxtQueue

/***LP  InsertReadyQueue - Insert the context into the ready queue
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      fDelayExecute - queue the request, don't execute now
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      The caller must acquire the CtxtQ mutex before entering this
 *      routine and release it after exiting this routine.
 */

NTSTATUS LOCAL InsertReadyQueue(PCTXT pctxt, BOOLEAN fDelayExecute)
{
    TRACENAME("INSERTREADYQUEUE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InsertReadyQueue(pctxt=%x,fDelayExecute=%x)\n",
              pctxt, fDelayExecute));

    CHKDEBUGGERREQ();

    //
    // Make sure we do have the spin lock.
    //
    LOGSCHEDEVENT('INSQ', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->pbOp);
    //
    // If there is a pending timer, cancel it.
    //
    if (pctxt->dwfCtxt & CTXTF_TIMER_PENDING)
    {
        BOOLEAN fTimerCancelled;

        pctxt->dwfCtxt &= ~CTXTF_TIMER_PENDING;
        fTimerCancelled = KeCancelTimer(&pctxt->Timer);

        //
        // If the timer could not be cancelled (already queued), wait
        // for it to fire and dispatch the context from there.  The
        // pending timer is referring to this context and we can not
        // have it completed with the timer outstanding.  Plus this
        // also interlocked to setting of timers and timeout processing
        // to ensure that a timeout is not mistakenly performed on
        // the next timer.
        //
        if (!fTimerCancelled)
        {
            pctxt->dwfCtxt |= CTXTF_TIMER_DISPATCH;
        }
    }
    //
    // Make this context ready.
    //
    pctxt->dwfCtxt |= CTXTF_READY;

    //
    // If this context is already running, we are done; otherwise, process it.
    //
    if (!(pctxt->dwfCtxt & CTXTF_TIMER_DISPATCH) &&
        (!(pctxt->dwfCtxt & CTXTF_RUNNING) ||
         (pctxt->dwfCtxt & CTXTF_NEST_EVAL)))
    {
        if (fDelayExecute)
        {
            //
            // This context is from a completion callback of current context,
            // we need to unblock/restart current context.
            //
            ReleaseMutex(&gReadyQueue.mutCtxtQ);
            AsyncCallBack(pctxt, AMLISTA_CONTINUE);
            AcquireMutex(&gReadyQueue.mutCtxtQ);
        }
        else if ((pctxt->dwfCtxt & CTXTF_NEST_EVAL) &&
                 (gReadyQueue.pkthCurrent == KeGetCurrentThread()))
        {
            LOGSCHEDEVENT('NEST', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            //
            // Somebody is running a new method on the callout of the current
            // context.  We must run this new context first or else we will
            // dead lock the current context.  We assume that if pending is
            // returned, the callout will return.
            //
            rc = RunContext(pctxt);
        }
        else if ((gReadyQueue.pkthCurrent == NULL) &&
                 !(gReadyQueue.dwfCtxtQ & CQF_PAUSED))
            //
            // We only execute the method if we are not in paused state.
            //
        {
            LOGSCHEDEVENT('EVAL', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            //
            // There is no active context and we can execute it immediately.
            //
            rc = RunContext(pctxt);

            if ((gReadyQueue.plistCtxtQ != NULL) &&
                !(gReadyQueue.dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
            {
                //
                // If we have more jobs in the queue and we haven't scheduled
                // a dispatch, schedule one.
                //
                LOGSCHEDEVENT('KICK', (ULONG_PTR)rc, 0, 0);
                OSQueueWorkItem(&gReadyQueue.WorkItem);
                gReadyQueue.dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
            }
        }
        else
        {
            //
            // Insert the context in the ready queue.
            //
            ASSERT(!(pctxt->dwfCtxt & (CTXTF_IN_READYQ | CTXTF_RUNNING)));
            LOGSCHEDEVENT('QCTX', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            if (!(pctxt->dwfCtxt & CTXTF_IN_READYQ))
            {
                pctxt->dwfCtxt |= CTXTF_IN_READYQ;
                ListInsertTail(&pctxt->listQueue, &gReadyQueue.plistCtxtQ);
                pctxt->pplistCtxtQueue = &gReadyQueue.plistCtxtQ;
            }

            pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
            rc = AMLISTA_PENDING;
        }
    }

    EXIT(2, ("InsertReadyQueue=%x\n", rc));
    return rc;
}       //InsertReadyQueue

/***LP  RestartContext - Restart a context
 *
 *  ENTRY
 *      pctxt -> CTXT structure
 *      fDelayExecute - TRUE to queue for delay execution
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *      None
 */

NTSTATUS LOCAL RestartContext(PCTXT pctxt, BOOLEAN fDelayExecute)
{
    TRACENAME("RESTARTCONTEXT")
    NTSTATUS rc = STATUS_SUCCESS;
    PRESTART prest;

    ENTER(2, ("RestartContext(pctxt=%x,fDelayExecute=%x)\n",
              pctxt, fDelayExecute));

    ASSERT(!(pctxt->dwfCtxt & CTXTF_TIMER_PENDING));
    ASSERT((fDelayExecute == FALSE) || !(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL));

    LOGSCHEDEVENT('REST', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->pbOp);
    if (KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        AcquireMutex(&gReadyQueue.mutCtxtQ);
        rc = InsertReadyQueue(pctxt, fDelayExecute);
        ReleaseMutex(&gReadyQueue.mutCtxtQ);
    }
    else if ((prest = NEWRESTOBJ(sizeof(RESTART))) != NULL)
    {
        pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
        prest->pctxt = pctxt;
        ExInitializeWorkItem(&prest->WorkItem, RestartCtxtPassive, prest);
        OSQueueWorkItem(&prest->WorkItem);
        rc = AMLISTA_PENDING;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("RestartContext: failed to allocate restart context item"));
    }

    EXIT(2, ("RestartContext=%x\n", rc));
    return rc;
}       //RestartContext

/***LP  RestartCtxtPassive - Restart context running at PASSIVE_LEVEL
 *
 *  ENTRY
 *      prest-> RESTART
 *
 *  EXIT
 *      None
 */

VOID RestartCtxtPassive(PRESTART prest)
{
    TRACENAME("RESTARTCTXTPASSIVE")

    ENTER(2, ("RestartCtxtPassive(prest=%x)\n", prest));

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    InsertReadyQueue(prest->pctxt,
                     (BOOLEAN)((prest->pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    FREERESTOBJ(prest);

    EXIT(2, ("RestartCtxtPassive!\n"));
}       //RestartCtxtPassive

/***LP  RestartCtxtCallback - Callback to restart a context
 *
 *  ENTRY
 *      pctxtdata -> CTXTDATA structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT RestartCtxtCallback(PCTXTDATA pctxtdata)
{
    TRACENAME("RESTARTCTXTCALLBACK")
    PCTXT pctxt = CONTAINING_RECORD(pctxtdata, CTXT, CtxtData);

    ENTER(2, ("RestartCtxtCallback(pctxt=%x)\n", pctxt));

    ASSERT(pctxt->dwSig == SIG_CTXT);
    LOGSCHEDEVENT('RSCB', (ULONG_PTR)pctxt, 0, 0);
    RestartContext(pctxt,
                   (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));

    EXIT(2, ("RestartCtxtCallback!\n"));
}       //RestartCtxtCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\trace.h ===
/*** trace.h - Trace function Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _TRACE_H
#define _TRACE_H

/*** Macros
 */

/*XLATOFF*/
#ifdef TRACING
  #define TRACENAME(s)  char *pszTraceName = s;
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, pszTraceName, TRUE))       \
                                PRINTF p;                              \
                            ++giIndent;                                 \
                        }
  #define EXIT(n,p)     {                                               \
                            --giIndent;                                 \
                            if (IsTraceOn(n, pszTraceName, FALSE))      \
                                PRINTF p;                             \
                        }
#else
  #define TRACENAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif

/*** Exported function prototype
 */

#ifdef TRACING
BOOLEAN EXPORT IsTraceOn(UCHAR n, PSZ pszProcName, BOOLEAN fEnter);
LONG LOCAL SetTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL AddTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
LONG LOCAL ZapTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
#endif

/*** Exported data
 */

extern int giTraceLevel, giIndent;

#endif  //ifndef _TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\type1op.c ===
/*** type1op.c - Parse type 1 opcodes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/16/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  Break - Parse and execute the Break instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Break(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BREAK")

    ENTER(2, ("Break(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    DEREF(pterm);

    EXIT(2, ("Break=%x\n", AMLISTA_BREAK));
    return AMLISTA_BREAK;
}       //Break

/***LP  BreakPoint - Parse and execute the BreakPoint instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL BreakPoint(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BREAKPOINT")

    ENTER(2, ("BreakPoint(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    DEREF(pterm);
  #ifdef DEBUGGER
    PRINTF("\nHit a code breakpoint.\n");
    AMLIDebugger(FALSE);
  #endif

    EXIT(2, ("BreakPoint=%x\n", STATUS_SUCCESS));
    return STATUS_SUCCESS;
}       //BreakPoint

/***LP  Fatal - Parse and execute the Fatal instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Fatal(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("FATAL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Fatal(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "III")) == STATUS_SUCCESS)
    {
        if (ghFatal.pfnHandler != NULL)
        {
            ((PFNFT)ghFatal.pfnHandler)((ULONG)pterm->pdataArgs[0].uipDataValue,
                                        (ULONG)pterm->pdataArgs[1].uipDataValue,
                                        (ULONG)pterm->pdataArgs[2].uipDataValue,
                                        (ULONG_PTR) pctxt,
                                        ghFatal.uipParam);
        }
        rc = AMLIERR_FATAL;
    }

    EXIT(2, ("Fatal=%x\n", rc));
    return rc;
}       //Fatal

/***LP  IfElse - Parse and execute the If and Else instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IfElse(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("IFELSE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("IfElse(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    ASSERT(*pterm->pbOpTerm == OP_IF);
    ASSERT(pterm->pbScopeEnd != NULL);

    if (*pterm->pbOpTerm == OP_IF)
    {
        if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
        {
            if (pterm->pdataArgs[0].uipDataValue == 0)
            {
                //
                // FALSE case, we must skip TRUE scope.
                //
                pctxt->pbOp = pterm->pbOpEnd;
                if ((pctxt->pbOp < pterm->pbScopeEnd) &&
                    (*pctxt->pbOp == OP_ELSE))
                {
                    //
                    // There is an ELSE part, execute it.
                    //
                    pctxt->pbOp++;
                    ParsePackageLen(&pctxt->pbOp, &pterm->pbOpEnd);
                    rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                                   pctxt->pnsScope, pctxt->powner,
                                   pctxt->pheapCurrent, pterm->pdataResult);
                }
            }
            else
            {
                PUCHAR pbOp, pbOpRet;
                //
                // TRUE case.
                //
                if ((pterm->pbOpEnd < pterm->pbScopeEnd) &&
                    (*pterm->pbOpEnd == OP_ELSE))
                {
                    //
                    // Set return address to skip else scope.
                    //
                    pbOp = pterm->pbOpEnd + 1;
                    ParsePackageLen(&pbOp, &pbOpRet);
                }
                else
                {
                    //
                    // Set return address to continue.
                    //
                    pbOpRet = NULL;
                }

                rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, pbOpRet,
                               pctxt->pnsScope, pctxt->powner,
                               pctxt->pheapCurrent, pterm->pdataResult);
            }
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("IfElse: Else statement found without matching If"));
    }

    EXIT(2, ("IfElse=%x (value=%x)\n", rc, pterm->pdataArgs[0].uipDataValue));
    return rc;
}       //IfElse

/***LP  Load - Parse and execute the Load instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Load(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LOAD")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;
    POBJOWNER powner = NULL;

    ENTER(2, ("Load(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "Z")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATA, &pdata)) ==
         STATUS_SUCCESS))
    {
        PNSOBJ pns;

        if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                     pctxt->pnsScope, &pns, NSF_WARN_NOTFOUND))
            == AMLIERR_OBJ_NOT_FOUND)
        {
            AMLI_LOGERR(rc,
                        ("Load: failed to find the memory OpRegion or Field object - %s",
                         pterm->pdataArgs[0].pbDataBuff));
        }
        else if (rc == STATUS_SUCCESS)
        {
          #ifdef DEBUG
            gdwfAMLI |= AMLIF_LOADING_DDB;
          #endif
            if ((pns->ObjData.dwDataType == OBJTYPE_OPREGION) &&
                (((POPREGIONOBJ)pns->ObjData.pbDataBuff)->bRegionSpace ==
         REGSPACE_MEM))
            {
                rc = LoadMemDDB(pctxt,
                                (PDSDT)((POPREGIONOBJ)pns->ObjData.pbDataBuff)->uipOffset,
                                &powner);
            }
            else if (pns->ObjData.dwDataType == OBJTYPE_FIELDUNIT)
            {
                rc = LoadFieldUnitDDB(pctxt, &pns->ObjData, &powner);
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("Load: object is not a memory OpRegion or Field - %s",
                                  pterm->pdataArgs[0].pbDataBuff));
            }

            if (rc == STATUS_SUCCESS)
            {
                pdata->dwDataType = OBJTYPE_DDBHANDLE;
                pdata->powner = powner;
            }
          #ifdef DEBUG
            {
                KIRQL   oldIrql;

                gdwfAMLI &= ~AMLIF_LOADING_DDB;
                KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
                gdwGHeapSnapshot = gdwGlobalHeapSize;
                KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
            }
          #endif

          #ifdef DEBUGGER
            if (gdwfAMLIInit & AMLIIF_LOADDDB_BREAK)
            {
                PRINTF("\n" MODNAME ": Break at Load Definition Block Completion.\n");
                AMLIDebugger(FALSE);
            }
          #endif
        }
    }

    EXIT(2, ("Load=%x (powner=%x)\n", rc, powner));
    return rc;
}       //Load

/***LP  Notify - Parse and execute the Notify instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Notify(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("NOTIFY")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Notify(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        if (pterm->pdataArgs[1].uipDataValue > MAX_BYTE)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                             ("Notify: Notification value is greater than a byte value (Value=%x)",
                              pterm->pdataArgs[1].uipDataValue));
        }
        else if (ghNotify.pfnHandler != NULL)
        {
            pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;

            ENTER(2, ("pfnNotify(Value=%x,Obj=%s,Param=%x)\n",
                      pterm->pdataArgs[1].uipDataValue,
                      GetObjectPath(pterm->pnsObj), ghNotify.uipParam));

            rc = ((PFNNH)ghNotify.pfnHandler)(EVTYPE_NOTIFY,
                                         (ULONG)pterm->pdataArgs[1].uipDataValue,
                                         pterm->pnsObj, (ULONG)ghNotify.uipParam,
                                         RestartCtxtCallback,
                                         &(pctxt->CtxtData));

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_NOTIFY_FAILED,
                                 ("Notify: Notify handler failed (rc=%x)",
                                  rc));
            }

            EXIT(2, ("pfnNotify!\n"));
        }
    }

    EXIT(2, ("Notify=%x (pnsObj=%s)\n", rc, GetObjectPath(pterm->pnsObj)));
    return rc;
}       //Notify

/***LP  ReleaseResetSignalUnload - Parse and execute the
 *                                 Release/Reset/Signal/Unload instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseResetSignalUnload(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("RELEASERESETSIGNALUNLOAD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ReleaseResetSignalUnload(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "O")) == STATUS_SUCCESS)
    {
        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_RELEASE:
                ENTER(2, ("Release(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_MUTEX)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Release: object is not mutex type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    rc = ReleaseASLMutex(pctxt,
                                         (PMUTEXOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                }

                if (pterm->pnsObj->ObjData.dwfData & DATAF_GLOBAL_LOCK)
                {
                    if ((rc = ReleaseGL(pctxt)) != STATUS_SUCCESS)
                    {
                        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                         ("Release: failed to release global lock (rc=%x)",
                                          rc));
                    }
                }
                EXIT(2, ("Release=%x\n", rc));
                break;

            case OP_RESET:
                ENTER(2, ("Reset(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Reset: object is not event type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    ResetASLEvent((PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                    rc = STATUS_SUCCESS;
                }
                EXIT(2, ("Reset=%x\n", rc));
                break;

            case OP_SIGNAL:
                ENTER(2, ("Signal(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Signal: object is not event type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    SignalASLEvent((PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                }
                EXIT(2, ("Signal=%x\n", rc));
                break;

            case OP_UNLOAD:
                ENTER(2, ("Unload(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_DDBHANDLE)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Unload: object is not DDBHandle (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    UnloadDDB(pterm->pnsObj->ObjData.powner);
                    MEMZERO(&pterm->pnsObj->ObjData, sizeof(OBJDATA));
                    rc = STATUS_SUCCESS;
                }
                EXIT(2, ("Unload=%x\n", rc));
                break;
        }
    }

    EXIT(2, ("ReleaseResetSignalUnload=%x\n", rc));
    return rc;
}       //ReleaseResetSignalUnload

/***LP  Return - Parse and execute the Return instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Return(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("RETURN")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Return(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = DupObjData(pctxt->pheapCurrent, pterm->pdataResult,
                         &pterm->pdataArgs[0])) == STATUS_SUCCESS)
    {
        rc = AMLISTA_RETURN;
    }

    EXIT(2, ("Return=%x\n", rc));
    return rc;
}       //Return

/***LP  SleepStall - Parse and execute the Sleep/Stall instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SleepStall(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("SLEEPSTALL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("SleepStall(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        if (pterm->pamlterm->dwOpcode == OP_SLEEP)
        {
            ENTER(2, ("Sleep(dwMS=%d)\n", pterm->pdataArgs[0].uipDataValue));
            if (pterm->pdataArgs[0].uipDataValue > MAX_WORD)
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                                 ("Sleep: sleep value is greater than a word value (Value=%x)",
                                  pterm->pdataArgs[0].uipDataValue));
            }
            else if (pterm->pdataArgs[0].uipDataValue != 0)
            {
                if ((rc = SleepQueueRequest(
                                pctxt,
                                (ULONG)pterm->pdataArgs[0].uipDataValue)) ==
                    STATUS_SUCCESS)
                {
                    rc = AMLISTA_PENDING;
                }
            }
            EXIT(2, ("Sleep=%x\n", rc));
        }
        else if (pterm->pdataArgs[0].uipDataValue > MAX_BYTE)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                             ("Stall: stall value is greater than a byte value (Value=%x)",
                              pterm->pdataArgs[0].uipDataValue));
        }
        else
        {
            ENTER(2, ("Stall(dwUS=%d)\n", pterm->pdataArgs[0].uipDataValue));
            KeStallExecutionProcessor((ULONG)pterm->pdataArgs[0].uipDataValue);
            EXIT(2, ("Stall=%x\n", rc));
        }
    }

    EXIT(2, ("SleepStall=%x\n", rc));
    return rc;
}       //SleepStall

/***LP  While - Parse and execute the While instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL While(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("WHILE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("While(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        if (pterm->pdataArgs[0].uipDataValue == 0)
        {
            //
            // FALSE case, skip the while scope.
            //
            pctxt->pbOp = pterm->pbOpEnd;
        }
        else
        {
            //
            // Set the return address to the beginning of the while term.
            //
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, pterm->pbOpTerm,
                           pctxt->pnsScope, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("While=%x (value=%x)\n", rc, pterm->pdataArgs[0].uipDataValue));
    return rc;
}       //While
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\trace.c ===
/*** trace.c - Trace functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef TRACING

/*** Local function prototypes
 */

VOID LOCAL TraceIndent(VOID);
BOOLEAN LOCAL IsTrigPt(char *pszProcName);

/*** Local data
 */

int giTraceLevel = 0, giIndent = 0;
char aszTrigPtBuff[MAX_TRIG_PTS][MAX_TRIGPT_LEN + 1] = {0};
ULONG dwcTriggers = 0;

/***EP  IsTraceOn - Determine if tracing is on for the given procedure
 *
 *  ENTRY
 *      n - trace level
 *      pszProcName -> procedure name
 *      fEnter - TRUE if EnterProc trace
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN EXPORT IsTraceOn(UCHAR n, char *pszProcName, BOOLEAN fEnter)
{
    BOOLEAN rc = FALSE;

    if (!(gDebugger.dwfDebugger & (DBGF_IN_DEBUGGER | DBGF_CHECKING_TRACE)))
    {
        gDebugger.dwfDebugger |= DBGF_CHECKING_TRACE;

        if ((gDebugger.dwfDebugger & DBGF_TRIGGER_MODE) &&
            IsTrigPt(pszProcName))
        {
            if (fEnter)
                dwcTriggers++;
            else
                dwcTriggers--;
            rc = TRUE;
        }
        else if ((n <= giTraceLevel) &&
                 (!(gDebugger.dwfDebugger & DBGF_TRIGGER_MODE) ||
                  (dwcTriggers > 0)))
        {
            rc = TRUE;
        }

        if (rc == TRUE)
            TraceIndent();

        gDebugger.dwfDebugger &= ~DBGF_CHECKING_TRACE;
    }

    return rc;
}       //IsTraceOn

/***LP  IsTrigPt - Find the procedure name in the TrigPt buffer
 *
 *  ENTRY
 *      pszProcName -> procedure name
 *
 *  EXIT-SUCCESS
 *      returns TRUE - matched whole or partial name in the TrigPt buffer
 *  EXIT-FAILURE
 *      returns FALSE - no match
 */

BOOLEAN LOCAL IsTrigPt(char *pszProcName)
{
    BOOLEAN rc = FALSE;
    UCHAR i;

    for (i = 0; (rc == FALSE) && (i < MAX_TRIG_PTS); ++i)
    {
        if ((aszTrigPtBuff[i][0] != '\0') &&
            (STRSTR(pszProcName, &aszTrigPtBuff[i][0]) != NULL))
        {
            rc = TRUE;
        }
    }

    return rc;
}       //IsTrigPt

/***LP  TraceIndent - Indent trace output
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL TraceIndent(VOID)
{
    int i;

    PRINTF(MODNAME ":");
    for (i = 0; i < giIndent; i++)
    {
        PRINTF("| ");
    }
}       //TraceIndent

/***LP  SetTrace - set trace modes
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT
 *      returns DBGERR_NONE
 */

LONG LOCAL SetTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    DEREF(pszArg);
    DEREF(dwNonSWArgs);
    //
    // User typed "set" without any arguments
    //
    if ((pArg == NULL) && (dwArgNum == 0))
    {
        int i;

        PRINTF("\nTrace Level = %d\n", giTraceLevel);
        PRINTF("Trace Trigger Mode = %s\n\n",
               gDebugger.dwfDebugger & DBGF_TRIGGER_MODE? "ON": "OFF");

        for (i = 0; i < MAX_TRIG_PTS; ++i)
        {
            PRINTF("%2d: %s\n", i, aszTrigPtBuff[i]);
        }
    }

    return DBGERR_NONE;
}       //SetTrace

/***LP  AddTraceTrigPts - Add trace trigger points
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AddTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    PSZ psz;
    int i;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    STRUPR(pszArg);
    if ((pszArg != NULL) && ((psz = STRTOK(pszArg, ",")) != NULL))
    {
        do
        {
            for (i = 0; i < MAX_TRIG_PTS; ++i)
            {
                if (aszTrigPtBuff[i][0] == '\0')
                {
                    STRCPYN(aszTrigPtBuff[i], psz, MAX_TRIGPT_LEN + 1);
                    break;
                }
            }

            if (i == MAX_TRIG_PTS)
            {
                DBG_ERROR(("no free trigger point - %s", psz));
                rc = DBGERR_CMD_FAILED;
            }

        } while ((rc == DBGERR_NONE) && ((psz = STRTOK(NULL, ",")) != NULL));
    }

    return rc;
}       //AddTraceTrigPts

/***LP  ZapTraceTrigPts - Zap trace trigger points
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL ZapTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    PSZ psz, psz1;
    ULONG dwData;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if ((pszArg != NULL) && ((psz = STRTOK(pszArg, ",")) != NULL))
    {
        do
        {
            dwData = STRTOUL(psz, &psz1, 10);
            if ((psz == psz1) || (dwData >= MAX_TRIG_PTS))
            {
                DBG_ERROR(("invalid trigger point - %d", dwData));
                rc = DBGERR_CMD_FAILED;
            }
            else
                aszTrigPtBuff[dwData][0] = '\0';
        } while ((rc == DBGERR_NONE) && ((psz = STRTOK(NULL, ",")) != NULL));
    }

    return rc;
}       //ZapTraceTrigPts

#endif  //ifdef TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\sleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sleep.c

Abstract:

    This handles sleep requests on the part of the interpreter

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

    NB: Win9x can run this code also, but they will choose not do so.

--*/

#include "pch.h"

VOID
SleepQueueDpc(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Argument1,
    PVOID   Argument2
    )
/*++

Routine Description:

    This routine is fired when a timer event occurs

Arguments:

    Dpc         - The DPC that was fired
    Context     - Not used
    Argument1   - Time.LowPart -- Not used
    Argument2   - Time.HighPart -- Not used

Return Value:

    VOID
--*/
{
    LARGE_INTEGER   currentTime;
    LARGE_INTEGER   dueTime;
    LIST_ENTRY      localList;
    PLIST_ENTRY     listEntry;
    PSLEEP          sleepItem;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Argument1 );
    UNREFERENCED_PARAMETER( Argument2 );

    //
    // Initialize the local list. Contrary to what the docs say, this code
    // can be called from any IRQL (as long as the mem is resident)
    //
    InitializeListHead(&localList);

    //
    // Acquire the lock, since we must remove the things from the list
    // under some kind of protection.
    //
    AcquireMutex(&gmutSleep);

    //
    // Find the correct time. This *must* be done after we are acquire the
    // lock because there might be a long delay between trying to acquire
    // the lock and actually getting it
    //
    currentTime.QuadPart = KeQueryInterruptTime();

    //
    // Loop until we are done
    //
    while (!IsListEmpty(&SleepQueue)) {

        //
        // Obtain the first element in the global list again
        //
        sleepItem = CONTAINING_RECORD(SleepQueue.Flink, SLEEP, ListEntry);

        //
        // Should the current item be removed?
        //
        if (sleepItem->SleepTime.QuadPart > currentTime.QuadPart) {

            //
            // No, so we need to set the timer to take care of this request
            //
            dueTime.QuadPart = currentTime.QuadPart -
                               sleepItem->SleepTime.QuadPart;
            KeSetTimer(
                &SleepTimer,
                dueTime,
                &SleepDpc
                );
            break;

        }

        //
        // Yes, so remove it
        //
        listEntry = RemoveHeadList(&SleepQueue);

        //
        // Now, add the entry to the next queue
        //
        InsertTailList(&localList, listEntry);

    }

    //
    // Done with lock. This may cause another DPC to process more elements
    //
    ReleaseMutex(&gmutSleep);

    //
    // At this point, we are free to remove items from the local list and
    // try to do work on them.
    //
    while (!IsListEmpty(&localList)) {

        //
        // Remove the first element from the local list
        //
        listEntry = RemoveHeadList(&localList);
        sleepItem = CONTAINING_RECORD(listEntry, SLEEP, ListEntry);

        //
        // Force the interpreter to run
        //

        RestartContext(sleepItem->Context,
                       (BOOLEAN)((sleepItem->Context->dwfCtxt & CTXTF_ASYNC_EVAL)
                                 == 0));
    }
}

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif


NTSTATUS
LOCAL
SleepQueueRequest(
    IN  PCTXT   Context,
    IN  ULONG   SleepTime
    )
/*++

Routine Description:

    This routine is responsible for adding the sleep request to the
    system queue for pending sleep requests

Arguments:

    Context     - The current execution context
    SleepTime   - The amount of sleep time, in MilliSeconds

Rreturn Value:

    NTSTATUS

--*/
{
    TRACENAME("SLEEPQUEUEREQUEST")
    BOOLEAN         timerSet = FALSE;
    NTSTATUS        status;
    PLIST_ENTRY     listEntry;
    PSLEEP          currentSleep;
    PSLEEP          listSleep;
    ULONGLONG       currentTime;
    LARGE_INTEGER   dueTime;

    ENTER(2, ("SleepQueueRequest(Context=%x,SleepTime=%d)\n",
        Context, SleepTime) );

    status = PushFrame(Context,
                       SIG_SLEEP,
                       sizeof(SLEEP),
                       ProcessSleep,
                       &currentSleep);

    if (NT_SUCCESS(status)) {
        //
        // The first step is acquire the timer lock, since we must protect it
        //
        AcquireMutex(&gmutSleep);

        //
        // Next step is to determine time at which we should wake up this
        // context
        //
        currentTime = KeQueryInterruptTime();
        currentSleep->SleepTime.QuadPart = currentTime +
                                           ((ULONGLONG)SleepTime*10000);
        currentSleep->Context = Context;

        //
        // At this point, it becomes easier to walk the list backwards
        //
        listEntry = &SleepQueue;
        while (listEntry->Blink != &SleepQueue) {

            listSleep = CONTAINING_RECORD(listEntry->Blink, SLEEP, ListEntry);

            //
            // Do we have to add the new element after the current one?
            //
            if (currentSleep->SleepTime.QuadPart >=
                listSleep->SleepTime.QuadPart) {

                //
                // Yes
                //
                InsertHeadList(
                    &(listSleep->ListEntry),
                    &(currentSleep->ListEntry)
                    );

                break;
            }

            //
            // Next entry
            //
            listEntry = listEntry->Blink;
        }

        //
        // Look to see if we got to the head
        //
        if (listEntry->Blink == &SleepQueue) {

            //
            // If we get to this point, it is because we have
            // gone all the around the list. If we add to the
            // front of the list, we must set the timer
            //
            InsertHeadList(&SleepQueue, &currentSleep->ListEntry);
            dueTime.QuadPart = currentTime - currentSleep->SleepTime.QuadPart;
            timerSet = KeSetTimer(
                &SleepTimer,
                dueTime,
                &SleepDpc
                );
        }
        //
        // Done with the lock
        //
        ReleaseMutex(&gmutSleep);
    }

    EXIT(2, ("SleepQueueReqest=%x (currentSleep=%x timerSet=%x)\n",
        status, currentSleep, timerSet) );
    return status;

}

/***LP  ProcessSleep - post processing of sleep
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      psleep -> SLEEP
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessSleep(PCTXT pctxt, PSLEEP psleep, NTSTATUS rc)
{
    TRACENAME("PROCESSSLEEP")

    ENTER(2, ("ProcessSleep(pctxt=%x,pbOp=%x,psleep=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, psleep, rc));

    ASSERT(psleep->FrameHdr.dwSig == SIG_SLEEP);

    PopFrame(pctxt);

    EXIT(2, ("ProcessSleep=%x\n", rc));
    return rc;
}       //ProcessSleep
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\sync.c ===
/*** sync.c - synchronization functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/16/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  AysncCallBack - Call back async function
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      rcCtxt - return status of the context
 *
 *  EXIT
 *      None
 */

VOID LOCAL AsyncCallBack(PCTXT pctxt, NTSTATUS rcCtxt)
{
    TRACENAME("ASYNCCALLBACK")
    PFNACB pfnAsyncCallBack;
    PNSOBJ pnsObj;
    POBJDATA pdataCallBack;
    PVOID pvContext;

    rcCtxt = ((rcCtxt == STATUS_SUCCESS) || (rcCtxt == AMLISTA_CONTINUE))?
             rcCtxt: NTERR(rcCtxt);

    if (pctxt->pnctxt != NULL)
    {
        //
        // We have a nested context here.  We are calling back the nested
        // context, not the parent context.
        //
        pfnAsyncCallBack = pctxt->pnctxt->pfnAsyncCallBack;
        pnsObj = pctxt->pnctxt->pnsObj;
        pdataCallBack = pctxt->pnctxt->pdataCallBack;
        pvContext = pctxt->pnctxt->pvContext;
    }
    else
    {
        pfnAsyncCallBack = pctxt->pfnAsyncCallBack;
        pnsObj = pctxt->pnsObj;
        pdataCallBack = pctxt->pdataCallBack;
        pvContext = pctxt->pvContext;
    }

    ENTER(2, ("AsyncCallBack(pctxt=%x,rc=%x,Obj=%s,pdataCallBack=%x,pvContext=%x)\n",
              pctxt, rcCtxt, GetObjectPath(pnsObj), pdataCallBack, pvContext));

    
    if (pfnAsyncCallBack == (PFNACB)EvalMethodComplete)
    {
        LOGSCHEDEVENT('DONE', (ULONG_PTR)pnsObj, (ULONG_PTR)rcCtxt,
                      (ULONG_PTR)pvContext);
        EvalMethodComplete(pctxt, rcCtxt, (PSYNCEVENT)pvContext);
    }
    else if (pfnAsyncCallBack != NULL)
    {
        if (rcCtxt == AMLISTA_CONTINUE)
        {
            //
            // We are not done yet, restart the AsyncEval context using
            // current thread.
            //
            ASSERT(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL);
            RestartContext(pctxt, FALSE);
        }
        else
        {
            LOGSCHEDEVENT('ASCB', (ULONG_PTR)pnsObj, (ULONG_PTR)rcCtxt,
                          (ULONG_PTR)pvContext);
            pfnAsyncCallBack(pnsObj, rcCtxt, pdataCallBack, pvContext);
        }
    }
    
    EXIT(2, ("AsyncCallBack!\n"));
}       //AsyncCallBack

/***LP  EvalMethodComplete - eval completion callback
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      rc - evaluation status
 *      pse -> SyncEvent
 *
 *  EXIT
 *      None
 */

VOID EXPORT EvalMethodComplete(PCTXT pctxt, NTSTATUS rc, PSYNCEVENT pse)
{
    TRACENAME("EVALMETHODCOMPLETE")
    ENTER(2, ("EvalMethodComplete(pctxt=%x,rc=%x,pse=%x\n", pctxt, rc, pse));

    pse->rcCompleted = rc;
    pse->pctxt = pctxt;
    KeSetEvent(&pse->Event, 0, FALSE);

    EXIT(2, ("EvalMethodComplete!\n"));
}       //EvalMethodComplete

/***LP  SyncEvalObject - evaluate an object synchronously
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SyncEvalObject(PNSOBJ pns, POBJDATA pdataResult, int icArgs,
                              POBJDATA pdataArgs)
{
    TRACENAME("SYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    SYNCEVENT seEvalObj;

    ENTER(2, ("SyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs));

    KeInitializeEvent(&seEvalObj.Event, SynchronizationEvent, FALSE);

    if (KeGetCurrentThread() == gReadyQueue.pkthCurrent)
    {
        if (!(gReadyQueue.pctxtCurrent->dwfCtxt & CTXTF_ASYNC_EVAL))
        {
            LOGSCHEDEVENT('NSYN', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns,
                          0);
            //
            // Somebody is re-entering with the active context thread, so we
            // must nest using the existing active context.
            //
            if ((rc = NestAsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                                          (PFNACB)EvalMethodComplete,
                                          &seEvalObj, FALSE)) ==
                AMLISTA_PENDING)
            {
                rc = RestartContext(gReadyQueue.pctxtCurrent, FALSE);
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_FATAL,
                             ("SyncEvalObject: cannot nest a SyncEval on an async. context"));
        }
    }
    else
    {
        LOGSCHEDEVENT('SYNC', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns, 0);
        rc = AsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                             (PFNACB)EvalMethodComplete, &seEvalObj, FALSE);
    }

    if (KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        while (rc == AMLISTA_PENDING)
        {
            if ((rc = KeWaitForSingleObject(&seEvalObj.Event, Executive,
                                            KernelMode, FALSE,
                                            (PLARGE_INTEGER)NULL)) ==
                STATUS_SUCCESS)
            {
                if (seEvalObj.rcCompleted == AMLISTA_CONTINUE)
                {
                    rc = RestartContext(seEvalObj.pctxt, FALSE);
                }
                else
                {
                    rc = AMLIERR(seEvalObj.rcCompleted);
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_FATAL,
                                 ("SyncEvalObject: object synchronization failed (rc=%x)",
                                  rc));
            }
        }
    }
    else if (rc == AMLISTA_PENDING)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncEvalObject: object %s being evaluated at IRQL >= DISPATCH_LEVEL",
                          GetObjectPath(pns)));
    }

        EXIT(2, ("SyncEvalObject=%x\n", rc));
    return rc;
}       //SyncEvalObject

/***LP  AsyncEvalObject - evaluate an object asynchronously
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *      pfnAsyncCallBack -> completion callback function
 *      pvContext -> context data
 *      fAsync - TRUE if this is from an AsyncEval call
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult, int icArgs,
                               POBJDATA pdataArgs, PFNACB pfnAsyncCallBack,
                               PVOID pvContext, BOOLEAN fAsync)
{
    TRACENAME("ASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;

    ENTER(2, ("AsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x,pvContext=%x,fAsync=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack, pvContext, fAsync));

    LOGSCHEDEVENT('ASYN', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns, 0);
    if ((rc = NewContext(&pctxt)) == STATUS_SUCCESS)
    {
        BOOLEAN fQueueContext = FALSE;

        pctxt->pnsObj = pns;
        pctxt->pnsScope = pns;
        pctxt->pfnAsyncCallBack = pfnAsyncCallBack;
        pctxt->pdataCallBack = pdataResult;
        pctxt->pvContext = pvContext;
	
	ACPIWMILOGEVENT((1,
                    EVENT_TRACE_TYPE_START,
                    GUID_List[AMLI_LOG_GUID],
                    "Object = %s", 
                    GetObjectPath(pctxt->pnsObj)
                   ));

        if (fAsync)
        {
            pctxt->dwfCtxt |= CTXTF_ASYNC_EVAL;
        }

        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            if ((rc = PushCall(pctxt, pns, &pctxt->Result)) == STATUS_SUCCESS)
            {
                PCALL pcall;

                ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig ==
                       SIG_CALL);

                pcall = (PCALL)pctxt->LocalHeap.pbHeapEnd;

                if (icArgs != pcall->icArgs)
                {
                    rc = AMLI_LOGERR(AMLIERR_INCORRECT_NUMARG,
                                     ("AsyncEvalObject: incorrect number of arguments (NumArg=%d,Expected=%d)",
                                      icArgs, pcall->icArgs));
                }
                else
                {
                  #ifdef DEBUGGER
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        PRINTF("\n" MODNAME ": %08x: %s(",
                               KeGetCurrentThread(), GetObjectPath(pns));
                    }
                  #endif
                    //
                    // Copying arguments to the call frame manually will skip
                    // the argument parsing stage.
                    //
                    for (pcall->iArg = 0; pcall->iArg < icArgs; ++pcall->iArg)
                    {
                        if ((rc = DupObjData(pctxt->pheapCurrent,
                                             &pcall->pdataArgs[pcall->iArg],
                                             &pdataArgs[pcall->iArg])) !=
                            STATUS_SUCCESS)
                        {
                            break;
                        }

                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PrintObject(&pdataArgs[pcall->iArg]);
                            if (pcall->iArg + 1 < icArgs)
                            {
                                PRINTF(",");
                            }
                        }
                      #endif
                    }

                    if (rc == STATUS_SUCCESS)
                    {
                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PRINTF(")\n");
                        }
                      #endif
                        //
                        // Skip the argument parsing stage.
                        //
                        pcall->FrameHdr.dwfFrame = 2;
                        fQueueContext = TRUE;
                    }
                }
            }
        }
        else if (((rc = PushPost(pctxt, ProcessEvalObj, (ULONG_PTR)pns, 0,
                                 &pctxt->Result)) == STATUS_SUCCESS) &&
                 ((rc = ReadObject(pctxt, &pns->ObjData, &pctxt->Result)) !=
                  AMLISTA_PENDING))
        {
            fQueueContext = TRUE;
        }

        if (fQueueContext)
        {
            rc = RestartContext(pctxt, FALSE);
        }
        else
        {
            //
            // If we never queue the context because we bailed,
            // we must free it.
            //
            FreeContext(pctxt);
        }
    }

    EXIT(2, ("AsyncEvalObject=%x\n", rc));
    return rc;
}       //AsyncEvalObject

/***LP  NestAsyncEvalObject - evaluate an object asynchronously using the
 *                            current context
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *      pfnAsyncCallBack -> completion callback function
 *      pvContext -> context data
 *      fAsync - TRUE if this is from an AsyncEval call
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */
NTSTATUS LOCAL NestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                   int icArgs, POBJDATA pdataArgs,
                                   PFNACB pfnAsyncCallBack, PVOID pvContext,
                                   BOOLEAN fAsync)
{
    TRACENAME("NESTASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;

    ENTER(2, ("NestAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x,pvContext=%x,fAsync=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack, pvContext, fAsync));

    //
    // Context must be the current one in progress.
    //
    ASSERT(gReadyQueue.pkthCurrent == KeGetCurrentThread());
    pctxt = gReadyQueue.pctxtCurrent;

    LOGSCHEDEVENT('NASY', (ULONG_PTR)pns, (ULONG_PTR)pfnAsyncCallBack,
                  (ULONG_PTR)pctxt);
    if ((pctxt != NULL) &&
        (gReadyQueue.pkthCurrent == KeGetCurrentThread()))
    {
        PNESTEDCTXT  pnctxt;

        rc = PushFrame(pctxt, SIG_NESTEDCTXT, sizeof(NESTEDCTXT),
                       ParseNestedContext, &pnctxt);

        if (rc == STATUS_SUCCESS)
        {
            pnctxt->pnsObj = pns;
            pnctxt->pnsScope = pns;
            pnctxt->pfnAsyncCallBack = pfnAsyncCallBack;
            pnctxt->pdataCallBack = pdataResult;
            pnctxt->pvContext = pvContext;
            pnctxt->pnctxtPrev = pctxt->pnctxt;
            pnctxt->dwfPrevCtxt = pctxt->dwfCtxt;
            pctxt->pnctxt = pnctxt;
            pctxt->dwfCtxt |= CTXTF_NEST_EVAL;

            if (fAsync)
            {
                pctxt->dwfCtxt |= CTXTF_ASYNC_EVAL;
            }
            else
            {
                pctxt->dwfCtxt &= ~CTXTF_ASYNC_EVAL;
            }

            if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
            {
                if ((rc = PushCall(pctxt, pns, &pnctxt->Result)) ==
                    STATUS_SUCCESS)
                {
                    PCALL pcall;

                    ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig ==
                           SIG_CALL);

                    pcall = (PCALL)pctxt->LocalHeap.pbHeapEnd;

                    if (icArgs != pcall->icArgs)
                    {
                        rc = AMLI_LOGERR(AMLIERR_INCORRECT_NUMARG,
                                         ("NestAsyncEvalObject: incorrect number of arguments (NumArg=%d,Expected=%d)",
                                          icArgs, pcall->icArgs));
                    }
                    else
                    {
                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PRINTF("\n" MODNAME ": %s(", GetObjectPath(pns));
                        }
                      #endif
                        //
                        // Copying arguments to the call frame manually will
                        // skip the argument parsing stage.
                        //
                        for (pcall->iArg = 0;
                             pcall->iArg < icArgs;
                             ++pcall->iArg)
                        {
                            if ((rc = DupObjData(pctxt->pheapCurrent,
                                                 &pcall->pdataArgs[pcall->iArg],
                                                 &pdataArgs[pcall->iArg])) !=
                                STATUS_SUCCESS)
                            {
                                break;
                            }

                          #ifdef DEBUGGER
                            if (gDebugger.dwfDebugger &
                                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                            {
                                PrintObject(&pdataArgs[pcall->iArg]);
                                if (pcall->iArg + 1 < icArgs)
                                {
                                    PRINTF(",");
                                }
                            }
                          #endif
                        }

                        if (rc == STATUS_SUCCESS)
                        {
                          #ifdef DEBUGGER
                            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                            {
                                PRINTF(")\n");
                            }
                          #endif
                            //
                            // Skip the argument parsing stage.
                            //
                            pcall->FrameHdr.dwfFrame = 2;
                        }
                    }
                }
            }
            else
            {
                //
                // Delay the evaluate the object.
                //
                rc = PushPost(pctxt, ProcessEvalObj, (ULONG_PTR)pns, 0,
                              &pnctxt->Result);

                if (rc == STATUS_SUCCESS)
                {
                    ReadObject(pctxt, &pns->ObjData, &pnctxt->Result);
                }
            }

            //
            // Always return AMLISTA_PENDING.
            //
            rc = AMLISTA_PENDING;
        }
    }
    else
    {
        //
        // We cannot use the nested version --- fail the call
        //
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("NestAsyncEvalObject: pns=%08x No current context\n",
                          pns));
    }

    EXIT(2, ("NestAsyncEvalObject=%x\n", rc));
    return rc;
}       //NestAsyncEvalObject

/***LP  ProcessEvalObj - post process of EvalObj
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessEvalObj(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSEVALOBJ")

    ENTER(2, ("ProcessEvalObj(pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);
  #ifdef DEBUGGER
    if ((gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
        (rc == STATUS_SUCCESS))
    {
        PRINTF("\n" MODNAME ": EvalObject(%s)=",
               GetObjectPath((PNSOBJ)ppost->uipData1));
        DumpObject(ppost->pdataResult, NULL, 0);
        PRINTF("\n");
    }
  #else
    DEREF(ppost);
  #endif

    PopFrame(pctxt);

    EXIT(2, ("ProcessEvalObj=%x\n", rc));
    return rc;
}       //ProcessEvalObj

/***LP  TimeoutCallback - DPC callback for Mutex/Event timeout
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxt -> CTXT
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID TimeoutCallback(PKDPC pkdpc, PCTXT pctxt, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("TIMEOUTCALLBACK")

    ENTER(2, ("TimeoutCallback(pkdpc=%x,pctxt=%x,SysArg1=%x,SysArg2=%x)\n",
              pkdpc, pctxt, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    if (pctxt->dwfCtxt & CTXTF_TIMER_PENDING)
    {
        //
        // Timer has timed out.
        //
        pctxt->dwfCtxt &= ~CTXTF_TIMER_PENDING;
        pctxt->dwfCtxt |= CTXTF_TIMEOUT;

        //
        // Remove from waiting queue.
        //
        ASSERT(pctxt->pplistCtxtQueue != NULL);
        ListRemoveEntry(&((PCTXT)pctxt)->listQueue,
                        ((PCTXT)pctxt)->pplistCtxtQueue);
        pctxt->pplistCtxtQueue = NULL;

        RestartContext(pctxt,
                       (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    }
    else if (pctxt->dwfCtxt & CTXTF_TIMER_DISPATCH)
    {
        //
        // Timer couldn't be cancelled while queuing context.  Since the
        // queuing was aborted, we continue the queuing here.
        //
        pctxt->dwfCtxt &= ~CTXTF_TIMER_DISPATCH;
        RestartContext(pctxt,
                       (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    }
    else
    {
        // Should not be here
        ASSERT(pctxt->dwfCtxt & (CTXTF_TIMER_PENDING | CTXTF_TIMER_DISPATCH));
    }

    EXIT(2, ("TimeoutCallback!\n"));
}       //TimeoutCallback

/***LP  QueueContext - queue control method context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      wTimeOut - timeout in ms
 *      pplist -> list to insert created context
 *
 *  EXIT
 *      None
 */

VOID LOCAL QueueContext(PCTXT pctxt, USHORT wTimeout, PPLIST pplist)
{
    TRACENAME("QUEUECONTEXT")

    ENTER(2, ("QueueContext(pctxt=%x,Timeout=%d,pplist=%x)\n",
              pctxt, wTimeout, pplist));

    AcquireMutex(&gReadyQueue.mutCtxtQ);

    //
    // make sure this context isn't queued somewhere else.
    //
    ASSERT(pctxt->pplistCtxtQueue == NULL);
    ASSERT(pplist != NULL);
    ASSERT(!(pctxt->dwfCtxt &
             (CTXTF_TIMER_PENDING | CTXTF_TIMER_DISPATCH | CTXTF_TIMEOUT |
              CTXTF_READY)));
    ListInsertTail(&pctxt->listQueue, pplist);
    pctxt->pplistCtxtQueue = pplist;

    if (wTimeout != 0xffff)
    {
        LARGE_INTEGER liTimeout;

        pctxt->dwfCtxt |= CTXTF_TIMER_PENDING;
        liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)wTimeout);
        KeSetTimer(&pctxt->Timer, liTimeout, &pctxt->Dpc);
    }

    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    EXIT(2, ("QueueContext!\n"));
}       //QueueContext

/***LP  DequeueAndReadyContext - dequeue context and insert to ready queue
 *
 *  ENTRY
 *      pplist -> context list to dequeue from
 *
 *  EXIT-SUCCESS
 *      returns pctxt
 *  EXIT-FAILURE
 *      returns NULL
 */

PCTXT LOCAL DequeueAndReadyContext(PPLIST pplist)
{
    TRACENAME("DEQUEUEANDREADYCONTEXT")
    PCTXT pctxt = NULL;
    PLIST plist;

    ENTER(2, ("DequeueAndReadyContext(pplist=%x)\n", pplist));

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if ((plist = ListRemoveHead(pplist)) != NULL)
    {
        pctxt = CONTAINING_RECORD(plist, CTXT, listQueue);
        ASSERT(pctxt->dwSig == SIG_CTXT);
        ASSERT(pctxt->pplistCtxtQueue == pplist);
        pctxt->pplistCtxtQueue = NULL;
        InsertReadyQueue(pctxt, TRUE);
    }

    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    EXIT(2, ("DequeueAndReadyContext=%x\n", pctxt));
    return pctxt;
}       //DequeueAndReadyContext

/***LP  AcquireASLMutex - acquire ASL mutex
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pm -> MUTEX structure
 *      wTimeOut - timeout in ms
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AcquireASLMutex(PCTXT pctxt, PMUTEXOBJ pm, USHORT wTimeout)
{
    TRACENAME("ACQUIREASLMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("AcquireASLMutex(pctxt=%x,pm=%x,Timeout=%d)\n",
              pctxt, pm, wTimeout));

    if (pctxt->dwfCtxt & CTXTF_TIMEOUT)
    {
        pctxt->dwfCtxt &= ~CTXTF_TIMEOUT;
        rc = AMLISTA_TIMEOUT;
    }
    else if (pm->dwSyncLevel < pctxt->dwSyncLevel)
    {
        rc = AMLI_LOGERR(AMLIERR_MUTEX_INVALID_LEVEL,
                         ("AcquireASLMutex: invalid sync level"));
    }
    else if (pm->dwcOwned == 0)
    {
        PRESOURCE pres;

        pres = NEWCROBJ(pctxt->pheapCurrent, sizeof(RESOURCE));
        if (pres == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("AcquireASLMutex: failed to allocate context resource"));
        }
        else
        {
            pres->dwResType = RESTYPE_MUTEX;
            pres->pctxtOwner = pctxt;
            pres->pvResObj = pm;
            ListInsertHead(&pres->list, &pctxt->plistResources);

            pm->dwcOwned = 1;
            pm->hOwner = (HANDLE)pres;
            pctxt->dwSyncLevel = pm->dwSyncLevel;
        }
    }
    else if (((PRESOURCE)pm->hOwner)->pctxtOwner == pctxt)
    {
        pm->dwcOwned++;
    }
    else
    {
        QueueContext(pctxt, wTimeout, &pm->plistWaiters);
        rc = AMLISTA_PENDING;
    }

    EXIT(2, ("AcquireASLMutex=%x (CurrentOwner=%x)\n", rc, pm->hOwner));
    return rc;
}       //AcquireASLMutex

/***LP  ReleaseASLMutex - release ASL mutex
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pm -> MUTEX structure
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseASLMutex(PCTXT pctxt, PMUTEXOBJ pm)
{
    TRACENAME("RELEASEASLMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ReleaseASLMutex(pctxt=%x,pm=%x)\n", pctxt, pm));

    if (pm->dwcOwned == 0)
    {
        rc = AMLI_LOGERR(AMLIERR_MUTEX_NOT_OWNED,
                         ("ReleaseASLMutex: Mutex is not owned"));
    }
    else
    {
        PRESOURCE pres;

        pres = (PRESOURCE)pm->hOwner;
        if ((pres == NULL) || (pres->pctxtOwner != pctxt))
        {
            rc = AMLI_LOGERR(AMLIERR_MUTEX_NOT_OWNER,
                             ("ReleaseASLMutex: Mutex is owned by a different owner"));
        }
        else if (pm->dwSyncLevel > pctxt->dwSyncLevel)
        {
            rc = AMLI_LOGERR(AMLIERR_MUTEX_INVALID_LEVEL,
                             ("ReleaseASLMutex: invalid sync level (MutexLevel=%d,CurrentLevel=%x",
                              pm->dwSyncLevel, pctxt->dwSyncLevel));
        }
        else
        {
            pctxt->dwSyncLevel = pm->dwSyncLevel;
            pm->dwcOwned--;
            if (pm->dwcOwned == 0)
            {
                ListRemoveEntry(&pres->list, &pctxt->plistResources);
                FREECROBJ(pres);
                pm->hOwner = NULL;
                DequeueAndReadyContext(&pm->plistWaiters);
            }
        }
    }

    EXIT(2, ("ReleaseASLMutex=%x\n", rc));
    return rc;
}       //ReleaseASLMutex

/***LP  WaitASLEvent - wait ASL event
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pe -> EVENT structure
 *      wTimeOut - timeout in ms
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WaitASLEvent(PCTXT pctxt, PEVENTOBJ pe, USHORT wTimeout)
{
    TRACENAME("WAITASLEVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("WaitASLEvent(pctxt=%x,pe=%x,Timeout=%d)\n", pctxt, pe, wTimeout));

    if (pctxt->dwfCtxt & CTXTF_TIMEOUT)
    {
        pctxt->dwfCtxt &= ~CTXTF_TIMEOUT;
        rc = AMLISTA_TIMEOUT;
    }
    else if (pe->dwcSignaled > 0)
    {
        pe->dwcSignaled--;
    }
    else
    {
        QueueContext(pctxt, wTimeout, &pe->plistWaiters);
        rc = AMLISTA_PENDING;
    }

    EXIT(2, ("WaitASLEvent=%x\n", rc));
    return rc;
}       //WaitASLEvent

/***LP  ResetASLEvent - reset ASL event
 *
 *  ENTRY
 *      pe -> EVENT structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL ResetASLEvent(PEVENTOBJ pe)
{
    TRACENAME("RESETASLEVENT")

    ENTER(2, ("ResetASLEvent(pe=%x)\n", pe));

    pe->dwcSignaled = 0;

    EXIT(2, ("ResetASLEvent!\n"));
}       //ResetASLEvent

/***LP  SignalASLEvent - signal ASL event
 *
 *  ENTRY
 *      pe -> EVENT structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL SignalASLEvent(PEVENTOBJ pe)
{
    TRACENAME("SIGNALASLEVENT")

    ENTER(2, ("SignalASLEvent(pe=%x)\n", pe));

    if (DequeueAndReadyContext(&pe->plistWaiters) == NULL)
    {
        pe->dwcSignaled++;
    }

    EXIT(2, ("SignalASLEvent!\n"));
}       //SignalASLEvent

/***LP  SyncLoadDDB - load a DDB synchronously
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SyncLoadDDB(PCTXT pctxt)
{
    TRACENAME("SYNCLOADDDB")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("SyncLoadDDB(pctxt=%x)\n", pctxt));

    if (KeGetCurrentThread() == gReadyQueue.pkthCurrent)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncLoadDDB: cannot nest a SyncLoadDDB"));
        pctxt->powner = NULL;
        FreeContext(pctxt);
    }
    else if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncLoadDDB: cannot SyncLoadDDB at IRQL >= DISPATCH_LEVEL"));
        pctxt->powner = NULL;
        FreeContext(pctxt);
    }
    else
    {
        SYNCEVENT seEvalObj;

        KeInitializeEvent(&seEvalObj.Event, SynchronizationEvent, FALSE);
        pctxt->pfnAsyncCallBack = (PFNACB)EvalMethodComplete;
        pctxt->pvContext = &seEvalObj;
        rc = RestartContext(pctxt, FALSE);

        while (rc == AMLISTA_PENDING)
        {
            if ((rc = KeWaitForSingleObject(&seEvalObj.Event, Executive,
                                            KernelMode, FALSE,
                                            (PLARGE_INTEGER)NULL)) ==
                STATUS_SUCCESS)
            {
                if (seEvalObj.rcCompleted == AMLISTA_CONTINUE)
                {
                    rc = RestartContext(seEvalObj.pctxt, FALSE);
                }
                else
                {
                    rc = AMLIERR(seEvalObj.rcCompleted);
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_FATAL,
                                 ("SyncLoadDDB: object synchronization failed (rc=%x)",
                                  rc));
            }
        }
    }

    EXIT(2, ("SyncLoadDDB=%x\n", rc));
    return rc;
}       //SyncLoadDDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\strlib.c ===
/*** strlib.c - string functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***EP  StrLen - determine string length
 *
 *  ENTRY
 *      psz -> string
 *	n - limiting length
 *
 *  EXIT
 *      returns string length
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n)
{
    TRACENAME("STRLEN")
    ULONG dwLen;

    ENTER(5, ("StrLen(str=%s,n=%d)\n", psz, n));

    ASSERT(psz != NULL);
    if (n != (ULONG)-1)
        n++;
    for (dwLen = 0; (dwLen <= n) && (*psz != '\0'); psz++)
        dwLen++;

    EXIT(5, ("StrLen=%u\n", dwLen));
    return dwLen;
}       //StrLen

/***EP  StrCpy - copy string
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to copy
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCPY")
    ULONG dwSrcLen;

    ENTER(5, ("StrCpy(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    MEMCPY(pszDst, pszSrc, n);
    pszDst[n] = '\0';

    EXIT(5, ("StrCpy=%s\n", pszDst));
    return pszDst;
}       //StrCpy

/***EP  StrCat - concatenate strings
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to concatenate
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCAT")
    ULONG dwSrcLen, dwDstLen;

    ENTER(5, ("StrCat(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    dwDstLen = StrLen(pszDst, (ULONG)(-1));
    MEMCPY(&pszDst[dwDstLen], pszSrc, n);
    pszDst[dwDstLen + n] = '\0';

    EXIT(5, ("StrCat=%s\n", pszDst));
    return pszDst;
}       //StrCat

/***EP  StrCmp - compare strings
 *
 *  ENTRY
 *      psz1 -> string 1
 *      psz2 -> string 2
 *      n - number of bytes to compare
 *      fMatchCase - TRUE if case sensitive
 *
 *  EXIT
 *      returns 0  if string 1 == string 2
 *              <0 if string 1 < string 2
 *              >0 if string 1 > string 2
 */

LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase)
{
    TRACENAME("STRCMP")
    LONG rc;
    ULONG dwLen1, dwLen2;
    ULONG i;

    ENTER(5, ("StrCmp(s1=%s,s2=%s,n=%d,fMatchCase=%d)\n",
              psz1, psz2, n, fMatchCase));

    ASSERT(psz1 != NULL);
    ASSERT(psz2 != NULL);

    dwLen1 = StrLen(psz1, n);
    dwLen2 = StrLen(psz2, n);
    if (n == (ULONG)(-1))
        n = (dwLen1 > dwLen2)? dwLen1: dwLen2;

    if (fMatchCase)
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(psz1[i] - psz2[i]);
        }
    }
    else
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(TOUPPER(psz1[i]) - TOUPPER(psz2[i]));
        }
    }

    if ((rc == 0) && (i < n))
    {
        if (i < dwLen1)
            rc = (LONG)psz1[i];
        else if (i < dwLen2)
            rc = (LONG)(-psz2[i]);
    }

    EXIT(5, ("StrCmp=%d\n", rc));
    return rc;
}       //StrCmp

/***EP  StrChr - look for a character in a string
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = pszStr; (*psz != c) && (*psz != '\0'); psz++)
        ;

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrChr=%x\n", psz));
    return psz;
}       //StrChr

/***EP  StrRChr - look for a character in a string in reverse direction
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrRChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = &pszStr[StrLen(pszStr, (ULONG)-1)];
         (*psz != c) && (psz > pszStr);
	 psz--)
    {
    }

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrRChr=%x\n", psz));
    return psz;
}       //StrRChr

/***EP  StrTok - find the next token in string
 *
 *  ENTRY
 *      pszStr -> string containing tokens
 *      pszSep -> string containing delimiters
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the beginning of the token
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep)
{
    TRACENAME("STRTOK")
    static PSZ pszNext = NULL;


    ENTER(5, ("StrTok(Str=%s,Sep=%s)\n", pszStr, pszSep));

    ASSERT(pszSep != NULL);

    if (pszStr == NULL)
        pszStr = pszNext;

    if (pszStr != NULL)
    {
        //
        // Skip leading delimiter characters
        //
        while ((*pszStr != '\0') && (StrChr(pszSep, *pszStr) != NULL))
            pszStr++;

        for (pszNext = pszStr;
             (*pszNext != '\0') && (StrChr(pszSep, *pszNext) == NULL);
             pszNext++)
            ;

        if (*pszStr == '\0')
            pszStr = NULL;
        else if (*pszNext != '\0')
        {
            *pszNext = '\0';
            pszNext++;
        }
    }

    EXIT(5, ("StrTok=%s (Next=%s)\n",
             pszStr? pszStr: "(null)", pszNext? pszNext: "(null)"));
    return pszStr;
}       //StrTok

/***EP  StrToUL - convert the number in a string to a unsigned long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOUL")
    ULONG n = 0;
    ULONG m;

    ENTER(5, ("StrToUL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
	    break;

        if (m < dwBase)
        {
            n = (n*dwBase) + m;
            psz++;
        }
        else
            break;
    }

    if (ppszEnd != NULL)
        *ppszEnd = psz;

    EXIT(5, ("StrToUL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToUL

/***EP  StrToL - convert the number in a string to a long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOL")
    LONG n = 0;
    BOOLEAN fMinus;

    ENTER(5, ("StrToL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (*psz == '-')
    {
        fMinus = TRUE;
        psz++;
    }
    else
        fMinus = FALSE;

    n = (LONG)StrToUL(psz, ppszEnd, dwBase);

    if (fMinus)
        n = -n;

    EXIT(5, ("StrToL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToL

/***EP  StrStr - find a substring in a given string
 *
 *  ENTRY
 *      psz1 -> string to be searched
 *      psz2 -> substring to find
 *
 *  EXIT-SUCCESS
 *      returns pointer to psz1 where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrStr(PSZ psz1, PSZ psz2)
{
    TRACENAME("STRSTR")
    PSZ psz = psz1;
    ULONG dwLen;

    ENTER(5, ("StrStr(psz1=%s,psz2=%s)\n", psz1, psz2));

    dwLen = StrLen(psz2, (ULONG)-1);
    while ((psz = StrChr(psz, *psz2)) != NULL)
    {
        if (StrCmp(psz, psz2, dwLen, TRUE) == 0)
            break;
        else
            psz++;
    }

    EXIT(5, ("StrStr=%s\n", psz));
    return psz;
}       //StrStr

/***EP  StrUpr - convert string to upper case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrUpr(PSZ pszStr)
{
    TRACENAME("STRUPR")
    PSZ psz;

    ENTER(5, ("StrUpr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOUPPER(*psz);
    }

    EXIT(5, ("StrUpr=%s\n", pszStr));
    return pszStr;
}       //StrUpr

/***EP  StrLwr - convert string to lower case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrLwr(PSZ pszStr)
{
    TRACENAME("STRLWR")
    PSZ psz;

    ENTER(5, ("StrLwr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOLOWER(*psz);
    }

    EXIT(5, ("StrLwr=%s\n", pszStr));
    return pszStr;
}       //StrLwr

/***EP  UlToA - convert an unsigned long value to a string
 *
 *  ENTRY
 *      dwValue - data
 *      pszStr -> string
 *      dwRadix - radix
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix)
{
    TRACENAME("ULTOA")
    PSZ psz;
    char ch;

    ENTER(5, ("UlToA(Value=%x,pszStr=%x,Radix=%d\n", dwValue, pszStr, dwRadix));

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PSZ psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    EXIT(5, ("UlToA=%s\n", pszStr));
    return pszStr;
}       //UlToA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\type2op.c ===
/*** type2op.c - Parse type 2 opcodes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/16/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  Buffer - Parse and execute the Buffer instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Buffer(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BUFFER")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwInitSize = (ULONG)(pterm->pbOpEnd - pctxt->pbOp);

    ENTER(2, ("Buffer(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintBuffData(pctxt->pbOp, dwInitSize);
        }
      #endif

        if ((ULONG)pterm->pdataArgs[0].uipDataValue < dwInitSize)
        {
            rc = AMLI_LOGERR(AMLIERR_BUFF_TOOSMALL,
                             ("Buffer: too many initializers (buffsize=%d,InitSize=%d)",
                              pterm->pdataArgs[0].uipDataValue, dwInitSize));
        }
        else if (pterm->pdataArgs[0].uipDataValue == 0)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_BUFFSIZE,
                             ("Buffer: invalid buffer size (size=%d)",
                             pterm->pdataArgs[0].uipDataValue));
        }
        else if ((pterm->pdataResult->pbDataBuff =
                  NEWBDOBJ(gpheapGlobal,
                           (ULONG)pterm->pdataArgs[0].uipDataValue)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Buffer: failed to allocate data buffer (size=%d)",
                             pterm->pdataArgs[0].uipDataValue));
        }
        else
        {
            pterm->pdataResult->dwDataType = OBJTYPE_BUFFDATA;
            pterm->pdataResult->dwDataLen = (ULONG)
                                            pterm->pdataArgs[0].uipDataValue;
            MEMZERO(pterm->pdataResult->pbDataBuff,
                    pterm->pdataResult->dwDataLen);
            MEMCPY(pterm->pdataResult->pbDataBuff, pctxt->pbOp, dwInitSize);
            pctxt->pbOp = pterm->pbOpEnd;
        }
    }

    EXIT(2, ("Buffer=%x\n", rc));
    return rc;
}       //Buffer

/***LP  Package - Parse and execute the Package instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Package(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("PACKAGE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Package(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        PPACKAGEOBJ ppkgobj;

        pterm->pdataResult->dwDataLen = (ULONG)
                                        (FIELD_OFFSET(PACKAGEOBJ, adata) +
                                         sizeof(OBJDATA)*
                                         pterm->pdataArgs[0].uipDataValue);

        if ((ppkgobj = (PPACKAGEOBJ)NEWPKOBJ(gpheapGlobal,
                                             pterm->pdataResult->dwDataLen)) ==
            NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Package: failed to allocate package object (size=%d)",
                             pterm->pdataResult->dwDataLen));
        }
        else
        {
            PPACKAGE ppkg;

            pterm->pdataResult->dwDataType = OBJTYPE_PKGDATA;
            MEMZERO(ppkgobj, pterm->pdataResult->dwDataLen);
            pterm->pdataResult->pbDataBuff = (PUCHAR)ppkgobj;
            ppkgobj->dwcElements = (UCHAR)pterm->pdataArgs[0].uipDataValue;

            if ((rc = PushFrame(pctxt, SIG_PACKAGE, sizeof(PACKAGE),
                                ParsePackage, &ppkg)) == STATUS_SUCCESS)
            {
                ppkg->ppkgobj = ppkgobj;
                ppkg->pbOpEnd = pterm->pbOpEnd;
            }
        }
    }

    EXIT(2, ("Package=%x\n", rc));
    return rc;
}       //Package

/***LP  ParsePackage - Parse and evaluate the Package term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppkg -> PACKAGE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParsePackage(PCTXT pctxt, PPACKAGE ppkg, NTSTATUS rc)
{
    TRACENAME("PARSEPACKAGE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppkg->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;
    int i;

    ENTER(2, ("ParsePackage(Stage=%d,pctxt=%x,pbOp=%x,ppkg=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppkg, rc));

    ASSERT(ppkg->FrameHdr.dwSig == SIG_PACKAGE);
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do some debugger work here.
            //
            ppkg->FrameHdr.dwfFrame++;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PrintIndent(pctxt);
                PRINTF("{");
                gDebugger.iPrintLevel++;
            }
          #endif

        case 1:
        Stage1:
            //
            // Stage 1: Parse package elements
            //
            while ((pctxt->pbOp < ppkg->pbOpEnd) &&
                   (ppkg->iElement < (int)ppkg->ppkgobj->dwcElements))

            {
                i = ppkg->iElement++;
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (i > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                if ((*pctxt->pbOp == OP_BUFFER) || (*pctxt->pbOp == OP_PACKAGE))
                {
                    if (((rc = ParseOpcode(pctxt, NULL,
                                           &ppkg->ppkgobj->adata[i])) !=
                         STATUS_SUCCESS) ||
                        (&ppkg->FrameHdr !=
                         (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                    {
                        break;
                    }
                }
                else
                {
                  #ifdef DEBUGGER
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        PrintIndent(pctxt);
                    }
                  #endif

                    if (((rc = ParseIntObj(&pctxt->pbOp,
                                           &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE) &&
                        ((rc = ParseString(&pctxt->pbOp,
                                           &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE) &&
                        ((rc = ParseObjName(&pctxt->pbOp,
                                            &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE))
                    {
                        rc = AMLI_LOGERR(rc,
                                         ("ParsePackage: invalid opcode 0x%02x at 0x%08x",
                                          *pctxt->pbOp, pctxt->pbOp));
                        break;
                    }
                    else if (rc != STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }

            if ((rc == AMLISTA_PENDING) ||
                (&ppkg->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if ((rc == STATUS_SUCCESS) &&
                     (pctxt->pbOp < ppkg->pbOpEnd) &&
                     (ppkg->iElement < (int)ppkg->ppkgobj->dwcElements))
            {
                goto Stage1;
            }

            ppkg->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                gDebugger.iPrintLevel--;
                PrintIndent(pctxt);
                PRINTF("}");
                gDebugger.iPrintLevel--;
            }
          #endif
            PopFrame(pctxt);
    }

    EXIT(2, ("ParsePackage=%x\n", rc));
    return rc;
}       //ParsePackage

/***LP  Acquire - Parse and execute the Acquire instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Acquire(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ACQUIRE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Acquire(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        PACQUIRE pacq;

        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_MUTEX)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Acquire: object is not mutex type (obj=%s,type=%s)",
                              GetObjectPath(pterm->pnsObj),
                              GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
        }
        else if ((rc = PushFrame(pctxt, SIG_ACQUIRE, sizeof(ACQUIRE),
                                 ParseAcquire, &pacq)) == STATUS_SUCCESS)
        {
            pacq->pmutex = (PMUTEXOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pacq->FrameHdr.dwfFrame = (pterm->pnsObj->ObjData.dwfData &
                                       DATAF_GLOBAL_LOCK)?
                                        ACQF_SET_RESULT | ACQF_NEED_GLOBALLOCK:
                                        ACQF_SET_RESULT;
            pacq->wTimeout = (USHORT)pterm->pdataArgs[1].uipDataValue;
            pacq->pdataResult = pterm->pdataResult;
        }
    }

    EXIT(2, ("Acquire=%x\n", rc));
    return rc;
}       //Acquire

/***LP  Concat - Parse and execute the Concatenate instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Concat(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CONCAT")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Concat(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "DD")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        if (pterm->pdataArgs[0].dwDataType != pterm->pdataArgs[1].dwDataType)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Concat: Source1 and Source2 are different types (Type1=%s,Type2=%s)",
                              GetObjectTypeName(pterm->pdataArgs[0].dwDataType),
                              GetObjectTypeName(pterm->pdataArgs[1].dwDataType)));
        }
        else
        {
            if (pterm->pdataArgs[0].dwDataType == OBJTYPE_INTDATA)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                pterm->pdataResult->dwDataLen = sizeof(ULONG)*2;
            }
            else
            {
                pterm->pdataResult->dwDataType = pterm->pdataArgs[0].dwDataType;
                pterm->pdataResult->dwDataLen = pterm->pdataArgs[0].dwDataLen +
                                                pterm->pdataArgs[1].dwDataLen;
                //
                // If object is string, take one NULL off
                //
                if (pterm->pdataResult->dwDataType == OBJTYPE_STRDATA)
                    pterm->pdataResult->dwDataLen--;
            }

            if ((pterm->pdataResult->pbDataBuff =
                     (pterm->pdataResult->dwDataType == OBJTYPE_STRDATA)?
                     NEWSDOBJ(gpheapGlobal,
                              pterm->pdataResult->dwDataLen):
                     NEWBDOBJ(gpheapGlobal,
                              pterm->pdataResult->dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("Concat: failed to allocate target buffer"));
            }
            else if (pterm->pdataArgs[0].dwDataType == OBJTYPE_INTDATA)
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       &pterm->pdataArgs[0].uipDataValue, sizeof(ULONG));
                MEMCPY(pterm->pdataResult->pbDataBuff + sizeof(ULONG),
                       &pterm->pdataArgs[1].uipDataValue, sizeof(ULONG));
            }
            else if (pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA)
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       pterm->pdataArgs[0].pbDataBuff,
                       pterm->pdataArgs[0].dwDataLen - 1);
                MEMCPY(pterm->pdataResult->pbDataBuff +
                       pterm->pdataArgs[0].dwDataLen - 1,
                       pterm->pdataArgs[1].pbDataBuff,
                       pterm->pdataArgs[1].dwDataLen);
            }
            else
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       pterm->pdataArgs[0].pbDataBuff,
                       pterm->pdataArgs[0].dwDataLen);
                MEMCPY(pterm->pdataResult->pbDataBuff +
                       pterm->pdataArgs[0].dwDataLen,
                       pterm->pdataArgs[1].pbDataBuff,
                       pterm->pdataArgs[1].dwDataLen);
            }

            if (rc == STATUS_SUCCESS)
            {
                rc = WriteObject(pctxt, pdata, pterm->pdataResult);
            }
        }
    }

    EXIT(2, ("Concat=%x\n", rc));
    return rc;
}       //Concat

/***LP  DerefOf - Parse and execute the DerefOf instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL DerefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DEREFOF")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("DerefOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "R")) == STATUS_SUCCESS)
    {
        POBJDATA pdata;

        pdata = &pterm->pdataArgs[0];
        if (pdata->dwDataType == OBJTYPE_OBJALIAS)
            pdata = &GetBaseObject(pdata->pnsAlias)->ObjData;
        else if (pdata->dwDataType == OBJTYPE_DATAALIAS)
            pdata = GetBaseData(pdata->pdataAlias);

        rc = ReadObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("DerefOf=%x (type=%s,value=%x,len=%d,buff=%x)\n",
             rc, GetObjectTypeName(pterm->pdataResult->dwDataType),
             pterm->pdataResult->uipDataValue, pterm->pdataResult->dwDataLen,
             pterm->pdataResult->pbDataBuff));
    return rc;
}       //DerefOf

/***LP  ExprOp1 - Parse and execute the 1-operand expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ExprOp1(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EXPROP1")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;
    ULONG dwResult = 0;

    ENTER(2, ("ExprOp1(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        int i;
        ULONG dwData1, dwData2;

        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_FINDSETLBIT:
                ENTER(2, ("FindSetLeftBit(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 31; i >= 0; --i)
                {
                    if (pterm->pdataArgs[0].uipDataValue & (1 << i))
                    {
                        dwResult = i + 1;
                        break;
                    }
                }
                EXIT(2, ("FindSetLeftBit=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_FINDSETRBIT:
                ENTER(2, ("FindSetRightBit(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 0; i <= 31; ++i)
                {
                    if (pterm->pdataArgs[0].uipDataValue & (1 << i))
                    {
                        dwResult = i + 1;
                        break;
                    }
                }
                EXIT(2, ("FindSetRightBit=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_FROMBCD:
                ENTER(2, ("FromBCD(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (dwData1 = (ULONG)pterm->pdataArgs[0].uipDataValue,
                     dwData2 = 1;
                     dwData1 != 0;
                     dwData2 *= 10, dwData1 >>= 4)
                {
                    dwResult += (dwData1 & 0x0f)*dwData2;
                }
                EXIT(2, ("FromBCD=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_TOBCD:
                ENTER(2, ("ToBCD(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 0, dwData1 = (ULONG)pterm->pdataArgs[0].uipDataValue;
                     dwData1 != 0;
                     ++i, dwData1 /= 10)
                {
                    dwResult |= (dwData1%10) << (4*i);
                }
                EXIT(2, ("ToBCD=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_NOT:
                ENTER(2, ("Not(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                dwResult = ~(ULONG)pterm->pdataArgs[0].uipDataValue;
                EXIT(2, ("Not=%x (Result=%x)\n", rc, dwResult));
        }

        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = (ULONG_PTR)dwResult;
        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("ExprOp1=%x (value=%x)\n", rc, dwResult));
    return rc;
}       //ExprOp1

/***LP  ExprOp2 - Parse and execute 2-operands expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ExprOp2(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EXPROP2")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("ExprOp2(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_ADD:
                ENTER(2, ("Add(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue +
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Add=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_AND:
                ENTER(2, ("And(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue &
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("And=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_MULTIPLY:
                ENTER(2, ("Multiply(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue *
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Multiply=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_NAND:
                ENTER(2, ("NAnd(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    ~(pterm->pdataArgs[0].uipDataValue &
                      pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("NAnd=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_NOR:
                ENTER(2, ("NOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    ~(pterm->pdataArgs[0].uipDataValue |
                      pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("NOr=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_OR:
                ENTER(2, ("Or(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue |
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Or=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SHIFTL:
                ENTER(2, ("ShiftLeft(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    SHIFTLEFT(pterm->pdataArgs[0].uipDataValue,
                              pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("ShiftLeft=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SHIFTR:
                ENTER(2, ("ShiftRight(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    SHIFTRIGHT(pterm->pdataArgs[0].uipDataValue,
                               pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("ShiftRight=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SUBTRACT:
                ENTER(2, ("Subtract(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue -
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Subtract=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_XOR:
                ENTER(2, ("XOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue ^
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("XOr=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
        }

        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("ExprOp2=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //ExprOp2

/***LP  Divide - Parse and execute the Divide instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Divide(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DIVIDE")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata1, pdata2;
    ULONG dwDividend = 0, dwRemainder = 0;

    ENTER(2, ("Divide(pctxt=%x,pbOp=%x,pterm)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata1))
         == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[3], OBJTYPE_DATAOBJ, &pdata2))
         == STATUS_SUCCESS))
    {
        ENTER(2, ("Divide(Value1=%x,Value2=%x)\n",
                  pterm->pdataArgs[0].uipDataValue,
                  pterm->pdataArgs[1].uipDataValue));
        dwDividend = (ULONG)(pterm->pdataArgs[0].uipDataValue /
                             pterm->pdataArgs[1].uipDataValue);
        dwRemainder = (ULONG)(pterm->pdataArgs[0].uipDataValue %
                              pterm->pdataArgs[1].uipDataValue);
        EXIT(2, ("Divide=%x (Dividend=%x,Remainder=%x)\n",
                 rc, dwDividend, dwRemainder));

        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = (ULONG_PTR)dwDividend;

        if ((rc = PushPost(pctxt, ProcessDivide, (ULONG_PTR)pdata2, 0,
                           pterm->pdataResult)) == STATUS_SUCCESS)
        {
            rc = PutIntObjData(pctxt, pdata1, dwRemainder);
        }
    }

    EXIT(2, ("Divide=%x (Dividend=%x,Remainder%x)\n",
             rc, dwDividend, dwRemainder));
    return rc;
}       //Divide

/***LP  ProcessDivide - post processing of Divide
 *
 *  ENTRY
 *      pctxt - CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessDivide(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSDIVIDE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppost->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;

    ENTER(2, ("ProcessDivide(Stage=%d,pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do the write.
            //
            ppost->FrameHdr.dwfFrame++;
            rc = WriteObject(pctxt, (POBJDATA)ppost->uipData1,
                             ppost->pdataResult);

            if ((rc == AMLISTA_PENDING) ||
                (&ppost->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ProcessDivide=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessDivide

/***LP  IncDec - Parse and execute the Increment/Decrement instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IncDec(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INCDEC")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("IncDec(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = PushPost(pctxt, ProcessIncDec,
                       (ULONG_PTR)pterm->pamlterm->dwOpcode,
                       (ULONG_PTR)&pterm->pdataArgs[0], pterm->pdataResult)) ==
        STATUS_SUCCESS)
    {
        rc = ReadObject(pctxt, &pterm->pdataArgs[0], pterm->pdataResult);
    }

    EXIT(2, ("IncDec=%x\n", rc));
    return rc;
}       //IncDec

/***LP  ProcessIncDec - post processing of IncDec
 *
 *  ENTRY
 *      pctxt - CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessIncDec(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSINCDEC")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppost->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;

    ENTER(2, ("ProcessIncDec(Stage=%d,pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: do the inc/dec operation.
            //
            ppost->FrameHdr.dwfFrame++;
            if (ppost->pdataResult->dwDataType != OBJTYPE_INTDATA)
            {
                FreeDataBuffs(ppost->pdataResult, 1);
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("ProcessIncDec: object is not integer type (obj=%x,type=%s)",
                                  ppost->pdataResult,
                                  GetObjectTypeName(ppost->pdataResult->dwDataType)));
            }
            else if (ppost->uipData1 == OP_INCREMENT)
            {
                ENTER(2, ("Increment(Value=%x)\n",
                          ppost->pdataResult->uipDataValue));
                ppost->pdataResult->uipDataValue++;
                EXIT(2, ("Increment=%x (Value=%x)\n",
                         rc, ppost->pdataResult->uipDataValue));
            }
            else
            {
                ENTER(2, ("Decrement(Value=%x)\n",
                          ppost->pdataResult->uipDataValue));
                ppost->pdataResult->uipDataValue--;
                EXIT(2, ("Decrement=%x (Value=%x)\n",
                         rc, ppost->pdataResult->uipDataValue));
            }

            if (rc == STATUS_SUCCESS)
            {
                rc = WriteObject(pctxt, (POBJDATA)ppost->uipData2,
                                 ppost->pdataResult);

                if ((rc == AMLISTA_PENDING) ||
                    (&ppost->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ProcessIncDec=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessIncDec

/***LP  Index - Parse and execute the Index instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Index(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INDEX")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Index(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "CI")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATA, &pdata)) ==
         STATUS_SUCCESS))
    {
        if (pterm->pdataArgs[0].dwDataType == OBJTYPE_PKGDATA)
        {
            PPACKAGEOBJ ppkg = (PPACKAGEOBJ)pterm->pdataArgs[0].pbDataBuff;

            if ((ULONG)pterm->pdataArgs[1].uipDataValue < ppkg->dwcElements)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_DATAALIAS;
                pterm->pdataResult->pdataAlias =
                    &ppkg->adata[pterm->pdataArgs[1].uipDataValue];
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("Index: index out-of-bound (index=%d,max=%d)",
                                  pterm->pdataArgs[1].uipDataValue,
                                  ppkg->dwcElements));
            }
        }
        else
        {
            ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_BUFFDATA);
            if ((ULONG)pterm->pdataArgs[1].uipDataValue <
                pterm->pdataArgs[0].dwDataLen)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_BUFFFIELD;
                pterm->pdataResult->dwDataLen = sizeof(BUFFFIELDOBJ);
                if ((pterm->pdataResult->pbDataBuff =
                     NEWBFOBJ(pctxt->pheapCurrent,
                              pterm->pdataResult->dwDataLen)) == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("Index: failed to allocate buffer field object"));
                }
                else
                {
                    PBUFFFIELDOBJ pbf = (PBUFFFIELDOBJ)pterm->pdataResult->pbDataBuff;

                    pbf->FieldDesc.dwByteOffset =
                        (ULONG)pterm->pdataArgs[1].uipDataValue;
                    pbf->FieldDesc.dwStartBitPos = 0;
                    pbf->FieldDesc.dwNumBits = 8;
                    pbf->pbDataBuff = pterm->pdataArgs[0].pbDataBuff;
                    pbf->dwBuffLen = pterm->pdataArgs[0].dwDataLen;
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("Index: index out-of-bound (index=%d,max=%d)",
                                  pterm->pdataArgs[1].uipDataValue,
                                  pterm->pdataArgs[0].dwDataLen));
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            rc = WriteObject(pctxt, pdata, pterm->pdataResult);
        }
    }

    EXIT(2, ("Index=%x (Type=%s,Value=%x,Len=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pterm->pdataResult->dwDataType),
             pterm->pdataResult->uipDataValue, pterm->pdataResult->dwDataLen,
             pterm->pdataResult->pbDataBuff));
    return rc;
}       //Index

/***LP  LNot - Parse and execute the LNot instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LNot(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LNOT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("LNot(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        ENTER(2, ("LNot(Value=%x)\n", pterm->pdataArgs[0].uipDataValue));
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        if (pterm->pdataArgs[0].uipDataValue == 0)
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
        else
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
        EXIT(2, ("LNot=%x (Value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    }

    EXIT(2, ("LNot=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //LNot

/***LP  LogOp2 - Parse and execute 2-operand logical expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LogOp2(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LOGOP2")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("LogOp2(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS)
    {
        BOOLEAN fResult = FALSE;

        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_LAND:
                ENTER(2, ("LAnd(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue &&
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LAnd=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LOR:
                ENTER(2, ("LOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue ||
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LOr=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LG:
                ENTER(2, ("LGreater(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue >
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LGreater=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LL:
                ENTER(2, ("LLess(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue <
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LLess=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LEQ:
                ENTER(2, ("LEqual(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue ==
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LEqual=%x (Result=%x)\n", rc, fResult));
        }
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = fResult?
                                              DATAVALUE_ONES: DATAVALUE_ZERO;
    }

    EXIT(2, ("LogOp2=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //LogOp2

/***LP  ObjTypeSizeOf - Parse and execute the ObjectType/SizeOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ObjTypeSizeOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("OBJTYPESIZEOF")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("ObjTypeSizeOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    pdata = GetBaseData(&pterm->pdataArgs[0]);
    pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
    if (pterm->pamlterm->dwOpcode == OP_OBJTYPE)
    {
        ENTER(2, ("ObjectType(pdataObj=%x)\n", pdata));
        pterm->pdataResult->uipDataValue = (ULONG_PTR)pdata->dwDataType;
        EXIT(2, ("ObjectType=%x (Type=%s)\n",
                 rc, GetObjectTypeName(pdata->dwDataType)));
    }
    else
    {
        ENTER(2, ("SizeOf(pdataObj=%x)\n", pdata));
        switch (pdata->dwDataType)
        {
            case OBJTYPE_BUFFDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)pdata->dwDataLen;
                break;

            case OBJTYPE_STRDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)
                                                    (pdata->dwDataLen - 1);
                break;

            case OBJTYPE_PKGDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)
                    ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                 ("SizeOf: expected argument type string/buffer/package (type=%s)",
                                  GetObjectTypeName(pdata->dwDataType)));
        }
        EXIT(2, ("Sizeof=%x (Size=%d)\n", rc, pterm->pdataResult->uipDataValue));
    }

    EXIT(2, ("ObjTypeSizeOf=%x (value=%x)\n",
             rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //ObjTypeSizeOf

/***LP  RefOf - Parse and execute the RefOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("REFOF")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("RefOf(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    MoveObjData(pterm->pdataResult, &pterm->pdataArgs[0]);

    EXIT(2, ("RefOf=%x (ObjAlias=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //RefOf

/***LP  CondRefOf - Parse and execute the CondRefOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CondRefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CONDREFOF")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("CondRefOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata)) ==
        STATUS_SUCCESS)
    {
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        if ((pterm->pdataArgs[0].dwDataType == OBJTYPE_OBJALIAS) ||
            (pterm->pdataArgs[0].dwDataType == OBJTYPE_DATAALIAS))
        {
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
            rc = WriteObject(pctxt, pdata, &pterm->pdataArgs[0]);
        }
        else
        {
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
        }
    }

    EXIT(2, ("CondRefOf=%x (ObjAlias=%x)\n",
             rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //CondRefOf

/***LP  Store - Parse and execute the Store instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Store(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("STORE")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Store(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata)) ==
        STATUS_SUCCESS)
    {
        MoveObjData(pterm->pdataResult, &pterm->pdataArgs[0]);
        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("Store=%x (type=%s,value=%x,buff=%x,len=%x)\n",
             rc, GetObjectTypeName(pterm->pdataArgs[0].dwDataType),
             pterm->pdataArgs[0].uipDataValue, pterm->pdataArgs[0].pbDataBuff,
             pterm->pdataArgs[0].dwDataLen));
    return rc;
}       //Store

/***LP  Wait - Parse and execute the Wait instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Wait(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("WAIT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Wait(pctxt=%x,pbOp=%x,pter=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Wait: object is not event type (obj=%s,type=%s)",
                              GetObjectPath(pterm->pnsObj),
                              GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
        }
        else if ((rc = PushPost(pctxt, ProcessWait, 0, 0, pterm->pdataResult))
                 == STATUS_SUCCESS)
        {
            rc = WaitASLEvent(pctxt,
                              (PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff,
                              (USHORT)pterm->pdataArgs[1].uipDataValue);
        }
    }

    EXIT(2, ("Wait=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //Wait

/***LP  ProcessWait - post process of Wait
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessWait(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSWAIT")

    ENTER(2, ("ProcessWait(pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);
    ppost->pdataResult->dwDataType = OBJTYPE_INTDATA;
    if (rc == AMLISTA_TIMEOUT)
    {
        ppost->pdataResult->uipDataValue = DATAVALUE_ONES;
        rc = STATUS_SUCCESS;
    }
    else
    {
        ppost->pdataResult->uipDataValue = DATAVALUE_ZERO;
    }
    PopFrame(pctxt);

    EXIT(2, ("ProcessWait=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessWait

/***LP  Match - Parse and execute the Match instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Match(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("MATCH")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Match(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "PIIIII")) == STATUS_SUCCESS)
    {
        PPACKAGEOBJ ppkgobj = (PPACKAGEOBJ)pterm->pdataArgs[0].pbDataBuff;
        OBJDATA data;
        int i;

        MEMZERO(&data, sizeof(data));
        for (i = (int)pterm->pdataArgs[5].uipDataValue;
             rc == STATUS_SUCCESS;
             ++i)
        {
            FreeDataBuffs(&data, 1);
            //
            // This will never block because package element can only be simple
            // data.
            //
            if (((rc = EvalPackageElement(ppkgobj, i, &data)) ==
                 STATUS_SUCCESS) &&
                (data.dwDataType == OBJTYPE_INTDATA) &&
                MatchData((ULONG)data.uipDataValue,
                          (ULONG)pterm->pdataArgs[1].uipDataValue,
                          (ULONG)pterm->pdataArgs[2].uipDataValue) &&
                MatchData((ULONG)data.uipDataValue,
                          (ULONG)pterm->pdataArgs[3].uipDataValue,
                          (ULONG)pterm->pdataArgs[4].uipDataValue))
            {
                break;
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = (ULONG_PTR)i;
        }
        else if (rc == AMLIERR_INDEX_TOO_BIG)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
            rc = STATUS_SUCCESS;
        }

        FreeDataBuffs(&data, 1);
    }

    EXIT(2, ("Match=%x\n", rc));
    return rc;
}       //Match

/***LP  MatchData - Match data of a package element
 *
 *  ENTRY
 *      dwPkgData - package element data
 *      dwOp - operation
 *      dwData - data
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL MatchData(ULONG dwPkgData, ULONG dwOp, ULONG dwData)
{
    TRACENAME("MATCHDATA")
    BOOLEAN rc = FALSE;

    ENTER(2, ("MatchData(PkgData=%x,Op=%x,Data=%x)\n",
              dwPkgData, dwOp, dwData));

    switch (dwOp)
    {
        case MTR:
            rc = TRUE;
            break;

        case MEQ:
            rc = (BOOLEAN)(dwPkgData == dwData);
            break;

        case MLE:
            rc = (BOOLEAN)(dwPkgData <= dwData);
            break;

        case MLT:
            rc = (BOOLEAN)(dwPkgData < dwData);
            break;

        case MGE:
            rc = (BOOLEAN)(dwPkgData >= dwData);
            break;

        case MGT:
            rc = (BOOLEAN)(dwPkgData > dwData);
            break;
    }

    EXIT(2, ("MatchData=%x\n", rc));
    return rc;
}       //MatchData

NTSTATUS LOCAL OSInterface(
                                PCTXT pctxt, 
                                PTERM pterm
                              )
/*++

Routine Description:

    Check if the OS is supported.

Arguments:

    PCTXT pctxt - Pointer to the context structure.
    PTERM pterm - Pointer to the Term structure.

Return Value:

    STATUS_SUCCESS on match.

--*/
{
    TRACENAME("OSInterface")
    NTSTATUS rc;
    // Add future OS strings here.
    char Win2000[] = "Windows 2000";
    char Win2001[] = "Windows 2001";
    char Win2001SP1[] = "Windows 2001 SP1";
    char* SupportedOSList[] = {
                                    Win2000, 
                                    Win2001,
                                    Win2001SP1
                                };
    ULONG ListSize = sizeof(SupportedOSList) / sizeof(char*);
    ULONG i = 0;
    
    ENTER(2, ("OSInterface(pctxt=%x,pbOp=%x,pterm=%x, Querying for %s)\n",
              pctxt, pctxt->pbOp, pterm, pterm->pdataArgs[0].pbDataBuff));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "A")) == STATUS_SUCCESS)
    {
        if ((rc = ValidateArgTypes((pterm->pdataArgs)->pdataAlias, "Z")) == STATUS_SUCCESS)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
                    
            for(i=0; i<ListSize; i++)
            {
                if(STRCMPI(SupportedOSList[i], (pterm->pdataArgs)->pdataAlias->pbDataBuff) == 0)
                { 
                    pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
                    rc = STATUS_SUCCESS;

                    //
                    // Save highest OS Version Queried
                    // 0 == Windows 2000
                    // 1 == Windows 2001
                    // 2 == Windows 2001 SP1
                    // .
                    // .
                    //
                    if(gdwHighestOSVerQueried < i)
                    {
                        gdwHighestOSVerQueried = i;
                    }
                    
                    break;
                }
            }
        }
    }
    
    EXIT(2, ("OSInterface=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //OSInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\uasmdata.c ===
/*** uasmdata.c - Unassembler data
 *
 *  This module contains data declaration of the unassembler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"

#ifdef DEBUGGER

int gicCode = 0;
int giLevel = 0;
PNSOBJ gpnsCurUnAsmScope = NULL;

#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN      UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  CD, 0, OP_NONE, NULL, NULL, OL|CL|LL|AF|AV,
    "Include",          CD, 0, OP_NONE, NULL, NULL, AF,
    "External",         CD, 0, OP_NONE, NULL, "uX", AF,

    // Short Objects
    "Zero",             CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",              CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",             CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",         CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",             SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",             SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",             SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",             SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",             SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",             SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",             SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",           SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",           SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",           SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",           SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",           SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",           SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",           SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",           SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",            SN, 0, OP_DEBUG,    NULL, NULL, 0,
    
    // Named Terms
    "Alias",            NS, 0, OP_ALIAS, "NN", "Ua", 0,
    "Name",             NS, 0, OP_NAME,  "NO", "u",  0,
    "Scope",            NS, 0, OP_SCOPE, "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",           DO, 0, OP_BUFFER,  "C",  "U",  DL|LN,
    "Package",          DO, 0, OP_PACKAGE, "B",  NULL, PL|LN,
    "EISAID",           DO, 0, OP_DWORD,   NULL, NULL, AF,

    // Argument Keywords
    "AnyAcc",           KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",          KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",          KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",         KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",         KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",        KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",             KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",           KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",         KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",      KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",     KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",     KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",         KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",       KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl",  KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",            KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",       KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",    KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",              KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",              KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",              KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",              KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",              KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",              KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",             KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",            KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",       KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",        KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",           KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",        KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",    KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",            KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",            KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",            KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",        KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",     KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",        KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",     KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",       KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",         KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",         KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",        KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",         KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer", KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer", KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",        KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",        KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",         KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",      KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",         KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",      KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",        KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",   KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",     KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",     KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",    KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges", KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",      KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",          KW, $EDG, OP_NONE, NULL, "U", 0,
    "ExtLevel",         KW, $LVL, OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",    KW, $HGH, OP_NONE, NULL, "V", 0,
    "ExtActiveLow",     KW, $LOW, OP_NONE, NULL, "V", 0,

    "ExtShared",        KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",     KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",       KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",           KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",           KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",          KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",           KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",     KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",        KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",         KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",        KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",         KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",      KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",      KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",   KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",     KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",     KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",           FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",         FM, 0, 0x01,    NULL, "A",  AF,

    // Named Object Creators
    "BankField",        NO, 0, OP_BANKFIELD,   "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",   NO, 0, OP_BITFIELD,    "CCN",   "UUb",    0,
    "CreateByteField",  NO, 0, OP_BYTEFIELD,   "CCN",   "UUb",    0,
    "CreateDWordField", NO, 0, OP_DWORDFIELD,  "CCN",   "UUb",    0,
    "CreateField",      NO, 0, OP_CREATEFIELD, "CCCN",  "UUUb",   0,
    "CreateWordField",  NO, 0, OP_WORDFIELD,   "CCN",   "UUb",    0,
    "Device",           NO, 0, OP_DEVICE,      "N",     "d",      OL|LN|CC,
    "Event",            NO, 0, OP_EVENT,       "N",     "e",      0,
    "Field",            NO, 0, OP_FIELD,       "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",       NO, 0, OP_IDXFIELD,    "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",           NO, 0, OP_METHOD,      "NKk",   "m!E",    CL|OL|LN|AF|CC,
    "Mutex",            NO, 0, OP_MUTEX,       "NB",    "x",      0,
    "OperationRegion",  NO, 0, OP_OPREGION,    "NKCC",  "oDUU",   AF,
    "PowerResource",    NO, 0, OP_POWERRES,    "NBW",   "p",      OL|LN|CC,
    "Processor",        NO, 0, OP_PROCESSOR,   "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",      NO, 0, OP_THERMALZONE, "N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",            C1, 0, OP_BREAK,      NULL,  NULL,  0,
    "BreakPoint",       C1, 0, OP_BREAKPOINT, NULL,  NULL,  0,
    "Else",             C1, 0, OP_ELSE,       NULL,  NULL,  AF|CL|OL|LN,
    "Fatal",            C1, 0, OP_FATAL,      "BDC", "  U", 0,
    "If",               C1, 0, OP_IF,         "C",   "U",   CL|OL|LN,
    "Load",             C1, 0, OP_LOAD,       "NS",  "UU",  0,
    "Noop",             C1, 0, OP_NOP,        NULL,  NULL,  0,
    "Notify",           C1, 0, OP_NOTIFY,     "SC",  "UU",  0,
    "Release",          C1, 0, OP_RELEASE,    "S",   "X",   0,
    "Reset",            C1, 0, OP_RESET,      "S",   "E",   0,
    "Return",           C1, 0, OP_RETURN,     "C",   "U",   0,
    "Signal",           C1, 0, OP_SIGNAL,     "S",   "E",   0,
    "Sleep",            C1, 0, OP_SLEEP,      "C",   "U",   0,
    "Stall",            C1, 0, OP_STALL,      "C",   "U",   0,
    "Unload",           C1, 0, OP_UNLOAD,     "S",   "U",   0,
    "While",            C1, 0, OP_WHILE,      "C",   "U",   CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",          C2, 0, OP_ACQUIRE,     "SW",     "X",      0,
    "Add",              C2, 0, OP_ADD,         "CCS",    "UUU",    0,
    "And",              C2, 0, OP_AND,         "CCS",    "UUU",    0,
    "Concatenate",      C2, 0, OP_CONCAT,      "CCS",    "UUU",    0,
    "CondRefOf",        C2, 0, OP_CONDREFOF,   "SS",     "UU",     0,
    "Decrement",        C2, 0, OP_DECREMENT,   "S",      "U",      0,
    "DerefOf",          C2, 0, OP_DEREFOF,     "C",      "U",      0,
    "Divide",           C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",   0,
    "FindSetLeftBit",   C2, 0, OP_FINDSETLBIT, "CS",     "UU",     0,
    "FindSetRightBit",  C2, 0, OP_FINDSETRBIT, "CS",     "UU",     0,
    "FromBCD",          C2, 0, OP_FROMBCD,     "CS",     "UU",     0,
    "Increment",        C2, 0, OP_INCREMENT,   "S",      "U",      0,
    "Index",            RO|C2, 0, OP_INDEX,    "CCS",    "UUU",    0,
    "LAnd",             C2, 0, OP_LAND,        "CC",     "UU",     0,
    "LEqual",           C2, 0, OP_LEQ,         "CC",     "UU",     0,
    "LGreater",         C2, 0, OP_LG,          "CC",     "UU",     0,
    "LGreaterEqual",    C2, 0, OP_LGEQ,        "CC",     "UU",     0,
    "LLess",            C2, 0, OP_LL,          "CC",     "UU",     0,
    "LLessEqual",       C2, 0, OP_LLEQ,        "CC",     "UU",     0,
    "LNot",             C2, 0, OP_LNOT,        "C",      "U",      0,
    "LNotEqual",        C2, 0, OP_LNOTEQ,      "CC",     "UU",     0,
    "LOr",              C2, 0, OP_LOR,         "CC",     "UU",     0,
    "Match",            C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU", AF,
    "Multiply",         C2, 0, OP_MULTIPLY,    "CCS",    "UUU",    0,
    "NAnd",             C2, 0, OP_NAND,        "CCS",    "UUU",    0,
    "NOr",              C2, 0, OP_NOR,         "CCS",    "UUU",    0,
    "Not",              C2, 0, OP_NOT,         "CS",     "UU",     0,
    "ObjectType",       C2, 0, OP_OBJTYPE,     "S",      "U",      0,
    "Or",               C2, 0, OP_OR,          "CCS",    "UUU",    0,
    "RefOf",            C2, 0, OP_REFOF,       "S",      "U",      0,
    "ShiftLeft",        C2, 0, OP_SHIFTL,      "CCS",    "UUU",    0,
    "ShiftRight",       C2, 0, OP_SHIFTR,      "CCS",    "UUU",    0,
    "SizeOf",           C2, 0, OP_SIZEOF,      "S",      "U",      0,
    "Store",            C2, 0, OP_STORE,       "CS",     "UU",     0,
    "Subtract",         C2, 0, OP_SUBTRACT,    "CCS",    "UUU",    0,
    "ToBCD",            C2, 0, OP_TOBCD,       "CS",     "UU",     0,
    "Wait",             C2, 0, OP_WAIT,        "SC",     "E",      0,
    "XOr",              C2, 0, OP_XOR,         "CCS",    "UUU",    0,
    "OSI",              C2, 0, OP_OSI,          "S",     "U",      0,    
    NULL,               0,  0, OP_NONE, NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\unasm.c ===
/*** unasm.c - Unassemble AML back to ASL
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"

#ifdef DEBUGGER

//Local function prototype
VOID LOCAL Indent(PUCHAR pbOp, int iLevel);
UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(ULONG dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData);
LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp);
LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ *ppns, char c);
LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen);
LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp);
LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ *ppns);
LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos);

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Current Opcode pointer
 *      pbEnd -> end of scope
 *      iLevel - level of indentation
 *      icLines - 1: unasm one line; 0: unasm default # lines; -1: internal
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, int iLevel, int icLines)
{
    LONG rc = UNASMERR_NONE;

    if (iLevel != -1)
    {
        giLevel = iLevel;
    }

    if (icLines == 1)
    {
        gicCode = 1;
    }
    else if (icLines == 0)
    {
        gicCode = MAX_UNASM_CODES;
    }
    else if (icLines == -1)
    {
        Indent(*ppbOp, giLevel);
        PRINTF("{");
        giLevel++;
    }

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((rc = UnAsmOpcode(ppbOp)) == UNASMERR_NONE)
        {
            if ((icLines == 0) || (iLevel == -1))
            {
                continue;
            }

            if (gicCode == 0)
            {
                char szReply[2];

                ConPrompt("\nPress <space> to continue and 'q' to quit? ",
                          szReply, sizeof(szReply));
                PRINTF("\n");
                if (szReply[0] == 'q')
                {
                    rc = UNASMERR_ABORT;
                    break;
                }
                else
                {
                    gicCode = MAX_UNASM_CODES;
                }
            }
            else
            {
                gicCode--;
            }
        }
        else
        {
            break;
        }
    }

    if ((rc == UNASMERR_NONE) && (icLines < 0))
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmScope

/***LP  Indent - Print indent level
 *
 *  ENTRY
 *      pbOp -> opcode
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL Indent(PUCHAR pbOp, int iLevel)
{
    int i;

    PRINTF("\n%08x: ", pbOp);
    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }
}       //Indent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable)
{
    UCHAR bOpClass = OPCLASS_INVALID;

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
        {
            pOpTable++;
        }
    }

    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(ULONG dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (UTC_CONST_NAME | UTC_SHORT_NAME | UTC_NAMESPACE_MODIFIER |
              UTC_DATA_OBJECT | UTC_NAMED_OBJECT | UTC_OPCODE_TYPE1 |
              UTC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == UTC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (UCHAR)(TermTable[i].dwTermData >> 8)) ==
             (UCHAR)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwOpcode;
    UCHAR bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    PNSOBJ pns;
    int i;

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((ULONG)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (ULONG)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp);
            break;

        case OPCLASS_NAME_OBJ:
            if (((rc = UnAsmNameObj(ppbOp, &pns, NSTYPE_UNKNOWN)) ==
                 UNASMERR_NONE) &&
                (pns != NULL) &&
                (pns->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                int iNumArgs;

                iNumArgs = ((PMETHODOBJ)pns->ObjData.pbDataBuff)->bMethodFlags &
                           METHOD_NUMARG_MASK;

                for (i = 0; i < iNumArgs; ++i)
                {
                    szUnAsmArgTypes[i] = 'C';
                }
                szUnAsmArgTypes[i] = '\0';
                rc = UnAsmArgs(szUnAsmArgTypes, NULL, ppbOp, NULL);
            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                DBG_ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = UNASMERR_FATAL;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp);
            }
            break;

        default:
            DBG_ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    UCHAR bOp = **ppbOp;
    PSZ psz;

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            PRINTF("0x%x", **ppbOp);
            *ppbOp += sizeof(UCHAR);
            break;

        case OP_WORD:
            PRINTF("0x%x", *((UNALIGNED USHORT *)*ppbOp));
            *ppbOp += sizeof(USHORT);
            break;

        case OP_DWORD:
            PRINTF("0x%x", *((UNALIGNED ULONG *)*ppbOp));
            *ppbOp += sizeof(ULONG);
            break;

        case OP_STRING:
            PRINTF("\"");
            for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
            {
                if (*psz == '\\')
                {
                    PRINTF("\\");
                }
                PRINTF("%c", *psz);
            }
            PRINTF("\"");
            *ppbOp += STRLEN((PSZ)*ppbOp) + 1;
            break;

        default:
            DBG_ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = UNASMERR_INVALID_OPCODE;
    }

    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      ppns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ *ppns, char c)
{
    LONG rc = UNASMERR_NONE;
    char szName[MAX_NAME_LEN + 1];
    int iLen = 0;

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NAME_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            DBG_ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = UNASMERR_FATAL;
        }
        else
        {
            rc = UnAsmNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }

    if (rc == UNASMERR_NONE)
    {
        PNSOBJ pns = NULL;

        PRINTF("%s", szName);

        if ((rc = GetNameSpaceObject(szName, gpnsCurUnAsmScope, &pns, 0)) !=
            UNASMERR_NONE)
        {
            rc = UNASMERR_NONE;
        }

        if (rc == UNASMERR_NONE)
        {
            if ((c == NSTYPE_SCOPE) && (pns != NULL))
            {
                gpnsCurUnAsmScope = pns;
            }

            if (ppns != NULL)
            {
                *ppns = pns;
            }
        }
    }

    return rc;
}       //UnAsmNameObj

/***LP  UnAsmNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen)
{
    LONG rc = UNASMERR_NONE;
    int icNameSegs = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NAME_LEN))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NAME_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        DBG_ERROR(("UnAsmNameTail: name too long - %s", pszBuff));
        rc = UNASMERR_FATAL;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    return rc;
}       //UnAsmNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    PUCHAR pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurUnAsmScope;
    PNSOBJ pns = NULL;

    PRINTF("%s", pterm->pszID);

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions, ppbOp,
                       &pns);
    }

    if (rc == UNASMERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
            if ((pterm->dwfTerm & TF_CHANGE_CHILDSCOPE) &&
                (pns != NULL))
            {
                gpnsCurUnAsmScope = pns;
            }

            rc = UnAsmScope(ppbOp, pbEnd, -1, -1);
        }
    }
    gpnsCurUnAsmScope = pnsScopeSave;

    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      ppbOp -> opcode pointer
 *      ppns -> to hold created object
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ *ppns)
{
    LONG rc = UNASMERR_NONE;
    static UCHAR bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm = {0};

    iNumArgs = STRLEN(pszUnAsmArgTypes);
    PRINTF("(");

    for (i = 0; i < iNumArgs; ++i)
    {
        if (i != 0)
        {
            PRINTF(", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, ppns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((ULONG)(**ppbOp));
                    ASSERT(pterm != NULL);
                    (*ppbOp)++;
                    if(pterm)
                    {
                        rc = UnAsmTermObj(pterm, ppbOp);
                    }
                    else
                    {
                        rc = UNASMERR_INVALID_OPCODE;
                    }
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp);
                break;

            case 'B':
                PRINTF("0x%x", **ppbOp);
                *ppbOp += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':
                if (pszUnAsmArgTypes[i] == 'K')
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    PRINTF("0x%x", **ppbOp & 0x07);
                }
                else
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    ASSERT(pterm != NULL);
                    PRINTF("%s", pterm->pszID);
                }

                if (pszUnAsmArgTypes[i] == 'K')
                {
                    *ppbOp += sizeof(UCHAR);
                }
                break;

            case 'W':
                PRINTF("0x%x", *((PUSHORT)*ppbOp));
                *ppbOp += sizeof(USHORT);
                break;

            case 'D':
                PRINTF("0x%x", *((PULONG)*ppbOp));
                *ppbOp += sizeof(ULONG);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp);
                break;

            default:
                DBG_ERROR(("UnAsmOpcode: invalid ArgType '%c'",
                           pszUnAsmArgTypes[i]));
                rc = UNASMERR_FATAL;
        }
    }

    PRINTF(")");

    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        PRINTF("Debug");
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp);
    }
    else
    {
        DBG_ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmSuperName

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    int i;

    Indent(*ppbOp, giLevel);
    PRINTF("{");

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, 0);
        PRINTF("0x%02x", **ppbOp);

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 8); ++i)
        {
            PRINTF(", 0x%02x", **ppbOp);
            (*ppbOp)++;
        }

        if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    Indent(*ppbOp, giLevel);
    PRINTF("}");

    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    PASLTERM pterm;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((ULONG)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp);
        }

        if (rc != UNASMERR_NONE)
        {
            break;
        }
        else if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwBitPos = 0;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);
        if ((rc = UnAsmField(ppbOp, &dwBitPos)) == UNASMERR_NONE)
        {
            if (*ppbOp < pbEnd)
            {
                PRINTF(",");
            }
        }
        else
        {
            break;
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0x01)
    {
        PASLTERM pterm = {0};

        (*ppbOp)++;
        pterm = FindKeywordTerm('A', **ppbOp);
        if(pterm)
        {
            PRINTF("AccessAs(%s, 0x%x)", pterm->pszID, *(*ppbOp + 1));
        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        ULONG dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            STRCPYN(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
            {
                PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
            }
            else
            {
                PRINTF(", %d", dwcbBits);
            }
        }
        else
        {
            PRINTF("%s, %d", szNameSeg, dwcbBits);
        }

        *pdwBitPos += dwcbBits;
    }

    return rc;
}       //UnAsmField

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpibs.h ===
BOOLEAN NotifyUserInAVeryNonSubtleWay (ULONG ErrorCode, PCHAR ReplacementText, PCHAR SupplementalText, ULONG Flags); 

extern ULONG IgnoreHook;


// Flags for NotifyUserInAVeryNonSubtleWay

#define BS_HARDWAREBIOS_BIT 0
#define BS_HARDWAREBIOS     (1 << BS_HARDWAREBIOS_BIT)

#define BS_SOFTWARE_BIT 1
#define BS_SOFTWARE         (1 << BS_SOFTWARE_BIT)

// Joe User meet Mr. Reaper....

#define BS_REAPER_BIT 2
#define BS_REAPER           (1 << BS_REAPER_BIT)

#define BS_REPLACE_TEXT_BIT 3
#define BS_REPLACE_TEXT (1 << BS_REPLACE_TEXT_BIT)

#define BS_SUPPLEMENT_TEXT_BIT 4
#define BS_SUPPLEMENT_TEXT  (1 << BS_SUPPLEMENT_TEXT_BIT)

#define BS_SUPPRESS_AUTOMATIC_SUPPLEMENT_BIT 5
#define BS_SUPPRESS_AUTOMATIC_SUPPLEMENT    (1 << BS_SUPPRESS_AUTOMATIC_SUPPLEMENT_BIT)

#define BS_KNOWN_CAUSE_MASK (BS_HARDWAREBIOS | BS_SOFTWARE)

#define BS_VALID_FLAGS_MASK  (BS_HARDWAREBIOS | BS_SOFTWARE | BS_REAPER | BS_REPLACE_TEXT | BS_SUPPLEMENT_TEXT | \
                            BS_SUPPRESS_AUTOMATIC_SUPPLEMENT)
                            
                            
                            
 
#define BS_STANDARD_CAPTION "ACPI Critical Error #%x"
#define BS_UNKNOWN_CAUSE_MESSAGE "The ACPI device driver has encountered an unusual error. "BS_SUPPORT_MESSAGE_TRAILER                                    
#define BS_UNKNOWN_CAUSE_MESSAGE_SIZE (sizeof (BS_UNKNOWN_CAUSE_MESSAGE))

#define BS_HARDWARE_CAUSE_MESSAGE "The ACPI driver has encountered a hardware or bios problem. "
#define BS_HARDWARE_CAUSE_MESSAGE_SIZE (sizeof (BS_HARDWARE_CAUSE_MESSAGE))

#define BS_SOFTWARE_CAUSE_MESSAGE "The ACPI device driver has encountered a critical error. "BS_SUPPORT_MESSAGE_TRAILER
#define BS_SOFTWARE_CAUSE_MESSAGE_SIZE (sizeof (BS_SOFTWARE_CAUSE_MESSAGE))

#define BS_REAPER_MESSAGE "This problem will usually result in a system CRASH or HANG !"
#define BS_REAPER_MESSAGE_SIZE (sizeof (BS_REAPER_MESSAGE))

#define BS_SUPPORT_MESSAGE_TRAILER "Please contact Microsoft Beta Support and give them the above error number."

#define BS_BS_FLAGS (MB_SYSTEMMODAL | MB_OK | MB_ASAP | MB_NOWINDOW)


#define BS_SUPP_MESSAGE "The SCI_EN bit was not set after enabling ACPI"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\amlinew\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef DEBUGGER

/*** Constants
 */

// Implementation constants
#define MAX_ARGS                7

// Error codes
#define UNASMERR_NONE           0
#define UNASMERR_FATAL          -1
#define UNASMERR_INVALID_OPCODE -2
#define UNASMERR_ABORT          -3

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Term classes
#define UTC_PNP_MACRO           0x00100000
#define UTC_REF_OBJECT          0x00200000
#define UTC_FIELD_MACRO         0x00400000
#define UTC_DATA_OBJECT         0x00800000
#define UTC_NAMED_OBJECT        0x01000000
#define UTC_NAMESPACE_MODIFIER  0x02000000
#define UTC_OPCODE_TYPE1        0x04000000
#define UTC_OPCODE_TYPE2        0x08000000
#define UTC_CONST_NAME          0x10000000
#define UTC_SHORT_NAME          0x20000000
#define UTC_COMPILER_DIRECTIVE  0x40000000
#define UTC_KEYWORD             0x80000000
#define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 |  \
                                 UTC_SHORT_NAME | UTC_CONST_NAME |      \
                                 UTC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          UTC_FIELD_MACRO
#define TF_DATA_OBJECT          UTC_DATA_OBJECT
#define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
#define TF_CONST_NAME           UTC_CONST_NAME
#define TF_SHORT_NAME           UTC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
#define TF_KEYWORD              UTC_KEYWORD
#define TF_PNP_MACRO            UTC_PNP_MACRO
#define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                 UTC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

/*** Type definitions
 */

typedef ULONG NAMESEG;
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    ULONG   dwfTermClass;
    ULONG   dwTermData;
    ULONG   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgActions;
    ULONG   dwfTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   bExOp;
    UCHAR   bOpClass;
} OPMAP, *POPMAP;

// Data prototype
extern int gicCode;
extern int giLevel;
extern PNSOBJ gpnsCurUnAsmScope;
extern ASLTERM TermTable[];
extern UCHAR OpClassTable[256];
extern OPMAP ExOpClassTable[];

// Exported functions
LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, int iLevel, int icCode);

#endif  //ifdef DEBUGGER

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpidbg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpidbg.h

Abstract:

    This module contains the debug stubs

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only, Win9x driver mode

--*/

#ifndef _ACPIDBG_H_
#define _ACPIDBG_H_

    //
    // ACPI BugCheck Definitions
    //

    //
    // ACPI cannot find the SCI Interrupt vector in the resources handed
    // to it when ACPI is started.
    //      Argument 0  - ACPI's deviceExtension
    //      Argument 1  - ACPI's ResourceList
    //      Argument 2  - 0 <- Means no resource list found
    //      Argument 2  - 1 <- Means no IRQ resource found in list
    //
    #define ACPI_ROOT_RESOURCES_FAILURE                 0x0001

    //
    // ACPI could not process the resource list for the PCI root buses
    // There is an White Paper on the Web Site about this problem
    //      Argument 0  - The ACPI Extension for the PCI bus
    //      Argument 1  - 0
    //          Argument 2  - Pointer to the QUERY_RESOURCES irp
    //      Argument 1  - 1
    //          Argument 2  - Pointer to the QUERY_RESOURCE_REQUIREMENTS irp
    //      Argument 1  - 2
    //          Argument 2  - 0 <- Indicates that we found an empty resource list
    //      Argument 1  - 3 <- Could not find the current bus number in the CRS
    //          Argument 2  - Pointer to the PNP CRS descriptor
    //      Argument 1  - Pointer to the Resource List for PCI
    //          Argument 2  - Number of errors/conflicts found in the resource list
    //
    #define ACPI_ROOT_PCI_RESOURCE_FAILURE              0x0002

    //
    // ACPI tried to run a control method while creating device extensions
    // to represent the ACPI namespace, but this control method failed
    //      Argument 0  - The ACPI Object that was being run
    //      Argument 1  - return value from the interpreter
    //      Argument 2  - Name of the control method (in ULONG format)
    //
    #define ACPI_FAILED_MUST_SUCCEED_METHOD             0x0003

    //
    // ACPI evaluated a _PRW and expected to find an integer as a
    // package element
    //      Argument 0  - The ACPI Extension for which the _PRW belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_PRW_PACKAGE_EXPECTED_INTEGER           0x0004

    //
    // ACPI evaluated a _PRW and the package that came back failed to
    // contain at least 2 elements. The ACPI specification requires that
    // two elements to always be present in a _PRW.
    //      Argument 0  - The ACPI Extension for which the _PRW belongs to
    //      Argument 1  - Pointer to the _PRW
    //      Argument 2  - Number of elements in the _PRW
    //
    #define ACPI_PRW_PACKAGE_TOO_SMALL                  0x0005

    //
    // ACPI tried to find a named object named, but could not find it.
    //      Argument 0  - The ACPI Extension for which the _PRx belongs to
    //      Argument 1  - Pointer to the _PRx
    //      Argument 2  - Pointer to the name of the object to look for
    //
    #define ACPI_PRX_CANNOT_FIND_OBJECT                 0x0006

    //
    // ACPI evaluated a method and expected to receive a Buffer in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_BUFFER                        0x0007

    //
    // ACPI evaluated a method and expected to receive an Integer in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_INTEGER                       0x0008

    //
    // ACPI evaluated a method and expected to receive a Package in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_PACKAGE                       0x0009

    //
    // ACPI evaluated a method and expected to receive a String in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_STRING                        0x000A

    //
    // ACPI cannot find the object referenced to by an _EJD string
    //      Argument 0  - The ACPI Extension for which which the _EJD belongs to
    //      Argument 1  - The status returned by the interpreter
    //      Argument 2  - Name of the object we are trying to find
    //
    #define ACPI_EJD_CANNOT_FIND_OBJECT                 0x000B

    //
    // ACPI provides faulty/insufficient information for dock support
    //      Argument 0  - The ACPI Extension for which ACPI found a dock device
    //      Argument 1  - Pointer to the _EJD method
    //      Argument 2  - 0 <- Bios does not claim system is dockage
    //                    1 <- Duplicate device extensions for dock device
    //
    #define ACPI_CLAIMS_BOGUS_DOCK_SUPPORT              0x000C

    //
    // ACPI could not find a required method/object in the namespace
    // This is the bugcheck that is used if a vendor does not have an
    // _HID or _ADR present
    //      Argument 0  - The ACPI Extension that we need the object for
    //      Argument 1  - The (ULONG) name of the method we looked for
    //      Argument 2  - 0 <- Base Case
    //      Argument 2  - 1 <- Conflict
    //
    #define ACPI_REQUIRED_METHOD_NOT_PRESENT            0x000D

    //
    // ACPI could not find a requird method/object in the namespace for
    // a power resource (or entity other than a "device"). This is the
    // bugcheck used if a vendor does not have an _ON, _OFF, or _STA present
    // for a power resource
    //      Argument 0  - The NS PowerResource that we need the object for
    //      Argument 1  - The (ULONG) name of the method we looked for
    //      Argument 2  - 0 <- Base Case
    //
    #define ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT 0x000E

    //
    // ACPI could not parse the resource descriptor
    //      Argument 0  - The current buffer that ACPI was parsing
    //      Argument 1  - The buffer's tag
    //      Argument 2  - The specified length of the buffer
    //
    #define ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL     0x000F

    //
    // ACPI could not map determine the system to device state mapping
    // correctly
    //
    // There is a very long white paper about this topic
    //
    //      Argument 0  - The ACPI Extension for which are trying to do the mapping
    //      Argument 1  - 0 The _PRx mapped back to a non-supported S-state
    //          Argument 2  - The DEVICE_POWER_STATE (ie: x+1)
    //      Argument 1  - 1 We cannot find a D-state to associate with the S-state
    //          Argument 2  - The SYSTEM_POWER_STATE that is causing us grief
    //      Argument 1  - 2 The device claims to support wake from this s-state but
    //                      the s-state is not supported by the system
    //          Argument 2  - The SYSTEM_POWER_STATE that is causing us grief
    //
    #define ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES     0x0010

    //
    // The system could not enter ACPI mode
    //
    //      Argument 0  - 0 <- System could not initialize AML interpreter
    //      Argument 0  - 1 <- System could not find RSDT
    //      Argument 0  - 2 <- System could not allocate critical driver structures
    //      Argument 0  - 3 <- System could not load RSDT
    //      Argument 0  - 4 <- System could not load DDBs
    //      Argument 0  - 5 <- System cannot connect Interrupt vector
    //      Argument 0  - 6 <- SCI_EN never becomes set in PM1 Control Register
    //      Argument 0  - 7 <- Table checksum is incorrect
    //          Argument 1  - Pointer to the table that had a bad checksum
    //          Argument 2  - Creator Revision
    //      Argument 0  - 8 <- Failed to load DDB
    //          Argument 1  - Pointer to the table that we failed to load
    //          Argument 2  - Creator Revision
    //
    #define ACPI_SYSTEM_CANNOT_START_ACPI               0x0011

    //
    // The ACPI driver was expecting a power resource object.
    //      Argument 0  - The ACPI Extension for which is looking for powerres
    //      Argument 1  - Pointer to the object that returned the bogus powerres
    //      Argument 2  - Pointer to the name of the object to look for
    //
    #define ACPI_EXPECTED_POWERRES                      0x0012

    //
    // The ACPI driver attempted to unload a table and an error occured
    //      Argument 0  - The NSOBj that we were trying to unload
    //      Argument 1  - 0 - The NSOBj has not been unloaded by the current
    //                        operation, but its parent object is marked as
    //                        requiring an unload
    //      Argument 1  - 1 - The NSOBJ has been marked as requiring an unload
    //                        buts it device parent has not.
    //
    #define ACPI_TABLE_UNLOAD                           0x0013

    //
    // ACPI tried to evaluate the PIC control method and but failed
    //      Argument 0  - InterruptModel (Integer)
    //      Argument 1  - return value from interpreter
    //      Argument 2  - Pointer to the PIC control method
    //
    #define ACPI_FAILED_PIC_METHOD                      0x2001

    //
    // ACPI tried to do interrupt routing, but failed
    //
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - Pointer to the parent of the device object
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_CANNOT_ROUTE_INTERRUPTS                0x10001

    //
    // ACPI could not find the link node referenced in a _PRT
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - Pointer to the name we are looking for
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_PRT_CANNOT_FIND_LINK_NODE              0x10002

    //
    // ACPI could not find a mapping in the _PRT package for a device
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - The Device ID / Function Number
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_PRT_CANNOT_FIND_DEVICE_ENTRY           0x10003

    //
    // ACPI found an entry in the _PRT for which the function ID isn't
    // all F's. The Win98 behaviour is to bugcheck if it see this condition,
    // so we do so all well. The generic format for a _PRT entry is such
    // that the device number is specified, but the function number isn't.
    // If it isn't done this way, then the machine vendor can introduce
    // dangerous ambiguities
    //
    //      Argument 0  - Pointer to the PRT object
    //      Argument 1  - Pointer to the current PRT Element
    //      Argument 2  - The DeviceID/FunctionID of the element
    //
    #define ACPI_PRT_HAS_INVALID_FUNCTION_NUMBERS       0x10005

    //
    // ACPI found a link node, but cannot disable it. Link nodes must
    // be disable to allow for reprogramming
    //      Argument 0  - Pointer to the link node
    //
    #define ACPI_LINK_NODE_CANNOT_BE_DISABLED           0x10006



    #ifdef ACPIPrint
        #undef ACPIPrint
    #endif

    //
    // Define the various debug masks and levels
    //
    #define ACPI_PRINT_CRITICAL     DPFLTR_ERROR_LEVEL
    #define ACPI_PRINT_FAILURE      DPFLTR_ERROR_LEVEL
    #define ACPI_PRINT_WARNING      DPFLTR_WARNING_LEVEL
    #define ACPI_PRINT_INFO         DPFLTR_INFO_LEVEL
    #define ACPI_PRINT_DPC          DPFLTR_INFO_LEVEL + 1
    #define ACPI_PRINT_IO           DPFLTR_INFO_LEVEL + 2
    #define ACPI_PRINT_ISR          DPFLTR_INFO_LEVEL + 3
    #define ACPI_PRINT_IRP          DPFLTR_INFO_LEVEL + 4
    #define ACPI_PRINT_LOADING      DPFLTR_INFO_LEVEL + 5
    #define ACPI_PRINT_MSI          DPFLTR_INFO_LEVEL + 6
    #define ACPI_PRINT_PNP          DPFLTR_INFO_LEVEL + 7
    #define ACPI_PRINT_PNP_STATE    DPFLTR_INFO_LEVEL + 8
    #define ACPI_PRINT_POWER        DPFLTR_INFO_LEVEL + 9
    #define ACPI_PRINT_REGISTRY     DPFLTR_INFO_LEVEL + 10
    #define ACPI_PRINT_REMOVE       DPFLTR_INFO_LEVEL + 11
    #define ACPI_PRINT_RESOURCES_1  DPFLTR_INFO_LEVEL + 12
    #define ACPI_PRINT_RESOURCES_2  DPFLTR_INFO_LEVEL + 13
    #define ACPI_PRINT_SXD          DPFLTR_INFO_LEVEL + 14
    #define ACPI_PRINT_THERMAL      DPFLTR_INFO_LEVEL + 15
    #define ACPI_PRINT_WAKE         DPFLTR_INFO_LEVEL + 16


    #define ACPIDebugEnter(name)
    #define ACPIDebugExit(name)

    #if DBG

        VOID
        ACPIDebugPrint(
            ULONG   DebugPrintLevel,
            PCCHAR  DebugMessage,
            ...
            );
        VOID
        ACPIDebugDevicePrint(
            ULONG   DebugPrintLevel,
            PVOID   DebugExtension,
            PCCHAR  DebugMessage,
            ...
            );

        VOID
        ACPIDebugThermalPrint(
            ULONG       DebugPrintLevel,
            PVOID       DebugExtension,
            ULONGLONG   DebugTime,
            PCCHAR      DebugMessage,
            ...
            );

        #define ACPIPrint(x)         ACPIDebugPrint x
        #define ACPIDevPrint(x)      ACPIDebugDevicePrint x
        #define ACPIThermalPrint(x)  ACPIDebugThermalPrint x
        #define ACPIBreakPoint()     KdBreakPoint()

    #else

        #define ACPIPrint(x)
        #define ACPIDevPrint(x)
        #define ACPIThermalPrint(x)
        #define ACPIBreakPoint()

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpi.h ===
/*++

File:

    acpi\driver\inc\acpi.h

Author:

    Jason Clark

Description:

    Contains all the definitions for modules that are exported from the
    shared acpi code base

Revision History:

    12/03/96    - Initial Revision

--*/

#ifndef _INC_ACPI_H_
#define _INC_ACPI_H_

    //
    // Make sure that pool tagging is defined
    //
    #ifdef ExAllocatePool
        #undef ExAllocatePool
    #endif
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ipcA')

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpierr.h ===
#define ACPI_ERROR_FORCED_SUPPLEMENT                0x0100
#define ACPI_ERROR_FORCED_REPLACEMENT               0x0200



/* Category */                                                    
#define ACPI_ERROR_INITIALIZATION_CATEGORY          0x1000

/* Errors within ACPI_ERROR_INITIALIZATION_CATEGORY */
#define ACPI_ERROR_I_SCI_ENABLE_INDEX               0x01
#define ACPI_ERROR_I_SCI_ENABLE                     (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_SCI_ENABLE_INDEX)   
                                                     
#define ACPI_ERROR_I_RSDT_CHECKSUM_INDEX            0x02
#define ACPI_ERROR_I_RSDT_CHECKSUM                  (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_RSDT_CHECKSUM_INDEX)
                                                     
#define ACPI_ERROR_I_NO_RSDT_INDEX                  0x03
#define ACPI_ERROR_I_NO_RSDT                        (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_NO_RSDT_INDEX)
                                                     
#define ACPI_ERROR_I_DSDT_SIGNATURE_INDEX           0x04
#define ACPI_ERROR_I_DSDT_SIGNATURE                 (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_DSDT_SIGNATURE_INDEX)
                        
#define ACPI_ERROR_I_FACS_LENGTH_INDEX              0x05
#define ACPI_ERROR_I_FACS_LENGTH                    (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FACS_LENGTH_INDEX)
                                                    
#define ACPI_ERROR_I_FACS_SIGNATURE_INDEX           0x06
#define ACPI_ERROR_I_FACS_SIGNATURE                 (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FACS_SIGNATURE_INDEX)
                                                                                                          
#define ACPI_ERROR_I_FOUND_FADT_LATE_INDEX          0x07
#define ACPI_ERROR_I_FOUND_FADT_LATE                (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FOUND_FADT_LATE_INDEX)
                                                                                                          
#define ACPI_ERROR_I_MISSING_FADT_FACS_DSDT_INDEX        0x08
#define ACPI_ERROR_I_MISSING_FADT_FACS_DSDT         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_MISSING_FADT_FACS_DSDT_INDEX)                                          
                                                    
#define ACPI_ERROR_I_CANT_CLEAR_PM_STATUS_INDEX     0x09
#define ACPI_ERROR_I_CANT_CLEAR_PM_STATUS           (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_CANT_CLEAR_PM_STATUS_INDEX)

#define ACPI_ERROR_I_BROKEN_ENABLE_INDEX            0x0A
#define ACPI_ERROR_I_BROKEN_ENABLE                  (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_BROKEN_ENABLE_INDEX)

#define ACPI_I_GP_BLK_LEN_0_INDEX                   0x0B
#define ACPI_I_GP_BLK_LEN_0                         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_I_GP_BLK_LEN_0_INDEX)                                                     
                                                     
#define ACPI_I_GP_BLK_LEN_1_INDEX                   0x0C
#define ACPI_I_GP_BLK_LEN_1                         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_I_GP_BLK_LEN_1_INDEX)
                                                     
#define ACPI_I_GP0CM_WITH_NO_GP0_INDEX				0x0D
#define ACPI_I_GP0CM_WITH_NO_GP0					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GP0CM_WITH_NO_GP0_INDEX)
                                                     
#define ACPI_I_GP1CM_WITH_NO_GP1_INDEX				0x0E
#define ACPI_I_GP1CM_WITH_NO_GP1					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GP1CM_WITH_NO_GP1_INDEX)                                              
                                                     
#define ACPI_I_GPCM_INDEX_TOO_HIGH_INDEX			0x0F
#define ACPI_I_GPCM_INDEX_TOO_HIGH					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GPCM_INDEX_TOO_HIGH_INDEX)                                                     
                                                     
#define ACPI_ERROR_I_NO_PBLK_INDEX					0x10
#define ACPI_ERROR_I_NO_PBLK						(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_NO_PBLK_INDEX)                                                    
                                                    
#define ACPI_ERROR_I_BAD_S1_INDEX					0x11
#define ACPI_ERROR_I_BAD_S1							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S1_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S2_INDEX					0x12
#define ACPI_ERROR_I_BAD_S2							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S2_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S3_INDEX					0x13
#define ACPI_ERROR_I_BAD_S3							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S3_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S4_INDEX					0x14
#define ACPI_ERROR_I_BAD_S4							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S4_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S5_INDEX					0x15
#define ACPI_ERROR_I_BAD_S5							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S5_INDEX)     
                                                                                                     
#define ACPI_ERROR_I_0_CSTATE_LATENCY_INDEX			0x16
#define ACPI_ERROR_I_0_CSTATE_LATENCY				(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_0_CSTATE_LATENCY_INDEX)
                                                                                                         
                                                                                           
#define ACPI_ERROR_INTERPRETER_CATEGORY             0x2000


#define ACPI_ERROR_INT_RETURNED_FAILURE_INDEX       0x01
#define ACPI_ERROR_INT_RETURNED_FAILURE             (ACPI_ERROR_INTERPRETER_CATEGORY + \
                                                     ACPI_ERROR_INT_RETURNED_FAILURE_INDEX)
                                                     
#define ACPI_ERROR_INT_BAD_TABLE_CHECKSUM_INDEX     0x02
#define ACPI_ERROR_INT_BAD_TABLE_CHECKSUM           (ACPI_ERROR_INTERPRETER_CATEGORY + \
                                                     ACPI_ERROR_INT_BAD_TABLE_CHECKSUM_INDEX)
                                                                                                         
#define ACPI_ERROR_EVENTHANDLER_CATEGORY            0x3000


#define ACPI_ERROR_E_STUCK_STATUS_INDEX             0x01
#define ACPI_ERROR_E_STUCK_STATUS                   (ACPI_ERROR_EVENTHANDLER_CATEGORY + \
                                                     ACPI_ERROR_E_STUCK_STATUS_INDEX)                                              
                                                     
#define ACPI_ERROR_THERMAL_CATEGORY					0x4000
                                                     
                                                     
#define ACPI_ERROR_T_ODD_THERMAL_BRANCH_INDEX		0x01
#define ACPI_ERROR_T_ODD_THERMAL_BRANCH				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_ODD_THERMAL_BRANCH_INDEX)
                                                     
#define ACPI_ERROR_T_CRT_OUT_OF_BOUNDS_INDEX		0x02
#define ACPI_ERROR_T_CRT_OUT_OF_BOUNDS				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_CRT_OUT_OF_BOUNDS_INDEX)
                                                                                                         
                                                     
#define ACPI_ERROR_T_INVALID_TSP_INDEX				0x03
#define ACPI_ERROR_T_INVALID_TSP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_TSP_INDEX)
                                                     
#define ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET_INDEX	0x04
#define ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET	(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET_INDEX)
                                                     
#define ACPI_ERROR_T_CANT_EVAL_TMP_INDEX			0x05
#define ACPI_ERROR_T_CANT_EVAL_TMP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_CANT_EVAL_TMP_INDEX)
                                                     
#define ACPI_ERROR_T_INVALID_TMP_INDEX				0x06
#define ACPI_ERROR_T_INVALID_TMP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_TMP_INDEX)
                                                      
#define ACPI_ERROR_T_NO_PSV_INDEX					0x07
#define ACPI_ERROR_T_NO_PSV							(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_NO_PSV_INDEX)

#define ACPI_ERROR_T_0_DUTY_WIDTH_INDEX				0x08
#define ACPI_ERROR_T_0_DUTY_WIDTH					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_0_DUTY_WIDTH_INDEX)
                                                     
#define ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS_INDEX		0x09
#define ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS_INDEX)                                                     
                                                 
                                                    
#define ACPI_ERROR_DEVICE_PM_CATEGORY               0x5000


#define ACPI_ERROR_D_INVALID_SYSTEM_LEVEL_INDEX     0x01
#define ACPI_ERROR_D_INVALID_SYSTEM_LEVEL           (ACPI_ERROR_DEVICE_PM_CATEGORY + \
                                                    ACPI_ERROR_D_INVALID_SYSTEM_LEVEL_INDEX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpios.h ===
/*++

Copyright (c) 1997, Microsoft Corporation:

Module Name:

    acpios.h

Abstract:

    Functions which reside within the OS specific portion of the ACPI driver

Author:


Environment:

    NT Kernel Mode, Win9x Driver

--*/

#ifdef WIN95_BUILD
    #define LOCKABLE_PRAGMA
    #define ACPI_LOCKABLE_CODE  code_seg("PAGE", "CODE")
    #define ACPI_LOCKABLE_DATA  data_seg(".edata", "DATA")
#else
#endif

//
// Open mode and other flags
//
#define OF_READONLY             0x00000000
#define OF_WRITEONLY            0x00000001
#define OF_READWRITE            0x00000002
#define OF_SHARE_DENYALL        0x00000010
#define OF_SHARE_DENYWRITE      0x00000020
#define OF_SHARE_DENYREAD       0x00000030
#define OF_SHARE_DENYNONE       0x00000040
#define OF_INHERIT_NONE         0x00000080
#define OF_DISABLE_INT24        0x00200000
#define OF_AUTOCOMMITONWRITE    0x00400000

//
// Create attribute flags
//
#define CF_READONLY             0x00000001
#define CF_HIDDEN               0x00000002
#define CF_SYSTEM               0x00000004
#define CF_VOL_LABEL            0x00000008
#define CF_ARCHIVE              0x00000020

//
// Action flags
//
#define AF_EXIST_FAIL           0x00000000
#define AF_EXIST_OPEN           0x00000001
#define AF_EXIST_REPLACE        0x00000002
#define AF_NOTEXIST_FAIL        0x00000000
#define AF_NOTEXIST_CREATE      0x00000010

//
// Registry flags
//
#define REGF_HARDWARE   0x00000000
#define REGF_SOFTWARE   0x00000001

//
// ACPI Registry key.
//
#define ACPI_REGISTRY_KEY  \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI"

//
// Where to find the ACPI Registry information
//
#define ACPI_PARAMETERS_REGISTRY_KEY  \
    "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Parameters"

//
// Where to find the procesor information
//
#define ACPI_PROCESSOR_INFORMATION_KEY \
    "\\Registry\\Machine\\Hardware\\Description\\System\\CentralProcessor\\0"

//
// String that identifies processor stepping information
//
#define ACPI_PROCESSOR_STEPPING_IDENTIFIER   "Stepping"


NTSTATUS
ACPIDispatchForwardIrp(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

//
// These are the functions that the OS-Specific part of the driver *must*
// export
//
VOID
ACPIAssert(
    ULONG Condition,
    ULONG ErrorCode,
    PCHAR ReplacementText,
    PCHAR SupplementalText,
    ULONG Flags
    );
#define ACPISimpleHardwareAssert(x,y)                   \
    ACPIAssert((ULONG)(x),(y),0,0,BS_HARDWAREBIOS)

#define ACPISimpleFatalHardwareAssert(x,y)              \
    ACPIAssert((x),(y),0,0,BS_HARDWAREBIOS|BS_REAPER)

#define ACPISimpleSoftwareAssert(x,y)                   \
    ACPIAssert((x),(y),0,0,BS_SOFTWARE)

#define ACPISimpleFatalSoftwareAssert(x,y)              \
    ACPIAssert((x),(y),0,0,BS_SOFTWARE|BS_REAPER)

#define ACPISimpleUnknownAssert(x,y)                    \
    ACPIAssert((x),(y),0,0,0)

#define ACPISimpleFatalUnknownAssert(x,y)               \
    ACPIAssert((x),(y),0,0,BS_REAPER)

#if 0
ULONG
DbgPrompt(
   PSZ pszPrompt,
   PSZ pszBuff,
   ULONG dwcbLen
   );
#endif

NTSTATUS
NotifyHalWithMachineStates(
    VOID
    );

NTSTATUS
OSCloseHandle(
    HANDLE  Handle
    );

PNSOBJ
OSConvertDeviceHandleToPNSOBJ(
    PVOID DeviceHandle
    );

NTSTATUS
OSCreateHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    );

NTSTATUS
OSGetRegistryValue(
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information
    );

VOID
OSInitialize(
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
OSInterruptVector(
    PVOID Context
    );

VOID
OSInitializeCallbacks(
    VOID
    );

NTSTATUS EXPORT
OSNotifyDeviceEnum(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceCheck(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceWake(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceEject(
    PNSOBJ  AcpiObject
    );

VOID EXPORT
OSNotifyDeviceWakeByGPEEvent(
    IN ULONG                GpeBit,
    IN ULONG                GpeRegister,
    IN ULONG                GpeMask
    );

NTSTATUS
OSOpenHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    );

NTSTATUS
OSOpenLargestSubkey(
    HANDLE  ParentHandle,
    PHANDLE ChildHandle,
    ULONG   RomVersion
    );

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING KeyName,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    );

NTSTATUS
OSReadAcpiConfigurationData(
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *KeyInfo
    );

NTSTATUS
OSReadRegValue(
    PSZ     ValueName,
    HANDLE  ParentHandle,
    PVOID   Buffer,
    PULONG  BufferSize
    );

NTSTATUS
OSWriteRegValue(
    PSZ     ValueName,
    HANDLE  Handle,
    PVOID   Data,
    ULONG   DataSize
    );

VOID
OSQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    );

//
// NT only deals with Device Objects so this can be done directly
// from acpipowr.c
// Memphis may be dealing with a PDO or DevNode so OS Specific
// code needs to determine which and convert.
//

#ifndef _WIN32_WINNT

extern ULONG gPm1Status;

VOID
OSDeviceCheck (
        PVOID DeviceHandle
    );

VOID
OSDeviceCheckOnParent (
        PVOID DeviceHandle
    );

VOID
WakeupFrom (
    PNSOBJ pnsobj
    );

BOOLEAN
OSLockRegion (
        ULONG dwRegionAddr,
        ULONG dwRegionSize
    );

BOOLEAN
OSUnlockRegion (
        ULONG dwRegionAddr,
        ULONG dwRegionSize
    );

BOOLEAN
OSVerifyBuffer (
        PVOID pvBuff,
        ULONG dwLen
    );

VOID
OSSleep (
        ULONG dwUSecs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\acpiregs.h ===
// ACPI register definitions

// PM1_BLK definitions


//      PM1_STS register
#define PM1_STS_OFFSET          0x00    //      16 bits

#define PM1_TMR_STS_BIT         0
#define PM1_TMR_STS                     (1 << PM1_TMR_STS_BIT)

#define PM1_BM_STS_BIT          4
#define PM1_BM_STS                      (1 << PM1_BM_STS_BIT)

#define PM1_GBL_STS_BIT         5
#define PM1_GBL_STS                     (1 << PM1_GBL_STS_BIT)

#define PM1_PWRBTN_STS_BIT      8
#define PM1_PWRBTN_STS          (1 << PM1_PWRBTN_STS_BIT)

#define PM1_SLEEPBTN_STS_BIT    9
#define PM1_SLEEPBTN_STS        (1 << PM1_SLEEPBTN_STS_BIT)

#define PM1_RTC_STS_BIT         10
#define PM1_RTC_STS                     (1 << PM1_RTC_STS_BIT)

#define PM1_WAK_STS_BIT         15
#define PM1_WAK_STS                     (1 << PM1_WAK_STS_BIT)


//      PM1_EN register
#define PM1_EN_OFFSET           0x02    //      16 bits

#define PM1_TMR_EN_BIT          0
#define PM1_TMR_EN                      (1 << PM1_TMR_EN_BIT)

#define PM1_GBL_EN_BIT          5
#define PM1_GBL_EN                      (1 << PM1_GBL_EN_BIT)

#define PM1_PWRBTN_EN_BIT       8
#define PM1_PWRBTN_EN           (1 << PM1_PWRBTN_EN_BIT)

#define PM1_SLEEPBTN_EN_BIT     9
#define PM1_SLEEPBTN_EN         (1 << PM1_SLEEPBTN_EN_BIT)

#define PM1_RTC_EN_BIT          10
#define PM1_RTC_EN                      (1 << PM1_RTC_EN_BIT)


//      PM1_CNTRL register
#if SPEC_VER < 71
#define PM1_CNTRL_OFFSET        0x04    //      16 bits
#endif

#define PM1_SCI_EN_BIT          0
#define PM1_SCI_EN                      (1 << PM1_SCI_EN_BIT)

#define PM1_BM_RLD_BIT          1
#define PM1_BM_RLD                      (1 << PM1_BM_RLD_BIT)

#define PM1_GBL_RLS_BIT         2
#define PM1_GBL_RLS                     (1 << PM1_GBL_RLS_BIT)

#define PM1_SLP_EN_BIT          13
#define PM1_SLP_EN                      (1 << PM1_SLP_EN_BIT)

//      P_CNTRL regsiter
#define P_CNTRL_OFFSET          0x00    //      32 bits

//      P_LVL2 register
#define P_LVL2_OFFSET           0x04    //      8 bits (read only)

//      P_LVL2 register
#define P_LVL3_OFFSET           0x05    //      8 bits (read only)

#define P_THT_EN_BIT            0x04
#define P_THT_EN                (1 << P_THT_EN_BIT)

#define SLP_CMD     (1 << 13)   //  Write this value to pm control to put the machine to sleep
#define SLP_TYP_POS         10          //  Bit position of 3 bit slp typ field in pm control register

//      GP register
#define MAX_GPE                 256
#define MAX_GPE_BUFFER_SIZE     (MAX_GPE/8)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\list.h ===
/*** list.h - List management function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _LIST_H
#define _LIST_H

/*** Macros
 */

#ifndef EXPORT
  #define EXPORT __cdecl
#endif

/*** Type and Structure definitions
 */

typedef struct _List
{
    struct _List *plistPrev;
    struct _List *plistNext;
} LIST, *PLIST, **PPLIST;

/*** Exported function prototypes
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead);
PLIST EXPORT ListRemoveHead(PPLIST pplistHead);
PLIST EXPORT ListRemoveTail(PPLIST pplistHead);
VOID EXPORT ListRemoveAll(PPLIST pplistHead);
VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead);
VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead);

#endif  //ifndef _LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\amlreg.h ===
/*++

Copyright (c) 1997, Microsoft Corporation:

Module Name:

    amlreg.h

Abstract:

    Constants and typedefs for reading AML files and putting them in the registry.

Author:


Environment:

    NT Kernel Mode, Win9x Driver

--*/

#ifndef _AMLREG_H_
#define _AMLREG_H_

//
// Values for "action" registry entry
//
#define ACTION_LOAD_TABLE       0
#define ACTION_LOAD_ROM         1
#define ACTION_LOAD_NOTHING     2
#define ACTION_LOAD_LEGACY      3
#define ACTION_FATAL_ERROR      4

typedef struct {
    ULONG       Offset;
    ULONG       Length;             // 0 = set image size
} REGISTRY_HEADER, *PREGISTRY_HEADER;

typedef struct {
    BOOLEAN     Opened;
    PUCHAR      Desc;
    PUCHAR      FileName;
    HANDLE      FileHandle;
    HANDLE      MapHandle;
    ULONG       FileSize;
    PUCHAR      Image;
    PUCHAR      EndOfImage;

    PUCHAR      OemID;
    PUCHAR      OemTableID;
    ULONG       OemRevision;
} IFILE, *PIFILE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\aml.h ===
/*** aml.h - AML Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AML_H
#define _AML_H

/*** Macros
 */

#define EXOP(op)                (((op) << 8) | OP_EXT_PREFIX)

/*** Opcode values
 */

#define OP_NONE                 0xffffffff      //not a valid opcode

#define OP_ZERO                 0x00
#define OP_ONE                  0x01
#define OP_ALIAS                0x06
#define OP_NAME                 0x08
#define OP_BYTE                 0x0a
#define OP_WORD                 0x0b
#define OP_DWORD                0x0c
#define OP_STRING               0x0d
#define OP_SCOPE                0x10
#define OP_BUFFER               0x11
#define OP_PACKAGE              0x12
#define OP_METHOD               0x14
#define OP_DUAL_NAME_PREFIX     0x2e    // '.'
#define OP_MULTI_NAME_PREFIX    0x2f    // '/'
#define OP_EXT_PREFIX           0x5b    // '['
#define OP_ROOT_PREFIX          0x5c    // '\'
#define OP_PARENT_PREFIX        0x5e    // '^'
#define OP_LOCAL0               0x60    // '`'
#define OP_LOCAL1               0x61    // 'a'
#define OP_LOCAL2               0x62    // 'b'
#define OP_LOCAL3               0x63    // 'c'
#define OP_LOCAL4               0x64    // 'd'
#define OP_LOCAL5               0x65    // 'e'
#define OP_LOCAL6               0x66    // 'f'
#define OP_LOCAL7               0x67    // 'g'
#define OP_ARG0                 0x68    // 'h'
#define OP_ARG1                 0x69    // 'i'
#define OP_ARG2                 0x6a    // 'j'
#define OP_ARG3                 0x6b    // 'k'
#define OP_ARG4                 0x6c    // 'l'
#define OP_ARG5                 0x6d    // 'm'
#define OP_ARG6                 0x6e    // 'n'
#define OP_STORE                0x70    // 'p'
#define OP_REFOF                0x71
#define OP_ADD                  0x72
#define OP_CONCAT               0x73
#define OP_SUBTRACT             0x74
#define OP_INCREMENT            0x75
#define OP_DECREMENT            0x76
#define OP_MULTIPLY             0x77
#define OP_DIVIDE               0x78
#define OP_SHIFTL               0x79
#define OP_SHIFTR               0x7a
#define OP_AND                  0x7b
#define OP_NAND                 0x7c
#define OP_OR                   0x7d
#define OP_NOR                  0x7e
#define OP_XOR                  0x7f
#define OP_NOT                  0x80
#define OP_FINDSETLBIT          0x81
#define OP_FINDSETRBIT          0x82
#define OP_DEREFOF              0x83
#define OP_NOTIFY               0x86
#define OP_SIZEOF               0x87
#define OP_INDEX                0x88
#define OP_MATCH                0x89
#define OP_DWORDFIELD           0x8a
#define OP_WORDFIELD            0x8b
#define OP_BYTEFIELD            0x8c
#define OP_BITFIELD             0x8d
#define OP_OBJTYPE              0x8e
#define OP_LAND                 0x90
#define OP_LOR                  0x91
#define OP_LNOT                 0x92
#define OP_LNOTEQ               0x9392
#define OP_LLEQ                 0x9492
#define OP_LGEQ                 0x9592
#define OP_LEQ                  0x93
#define OP_LG                   0x94
#define OP_LL                   0x95
#define OP_IF                   0xa0
#define OP_ELSE                 0xa1
#define OP_WHILE                0xa2
#define OP_NOP                  0xa3
#define OP_RETURN               0xa4
#define OP_BREAK                0xa5
#define OP_OSI                  0xca
#define OP_BREAKPOINT           0xcc
#define OP_ONES                 0xff

#define EXOP_MUTEX              0x01
#define EXOP_EVENT              0x02
#define EXOP_CONDREFOF          0x12
#define EXOP_CREATEFIELD        0x13
#define EXOP_LOAD               0x20
#define EXOP_STALL              0x21
#define EXOP_SLEEP              0x22
#define EXOP_ACQUIRE            0x23
#define EXOP_SIGNAL             0x24
#define EXOP_WAIT               0x25
#define EXOP_RESET              0x26
#define EXOP_RELEASE            0x27
#define EXOP_FROMBCD            0x28
#define EXOP_TOBCD              0x29
#define EXOP_UNLOAD             0x2a
#define EXOP_REVISION           0x30
#define EXOP_DEBUG              0x31
#define EXOP_FATAL              0x32
#define EXOP_OPREGION           0x80
#define EXOP_FIELD              0x81
#define EXOP_DEVICE             0x82
#define EXOP_PROCESSOR          0x83
#define EXOP_POWERRES           0x84
#define EXOP_THERMALZONE        0x85
#define EXOP_IDXFIELD           0x86
#define EXOP_BANKFIELD          0x87

#define OP_MUTEX                EXOP(EXOP_MUTEX)
#define OP_EVENT                EXOP(EXOP_EVENT)
#define OP_CONDREFOF            EXOP(EXOP_CONDREFOF)
#define OP_CREATEFIELD          EXOP(EXOP_CREATEFIELD)
#define OP_LOAD                 EXOP(EXOP_LOAD)
#define OP_STALL                EXOP(EXOP_STALL)
#define OP_SLEEP                EXOP(EXOP_SLEEP)
#define OP_ACQUIRE              EXOP(EXOP_ACQUIRE)
#define OP_SIGNAL               EXOP(EXOP_SIGNAL)
#define OP_WAIT                 EXOP(EXOP_WAIT)
#define OP_RESET                EXOP(EXOP_RESET)
#define OP_RELEASE              EXOP(EXOP_RELEASE)
#define OP_FROMBCD              EXOP(EXOP_FROMBCD)
#define OP_TOBCD                EXOP(EXOP_TOBCD)
#define OP_UNLOAD               EXOP(EXOP_UNLOAD)
#define OP_REVISION             EXOP(EXOP_REVISION)
#define OP_DEBUG                EXOP(EXOP_DEBUG)
#define OP_FATAL                EXOP(EXOP_FATAL)
#define OP_OPREGION             EXOP(EXOP_OPREGION)
#define OP_FIELD                EXOP(EXOP_FIELD)
#define OP_DEVICE               EXOP(EXOP_DEVICE)
#define OP_PROCESSOR            EXOP(EXOP_PROCESSOR)
#define OP_POWERRES             EXOP(EXOP_POWERRES)
#define OP_THERMALZONE          EXOP(EXOP_THERMALZONE)
#define OP_IDXFIELD             EXOP(EXOP_IDXFIELD)
#define OP_BANKFIELD            EXOP(EXOP_BANKFIELD)

/*** Field flags
 */

#define ACCTYPE_MASK            0x0f
#define ACCTYPE_ANY             0x00    //AnyAcc
#define ACCTYPE_BYTE            0x01    //ByteAcc
#define ACCTYPE_WORD            0x02    //WordAcc
#define ACCTYPE_DWORD           0x03    //DWordAcc
#define ACCTYPE_QWORD           0x04    //QWordAcc
#define ACCTYPE_BUFFER          0x05    //BufferAcc
#define LOCKRULE_MASK           0x10
#define LOCKRULE_NOLOCK         0x00    //NoLock
#define LOCKRULE_LOCK           0x10    //Lock
#define UPDATERULE_MASK         0x60
#define UPDATERULE_PRESERVE     0x00    //Preserve
#define UPDATERULE_WRITEASONES  0x20    //WriteAsOnes
#define UPDATERULE_WRITEASZEROS 0x40    //WriteAsZeros
#define ACCATTRIB_MASK          0xff00

//
// Returns 1, 2 or 4 for BYTE, WORD or DWORD respectively and returns 1 for
// any other sizes.
//
#define ACCSIZE(f)  (((((f) & ACCTYPE_MASK) >= ACCTYPE_BYTE) &&   \
                    (((f) & ACCTYPE_MASK) <= ACCTYPE_DWORD))?   \
                    (1 << (((f) & ACCTYPE_MASK) - 1)): 1)

/*** Operation region space
 */

#define REGSPACE_MEM            0       //SystemMemory
#define REGSPACE_IO             1       //SystemIO
#define REGSPACE_PCICFG         2       //PCI_Config
#define REGSPACE_EC             3       //EmbeddedControl
#define REGSPACE_SMB            4       //SMBus
#define REGSPACE_CMOSCFG        5       //Cmos_Config
#define REGSPACE_PCIBARTARGET   6       //PCIBARTarget


/*** Method flags
 */

#define METHOD_NUMARG_MASK      0x07
#define METHOD_SYNCMASK         0x08
#define METHOD_NOTSERIALIZED    0x00
#define METHOD_SERIALIZED       0x08

/*** Match operation values
 */

#define MTR                     0
#define MEQ                     1
#define MLE                     2
#define MLT                     3
#define MGE                     4
#define MGT                     5

/*** IRQ Flags for short descriptor
 */

#define _HE             0x01    //ActiveHigh, EdgeTrigger
#define _LL             0x08    //ActiveLow, LevelTrigger
#define _SHR            0x10    //Shared
#define _EXC            0x00    //Exclusive

/*** IRQ Flags for long descriptor
 */

#define $EDG            0x02    //EdgeTrigger
#define $LVL            0x00    //LevelTrigger
#define $LOW            0x04    //ActiveLow
#define $HGH            0x00    //ActiveHigh
#define $SHR            0x08    //Shared
#define $EXC            0x00    //Exclusive

/*** DMA Flags
 */

#define X8                      0x00    //Transfer8
#define X816                    0x01    //Transfer8_16
#define X16                     0x02    //Transfer16
#define NOBM                    0x00    //NotBusMaster
#define BM                      0x04    //BusMaster
#define COMP                    0x00    //Compatibility
#define TYPA                    0x20    //TypeA
#define TYPB                    0x40    //TypeB
#define TYPF                    0x60    //TypeF

/*** IO Flags
 */

#define DC16                    0x01    //Decode16
#define DC10                    0x00    //Decode10

/*** Memory Flags
 */

#define _RW                     0x01    //Read/Write
#define _ROM                    0x00    //Read only

/*** Address Space Descriptor General Flags
 */

#define RCS                     0x01    //Resource Consumer
#define RPD                     0x00    //Resource Producer
#define BSD                     0x02    //Bridge Subtractive Decode
#define BPD                     0x00    //Bridge Positive Decode
#define MIF                     0x04    //Min address is fixed
#define NMIF                    0x00    //Min address is not fixed
#define MAF                     0x08    //Max address is fixed
#define NMAF                    0x00    //Max address is not fixed

/*** Memory Address Space Flags
 */

#define CACH                    0x02    //Cacheable
#define WRCB                    0x04    //WriteCombining
#define PREF                    0x06    //Prefetchable
#define NCAC                    0x00    //Non-Cacheable

/*** IO Address Space Flags
 */

#define ISA                     0x02    //ISAOnly ranges
#define NISA                    0x01    //NonISAOnly ranges
#define ERNG                    0x03    //Entire range

#define MAX_ARGS                7
#define MAX_NSPATH_LEN          1275    //approx. 255*4 + 255 (255 NameSegs)

#endif  //ifndef _AML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpidock.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpidock.c

Abstract:

    This module handles docking issues for ACPI.

    For each dock, we create a node off the root of ACPI called a "profile
    provider". This node represents that individual dock. We do this so
    that the OS can determine the current or upcoming hardware profile
    without having to start that portion of the tree which leads down to
    the dock. Also, as multiple simulataneous docks are supported via ACPI,
    we make them all children of the root so that the OS can pick up the
    hardware profile in just one pass.

Author:

    Adrian J. Oney (AdriaO)

Environment:

    Kernel mode only.

Revision History:

    20-Jan-98   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIDockIrpStartDevice)
#pragma alloc_text(PAGE,ACPIDockIrpQueryCapabilities)
#pragma alloc_text(PAGE,ACPIDockIrpQueryDeviceRelations)
#pragma alloc_text(PAGE,ACPIDockIrpEject)
#pragma alloc_text(PAGE,ACPIDockIrpQueryID)
#pragma alloc_text(PAGE,ACPIDockIrpSetLock)
#pragma alloc_text(PAGE,ACPIDockIrpQueryEjectRelations)
#pragma alloc_text(PAGE,ACPIDockIrpQueryInterface)
#pragma alloc_text(PAGE,ACPIDockIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE,ACPIDockIntfReference)
#pragma alloc_text(PAGE,ACPIDockIntfDereference)
#pragma alloc_text(PAGE,ACPIDockIntfSetMode)
#pragma alloc_text(PAGE,ACPIDockIntfUpdateDeparture)
#endif


PDEVICE_EXTENSION
ACPIDockFindCorrespondingDock(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine takes a pointer to an ACPI object an returns the dock extension
    that matches it.

Argument Description:

    DeviceExtension - The device for which we want the dock

Return Value:

    NULL or the matching extension for the profile provider

--*/
{
    PDEVICE_EXTENSION      rootChildExtension = NULL ;
    EXTENSIONLIST_ENUMDATA eled ;

    ACPIExtListSetupEnum(
        &eled,
        &(RootDeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        ) ;

    for(rootChildExtension = ACPIExtListStartEnum(&eled);
                             ACPIExtListTestElement(&eled, TRUE) ;
        rootChildExtension = ACPIExtListEnumNext(&eled)) {

        if (!rootChildExtension) {

            ACPIExtListExitEnumEarly(&eled);
            break;

        }

        if (!(rootChildExtension->Flags & DEV_PROP_DOCK)) {

            continue;

        }

        if (rootChildExtension->Dock.CorrospondingAcpiDevice ==
            DeviceExtension) {

            ACPIExtListExitEnumEarly(&eled) ;
            break;

        }

    }

    //
    // Done
    //
    return rootChildExtension;
}

NTSTATUS
ACPIDockGetDockObject(
    IN  PNSOBJ AcpiObject,
    OUT PNSOBJ *dckObject
    )
/*++

Routine Description:

    This routine gets the _DCK method object if the device has one

Arguments:

    The ACPI Object to test.

Return Value:

    NTSTATUS (failure if _DCK method does not exist)

--*/
{
    return AMLIGetNameSpaceObject(
        "_DCK",
        AcpiObject,
        dckObject,
        NSF_LOCAL_SCOPE
        );
}

NTSTATUS
ACPIDockIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack            = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction       = irpStack->MinorFunction;
    PDEVICE_EXTENSION   deviceExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PNSOBJ              ej0Object;
    NTSTATUS            status;
    ULONG               i, ignoredPerSpec ;

    PAGED_CODE();

    //
    // The dock may have failed _DCK on a start, in which case we have kept
    // it around for the explicit purpose of ejecting it. Now we make the dock
    // go away.
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_CAP_UNATTACHED_DOCK,
        TRUE
        );

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpEject: no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0);

        //
        // Mark the irp as very bad...
        //
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT) {

        //
        // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
        // lose the debugger com port programming.
        //
        KdDisableDebugger();

        if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

            status = ACPIGetIntegerEvalIntegerSync(
               dockDeviceExtension,
               PACKED_DCK,
               0,
               &ignoredPerSpec
               );

            deviceExtension->Dock.IsolationState = IS_ISOLATED;
        }

        if (!NT_SUCCESS(status)) {

           KdEnableDebugger();

           Irp->IoStatus.Status = status ;
           IoCompleteRequest( Irp, IO_NO_INCREMENT );
           return status ;
        }
    }

    ej0Object = ACPIAmliGetNamedChild(
        dockDeviceExtension->AcpiObject,
        PACKED_EJ0
        );

    if (ej0Object != NULL) {

        status = ACPIGetNothingEvalIntegerSync(
          dockDeviceExtension,
          PACKED_EJ0,
          1
          );

    } else {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT) {

        KdEnableDebugger() ;
    }

    //
    // The dock may have failed _DCK on a start, in which case we have kept
    // it around for the explicit purpose of ejecting it. Now we make the dock
    // go away.
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_CAP_UNATTACHED_DOCK,
        TRUE
        );

    if (NT_SUCCESS(status)) {

        //
        // Get the currrent device status
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &i,
            NULL
            );
        if (NT_SUCCESS(status) &&
            !(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "(0x%08lx): ACPIDockIrpEjectDevice: "
                "dock is still listed as present after _DCK/_EJx!\n",
                Irp
                ) );

            //
            // The device did not go away. Let us fail this
            //
            status = STATUS_UNSUCCESSFUL ;

        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status ;
}

NTSTATUS
ACPIDockIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to get the capabilities of a device.

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS             status ;
    PDEVICE_EXTENSION    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION    dockDeviceExtension;
    PIO_STACK_LOCATION   irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR                minorFunction   = irpStack->MinorFunction;
    PDEVICE_CAPABILITIES capabilities;
    PNSOBJ               acpiObject ;

    PAGED_CODE();

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryCapabilities: "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    acpiObject = dockDeviceExtension->AcpiObject ;

    //
    // Set the current flags for the capabilities
    //
    capabilities->SilentInstall  = TRUE;
    capabilities->RawDeviceOK    = TRUE;
    capabilities->DockDevice     = TRUE;
    capabilities->Removable      = TRUE;
    capabilities->UniqueID       = TRUE;

    if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ0)) {

        capabilities->EjectSupported = TRUE;
    }

    if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ1) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ2) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ3) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ4)) {

        capabilities->WarmEjectSupported = TRUE;
    }

    //
    // An object of this name signifies the node is lockable
    //
#if !defined(ACPI_INTERNAL_LOCKING)
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_LCK) != NULL) {

        capabilities->LockSupported = TRUE;

    }
#endif

    //
    // Internally record the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );

    //
    // Round down S1-S3 to D3. This will ensure we reexamine the _STA after
    // resume from sleep (note that we won't actually be playing with the docks
    // power methods, so this is safe)
    //
    capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
    capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
    capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;

    //
    // We can do this slimy-like because we don't have any Wake bits or
    // anything else fancy.
    //
    IoCopyDeviceCapabilitiesMapping(
        capabilities,
        deviceExtension->PowerInfo.DevicePowerMatrix
        );

    //
    // Now update our power matrix.
    //

    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );
    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIDockIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to query device relations. Since profile providers
    never have children, we only need to fix up the eject relations
    appropriately

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

       case BusRelations:
           break ;

       case TargetDeviceRelation:

           status = ACPIBusIrpQueryTargetRelation(
               DeviceObject,
               Irp,
               &deviceRelations
               );
           break ;

       case EjectionRelations:

           status = ACPIDockIrpQueryEjectRelations(
               DeviceObject,
               Irp,
               &deviceRelations
               );
           break ;

       default:

           ACPIDevPrint( (
               ACPI_PRINT_IRP,
               deviceExtension,
               "(0x%08lx): %s - Unhandled Type %d\n",
               Irp,
               ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
               irpStack->Parameters.QueryDeviceRelations.Type
               ) );
           break ;
      }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ((status != STATUS_NOT_SUPPORTED) && (deviceRelations == NULL)) {

        //
        // If we haven't succeed the irp, then we can also fail it, but only
        // if nothing else has been added.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Grab our status from what is already present
        //
        status = Irp->IoStatus.Status;
    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryEjectRelations(
    IN     PDEVICE_OBJECT    DeviceObject,
    IN     PIRP              Irp,
    IN OUT PDEVICE_RELATIONS *PdeviceRelations
    )
{
    PDEVICE_EXTENSION  deviceExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION  dockDeviceExtension ;
    PNSOBJ             acpiObject          = NULL;
    NTSTATUS           status ;

    PAGED_CODE();

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;
    if (!dockDeviceExtension) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return STATUS_UNSUCCESSFUL;

    }

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    acpiObject = dockDeviceExtension->AcpiObject;
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            acpiObject
            ) );
        return STATUS_INVALID_PARAMETER;

    }

    status = ACPIDetectEjectDevices(
        dockDeviceExtension,
        PdeviceRelations,
        dockDeviceExtension
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // That's not nice..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: enum 0x%08lx\n",
            Irp,
            status
            ) );

    }
    return status ;
}

NTSTATUS
ACPIDockIrpQueryID(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_ID PNP
    minor function

    Note:   This is what the returned strings from this function should look
            like.

            DeviceID     = ACPI\DockDevice
            InstanceID   = ACPI object node ( CDCK, etc )
            HardwareIDs  = ACPI\DockDevice&_SB.DOCK, ACPI\DockDevice

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject      = deviceExtension->AcpiObject;
    PUCHAR              buffer;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    UNICODE_STRING      unicodeIdString;
    PWCHAR              serialID;
    ULONG               firstHardwareIDLength;

    PAGED_CODE();

    //
    // Initilize the Unicode Structure
    //
    RtlZeroMemory( &unicodeIdString, sizeof(UNICODE_STRING) );

    //
    // What we do is based on the IdType of the Request...
    //
    type = irpStack->Parameters.QueryId.IdType;
    switch (type) {
        case BusQueryDeviceID:

            //
            // We pre-calculate this since it is so useful for debugging
            //
            status = ACPIInitUnicodeString(
                &unicodeIdString,
                deviceExtension->DeviceID
                );
            break;

        case BusQueryDeviceSerialNumber:

            //
            // lets get the corrosponding dock node for this device
            //
            dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice;

            if (!dockDeviceExtension) {

                //
                // Invalid name space object <bad>
                //
                ACPIDevPrint( (
                    ACPI_PRINT_FAILURE,
                    deviceExtension,
                    "(0x%08lx): ACPIDockIrpQueryID: no corresponding extension!!\n",
                    Irp
                    ) );
                ASSERT(0);

                //
                // Mark the irp as very bad...
                //
                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return STATUS_UNSUCCESSFUL;
            }

            status = ACPIGetSerialIDWide(
                dockDeviceExtension,
                &serialID,
                NULL
                );

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Return the Serial Number for the DockDevice
            //
            unicodeIdString.Buffer = serialID;
            break;

        case BusQueryInstanceID:

            //
            // We pre-calculate this since it is so useful for debugging
            //
            status = ACPIInitUnicodeString(
                &unicodeIdString,
                deviceExtension->InstanceID
                );

            break;

        case BusQueryCompatibleIDs:

            status = STATUS_NOT_SUPPORTED;
            break;

        case BusQueryHardwareIDs:

            //
            // Now set our identifier. In theory, the OS could use this
            // string in any scenario, although in reality it will key off
            // of the dock ID.
            //
            // Construct the MultiSz hardware ID list:
            //     ACPI\DockDevice&_SB.PCI0.DOCK
            //     ACPI\DockDevice
            //
            status = ACPIInitMultiString(
                &unicodeIdString,
                "ACPI\\DockDevice",
                deviceExtension->InstanceID,
                "ACPI\\DockDevice",
                NULL
                );

            if (NT_SUCCESS(status)) {

                //
                // Replace first '\0' with '&'
                //
                firstHardwareIDLength = wcslen(unicodeIdString.Buffer);
                unicodeIdString.Buffer[firstHardwareIDLength] = L'&';
            }

            break;

        default:

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Id %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                type
                ) );
            status = STATUS_NOT_SUPPORTED;
            break;

    } // switch

    //
    // Did we pass or did we fail?
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;

    } else {

        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s(%d) = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        type,
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_INTERFACE minor
    function. The only reason we respond to this is so we can handle the
    dock interface which is used to solve the removal ordering problem we won't
    be fixing 5.0 (sigh).

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    LPGUID              interfaceType;

    PAGED_CODE();

    status = Irp->IoStatus.Status;
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

    if (CompareGuid(interfaceType, (PVOID) &GUID_DOCK_INTERFACE)) {

        DOCK_INTERFACE dockInterface;
        USHORT         count;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size > sizeof(DOCK_INTERFACE)) {

            count = sizeof(DOCK_INTERFACE);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Build up the interface structure.
        //
        dockInterface.Size = count;
        dockInterface.Version = DOCK_INTRF_STANDARD_VER;
        dockInterface.Context = DeviceObject;
        dockInterface.InterfaceReference = ACPIDockIntfReference;
        dockInterface.InterfaceDereference = ACPIDockIntfDereference;
        dockInterface.ProfileDepartureSetMode = ACPIDockIntfSetMode;
        dockInterface.ProfileDepartureUpdate = ACPIDockIntfUpdateDeparture;

        //
        // Give it a reference
        //
        dockInterface.InterfaceReference(dockInterface.Context);

        //
        // Hand back the interface
        //
        RtlCopyMemory(
            (PDOCK_INTERFACE) irpStack->Parameters.QueryInterface.Interface,
            &dockInterface,
            count
            );

        //
        // We're done with this irp
        //
        Irp->IoStatus.Status = status = STATUS_SUCCESS;
    }

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_PNP_DEVICE_STATE
    minor function. The only reason we respond to this is so we can set the
    PNP_DEVICE_DONT_DISPLAY_IN_UI flag (we are a raw PDO that does not need
    to be visible)

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI ;

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject    - The device whose state we want to know
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension ;
    PIO_STACK_LOCATION  irpSp;
    PNSOBJ              acpiObject, ejectObject ;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx ;

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryPower - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - complete the IRP.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    //
    // Restrict power states to those supported.
    //
    acpiObject = dockDeviceExtension->AcpiObject;

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;

    switch (irpSp->Parameters.Power.State.SystemState) {

        case PowerSystemSleeping1:
            packedEJx = PACKED_EJ1;
            break;
        case PowerSystemSleeping2:
            packedEJx = PACKED_EJ2;
            break;
        case PowerSystemSleeping3:
            packedEJx = PACKED_EJ3;
            break;
        case PowerSystemHibernate:
            packedEJx = PACKED_EJ4;
            break;
        case PowerSystemWorking:
        case PowerSystemShutdown:
        default:
            packedEJx = 0;
            break;
    }

    if (packedEJx) {

        ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx);
        if (ejectObject == NULL) {

            //
            // Fail the request, as we cannot eject in this case.
            //
            PoStartNextPowerIrp( Irp );
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return STATUS_UNSUCCESSFUL;
        }
    }

    return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
}

NTSTATUS
ACPIDockIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we need to remove the device. Note that we only
    delete ourselves if we have been undocked (ie, our hardware is gone)

Arguments:

    DeviceObject    - The dock device to "remove"
    Irp             - The request to the device to tell it to go away

Return Value:

    NTSTATUS

--*/
{
   LONG                oldReferenceCount;
   KIRQL               oldIrql;
   NTSTATUS            status          = STATUS_SUCCESS;
   PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
   PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
   UCHAR               minorFunction   = irpStack->MinorFunction;
   ULONG               i, ignoredPerSpec;

   if (!(deviceExtension->Flags & DEV_MASK_NOT_PRESENT)) {

       //
       // If the device is still physically present, so must the PDO be.
       // This case is essentially a stop. Mark the request as complete...
       //
       Irp->IoStatus.Status = status;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return status;
   }

   if (deviceExtension->DeviceState == Removed) {

       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_NO_SUCH_DEVICE;
   }

   if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_REMOVE) {

       PDEVICE_EXTENSION dockDeviceExtension;

       //
       // lets get the corrosponding dock node for this device
       //
       dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

       //
       // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
       // lose the debugger com port programming.
       //
       if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

           KdDisableDebugger();

           status = ACPIGetIntegerEvalIntegerSync(
              dockDeviceExtension,
              PACKED_DCK,
              0,
              &ignoredPerSpec
              );

           KdEnableDebugger();
       }
   }

   //
   // The device is gone. Let the isolation state reflect that.
   //
   deviceExtension->Dock.IsolationState = IS_UNKNOWN;

   //
   // Set the device state as removed
   //
   deviceExtension->DeviceState = Removed;

   //
   // Complete the request
   //
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = (ULONG_PTR) NULL;
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   //
   // Done
   //
   ACPIDevPrint( (
       ACPI_PRINT_IRP,
       deviceExtension,
       "(0x%08lx): %s = 0x%08lx\n",
       Irp,
       ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
       STATUS_SUCCESS
       ) );

   //
   // Update the device extension
   //
   KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

   ASSERT(!(deviceExtension->Flags&DEV_TYPE_FILTER)) ;

   //
   // Step one is to zero out the things that we no longer care about
   //
   deviceExtension->TargetDeviceObject = NULL;
   deviceExtension->PhysicalDeviceObject = NULL;
   deviceExtension->DeviceObject = NULL;

   //
   // Mark the node as being fresh and untouched
   //
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_MASK_TYPE, TRUE );
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

   //
   // The reference count should have value > 0
   //
   oldReferenceCount = InterlockedDecrement(
       &(deviceExtension->ReferenceCount)
       );

   ASSERT(oldReferenceCount >= 0) ;

   if ( oldReferenceCount == 0) {

       //
       // Delete the extension
       //
       ACPIInitDeleteDeviceExtension( deviceExtension );

   }

   //
   // Done with the lock
   //
   KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

   //
   // Delete the device
   //
   IoDeleteDevice( DeviceObject );

   //
   // Done
   //
   return STATUS_SUCCESS;
}

NTSTATUS
ACPIDockIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - The device to set the lock state for
    Irp             - The request to the device to tell it to lock

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

    PAGED_CODE();

    //
    // We aren't a real device, so we don't do locking.
    //
    status = Irp->IoStatus.Status ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status ;
}

NTSTATUS
ACPIDockIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device

Arguments:

    DeviceObject    - The device to start
    Irp             - The request to the device to tell it to start

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    ULONG               dockResult;
    ULONG               dockStatus;

    PAGED_CODE();

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpStartDevice - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    if (deviceExtension->Dock.IsolationState == IS_ISOLATED) {

        KdDisableDebugger();

        //
        // Note: the way that this is structured is that we get
        // the _DCK value first, and if that succeeds, then we
        // get the device presence. If that also succeeds, then
        // we try to process the two. If either fail, we don't
        // do any work
        //
        status = ACPIGetIntegerEvalIntegerSync(
            dockDeviceExtension,
            PACKED_DCK,
            1,
            &dockResult
            );

        if (NT_SUCCESS(status)) {

            //
            // Get the device presence
            //
            status = ACPIGetDevicePresenceSync(
                dockDeviceExtension,
                (PVOID *) &dockStatus,
                NULL
                );

        }

        KdEnableDebugger();

        if (NT_SUCCESS(status)) {

            if (dockDeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

                if (dockResult != 0) {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: "
                        "Not present, but _DCK = %08lx\n",
                        Irp,
                        dockResult
                        ) );

                } else {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: _DCK = 0\n",
                        Irp
                        ) );

                }
                status = STATUS_UNSUCCESSFUL ;

            } else {

                if (dockResult != 1) {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: _DCK = 0\n",
                        Irp
                        ) );

                } else {

                    ACPIDevPrint( (
                        ACPI_PRINT_IRP,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice = 0x%08lx\n",
                        Irp,
                        status
                        ) );

                }
            }
        }

        //
        // We are done. The ACPI implementers guide says we don't need to
        // enumerate the entire tree here as the _DCK method should have
        // notified the appropriate branches of the tree if the docking event
        // was successful. Unfortunately Win2K behavior was to enumerate the
        // entire tree. Specifically, it would drain starts before enums. Since
        // the profile provider appeared at the top of the tree, the dock would
        // start and then the enum that found it would proceed and find the
        // hardware. To maintain this pseudo-behavior we queue an enum here
        // (bletch.)
        //
        IoInvalidateDeviceRelations(
            RootDeviceExtension->PhysicalDeviceObject,
            BusRelations
            );

        //
        // Now we remove the unattached dock flag, but only if we succeeded
        // start. If we cleared it in the failure case, we couldn't eject the
        // dock that may be physically attached. Note that this also means we
        // *must* try to eject the dock after start failure! The proper code for
        // this is part of the kernel.
        //
        if (NT_SUCCESS(status)) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_CAP_UNATTACHED_DOCK,
                TRUE
                );
        }
    }

    if (NT_SUCCESS(status)) {

        deviceExtension->Dock.IsolationState = IS_ISOLATION_DROPPED;
        deviceExtension->DeviceState = Started;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

BOOLEAN
ACPIDockIsDockDevice(
    IN PNSOBJ AcpiObject
    )
/*++

Routine Description:

    This routine will tell the caller whether the given device is a dock.

Arguments:

    The ACPI Object to test.

Return Value:

    BOOLEAN (true iff dock)

--*/
{
    PNSOBJ dckMethodObject ;

    //
    // ACPI dock devices are identified via _DCK methods.
    //
    return (NT_SUCCESS(ACPIDockGetDockObject(AcpiObject, &dckMethodObject))) ;
}

NTSTATUS
ACPIDockIrpSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles request to set the power state for a Physical
    Device object

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpSp->MinorFunction;

    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        return ACPIDockIrpSetDevicePower(DeviceObject, Irp);

    } else {

        return ACPIDockIrpSetSystemPower(DeviceObject, Irp);
    }
}

NTSTATUS
ACPIDockIrpSetDevicePower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    )
/*++

Routine Description:

    This routine handles device power request for a dock PDO

Arguments:

    DeviceObject    - The PDO target
    Irp             - The request
    IrpStack        - The current request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Queue the irp up. Note that we will *always* call the completion
    // routine, so we don't really care what was returned directly by
    // this call --- the callback gets a chance to execute.
    //
    status = ACPIDeviceIrpDeviceRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used
    // if we overload STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Note: We called the completion routine, which should have completed
    // the IRP with the same STATUS code as is being returned here (okay, if
    // it is STATUS_PENDING, obviously we haven't completed the IRP, but that
    // is okay).
    //
    return status;
}

NTSTATUS
ACPIDockIrpSetSystemPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles request to set the system power state for a Physical
    Device object. Here we initiate warm ejects and act as a power policy
    manager for ourselves.

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpSp->MinorFunction;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    SYSTEM_POWER_STATE  systemState;
    DEVICE_POWER_STATE  deviceState;
    POWER_STATE         powerState;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Grab these two values. They are required for further calculations
    //
    systemState= irpSp->Parameters.Power.State.SystemState;
    deviceState = deviceExtension->PowerInfo.DevicePowerMatrix[systemState];

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpSetPower - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    if (irpSp->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        //
        // We are going to do some work on the irp, so mark it as being
        // successful for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Mark the irp as pending
        //
        IoMarkIrpPending( Irp );

        //
        // We might queue up the irp, so this counts as a completion routine.
        // Which means we need to incr the ref count
        //
        InterlockedIncrement( &dockDeviceExtension->OutstandingIrpCount );

        ACPIDevPrint( (
            ACPI_PRINT_REMOVE,
            deviceExtension,
            "(0x%08lx) ACPIBusIrpSetSystemPower: Eject from S%d!\n",
            Irp,
            systemState - PowerSystemWorking
            ) );

        //
        // Request the warm eject
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            dockDeviceExtension,
            Irp,
            ACPIDeviceIrpCompleteRequest,
            (BOOLEAN) (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT)
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

        return status;
    }

    //
    // Look at the device extension and determine if we need to send a
    // D-irp in respond. The rule is that if the device is RAW driven or
    // the current D state of the device is numerically lower then the
    // known D state for the given S state, then we should send the request
    //
    ASSERT(deviceExtension->Flags & DEV_CAP_RAW);

    if ( (deviceExtension->PowerInfo.PowerState == deviceState) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx) ACPIDockIrpSetSystemPower: send D%d irp!\n",
        Irp,
        deviceState - PowerDeviceD0
        ) );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // We need to actually use a PowerState to send the request down, not
    // a device state
    //
    powerState.DeviceState = deviceState;

    //
    // Make the request
    //
    PoRequestPowerIrp(
        DeviceObject,
        IRP_MN_SET_POWER,
        powerState,
        ACPIDockIrpSetSystemPowerComplete,
        Irp,
        NULL
        );

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIDockIrpSetSystemPowerComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the created D-irp has been sent throughout
    the stack

Arguments:

    DeviceObject    - The device that received the request
    MinorFunction   - The function that was requested of the device
    PowerState      - The power state the device was sent to
    Context         - The original system irp
    IoStatus        - The result of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP                irp = (PIRP) Context;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Make sure that we have cleared the information field
    //
    irp->IoStatus.Information = 0;

    //
    // Call this wrapper function so that we don't have to duplicated code
    //
    ACPIDeviceIrpCompleteRequest(
        deviceExtension,
        (PVOID) irp,
        IoStatus->Status
        );

    //
    // Done
    //
    return IoStatus->Status;
}

VOID
ACPIDockIntfReference(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine increments the reference count for the dock interface

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    None

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    PAGED_CODE();

    ObReferenceObject(deviceObject);
    InterlockedIncrement(&deviceExtension->ReferenceCount);

    if (!(deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED)) {

        InterlockedIncrement(&deviceExtension->Dock.InterfaceReferenceCount);
    }
}

VOID
ACPIDockIntfDereference(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine decrements the reference count for the dock interface

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    None

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    ULONG               oldReferenceCount;

    PAGED_CODE();

    if (!(deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED)) {

        oldReferenceCount = InterlockedDecrement(
            &deviceExtension->Dock.InterfaceReferenceCount
            );

        if (oldReferenceCount == 0) {

            //
            // Revert back to the default used in buildsrc.c
            //
            deviceExtension->Dock.ProfileDepartureStyle = PDS_UPDATE_ON_EJECT;
        }
    }

    oldReferenceCount = InterlockedDecrement(&deviceExtension->ReferenceCount);

    if (oldReferenceCount == 0) {

        //
        // Delete the extension
        //
        ACPIInitDeleteDeviceExtension(deviceExtension);
    }

    ObDereferenceObject(deviceObject);
}

NTSTATUS
ACPIDockIntfSetMode(
    IN  PVOID                   Context,
    IN  PROFILE_DEPARTURE_STYLE Style
    )
/*++

Routine Description:

    This routine sets the manner in which profiles will be updated

Arguments:

    Context    - The device object this interface was taken out against
    Style      - PDS_UPDATE_ON_REMOVE, PDS_UPDATE_ON_EJECT,
                 PDS_UPDATE_ON_INTERFACE, or PDS_UPDATE_DEFAULT

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    PAGED_CODE();

    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        return STATUS_NO_SUCH_DEVICE;
    }

    deviceExtension->Dock.ProfileDepartureStyle =
        (Style == PDS_UPDATE_DEFAULT) ? PDS_UPDATE_ON_EJECT : Style;

    ASSERT(deviceExtension->Dock.InterfaceReferenceCount);
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDockIntfUpdateDeparture(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine initiates the hardware profile change portion of an undock

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    NTSTATUS            status;
    ULONG               ignoredPerSpec;
    PDEVICE_EXTENSION   dockDeviceExtension;

    PAGED_CODE();

    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(deviceExtension->Dock.InterfaceReferenceCount);
    ASSERT(deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_INTERFACE);

    if (deviceExtension->Dock.ProfileDepartureStyle != PDS_UPDATE_ON_INTERFACE) {

        //
        // Can't do this, we may already have updated our profile!
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    //
    // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
    // lose the debugger com port programming.
    //
    if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

        KdDisableDebugger();

        status = ACPIGetIntegerEvalIntegerSync(
           dockDeviceExtension,
           PACKED_DCK,
           0,
           &ignoredPerSpec
           );

        KdEnableDebugger();

        deviceExtension->Dock.IsolationState = IS_ISOLATED;
    }
    else{

        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\amli.h ===
/*** amli.h - AML Interpreter Public Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/03/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLI_H
#define _AMLI_H

#include <list.h>

#ifndef _INC_NSOBJ_ONLY

/*** Build Options
 */

#if DBG
  #define DEBUG
  #define DEBUGGER
  #define TRACING
#endif

#ifdef MAXDEBUG
  #define TRACING
#endif

/*** Macros
 */

#define AMLI_FAC_CODE                   0
#define NTINFO(x)                       (x)
#define NTWARN(x)                       (x)
#define NTERR(x)                        (x)
#define AMLIERR(x)                      (x)

#define STDCALL                         __stdcall
#define AMLIAPI                         __cdecl
#ifndef EXPORT
  #define EXPORT                        __cdecl
#endif

// Name space navigation macros
#define NSGETPARENT(p)                  ((p)->pnsParent)
#define NSGETFIRSTCHILD(p)              ((p)->pnsFirstChild)
#define NSGETPREVSIBLING(p)             (((p)->pnsParent != NULL &&         \
                                          (p)->pnsParent->pnsFirstChild !=  \
                                          (p))?                             \
                                         (PNSOBJ)((p)->list.plistPrev): NULL)
#define NSGETNEXTSIBLING(p)             (((p)->pnsParent != NULL &&         \
                                          (p)->pnsParent->pnsFirstChild !=  \
                                          (PNSOBJ)((p)->list.plistNext))?   \
                                         (PNSOBJ)((p)->list.plistNext): NULL)
#define NSGETOBJTYPE(p)                 ((p)->ObjData.dwDataType)

/*** Constants
 */

// AMLI Error Codes
#define AMLIERR_NONE                    STATUS_SUCCESS
#define AMLIERR_OUT_OF_MEM              STATUS_INSUFFICIENT_RESOURCES
#define AMLIERR_INVALID_OPCODE          STATUS_ACPI_INVALID_OPCODE
#define AMLIERR_NAME_TOO_LONG           STATUS_NAME_TOO_LONG
#define AMLIERR_ASSERT_FAILED           STATUS_ACPI_ASSERT_FAILED
#define AMLIERR_INVALID_NAME            STATUS_OBJECT_NAME_INVALID
#define AMLIERR_OBJ_NOT_FOUND           STATUS_OBJECT_NAME_NOT_FOUND
#define AMLIERR_OBJ_ALREADY_EXIST       STATUS_OBJECT_NAME_COLLISION
#define AMLIERR_INDEX_TOO_BIG           STATUS_ACPI_INVALID_INDEX
#define AMLIERR_ARG_NOT_EXIST           STATUS_ACPI_INVALID_ARGUMENT
#define AMLIERR_FATAL                   STATUS_ACPI_FATAL
#define AMLIERR_INVALID_SUPERNAME       STATUS_ACPI_INVALID_SUPERNAME
#define AMLIERR_UNEXPECTED_ARGTYPE      STATUS_ACPI_INVALID_ARGTYPE
#define AMLIERR_UNEXPECTED_OBJTYPE      STATUS_ACPI_INVALID_OBJTYPE
#define AMLIERR_UNEXPECTED_TARGETTYPE   STATUS_ACPI_INVALID_TARGETTYPE
#define AMLIERR_INCORRECT_NUMARG        STATUS_ACPI_INCORRECT_ARGUMENT_COUNT
#define AMLIERR_FAILED_ADDR_XLATE       STATUS_ACPI_ADDRESS_NOT_MAPPED
#define AMLIERR_INVALID_EVENTTYPE       STATUS_ACPI_INVALID_EVENTTYPE
#define AMLIERR_REGHANDLER_FAILED       STATUS_ACPI_REG_HANDLER_FAILED
#define AMLIERR_HANDLER_EXIST           STATUS_ACPI_HANDLER_COLLISION
#define AMLIERR_INVALID_DATA            STATUS_ACPI_INVALID_DATA
#define AMLIERR_INVALID_REGIONSPACE     STATUS_ACPI_INVALID_REGION
#define AMLIERR_INVALID_ACCSIZE         STATUS_ACPI_INVALID_ACCESS_SIZE
#define AMLIERR_INVALID_TABLE           STATUS_ACPI_INVALID_TABLE
#define AMLIERR_ACQUIREGL_FAILED        STATUS_ACPI_ACQUIRE_GLOBAL_LOCK
#define AMLIERR_ALREADY_INITIALIZED     STATUS_ACPI_ALREADY_INITIALIZED
#define AMLIERR_NOT_INITIALIZED         STATUS_ACPI_NOT_INITIALIZED
#define AMLIERR_MUTEX_INVALID_LEVEL     STATUS_ACPI_INVALID_MUTEX_LEVEL
#define AMLIERR_MUTEX_NOT_OWNED         STATUS_ACPI_MUTEX_NOT_OWNED
#define AMLIERR_MUTEX_NOT_OWNER         STATUS_ACPI_MUTEX_NOT_OWNER
#define AMLIERR_RS_ACCESS               STATUS_ACPI_RS_ACCESS
#define AMLIERR_STACK_OVERFLOW          STATUS_ACPI_STACK_OVERFLOW
#define AMLIERR_INVALID_BUFFSIZE        STATUS_INVALID_BUFFER_SIZE
#define AMLIERR_BUFF_TOOSMALL           STATUS_BUFFER_TOO_SMALL
#define AMLIERR_NOTIFY_FAILED           STATUS_ACPI_FATAL

// RegEventHandler constants
#define EVTYPE_OPCODE                   0x00000001
#define EVTYPE_NOTIFY                   0x00000002
#define EVTYPE_FATAL                    0x00000003
#define EVTYPE_VALIDATE_TABLE           0x00000004
#define EVTYPE_ACQREL_GLOBALLOCK        0x00000005
#define EVTYPE_RS_COOKACCESS            0x00000006
#define EVTYPE_RS_RAWACCESS             0x00000007
#define EVTYPE_CON_MESSAGE              0x00000008
#define EVTYPE_CON_PROMPT               0x00000009
#define EVTYPE_CREATE                   0x0000000A
#define EVTYPE_DESTROYOBJ               0x0000000B
#define EVTYPE_OPCODE_EX                0x0000000C

// OPCODE_EX flags
#define OPEXF_NOTIFY_PRE                0x00000001
#define OPEXF_NOTIFY_POST               0x00000002

// DESTROYOBJ events
#define DESTROYOBJ_START                0x00000001
#define DESTROYOBJ_REMOVE_OBJECT        0x00000002
#define DESTROYOBJ_END                  0x00000003
#define DESTROYOBJ_CHILD_NOT_FREED      0x00000004
#define DESTROYOBJ_BOGUS_PARENT         0x00000005

// Notify Event Constants
#define OPEVENT_DEVICE_ENUM             0x00000000
#define OPEVENT_DEVICE_CHECK            0x00000001
#define OPEVENT_DEVICE_WAKE             0x00000002
#define OPEVENT_DEVICE_EJECT            0x00000003

#define RSACCESS_READ                   0
#define RSACCESS_WRITE                  1

#define GLOBALLOCK_ACQUIRE              0
#define GLOBALLOCK_RELEASE              1

// dwfAMLIInit flags
#define AMLIIF_INIT_BREAK       0x00000001      //break at AMLIInit completion
#define AMLIIF_LOADDDB_BREAK    0x00000002      //break at LoadDDB completion
#define AMLIIF_NOCHK_TABLEVER   0x80000000      //do not check table version

#endif  //ifndef _INC_NSOBJ_ONLY

#define NAMESEG                 ULONG
#define SUPERNAME               NAMESEG

// dwfFlags for AMLIGetNameSpaceObject
#define NSF_LOCAL_SCOPE         0x00000001

/*** Type and Structure definitions
 */

typedef struct _ObjData OBJDATA, *POBJDATA, **PPOBJDATA;
typedef struct _NSObj NSOBJ, *PNSOBJ, **PPNSOBJ;

//dwDataType values
typedef enum _OBJTYPES {
    OBJTYPE_UNKNOWN = 0,
    OBJTYPE_INTDATA,
    OBJTYPE_STRDATA,
    OBJTYPE_BUFFDATA,
    OBJTYPE_PKGDATA,
    OBJTYPE_FIELDUNIT,
    OBJTYPE_DEVICE,
    OBJTYPE_EVENT,
    OBJTYPE_METHOD,
    OBJTYPE_MUTEX,
    OBJTYPE_OPREGION,
    OBJTYPE_POWERRES,
    OBJTYPE_PROCESSOR,
    OBJTYPE_THERMALZONE,
    OBJTYPE_BUFFFIELD,
    OBJTYPE_DDBHANDLE,
    OBJTYPE_DEBUG,
//These are internal object types (not to be exported to the ASL code)
    OBJTYPE_INTERNAL = 0x80,
    OBJTYPE_OBJALIAS = 0x80,
    OBJTYPE_DATAALIAS,
    OBJTYPE_BANKFIELD,
    OBJTYPE_FIELD,
    OBJTYPE_INDEXFIELD,
    OBJTYPE_DATA,
    OBJTYPE_DATAFIELD,
    OBJTYPE_DATAOBJ,
} OBJTYPES;

struct _ObjData
{
    USHORT        dwfData;              //flags
    USHORT        dwDataType;           //object type
    union
    {
        ULONG     dwRefCount;           //reference count if base object
        POBJDATA  pdataBase;            //alias pointer to base object
    };
    union
    {
        ULONG     dwDataValue;          //data value of object 32-bit
        ULONG_PTR uipDataValue;         //data value of object 64-bit
        PNSOBJ    pnsAlias;             //alias ptr to base obj (OBJTYPE_OBJALIAS)
        POBJDATA  pdataAlias;           //alias ptr to base obj (OBJTYPE_DATAALIAS)
        PVOID     powner;               //object owner (OBJTYPE_DDBHANDLE)
    };
    ULONG         dwDataLen;            //object buffer length
    PUCHAR        pbDataBuff;           //object buffer
};

//dwfData flags
#define DATAF_BUFF_ALIAS        0x00000001
#define DATAF_GLOBAL_LOCK       0x00000002
#define DATAF_NSOBJ_DEFUNC      0x00000004

//Predefined data values (dwDataValue)
#define DATAVALUE_ZERO          0
#define DATAVALUE_ONE           1
#define DATAVALUE_ONES          0xffffffff

struct _NSObj
{
    LIST    list;                       //NOTE: list must be first in structure
    PNSOBJ  pnsParent;
    PNSOBJ  pnsFirstChild;
    ULONG   dwNameSeg;
    HANDLE  hOwner;
    PNSOBJ  pnsOwnedNext;
    OBJDATA ObjData;
    PVOID   Context;
    ULONG   dwRefCount;
};

typedef struct _FieldDesc
{
    ULONG dwByteOffset;
    ULONG dwStartBitPos;
    ULONG dwNumBits;
    ULONG dwFieldFlags;
} FIELDDESC, *PFIELDDESC;

//dwFieldFlags
#define FDF_FIELDFLAGS_MASK 0x000000ff
#define FDF_ACCATTRIB_MASK  0x0000ff00
#define FDF_BUFFER_TYPE     0x00010000
#define FDF_NEEDLOCK        0x80000000

typedef struct _BuffFieldObj
{
    FIELDDESC FieldDesc;
    PUCHAR    pbDataBuff;
    ULONG     dwBuffLen;
} BUFFFIELDOBJ, *PBUFFFIELDOBJ;

typedef struct _FieldUnitObj
{
    FIELDDESC FieldDesc;
    PNSOBJ    pnsFieldParent;
} FIELDUNITOBJ, *PFIELDUNITOBJ;

typedef struct _BankFieldObj
{
    PNSOBJ pnsBase;
    PNSOBJ pnsBank;
    ULONG  dwBankValue;
} BANKFIELDOBJ, *PBANKFIELDOBJ;

typedef struct _FieldObj
{
    PNSOBJ pnsBase;
} FIELDOBJ, *PFIELDOBJ;

typedef struct _IndexFieldObj
{
    PNSOBJ pnsIndex;
    PNSOBJ pnsData;
} INDEXFIELDOBJ, *PINDEXFIELDOBJ;

#ifdef ASL_ASSEMBLER
#define KSPIN_LOCK ULONG
#endif

typedef struct _OpRegionObj
{
    ULONG_PTR uipOffset;
    ULONG     dwLen;
    UCHAR     bRegionSpace;
    UCHAR     reserved[3];
    volatile LONG   RegionBusy;
    KSPIN_LOCK      listLock;
    PLIST     plistWaiters;
} OPREGIONOBJ, *POPREGIONOBJ;

typedef struct _MutexObj
{
    ULONG   dwSyncLevel;
    ULONG   dwcOwned;
    HANDLE  hOwner;
    PLIST   plistWaiters;
} MUTEXOBJ, *PMUTEXOBJ;

typedef struct _EventObj
{
    ULONG  dwcSignaled;
    PLIST  plistWaiters;
} EVENTOBJ, *PEVENTOBJ;

typedef struct _MethodObj
{
    MUTEXOBJ Mutex;
    UCHAR    bMethodFlags;
    UCHAR    abCodeBuff[ANYSIZE_ARRAY];
} METHODOBJ, *PMETHODOBJ;

typedef struct _PowerResObj
{
    UCHAR bSystemLevel;
    UCHAR bResOrder;
} POWERRESOBJ, *PPOWERRESOBJ;

typedef struct _ProcessorObj
{
    ULONG dwPBlk;
    ULONG dwPBlkLen;
    UCHAR bApicID;
} PROCESSOROBJ, *PPROCESSOROBJ;

typedef struct _PackageObj
{
    ULONG   dwcElements;
    OBJDATA adata[ANYSIZE_ARRAY];
} PACKAGEOBJ, *PPACKAGEOBJ;

#ifndef _INC_NSOBJ_ONLY

typedef struct _ctxtdata
{
    PVOID dwData1;
    PVOID dwData2;
    PVOID dwData3;
    PVOID dwData4;
} CTXTDATA, *PCTXTDATA;

typedef NTSTATUS (EXPORT *PFNHND)();
typedef NTSTATUS (EXPORT *PFNOH)(ULONG, ULONG, PNSOBJ, ULONG);
typedef NTSTATUS (EXPORT *PFNOO)(ULONG, PNSOBJ);
typedef VOID     (EXPORT *PFNAA)(PVOID);
typedef NTSTATUS (EXPORT *PFNNH)(ULONG, ULONG, PNSOBJ, ULONG, PFNAA, PVOID);
typedef NTSTATUS (EXPORT *PFNCA)(ULONG, PNSOBJ, ULONG_PTR, ULONG, PULONG, ULONG_PTR,
                                 PFNAA, PVOID);
typedef NTSTATUS (EXPORT *PFNRA)(ULONG, PFIELDUNITOBJ, POBJDATA, ULONG_PTR, PFNAA,
                                 PVOID);
typedef NTSTATUS (EXPORT *PFNVT)(PDSDT, ULONG_PTR);
typedef NTSTATUS (EXPORT *PFNFT)(ULONG, ULONG, ULONG, ULONG_PTR, ULONG_PTR);
typedef NTSTATUS (EXPORT *PFNGL)(ULONG, ULONG, ULONG_PTR, PFNAA, PVOID);
typedef VOID     (EXPORT *PFNCM)(PSZ, ULONG_PTR);
typedef VOID     (EXPORT *PFNCP)(PSZ, PSZ, ULONG, ULONG_PTR);
typedef VOID     (EXPORT *PFNACB)(PNSOBJ, NTSTATUS, POBJDATA, PVOID);
typedef NTSTATUS (EXPORT *PFNOPEX)(ULONG, ULONG, ULONG, PNSOBJ, ULONG);
typedef NTSTATUS (EXPORT *PFNDOBJ)(ULONG, PVOID, ULONG);

/*** Exported function prototypes
 */

#ifdef DEBUGGER
VOID STDCALL AMLIDebugger(BOOLEAN fCallFromVxD);
#endif
NTSTATUS AMLIAPI AMLIInitialize(ULONG dwCtxtBlkSize, ULONG dwGlobalHeapBlkSize,
                                ULONG dwfAMLIInit, ULONG dwmsTimeSliceLength,
                                ULONG dwmsTimeSliceInterval, ULONG dwmsMaxCTObjs);
NTSTATUS AMLIAPI AMLITerminate(VOID);
NTSTATUS AMLIAPI AMLILoadDDB(PDSDT pDSDT, HANDLE *phDDB);
VOID AMLIAPI AMLIUnloadDDB(HANDLE hDDB);
NTSTATUS AMLIAPI AMLIGetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope,
                                        PPNSOBJ ppns, ULONG dwfFlags);
NTSTATUS AMLIAPI AMLIGetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns);
NTSTATUS AMLIAPI AMLIEvalNameSpaceObject(PNSOBJ pns, POBJDATA pResult,
                                         int icArgs, POBJDATA pArgs);
NTSTATUS AMLIAPI AMLIAsyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                                     POBJDATA pArgs, PFNACB pfnAsynCallBack,
                                     PVOID pvContext);
NTSTATUS AMLIAPI AMLINestAsyncEvalObject(PNSOBJ pns, POBJDATA pResult,
                                         int icArgs, POBJDATA pArgs,
                                         PFNACB pfnAsynCallBack,
                                         PVOID pvContext);
NTSTATUS AMLIAPI AMLIEvalPackageElement(PNSOBJ pns, int iPktIndex,
                                        POBJDATA pResult);
NTSTATUS AMLIAPI AMLIEvalPkgDataElement(POBJDATA pdataPkg, int iPkgIndex,
                                        POBJDATA pdataResult);
VOID AMLIAPI AMLIFreeDataBuffs(POBJDATA pdata, int icData);
NTSTATUS AMLIAPI AMLIRegEventHandler(ULONG dwEventType, ULONG_PTR uipEventData,
                                     PFNHND pfnHandler, ULONG_PTR uipParam);
NTSTATUS AMLIAPI AMLIPauseInterpreter(PFNAA pfnCallBack, PVOID Context);
VOID AMLIAPI AMLIResumeInterpreter(VOID);
VOID AMLIAPI AMLIReferenceObject(PNSOBJ pnsObj);
VOID AMLIAPI AMLIDereferenceObject(PNSOBJ pnsObj);
NTSTATUS AMLIAPI AMLIDestroyFreedObjs(PNSOBJ pnsoObj);
#ifdef DEBUGGER
NTSTATUS AMLIAPI AMLIGetLastError(PSZ *ppszErrMsg);
#endif

#endif  //ifndef _INC_NSOBJ_ONLY

#endif  //ifndef _AMLI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpidock.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpidock.h

Abstract:

    This module handles docking issues for ACPI.

Author:

    Adrian J. Oney (AdriaO)

Environment:

    Kernel mode only.

Revision History:

    20-Jan-98   Initial Revision

--*/

#ifndef _ACPIDOCK_H_
#define _ACPIDOCK_H_

    NTSTATUS
    ACPIDockBuildDockPdo(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      ParentPdoObject
        );

    PDEVICE_EXTENSION
    ACPIDockFindCorrespondingDock(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIDockGetDockObject(
        IN  PNSOBJ AcpiObject,
        OUT PNSOBJ *dckObject
        );

    NTSTATUS
    ACPIDockIrpEject(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryEjectRelations(
        IN     PDEVICE_OBJECT    DeviceObject,
        IN     PIRP              Irp,
        IN OUT PDEVICE_RELATIONS *PdeviceRelations
        );

    NTSTATUS
    ACPIDockIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryID(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetLock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetDevicePower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetSystemPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetSystemPowerComplete(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

    NTSTATUS
    ACPIDockIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    BOOLEAN
    ACPIDockIsDockDevice(
        IN PNSOBJ AcpiObject
        );

    VOID
    ACPIDockIntfReference(
        IN  PVOID   Context
        );

    VOID
    ACPIDockIntfDereference(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIDockIntfSetMode(
        IN  PVOID                   Context,
        IN  PROFILE_DEPARTURE_STYLE Style
        );

    NTSTATUS
    ACPIDockIntfUpdateDeparture(
        IN  PVOID   Context
        );

#endif // _ACPIDOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\strlib.h ===
/*** strlib.h - String functions Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _STRLIB_H
#define _STRLIB_H

/*** Macros
 */

#ifndef EXPORT
  #define EXPORT __cdecl
#endif

#define STRLEN(s)               StrLen(s, (ULONG)(-1))
#define STRCPY(s1,s2)           StrCpy(s1, s2, (ULONG)(-1))
#define STRCPYN(s1,s2,n)        StrCpy(s1, s2, (ULONG)(n))
#define STRCAT(s1,s2)           StrCat(s1, s2, (ULONG)(-1))
#define STRCATN(s1,s2,n)        StrCat(s1, s2, (ULONG)(n))
#define STRCMP(s1,s2)           StrCmp(s1, s2, (ULONG)(-1), TRUE)
#define STRCMPI(s1,s2)          StrCmp(s1, s2, (ULONG)(-1), FALSE)
#define STRCMPN(s1,s2,n)        StrCmp(s1, s2, (ULONG)(n), TRUE)
#define STRCMPNI(s1,s2,n)       StrCmp(s1, s2, (ULONG)(n), FALSE)
#define STRCHR(s,c)             StrChr(s, c)
#define STRRCHR(s,c)            StrRChr(s, c)
#define STRTOK(s1,s2)           StrTok(s1, s2)
#define STRTOUL(s,pe,b)         StrToUL(s, pe, b)
#define STRTOL(s,pe,b)          StrToL(s, pe, b)
#define STRSTR(s1,s2)           StrStr(s1, s2)
#define STRUPR(s)               StrUpr(s)
#define STRLWR(s)               StrLwr(s)
#define ULTOA(d,s,r)            UlToA(d, s, r)
#define ISUPPER(c)              (((c) >= 'A') && ((c) <= 'Z'))
#define ISLOWER(c)              (((c) >= 'a') && ((c) <= 'z'))
#define ISALPHA(c)              (ISUPPER(c) || ISLOWER(c))
#define TOUPPER(c)              ((CHAR)(ISLOWER(c)? ((c) & 0xdf): (c)))
#define TOLOWER(c)              ((CHAR)(ISUPPER(c)? ((c) | 0x20): (c)))

/*** Exported function prototypes
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n);
PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n);
PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n);
LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase);
PSZ EXPORT StrChr(PSZ pszStr, CHAR c);
PSZ EXPORT StrRChr(PSZ pszStr, CHAR c);
PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep);
ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase);
LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase);
PSZ EXPORT StrStr(PSZ psz1, PSZ psz2);
PSZ EXPORT StrUpr(PSZ pszStr);
PSZ EXPORT StrLwr(PSZ pszStr);
PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix);

#endif  //ifndef _STRLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\inc\ospower.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ospower.h

Abstract:

    This contains the OS-shared power structures. These varify depending
    on the OS that is being used

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _OSPOWER_H_
#define _OSPOWER_H_

    //
    // Makesure that the _DEVICE_EXTENSION structure is defined
    //
    struct _DEVICE_EXTENSION;

    //
    // These are the flags that can used with the Power Device Node
    //
    #define DEVICE_NODE_PRESENT         0x0001
    #define DEVICE_NODE_INITIALIZED     0x0002
    #define DEVICE_NODE_STA_UNKNOWN     0x0004
    #define DEVICE_NODE_ON              0x0010
    #define DEVICE_NODE_OVERRIDE_ON     0x0020
    #define DEVICE_NODE_OVERRIDE_OFF    0x0040
    #define DEVICE_NODE_ALWAYS_ON       0x0200
    #define DEVICE_NODE_ALWAYS_OFF      0x0400

    //
    // These are fast macros
    //
    #define DEVICE_NODE_TURN_ON         (DEVICE_NODE_OVERRIDE_ON | DEVICE_NODE_ALWAYS_ON)
    #define DEVICE_NODE_TURN_OFF        (DEVICE_NODE_OVERRIDE_OFF | DEVICE_NODE_ALWAYS_OFF)

    //
    // These flags are more for status of the device node. Note that the
    // Hibernate Path flags requires special handling
    //
    #define DEVICE_NODE_FAIL            0x10000
    #define DEVICE_NODE_HIBERNATE_PATH  0x20000

    //
    // These are the various request flags for device requests
    //
    #define DEVICE_REQUEST_DELAYED              0x00000001
    #define DEVICE_REQUEST_NO_QUEUE             0x00000002
    #define DEVICE_REQUEST_LOCK_DEVICE          0x00000004
    #define DEVICE_REQUEST_UNLOCK_DEVICE        0x00000008
    #define DEVICE_REQUEST_LOCK_HIBER           0x00000010
    #define DEVICE_REQUEST_UNLOCK_HIBER         0x00000020
    #define DEVICE_REQUEST_HAS_CANCEL           0x00000040
    #define DEVICE_REQUEST_UPDATE_HW_PROFILE    0x00000080
    #define DEVICE_REQUEST_TO_SYNC_QUEUE        0x00000100

    //
    // These values are used with WorkDone variables and InterlockedXXX
    // functions to synchronize the various phases of DevicePowerManagement
    //
    typedef enum _WORK_DONE {
        WORK_DONE_COMPLETE = 0,
        WORK_DONE_PENDING,
        WORK_DONE_FAILURE,
        WORK_DONE_STEP_0,
        WORK_DONE_STEP_1,
        WORK_DONE_STEP_2,
        WORK_DONE_STEP_3,
        WORK_DONE_STEP_4,
        WORK_DONE_STEP_5,
        WORK_DONE_STEP_6,
        WORK_DONE_STEP_7,
        WORK_DONE_STEP_8,
        WORK_DONE_STEP_9,
        WORK_DONE_STEP_10,
        WORK_DONE_STEP_11,
        WORK_DONE_STEP_12,
        WORK_DONE_STEP_13,
        WORK_DONE_STEP_14,
        WORK_DONE_STEP_15,
        WORK_DONE_STEP_16,
        WORK_DONE_STEP_17,
        WORK_DONE_STEP_18,
        WORK_DONE_STEP_19,
        WORK_DONE_STEP_20,
        WORK_DONE_STEP_21,
        WORK_DONE_STEP_22,
        WORK_DONE_STEP_23,
        WORK_DONE_STEP_24,
        WORK_DONE_STEP_25,
        WORK_DONE_STEP_26,
    } WORK_DONE;

    //
    // This describes a single power device node
    //
    //     This used to be called a POWERDEVICEDEPENCIES
    //     but that was to hard to type out
    //
    typedef struct _ACPI_POWER_DEVICE_NODE {

        //
        // Keeps the things in order
        //
        LIST_ENTRY                      ListEntry;

        //
        // This define the current device state and flags
        //
        union{
            ULONGLONG                       Flags;
            struct {
                ULONGLONG                   Present:1;
                ULONGLONG                   Initialized:1;
                ULONGLONG                   StatusUnknown:1;
                ULONGLONG                   On:1;
                ULONGLONG                   OverrideOn:1;
                ULONGLONG                   OverrideOff:1;
                ULONGLONG                   AlwaysOn:1;
                ULONGLONG                   AlwaysOff:1;
                ULONGLONG                   Reserved1:5;
                ULONGLONG                   Failed:1;
                ULONGLONG                   HibernatePath:1;
                ULONGLONG                   Reserved2:49;
            } UFlags;
        };

        //
        // How many references there are to the node
        //
        ULONG                           UseCounts;

        //
        // The name space object associated with the power node
        //
        PNSOBJ                          PowerObject;

        //
        // The resource order
        //
        UCHAR                           ResourceOrder;

        //
        // The supported system level
        //
        SYSTEM_POWER_STATE              SystemLevel;

        //
        // This is the head of a list of DPNs that are associated with this
        // PDN
        //
        LIST_ENTRY                      DevicePowerListHead;

        //
        // This reflects the amount of work that has been done on the
        // DeviceNode
        //
        ULONG                           WorkDone;

        //
        // This is a pointer to the on function
        //
        PNSOBJ                          PowerOnObject;

        //
        // This is a pointer to the off function
        //
        PNSOBJ                          PowerOffObject;

        //
        // This is a pointer to the sta function
        //
        PNSOBJ                          PowerStaObject;

    } ACPI_POWER_DEVICE_NODE, *PACPI_POWER_DEVICE_NODE;

    //
    // This describes a single power node for a devices list of power reqs
    //
    //     This was known as a POWER_RES_LIST_NODE. Again that was a pain
    //     to type and it didn't quite do what I need it to do
    //
    typedef struct _ACPI_DEVICE_POWER_NODE {

        //
        // Contains pointer to next element
        //
        struct _ACPI_DEVICE_POWER_NODE  *Next;

        //
        // Pointer to actual power resource
        //
        PACPI_POWER_DEVICE_NODE         PowerNode;

        //
        // This is the system level that is supported for this node
        //
        SYSTEM_POWER_STATE              SystemState;

        //
        // This is the device power level of the device that this node
        // is associated with
        //
        DEVICE_POWER_STATE              AssociatedDeviceState;

        //
        // This determines if the Device Power Node is on the wake path
        // or not
        //
        BOOLEAN                         WakePowerResource;

        //
        // This is a pointer back to the DeviceExtension
        //
        struct _DEVICE_EXTENSION        *DeviceExtension;

        //
        // This is the list that is used to link all of the DPN attached
        // to a single PDN.
        //
        LIST_ENTRY                      DevicePowerListEntry;

    } ACPI_DEVICE_POWER_NODE, *PACPI_DEVICE_POWER_NODE;

    //
    // This callback is used for handling power requests which must be
    // processed through the main power DPC. Win9x does not use this
    // approach to power managament
    //
    typedef VOID ( *PACPI_POWER_CALLBACK )(PDEVICE_EXTENSION, PVOID, NTSTATUS);

    typedef enum {
        AcpiPowerRequestDevice = 0,
        AcpiPowerRequestSystem,
        AcpiPowerRequestWaitWake,
        AcpiPowerRequestWarmEject,
        AcpiPowerRequestSynchronize,
        AcpiPowerRequestMaximum
    } ACPI_POWER_REQUEST_TYPE;

    //
    // This is how we describe the power requests that we have outstanding
    // on a single device extension
    //
    typedef struct _ACPI_POWER_REQUEST {

        //
        // This is the ListEntry used to chain all the PowerRequests on
        // the same queue
        //
        LIST_ENTRY              ListEntry;

        //
        // This is the ListEntry used to chain all the PowerRequests on the
        // same device/irp. These requests are processed in serial
        //
        LIST_ENTRY              SerialListEntry;

        //
        // This is the signature block --- if this is not the value we expect,
        // then we assume the request is garbage
        //
        ULONG                   Signature;

        //
        // This is a pointer to the associated DeviceExtension
        //
        struct _DEVICE_EXTENSION    *DeviceExtension;

        //
        // This is the type of request
        //
        ACPI_POWER_REQUEST_TYPE RequestType;

        //
        // Has this request failed already?
        //
        BOOLEAN                 FailedOnce;

        //
        // Holds information about what we need to do for the various
        // requests
        //
        union {

            //
            // This is the Information required by a DevicePower request
            //
            struct {
                ULONG               Flags;
                DEVICE_POWER_STATE  DevicePowerState;
            } DevicePowerRequest;

            //
            // This is the Information required by a SystemPower request
            //
            struct {
                SYSTEM_POWER_STATE  SystemPowerState;
                POWER_ACTION        SystemPowerAction;
            } SystemPowerRequest;

            //
            // This is the Information required by a WaitWake request
            //
            struct {
                ULONG               Flags;
                SYSTEM_POWER_STATE  SystemPowerState;
            } WaitWakeRequest;

            //
            // This is the information required by the WarmEject request
            //
            struct {
                ULONG               Flags;
                SYSTEM_POWER_STATE  EjectPowerState;
            } EjectPowerRequest;

            //
            // This is the information required by the Synchronize request
            //
            struct {
                ULONG               Flags;
            } SynchronizePowerRequest;

            //
            // Make the flags easy to access...
            //
            struct {
                ULONG               Delayed:1;
                ULONG               NoQueue:1;
                ULONG               LockDevice:1;
                ULONG               UnlockDevice:1;
                ULONG               LockHiber:1;
                ULONG               UnlockHiber:1;
                ULONG               HasCancel:1;
                ULONG               UpdateProfile:1;
                ULONG               SyncQueue:1;
                ULONG               Reserved:23;
            } UFlags;

        } u;

        //
        // This is the routine that will get called when the request is
        // done
        //
        PACPI_POWER_CALLBACK        CallBack;

        //
        // This is the context that will be passed to the completion routine
        //
        PVOID                       Context;

        //
        // This defines the amount of work that has been done on the
        // request. This can only be touched with an InterlockedXXX call
        //
        ULONG                       WorkDone;

        //
        // This is the next value for WorkDone, if we have been successfull
        //
        ULONG                       NextWorkDone;

        //
        // Since we sometimes need to get data back from the interpreter,
        // we need some place to store that data
        //
        OBJDATA                     ResultData;

        //
        // This is the result of the request
        //
        NTSTATUS                    Status;

    } ACPI_POWER_REQUEST, *PACPI_POWER_REQUEST;

    //
    // Define the power information
    //
    //     This was known as a DEVICEPOWERDEPENDENCIES. But that
    //     was incredibly confusing and not quite suited to my needs
    //
    typedef struct _ACPI_POWER_INFO {

        //
        // Context is the OS object we are associated with, either a
        // device node or a device extension
        //
        PVOID                   Context;

        //
        // Current State of the device
        //
        DEVICE_POWER_STATE      PowerState;

        //
        // This is the notify callback (and context) for the current device
        //
        PDEVICE_NOTIFY_CALLBACK DeviceNotifyHandler;
        PVOID                   HandlerContext;

        //
        // This is an array of powerNodes, which point to Wake, D0, D1, and D2,
        // respectively
        //
        PACPI_DEVICE_POWER_NODE PowerNode[PowerDeviceD2+1];

        //
        // This is an array of PowerObjects, which represent _PS0 to _PS3
        // and _PRW
        //
        PNSOBJ                  PowerObject[PowerDeviceD3+1];

        //
        // This is the Enable bit for the GPE mask for Wake support
        //
        ULONG                   WakeBit;

        //
        // We want to remember the devices capabilities so that we can dump
        // it out at some later point in time.
        //
        DEVICE_POWER_STATE      DevicePowerMatrix[PowerSystemMaximum];

        //
        // This is the deepest sleep level that can used and at the same
        // time, have the device wake the system
        //
        SYSTEM_POWER_STATE      SystemWakeLevel;

        //
        // This is the deepest power level that the device can be in and
        // still wake up the system
        //
        DEVICE_POWER_STATE      DeviceWakeLevel;

        //
        // This is the current desired state of the device
        //
        DEVICE_POWER_STATE      DesiredPowerState;

        //
        // This keeps track of the number of times the device has
        // been enabled for Wake Support. On a 0-1 transition, we
        // must run _PSW(1). On a 1-0 transition, we must run _PSW(0).
        //
        ULONG                   WakeSupportCount;

        //
        // This is the list of pending _PSW calls
        //
        LIST_ENTRY              WakeSupportList;

        //
        // This is a pointer associated with the current PowerRequest
        //
        PACPI_POWER_REQUEST     CurrentPowerRequest;

        //
        // This is the queue that is used to link the PowerRequests associated
        // with this device. Note: that this list is *only* for DevicePower
        // requests with no associated Irps
        //
        LIST_ENTRY              PowerRequestListEntry;

        //
        // Remember what we support so that we can answer the QueryCapibilities
        //
        ULONG                   SupportDeviceD1   : 1;
        ULONG                   SupportDeviceD2   : 1;
        ULONG                   SupportWakeFromD0 : 1;
        ULONG                   SupportWakeFromD1 : 1;
        ULONG                   SupportWakeFromD2 : 1;
        ULONG                   SupportWakeFromD3 : 1;
        ULONG                   Reserved          :26;

    } ACPI_POWER_INFO, *PACPI_POWER_INFO;

    //
    // Find the power information for the given node
    //
    PACPI_POWER_INFO
    OSPowerFindPowerInfo(
        PNSOBJ  AcpiObject
        );

    PACPI_POWER_INFO
    OSPowerFindPowerInfoByContext(
        PVOID   Context
        );

    PACPI_POWER_DEVICE_NODE
    OSPowerFindPowerNode(
        PNSOBJ  PowerObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpiirp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpiirp.c

Abstract:

    This module contains routines for simplifying IRP handling

Author:

    Adrian J. Oney (AdriaO)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIIrpInvokeDispatchRoutine)
#pragma alloc_text(PAGE, ACPIIrpSetPagableCompletionRoutineAndForward)
#pragma alloc_text(PAGE, ACPIIrpCompletionRoutineWorker)
#endif

NTSTATUS
ACPIIrpInvokeDispatchRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled
    )
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status, returnStatus;

    PAGED_CODE();

    ACPIDebugEnter( "ACPIIrpInvokeDispatchRoutine" );

    //
    // Retrieve the status from the embedded IRP
    //
    status = Irp->IoStatus.Status;
    returnStatus = STATUS_NOT_SUPPORTED;

    //
    // And call the completion routine appropriately
    //

    if (NT_SUCCESS(status)) {

        if (InvokeOnSuccess) {

            returnStatus = CompletionRoutine(DeviceObject, Irp, Context, FALSE);
        }

    } else if (status == STATUS_NOT_SUPPORTED) {

        if (InvokeIfUnhandled) {

            returnStatus = CompletionRoutine(DeviceObject, Irp, Context, FALSE);
        }
    }

    if (deviceExtension->Flags & DEV_TYPE_PDO) {

        if (returnStatus != STATUS_PENDING) {

            if (returnStatus != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = returnStatus;
            } else {

                returnStatus = Irp->IoStatus.Status;
            }

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

    } else if (returnStatus != STATUS_PENDING) {

        if (returnStatus != STATUS_NOT_SUPPORTED) {

            Irp->IoStatus.Status = returnStatus;
        }

        if (NT_SUCCESS(returnStatus) || (returnStatus == STATUS_NOT_SUPPORTED)) {

            returnStatus = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );
        } else {

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }

    return returnStatus;

    ACPIDebugExit( "ACPIIrpInvokeDispatchRoutine" );
}

NTSTATUS
ACPIIrpSetPagableCompletionRoutineAndForward(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN PVOID                  Context,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled,
    IN BOOLEAN                InvokeOnError,
    IN BOOLEAN                InvokeOnCancel
    )
/*++

Routine Description:

    This routine handles an ACPI Filter Irp call. Irp count referencing is
    automatically taken care of.

Arguments:

    DeviceObject      - Pointer to the device object we received the request
                        for.
    Irp               - Pointer to the request
    CompletionRoutine - Routine to call after completion of the Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PACPI_IO_CONTEXT    pIoContext ;
    PIO_WORKITEM        pIoWorkItem ;

    PAGED_CODE() ;

    ACPIDebugEnter( "ACPIIrpSetPagableCompletionRoutineAndForward" );

    pIoContext = (PACPI_IO_CONTEXT) ExAllocatePool(
        NonPagedPool,
        sizeof(ACPI_IO_CONTEXT)
        );

    if (pIoContext == NULL) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    pIoWorkItem = IoAllocateWorkItem(DeviceObject);

    if (pIoWorkItem == NULL) {

        ExFreePool(pIoContext);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    pIoContext->CompletionRoutine  = CompletionRoutine ;
    pIoContext->DeviceObject       = DeviceObject ;
    pIoContext->Context            = Context ;
    pIoContext->InvokeOnSuccess    = InvokeOnSuccess ;
    pIoContext->InvokeIfUnhandled  = InvokeIfUnhandled ;
    pIoContext->InvokeOnError      = InvokeOnError ;
    pIoContext->InvokeOnCancel     = InvokeOnCancel ;
    pIoContext->Irp                = Irp ;
    pIoContext->IoWorkItem         = pIoWorkItem ;

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIIrpGenericFilterCompletionHandler,
        (PVOID) pIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending
    //
    IoMarkIrpPending(Irp);

    //
    // Send the request along
    //
    IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // We do this because we may change the status in the completion routine.
    //
    return STATUS_PENDING;

    ACPIDebugExit( "ACPIIrpSetPagableCompletionRoutineAndForward" );
}

NTSTATUS
ACPIIrpGenericFilterCompletionHandler(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    A rather generic "synchronize the IRP on this thread" completion routine.

Argument:

    DeviceObject       - Pointer to the device object we received the
                         request for
    Irp                - Pointer to the request
    Event              - Pointer to structure containing the Irp handlers

Return Value:

    NTSTATUS

--*/
{
    PACPI_IO_CONTEXT pIoContext = (PACPI_IO_CONTEXT) Context;

    ACPIDebugEnter( "ACPIIrpGenericFilterCompletionHandler" );

    if (Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {

        IoQueueWorkItem(
            pIoContext->IoWorkItem,
            ACPIIrpCompletionRoutineWorker,
            DelayedWorkQueue,
            pIoContext
            );

    } else {

        ACPIIrpCompletionRoutineWorker(DeviceObject, Context);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

    ACPIDebugExit( "ACPIIrpGenericFilterCompletionHandler" );
}

VOID
ACPIIrpCompletionRoutineWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )
{
    PACPI_IO_CONTEXT       pIoContext;
    PDEVICE_EXTENSION      deviceExtension;
    ACPICALLBACKROUTINE    completionRoutine;
    PIRP                   irp;
    NTSTATUS               status, returnStatus;
    PVOID                  context;

    PAGED_CODE();

    ACPIDebugEnter( "ACPIIrpCompletionRoutineWorker" );

    //
    // Read out fields from the device object
    //
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Cast the context and dig into it.
    //
    pIoContext = (PACPI_IO_CONTEXT) Context;
    completionRoutine   = pIoContext->CompletionRoutine;
    context             = pIoContext->Context;
    irp                 = pIoContext->Irp;

    //
    // Retrieve the status from the embedded IRP
    //
    status = irp->IoStatus.Status;
    returnStatus = STATUS_NOT_SUPPORTED;

    //
    // And call the completion routine appropriately
    //

    if (NT_SUCCESS(status)) {

        if (pIoContext->InvokeOnSuccess) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }

    } else if (status == STATUS_NOT_SUPPORTED) {

        if (pIoContext->InvokeIfUnhandled) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }

    } else {

        if ((pIoContext->InvokeOnError) ||
            (irp->Cancel && pIoContext->InvokeOnCancel)) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }
    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    IoFreeWorkItem(pIoContext->IoWorkItem);

    ExFreePool(pIoContext) ;

    if (returnStatus != STATUS_PENDING) {

        if (returnStatus != STATUS_NOT_SUPPORTED) {

            irp->IoStatus.Status = returnStatus;
        }

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    ACPIDebugExit( "ACPIIrpCompletionRoutineWorker" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\amlisupp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    amli.h

Abstract:

    This contains some of the routines to read
    and understand the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _AMLI_H_
    #define _AMLI_H_

#define ACPIAmliFreeDataBuffers AMLIFreeDataBuffs

#define PACKED_AC0  ((ULONG)'0CA_')
#define PACKED_AC1  ((ULONG)'1CA_')
#define PACKED_AC2  ((ULONG)'2CA_')
#define PACKED_AC3  ((ULONG)'3CA_')
#define PACKED_AC4  ((ULONG)'4CA_')
#define PACKED_AC5  ((ULONG)'5CA_')
#define PACKED_AC6  ((ULONG)'6CA_')
#define PACKED_AC7  ((ULONG)'7CA_')
#define PACKED_AC8  ((ULONG)'8CA_')
#define PACKED_AC9  ((ULONG)'9CA_')
#define PACKED_ADR  ((ULONG)'RDA_')
#define PACKED_AL0  ((ULONG)'0LA_')
#define PACKED_AL1  ((ULONG)'1LA_')
#define PACKED_AL2  ((ULONG)'2LA_')
#define PACKED_AL3  ((ULONG)'3LA_')
#define PACKED_AL4  ((ULONG)'4LA_')
#define PACKED_AL5  ((ULONG)'5LA_')
#define PACKED_AL6  ((ULONG)'6LA_')
#define PACKED_AL7  ((ULONG)'7LA_')
#define PACKED_AL8  ((ULONG)'8LA_')
#define PACKED_AL9  ((ULONG)'9LA_')
#define PACKED_BST  ((ULONG)'TSB_')
#define PACKED_CID  ((ULONG)'DIC_')
#define PACKED_CRS  ((ULONG)'SRC_')
#define PACKED_CRT  ((ULONG)'TRC_')
#define PACKED_DCK  ((ULONG)'KCD_')
#define PACKED_DDN  ((ULONG)'NDD_')
#define PACKED_DIS  ((ULONG)'SID_')
#define PACKED_EJD  ((ULONG)'DJE_')
#define PACKED_EJ0  ((ULONG)'0JE_')
#define PACKED_EJ1  ((ULONG)'1JE_')
#define PACKED_EJ2  ((ULONG)'2JE_')
#define PACKED_EJ3  ((ULONG)'3JE_')
#define PACKED_EJ4  ((ULONG)'4JE_')
#define PACKED_EJ5  ((ULONG)'5JE_')
#define PACKED_HID  ((ULONG)'DIH_')
#define PACKED_INI  ((ULONG)'INI_')
#define PACKED_IRC  ((ULONG)'CRI_')
#define PACKED_LCK  ((ULONG)'KCL_')
#define PACKED_LID  ((ULONG)'DIL_')
#define PACKED_OFF  ((ULONG)'FFO_')
#define PACKED_ON   ((ULONG)'_NO_')
#define PACKED_PR0  ((ULONG)'0RP_')
#define PACKED_PR1  ((ULONG)'1RP_')
#define PACKED_PR2  ((ULONG)'2RP_')
#define PACKED_PRS  ((ULONG)'SRP_')
#define PACKED_PRT  ((ULONG)'TRP_')
#define PACKED_PRW  ((ULONG)'WRP_')
#define PACKED_PS0  ((ULONG)'0SP_')
#define PACKED_PS1  ((ULONG)'1SP_')
#define PACKED_PS2  ((ULONG)'2SP_')
#define PACKED_PS3  ((ULONG)'3SP_')
#define PACKED_PSC  ((ULONG)'CSP_')
#define PACKED_PSL  ((ULONG)'LSP_')
#define PACKED_PSV  ((ULONG)'VSP_')
#define PACKED_PSW  ((ULONG)'WSP_')
#define PACKED_PTS  ((ULONG)'STP_')
#define PACKED_REG  ((ULONG)'GER_')
#define PACKED_RMV  ((ULONG)'VMR_')
#define PACKED_S0   ((ULONG)'_0S_')
#define PACKED_S0D  ((ULONG)'D0S_')
#define PACKED_S1   ((ULONG)'_1S_')
#define PACKED_S1D  ((ULONG)'D1S_')
#define PACKED_S2   ((ULONG)'_2S_')
#define PACKED_S2D  ((ULONG)'D2S_')
#define PACKED_S3   ((ULONG)'_3S_')
#define PACKED_S3D  ((ULONG)'D3S_')
#define PACKED_S4   ((ULONG)'_4S_')
#define PACKED_S4D  ((ULONG)'D4S_')
#define PACKED_S5   ((ULONG)'_5S_')
#define PACKED_S5D  ((ULONG)'D5S_')
#define PACKED_SCP  ((ULONG)'PCS_')
#define PACKED_SI   ((ULONG)'_IS_')
#define PACKED_SRS  ((ULONG)'SRS_')
#define PACKED_SST  ((ULONG)'TSS_')
#define PACKED_STA  ((ULONG)'ATS_')
#define PACKED_STD  ((ULONG)'DTS_')
#define PACKED_SUN  ((ULONG)'NUS_')
#define PACKED_SWD  ((ULONG)'DWS_')
#define PACKED_TC1  ((ULONG)'1CT_')
#define PACKED_TC2  ((ULONG)'2CT_')
#define PACKED_TMP  ((ULONG)'PMT_')
#define PACKED_TSP  ((ULONG)'PST_')
#define PACKED_UID  ((ULONG)'DIU_')
#define PACKED_WAK  ((ULONG)'KAW_')
#define PACKED_BBN  ((ULONG)'NBB_')

#define STA_STATUS_PRESENT          0x00000001
#define STA_STATUS_ENABLED          0x00000002
#define STA_STATUS_USER_INTERFACE   0x00000004
#define STA_STATUS_WORKING_OK       0x00000008
#define STA_STATUS_DEFAULT          ( STA_STATUS_PRESENT        | \
                                      STA_STATUS_ENABLED        | \
                                      STA_STATUS_USER_INTERFACE | \
                                      STA_STATUS_WORKING_OK)


typedef struct {
    PVOID   CompletionRoutine;
    PVOID   Context;
} AMLI_COMPLETION_CONTEXT, *PAMLI_COMPLETION_CONTEXT;

typedef struct {
    KEVENT      Event;
    NTSTATUS    Status;
} AMLISUPP_CONTEXT_PASSIVE, *PAMLISUPP_CONTEXT_PASSIVE;

typedef enum _ACPIENUM_CONTROL
  {
   ACPIENUM_STOP,
   ACPIENUM_CONTINUE,
   ACPIENUM_CONTINUE_NORECURSE
  } ACPIENUM_CONTROL ;

typedef ACPIENUM_CONTROL (*ACPIENUM_CALLBACK)(
   IN     PNSOBJ,
   IN OUT PVOID,
   IN     ULONG,
   OUT    NTSTATUS *
   ) ;

VOID
EXPORT
AmlisuppCompletePassive(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

VOID
ACPIAmliDoubleToName(
    IN  OUT PUCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    );

VOID
ACPIAmliDoubleToNameWide(
    IN  OUT PWCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    );

PNSOBJ
ACPIAmliGetNamedChild(
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   ObjectId
    );

PUCHAR
ACPIAmliNameObject(
    IN  PNSOBJ  AcpiObject
    );

VOID
EXPORT
ACPISimpleEvalComplete(
    IN  PNSOBJ              AcpiObject,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result OPTIONAL,
    IN  PKEVENT             Event
    );

NTSTATUS
ACPIAmliFindObject(
    IN  PUCHAR  ObjectName,
    IN  PNSOBJ  Scope,
    OUT PNSOBJ  *Object
    );

NTSTATUS
ACPIAmliGetFirstChild(
    IN  PUCHAR  ObjectName,
    OUT PNSOBJ  *Object
    );

NTSTATUS
ACPIAmliBuildObjectPathname(
    IN     PNSOBJ            ACPIObject,
    OUT    PUCHAR           *ConstructedPathName
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpiosnt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpiosnt.h

Abstract:

    This contains information that is specific to the NT ACPI module

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIOSNT_H_
#define _ACPIOSNT_H_

//
// Additonal status bits
//
#define PM1_GPE_PENDING     0x00010000
#define PM1_DPC_IN_PROGRESS 0x80000000

//
// Define the Maximum number of ACPI suffixes that we should try
//
#define ACPI_MAX_SUFFIX_LENGTH      99

typedef
VOID
(*PDEVICE_WORKER) (
    IN struct _DEVICE_EXTENSION    *DevExt,
    IN ULONG                        Events
    );

typedef struct {
    PDRIVER_DISPATCH        CreateClose;
    PDRIVER_DISPATCH        DeviceControl;
    PDRIVER_DISPATCH        PnpStartDevice;
    PDRIVER_DISPATCH        *Pnp;
    PDRIVER_DISPATCH        *Power;
    PDRIVER_DISPATCH        SystemControl;
    PDRIVER_DISPATCH        Other;
    PDEVICE_WORKER          Worker;
} IRP_DISPATCH_TABLE, *PIRP_DISPATCH_TABLE;

typedef struct {
    PUCHAR                  PnPId;
    PIRP_DISPATCH_TABLE     DispatchTable;
} INTERNAL_DEVICE_TABLE, *PINTERNAL_DEVICE_TABLE;

typedef struct {
    PUCHAR                  PnPId;
    ULONGLONG               Flags;
} INTERNAL_DEVICE_FLAG_TABLE, *PINTERNAL_DEVICE_FLAG_TABLE;

struct _DEVICE_EXTENSION ;
typedef struct _DEVICE_EXTENSION DEVICE_EXTENSION, *PDEVICE_EXTENSION ;

//
// Some bits to realize what state the device is in
//
typedef enum _ACPI_DEVICE_STATE {
    Stopped = 0,
    Inactive,
    Started,
    Removed,
    SurpriseRemoved,
    Invalid
} ACPI_DEVICE_STATE;

//
// For START_DEVICE's we want to drop from DISPATCH_LEVEL (the level that the
// Power Management Engine runs at) to PASSIVE_LEVEL so that we can either
// a) pass the irp along, or b) run some code was designed to run at passive
// level
//
typedef struct {

    //
    // Pointer to the work item that we will queue up.
    //
    WORK_QUEUE_ITEM Item;

    //
    // The device object --- we need to have a reference back to ourself
    //
    PDEVICE_OBJECT  DeviceObject;

    //
    // The Start Irp
    //
    PIRP            Irp;

} WORK_QUEUE_CONTEXT, *PWORK_QUEUE_CONTEXT;


typedef struct _FDO_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

    //
    // Location of our Interrupt Object
    //
    PKINTERRUPT         InterruptObject;

    //
    // Pending PM1 status bits which need handled
    //
    union {
        ULONG               Pm1Status;
        struct {
            ULONG           Tmr_Sts:1;
            ULONG           Reserved1:3;
            ULONG           Bm_Sts:1;
            ULONG           Gbl_Sts:1;
            ULONG           Reserved2:2;
            ULONG           PwrBtn_Sts:1;
            ULONG           SlpBtn_Sts:1;
            ULONG           Rtc_Sts:1;
            ULONG           Reserved3:4;
            ULONG           Wak_Sts:1;
            ULONG           Gpe_Sts:1;
            ULONG           Reserved4:14;
            ULONG           Dpc_Sts:1;
        } UPm1Status;
    };

    //
    // The storage for our DPC object
    //
    KDPC                InterruptDpc;

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;

typedef struct _PDO_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;

typedef struct _FILTER_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

    //
    // The interfaces that we kick out
    //
    PBUS_INTERFACE_STANDARD Interface;

} FILTER_DEVICE_EXTENSION, *PFILTER_DEVICE_EXTENSION;

//
// This is the structure that gets used when we want to pass events
// to and from the worker queue
//
typedef struct {
    ULONG               PendingEvents;
    LIST_ENTRY          Link;
} EXTENSION_WORKER, *PEXTENSION_WORKER;

//
// This is the extension that is used for button
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Lock to protect button accesses
    //
    KSPIN_LOCK          SpinLock;

    //
    // Current Lid State (Pushed or Not)
    //
    BOOLEAN             LidState;

    //
    // Current Events, Wake/Power/Sleep
    //
    union {
        ULONG               Events;
        struct {
            ULONG           Power_Button:1;
            ULONG           Sleep_Button:1;
            ULONG           Lid_Switch:1;
            ULONG           Reserved:28;
            ULONG           Wake_Capable:1;
        } UEvents;
    };

    //
    // What the button is capable of reporting
    //
    union {
        ULONG               Capabilities;
        struct {
            ULONG           Power_Button:1;
            ULONG           Sleep_Button:1;
            ULONG           Lid_Switch:1;
            ULONG           Reserved:28;
            ULONG           Wake_Capable:1;
        } UCapabilities;
    };

} BUTTON_EXTENSION, *PBUTTON_EXTENSION;

//
// This is the structure that is used for Thermal Zones
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Lock to protect thermal zone accesses
    //
    KSPIN_LOCK          SpinLock;

    //
    // Current State of the thermal zone
    //
    union {
        ULONG               Flags;
        struct {
            ULONG           Cooling:1;
            ULONG           Temp:1;
            ULONG           Trip:1;
            ULONG           Mode:1;
            ULONG           Init:1;
            ULONG           Reserved:24;
            ULONG           Wait:1;
            ULONG           Busy:1;
            ULONG           Loop:1;
        } UFlags;
    };

    //
    // Points to the Thermal Information Structure that contains the real
    // information
    //
    PVOID               Info;

    //
    // WMI Context Information Pointer
    //
    PWMILIB_CONTEXT     WmilibContext;

} THERMAL_EXTENSION, *PTHERMAL_EXTENSION;

//
// This is the structure that is used for Link Nodes
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;      // must be first

    //
    // To quickly allow the link nodes to be searched, they are linked together
    // regardless of their real location in the tree
    //
    LIST_ENTRY          List;

    //
    // Usage count on the link nodes
    //
    ULONG               ReferenceCount;

    //
    // Working reference count
    //
    LONG                TempRefCount;
    PNSOBJ              NameSpaceObject;    // Obsolete

    //
    // The IRQ that the link node is using
    //
    ULONGLONG           CurrentIrq;

    //
    // State flags - Shared/Exclusive, Level/Edge
    //
    UCHAR               Flags;

} LINK_NODE_EXTENSION, *PLINK_NODE_EXTENSION;

//
// This enum covers the various states of a _DCK device.
//
typedef enum {

    IS_UNKNOWN,
    IS_ISOLATED,
    IS_ISOLATION_DROPPED

} ISOLATION_STATE, *PISOLATION_STATE;

//
// This is the structure that is used for Dock's
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER            WorkQueue;

    //
    // This is the corresponding ACPI extension for the device
    //
    PDEVICE_EXTENSION           CorrospondingAcpiDevice;

    //
    // This is how (or more properly when) to handle profile changes
    //
    PROFILE_DEPARTURE_STYLE     ProfileDepartureStyle;

    //
    // Reference count for the dock interface
    //
    ULONG                       InterfaceReferenceCount;

    //
    // Current state of isolation.
    //
    ISOLATION_STATE             IsolationState;

} DOCK_EXTENSION, *PDOCK_EXTENSION;

typedef struct _PROCESSOR_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Points to the Compatible ID of the device
    //
    PUCHAR              CompatibleID;

    //
    // This is the index in the ProcessorList for this processor
    //
    ULONG               ProcessorIndex;

} PROCESSOR_DEVICE_EXTENSION, *PPROCESSOR_DEVICE_EXTENSION;

//
// The Device Extension Structure
//
struct _DEVICE_EXTENSION {

    //
    // Common flags
    //
    union {

        //
        // Make sure that these two elements stay in sync
        //
        ULONGLONG           Flags;
        struct {
            ULONGLONG   Type_Never_Present:1;
            ULONGLONG   Type_Not_Present:1;
            ULONGLONG   Type_Removed:1;
            ULONGLONG   Type_Not_Found:1;
            ULONGLONG   Type_Fdo:1;
            ULONGLONG   Type_Pdo:1;
            ULONGLONG   Type_Filter:1;
            ULONGLONG   Type_Surprise_Removed:1;
            ULONGLONG   