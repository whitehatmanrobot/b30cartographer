t,
    IN PVCB Vcb,
    IN BOOLEAN UpdateWithinTransaction
    )

/*++

Routine Description:

    This routine may be called any time the Mft is open to mark the volume
    dirty.

Arguments:

    Vcb - Vcb for volume to mark dirty

    UpdateWithinTransaction - Use TRUE if it is safe to log this operation.

Return Value:

    None

--*/

{
    PAGED_CODE();

#if ((DBG || defined( NTFS_FREE_ASSERTS )) && !defined( LFS_CLUSTER_CHECK ))
    KdPrint(("NTFS: Marking volume dirty, Vcb: %08lx\n", Vcb));
    if (NtfsBreakOnCorrupt) {
        KdPrint(("NTFS: Marking volume dirty\n", 0));
        DbgBreakPoint();
    }
#endif

    //
    //  Return if the volume is already marked dirty.  This also prevents
    //  endless recursion if the volume file itself is corrupt.
    //  Noop if the volume was mounted read only.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY) ||
       (FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ))) {

        return;
    }

    SetFlag(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY);

    NtfsSetVolumeInfoFlagState( IrpContext,
                                Vcb,
                                VOLUME_DIRTY,
                                TRUE,
                                UpdateWithinTransaction );

    //
    //  If this is chkdsk marking the volume dirty, let's not scare
    //  the user by putting a 'volume corrupt' message in the log.
    //  If an exception has occured, we want to log the event regardless.
    //

    if ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
        (IrpContext->MinorFunction != IRP_MN_USER_FS_REQUEST) ||
        (IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->Parameters.FileSystemControl.FsControlCode
                                   != FSCTL_MARK_VOLUME_DIRTY) ||
        (IrpContext->ExceptionStatus != 0)) {

        NtfsLogEvent( IrpContext,
                      NULL,
                      IO_FILE_SYSTEM_CORRUPT_WITH_NAME,
                      STATUS_DISK_CORRUPT_ERROR );
    }
}


VOID
NtfsSetVolumeInfoFlagState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FlagsToSet,
    IN BOOLEAN NewState,
    IN BOOLEAN UpdateWithinTransaction
    )

/*++

Routine Description:

    This routine sets or clears one or more bits in the given vcb's
    volume information.

Arguments:

    Vcb - Vcb for volume.

    FlagsToSet - The bit(s) to set or clear.

    NewState - Use TRUE to set the given bit(s), or FALSE to clear them.

    UpdateWithinTransaction - Use TRUE if this flag change should be done
                              inside a transaction.

Return Value:

    None

--*/

{
    LONGLONG Offset;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG RecordOffset;
    ULONG AttributeOffset;
    BOOLEAN CleanupAttributeContext = TRUE;

    //
    //  If we don't have the VolumeDasdScb open yet, we can't do anything,
    //  so we need to exit gracefully now.
    //

    if ((Vcb == NULL) ||
        (Vcb->VolumeDasdScb == NULL)) {

        ASSERTMSG( "Attempting to set volume info flag state for a non-mounted volume", FALSE );
        return;
    }

    NtfsInitializeAttributeContext( &AttributeContext );

    try {

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {
            VolumeInformation =
              (PVOLUME_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            NtfsPinMappedAttribute( IrpContext, Vcb, &AttributeContext );

            //
            //  Extract the relevant pointers and calculate offsets.
            //

            FileRecord = NtfsContainingFileRecord(&AttributeContext);
            Attribute = NtfsFoundAttribute(&AttributeContext);
            Offset = PtrOffset(VolumeInformation, &VolumeInformation->VolumeFlags);
            RecordOffset = PtrOffset(FileRecord, Attribute);
            AttributeOffset = Attribute->Form.Resident.ValueOffset + (ULONG)Offset;

            if (NewState) {

                SetFlag( VolumeInformation->VolumeFlags, FlagsToSet );

            } else {

                ClearFlag( VolumeInformation->VolumeFlags, FlagsToSet );
            }

            if (UpdateWithinTransaction) {

                //
                //  Log the change while we still have the old data.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb(&AttributeContext),
                              UpdateResidentValue,
                              &(VolumeInformation->VolumeFlags),
                              sizeof(VolumeInformation->VolumeFlags),
                              UpdateResidentValue,
                              Add2Ptr(Attribute, Attribute->Form.Resident.ValueOffset + (ULONG)Offset),
                              sizeof(VolumeInformation->VolumeFlags),
                              NtfsMftOffset(&AttributeContext),
                              RecordOffset,
                              AttributeOffset,
                              Vcb->BytesPerFileRecordSegment );
            }

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    &(VolumeInformation->VolumeFlags),
                                    sizeof(VolumeInformation->VolumeFlags),
                                    FALSE );

            //
            //  If this is not a transaction then mark the page dirty and flush
            //  this to disk.
            //

            if (!UpdateWithinTransaction) {

                LONGLONG MftOffset = NtfsMftOffset( &AttributeContext );

                CcSetDirtyPinnedData( NtfsFoundBcb( &AttributeContext ), NULL );
                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
                CleanupAttributeContext = FALSE;
                CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &MftOffset,
                              Vcb->BytesPerFileRecordSegment,
                              NULL );
            }

        }

    } finally {

        if (CleanupAttributeContext) {
            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }
}



BOOLEAN
NtfsUpdateVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR DiskMajorVersion,
    IN UCHAR DiskMinorVersion
    )
/*++

Routine Description:

    This routine is called to update the volume information on disk. This includes
    version numbers, and last mounted version   Disk versions are only updated if they
    are greater than the on disk ones.

Arguments:

    Vcb - Vcb for volume.

    DiskMajorVersion - This is the Major Version number for the on disk format.

    DiskMinorVersion - This is the Minor Version number for the on disk format.

Return Value:

    TRUE if disk version was updated

--*/
{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;
    PATTRIBUTE_RECORD_HEADER Attribute;
    VOLUME_INFORMATION NewVolumeInformation;
    BOOLEAN UpdatedVersion = TRUE;
    ULONG VolInfoSize;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttributeContext );

    try {

        //
        //  Lookup the volume information attribute.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {

            Attribute = NtfsFoundAttribute(&AttributeContext);

            ASSERT( Attribute->FormCode == RESIDENT_FORM );

            VolumeInformation =
              (PVOLUME_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            NtfsPinMappedAttribute( IrpContext, Vcb, &AttributeContext );

            RtlCopyMemory( &NewVolumeInformation, VolumeInformation, Attribute->Form.Resident.ValueLength );

            if (NewVolumeInformation.MajorVersion < DiskMajorVersion) {
                NewVolumeInformation.MajorVersion = DiskMajorVersion;
                NewVolumeInformation.MinorVersion = DiskMinorVersion;
                Vcb->MajorVersion = DiskMajorVersion;
                Vcb->MinorVersion = DiskMinorVersion;
            } else if (NewVolumeInformation.MinorVersion < DiskMinorVersion) {
                NewVolumeInformation.MinorVersion = DiskMinorVersion;
                Vcb->MinorVersion = DiskMinorVersion;
            } else {
                UpdatedVersion = FALSE;
            }

            //
            //  We can use the new volinfo for version 4 and greater
            //

            if (DiskMajorVersion > 3) {

#ifdef BENL_DBG
                KdPrint(( "NTFS: new volinfo for version 4+\n" ));
#endif

                NewVolumeInformation.LastMountedMajorVersion = DiskMajorVersion;
                NewVolumeInformation.LastMountedMinorVersion = DiskMinorVersion;

                VolInfoSize = sizeof( VOLUME_INFORMATION );
                UpdatedVersion = TRUE;
            } else {
                VolInfoSize = FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion );
            }

            if (UpdatedVersion) {
                NtfsChangeAttributeValue( IrpContext, Vcb->VolumeDasdScb->Fcb, 0, &NewVolumeInformation, VolInfoSize, TRUE, FALSE, FALSE, TRUE, &AttributeContext );
            }
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    return UpdatedVersion;
}


//
//  Local support routine
//

NTSTATUS
NtfsVerifyReadCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    //  If we change this return value then NtfsIoCallSelf needs to reference the
    //  file object.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\viewsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ViewSup.c

Abstract:

    This module implements the Index management routines for NtOfs

Author:

    Tom Miller      [TomM]          5-Jan-1996

Revision History:

--*/

#include "NtfsProc.h"
#include "Index.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VIEWSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('vFtN')

//
//  Temporary definitions for test
//

BOOLEAN NtOfsDoIndexTest = TRUE;
BOOLEAN NtOfsLeaveTestIndex = FALSE;
extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//  Define a context for NtOfsReadRecords, which is primarily an IndexContext
//  and a copy of the last Key returned.
//

typedef struct _READ_CONTEXT {

    //
    //  IndexContext (cursor) for the enumeration.
    //

    INDEX_CONTEXT IndexContext;

    //
    //  The last key returned is allocated from paged pool.  We have to
    //  separately record how much is allocated, and how long the current
    //  key is using, the latter being in the KeyLength field of IndexKey.
    //  SmallKeyBuffer will store a small key in this structure without going
    //  to pool.
    //

    INDEX_KEY LastReturnedKey;
    ULONG AllocatedKeyLength;
    ULONG SmallKeyBuffer[3];

} READ_CONTEXT, *PREAD_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsQueryViewIndex)
#pragma alloc_text(PAGE, NtOfsCreateIndex)
#pragma alloc_text(PAGE, NtOfsCloseIndex)
#pragma alloc_text(PAGE, NtOfsDeleteIndex)
#pragma alloc_text(PAGE, NtOfsFindRecord)
#pragma alloc_text(PAGE, NtOfsAddRecords)
#pragma alloc_text(PAGE, NtOfsDeleteRecords)
#pragma alloc_text(PAGE, NtOfsUpdateRecord)
#pragma alloc_text(PAGE, NtOfsReadRecords)
#pragma alloc_text(PAGE, NtOfsFreeReadContext)
#pragma alloc_text(PAGE, NtOfsFindLastRecord)
#pragma alloc_text(PAGE, NtOfsCollateUlong)
#pragma alloc_text(PAGE, NtOfsCollateUlongs)
#pragma alloc_text(PAGE, NtOfsCollateUnicode)
#pragma alloc_text(PAGE, NtOfsMatchAll)
#pragma alloc_text(PAGE, NtOfsMatchUlongExact)
#pragma alloc_text(PAGE, NtOfsMatchUlongsExact)
#pragma alloc_text(PAGE, NtOfsMatchUnicodeExpression)
#pragma alloc_text(PAGE, NtOfsMatchUnicodeString)
#pragma alloc_text(PAGE, NtOfsCollateSid)
#endif


NTFSAPI
NTSTATUS
NtOfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG DeleteCollationData,
    IN ULONG CollationRule,
    IN PCOLLATION_FUNCTION CollationFunction,
    IN PVOID CollationData OPTIONAL,
    OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine may be called to create / open a view index
    within a given file for a given CollationRule.

Arguments:

    Fcb - File in which the index is to be created.

    Name - Name of the index for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    DeleteCollationData - Specifies 1 if the NtfsFreePool should be called
                          for CollationData when no longer required, or 0
                          if NtfsFreePool should never be called.

    CollationRule - A binary code to store in the index root to convey the
                    collation function to ChkDsk.  These rules are defined
                    in ntfs.h, and must have a one-to-one correspondence with
                    the CollationFunction below.

    CollationFunction - Function to be called to collate the index.

    CollationData - Data pointer to be passed to CollationFunction.

    Scb - Returns an Scb as handle for the index.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and index already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and index does not exist

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;
    NTSTATUS Status = STATUS_SUCCESS;
    PBCB FileRecordBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileRecordOffset;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY EndEntry;
    } R;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  First we will initialize the Index Root structure which is the value
    //  of the attribute we need to create.
    //

    RtlZeroMemory( &R, sizeof(R) );

    R.IndexRoot.CollationRule = CollationRule;
    R.IndexRoot.BytesPerIndexBuffer = NTOFS_VIEW_INDEX_BUFFER_SIZE;

    R.IndexRoot.BlocksPerIndexBuffer = (UCHAR)ClustersFromBytes( Fcb->Vcb,
                                                                   NTOFS_VIEW_INDEX_BUFFER_SIZE );

    if (NTOFS_VIEW_INDEX_BUFFER_SIZE < Fcb->Vcb->BytesPerCluster) {

        R.IndexRoot.BlocksPerIndexBuffer = NTOFS_VIEW_INDEX_BUFFER_SIZE / DEFAULT_INDEX_BLOCK_SIZE;
    }

    R.IndexRoot.IndexHeader.FirstIndexEntry = QuadAlign(sizeof(INDEX_HEADER));
    R.IndexRoot.IndexHeader.FirstFreeByte =
    R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                             QuadAlign(sizeof(INDEX_ENTRY));

    //
    //  Now we need to put in the special End entry.
    //

    R.EndEntry.Length = sizeof(INDEX_ENTRY);
    SetFlag( R.EndEntry.Flags, INDEX_ENTRY_END );


    //
    //  Now, just create the Index Root Attribute.
    //

    NtfsInitializeAttributeContext( &LocalContext );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  First see if the index already exists, by searching for the root
        //  attribute.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    $INDEX_ROOT,
                                                    &Name,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If it is not there, and the CreateOptions allow, then let's create
        //  the index root now.  (First cleaning up the attribute context from
        //  the lookup).
        //

        if (!FoundAttribute && (CreateOptions <= CREATE_OR_OPEN)) {

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $INDEX_ROOT,
                                          &Name,
                                          &R,
                                          sizeof(R),
                                          0,
                                          NULL,
                                          TRUE,
                                          &LocalContext );

        //
        //  If the index is already there, and we were asked to create it, then
        //  return an error.
        //

        } else if (FoundAttribute && (CreateOptions == CREATE_NEW)) {

            try_return( Status = STATUS_OBJECT_NAME_COLLISION );

        //
        //  If the index is not there, and we  were supposed to open existing, then
        //  return an error.
        //

        } else if (!FoundAttribute && (CreateOptions == OPEN_EXISTING)) {

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        //
        //  Otherwise create/find the Scb and reference it.
        //

        *Scb = NtfsCreateScb( IrpContext, Fcb, $INDEX_ALLOCATION, &Name, FALSE, NULL );
        SetFlag( (*Scb)->ScbState, SCB_STATE_VIEW_INDEX );
        (*Scb)->ScbType.Index.CollationFunction = CollationFunction;

        //
        //  Handle the case where CollationData is to be deleted.
        //

        if (DeleteCollationData) {
            SetFlag((*Scb)->ScbState, SCB_STATE_DELETE_COLLATION_DATA);
            if ((*Scb)->ScbType.Index.CollationData != NULL) {
                NtfsFreePool(CollationData);
            } else {
                (*Scb)->ScbType.Index.CollationData = CollationData;
            }

        //
        //  Otherwise just jam the pointer the caller passed.
        //

        } else {
            (*Scb)->ScbType.Index.CollationData = CollationData;
        }

        NtfsIncrementCloseCounts( *Scb, TRUE, FALSE );

        //
        //  We have to set the view index present bit, so read it, save the
        //  old data and set the flag here.
        //

        NtfsPinMftRecord( IrpContext,
                          Fcb->Vcb,
                          &Fcb->FileReference,
                          FALSE,
                          &FileRecordBcb,
                          &FileRecord,
                          &FileRecordOffset );

        //
        //  If necessary, set the flag to indicate that this file will have
        //  no unnamed data stream and any attempt to open this file without
        //  specifying a named stream will fail, but without marking the
        //  volume corrupt.
        //

        if (!FlagOn( FileRecord->Flags, FILE_VIEW_INDEX_PRESENT )) {

            //
            //  We have to be very careful when using the InitialzeFileRecordSegment
            //  log record.  This action is applied unconditionally.  DoAction doesn't
            //  check the previous LSN in the page.  It may be garbage on a newly initialized
            //  file record.  We log the entire file record to avoid the case where we
            //  might overwrite a later Lsn with this earlier Lsn during restart.
            //

            //
            //  Log the existing file record as the undo action.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Fcb->Vcb->MftScb,
                                            FileRecordBcb,
                                            Noop,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Fcb->Vcb->BytesPerFileRecordSegment );

            SetFlag( FileRecord->Flags, FILE_VIEW_INDEX_PRESENT );

            //
            //  Log the new file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Fcb->Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Fcb->Vcb->BytesPerFileRecordSegment );
        }

    try_exit: NOTHING;

    } finally {
        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    return Status;
}


NTFSAPI
VOID
NtOfsCloseIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to close a previously returned handle on a view index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

Return Value:

    None.

--*/

{
    ASSERT( NtfsIsExclusiveFcb( Scb->Fcb ));

    NtfsDecrementCloseCounts( IrpContext, Scb, NULL, TRUE, FALSE, FALSE );
}


NTFSAPI
VOID
NtOfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to delete an index.

Arguments:

    Fcb - Supplies an Fcb as the previously returned object handle for the file

    Scb - Supplies an Scb as the previously returned handle for this index.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT(($BITMAP - $INDEX_ALLOCATION) == ($INDEX_ALLOCATION - $INDEX_ROOT));

    PAGED_CODE();

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  First see if there is some index allocation, and if so truncate it
        //  away allowing this operation to be broken up.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $INDEX_ALLOCATION,
                                       &Scb->AttributeName,
                                       NULL,
                                       FALSE,
                                       &LocalContext )) {

            NtfsCreateInternalAttributeStream( IrpContext, Scb, TRUE, NULL );

            NtfsDeleteAllocation( IrpContext, NULL, Scb, 0, MAXLONGLONG, TRUE, TRUE );
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        for (AttributeTypeCode = $INDEX_ROOT;
             AttributeTypeCode <= $BITMAP;
             AttributeTypeCode += ($INDEX_ALLOCATION - $INDEX_ROOT)) {

            //
            //  Initialize the attribute context on each trip through the loop.
            //

            NtfsInitializeAttributeContext( &LocalContext );

            //
            //  First see if the index already exists, by searching for the root
            //  attribute.
            //

            FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        AttributeTypeCode,
                                                        &Scb->AttributeName,
                                                        NULL,
                                                        TRUE,
                                                        &LocalContext );

            //
            //  Loop while we see the right records.
            //

            while (FoundAttribute) {

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &LocalContext );

                FoundAttribute = NtfsLookupNextAttributeByName( IrpContext,
                                                                Fcb,
                                                                AttributeTypeCode,
                                                                &Scb->AttributeName,
                                                                TRUE,
                                                                &LocalContext );
            }

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );
        }

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
NTSTATUS
NtOfsFindRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_KEY IndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to find the first occurrence of a key in an index,
    and return cached information which may can accelerate the update on the data
    for that key if the index buffer is not changed.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    IndexKey - Supplies the key to find.

    IndexRow - Returns a description of the Key and Data *in place*, for read-only
               access, valid only until the Bcb is unpinned.  (Neither key nor
               data may be modified in place!)

    MapHandle - Returns a map handle for accessing the key and data directly.

    QuickIndexHint - Supplies a previously returned hint, or all zeros on first use.
                     Returns location information which may be held an arbitrary
                     amount of time, which can accelerate a subsequent call to
                     NtOfsUpdateRecord for the data in this key, iff changes to
                     the index do not prohibit use of this hint.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if the specified key does not exist.

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ENTRY IndexEntry;
    NTSTATUS Status;
    PQUICK_INDEX QuickIndex = (PQUICK_INDEX)QuickIndexHint;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    NtfsInitializeIndexContext( &IndexContext );

    ASSERT_SHARED_SCB( Scb );

    try {

        //
        //  Use the second location in the index context to perform the
        //  read.
        //

        Sp =
        IndexContext.Current = IndexContext.Base + 1;

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer (BufferOffset test)
        //      - The index stream may not have been truncated (ChangeCount test)
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndexHint ) &&
            (QuickIndex->BufferOffset != 0) &&
            (QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount)) {

            ReadIndexBuffer( IrpContext,
                             Scb,
                             QuickIndex->IndexBlock,
                             FALSE,
                             Sp );

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                Sp->IndexEntry = (PINDEX_ENTRY) Add2Ptr( Sp->StartOfBuffer,
                                                         QuickIndex->BufferOffset );

            //
            //  Otherwise we need to reinitialize the index context and take
            //  the long path below.
            //

            } else {

                NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            }
        }

        //
        //  If we did not get the index entry via the hint, get it now.
        //

        if (Sp->Bcb == NULL) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 IndexKey,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (!FindNextIndexEntry( IrpContext,
                                     Scb,
                                     IndexKey,
                                     FALSE,
                                     FALSE,
                                     &IndexContext,
                                     FALSE,
                                     NULL )) {

                try_return( Status = STATUS_NO_MATCH );
            }
        }

        //
        //  Basic consistency check
        //

        IndexEntry = IndexContext.Current->IndexEntry;
        if ((IndexEntry->DataOffset + IndexEntry->DataLength > IndexEntry->Length) ||
            (IndexEntry->AttributeLength + sizeof( INDEX_ENTRY ) > IndexEntry->Length)) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }


        //
        //  If we found the key in the base, then return the Bcb from the
        //  attribute context and return no hint (BufferOffset = 0).
        //

        if (IndexContext.Current == IndexContext.Base) {

            MapHandle->Buffer = NULL;
            MapHandle->Bcb = NtfsFoundBcb(&IndexContext.AttributeContext);
            NtfsFoundBcb(&IndexContext.AttributeContext) = NULL;

            if (ARGUMENT_PRESENT( QuickIndexHint )) {
                QuickIndex->BufferOffset = 0;
            }

        //
        //  If we found the key in an index buffer, then return the Bcb from
        //  the lookup stack, and record the hint for the caller.
        //

        } else {

            Sp = IndexContext.Current;

            MapHandle->Buffer = Sp->StartOfBuffer;
            MapHandle->Bcb = Sp->Bcb;
            Sp->Bcb = NULL;

            if (ARGUMENT_PRESENT( QuickIndexHint )) {
                QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
            }
        }

        //
        //  Complete the MapHandle to disallow pinning.
        //

        MapHandle->FileOffset = MAXLONGLONG;
        MapHandle->Length = MAXULONG;

        //
        //  Return the IndexRow described directly in the buffer.
        //

        IndexRow->KeyPart.Key = (IndexEntry + 1);
        IndexRow->KeyPart.KeyLength = IndexEntry->AttributeLength;
        IndexRow->DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
        IndexRow->DataPart.DataLength = IndexEntry->DataLength;

    try_exit: NOTHING;

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

    }

    return Status;
}


NTFSAPI
NTSTATUS
NtOfsFindLastRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_KEY MaxIndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    This routine may be called to find the highest key in an index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    MaxIndexKey - Supplies the maximum possible key value (such as MAXULONG, etc.),
                  and this key must not actually be in use!

    IndexRow - Returns a description of the Key and Data *in place*, for read-only
               access, valid only until the Bcb is unpinned.  (Neither key nor
               data may be modified in place!)

    MapHandle - Returns a map handle for accessing the key and data directly.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if the specified key does not exist (index is empty).

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ENTRY IndexEntry, NextIndexEntry;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Slide down the "right" side of the tree.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             MaxIndexKey,
                             &IndexContext );

        //
        //  If this happens, the index must be empty.
        //

        Sp = IndexContext.Current;
        IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        if (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {
            try_return( Status = STATUS_NO_MATCH );
        }

        //
        //  If we found the key in the base, then return the Bcb from the
        //  attribute context and return no hint (BufferOffset = 0).
        //

        if (IndexContext.Current == IndexContext.Base) {

            MapHandle->Bcb = NtfsFoundBcb(&IndexContext.AttributeContext);
            NtfsFoundBcb(&IndexContext.AttributeContext) = NULL;

        //
        //  If we found the key in an index buffer, then return the Bcb from
        //  the lookup stack, and record the hint for the caller.
        //

        } else {


            MapHandle->Bcb = Sp->Bcb;
            Sp->Bcb = NULL;
        }

        //
        //  Complete the MapHandle to disallow pinning.
        //

        MapHandle->FileOffset = MAXLONGLONG;
        MapHandle->Length = MAXULONG;
        MapHandle->Buffer = NULL;

        //
        //  Now rescan the last buffer to return the second to last index entry,
        //  if there is one.
        //

        NextIndexEntry = IndexEntry;
        do {
            IndexEntry = NextIndexEntry;

            if (IndexEntry->Length == 0) {
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
            NextIndexEntry = NtfsNextIndexEntry(IndexEntry);
            NtfsCheckIndexBound( NextIndexEntry, Sp->IndexHeader );

        } while (!FlagOn(NextIndexEntry->Flags, INDEX_ENTRY_END));

        //
        //  Return the IndexRow described directly in the buffer.
        //

        IndexRow->KeyPart.Key = (IndexEntry + 1);
        IndexRow->KeyPart.KeyLength = IndexEntry->AttributeLength;
        IndexRow->DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
        IndexRow->DataPart.DataLength = IndexEntry->DataLength;

    try_exit: NOTHING;

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }

    return Status;
}


NTFSAPI
VOID
NtOfsAddRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN ULONG SequentialInsertMode
    )

/*++

Routine Description:

    This routine may be called to add one or more records to an index.

    If SequentialInsertMode is nonzero, this is a hint to the index package
    to keep all BTree buffers as full as possible, by splitting as close to
    the end of the buffer as possible.  If specified as zero, random inserts
    are assumed, and buffers are always split in the middle for better balance.


Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the number of records being added.

    IndexRow - Supplies an array of Count entries, containing the Keys and Data to add.

    SequentialInsertMode - If specified as nozero, the implementation may choose to
                           split all index buffers at the end for maximum fill.

Return Value:

    None.

Raises:

    STATUS_DUPLICATE_NAME -- if the specified key already exists.

--*/

{
    INDEX_CONTEXT IndexContext;
    struct {
        INDEX_ENTRY IndexEntry;
        PVOID Key;
        PVOID Data;
    } IE;
    ULONG i;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    UNREFERENCED_PARAMETER(SequentialInsertMode);

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Loop to add all entries
        //

        for (i = 0; i < Count; i++) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 &IndexRow->KeyPart,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    &IndexRow->KeyPart,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                NtfsRaiseStatus( IrpContext, STATUS_DUPLICATE_NAME, NULL, NULL );
            }

            //
            //  Initialize the Index Entry in pointer form.
            //
            //  Note that the final index entry ends up looking like this:
            //
            //      (IndexEntry)(Key)(Data)
            //
            //  where all fields are long-aligned and:
            //
            //      Key is at IndexEntry + sizeof(INDEX_ENTRY), and of length AttributeLength
            //      Data is at IndexEntry + DataOffset and of length DataLength
            //

            IE.IndexEntry.AttributeLength = (USHORT)IndexRow->KeyPart.KeyLength;

            IE.IndexEntry.DataOffset = (USHORT)(sizeof(INDEX_ENTRY) + LongAlign( IndexRow->KeyPart.KeyLength ));

            IE.IndexEntry.DataLength = (USHORT)IndexRow->DataPart.DataLength;
            IE.IndexEntry.ReservedForZero = 0;

            IE.IndexEntry.Length = (USHORT)(QuadAlign(IE.IndexEntry.DataOffset + IndexRow->DataPart.DataLength));

            IE.IndexEntry.Flags = INDEX_ENTRY_POINTER_FORM;
            IE.IndexEntry.Reserved = 0;
            IE.Key = IndexRow->KeyPart.Key;
            IE.Data = IndexRow->DataPart.Data;

            //
            //  Now add it to the index.  We can only add to a leaf, so force our
            //  position back to the correct spot in a leaf first.
            //

            IndexContext.Current = IndexContext.Top;
            AddToIndex( IrpContext, Scb, (PINDEX_ENTRY)&IE, &IndexContext, NULL, FALSE );
            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexRow += 1;
        }

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
VOID
NtOfsDeleteRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_KEY IndexKey
    )

/*++

Routine Description:

    This routine may be called to delete one or more records from an index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the number of records being deleted.

    IndexKey - Supplies an array of Count entries, containing the Keys to be deleted.

Return Value:

    None. (This call is benign if any records do not exist.)

--*/

{
    INDEX_CONTEXT IndexContext;
    ULONG i;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Loop to add all entries
        //

        for (i = 0; i < Count; i++) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 IndexKey,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    IndexKey,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                //
                //  Delete it.
                //

                DeleteFromIndex( IrpContext, Scb, &IndexContext );
            }

            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexKey += 1;
        }

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
VOID
NtOfsUpdateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL,
    IN OUT PMAP_HANDLE MapHandle OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to update the data portion of a record in an index.

    If QuickIndexHint is specified, then the update may occur by directly accessing
    the buffer containing the specified key, iff other changes to the index do not
    prevent that.  If changes prevent the quick update, then the record is looked
    up by key in order to perform the data update.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the count of updates described in IndexRow.  For counts
            greater than 1, QuickIndexHint and MapHandle must not be supplied.

    IndexRow - Supplies the key to be updated and the new data for that key.

    QuickIndexHint - Supplies a optional quick index for this row returned from a previous
                     call to NtOfsFindRecord, updated on return.

    MapHandle - Supplies an optional MapHandle to accompany the QuickIndex.  If MapHandle
                is supplied, then the QuickIndexHint must be guaranteed valid.  MapHandle
                is updated (pinned) on return.

                MapHandle is ignored if QuickIndexHint is not specified.

Return Value:

    None.

Raises:

    STATUS_INFO_LENGTH_MISMATCH -- if the specified data is a different length from the
                                   data in the key.
    STATUS_NO_MATCH -- if the specified key does not exist.

--*/

{
    INDEX_CONTEXT IndexContext;
    PQUICK_INDEX QuickIndex = (PQUICK_INDEX)QuickIndexHint;
    PVOID DataInIndex;
    PINDEX_ENTRY IndexEntry;
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    ASSERT(Count != 0);

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer (BufferOffset test)
        //      - The index stream may not have been truncated (ChangeCount test)
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndexHint ) &&
            (QuickIndex->BufferOffset != 0) &&
            (QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount)) {

            ASSERT(Count == 1);

            //
            //  Use the top location in the index context to perform the
            //  read.
            //

            Sp = IndexContext.Base;

            //
            //  If we have a MapHandle already, we do not need to read the
            //  IndexBuffer.
            //

            if (ARGUMENT_PRESENT(MapHandle)) {

                IndexBuffer = MapHandle->Buffer;
                Sp->Bcb = MapHandle->Bcb;
                MapHandle->Bcb = NULL;
                Sp->CapturedLsn.QuadPart = QuickIndex->CapturedLsn.QuadPart;

            } else {

                ReadIndexBuffer( IrpContext,
                                 Scb,
                                 QuickIndex->IndexBlock,
                                 FALSE,
                                 Sp );

                IndexBuffer = Sp->StartOfBuffer;
            }

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, QuickIndex->BufferOffset );

                if (IndexEntry->DataLength < IndexRow->DataPart.DataLength) {
                    NtfsRaiseStatus( IrpContext, STATUS_INFO_LENGTH_MISMATCH, NULL, NULL );
                }

                DataInIndex = Add2Ptr( IndexEntry, IndexEntry->DataOffset );

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                //  ASSERT(Scb->ScbType.Index.ClustersPerIndexBuffer != 0);

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateRecordDataAllocation,
                              IndexRow->DataPart.Data,
                              IndexRow->DataPart.DataLength,
                              UpdateRecordDataAllocation,
                              DataInIndex,
                              IndexRow->DataPart.DataLength,
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              QuickIndex->BufferOffset,
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                //
                //  Now call the Restart routine to do it.
                //

                NtOfsRestartUpdateDataInIndex( IndexEntry,
                                               IndexRow->DataPart.Data,
                                               IndexRow->DataPart.DataLength );

                //
                //  If there is a MapHandle, we must update the Bcb pointer.
                //

                if (ARGUMENT_PRESENT(MapHandle)) {

                    MapHandle->Bcb = Sp->Bcb;
                    Sp->Bcb = NULL;
                }

                try_return( NOTHING );

            //
            //  Otherwise we need to unpin the Bcb and take
            //  the long path below.
            //

            } else {

                ASSERT(!ARGUMENT_PRESENT(MapHandle));
                NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            }
        }

        //
        //  Loop to apply all updates.
        //

        do {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 &IndexRow->KeyPart,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    &IndexRow->KeyPart,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                //
                //  Point to the index entry and the data within it.
                //

                IndexEntry = IndexContext.Current->IndexEntry;

                if (IndexEntry->DataLength < IndexRow->DataPart.DataLength) {
                    NtfsRaiseStatus( IrpContext, STATUS_INFO_LENGTH_MISMATCH, NULL, NULL );
                }

                DataInIndex = Add2Ptr( IndexEntry, IndexEntry->DataOffset );

                //
                //  Now pin the entry.
                //

                if (IndexContext.Current == IndexContext.Base) {

                    PFILE_RECORD_SEGMENT_HEADER FileRecord;
                    PATTRIBUTE_RECORD_HEADER Attribute;
                    PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext.AttributeContext;

                    //
                    //  Pin the root
                    //

                    NtfsPinMappedAttribute( IrpContext,
                                            Vcb,
                                            Context );

                    //
                    //  Write a log record to change our ParentIndexEntry.
                    //

                    FileRecord = NtfsContainingFileRecord(Context);
                    Attribute = NtfsFoundAttribute(Context);

                    //
                    //  Write the log record, but do not update the FileRecord Lsn,
                    //  since nothing moved and we don't want to force index contexts
                    //  to have to rescan.
                    //
                    //  FileRecord->Lsn =
                    //

                    NtfsWriteLog( IrpContext,
                                  Vcb->MftScb,
                                  NtfsFoundBcb(Context),
                                  UpdateRecordDataRoot,
                                  IndexRow->DataPart.Data,
                                  IndexRow->DataPart.DataLength,
                                  UpdateRecordDataRoot,
                                  DataInIndex,
                                  IndexRow->DataPart.DataLength,
                                  NtfsMftOffset( Context ),
                                  (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                                  (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                                  Vcb->BytesPerFileRecordSegment );

                    if (ARGUMENT_PRESENT( QuickIndexHint )) {

                        ASSERT( Count == 1 );
                        QuickIndex->BufferOffset = 0;
                    }

                } else {

                    PINDEX_ALLOCATION_BUFFER IndexBuffer;

                    Sp = IndexContext.Current;
                    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

                    //
                    //  Pin the index buffer
                    //

                    NtfsPinMappedData( IrpContext,
                                       Scb,
                                       LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                       Scb->ScbType.Index.BytesPerIndexBuffer,
                                       &Sp->Bcb );

                    //
                    //  Write a log record to change our ParentIndexEntry.
                    //

                    //
                    //  Write the log record, but do not update the IndexBuffer Lsn,
                    //  since nothing moved and we don't want to force index contexts
                    //  to have to rescan.
                    //
                    //  Indexbuffer->Lsn =
                    //

                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Sp->Bcb,
                                  UpdateRecordDataAllocation,
                                  IndexRow->DataPart.Data,
                                  IndexRow->DataPart.DataLength,
                                  UpdateRecordDataAllocation,
                                  DataInIndex,
                                  IndexRow->DataPart.DataLength,
                                  LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                  0,
                                  (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)IndexBuffer),
                                  Scb->ScbType.Index.BytesPerIndexBuffer );

                    if (ARGUMENT_PRESENT( QuickIndexHint )) {

                        ASSERT( Count == 1 );
                        QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                        QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                        QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                        QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                    }
                }

                //
                //  Now call the Restart routine to do it.
                //

                NtOfsRestartUpdateDataInIndex( IndexEntry,
                                               IndexRow->DataPart.Data,
                                               IndexRow->DataPart.DataLength );

            //
            //  If the file name is not in the index, this is a bad file.
            //

            } else {

                NtfsRaiseStatus( IrpContext, STATUS_NO_MATCH, NULL, NULL );
            }

            //
            //  Get ready for the next pass through.
            //

            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexRow += 1;

        } while (--Count);

    try_exit: NOTHING;

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

    }
}


NTFSAPI
NTSTATUS
NtOfsReadRecords (
        IN PIRP_CONTEXT IrpContext,
        IN PSCB Scb,
        IN OUT PREAD_CONTEXT *ReadContext,
        IN PINDEX_KEY IndexKey OPTIONAL,
        IN PMATCH_FUNCTION MatchFunction,
        IN PVOID MatchData,
        IN OUT ULONG *Count,
        OUT PINDEX_ROW Rows,
        IN ULONG BufferLength,
        OUT PVOID Buffer
        )

/*++

Routine Description:

    This routine may be called to enumerate rows in an index, in collated
    order.  It only returns records accepted by the match function.

    IndexKey may be specified at any time to start a new search from IndexKey,
    and IndexKey must be specified on the first call for a given IrpContext
    (and *ReadContext must be NULL).

    The read terminates when either *Count records have been returned, or
    BufferLength has been exhausted, or there are no more matching records.

    NtOfsReadRecords will seek to the appropriate point in the BTree (as defined
    by the IndexKey or saved position and the CollateFunction) and begin calling
    MatchFunction for each record.  It continues doing this while MatchFunction
    returns STATUS_SUCCESS.  If MatchFunction returns STATUS_NO_MORE_MATCHES,
    NtOfsReadRecords will cache this result and not call MatchFunction again until
    called with a non-NULL IndexKey.

    Note that this call is self-synchronized, such that successive calls to
    the routine are guaranteed to make progress through the index and to return
    items in Collation order, in spite of Add and Delete record calls being
    interspersed with Read records calls.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    ReadContext - On the first call this must supply a pointer to NULL.  On
                  return a pointer to a private context structure is returned,
                  which must then be supplied on all subsequent calls.  This
                  structure must be eventually be freed via NtOfsFreeReadContext.

    IndexKey - If specified, supplies the key from which the enumeration is to
               start/resume.  It must be specified on the first call when *ReadContext
               is NULL.

    MatchFunction - Supplies the MatchFunction to be called to determine which
                    rows to return.

    MatchData - Supplies the MatchData to be specified on each call to the MatchFunction.

    Count - Supplies the count of how many rows may be received, and returns the
            number of rows actually being returned.

    Rows - Returns the Count row descriptions.

    BufferLength - Supplies the length of the buffer in bytes, into which the
                   row keys and data are copied upon return.

    Buffer - Supplies the buffer into which the rows may be copied.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if there is no match for the specified IndexKey.
    STATUS_NO_MORE_MATCHES -- if a match is returned or previously returned,
                              but there are no more matches.

--*/

{
    PINDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;
    ULONG LengthToCopy;
    BOOLEAN MustRestart;
    ULONG BytesRemaining = BufferLength;
    ULONG ReturnCount = 0;
    NTSTATUS Status;
    BOOLEAN NextFlag;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  On the first lookup, their must be a key.
    //

    ASSERT((IndexKey != NULL) || (*ReadContext != NULL));

    //
    //  Everything must be Ulong aligned and sized.
    //

    ASSERT(IsLongAligned(Buffer));
    ASSERT(IsLongAligned(BufferLength));

    Status = STATUS_SUCCESS;
    NextFlag = FALSE;

    //
    //  Pick up the IndexContext, allocating one if we need to.
    //

    if (*ReadContext == NULL) {
        *ReadContext = NtfsAllocatePool(PagedPool, sizeof(READ_CONTEXT) );
        NtfsInitializeIndexContext( &(*ReadContext)->IndexContext );
        (*ReadContext)->LastReturnedKey.Key = &(*ReadContext)->SmallKeyBuffer[0];
        (*ReadContext)->LastReturnedKey.KeyLength = 0;
        (*ReadContext)->AllocatedKeyLength = sizeof(READ_CONTEXT) -
                                             FIELD_OFFSET(READ_CONTEXT, SmallKeyBuffer[0]);
    }

    IndexContext = &(*ReadContext)->IndexContext;

    //
    //  Store the MatchFunction and Data in the IndexContext, for the enumerations.
    //

    IndexContext->MatchFunction = MatchFunction;
    IndexContext->MatchData = MatchData;

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  If a Key was passed, position to the first possible match.
        //

        if (ARGUMENT_PRESENT(IndexKey)) {

             FindFirstIndexEntry( IrpContext,
                                  Scb,
                                  IndexKey,
                                  IndexContext );

        //
        //  Otherwise return here if we hit the end of the matches last time.
        //

        } else if ((*ReadContext)->LastReturnedKey.KeyLength == 0) {

            try_return( Status = STATUS_NO_MORE_MATCHES );
        }

        //
        //  Loop while we still have space to store rows.
        //

        while (ReturnCount <= *Count) {

            //
            //  If we're already at the end, don't call FindNextIndexEntry again.
            //

            ASSERT(ARGUMENT_PRESENT(IndexKey) ||
                   ((*ReadContext)->LastReturnedKey.KeyLength != 0));

            //
            //  See if there is an actual match.
            //

            if (!FindNextIndexEntry( IrpContext,
                                     Scb,
                                     NULL,      //  Not needed because of Match Function
                                     TRUE,
                                     FALSE,
                                     IndexContext,
                                     NextFlag,
                                     &MustRestart )) {

                //
                //  First handle the restart case by resuming from the last
                //  key returned, and skip that one.
                //

                if (MustRestart) {

                    ASSERT(!ARGUMENT_PRESENT(IndexKey));

                    NtfsReinitializeIndexContext( IrpContext, IndexContext );

                    FindFirstIndexEntry( IrpContext,
                                         Scb,
                                         &(*ReadContext)->LastReturnedKey,
                                         IndexContext );

                    //
                    //  Set NextFlag to TRUE, so we can go back and skip
                    //  the key we resumed on.
                    //

                    NextFlag = TRUE;
                    continue;
                }

                //
                //  No (more) entries - remember that the enumeration is done.
                //

                (*ReadContext)->LastReturnedKey.KeyLength = 0;

                //
                //  Return the appropriate code based on whether we have returned
                //  any matches yet or not.
                //

                if ((ReturnCount == 0) && ARGUMENT_PRESENT(IndexKey)) {
                    Status = STATUS_NO_MATCH;
                } else {
                    Status = STATUS_NO_MORE_MATCHES;
                }

                try_return(Status);
            }

            //
            //  We always need to go one beyond the one we can return to keep
            //  all resume cases the same, so now is the time to get out if the
            //  count is finished.
            //

            if (ReturnCount == *Count) {
                break;
            }

            //
            //  Now we must always move to the next.
            //

            NextFlag = TRUE;

            //
            //  First try to copy the key.
            //

            IndexEntry = IndexContext->Current->IndexEntry;

            LengthToCopy = IndexEntry->AttributeLength;
            if (LengthToCopy > BytesRemaining) {
                break;
            }

            RtlCopyMemory( Buffer, IndexEntry + 1, LengthToCopy );
            Rows->KeyPart.Key = Buffer;
            Rows->KeyPart.KeyLength = LengthToCopy;
            LengthToCopy = LongAlign(LengthToCopy);
            Buffer = Add2Ptr( Buffer, LengthToCopy );
            BytesRemaining -= LengthToCopy;

            //
            //  Now try to copy the data.
            //

            LengthToCopy = IndexEntry->DataLength;
            if (LengthToCopy > BytesRemaining) {
                break;
            }

            RtlCopyMemory( Buffer, Add2Ptr(IndexEntry, IndexEntry->DataOffset), LengthToCopy );
            Rows->DataPart.Data = Buffer;
            Rows->DataPart.DataLength = LengthToCopy;
            LengthToCopy = LongAlign(LengthToCopy);
            Buffer = Add2Ptr( Buffer, LengthToCopy );
            BytesRemaining -= LengthToCopy;

            //
            //  Capture this key before looping back.
            //
            //  First see if there is enough space.
            //

            if (Rows->KeyPart.KeyLength > (*ReadContext)->AllocatedKeyLength) {

                PVOID NewBuffer;

                //
                //  Allocate a new buffer.
                //

                LengthToCopy = LongAlign(Rows->KeyPart.KeyLength + 16);
                NewBuffer = NtfsAllocatePool(PagedPool, LengthToCopy );

                //
                //  Delete old key buffer?
                //

                if ((*ReadContext)->LastReturnedKey.Key != &(*ReadContext)->SmallKeyBuffer[0]) {
                    NtfsFreePool( (*ReadContext)->LastReturnedKey.Key );
                }

                (*ReadContext)->LastReturnedKey.Key = NewBuffer;
                (*ReadContext)->AllocatedKeyLength = LengthToCopy;
            }

            RtlCopyMemory( (*ReadContext)->LastReturnedKey.Key,
                           Rows->KeyPart.Key,
                           Rows->KeyPart.KeyLength );

            (*ReadContext)->LastReturnedKey.KeyLength = Rows->KeyPart.KeyLength;

            Rows += 1;
            ReturnCount += 1;
        }

    try_exit: NOTHING;

    } finally {

#ifdef BENL_DBG
        ASSERT( (*ReadContext)->AllocatedKeyLength >= (*ReadContext)->LastReturnedKey.KeyLength );
#endif

        NtfsReinitializeIndexContext( IrpContext, IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }

    *Count = ReturnCount;

    //
    //  If we are already returning something, but we got an error, change it
    //  to success to return what we have.  Then we may or may not get this error
    //  again anyway when we are called back.  This loop is currently not designed
    //  to resume correctly in all cases if there are already items returned.
    //

    if (ReturnCount != 0) {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTFSAPI
VOID
NtOfsFreeReadContext (
        IN PREAD_CONTEXT ReadContext
        )

/*++

Routine Description:

    This routine is called to free an ReadContext created by NtOfsReadRecords.

Arguments:

    ReadContext - Supplies the context to free.

Return Value:

    STATUS_SUCCESS -- if operation was successful.

--*/

{
    PAGED_CODE();

    if (ReadContext->LastReturnedKey.Key != NULL &&
        ReadContext->LastReturnedKey.Key != &ReadContext->SmallKeyBuffer[0]) {
        NtfsFreePool( ReadContext->LastReturnedKey.Key );
    }

    if (ReadContext->IndexContext.Base != ReadContext->IndexContext.LookupStack) {
        NtfsFreePool( ReadContext->IndexContext.Base );
    }

    NtfsFreePool( ReadContext );
}


NTSTATUS
NtfsQueryViewIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query view index operation.  It is responsible
    for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG UserBufferLength;

    ULONG BaseLength;
    ULONG SidLength;

    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN GotEntry;
    BOOLEAN LastPass;
    BOOLEAN FirstPass = TRUE;

    ULONG NextEntry;
    ULONG LastEntry;
    ULONG VariableLength;
    PVOID CurrentEntryBuffer = NULL;

    PINDEX_KEY IndexKey;
    ULONG IndexKeyLength = 0;

    PREAD_CONTEXT ReadContext = NULL;
    PFILE_OBJECTID_INFORMATION ObjIdInfoPtr;

    PFILE_QUOTA_INFORMATION QuotaInfoPtr = NULL;
    PQUOTA_USER_DATA QuotaUserData;

    PFILE_REPARSE_POINT_INFORMATION ReparsePointInfoPtr;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN CcbAcquired = FALSE;
    BOOLEAN FirstQueryForThisCcb = FALSE;
    BOOLEAN IndexKeyAllocated = FALSE;
    BOOLEAN IndexKeyKeyAllocated = FALSE;
    BOOLEAN AccessingUserBuffer = FALSE;

    ULONG ReadRecordBuffer[20];

    ULONG VariableBytesToCopy = 0;

    BOOLEAN AnotherEntryWillFit = TRUE;
    BOOLEAN AtEndOfIndex = FALSE;
    PSTRING RestartKey = NULL;

    ULONG BytesRemainingInBuffer;

    NTSTATUS ReadRecordStatus;
    ULONG Count;
    INDEX_ROW IndexRow;

    //
    //  We need to be certain that the scratch buffer is big enough.
    //

    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_OBJECTID_INFORMATION) );
    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_QUOTA_INFORMATION) );
    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_REPARSE_POINT_INFORMATION) );

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsQueryViewIndex...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length) );
    DebugTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass) );
    DebugTrace( 0, Dbg, (" ->SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, (" ->RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, (" ->ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );

    //
    //  Because we probably need to do the I/O anyway we'll reject any request
    //  right now that cannot wait for I/O.  We do not want to abort after
    //  processing a few index entries.
    //

    if (!FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT)) {

        DebugTrace( 0, Dbg, ("Automatically enqueue Irp to Fsp\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    RestartKey = IrpSp->Parameters.QueryDirectory.FileName;

    //
    //  Look in the Ccb to see the type of search.
    //

    RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);

    ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);

    //
    //  Determine the size of the constant part of the structure and make sure the Scb
    //  and info class are in agreement.  There may be some security implications in
    //  letting a user treat, say, the reparse index as the object id index.
    //

    switch (FileInformationClass) {

    case FileObjectIdInformation:

        BaseLength = sizeof( FILE_OBJECTID_INFORMATION );
        IndexKeyLength = OBJECT_ID_KEY_LENGTH;
        if (Scb != Vcb->ObjectIdTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    case FileQuotaInformation:

        BaseLength = sizeof( FILE_QUOTA_INFORMATION );
        IndexKeyLength = sizeof( ULONG );
        if (Scb != Vcb->QuotaTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    case FileReparsePointInformation:

        BaseLength = sizeof( FILE_REPARSE_POINT_INFORMATION );
        IndexKeyLength = sizeof( REPARSE_INDEX_KEY );
        if (Scb != Vcb->ReparsePointTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    default:

        Status = STATUS_INVALID_INFO_CLASS;
        break;
    }

    if (Status != STATUS_SUCCESS) {

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );
        return Status;
    }

    try {

        //
        //  We only allow one active request in this handle at a time.  If this is
        //  not a synchronous request then wait on the handle.
        //

        if (!FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO )) {

            EOF_WAIT_BLOCK WaitBlock;
            NtfsAcquireIndexCcb( Scb, Ccb, &WaitBlock );
            CcbAcquired = TRUE;
        }

        //
        //  Initialize the value we use to start the index enumeration.  Read carefully,
        //  we're working with both IndexKey and IndexKey->Key here.
        //

        IndexKey = NtfsAllocatePool( PagedPool, sizeof(INDEX_KEY) );
        IndexKeyAllocated = TRUE;

        IndexKey->KeyLength = IndexKeyLength;

        IndexKey->Key = NtfsAllocatePool( PagedPool, IndexKeyLength );
        IndexKeyKeyAllocated = TRUE;

        //
        //  When we first come into this function, there are a few interesting
        //  cases we need to consider to get everything initialized correctly.
        //
        //  1  We were called with some value from which to (re)start the enumeration,
        //     i.e. the caller wants to start somewhere in the middle of the index.
        //
        //  2  This is the first time we've been called to enumerate this index with
        //     this Ccb, in which case we want to start from the beginning.  This
        //     is substantially similar to the case where the caller has enumerated
        //     this index before, but wishes to restart the scan from the beginning of
        //     the index.
        //
        //  3  This is _not_ the first time we've been called to enumerate this index
        //     with this Ccb, and no restart key was specified, and the caller does
        //     not wish to restart the scan.  In this case, we need to pick up where
        //     the last call left off.
        //

        if (RestartKey != NULL) {

            DebugTrace( 0, Dbg, ("Restart key NOT null (case 1)\n") );

            //
            //  If we have a leftover query buffer from a previous call, free
            //  it, since we're no longer interested in where it left us.
            //

            if (Ccb->QueryBuffer != NULL) {

                ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                NtOfsFreeReadContext( Ccb->QueryBuffer );

                Ccb->QueryBuffer = NULL;

                ClearFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED | CCB_FLAG_LAST_INDEX_ROW_RETURNED );
            }

            //
            //  Store the initial value from which to start the enumeration,
            //  being careful not to write beyond the size of our allocated buffer.
            //

            if (RestartKey->Length > IndexKeyLength) {

                NtfsFreePool( IndexKey->Key );
                IndexKeyKeyAllocated = FALSE;

                IndexKey->Key = NtfsAllocatePool( PagedPool, RestartKey->Length );
                IndexKeyKeyAllocated = TRUE;
            }

            //
            //  Copy the key, and store the length.
            //

            RtlCopyMemory( IndexKey->Key,
                           RestartKey->Buffer,
                           RestartKey->Length );

            IndexKey->KeyLength = IndexKeyLength = RestartKey->Length;

        } else if (RestartScan || (Ccb->QueryBuffer == NULL)) {

            DebugTrace( 0, Dbg, ("RestartScan || Qb null (case 2)") );

            //
            //  The restart scan case is similar to the case where we're called with a
            //  RestartKey in that we want to deallocate any leftover info in the Ccb.
            //  The only difference is that we don't have a key from which to restart
            //  so we just set the key back to the appropriate starting value.  If
            //  the Ccb has no query buffer, then this is our first enumeration call
            //  since the handle was opened, and we need to start from scratch.
            //

            if (Ccb->QueryBuffer != NULL) {

                DebugTrace( 0, Dbg, ("Qb NOT null\n") );

                ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                NtOfsFreeReadContext( Ccb->QueryBuffer );

                Ccb->QueryBuffer = NULL;

                ClearFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED | CCB_FLAG_LAST_INDEX_ROW_RETURNED );

            } else {

                DebugTrace( 0, Dbg, ("Qb null\n") );

                FirstQueryForThisCcb = TRUE;
            }

            if (FileInformationClass == FileQuotaInformation) {

                //
                //  In the quota case, we have some special requirements for the fist key,
                //  so we want to init it to handle the case where we haven't been called
                //  with a restart key.
                //

                *((PULONG) IndexKey->Key) = QUOTA_FISRT_USER_ID;

            } else {

                RtlZeroMemory( IndexKey->Key,
                               IndexKeyLength );
            }

        } else {

            DebugTrace( 0, Dbg, ("Ccb->QueryBuffer NOT null (case 3)\n") );


            ASSERT(Ccb->QueryBuffer != NULL);
            ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

            //
            //  We have a leftover query buffer in the Ccb, and we were _not_
            //  called with a restart key, and we're not restarting the enumeration.
            //  Let's just pick up the enumeration where the Ccb's buffer tells us
            //  the last call left off.
            //

            ReadContext = Ccb->QueryBuffer;

            //
            //  If the previous pass set the keylength to 0, it must have hit the
            //  end of the index.  Check the CCB_FLAG_LAST_INDEX_ROW_RETURNED bit
            //  to see if we already made our special last pass through here to
            //  return the last row.
            //

            if (ReadContext->LastReturnedKey.KeyLength == 0) {

                DebugTrace( 0, Dbg, ("LastReturnedKey had 0 length\n") );

                if (FlagOn(Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED)) {

                    //
                    //  We're at the end of the index, and the last entry has already
                    //  been returned to our caller.  We're all done now.
                    //

                    try_return( Status = STATUS_NO_MORE_FILES );

                } else {

                    //
                    //  We're at the end of the index, but we have not yet returned the
                    //  last entry to our caller.  We can't break out yet.
                    //

                    AtEndOfIndex = TRUE;

                    //
                    //  Remember that we are returning the last entry now.
                    //

                    SetFlag( Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED );

                    //
                    //  We need to set this to a nonzero value so NtOfsReadRecords
                    //  will honor our request to read the last record.
                    //

                    if (IndexKeyLength > ReadContext->AllocatedKeyLength) {
                        ReadContext->LastReturnedKey.KeyLength = ReadContext->AllocatedKeyLength;
                    } else {
                        ReadContext->LastReturnedKey.KeyLength = IndexKeyLength;
                    }
                }

            } else if (ReadContext->LastReturnedKey.KeyLength > IndexKeyLength) {

                //
                //  There's not enough room to store the initial value from which to
                //  start the enumeration.  Free the buffer and get a bigger one.
                //

                NtfsFreePool( IndexKey->Key );
                IndexKeyKeyAllocated = FALSE;

                IndexKey->Key = NtfsAllocatePool( PagedPool, ReadContext->LastReturnedKey.KeyLength );
                IndexKeyKeyAllocated = TRUE;
            }

            //
            //  Make sure we're either using the small key buffer, or we've allocated
            //  a buffer that's big enough.
            //

            ASSERT( (ReadContext->LastReturnedKey.Key == &ReadContext->SmallKeyBuffer[0]) ||
                    (ReadContext->LastReturnedKey.KeyLength <= ReadContext->AllocatedKeyLength) );

            //
            //  Store the initial value from which to start the enumeration.
            //

            RtlCopyMemory( IndexKey->Key,
                           ReadContext->LastReturnedKey.Key,
                           ReadContext->LastReturnedKey.KeyLength );

            IndexKeyLength = ReadContext->LastReturnedKey.KeyLength;
        }

        Irp->IoStatus.Information = 0;

        //
        //  Acquire shared access to the Scb.
        //

        NtfsAcquireSharedScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        //
        //  If the volume is no longer mounted, we should fail this
        //  request.  Since we have the Scb shared now, we know that
        //  a dismount request can't sneak in.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        try {

            //
            //  If we are in the Fsp now because we had to wait earlier,
            //  we must map the user buffer, otherwise we can use the
            //  user's buffer directly.
            //

            AccessingUserBuffer = TRUE;
            Buffer = NtfsMapUserBuffer( Irp );
            AccessingUserBuffer = FALSE;

            //
            //  At this point we are about to enter our query loop.  We have
            //  already decided if we need to call restart or continue when we
            //  go after an index entry.  The variables LastEntry and NextEntry are
            //  used to index into the user buffer.  LastEntry is the last entry
            //  we added to the user buffer, and NextEntry is the current
            //  one we're working on.
            //

            LastEntry = 0;
            NextEntry = 0;

            while (TRUE) {

                DebugTrace( 0, Dbg, ("Top of Loop\n") );
                DebugTrace( 0, Dbg, ("LastEntry = %08lx\n", LastEntry) );
                DebugTrace( 0, Dbg, ("NextEntry = %08lx\n", NextEntry) );

                //
                //  Check to see if we should quit the loop because we are only
                //  returning a single entry.  We actually want to spin around
                //  the loop top twice so that our enumeration has us left off
                //  at the last entry we didn't return.
                //

                LastPass = (ReturnSingleEntry && !FirstPass);

                //
                //  Be sure to pessimistically reinitialize these locals each
                //  time through the loop.
                //

                GotEntry = FALSE;
                IndexRow.KeyPart.KeyLength = 0;
                IndexRow.DataPart.DataLength = 0;
                Count = 1;

                //
                //  On the first pass for this IrpContext, we MUST take this code path
                //  with a null readcontext and a non-null IndexKey.  See the comment
                //  where NtOfsReadRecords is implemented.
                //

                if (FirstPass) {

                    DebugTrace( 0, Dbg, ("First pass\n") );

                    ReadContext = NULL;

                    ReadRecordStatus = NtOfsReadRecords( IrpContext,
                                                         Scb,
                                                         &ReadContext,
                                                         IndexKey,
                                                         NtOfsMatchAll,
                                                         IndexKey,
                                                         &Count,
                                                         &IndexRow,
                                                         sizeof(ReadRecordBuffer),
                                                         &ReadRecordBuffer );

                    //
                    //  We want to store the new ReadContext in the Ccb.  Free
                    //  anything leftover in the Ccb first.
                    //

                    if (Ccb->QueryBuffer != NULL) {

                        ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                        NtOfsFreeReadContext( Ccb->QueryBuffer );
                    }

                    Ccb->QueryBuffer = ReadContext;
                    SetFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED );
                    GotEntry = (NT_SUCCESS( ReadRecordStatus ) &&
                                (IndexRow.KeyPart.KeyLength != 0));

                } else if ((!AtEndOfIndex)) {

                    DebugTrace( 0, Dbg, ("Nth pass\n") );

                    //
                    //  We don't want to do this if the previous trip through the loop
                    //  took us to the end of the index.
                    //

                    ReadContext = Ccb->QueryBuffer;

                    ASSERT(ReadContext != NULL);

                    //
                    //  Lookup the next index entry and set ourselves
                    //  up for subsequent iterations through the loop.
                    //

                    ReadRecordStatus = NtOfsReadRecords( IrpContext,
                                                         Scb,
                                                         &ReadContext,
                                                         NULL,
                                                         NtOfsMatchAll,
                                                         NULL,
                                                         &Count,
                                                         &IndexRow,
                                                         sizeof(ReadRecordBuffer),
                                                         &ReadRecordBuffer );

                    GotEntry = (NT_SUCCESS( ReadRecordStatus ) &&
                                (IndexRow.KeyPart.KeyLength != 0));
                }

                //
                //  If we only want to do the top part of the loop this time, get out here.
                //  For more info, see the comment above where we set LastPass.  Basically,
                //  if we're just advancing our index pointer in the return single case,
                //  if we don't have room to return another entry in the return multiple
                //  case, or if we came in pointing to the end of the index and we've
                //  already made one pass to return that entry to the caller, we should
                //  get out now.
                //

                if (LastPass ||
                    !AnotherEntryWillFit ||
                    (AtEndOfIndex && !FirstPass)) {

                    DebugTrace( 0, Dbg, ("LastPass = %08lx\n", LastPass) );
                    DebugTrace( 0, Dbg, ("AnotherEntryWillFit = %08lx\n", AnotherEntryWillFit) );
                    DebugTrace( 0, Dbg, ("...breaking out\n") );

                    if ((FileInformationClass == FileQuotaInformation) &&
                        (QuotaInfoPtr != NULL)) {

                        //
                        //  In the quota enumeration case, we need to zero this field
                        //  to indicate the end of the list.
                        //

                        QuotaInfoPtr->NextEntryOffset = 0;
                    }

                    break;
                }

                //
                //  Now check to see if we actually got another index entry.  If
                //  we didn't then we also need to check if we never got any
                //  or if we just ran out.  If we just ran out then we break out
                //  of the main loop and finish the Irp after the loop.
                //

                if (!GotEntry) {

                    DebugTrace( 0, Dbg, ("GotEntry is FALSE\n") );

                    if (!FirstPass) {

                        if (FirstQueryForThisCcb) {

                            try_return( Status = STATUS_NO_SUCH_FILE );
                        }

                        try_return( Status = STATUS_NO_MORE_FILES );
                    }

                    break;
                }

                //
                //  If the previous pass set the keylength to 0, it must have hit the
                //  end of the index.
                //

                if (ReadContext->LastReturnedKey.KeyLength == 0) {

                    DebugTrace( 0, Dbg, ("LastReturnedKey had 0 length (mid-loop)\n") );

                    //
                    //  We're at the end of the index, but we have not yet returned the
                    //  last entry to our caller.  We can't break out yet.
                    //

                    AtEndOfIndex = TRUE;

                    //
                    //  Remember that we are returning the last entry now.
                    //

                    SetFlag( Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED );
                }

                //
                //  Here are the rules concerning filling up the buffer:
                //
                //  1.  The Io system guarantees that there will always be
                //      enough room for at least one base record.
                //
                //  2.  If the full first record (including variable length data)
                //      cannot fit, as much of the data as possible is copied
                //      and STATUS_BUFFER_OVERFLOW is returned.
                //
                //  3.  If a subsequent record cannot completely fit into the
                //      buffer, none of it (as in 0 bytes) is copied, and
                //      STATUS_SUCCESS is returned.  A subsequent query will
                //      pick up with this record.
                //

                BytesRemainingInBuffer = UserBufferLength - NextEntry;

                if ( (NextEntry != 0) &&
                     ( (BaseLength + VariableLength > BytesRemainingInBuffer) ||
                       (UserBufferLength < NextEntry) ) ) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit\n") );

                    try_return( Status = STATUS_SUCCESS );
                }

                ASSERT( BytesRemainingInBuffer >= BaseLength );

                //
                //  Zero the base part of the structure.
                //

                AccessingUserBuffer = TRUE;
                RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                //
                //  Now we have an entry to return to our caller.  We'll
                //  case on the type of information requested and fill up the
                //  user buffer if everything fits.
                //

                switch (FileInformationClass) {

                case FileObjectIdInformation:

                    ObjIdInfoPtr = (PFILE_OBJECTID_INFORMATION) (&Buffer[NextEntry]);

                    if (IndexRow.DataPart.DataLength == sizeof(NTFS_OBJECTID_INFORMATION)) {

                        RtlCopyMemory( &ObjIdInfoPtr->FileReference,
                                       &(((NTFS_OBJECTID_INFORMATION *) IndexRow.DataPart.Data)->FileSystemReference),
                                       sizeof( LONGLONG ) );

                        RtlCopyMemory( &ObjIdInfoPtr->ExtendedInfo,
                                       ((NTFS_OBJECTID_INFORMATION *) IndexRow.DataPart.Data)->ExtendedInfo,
                                       OBJECT_ID_EXT_INFO_LENGTH );

                    } else {

                        ASSERTMSG( "Bad objectid index datalength", FALSE );
                        SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );
                        try_return( STATUS_NO_MORE_FILES );
                    }

                    if (IndexRow.KeyPart.KeyLength == IndexKeyLength) {

                        RtlCopyMemory( &ObjIdInfoPtr->ObjectId,
                                       IndexRow.KeyPart.Key,
                                       IndexRow.KeyPart.KeyLength );

                    } else {

                        ASSERTMSG( "Bad objectid index keylength", FALSE );
                        SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );
                        try_return( STATUS_NO_MORE_FILES );
                    }

                    //
                    //  Object Ids have no variable length data, so we can skip
                    //  over some of the tricky code below.
                    //

                    VariableLength = 0;

                    break;

                case FileQuotaInformation:

                    QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) (&Buffer[NextEntry]);
                    QuotaUserData = (PQUOTA_USER_DATA) IndexRow.DataPart.Data;

                    //
                    //  Skip this entry if it has been deleted.
                    //

                    if (FlagOn( QuotaUserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {

                        continue;
                    }

                    SidLength = IndexRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA;

                    QuotaInfoPtr->ChangeTime.QuadPart = QuotaUserData->QuotaChangeTime;
                    QuotaInfoPtr->QuotaUsed.QuadPart = QuotaUserData->QuotaUsed;
                    QuotaInfoPtr->QuotaThreshold.QuadPart = QuotaUserData->QuotaThreshold;
                    QuotaInfoPtr->QuotaLimit.QuadPart = QuotaUserData->QuotaLimit;

                    QuotaInfoPtr->SidLength = SidLength;

                    RtlCopyMemory( &QuotaInfoPtr->Sid,
                                   &QuotaUserData->QuotaSid,
                                   SidLength );

                    QuotaInfoPtr->NextEntryOffset = QuadAlign( SidLength + SIZEOF_QUOTA_USER_DATA );

                    VariableLength = QuotaInfoPtr->SidLength;

                    break;

                case FileReparsePointInformation:

                    ReparsePointInfoPtr = (PFILE_REPARSE_POINT_INFORMATION) (&Buffer[NextEntry]);

                    if (IndexRow.KeyPart.KeyLength == sizeof(REPARSE_INDEX_KEY)) {

                        ReparsePointInfoPtr->Tag = ((PREPARSE_INDEX_KEY) IndexRow.KeyPart.Key)->FileReparseTag;
                        ReparsePointInfoPtr->FileReference = ((PREPARSE_INDEX_KEY) IndexRow.KeyPart.Key)->FileId.QuadPart;

                    } else {

                        ASSERTMSG( "Bad reparse point index key length", FALSE );
                    }

                    //
                    //  Reparse points have no variable length data, so we can skip
                    //  over some of the tricky code below.
                    //

                    VariableLength = 0;

                    break;

                default:

                    try_return( Status = STATUS_INVALID_INFO_CLASS );
                }

                if (VariableLength != 0) {

                    //
                    //  Compute how many bytes we can copy.  This should only be less
                    //  than the variable length if we are only returning a single
                    //  entry.
                    //

                    if (BytesRemainingInBuffer >= BaseLength + VariableLength) {

                        VariableBytesToCopy = VariableLength;

                    } else {

                        VariableBytesToCopy = BytesRemainingInBuffer - BaseLength;

                        if (FileInformationClass == FileQuotaInformation) {

                            //
                            //  In the quota enumeration case, we need to zero this field
                            //  to indicate the end of the list.
                            //

                            QuotaInfoPtr->NextEntryOffset = 0;
                        }

                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                } else {

                    VariableBytesToCopy = 0;
                }

                //
                //  Set up the previous next entry offset.
                //

                if (FileInformationClass == FileQuotaInformation) {

                    *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;
                }

                AccessingUserBuffer = FALSE;

                //
                //  And indicate how much of the user buffer we have currently
                //  used up.  We must compute this value before we long align
                //  ourselves for the next entry.  This is the point where we
                //  quad-align the length of the previous entry.
                //

                Irp->IoStatus.Information = QuadAlign( Irp->IoStatus.Information) +
                                            BaseLength + VariableBytesToCopy;

                //
                //  If we weren't able to copy the whole index entry, then we bail here.
                //

                if ( !NT_SUCCESS( Status ) ) {

                    DebugTrace( 0, Dbg, ("Couldn't copy the whole index entry, exiting\n") );

                    try_return( Status );
                }

                //
                //  Set ourselves up for the next iteration.
                //

                LastEntry = NextEntry;
                NextEntry += (ULONG)QuadAlign( BaseLength + VariableBytesToCopy );
                FirstPass = FALSE;

                //
                //  Determine whether we should be able to fit another entry
                //  in the user's buffer after this one.
                //

                AnotherEntryWillFit = ((NextEntry + BaseLength) <= UserBufferLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            DebugTrace( -1, Dbg, ("NtfsQueryViewIndex raising %08lx\n", Status) );

            if (FsRtlIsNtstatusExpected( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

            } else {

                ExRaiseStatus( AccessingUserBuffer ? STATUS_INVALID_USER_BUFFER : Status );
            }
        }

        //
        //  At this point we've successfully filled up some of the buffer so
        //  now is the time to set our status to success.
        //

        Status = STATUS_SUCCESS;

    try_exit:

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Set the last access flag in the Fcb if the caller
        //  didn't set it explicitly.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            NtfsGetCurrentTime( IrpContext, Scb->Fcb->CurrentLastAccess );
            SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

    } finally {

        DebugUnwind( NtfsQueryViewIndex );

        if (ScbAcquired) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        NtfsCleanupAfterEnumeration( IrpContext, Ccb );

        if (CcbAcquired) {

            NtfsReleaseIndexCcb( Scb, Ccb );
        }

        if (IndexKeyAllocated) {

            if (IndexKeyKeyAllocated) {

                NtfsFreePool( IndexKey->Key );
            }

            NtfsFreePool( IndexKey );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );

    return Status;
}

/*++

Routine Descriptions:

    Standard collation routines for creating simple indices.

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

    CollationData - Optional data to support the collation.

Return Value:

    LessThan, EqualTo, or Greater than, for how Key1 compares
    with Key2.

--*/

FSRTL_COMPARISON_RESULT
NtOfsCollateUlong (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    ULONG u1, u2;

    UNREFERENCED_PARAMETER(CollationData);

    ASSERT( Key1->KeyLength == 4 );
    ASSERT( Key2->KeyLength == 4 );

    u1 = *(PULONG)Key1->Key;
    u2 = *(PULONG)Key2->Key;

    if (u1 > u2) {
        return GreaterThan;
    } else if (u1 < u2) {
        return LessThan;
    }
    return EqualTo;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateUlongs (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    PULONG pu1, pu2;
    ULONG count;
    FSRTL_COMPARISON_RESULT result = EqualTo;

    UNREFERENCED_PARAMETER(CollationData);

    ASSERT( (Key1->KeyLength & 3) == 0 );
    ASSERT( (Key2->KeyLength & 3) == 0 );

    count = Key1->KeyLength;
    if (count != Key2->KeyLength) {
        result = LessThan;
        if (count > Key2->KeyLength) {
            count = Key2->KeyLength;
            result = GreaterThan;
        }
    }

    pu1 = (PULONG)Key1->Key;
    pu2 = (PULONG)Key2->Key;

    while (count > 0) {
       if (*pu1 > *pu2) {
           return GreaterThan;
       } else if (*(pu1++) < *(pu2++)) {
           return LessThan;
       }
       count -= 4;
    }
    return result;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateSid (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    LONG Compare;

    PAGED_CODE( );

    UNREFERENCED_PARAMETER(CollationData);

    //
    //  The length of a valid SID is imbedded in the data
    //  so the function will mismatch be for the data runs out.
    //

    Compare = memcmp( Key1->Key, Key2->Key, Key1->KeyLength );

    if (Compare > 0) {
        return GreaterThan;
    } else if (Compare < 0) {
        return LessThan;
    }

    return EqualTo;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateUnicode (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    UNICODE_STRING String1, String2;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    String1.Length =
    String1.MaximumLength = (USHORT)Key1->KeyLength;
    String1.Buffer = Key1->Key;

    String2.Length =
    String2.MaximumLength = (USHORT)Key2->KeyLength;
    String2.Buffer = Key2->Key;

    return NtfsCollateNames( ((PUPCASE_TABLE_AND_KEY)CollationData)->UpcaseTable,
                             ((PUPCASE_TABLE_AND_KEY)CollationData)->UpcaseTableSize,
                             &String1,
                             &String2,
                             LessThan,
                             TRUE );
}


/*++

Routine Descriptions:

    Standard match routines for find / enumerate in simple indices.

Arguments:

    IndexRow - Row to check for a match.

    MatchData - Optional data for determining a match.

Return Value:

    STATUS_SUCCESS if the IndexRow matches
    STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
        continue
    STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
        should terminate

--*/

NTSTATUS
NtOfsMatchAll (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNREFERENCED_PARAMETER(IndexRow);
    UNREFERENCED_PARAMETER(MatchData);

    return STATUS_SUCCESS;
}

NTSTATUS
NtOfsMatchUlongExact (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    ULONG u1, u2;

    ASSERT( IndexRow->KeyPart.KeyLength == 4 );

    u1 = *(PULONG)IndexRow->KeyPart.Key;
    u2 = *(PULONG)((PINDEX_KEY)MatchData)->Key;

    if (u1 == u2) {
        return STATUS_SUCCESS;
    } else if (u1 < u2) {
        return STATUS_NO_MATCH;
    }
    return STATUS_NO_MORE_MATCHES;
}

NTSTATUS
NtOfsMatchUlongsExact (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    PULONG pu1, pu2;
    ULONG count;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( (((PINDEX_KEY)MatchData)->KeyLength & 3) == 0 );
    ASSERT( (IndexRow->KeyPart.KeyLength & 3) == 0 );

    count = ((PINDEX_KEY)MatchData)->KeyLength;
    if (count != IndexRow->KeyPart.KeyLength) {
        status = STATUS_NO_MORE_MATCHES;
        if (count > IndexRow->KeyPart.KeyLength) {
            count = IndexRow->KeyPart.KeyLength;
            status = STATUS_NO_MATCH;
        }
    }

    pu1 = (PULONG)((PINDEX_KEY)MatchData)->Key;
    pu2 = (PULONG)IndexRow->KeyPart.Key;

    while (count > 0) {
       if (*pu1 > *pu2) {
           return STATUS_NO_MATCH;
       } else if (*(pu1++) < *(pu2++)) {
           return STATUS_NO_MORE_MATCHES;
       }
       count -= 4;
    }
    return status;
}

NTSTATUS
NtOfsMatchUnicodeExpression (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNICODE_STRING MatchString, IndexString;
    FSRTL_COMPARISON_RESULT BlindResult;
    PUPCASE_TABLE_AND_KEY UpcaseTableAndKey = (PUPCASE_TABLE_AND_KEY)MatchData;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    MatchString.Length =
    MatchString.MaximumLength = (USHORT)UpcaseTableAndKey->Key.KeyLength;
    MatchString.Buffer = UpcaseTableAndKey->Key.Key;

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexRow->KeyPart.KeyLength;
    IndexString.Buffer = IndexRow->KeyPart.Key;

    if (NtfsIsNameInExpression( UpcaseTableAndKey->UpcaseTable, &MatchString, &IndexString, TRUE )) {

        return STATUS_SUCCESS;

    } else if ((BlindResult = NtfsCollateNames(UpcaseTableAndKey->UpcaseTable,
                                               UpcaseTableAndKey->UpcaseTableSize,
                                               &MatchString,
                                               &IndexString,
                                               GreaterThan,
                                               TRUE)) != LessThan) {

        return STATUS_NO_MATCH;

    } else {

        return STATUS_NO_MORE_MATCHES;
    }
}

NTSTATUS
NtOfsMatchUnicodeString (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNICODE_STRING MatchString, IndexString;
    FSRTL_COMPARISON_RESULT BlindResult;
    PUPCASE_TABLE_AND_KEY UpcaseTableAndKey = (PUPCASE_TABLE_AND_KEY)MatchData;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    MatchString.Length =
    MatchString.MaximumLength = (USHORT)UpcaseTableAndKey->Key.KeyLength;
    MatchString.Buffer = UpcaseTableAndKey->Key.Key;

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexRow->KeyPart.KeyLength;
    IndexString.Buffer = IndexRow->KeyPart.Key;

    if (NtfsAreNamesEqual( UpcaseTableAndKey->UpcaseTable, &MatchString, &IndexString, TRUE )) {

        return STATUS_SUCCESS;

    } else if ((BlindResult = NtfsCollateNames(UpcaseTableAndKey->UpcaseTable,
                                               UpcaseTableAndKey->UpcaseTableSize,
                                               &MatchString,
                                               &IndexString,
                                               GreaterThan,
                                               TRUE)) != LessThan) {

        return STATUS_NO_MATCH;

    } else {

        return STATUS_NO_MORE_MATCHES;
    }
}


#ifdef TOMM
VOID
NtOfsIndexTest (
    PIRP_CONTEXT IrpContext,
    PFCB TestFcb
    )

{
    PSCB AdScb;
    NTSTATUS Status;
    ULONG i;
    MAP_HANDLE MapHandle;
    ULONG Count;
    UPCASE_TABLE_AND_KEY UpcaseTableAndKey;
    QUICK_INDEX_HINT QuickHint;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow[6];
    UCHAR Buffer[6*160];
    PREAD_CONTEXT ReadContext = NULL;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$Test" );
    USHORT MaxKey = MAXUSHORT;
    USHORT MinKey = 0;

    DbgPrint("NtOfs Make NtOfsDoIndexTest FALSE to suppress test\n");
    DbgPrint("NtOfs Make NtOfsLeaveTestIndex TRUE to leave test index\n");

    DbgBreakPoint();

    if (!NtOfsDoIndexTest) {
        return;
    }
    NtOfsDoIndexTest = FALSE;

    UpcaseTableAndKey.UpcaseTable = TestFcb->Vcb->UpcaseTable;
    UpcaseTableAndKey.UpcaseTableSize = TestFcb->Vcb->UpcaseTableSize;
    UpcaseTableAndKey.Key.Key = NULL;
    UpcaseTableAndKey.Key.KeyLength = 0;

    //
    //  Create Test Index
    //

    DbgPrint("NtOfs creating test index\n");
    NtOfsCreateIndex( IrpContext,
                      TestFcb,
                      IndexName,
                      CREATE_NEW,
                      0,
                      COLLATION_NTOFS_ULONG,
                      &NtOfsCollateUnicode,
                      &UpcaseTableAndKey,
                      &AdScb );

    DbgPrint("NtOfs created Test Index Scb %08lx\n", AdScb);

    //
    //  Access empty index
    //

    DbgPrint("NtOfs lookup last in empty index\n");
    IndexKey.Key = &MaxKey;
    IndexKey.KeyLength = sizeof(MaxKey);
    Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

    ASSERT(!NT_SUCCESS(Status));

    //
    //  Add some keys!
    //

    DbgPrint("NtOfs adding keys to index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexRow[0].KeyPart.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexRow[0].KeyPart.KeyLength = 0x80;
        IndexRow[0].DataPart.Data = (PCHAR)IndexRow[0].KeyPart.Key + 0x80;
        IndexRow[0].DataPart.DataLength = sizeof(ATTRIBUTE_DEFINITION_COLUMNS) - 0x84;

        NtOfsAddRecords( IrpContext, AdScb, 1, &IndexRow[0], 0 );
    }

    //
    //  Now find the last key
    //

    DbgPrint("NtOfs checkin last key in index\n");
    IndexKey.Key = &MaxKey;
    IndexKey.KeyLength = sizeof(MaxKey);
    Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlCompareMemory(IndexRow[0].KeyPart.Key, L"$VOLUME_NAME", sizeof(L"$VOLUME_NAME") - sizeof( WCHAR )) ==
           (sizeof(L"$VOLUME_NAME") - sizeof( WCHAR )));

    NtOfsReleaseMap( IrpContext, &MapHandle );

    //
    //  See if they are all there.
    //

    DbgPrint("NtOfs looking up all keys in index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexKey.KeyLength = 0x80;

        Status = NtOfsFindRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle, NULL );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("NtOfsIterationFailure with i = %08lx, Status = %08lx\n", i, Status);
        }

        NtOfsReleaseMap( IrpContext, &MapHandle );
    }

    //
    //  Now enumerate the entire index
    //

    IndexKey.Key = &MinKey;
    IndexKey.KeyLength = sizeof(MinKey);
    Count = 6;

    DbgPrint("NtOfs enumerating index:\n\n");
    while (NT_SUCCESS(Status = NtOfsReadRecords( IrpContext,
                                                 AdScb,
                                                 &ReadContext,
                                                 (ReadContext == NULL) ? &IndexKey : NULL,
                                                 &NtOfsMatchAll,
                                                 NULL,
                                                 &Count,
                                                 IndexRow,
                                                 sizeof(Buffer),
                                                 Buffer ))) {

        for (i = 0; i < Count; i++) {
            DbgPrint( "IndexKey = %ws, AttributeTypeCode = %lx\n",
                      IndexRow[i].KeyPart.Key,
                      *(PULONG)IndexRow[i].DataPart.Data );
        }
        DbgPrint( "\n" );
    }

    NtOfsFreeReadContext( ReadContext );
    ReadContext = NULL;

    //
    //  Loop to update all records.
    //

    DbgPrint("NtOfs updating up all keys in index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexKey.KeyLength = 0x80;

        RtlZeroMemory( &QuickHint, sizeof(QUICK_INDEX_HINT) );

        NtOfsFindRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle, &QuickHint );

        //
        //  Copy and update the data.
        //

        RtlCopyMemory( Buffer, IndexRow[0].DataPart.Data, IndexRow[0].DataPart.DataLength );
        *(PULONG)Buffer += 0x100;
        IndexRow[0].DataPart.Data = Buffer;

        //
        //  Perform update with all valid combinations of hint and map handle.
        //

        NtOfsUpdateRecord( IrpContext,
                           AdScb,
                           1,
                           &IndexRow[0],
                           (i <= $FILE_NAME/0x10) ? NULL : &QuickHint,
                           (i < $INDEX_ROOT/0x10) ? NULL : &MapHandle );

        NtOfsReleaseMap( IrpContext, &MapHandle );
    }

    //
    //  Now enumerate the entire index again to see the updates.
    //

    IndexKey.Key = &MinKey;
    IndexKey.KeyLength = sizeof(MinKey);
    Count = 6;

    DbgPrint("NtOfs enumerating index after updates:\n\n");
    while (NT_SUCCESS(Status = NtOfsReadRecords( IrpContext,
                                                 AdScb,
                                                 &ReadContext,
                                                 (ReadContext == NULL) ? &IndexKey : NULL,
                                                 &NtOfsMatchAll,
                                                 NULL,
                                                 &Count,
                                                 IndexRow,
                                                 sizeof(Buffer),
                                                 Buffer ))) {

        for (i = 0; i < Count; i++) {
            DbgPrint( "IndexKey = %ws, AttributeTypeCode = %lx\n",
                      IndexRow[i].KeyPart.Key,
                      *(PULONG)IndexRow[i].DataPart.Data );
        }
        DbgPrint( "\n" );
    }

    NtOfsFreeReadContext( ReadContext );
    ReadContext = NULL;


    //
    //  Now delete the keys
    //

    if (!NtOfsLeaveTestIndex) {

        DbgPrint("NtOfs deleting all keys in index:\n\n");
        for (i = 0; i < $EA/0x10; i++) {

            IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
            IndexKey.KeyLength = 0x80;

            NtOfsDeleteRecords( IrpContext, AdScb, 1, &IndexKey );
        }

        //
        //  Access empty index
        //

        DbgPrint("NtOfs lookup last key in empty index:\n\n");
        IndexKey.Key = &MaxKey;
        IndexKey.KeyLength = sizeof(MaxKey);
        Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

        ASSERT(!NT_SUCCESS(Status));

        DbgPrint("NtOfs deleting index:\n");
        NtOfsDeleteIndex( IrpContext, TestFcb, AdScb );
    }

    DbgPrint("NtOfs closing index:\n");
    NtOfsCloseIndex( IrpContext, AdScb );

    DbgPrint("NtOfs test complete!\n\n");

    return;

    //
    //  Make sure these at least compile until we have some real callers.
    //

    {
        MAP_HANDLE M;
        PVOID B;
        LONGLONG O;
        ULONG L;
        LSN Lsn;

        NtOfsInitializeMapHandle( &M );
        NtOfsMapAttribute( IrpContext, AdScb, O, L, &B, &M );
        NtOfsPreparePinWrite( IrpContext, AdScb, O, L, &B, &M );
        NtOfsPinRead( IrpContext, AdScb, O, L, &M );
        NtOfsDirty( IrpContext, &M, &Lsn );
        NtOfsReleaseMap( IrpContext, &M );
        NtOfsPutData( IrpContext, AdScb, O, L, &B );

    }
}

#endif TOMM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\volinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the set and query volume information routines for
    Ntfs called by the dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
NtfsQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer,
    IN OUT PULONG Length
    );
    
NTSTATUS
NtfsSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    );

NTSTATUS
NtfsSetFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer
    );

NTSTATUS
NtfsSetFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer
    );
    
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQueryVolumeInfo)
#pragma alloc_text(PAGE, NtfsCommonSetVolumeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsAttributeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsDeviceInfo)
#pragma alloc_text(PAGE, NtfsQueryFsSizeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsVolumeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsControlInfo)
#pragma alloc_text(PAGE, NtfsQueryFsFullSizeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsVolumeObjectIdInfo)
#pragma alloc_text(PAGE, NtfsSetFsLabelInfo)
#pragma alloc_text(PAGE, NtfsSetFsControlInfo)
#pragma alloc_text(PAGE, NtfsSetFsVolumeObjectIdInfo)
#endif


NTSTATUS
NtfsCommonQueryVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Volume Information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;
    BOOLEAN AcquiredVcb = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryVolumeInfo...\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryVolume.Length) );
    DebugTrace( 0, Dbg, ("FsInformationClass = %08lx\n", IrpSp->Parameters.QueryVolume.FsInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object to get the Vcb, we don't really
    //  care what the type of open is.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid vol. query requests.
    //

    if (UnopenedFileObject == TypeOfOpen) {

        DebugTrace( 0, Dbg, ("Invalid file object for write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryVolume:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }


    //
    //  Get the Vcb shared and raise if we can't wait for the resource.
    //  We're only using $Volume Scb for the query size calls because the info
    //  it gets is static and we only need to protect against dismount
    //  Doing this prevents a deadlock with commit extensions from mm which use
    //  this call. However for system files like the mft we always need the vcb to avoid deadlock
    //
                         
    if ((FsInformationClass != FileFsSizeInformation) || 
        (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {
        
        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;
    } else {
        
        NtfsAcquireSharedScb( IrpContext, Scb );
    }

    try {

        //
        //  Make sure the volume is mounted.
        //

        if ((AcquiredVcb && !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) ||
            (!AcquiredVcb && FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED))) {
            
            Irp->IoStatus.Information = 0;
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (FsInformationClass) {

        case FileFsVolumeInformation:

            Status = NtfsQueryFsVolumeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsSizeInformation:

            Status = NtfsQueryFsSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = NtfsQueryFsDeviceInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = NtfsQueryFsAttributeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsControlInformation:

            Status = NtfsQueryFsControlInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsFullSizeInformation:
        
            Status = NtfsQueryFsFullSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsObjectIdInformation:
        
            Status = NtfsQueryFsVolumeObjectIdInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonQueryVolumeInfo );

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
        } else  {
            NtfsReleaseScb( IrpContext, Scb );
        }   

        DebugTrace( -1, Dbg, ("NtfsCommonQueryVolumeInfo -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
NtfsCommonSetVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Volume Information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetVolumeInfo\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.SetVolume.Length) );
    DebugTrace( 0, Dbg, ("FsInformationClass = %08lx\n", IrpSp->Parameters.SetVolume.FsInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.SetVolume.Length;
    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object to get the Vcb, we don't really
    //  care what the type of open is.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen != UserVolumeOpen &&
        (TypeOfOpen != UserViewIndexOpen ||
         FsInformationClass != FileFsControlInformation ||
         Fcb != Vcb->QuotaTableScb->Fcb)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> STATUS_ACCESS_DENIED\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  The volume must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire exclusive access to the Vcb
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  Proceed only if the volume is mounted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            //
            //  Based on the information class we'll do different actions.  Each
            //  of the procedures that we're calling performs the action if
            //  possible and returns true if it successful and false if it couldn't
            //  wait for any I/O to complete.
            //

            switch (FsInformationClass) {

            case FileFsLabelInformation:

                Status = NtfsSetFsLabelInfo( IrpContext, Vcb, Buffer );
                break;

            case FileFsControlInformation:

                Status = NtfsSetFsControlInfo( IrpContext, Vcb, Buffer );
                break;

            case FileFsObjectIdInformation:

                Status = NtfsSetFsVolumeObjectIdInfo( IrpContext, Vcb, Buffer );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        } else {

            Status = STATUS_FILE_INVALID;
        }

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonSetVolumeInfo );

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    NTSTATUS Status;

    ULONG BytesToCopy;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsVolumeInfo...\n") );

    //
    //  Get the volume creation time from the Vcb.
    //

    Buffer->VolumeCreationTime.QuadPart = Vcb->VolumeCreationTime;

    //
    //  Fill in the serial number and indicate that we support objects
    //

    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;
    Buffer->SupportsObjects = TRUE;

    Buffer->VolumeLabelLength = Vcb->Vpb->VolumeLabelLength;

    //
    //  Update the length field with how much we have filled in so far.
    //

    *Length -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

    //
    //  See how many bytes of volume label we can copy
    //

    if (*Length >= (ULONG)Vcb->Vpb->VolumeLabelLength) {

        Status = STATUS_SUCCESS;

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        Status = STATUS_BUFFER_OVERFLOW;

        BytesToCopy = *Length;
    }

    //
    //  Copy over the volume label (if there is one).
    //

    RtlCopyMemory( &Buffer->VolumeLabel[0],
                   &Vcb->Vpb->VolumeLabel[0],
                   BytesToCopy);

    //
    //  Update the buffer length by the amount we copied.
    //

    *Length -= BytesToCopy;

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query size information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsSizeInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_SIZE_INFORMATION) );

    //
    //  Check if we need to rescan the bitmap.  Don't try this
    //  if we have started to teardown the volume.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Acquire the volume bitmap shared to rescan the bitmap.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

        try {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        } finally {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->TotalAllocationUnits.QuadPart = Vcb->TotalClusters;
    Buffer->AvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->SectorsPerAllocationUnit = Vcb->BytesPerCluster / Vcb->BytesPerSector;
    Buffer->BytesPerSector = Vcb->BytesPerSector;

    if (Buffer->AvailableAllocationUnits.QuadPart < 0) {
        Buffer->AvailableAllocationUnits.QuadPart = 0;
    }

    //
    //  If quota enforcement is enabled then the available allocation
    //  units. must be reduced by the available quota.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED )) {

        PCCB Ccb;
        ULONGLONG Quota;
        ULONGLONG QuotaLimit;

        //
        //  Go grab the ccb out of the Irp.
        //

        Ccb = (PCCB) (IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->
                        FileObject->FsContext2);

        if (Ccb != NULL && Ccb->OwnerId != 0) {

            NtfsGetRemainingQuota( IrpContext, Ccb->OwnerId, &Quota, &QuotaLimit, NULL );

        } else {

            NtfsGetRemainingQuota( IrpContext,
                                   NtfsGetCallersUserId( IrpContext ),
                                   &Quota,
                                   &QuotaLimit,
                                   NULL );
        }

        //
        //  Do not use LlClustersFromBytesTruncate it is signed and this must be
        //  an unsigned operation.
        //
        
        Quota = Int64ShrlMod32( Quota, Vcb->ClusterShift );        
        QuotaLimit = Int64ShrlMod32( QuotaLimit, Vcb->ClusterShift );        

        if (Quota < (ULONGLONG) Buffer->AvailableAllocationUnits.QuadPart) {

            Buffer->AvailableAllocationUnits.QuadPart = Quota;
            DebugTrace( 0, Dbg, (" QQQQQ AvailableAllocation is quota limited to %I64x\n", Quota) );
        }

        if (QuotaLimit < (ULONGLONG) Vcb->TotalClusters) {
        
            Buffer->TotalAllocationUnits.QuadPart = QuotaLimit;
            DebugTrace( 0, Dbg, (" QQQQQ TotalAllocation is quota limited to %I64x\n", QuotaLimit) );
        }
    }

    //
    //  Adjust the length variable
    //

    DebugTrace( 0, Dbg, ("AvailableAllocation is %I64x\n", Buffer->AvailableAllocationUnits.QuadPart) );
    DebugTrace( 0, Dbg, ("TotalAllocation is %I64x\n", Buffer->TotalAllocationUnits.QuadPart) );
    
    *Length -= sizeof(FILE_FS_SIZE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query device information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsDeviceInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_DISK;
    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query attribute information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    NTSTATUS Status;
    ULONG BytesToCopy;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsAttributeInfo...\n") );

    //
    //  See how many bytes of the name we can copy.
    //

    *Length -= FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]);

    if ( *Length >= 8 ) {

        Status = STATUS_SUCCESS;

        BytesToCopy = 8;

    } else {

        Status = STATUS_BUFFER_OVERFLOW;

        BytesToCopy = *Length;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
                                   FILE_CASE_PRESERVED_NAMES |
                                   FILE_UNICODE_ON_DISK |
                                   FILE_FILE_COMPRESSION |
                                   FILE_PERSISTENT_ACLS |
                                   FILE_NAMED_STREAMS;

    //
    //  This may be a version 1.x volume that has not been upgraded yet.
    //  It may also be an upgraded volume where we somehow failed to 
    //  open the quota index.  In either case, we should only tell the 
    //  quota ui that this volume supports quotas if it really does.
    //
    
    if (Vcb->QuotaTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_VOLUME_QUOTAS );
    }

    //
    //  Ditto for object ids.
    //

    if (Vcb->ObjectIdTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_OBJECT_IDS );
    }

    //
    //  Encryption is trickier than quotas and object ids.  It requires an
    //  upgraded volume as well as a registered encryption driver.
    //

    if (NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION ) &&
        FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_ENCRYPTION );
    }

    //
    //  Reparse points and sparse files are supported in 5.0 volumes.
    //
    //  For reparse points we verify whether the Vcb->ReparsePointTableScb has
    //  been initialized or not.
    //

    if (Vcb->ReparsePointTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_REPARSE_POINTS );
    }
    
    if (NtfsVolumeVersionCheck( Vcb, NTFS_SPARSE_FILE_VERSION )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_SPARSE_FILES );
    }

    //
    //  Clear the compression flag if we don't allow compression on this drive
    //  (i.e. large clusters)
    //

    if (!FlagOn( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

        ClearFlag( Buffer->FileSystemAttributes, FILE_FILE_COMPRESSION );
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_READ_ONLY_VOLUME );
    }
    
    Buffer->MaximumComponentNameLength = 255;
    Buffer->FileSystemNameLength = BytesToCopy;;
    RtlCopyMemory( &Buffer->FileSystemName[0], L"NTFS", BytesToCopy );

    //
    //  Adjust the length variable
    //

    *Length -= BytesToCopy;

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query control information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    QUOTA_USER_DATA QuotaBuffer;
    PQUOTA_USER_DATA UserData;
    ULONG OwnerId;
    ULONG Count = 1;
    PREAD_CONTEXT ReadContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsControlInfo...\n") );

    RtlZeroMemory( Buffer, sizeof( FILE_FS_CONTROL_INFORMATION ));

    PAGED_CODE();

    try {

        //
        //  Fill in the quota information if quotas are running.
        //

        if (Vcb->QuotaTableScb != NULL) {

            OwnerId = QUOTA_DEFAULTS_ID;
            IndexKey.KeyLength = sizeof( OwnerId );
            IndexKey.Key = &OwnerId;

            Status = NtOfsReadRecords( IrpContext,
                                       Vcb->QuotaTableScb,
                                       &ReadContext,
                                       &IndexKey,
                                       NtOfsMatchUlongExact,
                                       &IndexKey,
                                       &Count,
                                       &IndexRow,
                                       sizeof( QuotaBuffer ),
                                       &QuotaBuffer );


            if (NT_SUCCESS( Status )) {

                UserData = IndexRow.DataPart.Data;

                Buffer->DefaultQuotaThreshold.QuadPart =
                    UserData->QuotaThreshold;
                Buffer->DefaultQuotaLimit.QuadPart =
                    UserData->QuotaLimit;

                //
                //  If the quota info is corrupt or has not been rebuilt
                //  yet then indicate the information is incomplete.
                //

                if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE |
                                                 QUOTA_FLAG_CORRUPT )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTAS_INCOMPLETE );
                }

                if ((Vcb->QuotaState & VCB_QUOTA_REPAIR_RUNNING) >
                     VCB_QUOTA_REPAIR_POSTED ) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTAS_REBUILDING );
                }

                //
                //  Set the quota information basied on where we want
                //  to be rather than where we are.
                //

                if (FlagOn( UserData->QuotaFlags,
                            QUOTA_FLAG_ENFORCEMENT_ENABLED )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTA_ENFORCE );

                } else if (FlagOn( UserData->QuotaFlags,
                            QUOTA_FLAG_TRACKING_REQUESTED )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTA_TRACK );
                }

                if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LOG_LIMIT)) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_LOG_QUOTA_LIMIT );

                }

                if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD)) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_LOG_QUOTA_THRESHOLD );

                }
            }
        }

    } finally {

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }

    }

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_CONTROL_INFORMATION );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query full size information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsFullSizeInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_FULL_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );

    //
    //  Check if we need to rescan the bitmap.  Don't try this
    //  if we have started to teardown the volume.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Acquire the volume bitmap shared to rescan the bitmap.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

        try {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        } finally {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->TotalAllocationUnits.QuadPart = Vcb->TotalClusters;
    Buffer->CallerAvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->ActualAvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->SectorsPerAllocationUnit = Vcb->BytesPerCluster / Vcb->BytesPerSector;
    Buffer->BytesPerSector = Vcb->BytesPerSector;

    if (Buffer->CallerAvailableAllocationUnits.QuadPart < 0) {
        Buffer->CallerAvailableAllocationUnits.QuadPart = 0;
    }
    if (Buffer->ActualAvailableAllocationUnits.QuadPart < 0) {
        Buffer->ActualAvailableAllocationUnits.QuadPart = 0;
    }

    //
    //  If quota enforcement is enabled then the available allocation
    //  units. must be reduced by the available quota.
    //

    if (FlagOn(Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED)) {
        
        ULONGLONG Quota;
        ULONGLONG QuotaLimit;
        PCCB Ccb;

        //
        //  Go grab the ccb out of the Irp.
        //

        Ccb = (PCCB) (IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->
                        FileObject->FsContext2);

        if (Ccb != NULL && Ccb->OwnerId != 0) {

            NtfsGetRemainingQuota( IrpContext, Ccb->OwnerId, &Quota, &QuotaLimit, NULL );

        } else {

            NtfsGetRemainingQuota( IrpContext,
                                   NtfsGetCallersUserId( IrpContext ),
                                   &Quota,
                                   &QuotaLimit,
                                   NULL );

        }

        //
        //  Do not use LlClustersFromBytesTruncate it is signed and this must be
        //  an unsigned operation.
        //
        
        Quota = Int64ShrlMod32( Quota, Vcb->ClusterShift );
        QuotaLimit = Int64ShrlMod32( QuotaLimit, Vcb->ClusterShift );        

        if (Quota < (ULONGLONG) Buffer->CallerAvailableAllocationUnits.QuadPart) {

            Buffer->CallerAvailableAllocationUnits.QuadPart = Quota;
        }
        
        if (QuotaLimit < (ULONGLONG) Vcb->TotalClusters) {
        
            Buffer->TotalAllocationUnits.QuadPart = QuotaLimit;
        }
    }

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume object id information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    NTSTATUS Status;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    
    PAGED_CODE();

    //
    //  The Vcb should be held so a dismount can't sneak in.
    //
    
    ASSERT_SHARED_RESOURCE( &(Vcb->Resource) );

    //
    //  Fail for version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Only try this if the volume has an object id.
        //
        
        if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID )) {

            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        //
        //  Get the object id extended info for the $Volume file.  We
        //  can cheat a little because we have the key part of the object
        //  id stored in the Vcb.
        //        
        
        Status = NtfsGetObjectIdExtendedInfo( IrpContext,
                                              Vcb,
                                              Vcb->VolumeObjectId,
                                              ObjectIdBuffer.ExtendedInfo );
                                              
        //
        //  Copy both the indexed part and the extended info part out to the
        //  user's buffer.
        //
        
        if (Status == STATUS_SUCCESS) {
        
            RtlCopyMemory( Buffer->ObjectId, 
                           Vcb->VolumeObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( Buffer->ExtendedInfo, 
                           ObjectIdBuffer.ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );

            *Length -= (OBJECT_ID_EXT_INFO_LENGTH + OBJECT_ID_KEY_LENGTH);
        }        
        
    } else {

        Status = STATUS_VOLUME_DISMOUNTED;
    }        
    
    return Status;                                      
}
    

//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine implements the set label call

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsSetFsLabelInfo...\n") );

    //
    //  Check that the volume label length is supported by the system.
    //

    if (Buffer->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

        return STATUS_INVALID_VOLUME_LABEL;
    }

    try {

        //
        //  Initialize the attribute context and then lookup the volume name
        //  attribute for on the volume dasd file
        //

        NtfsInitializeAttributeContext( &AttributeContext );

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_NAME,
                                       &AttributeContext )) {

            //
            //  We found the volume name so now simply update the label
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Vcb->VolumeDasdScb->Fcb,
                                      0,
                                      &Buffer->VolumeLabel[0],
                                      Buffer->VolumeLabelLength,
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      &AttributeContext );

        } else {

            //
            //  We didn't find the volume name so now create a new label
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Vcb->VolumeDasdScb->Fcb,
                                          $VOLUME_NAME,
                                          NULL,
                                          &Buffer->VolumeLabel[0],
                                          Buffer->VolumeLabelLength,
                                          0, // Attributeflags
                                          NULL,
                                          TRUE,
                                          &AttributeContext );
        }

        Vcb->Vpb->VolumeLabelLength = (USHORT)Buffer->VolumeLabelLength;

        if ( Vcb->Vpb->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

             Vcb->Vpb->VolumeLabelLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        }

        RtlCopyMemory( &Vcb->Vpb->VolumeLabel[0],
                       &Buffer->VolumeLabel[0],
                       Vcb->Vpb->VolumeLabelLength );

    } finally {

        DebugUnwind( NtfsSetFsLabelInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine implements the set volume quota control info call

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    if (Vcb->QuotaTableScb == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Process the quota part of the control structure.
    //

    NtfsUpdateQuotaDefaults( IrpContext, Vcb, Buffer );

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer
    )
    
/*++

Routine Description:

    This routine implements the set volume object id call.

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    FILE_OBJECTID_BUFFER OldObjectIdBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB DasdFcb;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    //
    //  The Vcb should be held so a dismount can't sneak in.
    //

    ASSERT_EXCLUSIVE_RESOURCE( &(Vcb->Resource) );
    ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) );
    
    //
    //  Every mounted volume should have the dasd scb open.            
    //

    ASSERT( Vcb->VolumeDasdScb != NULL );

    //
    //  Fail for version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    DasdFcb = Vcb->VolumeDasdScb->Fcb;

    //
    //  Make sure the volume doesn't already have an object id.
    //

    Status = NtfsGetObjectIdInternal( IrpContext, DasdFcb, FALSE, &OldObjectIdBuffer );

    if (NT_SUCCESS( Status )) {

        // 
        //  This volume apparently has an object id, so we need to delete it.
        // 

        Status = NtfsDeleteObjectIdInternal( IrpContext, DasdFcb, Vcb, TRUE );
        
        //
        //  The volume currently has no object id, so update the in-memory object id.
        //
        
        if (NT_SUCCESS( Status )) {
        
            RtlZeroMemory( Vcb->VolumeObjectId,
                           OBJECT_ID_KEY_LENGTH );

            ClearFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );                            
        }
        
    } else if ((Status == STATUS_OBJECTID_NOT_FOUND) || 
               (Status == STATUS_OBJECT_NAME_NOT_FOUND)) {    

        //
        //  This volume does not have an object id, but nothing else went wrong
        //  while we were checking, so let's proceed normally.
        //

        Status = STATUS_SUCCESS;
        
    } else {

        //
        //  The object id lookup failed for some unexpected reason.
        //  Let's get out of here and return that status to our caller.
        //
        
        return Status;
    }

    //
    //  If we either didn't find an object id, or successfully deleted one,
    //  let's set the new object id.
    //
    
    if (NT_SUCCESS( Status )) {
    
        //
        //  I'd rather do one copy for the entire structure than one for 
        //  the indexed part, and another for the extended info.  I'd 
        //  like to assert that the strucutres are still the same and I
        //  can safely do that.
        //
        
        ASSERT( sizeof( ObjectIdBuffer ) == sizeof( *Buffer ) );

        RtlCopyMemory( &ObjectIdBuffer, 
                       Buffer, 
                       sizeof( ObjectIdBuffer ) );
        
        //
        //  Set this object id for the $Volume file.
        //
        
        Status = NtfsSetObjectIdInternal( IrpContext,
                                          DasdFcb,
                                          Vcb,
                                          &ObjectIdBuffer );

        //
        //  If all went well, update the in-memory object id.
        //
        
        if (NT_SUCCESS( Status )) {
        
            RtlCopyMemory( Vcb->VolumeObjectId,
                           &ObjectIdBuffer.ObjectId,
                           OBJECT_ID_KEY_LENGTH );
                           
            SetFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );                            
        }
    }
    
    return Status;                                      
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\workque.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Ntfs File
    system.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsOplockComplete)
#endif


VOID
NtfsOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    NTSTATUS Status = Irp->IoStatus.Status;
    PIRP_CONTEXT IrpContext = (PIRP_CONTEXT) Context;
    PAGED_CODE();

    //
    //  Check on the return value in the Irp.
    //

    if (Status == STATUS_SUCCESS) {

        //
        //  Insert the Irp context in the workqueue.
        //

        NtfsAddToWorkque( IrpContext, Irp );

    //
    //  If this is create and we have a completion event then
    //  we just want to signal the event and clean up the IrpContext.
    //  There is someone waiting who will clean up the Irp.
    //

    } else if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
               (IrpContext->Union.OplockCleanup != NULL) &&
               (IrpContext->Union.OplockCleanup->CompletionContext != NULL)) {

        KeInitializeEvent( &IrpContext->Union.OplockCleanup->CompletionContext->Event,
                           NotificationEvent,
                           TRUE );

        ASSERT( Status != STATUS_PENDING && Status != STATUS_REPARSE );
        NtfsCompleteRequest( IrpContext, NULL, Status );

    //
    //  Otherwise complete the Irp and cleanup the IrpContext.
    //

    } else {

        ASSERT( Status != STATUS_PENDING && Status != STATUS_REPARSE );
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return;
}


VOID
NtfsPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp = NULL;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    PUSN_FCB ThisUsn, LastUsn;
#endif

    IrpContext = (PIRP_CONTEXT) Context;

    //
    //  Make this is a valid allocated IrpContext. It's ok for
    //  this to be allocated on the caller's stack as long as the
    //  caller's not doing this operation asynchronously.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL )) ||
           (IrpContext->NodeTypeCode == NTFS_NTC_IRP_CONTEXT));

    //
    //  Make sure if we are posting the request, which may be
    //  because of log file full, that we free any Fcbs or PagingIo
    //  resources which were acquired.
    //

    //
    //  Just in case we somehow get here with a transaction ID, clear
    //  it here so we do not loop forever.
    //

    if (IrpContext->TransactionId != 0) {

        NtfsCleanupFailedTransaction( IrpContext );
    }

    //
    //  Cleanup all of the fields of the IrpContext.
    //  Restore the thread context pointer if associated with this IrpContext.
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

        NtfsRestoreTopLevelIrp();
        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
    }

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, FALSE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    //
    //  If we are aborting a transaction, then it is important to clear out the
    //  Usn reasons, so we do not try to write a Usn Journal record for
    //  somthing that did not happen!  Worse yet if we get a log file full
    //  we fail the abort, which is not allowed.
    //
    //  First, reset the bits in the Fcb, so we will not fail to allow posting
    //  and writing these bits later.  Note that all the reversible changes are
    //  done with the Fcb exclusive, and they are actually backed out anyway.
    //  All the nonreversible ones (only unnamed and named data overwrite) are
    //  forced out first anyway before the data is actually modified.
    //

    ThisUsn = &IrpContext->Usn;

    do {

        ASSERT( !FlagOn( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON ));

        if (ThisUsn->NextUsnFcb == NULL) { break; }

        LastUsn = ThisUsn;
        ThisUsn = ThisUsn->NextUsnFcb;

    } while (TRUE);
#endif

    IrpContext->OriginatingIrp = Irp;

    //
    //  Note that close.c uses a trick where the "Irp" is really
    //  a file object.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        if (Irp->Type == IO_TYPE_IRP) {

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  We need to lock the user's buffer, unless this is an MDL-read,
            //  in which case there is no user buffer.
            //
            //  **** we need a better test than non-MDL (read or write)!

            if (IrpContext->MajorFunction == IRP_MJ_READ
                || IrpContext->MajorFunction == IRP_MJ_WRITE) {

                ClearFlag(IrpContext->MinorFunction, IRP_MN_DPC);

                //
                //  Lock the user's buffer if this is not an Mdl request.
                //

                if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

                    NtfsLockUserBuffer( IrpContext,
                                        Irp,
                                        (IrpContext->MajorFunction == IRP_MJ_READ) ?
                                        IoWriteAccess : IoReadAccess,
                                        IrpSp->Parameters.Write.Length );
                }

            //
            //  We also need to check whether this is a query directory operation.
            //

            } else if (IrpContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL
                       && IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

                NtfsLockUserBuffer( IrpContext,
                                    Irp,
                                    IoWriteAccess,
                                    IrpSp->Parameters.QueryDirectory.Length );

            //
            //  These two FSCTLs use neither I/O, so check for them.
            //

            } else if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                       (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                       ((IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_READ_USN_JOURNAL) ||
                        (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_GET_RETRIEVAL_POINTERS))) {

                NtfsLockUserBuffer( IrpContext,
                                    Irp,
                                    IoWriteAccess,
                                    IrpSp->Parameters.FileSystemControl.OutputBufferLength );
            }

            //
            //  Mark that we've already returned pending to the user
            //

            IoMarkIrpPending( Irp );
        }
    }

    return;
}


NTSTATUS
NtfsPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)

Return Value:

    STATUS_PENDING


--*/

{
    //
    //  Before posting, free any Scb snapshots.  Note that if someone
    //  is calling this routine directly to post, then he better not
    //  have changed any disk structures, and thus we should have no
    //  work to do.  On the other hand, if someone raised a status
    //  (like STATUS_CANT_WAIT), then we do both a transaction abort
    //  and restore of these Scb values.
    //

    NtfsPrePostIrp( IrpContext, Irp );

    NtfsAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}



VOID
NtfsCancelOverflowRequest (
    IN PDEVICE_OBJECT Device,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp in the overflow queue. If its an irp that must be processed we  move the irp to the
    top of the queue o.w we cancel it direclty. The dequeuing code guarantees the cancel routine is removed before
    the irpcontext is dequeued.  It also won't dequeue an irp that is marked with a 1 in the info
    field. Note we are guarranteed by io subsys that
    the irp will remain for the lifetime of this call even after we drop the spinlock

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN Cancel;

    IrpContext = (PIRP_CONTEXT)Irp->IoStatus.Information;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    Cancel = (IrpContext->MajorFunction != IRP_MJ_CLEANUP) && 
             (IrpContext->MajorFunction != IRP_MJ_CLOSE);

    ASSERT( Cancel );
                         
    ASSERT( IrpContext->NodeTypeCode == NTFS_NTC_IRP_CONTEXT );

    Vdo = CONTAINING_RECORD( Device,
                             VOLUME_DEVICE_OBJECT,
                             DeviceObject );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Gain the critical workqueue spinlock and
    //  either cancel it or move it to the head of the list
    //  Note the workqueue code always tests the cancel first before working which
    //  is what synchronizes this
    //                        
    
    ExAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );
    RemoveEntryList( &IrpContext->WorkQueueItem.List );

    if (!Cancel) {
        InsertHeadList( &Vdo->OverflowQueue, &IrpContext->WorkQueueItem.List );
        Irp->Cancel = 0;
    } else {
        Vdo->OverflowQueueCount -= 1;
    }

    ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

    if (Cancel) {

        if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
            KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
        }
        NtfsCompleteRequest( IrpContext, Irp, STATUS_CANCELLED );
    }
}




//
//  Local support routine.
//

VOID
NtfsAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;


    if (ARGUMENT_PRESENT( Irp )) {

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Check if this request has an associated file object, and thus volume
        //  device object.
        //

        if ( IrpSp->FileObject != NULL ) {

            KIRQL SavedIrql;
            PVOLUME_DEVICE_OBJECT Vdo;

            Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                     VOLUME_DEVICE_OBJECT,
                                     DeviceObject );

            //
            //  Check to see if this request should be sent to the overflow
            //  queue.  If not, then send it off to an exworker thread. Block here
            //  for non deferred write threads when the overflow queue is full
            //

            if ((Vdo->OverflowQueueCount >= OVERFLOW_QUEUE_LIMIT) &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE )) {
                KeWaitForSingleObject( &Vdo->OverflowQueueEvent, Executive, KernelMode, FALSE, NULL );                    
            }

            ExAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

            if ( Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

                //
                //  We cannot currently respond to this IRP so we'll just enqueue it
                //  to the overflow queue on the volume.
                //

                
                if (NtfsSetCancelRoutine( Irp, NtfsCancelOverflowRequest, (ULONG_PTR)IrpContext, TRUE )) {

                    if (Status == STATUS_SUCCESS) {
                        
                        InsertTailList( &Vdo->OverflowQueue,
                                        &IrpContext->WorkQueueItem.List );
                        Vdo->OverflowQueueCount += 1;
                    }
                     
                } else {
                    Status = STATUS_CANCELLED;
                }
                
                ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

                if (Status != STATUS_SUCCESS) {

                    if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                        KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
                    }
                    NtfsCompleteRequest( IrpContext, Irp, Status );
                }

                return;

            } else {

                //
                //  We are going to send this Irp to an ex worker thread so up
                //  the count.
                //

                if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                    KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
                }
                Vdo->PostedRequestCount += 1;

                ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
            }
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          NtfsFspDispatch,
                          (PVOID)IrpContext );
    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\behavior.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    behavior.c

Abstract:

    This file contains routines that control file system behavior

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
BehaviorHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_BEHAVIOR );
    return EXIT_CODE_SUCCESS;
}

#define NTFS_KEY  L"System\\CurrentControlSet\\Control\\FileSystem"

typedef struct _BEHAVIOR_OPTION {
    PWSTR   Name;
    PWSTR   RegVal;
    ULONG   MinVal;
    ULONG   MaxVal;
} BEHAVIOR_OPTION, *PBEHAVIOR_OPTION;

BEHAVIOR_OPTION Options[] = {
    { L"disable8dot3",         L"NtfsDisable8dot3NameCreation",           0,  1 },
    { L"allowextchar",         L"NtfsAllowExtendedCharacterIn8dot3Name",  0,  1 },
    { L"disablelastaccess",    L"NtfsDisableLastAccessUpdate",            0,  1 },
    { L"quotanotify",          L"NtfsQuotaNotifyRate",                    1, -1 },
    { L"mftzone",              L"NtfsMftZoneReservation",                 1,  4 },
};

#define NUM_OPTIONS  (sizeof(Options)/sizeof(BEHAVIOR_OPTION))


INT
RegistryQueryValueKey(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for querying the Registry Key Value.
    This routine display the value associated with the corresponding
    Key Value.

Arguments:

    argc - The argument count and must be 1
    
    argv - Array with one string element that is the registry key to display.

Return Value:

    None

--*/
{
    ULONG i,Value,Size;
    HKEY hKey = NULL;
    LONG Status;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_RQUERYVK );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        //
        //  Verify that the option is correct
        //

        for (i = 0; i < NUM_OPTIONS; i++) {
            if (_wcsicmp( argv[0], Options[i].Name ) == 0) {
                break;
            }
        }

        if (i >= NUM_OPTIONS) {
            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Open the registry key
        //

        Status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            NTFS_KEY,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, NTFS_KEY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Query the value
        //

        Size = sizeof(ULONG);

        Status = RegQueryValueEx(
            hKey,
            Options[i].RegVal,
            0,
            NULL,
            (PBYTE)&Value,
            &Size
            );

        if (Status != ERROR_SUCCESS ) {
            DisplayMsg( MSG_BEHAVIOR_OUTPUT_NOT_SET, Options[i].Name );
        } else {
            DisplayMsg( MSG_BEHAVIOR_OUTPUT, Options[i].Name, Value );
        }

    } finally {

        if (hKey) {
            RegCloseKey( hKey );
        }

    }

    return ExitCode;
}


INT
RegistrySetValueKey (
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for setting the Registry Key Value.
    This routine sets the value for the Key Value Name given.

Arguments:

    argc - The argument count.
    argv - Array of strings which contain the DataType, DataLength,
           Data and KeyValue Name.

Return Value:

    None

--*/
{
    ULONG i,j;
    HKEY hKey = NULL;
    LONG Status;
    INT ExitCode = EXIT_CODE_SUCCESS;
    PWSTR EndPtr;
    
    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_RSETVK );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        //
        //  Verify that the option is correct
        //

        for (i = 0; i < NUM_OPTIONS; i++) {
            if (_wcsicmp( argv[0], Options[i].Name ) == 0) {
                break;
            }
        }

        if (i == NUM_OPTIONS) {
            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Verify that the value is correct
        //

        j = My_wcstoul( argv[1], &EndPtr, 0 );
        
        //
        //  If we did not parse the entire string or
        //  if we overflowed ULONG or
        //  if we're out of range
        //
        
        if (UnsignedNumberCheck( j, EndPtr ) 
            || j > Options[i].MaxVal 
            || j < Options[i].MinVal) {
            
            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        
        }

        //
        //  Open the registry key
        //

        Status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            NTFS_KEY,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, NTFS_KEY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Set the value
        //

        Status = RegSetValueEx(
            hKey,
            Options[i].RegVal,
            0,
            REG_DWORD,
            (PBYTE)&j,
            sizeof(DWORD)
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, Options[i].RegVal );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (hKey) {
            RegCloseKey( hKey );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\write.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    BrianAn         19-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//    The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#ifdef NTFS_RWC_DEBUG
PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('WFtN')

#define OVERFLOW_WRITE_THRESHHOLD        (0x1a00)

#define CollectWriteStats(VCB,OPEN_TYPE,SCB,FCB,BYTE_COUNT,IRP_CONTEXT,TLIC) {           \
    PFILE_SYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
    if (!FlagOn( (FCB)->FcbState, FCB_STATE_SYSTEM_FILE )) {                             \
        if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode )) {                        \
            FsStats->Common.UserFileWrites += 1;                                         \
            FsStats->Common.UserFileWriteBytes += (ULONG)(BYTE_COUNT);                   \
        } else {                                                                         \
            FsStats->Ntfs.UserIndexWrites += 1;                                          \
            FsStats->Ntfs.UserIndexWriteBytes += (ULONG)(BYTE_COUNT);                    \
        }                                                                                \
    } else {                                                                             \
        if ((SCB) != (VCB)->LogFileScb) {                                                \
            FsStats->Common.MetaDataWrites += 1;                                         \
            FsStats->Common.MetaDataWriteBytes += (ULONG)(BYTE_COUNT);                   \
        } else {                                                                         \
            FsStats->Ntfs.LogFileWrites += 1;                                            \
            FsStats->Ntfs.LogFileWriteBytes += (ULONG)(BYTE_COUNT);                      \
        }                                                                                \
                                                                                         \
        if ((SCB) == (VCB)->MftScb) {                                                    \
            FsStats->Ntfs.MftWrites += 1;                                                \
            FsStats->Ntfs.MftWriteBytes += (ULONG)(BYTE_COUNT);                          \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.MftWritesLazyWriter += 1;                                  \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.MftWritesFlushForLogFileFull += 1;                         \
            } else {                                                                     \
                FsStats->Ntfs.MftWritesUserRequest += 1;                                 \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.MftWritesUserLevel.Write += 1;                         \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.MftWritesUserLevel.Create += 1;                        \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.MftWritesUserLevel.SetInfo += 1;                       \
                    break;                                                               \
                case IRP_MJ_FLUSH_BUFFERS:                                               \
                    FsStats->Ntfs.MftWritesUserLevel.Flush += 1;                         \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->Mft2Scb) {                                            \
            FsStats->Ntfs.Mft2Writes += 1;                                               \
            FsStats->Ntfs.Mft2WriteBytes += (ULONG)(BYTE_COUNT);                         \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.Mft2WritesLazyWriter += 1;                                 \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.Mft2WritesFlushForLogFileFull += 1;                        \
            } else {                                                                     \
                FsStats->Ntfs.Mft2WritesUserRequest += 1;                                \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.Mft2WritesUserLevel.Write += 1;                        \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.Mft2WritesUserLevel.Create += 1;                       \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.Mft2WritesUserLevel.SetInfo += 1;                      \
                    break;                                                               \
                case IRP_MJ_FLUSH_BUFFERS:                                               \
                    FsStats->Ntfs.Mft2WritesUserLevel.Flush += 1;                        \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->RootIndexScb) {                                       \
            FsStats->Ntfs.RootIndexWrites += 1;                                          \
            FsStats->Ntfs.RootIndexWriteBytes += (ULONG)(BYTE_COUNT);                    \
        } else if ((SCB) == (VCB)->BitmapScb) {                                          \
            FsStats->Ntfs.BitmapWrites += 1;                                             \
            FsStats->Ntfs.BitmapWriteBytes += (ULONG)(BYTE_COUNT);                       \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.BitmapWritesLazyWriter += 1;                               \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.BitmapWritesFlushForLogFileFull += 1;                      \
            } else {                                                                     \
                FsStats->Ntfs.BitmapWritesUserRequest += 1;                              \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.BitmapWritesUserLevel.Write += 1;                      \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.BitmapWritesUserLevel.Create += 1;                     \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.BitmapWritesUserLevel.SetInfo += 1;                    \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->MftBitmapScb) {                                       \
            FsStats->Ntfs.MftBitmapWrites += 1;                                          \
            FsStats->Ntfs.MftBitmapWriteBytes += (ULONG)(BYTE_COUNT);                    \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.MftBitmapWritesLazyWriter += 1;                            \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.MftBitmapWritesFlushForLogFileFull += 1;                   \
            } else {                                                                     \
                FsStats->Ntfs.MftBitmapWritesUserRequest += 1;                           \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.Write += 1;                   \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.Create += 1;                  \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.SetInfo += 1;                 \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        }                                                                                \
    }                                                                                    \
}

#define WriteToEof (StartingVbo < 0)

#ifdef SYSCACHE_DEBUG

#define CalculateSyscacheFlags( IRPCONTEXT, FLAG, INITIAL_VALUE )           \
    FLAG = INITIAL_VALUE;                                                   \
    if (PagingIo) {                                                         \
        FLAG |= SCE_FLAG_PAGING;                                            \
    }                                                                       \
    if (!SynchronousIo) {                                                   \
        FLAG |= SCE_FLAG_ASYNC;                                             \
    }                                                                       \
    if (SynchPagingIo) {                                                    \
        FLAG |= SCE_FLAG_SYNC_PAGING;                                       \
    }                                                                       \
    if (FlagOn( (IRPCONTEXT)->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {      \
        FLAG |= SCE_FLAG_LAZY_WRITE;                                        \
    }                                                                       \
    if (RecursiveWriteThrough) {                                            \
        FLAG |= SCE_FLAG_RECURSIVE;                                         \
    }                                                                       \
    if (NonCachedIo) {                                                      \
        FLAG |= SCE_FLAG_NON_CACHED;                                        \
    }                                                                       \
    if (Scb->CompressionUnit) {                                             \
        FLAG |= SCE_FLAG_COMPRESSED;                                        \
    }


#endif


NTSTATUS
NtfsFsdWrite (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD entry part of Write.

Arguments:

    IrpContext - If present, a pointer to an IrpContext
        on the caller's stack.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    DebugTrace( +1, Dbg, ("NtfsFsdWrite\n") );

    //
    //  Call the common Write routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {


            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate synchronous paging io on the stack to avoid allocation
                //  failures
                //  

                if (CanFsdWait( Irp ) && FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                    IrpContext = (PIRP_CONTEXT) NtfsAllocateFromStack( sizeof( IRP_CONTEXT ));
                }

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                if (ThreadTopLevelContext->ScbBeingHotFixed != NULL) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY );
                }

                //
                //  If this is an MDL_WRITE then the Mdl in the Irp should
                //  be NULL.
                //

                if (FlagOn( IrpContext->MinorFunction, IRP_MN_MDL ) &&
                    !FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    Irp->MdlAddress = NULL;
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  If this is an Mdl complete request, don't go through
            //  common write.
            //

            ASSERT(!FlagOn( IrpContext->MinorFunction, IRP_MN_DPC ));

            if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                DebugTrace( 0, Dbg, ("Calling NtfsCompleteMdl\n") );
                Status = NtfsCompleteMdl( IrpContext, Irp );

            //
            //  Identify write requests which can't wait and post them to the
            //  Fsp.
            //

            } else {

                //
                //  Capture the auxiliary buffer and clear its address if it
                //  is not supposed to be deleted by the I/O system on I/O completion.
                //

                if (Irp->Tail.Overlay.AuxiliaryBuffer != NULL) {

                    IrpContext->Union.AuxiliaryBuffer =
                      (PFSRTL_AUXILIARY_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

                    if (!FlagOn(IrpContext->Union.AuxiliaryBuffer->Flags,
                                FSRTL_AUXILIARY_FLAG_DEALLOCATE)) {

                        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    }
                }

                Status = NtfsCommonWrite( IrpContext, Irp );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            ExceptionCode = GetExceptionCode();

            if (ExceptionCode == STATUS_FILE_DELETED) {

                if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL ) ||
                    FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
                }

            } else if ((ExceptionCode == STATUS_VOLUME_DISMOUNTED) &&
                       FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
            }

            Status = NtfsProcessException( IrpContext,
                                           Irp,
                                           ExceptionCode );
        }

    } while ((Status == STATUS_CANT_WAIT || Status == STATUS_LOG_FILE_FULL) &&
             (ThreadTopLevelContext == &TopLevelContext));

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdWrite -> %08lx\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}



NTSTATUS
NtfsCommonWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Write called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_OBJECT UserFileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

#ifdef  COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PCOMPRESSED_DATA_INFO CompressedDataInfo;
    ULONG EngineMatches;
    ULONG CompressionUnitSize, ChunkSize;
#endif

    PNTFS_ADVANCED_FCB_HEADER Header;

    BOOLEAN OplockPostIrp = FALSE;
    BOOLEAN PostIrp = FALSE;

    PVOID SystemBuffer = NULL;
    PVOID SafeBuffer = NULL;

    BOOLEAN RecursiveWriteThrough = FALSE;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;

    BOOLEAN UpdateMft = FALSE;
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN SetWriteSeen = FALSE;

    BOOLEAN RestoreValidDataToDisk = FALSE;

    BOOLEAN Wait;
    BOOLEAN OriginalTopLevel;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;
    ULONG PagingFileIo;
    BOOLEAN SynchPagingIo;
    BOOLEAN RawEncryptedWrite = FALSE;

    NTFS_IO_CONTEXT LocalContext;

    VBO StartingVbo;
    LONGLONG ByteCount;
    LONGLONG ByteRange;
    LONGLONG OldFileSize;

    PVOID NewBuffer;
    PMDL NewMdl;
    PMDL OriginalMdl;
    PVOID OriginalBuffer;
    ULONG TempLength;

    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttributeContext = FALSE;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;

    LONGLONG ZeroStart;
    LONGLONG ZeroLength;

#ifdef SYSCACHE_DEBUG
    BOOLEAN PurgeResult;
    LONG TempEntry;
#endif

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonWrite\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    UserFileObject = FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid write requests.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != StreamFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        DebugTrace( 0, Dbg, ("Invalid file object for write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  If this is a recursive request which has already failed then
    //  complete this request with STATUS_FILE_LOCK_CONFLICT.  Always let the
    //  log file requests go through though since Cc won't get a chance to
    //  retry.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY ) &&
        !NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus ) &&
        (Scb != Vcb->LogFileScb)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_FILE_LOCK_CONFLICT );
        return STATUS_FILE_LOCK_CONFLICT;
    }

    //
    //  Check if this volume has already been shut down.  If it has, fail
    //  this write request.
    //

    //**** ASSERT( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) );

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN)) {

        Irp->IoStatus.Information = 0;

        DebugTrace( 0, Dbg, ("Write for volume that is already shutdown.\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_TOO_LATE) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_TOO_LATE );
        return STATUS_TOO_LATE;
    }

    //
    //  Fail if the volume is mounted read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Irp->IoStatus.Information = 0;

        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_MEDIA_WRITE_PROTECTED) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Initialize the appropriate local variables.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags,IRP_NOCACHE );
    SynchronousIo = BooleanFlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO );
    PagingFileIo = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );
    SynchPagingIo = (BOOLEAN) FlagOn( Irp->Flags, IRP_SYNCHRONOUS_PAGING_IO );
    OriginalTopLevel = NtfsIsTopLevelRequest( IrpContext );

    //
    //  If this is async paging io then check if we are being called by the mapped page writer.
    //  Convert it back to synchronous if not.
    //

    if (!Wait && PagingIo && !PagingFileIo) {

        if ((IrpContext->TopLevelIrpContext != IrpContext) ||
            (NtfsGetTopLevelContext()->SavedTopLevelIrp != (PIRP) FSRTL_MOD_WRITE_TOP_LEVEL_IRP)) {

            Wait = TRUE;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
        }
    }

    DebugTrace( 0, Dbg, ("PagingIo       -> %04x\n", PagingIo) );
    DebugTrace( 0, Dbg, ("NonCachedIo    -> %04x\n", NonCachedIo) );
    DebugTrace( 0, Dbg, ("SynchronousIo  -> %04x\n", SynchronousIo) );

    //
    //  Extract starting Vbo and offset. Restore back write to eof if the
    //  flag was set that we came through and adjusted for it and now the filesize
    //  has shrunk due to a failure to adjust size or an intervening seteof
    //  it should be safe to add the irp params since we validated for overflows when
    //  we set the writing_at_eof flag
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF ) &&
        (Scb->Header.FileSize.QuadPart < IrpSp->Parameters.Write.ByteOffset.QuadPart + IrpSp->Parameters.Write.Length)) {

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
        IrpSp->Parameters.Write.ByteOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        IrpSp->Parameters.Write.ByteOffset.HighPart = -1;
    }

    StartingVbo = IrpSp->Parameters.Write.ByteOffset.QuadPart;
    ByteCount = (LONGLONG) IrpSp->Parameters.Write.Length;

    //
    //  Check for overflows. However, 0xFFFFFFFF is a valid value
    //  when we are appending at EOF.
    //

    ASSERT( !WriteToEof ||
            (IrpSp->Parameters.Write.ByteOffset.HighPart == -1 &&
            IrpSp->Parameters.Write.ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE));

    if ((MAXLONGLONG - StartingVbo < ByteCount) && (!WriteToEof)) {

        ASSERT( !PagingIo );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    ByteRange = StartingVbo + ByteCount;

    DebugTrace( 0, Dbg, ("StartingVbo   -> %016I64x\n", StartingVbo) );

    //
    //  If this is a null request, return immediately.
    //

    if ((ULONG)ByteCount == 0) {

        Irp->IoStatus.Information = 0;

        DebugTrace( 0, Dbg, ("No bytes to write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_SUCCESS) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

#if DBG
    if (PagingIo &&
        NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) &&
        Scb->Header.PagingIoResource != NULL &&
        NtfsIsSharedScbPagingIo( Scb ) &&
        FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
        Scb->EncryptionContext == NULL) {

        //
        //  We're in trouble if we can't encrypt the data in the pages before writing
        //  it out.  Naturally, if this is a directory or some other unencryptible
        //  attribute type, we don't care, since we weren't going to encrypt the data
        //  anyway.  It is valid to do raw writes to an encypted stream without an
        //  encryption context, but raw encrypted writes shouldn't look like paging io.
        //

        ASSERTMSG( "Encrypted file without an encryption context -- can't do paging io", FALSE );
    }
#endif

    //
    //  If this is async Io to a compressed stream
    //  then we will make this look synchronous.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

        Wait = TRUE;
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    //
    //  See if we have to defer the write.
    //

    if (!PagingIo &&
        !NonCachedIo &&
        !FlagOn( FileObject->Flags, FO_WRITE_THROUGH ) &&
        !CcCanIWrite( FileObject,
                      (ULONG)ByteCount,
                      (BOOLEAN)(FlagOn( IrpContext->State,
                                       IRP_CONTEXT_STATE_WAIT | IRP_CONTEXT_STATE_IN_FSP ) == IRP_CONTEXT_STATE_WAIT),
                      BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

        BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

        NtfsPrePostIrp( IrpContext, Irp );

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

        CcDeferWrite( FileObject,
                      (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                      IrpContext,
                      Irp,
                      (ULONG)ByteCount,
                      Retrying );

        return STATUS_PENDING;
    }

    //
    //  Use a local pointer to the Scb header for convenience.
    //

    Header = &Scb->Header;

    //
    //  Make sure there is an initialized NtfsIoContext block.
    //

    if (TypeOfOpen == UserVolumeOpen
        || NonCachedIo) {

        //
        //  If there is a context pointer, we need to make sure it was
        //  allocated and not a stale stack pointer.
        //

        if (IrpContext->Union.NtfsIoContext == NULL
            || !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {

            //
            //  If we can wait, use the context on the stack.  Otherwise
            //  we need to allocate one.
            //

            if (Wait) {

                IrpContext->Union.NtfsIoContext = &LocalContext;
                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

            } else {

                IrpContext->Union.NtfsIoContext = (PNTFS_IO_CONTEXT)ExAllocateFromNPagedLookasideList( &NtfsIoContextLookasideList );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );
            }
        }

        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

        //
        //  Store whether we allocated this context structure in the structure
        //  itself.
        //

        IrpContext->Union.NtfsIoContext->AllocatedContext =
            BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

        if (Wait) {

            KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->Union.NtfsIoContext->PagingIo = PagingIo;
            IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId =
                ExGetCurrentResourceThread();

            IrpContext->Union.NtfsIoContext->Wait.Async.RequestedByteCount =
                (ULONG)ByteCount;
        }
    }

    DebugTrace( 0, Dbg, ("PagingIo       -> %04x\n", PagingIo) );
    DebugTrace( 0, Dbg, ("NonCachedIo    -> %04x\n", NonCachedIo) );
    DebugTrace( 0, Dbg, ("SynchronousIo  -> %04x\n", SynchronousIo) );
    DebugTrace( 0, Dbg, ("WriteToEof     -> %04x\n", WriteToEof) );

    //
    //  Handle volume Dasd here.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        //
        //  If the caller has not asked for extended DASD IO access then
        //  limit with the volume size.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO )) {

            //
            //  If this is a volume file, we cannot write past the current
            //  end of file (volume).  We check here now before continueing.
            //
            //  If the starting vbo is past the end of the volume, we are done.
            //

            if (WriteToEof || (Header->FileSize.QuadPart <= StartingVbo)) {

                DebugTrace( 0, Dbg, ("No bytes to write\n") );
                DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_SUCCESS) );

                NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
                return STATUS_SUCCESS;

            //
            //  If the write extends beyond the end of the volume, truncate the
            //  bytes to write.
            //

            } else if (Header->FileSize.QuadPart < ByteRange) {

                ByteCount = Header->FileSize.QuadPart - StartingVbo;
            }
        }

        SetFlag( UserFileObject->Flags, FO_FILE_MODIFIED );
        Status = NtfsVolumeDasdIo( IrpContext,
                                   Irp,
                                   Vcb,
                                   StartingVbo,
                                   (ULONG)ByteCount );

        //
        //  If the volume was opened for Synchronous IO, update the current
        //  file position.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS(Status)) {

            UserFileObject->CurrentByteOffset.QuadPart = StartingVbo + (LONGLONG) Irp->IoStatus.Information;
        }

        DebugTrace( 0, Dbg, ("Complete with %08lx bytes written\n", Irp->IoStatus.Information) );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", Status) );

        if (Wait) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        return Status;
    }

    //
    //  If this is a paging file, just send it to the device driver.
    //  We assume Mm is a good citizen.
    //

    if (PagingFileIo != 0) {

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
        }

        //
        //  Do the usual STATUS_PENDING things.
        //

        IoMarkIrpPending( Irp );

        //
        //  Perform the actual IO, it will be completed when the io finishes.
        //

        NtfsPagingFileIo( IrpContext,
                          Irp,
                          Scb,
                          StartingVbo,
                          (ULONG)ByteCount );

        //
        //  We, nor anybody else, need the IrpContext any more.
        //

        NtfsCompleteRequest( IrpContext, NULL, 0 );

        return STATUS_PENDING;
    }

    //
    //  Special processing for paging io.
    //

    if (PagingIo) {

        //
        //  If this is the Usn Journal then bias the Io to the correct location in the
        //  file.
        //

        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

            StartingVbo += Vcb->UsnCacheBias;
            ByteRange = StartingVbo + (LONGLONG) IrpSp->Parameters.Write.Length;
        }

        //
        //  Gather statistics on this IO.
        //

        CollectWriteStats( Vcb, TypeOfOpen, Scb, Fcb, ByteCount, IrpContext,
                           IrpContext->TopLevelIrpContext );
    }

    //
    //  Use a try-finally to free Scb and buffers on the way out.
    //  At this point we can treat all requests identically since we
    //  have a usable Scb for each of them.  (Volume, User or Stream file)
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has been opened cached, then we will do a flush here
        //  to avoid stale data problems.  Note that we must flush before
        //  acquiring the Fcb shared since the write may try to acquire
        //  it exclusive.
        //
        //  CcFlushCache may not raise.
        //
        //  The Purge following the flush will guarantee cache coherency.
        //

        //
        //  If this request is paging IO then check if our caller already
        //  owns any of the resources for this file.  If so then we don't
        //  want to perform a log file full in this thread.
        //

        if (!PagingIo) {

            //
            //  Capture the source information.
            //

            IrpContext->SourceInfo = Ccb->UsnSourceInfo;

            //
            //  Check for rawencryptedwrite
            //

            if (NonCachedIo &&
                !NtfsIsTopLevelNtfs( IrpContext )) {

#if DBG || defined( NTFS_FREE_ASSERT )
                IrpSp = IoGetCurrentIrpStackLocation( IrpContext->TopLevelIrpContext->OriginatingIrp );

                ASSERT( (IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                        (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_WRITE_RAW_ENCRYPTED ));
#endif

                RawEncryptedWrite = TRUE;
            }

            if (NonCachedIo &&
                (TypeOfOpen != StreamFileOpen) &&
                (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

                //
                //  Acquire the paging io resource to test the compression state.  If the
                //  file is compressed this will add serialization up to the point where
                //  CcCopyWrite flushes the data, but those flushes will be serialized
                //  anyway.  Uncompressed files will need the paging io resource
                //  exclusive to do the flush.
                //

                ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                PagingIoAcquired = TRUE;

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    if (WriteToEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        ULONG Flags;

                        CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                        TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, Flags, WriteToEof ? Header->FileSize.QuadPart : StartingVbo, ByteCount, -1 );
                    }
#endif
                    CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                  WriteToEof ? &Header->FileSize : (PLARGE_INTEGER)&StartingVbo,
                                  (ULONG)ByteCount,
                                  &Irp->IoStatus );

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlUpdateSyscacheEvent( Scb, TempEntry, Irp->IoStatus.Status, 0 );
                    }
#endif

                    if (WriteToEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    //
                    //  Make sure there was no error in the flush path.
                    //

                    if (!NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus ) ||
                        !NT_SUCCESS( Irp->IoStatus.Status )) {

                        NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                            &Irp->IoStatus.Status,
                                                            TRUE,
                                                            STATUS_UNEXPECTED_IO_ERROR );
                    }

                    //
                    //  Now purge the data for this range.
                    //

                    NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );

#ifdef SYSCACHE_DEBUG
                    PurgeResult =
#endif
                    CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                       (PLARGE_INTEGER)&StartingVbo,
                                                       (ULONG)ByteCount,
                                                       FALSE );
#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb ) && !PurgeResult) {
                        KdPrint( ("NTFS: Failed Purge 0x%x 0x%I64x 0x%x\n", Scb, StartingVbo, ByteCount) );
                        DbgBreakPoint();

                        //
                        // Repeat attempt so we can watch
                        //

                        PurgeResult = CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                           (PLARGE_INTEGER)&StartingVbo,
                                                           (ULONG)ByteCount,
                                                           FALSE );
                    }
#endif
                }

            //
            //  If not paging I/O, then we must acquire a resource, and do some
            //  other initialization.  We already have the resource if we performed
            //  the coherency flush above.
            //

            } else {

                //  We want to acquire the paging io resource if not already acquired.
                //  Acquire exclusive if we failed a previous convert to non-resident because
                //  of a possible deadlock.  Otherwise get it shared.
                //

                if (!(FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) ?
                      ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, Wait ) :
                      ExAcquireSharedWaitForExclusive( Scb->Header.PagingIoResource, Wait ))) {

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }
                PagingIoAcquired = TRUE;
            }


            //
            //  Check if we have already gone through cleanup on this handle.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CLOSED, NULL, NULL );
            }

            //
            //  Now check if the attribute has been deleted or is on a dismounted volume.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                } else {
                    NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                }
            }
            //
            //  Now synchronize with the FsRtl Header
            //

            NtfsAcquireFsrtlHeader( Scb );
            
            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.
            //

            if ((ByteRange > Header->ValidDataLength.QuadPart) || WriteToEof) {

                if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                    (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                    DoingIoAtEof = TRUE;
                    OldFileSize = Header->FileSize.QuadPart;

                } else {

                    ASSERT( IrpContext->TopLevelIrpContext->CleanupStructure == NULL );

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
    #if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
    #endif

                        //
                        //  Store this in the IrpContext until commit or post
                        //

                        IrpContext->CleanupStructure = Scb;

                        OldFileSize = Header->FileSize.QuadPart;

                        //
                        //  Check for writing to end of File.  If we are, then we have to
                        //  recalculate the byte range.
                        //

                        if (WriteToEof) {

                            //
                            //  Mark the in irp context that the write is at eof and change its paramters
                            //  to reflect where the end of the file is.
                            //

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
                            IrpSp->Parameters.Write.ByteOffset.QuadPart = Header->FileSize.QuadPart;

                            StartingVbo = Header->FileSize.QuadPart;
                            ByteRange = StartingVbo + ByteCount;

                            //
                            //  If the ByteRange now exceeds our maximum value, then
                            //  return an error.
                            //

                            if (ByteRange < StartingVbo) {

                                NtfsReleaseFsrtlHeader( Scb );
                                try_return( Status = STATUS_INVALID_PARAMETER );
                            }
                        }

    #if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
    #endif
                    }

                }

                //
                //  Make sure the user isn't writing past our maximum file size.
                //

                if ((ULONGLONG)ByteRange > MAXFILESIZE) {

                    NtfsReleaseFsrtlHeader( Scb );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }
            }

            NtfsReleaseFsrtlHeader( Scb );
            
            //
            //  We cannot handle user noncached I/Os to compressed files, so we always
            //  divert them through the cache with write through.
            //
            //  The reason that we always handle the user requests through the cache,
            //  is that there is no other safe way to deal with alignment issues, for
            //  the frequent case where the user noncached I/O is not an integral of
            //  the Compression Unit.  We cannot, for example, read the rest of the
            //  compression unit into a scratch buffer, because we are not synchronized
            //  with anyone mapped to the file and modifying the other data.  If we
            //  try to assemble the data in the cache in the noncached path, to solve
            //  the above problem, then we have to somehow purge these pages away
            //  to solve cache coherency problems, but then the pages could be modified
            //  by a file mapper and that would be wrong, too.
            //
            //  Bottom line is we can only really support cached writes to compresed
            //  files.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) && NonCachedIo) {

                NonCachedIo = FALSE;

                if (Scb->FileObject == NULL) {

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }

                FileObject = Scb->FileObject;
                SetFlag( FileObject->Flags, FO_WRITE_THROUGH );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH );
            }

            //
            //  If this is async I/O save away the async resource.
            //

            if (!Wait && NonCachedIo) {

                IrpContext->Union.NtfsIoContext->Wait.Async.Resource = Header->PagingIoResource;
            }

            //
            //  Set the flag in our IrpContext to indicate that we have entered
            //  write.
            //

            ASSERT( !FlagOn( IrpContext->TopLevelIrpContext->Flags,
                    IRP_CONTEXT_FLAG_WRITE_SEEN ));

            SetFlag( IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN );
            SetWriteSeen = TRUE;

            //
            //  Now post any Usn changes.  We will blindly make the call here, because
            //  usually all but the first call is in the fast path anyway.
            //  Checkpoint the transaction to reduce resource contention of the UsnJournal
            //  and Mft.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                ULONG Reason = 0;

                ASSERT( Vcb->UsnJournal != NULL );

                if (ByteRange > Header->FileSize.QuadPart) {
                    Reason |= USN_REASON_DATA_EXTEND;
                }
                if (StartingVbo < Header->FileSize.QuadPart) {
                    Reason |= USN_REASON_DATA_OVERWRITE;
                }

                NtfsPostUsnChange( IrpContext, Scb, Reason );
                if (IrpContext->TransactionId != 0) {
                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }

        } else {

            //
            //  Only do the check if we are the top-level Ntfs case.  In any
            //  recursive Ntfs case we don't perform a log-file full.
            //

            if (NtfsIsTopLevelRequest( IrpContext )) {

                if (NtfsIsSharedScb( Scb ) ||
                    ((Scb->Header.PagingIoResource != NULL) &&
                     NtfsIsSharedScbPagingIo( Scb ))) {

                    //
                    //  Don't try to do a clean checkpoint in this thread.
                    //

                    NtfsGetTopLevelContext()->TopLevelRequest = FALSE;
                }
            }

            //
            //  For all paging I/O, the correct resource has already been
            //  acquired shared - PagingIoResource if it exists, or else
            //  main Resource.  In some rare cases this is not currently
            //  true (shutdown & segment dereference thread), so we acquire
            //  shared here, but we starve exclusive in these rare cases
            //  to be a little more resilient to deadlocks!  Most of the
            //  time all we do is the test.
            //

            if ((Header->PagingIoResource != NULL) &&
                !NtfsIsSharedScbPagingIo( (PSCB) Header ) &&
                !NtfsIsSharedScb( (PSCB) Header ) ) {

                ExAcquireSharedStarveExclusive( Header->PagingIoResource, TRUE );
                PagingIoAcquired = TRUE;
            }

            //
            //  Now check if the attribute has been deleted or is on a dismounted volume.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                } else {
                    NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                }
            }

            //
            //  If this is async paging IO to a compressed file force it to be
            //  synchronous.
            //

            if (!Wait && (Scb->CompressionUnit != 0)) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    Wait = TRUE;
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                    RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                    //
                    //  Store whether we allocated this context structure in the structure
                    //  itself.
                    //

                    IrpContext->Union.NtfsIoContext->AllocatedContext =
                        BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                    KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                       NotificationEvent,
                                       FALSE );

                }
            }

            //
            //  Note that the lazy writer must not be allowed to try and
            //  acquire the resource exclusive.  This is not a problem since
            //  the lazy writer is paging IO and thus not allowed to extend
            //  file size, and is never the top level guy, thus not able to
            //  extend valid data length.
            //

            if ((Scb->LazyWriteThread[0]  == PsGetCurrentThread()) ||
                (Scb->LazyWriteThread[1]  == PsGetCurrentThread())) {

                DebugTrace( 0, Dbg, ("Lazy writer generated write\n") );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE );

                //
                //  If the temporary bit is set in the Scb then set the temporary
                //  bit in the file object.  In case the temporary bit has changed
                //  in the Scb, this is a good file object to fix it in!
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {
                    SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );
                } else {
                    ClearFlag( FileObject->Flags, FO_TEMPORARY_FILE );
                }

            //
            //  Test if we are the result of a recursive flush in the write path.  In
            //  that case we won't have to update valid data.
            //

            } else {

                //
                //  Check if we are recursing into write from a write via the
                //  cache manager.
                //

                if (FlagOn( IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN )) {

                    RecursiveWriteThrough = TRUE;

                    //
                    //  If the top level request is a write to the same file object
                    //  then set the write-through flag in the current Scb.  We
                    //  know the current request is not top-level because some
                    //  other write has already set the bit in the top IrpContext.
                    //

                    if ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_WRITE) &&
                        (IrpContext->TopLevelIrpContext->OriginatingIrp != NULL) &&
                        (FileObject->FsContext ==
                         IoGetCurrentIrpStackLocation( IrpContext->TopLevelIrpContext->OriginatingIrp )->FileObject->FsContext)) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH );
                    }

                //
                //  Otherwise set the flag in the top level IrpContext showing that
                //  we have entered write.
                //

                } else {

                    SetFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
                    SetWriteSeen = TRUE;

                }

            }

            //
            //  This could be someone who extends valid data or valid data to disk,
            //  like the Mapped Page Writer or a flush or the lazy writer
            //  writing the last page contianing the VDL, so we have to
            //  duplicate code from above in the non paging case to serialize this guy with I/O
            //  at the end of the file.  We do not extend valid data for
            //  metadata streams and need to eliminate them to avoid deadlocks
            //  later.
            //

            if (!RecursiveWriteThrough) {

                if (!FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE)) {

                    ASSERT(!WriteToEof);

                    //
                    //  Now synchronize with the FsRtl Header
                    //

                    NtfsAcquireFsrtlHeader( Scb );

                    //
                    //  Now see if we will change FileSize.  We have to do it now
                    //  so that our reads are not nooped.
                    //

                    if (ByteRange > Header->ValidDataLength.QuadPart) {

                        //
                        //  Our caller may already be synchronized with EOF.
                        //  The FcbWithPaging field in the top level IrpContext
                        //  will have either the current Fcb/Scb if so.
                        //

                        if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                            (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                            DoingIoAtEof = TRUE;
                            OldFileSize = Header->FileSize.QuadPart;

                        } else {

                            //
                            //  We can change FileSize and ValidDataLength if either, no one
                            //  else is now, or we are still extending after waiting.
                            //  We won't block the mapped page writer or deref seg thread on IoAtEof.                                  //  We also won't block on non-top level requests that are not recursing from the filesystem like the deref
                            //  seg thread. Mm initiated flushes are originally not top level but the top level
                            //  irp context is the current irp context. (as opposed to recursive file system writes
                            //  which are not top level and top level irp context is different from the current one)

                            if (FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE )) {

                                if (!OriginalTopLevel && NtfsIsTopLevelNtfs( IrpContext )) {

                                    NtfsReleaseFsrtlHeader( Scb );
                                    try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                                }

                                DoingIoAtEof = NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

                            } else {

                                DoingIoAtEof = TRUE;
                            }

                            //
                            //  Set the Flag if we are changing FileSize or ValidDataLength,
                            //  and save current values.
                            //

                            if (DoingIoAtEof) {

                                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
                                
#if (DBG || defined( NTFS_FREE_ASSERTS ))
                                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                                //
                                //  Store this in the IrpContext until commit or post
                                //

                                IrpContext->CleanupStructure = Scb;

                                OldFileSize = Header->FileSize.QuadPart;
#if (DBG || defined( NTFS_FREE_ASSERTS ))
                            } else {

                                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                            }
                        }

                    }
                    NtfsReleaseFsrtlHeader( Scb );
                }

                //
                //  Now that we're synchronized with doing io at eof we can check 
                //  the lazywrite's bounds
                //  

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                    //
                    //  The lazy writer should always be writing data ends on
                    //  or before the page containing ValidDataLength.  
                    //  In some cases the lazy writer may be writing beyond this point. 
                    //
                    //  1. The user may have truncated the size to zero through
                    //  SetAllocation but the page was already queued to the lazy
                    //  writer. In the typical case this write will be nooped
                    //
                    //  2. If there is a mapped section and the user actually modified 
                    //  the page in which VDL is contained but beyond VDL this page is written to disk
                    //  and VDL is updated. Otherwise it may never get written since the mapped writer
                    //  defers to the lazywriter
                    //
                    //  3. For all writes really beyond the page containing VDL when
                    //  the file is mapped since ValidDataLength is notupdated here a
                    //  subsequent write may zero this range and the data would be lost.  So 
                    //  We will return FILE_LOCK_CONFLICT to lazy writer if there is a mapped section and wait
                    //  for the mapped page writer to write this page (or any
                    //  page beyond this point).
                    //
                    //  Returning FILE_LOCK_CONFLICT should never cause us to lose
                    //  the data so we can err on the conservative side here.
                    //  There is nothing to worry about unless the file has been
                    //  mapped.
                    //
    
                    if (FlagOn( Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {
    
                        //
                        //  Fail if the start of this request is beyond valid data length.
                        //  Don't worry if this is an unsafe test.  MM and CC won't
                        //  throw this page away if it is really dirty.
                        //
    
                        if ((ByteRange > Header->ValidDataLength.QuadPart) &&
                            (StartingVbo < Header->FileSize.QuadPart)) {
    
                            //
                            //  It's OK if byte range is within the page containing valid data length.
                            //
    
                            if (ByteRange > ((Header->ValidDataLength.QuadPart + PAGE_SIZE - 1) & ~((LONGLONG) (PAGE_SIZE - 1)))) {
    
                                //
                                //  Don't flush this now.
                                //
    
                                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                            }
    
                        }
    
                    //
                    //  This is a stale callback by cc we can discard the data
                    //  this usually indicates a failed purge at some point during a truncate
                    //
    
                    } else if (ByteRange >= Header->ValidDataLength.QuadPart)  {

                        //
                        //  Trim the write down 
                        //  

                        ByteRange = Header->ValidDataLength.QuadPart;
                        ByteCount = ByteRange - StartingVbo;

                        //
                        //  If all of the write is beyond vdl just noop it
                        //

                        if (StartingVbo >= Header->ValidDataLength.QuadPart) {
                            DoingIoAtEof = FALSE;
                            Irp->IoStatus.Information = 0;
                            try_return( Status = STATUS_SUCCESS );
                        }
                    }
                }  //  lazy writer
            }  //  not recursive write through


            //
            //  If are paging io, then we do not want
            //  to write beyond end of file.  If the base is beyond Eof, we will just
            //  Noop the call.  If the transfer starts before Eof, but extends
            //  beyond, we will truncate the transfer to the last sector
            //  boundary.
            //
            //  Just in case this is paging io, limit write to file size.
            //  Otherwise, in case of write through, since Mm rounds up
            //  to a page, we might try to acquire the resource exclusive
            //  when our top level guy only acquired it shared. Thus, =><=.
            //

            NtfsAcquireFsrtlHeader( Scb );
            if (ByteRange > Header->FileSize.QuadPart) {

                if (StartingVbo >= Header->FileSize.QuadPart) {
                    DebugTrace( 0, Dbg, ("PagingIo started beyond EOF.\n") );

                    Irp->IoStatus.Information = 0;

                    //
                    //  Make sure we do not advance ValidDataLength!
                    //  We also haven't really written anything so set doingioateof back to
                    //  false
                    //

                    ByteRange = Header->ValidDataLength.QuadPart;
                    DoingIoAtEof = FALSE;

                    NtfsReleaseFsrtlHeader( Scb );

                    try_return( Status = STATUS_SUCCESS );

                } else {

                    DebugTrace( 0, Dbg, ("PagingIo extending beyond EOF.\n") );

#ifdef NTFS_RWC_DEBUG
                    if ((FileObject->SectionObjectPointer != &Scb->NonpagedScb->SegmentObject) &&
                        (StartingVbo < NtfsRWCHighThreshold) &&
                        (ByteRange > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( Scb );

                        NextBuffer->Operation = TrimCompressedWrite;
                        NextBuffer->Information = Scb->Header.FileSize.LowPart;
                        NextBuffer->FileOffset = (ULONG) StartingVbo;
                        NextBuffer->Length = (ULONG) ByteRange;
                    }
#endif
                    ByteCount = Header->FileSize.QuadPart - StartingVbo;
                    ByteRange = Header->FileSize.QuadPart;
                }
            }

            NtfsReleaseFsrtlHeader( Scb );

            //
            //  If there is a user-mapped file and a Usn Journal, then try to post a change.
            //  Checkpoint the transaction to reduce resource contention of the UsnJournal
            //  and Mft.
            //

            if (FlagOn(Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE) &&
                FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                ASSERT( Vcb->UsnJournal != NULL );

                NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );
                if (IrpContext->TransactionId != 0) {
                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }
        }

        ASSERT( PagingIo || FileObject->WriteAccess || RawEncryptedWrite );
        ASSERT( !(PagingIo && RawEncryptedWrite) );

        //
        //  If the Scb is uninitialized, we initialize it now.
        //  We skip this step for a $INDEX_ALLOCATION stream.  We need to
        //  protect ourselves in the case where an $INDEX_ALLOCATION
        //  stream was created and deleted in an aborted transaction.
        //  In that case we may get a lazy-writer call which will
        //  naturally be nooped below since the valid data length
        //  in the Scb is 0.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Acquire and drop the Scb when doing this.
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;

            } else {

                ASSERT( Header->ValidDataLength.QuadPart == Li0.QuadPart );
            }
        }

        //
        //  We assert that Paging Io writes will never WriteToEof.
        //

        ASSERT( !WriteToEof || !PagingIo );

        //
        //  We assert that we never get a non-cached io call for a non-$DATA,
        //  resident attribute.
        //

        ASSERTMSG( "Non-cached I/O call on resident system attribute\n",
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
                    NtfsIsTypeCodeLoggedUtilityStream( Scb->AttributeTypeCode ) ||
                    !NonCachedIo ||
                    !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

        //
        //  Here is the deal with ValidDataLength and FileSize:
        //
        //  Rule 1: PagingIo is never allowed to extend file size.
        //
        //  Rule 2: Only the top level requestor may extend Valid
        //          Data Length.  This may be paging IO, as when a
        //          a user maps a file, but will never be as a result
        //          of cache lazy writer writes since they are not the
        //          top level request.
        //
        //  Rule 3: If, using Rules 1 and 2, we decide we must extend
        //          file size or valid data, we take the Fcb exclusive.
        //

        //
        //  Now see if we are writing beyond valid data length, and thus
        //  maybe beyond the file size.  If so, then we must
        //  release the Fcb and reacquire it exclusive.  Note that it is
        //  important that when not writing beyond EOF that we check it
        //  while acquired shared and keep the FCB acquired, in case some
        //  turkey truncates the file.  Note that for paging Io we will
        //  already have acquired the file correctly.
        //

        if (DoingIoAtEof) {

            //
            //  If this was a non-cached asynchronous operation we will
            //  convert it to synchronous.  This is to allow the valid
            //  data length change to go out to disk and to fix the
            //  problem of the Fcb being in the exclusive Fcb list.
            //

            if (!Wait && NonCachedIo) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                //
                //  Store whether we allocated this context structure in the structure
                //  itself.
                //

                IrpContext->Union.NtfsIoContext->AllocatedContext =
                    BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                   NotificationEvent,
                                   FALSE );

            //
            //  If this is async Io to a compressed stream
            //  then we will make this look synchronous.
            //

            } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            }

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Acquire and drop the Scb when doing this.
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!PagingIo && (TypeOfOpen == UserFileOpen)) {

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsPrePostIrp );

            if (Status != STATUS_SUCCESS) {

                OplockPostIrp = TRUE;
                PostIrp = TRUE;
                try_return( NOTHING );
            }

            //
            //  This oplock call can affect whether fast IO is possible.
            //  We may have broken an oplock to no oplock held.  If the
            //  current state of the file is FastIoIsNotPossible then
            //  recheck the fast IO state.
            //

            if (Header->IsFastIoPossible == FastIoIsNotPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Header->IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            // We have to check for write access according to the current
            // state of the file locks, and set FileSize from the Fcb.
            //

            if ((Scb->ScbType.Data.FileLock != NULL) &&
                !FsRtlCheckLockForWriteAccess( Scb->ScbType.Data.FileLock, Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //  ASSERT( Header->ValidDataLength.QuadPart <= Header->FileSize.QuadPart);

        //
        //  If we are extending a file size, we may have to extend the allocation.
        //  For a non-resident attribute, this is a call to the add allocation
        //  routine.  For a resident attribute it depends on whether we
        //  can use the change attribute routine to automatically extend
        //  the attribute.
        //

        if (DoingIoAtEof && !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

            //
            //  EXTENDING THE FILE
            //

            //
            //  If the write goes beyond the allocation size, add some
            //  file allocation.
            //

            if (ByteRange > Header->AllocationSize.QuadPart) {

                BOOLEAN NonResidentPath;

                NtfsAcquireExclusiveScb( IrpContext, Scb );
                ScbAcquired = TRUE;

                NtfsMungeScbSnapshot( IrpContext, Scb, OldFileSize );

                //
                //  We have to deal with both the resident and non-resident
                //  case.  For the resident case we do the work here
                //  only if the new size is too large for the change attribute
                //  value routine.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                    PFILE_RECORD_SEGMENT_HEADER FileRecord;

                    NonResidentPath = FALSE;

                    //
                    //  Now call the attribute routine to change the value, remembering
                    //  the values up to the current valid data length.
                    //

                    NtfsInitializeAttributeContext( &AttrContext );
                    CleanupAttributeContext = TRUE;

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    FileRecord = NtfsContainingFileRecord( &AttrContext );
                    Attribute = NtfsFoundAttribute( &AttrContext );
                    LlTemp1 = (LONGLONG) (Vcb->BytesPerFileRecordSegment
                                                   - FileRecord->FirstFreeByte
                                                   + QuadAlign( Attribute->Form.Resident.ValueLength ));

                    //
                    //  If the new attribute size will not fit then we have to be
                    //  prepared to go non-resident.  If the byte range takes more
                    //  more than 32 bits or this attribute is big enough to move
                    //  then it will go non-resident.  Otherwise we simply may
                    //  end up moving another attribute or splitting the file
                    //  record.
                    //

                    //
                    //  Note, there is an infinitesimal chance that before the Lazy Writer
                    //  writes the data for an attribute which is extending, but fits
                    //  when we check it here, that some other attribute will grow,
                    //  and this attribute no longer fits.  If in addition, the disk
                    //  is full, then the Lazy Writer will fail to allocate space
                    //  for the data when it gets around to writing.  This is
                    //  incredibly unlikely, and not fatal; the Lazy Writer gets an
                    //  error rather than the user.  What we are trying to avoid is
                    //  having to update the attribute every time on small writes
                    //  (also see comments below in NONCACHED RESIDENT ATTRIBUTE case).
                    //

                    if (ByteRange > LlTemp1) {

                        //
                        //  Go ahead and convert this attribute to non-resident.
                        //  Then take the non-resident path below.  There is a chance
                        //  that there was a more suitable candidate to move non-resident
                        //  but we don't want to change the file size until we copy
                        //  the user's data into the cache in case the buffer is
                        //  corrupt.
                        //

                        //
                        //  We must have the paging Io resource exclusive to prevent a
                        //  collided page wait while doing the convert to non-resident.
                        //

                        if (!PagingIo &&
                            !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                            (Scb->Header.PagingIoResource != NULL)) {

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  Attribute,
                                                  NonCachedIo,
                                                  &AttrContext );

                        NonResidentPath = TRUE;

                    //
                    //  If there is room for the data, we will write a zero
                    //  to the last byte to reserve the space since the
                    //  Lazy Writer cannot grow the attribute with shared
                    //  access.
                    //

                    } else {

                        //
                        //  The attribute will stay resident because we
                        //  have already checked that it will fit.  It will
                        //  not update the file size and valid data size in
                        //  the Scb.
                        //

                        NtfsChangeAttributeValue( IrpContext,
                                                  Fcb,
                                                  (ULONG) ByteRange,
                                                  NULL,
                                                  0,
                                                  TRUE,
                                                  FALSE,
                                                  FALSE,
                                                  FALSE,
                                                  &AttrContext );

                        Header->AllocationSize.LowPart = QuadAlign( (ULONG)ByteRange );
                        Scb->TotalAllocated = Header->AllocationSize.QuadPart;
                    }

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    CleanupAttributeContext = FALSE;

                } else {

                    NonResidentPath = TRUE;
                }

                //
                //  Note that we may have gotten all the space we need when
                //  we converted to nonresident above, so we have to check
                //  again if we are extending.
                //

                if (NonResidentPath &&
                    ByteRange > Scb->Header.AllocationSize.QuadPart) {

                    BOOLEAN AskForMore = TRUE;

                    //
                    //  Assume we start allocating from the current allocation size unless we're
                    //  sparse in which case we'll allocate from the starting compression unit if
                    //  its beyond vdl
                    //

                    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                        (BlockAlignTruncate( StartingVbo, (LONG)Scb->CompressionUnit) <= Scb->Header.ValidDataLength.QuadPart )) {
                        
                        LlTemp1 = Scb->Header.AllocationSize.QuadPart;
                    } else {
                        LlTemp1 = BlockAlignTruncate( StartingVbo, (LONG)Scb->CompressionUnit );
                    }

                    //
                    //  If we are not writing compressed then we may need to allocate precisely.
                    //  This includes the uncompressed sparse file case
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

                        //
                        //  If there is a compression unit then we could be in the process of
                        //  decompressing.  Allocate precisely in this case because we don't
                        //  want to leave any holes.  Specifically the user may have truncated
                        //  the file and is now regenerating it yet the clear compression operation
                        //  has already passed this point in the file (and dropped all resources).
                        //  No one will go back to cleanup the allocation if we leave a hole now.
                        //

                        if (Scb->CompressionUnit != 0) {

                            LlTemp2 = ByteRange + Scb->CompressionUnit - 1;
                            ((PLARGE_INTEGER) &LlTemp2)->LowPart &= ~(Scb->CompressionUnit - 1);
                            LlTemp2 -= LlTemp1;
                            AskForMore = FALSE;

                        //
                        //  Allocate through ByteRange.
                        //

                        } else {

                            LlTemp2 = ByteRange - LlTemp1;
                        }

                    //
                    //  If the file is compressed, we want to limit how far we are
                    //  willing to go beyond ValidDataLength, because we would just
                    //  have to throw that space away anyway in NtfsZeroData.  If
                    //  we would have to zero more than two compression units (same
                    //  limit as NtfsZeroData), then just allocate space where we
                    //  need it.
                    //

                    } else {

                        if ((StartingVbo - Header->ValidDataLength.QuadPart) > (LONGLONG) (Scb->CompressionUnit * 2)) {

                            ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ));

                            LlTemp1 = StartingVbo;
                            ((PLARGE_INTEGER) &LlTemp1)->LowPart &= ~(Scb->CompressionUnit - 1);
                        }

                        //
                        //  Allocate to the end of ByteRange.
                        //

                        LlTemp2 = ByteRange - LlTemp1;
                    }

                    //
                    //
                    //  This will add the allocation and modify the allocation
                    //  size in the Scb.
                    //

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytesTruncate( Vcb, LlTemp1 ),
                                       LlClustersFromBytes( Vcb, LlTemp2 ),
                                       AskForMore,
                                       Ccb );

                    //
                    //  Assert that the allocation worked
                    //

                    ASSERT( Header->AllocationSize.QuadPart >= ByteRange ||
                            (Scb->CompressionUnit != 0));

                    SetFlag(Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE);

                    //
                    //  If this is a sparse file lets pad the allocation by adding a
                    //  hole at the end of the allocation.  This will let us utilize
                    //  the fast IO path.
                    //

                    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        LlTemp2 = Int64ShllMod32( LlTemp2, 3 );

                        if (MAXFILESIZE - Header->AllocationSize.QuadPart > LlTemp2) {

                            NtfsAddSparseAllocation( IrpContext,
                                                     FileObject,
                                                     Scb,
                                                     Header->AllocationSize.QuadPart,
                                                     LlTemp2 );
                        }
                    }
                }

                //
                //  Now that we have grown the attribute, it is important to
                //  checkpoint the current transaction and free all main resources
                //  to avoid the tc type deadlocks.  Note that the extend is ok
                //  to stand in its own right, and the stream will be truncated
                //  on close anyway.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs later.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                //
                //  Growing allocation can change file size (in ChangeAttributeValue).
                //  Make sure we know the correct value for file size to restore.
                //

                OldFileSize = Header->FileSize.QuadPart;
                while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                //
                //  Go through and free any Scb's in the queue of shared
                //  Scb's for transactions.
                //

                if (IrpContext->SharedScb != NULL) {

                    NtfsReleaseSharedResources( IrpContext );
                }

                ScbAcquired = FALSE;
            }

            //
            //  Now synchronize with the FsRtl Header and set FileSize
            //  now so that our reads will not get truncated.
            //

            NtfsAcquireFsrtlHeader( Scb );
            if (ByteRange > Header->FileSize.QuadPart) {
                ASSERT( ByteRange <= Header->AllocationSize.QuadPart );
                Header->FileSize.QuadPart = ByteRange;
                SetFlag( UserFileObject->Flags, FO_FILE_SIZE_CHANGED );
            }
            NtfsReleaseFsrtlHeader( Scb );
        }


        //
        //  HANDLE THE NONCACHED RESIDENT ATTRIBUTE CASE
        //
        //  We let the cached case take the normal path for the following
        //  reasons:
        //
        //    o To insure data coherency if a user maps the file
        //    o To get a page in the cache to keep the Fcb around
        //    o So the data can be accessed via the Fast I/O path
        //    o To reduce the number of calls to NtfsChangeAttributeValue,
        //      to infrequent calls from the Lazy Writer.  Calls to CcCopyWrite
        //      are much cheaper.  With any luck, if the attribute actually stays
        //      resident, we will only have to update it (and log it) once
        //      when the Lazy Writer gets around to the data.
        //
        //  The disadvantage is the overhead to fault the data in the
        //  first time, but we may be able to do this with asynchronous
        //  read ahead.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY )
            && NonCachedIo) {

            //
            //  The attribute is already resident and we have already tested
            //  if we are going past the end of the file.
            //

            DebugTrace( 0, Dbg, ("Resident attribute write\n") );

            //
            //  If this buffer is not in system space then we can't
            //  trust it.  In that case we will allocate a temporary buffer
            //  and copy the user's data to it.
            //

            SystemBuffer = NtfsMapUserBuffer( Irp );

            if (!PagingIo && (Irp->RequestorMode != KernelMode)) {

                SafeBuffer = NtfsAllocatePool( NonPagedPool,
                                                (ULONG) ByteCount );

                try {

                    RtlCopyMemory( SafeBuffer, SystemBuffer, (ULONG)ByteCount );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                SystemBuffer = SafeBuffer;
            }

            //
            //  Make sure we don't have any Mft records.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Unlike the other cases, we're already holding the Scb, so
                //  there's no need to acquire & drop it around the Update call.
                //

                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs later.
                //

                NtfsPurgeFileRecordCache( IrpContext );
            }

            NtfsMungeScbSnapshot( IrpContext, Scb, OldFileSize );

            //
            //  Now see if the file is still resident, and if not
            //  fall through below.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  If this Scb is for an $EA attribute which is now resident then
                //  we don't want to write the data into the attribute.  All resident
                //  EA's are modified directly.
                //

                if (Scb->AttributeTypeCode != $EA) {

                    NtfsInitializeAttributeContext( &AttrContext );
                    CleanupAttributeContext = TRUE;

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    //
                    //  The attribute should already be optionally extended,
                    //  just write the data to it now.
                    //

                    NtfsChangeAttributeValue( IrpContext,
                                              Fcb,
                                              ((ULONG)StartingVbo),
                                              SystemBuffer,
                                              (ULONG)ByteCount,
                                              (BOOLEAN)((((ULONG)StartingVbo) + (ULONG)ByteCount) >
                                                        Attribute->Form.Resident.ValueLength),
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              &AttrContext );
                }

                //
                //  Make sure the cache FileSizes are updated if this is not paging I/O.
                //

                if (!PagingIo && DoingIoAtEof) {
                    NtfsSetBothCacheSizes( FileObject,
                                           (PCC_FILE_SIZES)&Header->AllocationSize,
                                           Scb );
                }

                Irp->IoStatus.Information = (ULONG)ByteCount;

                try_return( Status = STATUS_SUCCESS );

            //
            //  Gee, someone else made the file nonresident, so we can just
            //  free the resource and get on with life.
            //

            } else {
                NtfsReleaseScb( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  HANDLE THE NON-CACHED CASE
        //

        if (NonCachedIo) {

            ULONG SectorSize;
            ULONG BytesToWrite;

            //
            //  Make sure the cache FileSizes are updated if this is not paging I/O.
            //

            if (!PagingIo && DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       Scb );
            }

            //
            //  Get the sector size
            //

            SectorSize = Vcb->BytesPerSector;

            //
            //  Round up to a sector boundry
            //

            BytesToWrite = ((ULONG)ByteCount + (SectorSize - 1))
                           & ~(SectorSize - 1);

            //
            //  All requests should be well formed and
            //  make sure we don't wipe out any data
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                if ((((ULONG)StartingVbo) & (SectorSize - 1))

                    || ((BytesToWrite != (ULONG)ByteCount)
                        && ByteRange < Header->ValidDataLength.QuadPart )) {

                    //**** we only reach this path via fast I/O and by returning not implemented we
                    //**** force it to return to use via slow I/O

                    DebugTrace( 0, Dbg, ("NtfsCommonWrite -> STATUS_NOT_IMPLEMENTED\n") );

                    try_return( Status = STATUS_NOT_IMPLEMENTED );
                }
            }

            //
            //  If this is a write to an encrypted file then make it synchronous.  We
            //  need to do this so that the encryption driver has a thread to run in.
            //

            if ((Scb->EncryptionContext != NULL) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) &&
                (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
                NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                //
                //  Store whether we allocated this context structure in the structure
                //  itself.
                //

                IrpContext->Union.NtfsIoContext->AllocatedContext =
                    BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                   NotificationEvent,
                                   FALSE );
            }

            //
            // If this noncached transfer is at least one sector beyond
            // the current ValidDataLength in the Scb, then we have to
            // zero the sectors in between.  This can happen if the user
            // has opened the file noncached, or if the user has mapped
            // the file and modified a page beyond ValidDataLength.  It
            // *cannot* happen if the user opened the file cached, because
            // ValidDataLength in the Fcb is updated when he does the cached
            // write (we also zero data in the cache at that time), and
            // therefore, we will bypass this action when the data
            // is ultimately written through (by the Lazy Writer).
            //
            //  For the paging file we don't care about security (ie.
            //  stale data), do don't bother zeroing.
            //
            //  We can actually get writes wholly beyond valid data length
            //  from the LazyWriter because of paging Io decoupling.
            //
            //  We drop this zeroing on the floor in any case where this
            //  request is a recursive write caused by a flush from a higher level write.
            //

            if (Header->ValidDataLength.QuadPart > Scb->ValidDataToDisk) {
                LlTemp1 = Header->ValidDataLength.QuadPart;
            } else {

                //
                //  This can only occur for compressed files
                //  

                LlTemp1 = Scb->ValidDataToDisk;
            }

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) &&
                !RecursiveWriteThrough &&
                (StartingVbo > LlTemp1)) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags;

                    CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                    TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, LlTemp1, StartingVbo - LlTemp1, 0);
                }
#endif

                if (!NtfsZeroData( IrpContext,
                                   Scb,
                                   FileObject,
                                   LlTemp1,
                                   StartingVbo - LlTemp1,
                                   &OldFileSize )) {
#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, 0 );
                    }
#endif
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, 0 );
                }
#endif
            }

            //
            //  If this Scb uses update sequence protection, we need to transform
            //  the blocks to a protected version.  We first allocate an auxilary
            //  buffer and Mdl.  Then we copy the data to this buffer and
            //  transform it.  Finally we attach this Mdl to the Irp and use
            //  it to perform the Io.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT )) {

                TempLength = BytesToWrite;

                //
                //  Find the system buffer for this request and initialize the
                //  local state.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp );

                OriginalMdl = Irp->MdlAddress;
                OriginalBuffer = Irp->UserBuffer;
                NewBuffer = NULL;

                //
                //  Protect this operation with a try-finally.
                //

                try {

                    //
                    //  If this is the Mft Scb and the range of bytes falls into
                    //  the range for the Mirror Mft, we generate a write to
                    //  the mirror as well.  Don't do this if we detected a problem
                    //  with the Mft when analyzing the first file records.  We
                    //  can use the presence of the version number in the Vcb
                    //  to tell us this.
                    //

                    if ((Scb == Vcb->MftScb) &&
                        (StartingVbo < Vcb->Mft2Scb->Header.FileSize.QuadPart) &&
                        (Vcb->MajorVersion != 0)) {

                        LlTemp1 = Vcb->Mft2Scb->Header.FileSize.QuadPart - StartingVbo;

                        if ((ULONG)LlTemp1 > BytesToWrite) {

                            (ULONG)LlTemp1 = BytesToWrite;
                        }

                        CcCopyWrite( Vcb->Mft2Scb->FileObject,
                                     (PLARGE_INTEGER)&StartingVbo,
                                     (ULONG)LlTemp1,
                                     TRUE,
                                     SystemBuffer );

                        //
                        //  Now flush this to disk.
                        //

                        CcFlushCache( &Vcb->Mft2Scb->NonpagedScb->SegmentObject,
                                      (PLARGE_INTEGER)&StartingVbo,
                                      (ULONG)LlTemp1,
                                      &Irp->IoStatus );

                        NtfsCleanupTransaction( IrpContext, Irp->IoStatus.Status, TRUE );
                    }

                    //
                    //  Start by allocating buffer and Mdl.
                    //

                    NtfsCreateMdlAndBuffer( IrpContext,
                                            Scb,
                                            RESERVED_BUFFER_ONE_NEEDED,
                                            &TempLength,
                                            &NewMdl,
                                            &NewBuffer );

                    //
                    //  Now transform and write out the original stream.
                    //

                    RtlCopyMemory( NewBuffer, SystemBuffer, BytesToWrite );

                    //
                    //  We copy our Mdl into the Irp and then perform the Io.
                    //

                    Irp->MdlAddress = NewMdl;
                    Irp->UserBuffer = NewBuffer;

                    //
                    //  Now increment the sequence number in both the original
                    //  and copied buffer, and transform the copied buffer.
                    //  If this is the LogFile then adjust the range of the transform.
                    //

                    if ((PAGE_SIZE != LFS_DEFAULT_LOG_PAGE_SIZE) &&
                        (Scb == Vcb->LogFileScb)) {

                        LONGLONG LfsFileOffset;
                        ULONG LfsLength;
                        ULONG LfsBias;

                        LfsFileOffset = StartingVbo;
                        LfsLength = BytesToWrite;

                        LfsCheckWriteRange( &Vcb->LfsWriteData, &LfsFileOffset, &LfsLength );
                        LfsBias = (ULONG) (LfsFileOffset - StartingVbo);

                        NtfsTransformUsaBlock( Scb,
                                               Add2Ptr( SystemBuffer, LfsBias ),
                                               Add2Ptr( NewBuffer, LfsBias ),
                                               LfsLength );

                    } else {

                        NtfsTransformUsaBlock( Scb,
                                               SystemBuffer,
                                               NewBuffer,
                                               BytesToWrite );
                    }

                    ASSERT( Wait );
                    NtfsNonCachedIo( IrpContext,
                                     Irp,
                                     Scb,
                                     StartingVbo,
                                     BytesToWrite,
                                     0 );

                } finally {

                    //
                    //  In all cases we restore the user's Mdl and cleanup
                    //  our Mdl and buffer.
                    //

                    if (NewBuffer != NULL) {

                        Irp->MdlAddress = OriginalMdl;
                        Irp->UserBuffer = OriginalBuffer;

                        NtfsDeleteMdlAndBuffer( NewMdl, NewBuffer );
                    }
                }

            //
            //  Otherwise we simply perform the Io.
            //

            } else {

                ULONG StreamFlags = 0;

                //
                //  If the file has an UpdateLsn, then flush the log file before
                //  allowing the data to go out.  The UpdateLsn is synchronized
                //  with the FcbLock.  However, since we are in the process of
                //  doing a write, if we see a 0 in our unsafe test, it is ok
                //  to procede without an LfsFlush.
                //

                if (Fcb->UpdateLsn.QuadPart != 0) {

                    LSN UpdateLsn;

                    NtfsLockFcb( IrpContext, Fcb );
                    UpdateLsn = Fcb->UpdateLsn;
                    Fcb->UpdateLsn.QuadPart = 0;
                    NtfsUnlockFcb( IrpContext, Fcb );
                    LfsFlushToLsn( Vcb->LogHandle, UpdateLsn );
                }

                //
                //  Remember that from this point on we need to restore ValidDataToDisk.
                //  (Doing so earlier can get us into deadlocks if we hit the finally
                //  clause holding the Mft & UsnJournal.)
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                    RestoreValidDataToDisk = TRUE;
                }
                

                //
                //  Let's decide if there's anything special we need to tell NonCachedIo
                //  about this stream and how we're accessing it.
                //

                if (FileObject->SectionObjectPointer != &Scb->NonpagedScb->SegmentObject) {

                    SetFlag( StreamFlags, COMPRESSED_STREAM );
                }

                if (RawEncryptedWrite) {

                    SetFlag( StreamFlags, ENCRYPTED_STREAM );
                }

#ifdef NTFS_RWC_DEBUG
                if (FlagOn( StreamFlags, COMPRESSED_STREAM )) {

                    if ((StartingVbo < NtfsRWCHighThreshold) &&
                        (StartingVbo + BytesToWrite > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( Scb );

                        NextBuffer->Operation = WriteCompressed;
                        NextBuffer->Information = 0;
                        NextBuffer->FileOffset = (ULONG) StartingVbo;
                        NextBuffer->Length = (ULONG) BytesToWrite;
                    }
                }
#endif

                Status = NtfsNonCachedIo( IrpContext,
                                          Irp,
                                          Scb,
                                          StartingVbo,
                                          BytesToWrite,
                                          StreamFlags );

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags;

                    CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                    FsRtlLogSyscacheEvent( Scb, SCE_WRITE, Flags, StartingVbo, BytesToWrite, Status );
                }
#endif

#ifdef SYSCACHE
                if ((NodeType(Scb) == NTFS_NTC_SCB_DATA) &&
                    FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE)) {

                    PULONG WriteMask;
                    ULONG Len;
                    ULONG Off = (ULONG)StartingVbo;

                    //
                    //  If this attribute is encrypted, we can't verify the data
                    //  right now, since it has already been encrypted.
                    //

                    if (FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
//                        !FlagOn(Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED) &&
                        NtfsIsTypeCodeUserData(Scb->AttributeTypeCode)) {

                        PSYSCACHE_EVENT SyscacheEvent;

                        FsRtlVerifySyscacheData( FileObject,
                                                 MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority ),
                                                 BytesToWrite,
                                                 (ULONG)StartingVbo );

                        SyscacheEvent = NtfsAllocatePool( PagedPool, sizeof( SYSCACHE_EVENT ) );

                        if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                            SyscacheEvent->EventTypeCode = SYSCACHE_PAGING_WRITE;

                        } else {

                            SyscacheEvent->EventTypeCode = SYSCACHE_NORMAL_WRITE;
                        }

                        SyscacheEvent->Data1 = StartingVbo;
                        SyscacheEvent->Data2 = (LONGLONG) BytesToWrite;

                        InsertTailList( &Scb->ScbType.Data.SyscacheEventList, &SyscacheEvent->EventList );
                    }

                    WriteMask = Scb->ScbType.Data.WriteMask;
                    if (WriteMask == NULL) {
                        WriteMask = NtfsAllocatePool( NonPagedPool, (((0x2000000) / PAGE_SIZE) / 8) );
                        Scb->ScbType.Data.WriteMask = WriteMask;
                        RtlZeroMemory(WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
                    }

                    if (Off < 0x2000000) {
                        Len = BytesToWrite;
                        if ((Off + Len) > 0x2000000) {
                            Len = 0x2000000 - Off;
                        }
                        while (Len != 0) {
                            WriteMask[(Off / PAGE_SIZE)/32] |= (1 << ((Off / PAGE_SIZE) % 32));

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
                }
#endif

                if (Status == STATUS_PENDING) {

                    IrpContext->Union.NtfsIoContext = NULL;
                    PagingIoAcquired = FALSE;
                    Irp = NULL;

                    try_return( Status );
                }
            }

            //
            //  Show that we want to immediately update the Mft.
            //

            UpdateMft = TRUE;

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext, Status, STATUS_UNEXPECTED_IO_ERROR );

            } else {

                //
                //  Else set the context block to reflect the entire write
                //  Also assert we got how many bytes we asked for.
                //

                ASSERT( Irp->IoStatus.Information == BytesToWrite );

                Irp->IoStatus.Information = (ULONG)ByteCount;
            }

            //
            // The transfer is either complete, or the Iosb contains the
            // appropriate status.
            //

            try_return( Status );

        } // if No Intermediate Buffering


        //
        //  HANDLE THE CACHED CASE
        //

        ASSERT( !PagingIo );

        //
        //  Remember if we need to update the Mft.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            UpdateMft = BooleanFlagOn(IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH);
        }

        //
        //  If this write is beyond (valid data length / valid data to disk), then we
        //  must zero the data in between. Only compressed files have a nonzero VDD
        //

        if (Header->ValidDataLength.QuadPart > Scb->ValidDataToDisk) {
            ZeroStart = Header->ValidDataLength.QuadPart;
        } else {
            ZeroStart = Scb->ValidDataToDisk;
        }
        ZeroLength = StartingVbo - ZeroStart;

        //
        // We delay setting up the file cache until now, in case the
        // caller never does any I/O to the file, and thus
        // FileObject->PrivateCacheMap == NULL.  Don't cache the normal
        // stream unless we need to.
        //

        if ((FileObject->PrivateCacheMap == NULL)

                &&

            !FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED) || (ZeroLength > 0)) {

            DebugTrace( 0, Dbg, ("Initialize cache mapping.\n") );

            //
            //  Get the file allocation size, and if it is less than
            //  the file size, raise file corrupt error.
            //

            if (Header->FileSize.QuadPart > Header->AllocationSize.QuadPart) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Now initialize the cache map.  Notice that we may extending
            //  the ValidDataLength with this write call.  At this point
            //  we haven't updated the ValidDataLength in the Scb header.
            //  This way we will get a call from the cache manager
            //  when the lazy writer writes out the data.
            //

            //
            //  Make sure we are serialized with the FileSizes, and
            //  will remove this condition if we abort.
            //

            if (!DoingIoAtEof) {
                FsRtlLockFsRtlHeader( Header );
                IrpContext->CleanupStructure = Scb;
            }

            CcInitializeCacheMap( FileObject,
                                  (PCC_FILE_SIZES)&Header->AllocationSize,
                                  FALSE,
                                  &NtfsData.CacheManagerCallbacks,
                                  Scb );

            if (!DoingIoAtEof) {
                FsRtlUnlockFsRtlHeader( Header );
                IrpContext->CleanupStructure = NULL;
            }

            CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Make sure the cache FileSizes are updated.
        //

        if (DoingIoAtEof) {
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Header->AllocationSize,
                                   Scb );
        }

        if (ZeroLength > 0) {

            //
            //  If the caller is writing zeros way beyond ValidDataLength,
            //  then noop it.  We need to wrap the compare in a try-except
            //  to protect ourselves from an invalid user buffer.
            //

            if ((ZeroLength > PAGE_SIZE) &&
                (ByteCount <= sizeof( LARGE_INTEGER ))) {

                ULONG Zeroes;

                try {

                    Zeroes = RtlEqualMemory( NtfsMapUserBuffer( Irp ),
                                             &Li0,
                                             (ULONG)ByteCount );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                if (Zeroes) {

                    ByteRange = Header->ValidDataLength.QuadPart;
                    Irp->IoStatus.Information = (ULONG)ByteCount;
                    try_return( Status = STATUS_SUCCESS );
                }
            }

            //
            // Call the Cache Manager to zero the data.
            //

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                ULONG Flags;

                CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_ZERO_C, Flags, ZeroStart, ZeroLength, StartingVbo );
            }
#endif


            if (!NtfsZeroData( IrpContext,
                               Scb,
                               FileObject,
                               ZeroStart,
                               ZeroLength,
                               &OldFileSize )) {
#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, SCE_FLAG_CANT_WAIT );
                }
#endif
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }


        //
        //  For a compressed stream, we must first reserve the space.
        //

        if ((Scb->CompressionUnit != 0) &&
            !FlagOn(Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE) &&
            !NtfsReserveClusters(IrpContext, Scb, StartingVbo, (ULONG)ByteCount)) {

            //
            //  If the file is only sparse and is fully allocated then there is no
            //  reason to reserve.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                VCN CurrentVcn;
                LCN CurrentLcn;
                ULONGLONG RemainingClusters;
                ULONGLONG CurrentClusters;

                CurrentVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );
                RemainingClusters = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );

                while (NtfsLookupAllocation( IrpContext,
                                             Scb,
                                             CurrentVcn,
                                             &CurrentLcn,
                                             &CurrentClusters,
                                             NULL,
                                             NULL )) {

                    if (CurrentClusters >= RemainingClusters) {

                        RemainingClusters = 0;
                        break;
                    }

                    CurrentVcn += CurrentClusters;
                    RemainingClusters -= CurrentClusters;
                }

                if (RemainingClusters != 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

            } else {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }
        }

        //
        //  We need to go through the cache for this
        //  file object.  First handle the noncompressed calls.
        //

        if (!FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {

            //
            //  If there is a compressed section, we have to do cache coherency for
            //  that stream, and loop here to do a Cache Manager view at a time.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = StartingVbo;
                ULONG LocalLength;
                ULONG LengthLeft = (ULONG)ByteCount;

                //
                //  Create the compressed stream if not there.
                //

                if (Header->FileObjectC == NULL) {
                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );
                }

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp );
                }

                //
                //  We must loop to do a view at a time, because that is how much
                //  we synchronize at once below.
                //

                do {

                    //
                    //  Calculate length left in view.
                    //

                    LocalLength = (ULONG)LengthLeft;
                    if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                        LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                    }

                    //
                    //  Synchronize the current view.
                    //

                    Status = NtfsSynchronizeUncompressedIo( Scb,
                                                            &LocalOffset,
                                                            LocalLength,
                                                            TRUE,
                                                            &CompressionSync );

                    //
                    //  If we successfully synchronized, then do a piece of the transfer.
                    //

                    if (NT_SUCCESS(Status)) {

                        if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                            DebugTrace( 0, Dbg, ("Cached write.\n") );

                            //
                            // Do the write, possibly writing through
                            //
                            //  Make sure we don't have any Mft records.
                            //

                            NtfsPurgeFileRecordCache( IrpContext );

                            if (!CcCopyWrite( FileObject,
                                              (PLARGE_INTEGER)&LocalOffset,
                                              LocalLength,
                                              (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                              SystemBuffer )) {

                                DebugTrace( 0, Dbg, ("Cached Write could not wait\n") );

                                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                            } else if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                                NtfsRaiseStatus( IrpContext, IrpContext->ExceptionStatus, NULL, NULL );
                            }

                            Irp->IoStatus.Status = STATUS_SUCCESS;

                            SystemBuffer = Add2Ptr( SystemBuffer, LocalLength );

                        } else {

                            //
                            //  DO AN MDL WRITE
                            //

                            DebugTrace( 0, Dbg, ("MDL write.\n") );

                            ASSERT( FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );

                            //
                            //  If we got this far and then hit a log file full the Mdl will
                            //  already be present.
                            //

                            ASSERT((Irp->MdlAddress == NULL) || (LocalOffset != StartingVbo));

#ifdef NTFS_RWCMP_TRACE
                            if (NtfsCompressionTrace && IsSyscache(Header)) {
                                DbgPrint("CcMdlWrite: FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                            }
#endif

                            CcPrepareMdlWrite( FileObject,
                                               (PLARGE_INTEGER)&LocalOffset,
                                               LocalLength,
                                               &Irp->MdlAddress,
                                               &Irp->IoStatus );
                        }

                        Status = Irp->IoStatus.Status;

                        LocalOffset += LocalLength;
                        LengthLeft -= LocalLength;
                    }

                } while ((LengthLeft != 0) && NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {
                    Irp->IoStatus.Information = (ULONG)ByteCount;
                }

                try_return( Status );
            }
#endif

            //
            // DO A NORMAL CACHED WRITE, if the MDL bit is not set,
            //

            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                DebugTrace( 0, Dbg, ("Cached write.\n") );

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp );

                //
                // Do the write, possibly writing through
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                if (!CcCopyWrite( FileObject,
                                  (PLARGE_INTEGER)&StartingVbo,
                                  (ULONG)ByteCount,
                                  (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                  SystemBuffer )) {

                    DebugTrace( 0, Dbg, ("Cached Write could not wait\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                } else if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                    NtfsRaiseStatus( IrpContext, IrpContext->ExceptionStatus, NULL, NULL );
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG)ByteCount;

                try_return( Status = STATUS_SUCCESS );

            } else {

                //
                //  DO AN MDL WRITE
                //

                DebugTrace( 0, Dbg, ("MDL write.\n") );

                ASSERT( FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );

                //
                //  If we got this far and then hit a log file full the Mdl will
                //  already be present.
                //

                ASSERT(Irp->MdlAddress == NULL);

#ifdef NTFS_RWCMP_TRACE
                if (NtfsCompressionTrace && IsSyscache(Header)) {
                    DbgPrint("CcMdlWrite: FO = %08lx, Len = %08lx\n", (ULONG)StartingVbo, (ULONG)ByteCount );
                }
#endif

                CcPrepareMdlWrite( FileObject,
                                   (PLARGE_INTEGER)&StartingVbo,
                                   (ULONG)ByteCount,
                                   &Irp->MdlAddress,
                                   &Irp->IoStatus );

                Status = Irp->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );
            }

        //
        //  Handle the compressed calls.
        //

        } else {

#ifdef  COMPRESS_ON_WIRE

            ASSERT((StartingVbo & (NTFS_CHUNK_SIZE - 1)) == 0);

            //
            //  Get out if COW is not supported.
            //

            if (!NtfsEnableCompressedIO) {

                NtfsRaiseStatus( IrpContext, STATUS_UNSUPPORTED_COMPRESSION, NULL, NULL );
            }


            if ((Header->FileObjectC == NULL) ||
                (Header->FileObjectC->PrivateCacheMap == NULL)) {

                        //
                //  Don't do compressed IO on a stream which is changing its
                //  compression state.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                    NtfsRaiseStatus( IrpContext, STATUS_UNSUPPORTED_COMPRESSION, NULL, NULL );
                }

                //
                //  Make sure we are serialized with the FileSizes, and
                //  will remove this condition if we abort.
                //

                if (!DoingIoAtEof) {
                    FsRtlLockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = Scb;
                }

                NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                if (!DoingIoAtEof) {
                    FsRtlUnlockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = NULL;
                }
            }

            //
            //  Make sure the cache FileSizes are updated.
            //

            if (DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       Scb );
            }

            //
            //  Assume success.
            //

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG)(ByteRange - StartingVbo);

            //
            //  Based on the Mdl minor function, set up the appropriate
            //  parameters for the call below.  (NewMdl is not exactly the
            //  right type, so it is cast...)
            //

            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp );
                NewMdl = NULL;

            } else {

                //
                //  We will deliver the Mdl directly to the Irp.
                //

                SystemBuffer = NULL;
                NewMdl = (PMDL)&Irp->MdlAddress;
            }

            CompressedDataInfo = (PCOMPRESSED_DATA_INFO)IrpContext->Union.AuxiliaryBuffer->Buffer;

            //
            //  Calculate the compression unit and chunk sizes.
            //

            CompressionUnitSize = Scb->CompressionUnit;
            ChunkSize = 1 << CompressedDataInfo->ChunkShift;

            //
            //  See if the engine matches, so we can pass that on to the
            //  compressed write routine.
            //

            EngineMatches =
              ((CompressedDataInfo->CompressionFormatAndEngine == ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1)) &&
               (CompressedDataInfo->ChunkShift == NTFS_CHUNK_SHIFT));

            //
            //  Do the compressed write in common code with the Fast Io path.
            //  We do it from a loop because we may need to create the other
            //  data stream.
            //

            while (TRUE) {

                Status = NtfsCompressedCopyWrite( FileObject,
                                                  (PLARGE_INTEGER)&StartingVbo,
                                                  (ULONG)ByteCount,
                                                  SystemBuffer,
                                                  (PMDL *)NewMdl,
                                                  CompressedDataInfo,
                                                  IoGetRelatedDeviceObject(FileObject),
                                                  Header,
                                                  Scb->CompressionUnit,
                                                  NTFS_CHUNK_SIZE,
                                                  EngineMatches );

                //
                //  On successful Mdl requests we hang on to the PagingIo resource.
                //

                if ((NewMdl != NULL) && NT_SUCCESS(Status) && (*((PMDL *) NewMdl) != NULL)) {
                    PagingIoAcquired = FALSE;
                }

                //
                //  Check for the status that says we need to create the normal
                //  data stream, else we are done.
                //

                if (Status != STATUS_NOT_MAPPED_DATA) {
                    break;
                }

                //
                //  Create the normal data stream and loop back to try again.
                //

                ASSERT(Scb->FileObject == NULL);

                //
                //  Make sure we are serialized with the FileSizes, and
                //  will remove this condition if we abort.
                //

                if (!DoingIoAtEof) {
                    FsRtlLockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = Scb;
                }

                NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                if (!DoingIoAtEof) {
                    FsRtlUnlockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = NULL;
                }
            }
#endif
        }


    try_exit: NOTHING;

        if (Irp) {

            if (PostIrp) {

                //
                //  If we acquired this Scb exclusive, we won't need to release
                //  the Scb.  That is done in the oplock post request.
                //

                if (OplockPostIrp) {

                    ScbAcquired = FALSE;
                }

            //
            //  If we didn't post the Irp, we may have written some bytes to the
            //  file.  We report the number of bytes written and update the
            //  file object for synchronous writes.
            //

            } else {

                DebugTrace( 0, Dbg, ("Completing request with status = %08lx\n", Status) );

                DebugTrace( 0, Dbg, ("                   Information = %08lx\n",
                            Irp->IoStatus.Information));

                //
                //  Record the total number of bytes actually written
                //

                LlTemp1 = Irp->IoStatus.Information;

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.
                //

                if (SynchronousIo && !PagingIo) {

                    UserFileObject->CurrentByteOffset.QuadPart = StartingVbo + LlTemp1;
                }

                //
                //  The following are things we only do if we were successful
                //

                if (NT_SUCCESS( Status )) {

                    //
                    //  Mark that the modify time needs to be updated on close.
                    //  Note that only the top level User requests will generate
                    //  correct

                    if (!PagingIo) {

                        //
                        //  Set the flag in the file object to know we modified this file.
                        //

                        SetFlag( UserFileObject->Flags, FO_FILE_MODIFIED );

                    //
                    //  On successful paging I/O to a compressed or sparse data stream
                    //  which is not mapped, try to free any reserved space for the stream.
                    //  Note: mapped compressed streams will generally not free reserved
                    //  space
                    //

                    } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                        NtfsFreeReservedClusters( Scb,
                                                  StartingVbo,
                                                  (ULONG) Irp->IoStatus.Information );
                    }

                    //
                    //  If we extended the file size and we are meant to
                    //  immediately update the dirent, do so. (This flag is
                    //  set for either WriteThrough or noncached, because
                    //  in either case the data and any necessary zeros are
                    //  actually written to the file.)  Note that a flush of
                    //  a user-mapped file could cause VDL to get updated the
                    //  first time because we never had a cached write, so we
                    //  have to be sure to update VDL here in that case as well.
                    //

                    if (DoingIoAtEof) {

                        CC_FILE_SIZES CcFileSizes;

                        //
                        //  If we know this has gone to disk we update the Mft.
                        //  This variable should never be set for a resident
                        //  attribute.
                        //  The lazy writer uses callbacks to have the filesizes updated on disk
                        //  so we don't do any of this here
                        //

                        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                            if (UpdateMft) {

                                //
                                //  Get the Scb if we don't already have it.
                                //
    
                                if (!ScbAcquired) {
    
                                    //
                                    //  Make sure we don't have any Mft records.
                                    //
    
                                    NtfsPurgeFileRecordCache( IrpContext );
                                    NtfsAcquireExclusiveScb( IrpContext, Scb );
                                    ScbAcquired = TRUE;
    
                                    if (FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY )) {
    
                                        goto RestoreUnderway;
                                    }
    
                                    NtfsMungeScbSnapshot( IrpContext, Scb, OldFileSize );
    
                                } else if (FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY )) {
    
                                    goto RestoreUnderway;
                                }
    
                                //
                                //  Start by capturing any file size changes.
                                //
    
                                NtfsUpdateScbFromFileObject( IrpContext, UserFileObject, Scb, FALSE );
    
                                //
                                //  Write a log entry to update these sizes.
                                //
    
                                NtfsWriteFileSizes( IrpContext,
                                                    Scb,
                                                    &ByteRange,
                                                    TRUE,
                                                    TRUE,
                                                    TRUE );
    
                                //
                                //  Clear the check attribute size flag.
                                //
    
                                NtfsAcquireFsrtlHeader( Scb );
                                ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
    
                            //
                            //  Otherwise we set the flag indicating that we need to
                            //  update the attribute size.
                            //
    
                            } else {
    
                            RestoreUnderway:
    
                                NtfsAcquireFsrtlHeader( Scb );
                                SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                            }
                        } else {
                            NtfsAcquireFsrtlHeader( Scb );
                        }

                        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) ||
                                ByteRange <= ((Header->ValidDataLength.QuadPart + PAGE_SIZE - 1) & ~((LONGLONG) (PAGE_SIZE - 1))) );
                                
                        //
                        //  Now is the time to update valid data length.
                        //  The Eof condition will be freed when we commit.
                        //

                        if (ByteRange > Header->ValidDataLength.QuadPart) {

                            Header->ValidDataLength.QuadPart = ByteRange;

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {
                                ULONG Flags;

                                CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, Flags, StartingVbo, ByteCount, ByteRange );
                            }
#endif
                        }
                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                        DoingIoAtEof = FALSE;

                        //
                        //  Inform Cc that we changed the VDL for non cached toplevel
                        //

                        if (CcIsFileCached( FileObject ) && NonCachedIo) {
                            NtfsSetBothCacheSizes( FileObject, &CcFileSizes, Scb );
                        } else {

                            //
                            //  If there is a compressed section, then update both file sizes to get
                            //  the ValidDataLength update in the one we did not write.
                            //

#ifdef  COMPRESS_ON_WIRE
                            if (Header->FileObjectC != NULL) {
                                if (FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {
                                    if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {
                                        CcSetFileSizes( FileObject, &CcFileSizes );
                                    }
                                } else {
                                    CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                                }
                            }
#endif
                        }

                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }

                //
                //  Abort transaction on error by raising.  If this is the log file itself
                //  then just return normally.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                if (Scb != Scb->Vcb->LogFileScb) {

                    NtfsCleanupTransaction( IrpContext, Status, FALSE );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsCommonWrite );

        //
        //  Clean up any Bcb from read/synchronize compressed.
        //
#ifdef  COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (SafeBuffer) {

            NtfsFreePool( SafeBuffer );
        }

        //
        //  Now is the time to restore FileSize on errors.
        //  The Eof condition will be freed when we commit.
        //

        if (DoingIoAtEof && !PagingIo) {

            //
            //  Acquire the main resource to knock valid data to disk back.
            //

            if (RestoreValidDataToDisk) {

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs.
                //

                NtfsPurgeFileRecordCache( IrpContext );
                NtfsAcquireExclusiveScb( IrpContext, Scb );

                if (Scb->ValidDataToDisk > OldFileSize) {
                    Scb->ValidDataToDisk = OldFileSize;
                }

                NtfsReleaseScb( IrpContext, Scb );
            }

            NtfsAcquireFsrtlHeader( Scb );

            //
            //  Always force a recalc for write at eof unless we've commited the filesize
            //  forward. In that case we should write at the calculated offset unless the
            //  file shrinks in between. See test at beginning of common write
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF ) &&
                OldFileSize == IrpSp->Parameters.Write.ByteOffset.QuadPart) {

                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
                IrpSp->Parameters.Write.ByteOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
                IrpSp->Parameters.Write.ByteOffset.HighPart = -1;
            }

            Header->FileSize.QuadPart = OldFileSize;

            ASSERT( Header->ValidDataLength.QuadPart <= Header->FileSize.QuadPart );

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                CcGetFileSizePointer(FileObject)->QuadPart = OldFileSize;
            }
#ifdef COMPRESS_ON_WIRE
            if (Header->FileObjectC != NULL) {
                CcGetFileSizePointer(Header->FileObjectC)->QuadPart = OldFileSize;
            }
#endif
            NtfsReleaseFsrtlHeader( Scb );

        }

        //
        //  If the Scb or PagingIo resource has been acquired, release it.
        //

        if (PagingIoAcquired) {
            ExReleaseResourceLite( Header->PagingIoResource );
        }

        if (Irp) {

            if (ScbAcquired) {
                NtfsReleaseScb( IrpContext, Scb );
            }

            //
            //  Now remember to clear the WriteSeen flag if we set it. We only
            //  do this if there is still an Irp.  It is possible for the current
            //  Irp to be posted or asynchronous.  In that case this is a top
            //  level request and the cleanup happens elsewhere.  For synchronous
            //  recursive cases the Irp will still be here.
            //

            if (SetWriteSeen) {
                ClearFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
            }
        }


        DebugTrace( -1, Dbg, ("NtfsCommonWrite -> %08lx\n", Status) );
    }

    //
    //  Complete the request if we didn't post it and no exception
    //
    //  Note that NtfsCompleteRequest does the right thing if either
    //  IrpContext or Irp are NULL
    //
    if (!PostIrp) {

        NtfsCompleteRequest( IrpContext, Irp, Status );

    } else if (!OplockPostIrp) {

        Status = NtfsPostRequest( IrpContext, Irp );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS NtfsGetIoAtEof (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG StartingVbo,
    IN LONGLONG ByteCount,
    IN BOOLEAN Wait,
    OUT PBOOLEAN DoingIoAtEof,
    OUT PLONGLONG OldFileSize
    )

{
    //
    //  Our caller may already be synchronized with EOF.
    //  The FcbWithPaging field in the top level IrpContext
    //  will have either the current Fcb/Scb if so.
    //

    if ((IrpContext->TopLevelIrpContext->CleanupStructure == Scb->Fcb) ||
        (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

        *DoingIoAtEof = TRUE;
        *OldFileSize = Scb->Header.FileSize.QuadPart;

    } else {

        if (FlagOn( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) && !Wait) {
            return STATUS_FILE_LOCK_CONFLICT;
        }

        *DoingIoAtEof = !FlagOn( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                       NtfsWaitForIoAtEof( &(Scb->Header), (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

        //
        //  Set the Flag if we are changing FileSize or ValidDataLength,
        //  and save current values.
        //

        if (*DoingIoAtEof) {

            SetFlag( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
#if (DBG || defined( NTFS_FREE_ASSERTS ))
            Scb->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

            //
            //  Store this in the IrpContext until commit or post
            //

            IrpContext->CleanupStructure = Scb;
            *OldFileSize = Scb->Header.FileSize.QuadPart;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        } else {

            ASSERT( Scb->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\fsfile.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsfile.c

Abstract:

    This file contains code for commands that affect
    individual files.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>

//----------------------------------
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>

#define MAX_ALLOC_RANGES                          32


INT
FileHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_FILE );
    return EXIT_CODE_SUCCESS;
}

INT
FindFilesBySid(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine finds file owned by the user specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl findbysid <user> <pathname>'.

Return Value:

    None

--*/
{
    #define SID_MAX_LENGTH  (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL Status;

    struct {
        ULONG Restart;
        BYTE Sid[SID_MAX_LENGTH];
    } InBuffer;

    DWORD nInBufferSize;
    DWORD BytesReturned;
    ULONG SidLength = sizeof( InBuffer.Sid );
    WCHAR Domain[MAX_PATH];
    ULONG DomainLength = sizeof( Domain );
    SID_NAME_USE SidNameUse;
    DWORD nOutBufferSize;
    PBYTE lpOutBuffer;
    PFILE_NAME_INFORMATION FileNameInfo;
    ULONG Length;
    PWSTR Filename;
    ULONG Found = 0;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_FINDBYSID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[1] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(InBuffer);

        nOutBufferSize = 32768;
        lpOutBuffer = (PBYTE) malloc( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        memset( lpOutBuffer, 0, nOutBufferSize );
        memset( &InBuffer, 0, sizeof(InBuffer) );

        if (!LookupAccountName(
                NULL,
                argv[0],
                InBuffer.Sid,
                &SidLength,
                Domain,
                &DomainLength,
                &SidNameUse
                ))
        {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        InBuffer.Restart = 1;

        do {
            Status = DeviceIoControl(
                FileHandle,
                FSCTL_FIND_FILES_BY_SID,
                &InBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                &BytesReturned,
                (LPOVERLAPPED)NULL
                );
            if (!Status) {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }

            InBuffer.Restart = 0;
            FileNameInfo = (PFILE_NAME_INFORMATION) lpOutBuffer;
            while ((PBYTE)FileNameInfo < lpOutBuffer + BytesReturned) {
                Length = sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ) + FileNameInfo->FileNameLength;
                wprintf( L" '%.*ws'\n",
                        FileNameInfo->FileNameLength / sizeof( WCHAR ),
                        FileNameInfo->FileName );
                FileNameInfo = (PFILE_NAME_INFORMATION) Add2Ptr( FileNameInfo, QuadAlign( Length ) );
                Found += 1;
            }
        } while (Status && BytesReturned);

        if (Found == 0) {
            DisplayMsg( MSG_FINDFILESBYSID_NONE );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpOutBuffer );
        free( Filename );
    }

    return ExitCode;
}


INT
SetZeroData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets zero data for the range in the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setzero offset=<val> beyond=<val> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PWSTR EndPtr;
    BOOL Status;
    PFILE_ZERO_DATA_INFORMATION lpInBuffer;
    DWORD nInBufferSize;
    LPDWORD lpBytesReturned;
    ULONGLONG Offset;
    ULONGLONG Length;
    ULONGLONG Beyond;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 3) {
            DisplayMsg( MSG_SETZERO_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[2] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (_wcsnicmp( argv[0], L"offset=", 7)) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Offset = My_wcstoui64( argv[0] + 7, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Offset, EndPtr )) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (_wcsnicmp( argv[1], L"length=", 7)) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Length = My_wcstoui64( argv[1] + 7, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length, EndPtr )) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Beyond = Offset + Length;
        if (Beyond < Offset) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpBytesReturned = (LPDWORD) malloc ( sizeof(DWORD) );
        nInBufferSize = sizeof(FILE_ZERO_DATA_INFORMATION);
        lpInBuffer = (PFILE_ZERO_DATA_INFORMATION) malloc ( nInBufferSize );
        lpInBuffer->FileOffset.QuadPart = Offset;
        lpInBuffer->BeyondFinalZero.QuadPart = Beyond;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_ZERO_DATA,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            NULL,
            0,
            lpBytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        } else {
            DisplayMsg( MSG_SET_ZERODATA );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (Filename) {
            free( Filename );
        }
    }

    return ExitCode;
}


INT
QueryAllocatedRanges(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine scans for any allocated range within the range
    specified in the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl qryalcrnge offset=<val> length=<val> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PWSTR EndPtr;
    BOOL Status;
    PFILE_ALLOCATED_RANGE_BUFFER lpInBuffer;
    DWORD nInBufferSize;
    PFILE_ALLOCATED_RANGE_BUFFER *lpOutBuffer;
    PFILE_ALLOCATED_RANGE_BUFFER pBuffer;
    DWORD nOutBufferSize;
    LPDWORD lpBytesReturned;
    ULARGE_INTEGER Offset;
    ULARGE_INTEGER Length;
    INT NumberOfBuffers;
    INT Index;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 3) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[2] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Offset.QuadPart = Length.QuadPart = 0;

        if (_wcsnicmp( argv[0], L"offset=", 7 )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Offset.QuadPart = My_wcstoui64( argv[0] + 7, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Offset.QuadPart, EndPtr)) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (_wcsnicmp( argv[1], L"length=", 7 )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Length.QuadPart = My_wcstoui64( argv[1] + 7, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length.QuadPart, EndPtr )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpBytesReturned = (LPDWORD) malloc ( sizeof(DWORD) );
        nInBufferSize = sizeof(FILE_ALLOCATED_RANGE_BUFFER);
        lpInBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) malloc ( nInBufferSize );
        nOutBufferSize = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * MAX_ALLOC_RANGES;
        lpOutBuffer = (PFILE_ALLOCATED_RANGE_BUFFER *) calloc ( MAX_ALLOC_RANGES, sizeof(FILE_ALLOCATED_RANGE_BUFFER) );

        lpInBuffer->FileOffset.QuadPart = Offset.QuadPart;
        lpInBuffer->Length.QuadPart = Length.QuadPart;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_ALLOCATED_RANGES,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            lpOutBuffer,
            nOutBufferSize,
            lpBytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        pBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) lpOutBuffer ;
        NumberOfBuffers = (*lpBytesReturned) / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

        for ( Index=0; Index<NumberOfBuffers; Index++ ) {
            DisplayMsg( MSG_ALLOCRANGE_RANGES, Index, QuadToHexText( pBuffer[Index].FileOffset.QuadPart ), QuadToHexText( pBuffer[Index].Length.QuadPart ));
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}


typedef BOOL
(WINAPI *PSETFILEVALIDDATA)(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    );

PSETFILEVALIDDATA pSetFileValidData = NULL;

BOOL WINAPI
DefaultSetFileValidData(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    )
{
    return FALSE;
}


INT
SetValidDataLength(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_VALID_DATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        EnablePrivilege( SE_MANAGE_VOLUME_NAME );

        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!RunningOnWin2K) {
            LONGLONG ValidDataLength;
            PWSTR EndStr;
            
            if (pSetFileValidData == NULL) {
                pSetFileValidData = (PSETFILEVALIDDATA) GetProcAddress( GetModuleHandle(L"KERNEL32.DLL"), "SetFileValidData" );
            } else {
                pSetFileValidData = DefaultSetFileValidData;
            }
            
            ValidDataLength = My_wcstoui64( argv[1], &EndStr, 0 );
            if (UnsignedI64NumberCheck( ValidDataLength, EndStr )
                || !pSetFileValidData( hFile, ValidDataLength)
                ) {
                DisplayError( );
                ExitCode = EXIT_CODE_FAILURE;
            } else {
                DisplayMsg( MSG_SET_VDL );
            }
        }

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        free( Filename );
    }

    return ExitCode;
}


typedef BOOL
(WINAPI *PSETFILESHORTNAMEW)(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    );

BOOL WINAPI
DoNothingSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )
{
    return FALSE;
}


BOOL WINAPI
InitialSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    );

PSETFILESHORTNAMEW pSetFileShortName = InitialSetShortName;

BOOL WINAPI
InitialSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )
{
    HANDLE Handle = GetModuleHandle( L"KERNEL32.DLL" );
    FARPROC Proc;

    if (Handle == INVALID_HANDLE_VALUE) {
        pSetFileShortName = DoNothingSetShortName;
    } else if ((Proc = GetProcAddress( Handle, "SetFileShortNameW" )) != NULL) {
        pSetFileShortName = (PSETFILESHORTNAMEW) Proc;
    } else {
        pSetFileShortName = DoNothingSetShortName;
    }

    return pSetFileShortName( hFile, lpShortName );
}


INT
SetShortName(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_SHORTNAME, argv[1] );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        EnablePrivilege( SE_RESTORE_NAME );
        
        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!RunningOnWin2K) {
            if (!pSetFileShortName( hFile, argv[1] )) {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
            }
        }

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
CreateNewFile(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    LARGE_INTEGER Length;
    BOOL GoodFile = TRUE;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {
        PWSTR EndPtr;

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_CREATEFILE, argv[1] );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Length.QuadPart = My_wcstoui64( argv[1], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length.QuadPart, EndPtr )) {
            DisplayMsg( MSG_USAGE_CREATEFILE, argv[1] );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            0,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GoodFile = FALSE;

        if (!SetFilePointerEx( hFile, Length, NULL, FILE_BEGIN )) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!SetEndOfFile( hFile )) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GoodFile = TRUE;
        DisplayMsg( MSG_CREATEFILE_SUCCEEDED, Filename );

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        if (!GoodFile) {
            DeleteFile( Filename );
        }
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\hardlink.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hardlink.c

Abstract:

    This file contains code for commands that affect hardlinks.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
HardLinkHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_HARDLINK );
    return EXIT_CODE_SUCCESS;
}

INT
CreateHardLinkFile(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    PWSTR Filename1 = NULL;
    PWSTR Filename2 = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;

    do {
        if (argc != 2) {
            DisplayMsg( MSG_USAGE_HARDLINK_CREATE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            break;
        }

        Filename1 = GetFullPath( argv[0] );
        if (!Filename1) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        Filename2 = GetFullPath( argv[1] );
        if (!Filename2) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        if ((!IsVolumeLocalNTFS( Filename1[0] )) || (!IsVolumeLocalNTFS( Filename2[0] ))) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        if (CreateHardLink( Filename1, Filename2, NULL )) {
            DisplayMsg( MSG_HARDLINK_CREATED, Filename1, Filename2 );
        } else {
            if (GetLastError( ) == ERROR_NOT_SAME_DEVICE) {
                DisplayMsg( MSG_NOT_SAME_DEVICE );
            } else {
                DisplayError();
            }
            ExitCode = EXIT_CODE_FAILURE;
        }
    } while ( FALSE );

    free( Filename1 );
    free( Filename2 );

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\dirty.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    volume.c

Abstract:

    This file contains code for commands that affect
    the the dirty bit of ntfs volumes.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
DirtyHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_DIRTY );
    return EXIT_CODE_SUCCESS;
}

INT
IsVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine checks if the Volume specified is dirty.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl isdirtyv <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DWORD VolumeStatus;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_ISVDIRTY );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocal( argv[0][0] )) {
            DisplayMsg( MSG_NEED_LOCAL_VOLUME );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_IS_VOLUME_DIRTY,
            NULL,
            0,
            (LPVOID)&VolumeStatus,
            sizeof(VolumeStatus),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (VolumeStatus & VOLUME_IS_DIRTY) {
            DisplayMsg( MSG_ISVDIRTY_YES, argv[0] );
        } else {
            DisplayMsg( MSG_ISVDIRTY_NO, argv[0] );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
MarkVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine marks the volume as dirty.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl markv <volume pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesReturned;
    WCHAR FileName[MAX_PATH];
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_MARKV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcsncat( FileName, argv[0], (sizeof(FileName)/sizeof(WCHAR))-wcslen(FileName) );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_MARK_VOLUME_DIRTY,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        } else {
            DisplayMsg( MSG_DIRTY_SET, argv[0] );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\main.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file implements the main entry point
    for this project and also processes all
    command dispatching.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>

BOOL RunningOnWin2K;

typedef INT (*PFSCOMMANDFUNC)(INT,PWSTR*);

typedef struct _COMMAND_VECTOR {
    PWSTR CommandName;
    union {
        PVOID _make_it_compile;
        PFSCOMMANDFUNC CommandFunc;
        struct _COMMAND_VECTOR *CommandVector;
        DWORD_PTR HelpMessage;
    };
} COMMAND_VECTOR, *PCOMMAND_VECTOR;

COMMAND_VECTOR CmdVectorUsn[] =
{
    { L"?",                           UsnHelp                  },
    { L"help",                        UsnHelp                  },
    { L"createjournal",               CreateUsnJournal         },
    { L"deletejournal",               DeleteUsnJournal         },
    { L"enumdata",                    EnumUsnData              },
    { L"queryjournal",                QueryUsnJournal          },
    { L"readdata",                    ReadFileUsnData          },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorQuota[] =
{
    { L"?",                           QuotaHelp                },
    { L"help",                        QuotaHelp                },
    { L"disable",                     DisableQuota             },
    { L"track",                       TrackQuota               },
    { L"enforce",                     EnforceQuota             },
    { L"violations",                  GetDiskQuotaViolation    },
    { L"modify",                      ChangeDiskQuota          },
    { L"query",                       QueryDiskQuota           },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorDirty[] =
{
    { L"?",                           DirtyHelp                },
    { L"help",                        DirtyHelp                },
    { L"query",                       IsVolumeDirty            },
    { L"set",                         MarkVolumeDirty          },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorFsInfo[] =
{
    { L"?",                           FsInfoHelp               },
    { L"help",                        FsInfoHelp               },
    { L"drives",                      ListDrives               },
    { L"drivetype",                   DriveType                },
    { L"volumeinfo",                  VolumeInfo               },
    { L"ntfsinfo",                    GetNtfsVolumeData        },
    { L"statistics",                  GetFileSystemStatistics  },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorReparse[] =
{
    { L"?",                           ReparseHelp              },
    { L"help",                        ReparseHelp              },
    { L"query",                       GetReparsePoint          },
    { L"delete",                      DeleteReparsePoint       },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorBehavior[] =
{
    { L"?",                           BehaviorHelp             },
    { L"help",                        BehaviorHelp             },
    { L"query",                       RegistryQueryValueKey    },
    { L"set",                         RegistrySetValueKey      },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorFile[] =
{
    { L"?",                           FileHelp                 },
    { L"help",                        FileHelp                 },
    { L"findbysid",                   FindFilesBySid           },
    { L"queryallocranges",            QueryAllocatedRanges     },
    { L"setshortname",                SetShortName             },
    { L"setvaliddata",                SetValidDataLength       },
    { L"setzerodata",                 SetZeroData              },
    { L"createnew",                   CreateNewFile            },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorVolume[] =
{
    { L"?",                           VolumeHelp               },
    { L"help",                        VolumeHelp               },
    { L"dismount",                    DismountVolume           },
    { L"diskfree",                    DiskFreeSpace            },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorObjectId[] =
{
    { L"?",                           ObjectIdHelp             },
    { L"help",                        ObjectIdHelp             },
    { L"query",                       GetObjectId              },
    { L"set",                         SetObjectId              },
    { L"delete",                      DeleteObjectId           },
    { L"create",                      CreateOrGetObjectId      },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorSparse[] =
{
    { L"?",                           SparseHelp               },
    { L"help",                        SparseHelp               },
    { L"setflag",                     SetSparse                },
    { L"queryflag",                   QuerySparse              },
    { L"queryrange",                  QuerySparseRange         },
    { L"setrange",                    SetSparseRange           },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorHardLink[] =
{
    { L"?",                           HardLinkHelp             },
    { L"help",                        HardLinkHelp             },
    { L"create",                      CreateHardLinkFile       },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorGroups[] =
{
    { L"behavior",                    CmdVectorBehavior        },
    { L"dirty",                       CmdVectorDirty           },
    { L"file",                        CmdVectorFile            },
    { L"fsinfo",                      CmdVectorFsInfo          },
    { L"hardlink",                    CmdVectorHardLink        },
    { L"objectid",                    CmdVectorObjectId        },
    { L"quota",                       CmdVectorQuota           },
    { L"reparsepoint",                CmdVectorReparse         },
    { L"sparse",                      CmdVectorSparse          },
    { L"usn",                         CmdVectorUsn             },
    { L"volume",                      CmdVectorVolume          },
    { NULL,                           NULL                     }
};



PCOMMAND_VECTOR
FindCommand(
    PCOMMAND_VECTOR Cmds,
    LPWSTR CmdName
    )
{
    while (Cmds->CommandName) {
        if (!_wcsicmp( Cmds->CommandName, CmdName )) {
            return Cmds;
        }
        Cmds += 1;
    }
    return NULL;
}


INT
__cdecl wmain(
    INT argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    This routine is the 'main' routine for the tool 'fscutl'.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl <command> <options/flags> <parameters> ...'

Return Value:

    INT - Return Status

--*/
{
    PCOMMAND_VECTOR Cmds = NULL;
    PCOMMAND_VECTOR Cmds2 = NULL;
    OSVERSIONINFOEX OsVer;

#if FALSE
    LANGID (WINAPI *pSetThreadUILanguage)(  ) = NULL;

    if (pSetThreadUILanguage == NULL) {
        pSetThreadUILanguage = (PVOID) GetProcAddress( GetModuleHandle( TEXT( "kernel32" )), "SetThreadUILanguage" );
    }

    if (pSetThreadUILanguage == NULL) {
        SetThreadLocale( MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT ));
    } else {
        (*pSetThreadUILanguage)( 0 );
    }
#endif

    setlocale( LC_ALL, ".OCP" ) ;


    SHIFT( argc, argv );

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx( (LPOSVERSIONINFO)&OsVer ) && OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion == 0) {
        RunningOnWin2K = TRUE;
    }

    if (!IsUserAdmin()) {
        DisplayMsg( MSG_ADMIN_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    //
    //  Check for blind usage
    //

    if (argc == 0) {
        Help( 0, NULL );
        return EXIT_CODE_SUCCESS;
    }
    
    //
    //  We have a two-level dispatch scheme.  First level selects a table and second
    //  selects a function
    //

    Cmds = FindCommand( CmdVectorGroups, argv[0] );
    if (Cmds == NULL) {
        DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
        Help( 0, NULL );
        return EXIT_CODE_FAILURE;
    }
    
    SHIFT( argc, argv );

    //
    //  If there's no argument, then it's a cry for help
    //

    if (argc == 0) {
        Cmds2 = FindCommand( Cmds->CommandVector, L"?" );
        Cmds2->CommandFunc( argc, argv );
        return EXIT_CODE_SUCCESS;
    }
    
    //
    //  Go to second level dispatch.
    //

    Cmds2 = FindCommand( Cmds->CommandVector, argv[0] );
    if (Cmds2 == NULL) {
        DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
        Cmds2 = FindCommand( Cmds->CommandVector, L"?" );
        SHIFT( argc, argv );
        Cmds2->CommandFunc( argc, argv );
        return EXIT_CODE_FAILURE;
    }
    
    SHIFT( argc, argv );

    return Cmds2->CommandFunc( argc, argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\fsinfo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsinfo.c

Abstract:

    This file contains code for commands that affect
    information specific to the file system.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
FsInfoHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_FSINFO );
    return EXIT_CODE_SUCCESS;
}

typedef struct _NTFS_FILE_SYSTEM_STATISTICS {
        FILESYSTEM_STATISTICS Common;
        NTFS_STATISTICS Ntfs;
        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];
} NTFS_FILE_SYSTEM_STATISTICS, *PNTFS_FILE_SYSTEM_STATISTICS;

typedef struct _FAT_FILE_SYSTEM_STATISTICS {
        FILESYSTEM_STATISTICS Common;
        FAT_STATISTICS Fat;
        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];
} FAT_FILE_SYSTEM_STATISTICS, *PFAT_FILE_SYSTEM_STATISTICS;



ULONGLONG
FsStat(
    IN PVOID FsStats,
    IN ULONG FsSize,
    IN ULONG Offset,
    IN ULONG NumProcs
    )
/*++

Routine Description:

    This routine iterates through the file system statistics structure
    and accumulates a total amount for a given statistic field.

    Note: This function assumes that the width of the field being accumulated
          is a ULONG.  If this assumption is invalidated then a width argument
          should be added to this function.

Arguments:

    FsStats - Pointer to an array of file system statistics structures
    FsSize - Size of the individual file system statistics structures in the array
    Offset - Offset of the desired field from the beginning of the file system statistics structure
    NumProcs - Number of processors on the machine where the stats were gathered

Return Value:

    Accumulated total.

--*/
{
    ULONG i;
    ULONGLONG Total = 0;

    for (i=0; i<NumProcs; i++) {
        Total += *(PULONG)((PUCHAR)FsStats + Offset);
        FsStats = (PVOID)((PUCHAR)FsStats + FsSize);
    }

    return Total;
}


INT
ListDrives(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine lists all the drive names in the system.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form : 'fscutl lsdrv'.

Return Value:

    None

--*/
{
    DWORD nBufferLen = MAX_PATH;
    DWORD Length;
    LPWSTR lpBuffer = NULL;
    WORD Index;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 0) {
            DisplayMsg( MSG_LISTDRIVES_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpBuffer = (LPWSTR) malloc( nBufferLen * sizeof(WCHAR) );
        if (!lpBuffer) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Length = GetLogicalDriveStrings( nBufferLen, lpBuffer );
        if (!Length) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wprintf( L"\n" );
        DisplayMsg( MSG_DRIVES );
        for ( Index = 0 ; Index < Length; Index ++ ) {
            wprintf( L"%c", lpBuffer[Index] );
        }
        wprintf( L"\n" );

    } finally {

        if (lpBuffer) {
            free( lpBuffer );
        }

    }
    return ExitCode;
}


INT
DriveType(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine describes the drive type of the drive passed in.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
          'fscutl dt <drive name>' or
          'fscutl drivetype <drive name>'

Return Value:

   None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_DRIVETYPE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    DisplayMsg( GetDriveType( argv[0] ) + MSG_DRIVE_UNKNOWN, argv[0] );

    return EXIT_CODE_SUCCESS;
}


INT
VolumeInfo(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine provides the information about the Volume.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
           'fscutl infov <root pathname>'.

Return Value:

    None

--*/
{
    LPWSTR lpVolumeNameBuffer = NULL;         // address of name of the volume
    DWORD nVolumeNameSize;                    // length of lpVolumeNameBuffer
    LPDWORD lpVolumeSerialNumber = NULL;      // address of volume serial number
    LPDWORD lpMaximumComponentLength = NULL;  // address of system's maximum
                                              // filename length
    LPDWORD lpFileSystemFlags = NULL;         // address of file system flags
    LPWSTR lpFileSystemNameBuffer = NULL;     // address of name of file system
    DWORD nFileSystemNameSize;                // length of lpFileSystemNameBuffer
    BOOL Status;                              // return status
    DWORD dwMask;                             // FileSystem Flag Mask
    DWORD Index;
    DWORD  FsFlag;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_INFOV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        nVolumeNameSize = MAX_PATH;

        lpVolumeNameBuffer = (LPWSTR) malloc ( MAX_PATH * sizeof(WCHAR) );
        if (lpVolumeNameBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpVolumeSerialNumber = (LPDWORD) malloc( sizeof(DWORD) );
        if (lpVolumeSerialNumber == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpFileSystemFlags = (LPDWORD) malloc ( sizeof(DWORD) );
        if (lpFileSystemFlags == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpMaximumComponentLength = (LPDWORD) malloc ( sizeof(DWORD) );
        if (lpMaximumComponentLength == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nFileSystemNameSize = MAX_PATH;
        lpFileSystemNameBuffer = (LPWSTR) malloc ( MAX_PATH * sizeof(WCHAR) );
        if (lpFileSystemNameBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = GetVolumeInformation (
            argv[0],
            lpVolumeNameBuffer,
            nVolumeNameSize,
            lpVolumeSerialNumber,
            lpMaximumComponentLength,
            lpFileSystemFlags,
            lpFileSystemNameBuffer,
            nFileSystemNameSize
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_VOLNAME, lpVolumeNameBuffer );
        DisplayMsg( MSG_SERIALNO, *lpVolumeSerialNumber );
        DisplayMsg( MSG_MAX_COMP_LEN, *lpMaximumComponentLength );
        DisplayMsg( MSG_FS_NAME, lpFileSystemNameBuffer );

        dwMask = 1 ;
        FsFlag = *lpFileSystemFlags;

        for ( Index=0 ; Index<32 ; Index++ ) {
            switch (FsFlag & dwMask) {
                case FILE_CASE_SENSITIVE_SEARCH:
                    DisplayMsg( MSG_FILE_CASE_SENSITIVE_SEARCH );
                    break;

                case FILE_CASE_PRESERVED_NAMES:
                    DisplayMsg( MSG_FILE_CASE_PRESERVED_NAMES );
                    break;

                case FILE_UNICODE_ON_DISK:
                    DisplayMsg( MSG_FILE_UNICODE_ON_DISK );
                    break;

                case FILE_PERSISTENT_ACLS:
                    DisplayMsg( MSG_FILE_PERSISTENT_ACLS );
                    break;

                case FILE_FILE_COMPRESSION:
                    DisplayMsg( MSG_FILE_FILE_COMPRESSION );
                    break;

                case FILE_VOLUME_QUOTAS:
                    DisplayMsg( MSG_FILE_VOLUME_QUOTAS );
                    break;

                case FILE_SUPPORTS_SPARSE_FILES:
                    DisplayMsg( MSG_FILE_SUPPORTS_SPARSE_FILES );
                    break;

                case FILE_SUPPORTS_REPARSE_POINTS:
                    DisplayMsg( MSG_FILE_SUPPORTS_REPARSE_POINTS );
                    break;

                case FILE_SUPPORTS_REMOTE_STORAGE:
                    DisplayMsg( MSG_FILE_SUPPORTS_REMOTE_STORAGE );
                    break;

                case FILE_VOLUME_IS_COMPRESSED:
                    DisplayMsg( MSG_FILE_VOLUME_IS_COMPRESSED );
                    break;

                case FILE_SUPPORTS_OBJECT_IDS:
                    DisplayMsg( MSG_FILE_SUPPORTS_OBJECT_IDS );
                    break;

                case FILE_SUPPORTS_ENCRYPTION:
                    DisplayMsg( MSG_FILE_SUPPORTS_ENCRYPTION );
                    break;

                case FILE_NAMED_STREAMS:
                    DisplayMsg( MSG_FILE_NAMED_STREAMS );
                    break;
            }
            dwMask <<= 1;
        }

    } finally {

        free( lpVolumeNameBuffer );
        free( lpVolumeSerialNumber );
        free( lpFileSystemFlags );
        free( lpMaximumComponentLength );
        free( lpFileSystemNameBuffer );
    }

    return ExitCode;
}


INT
GetNtfsVolumeData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the NTFS volume data for the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getntfsdv <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    BYTE Buffer[sizeof( NTFS_VOLUME_DATA_BUFFER ) + sizeof( NTFS_EXTENDED_VOLUME_DATA )];
    PNTFS_VOLUME_DATA_BUFFER pvdb = (PNTFS_VOLUME_DATA_BUFFER)Buffer;
    PNTFS_EXTENDED_VOLUME_DATA pevd = (PNTFS_EXTENDED_VOLUME_DATA)(pvdb + 1);
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_NTFSINFO );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_NTFS_VOLUME_DATA,
            NULL,
            0,
            pvdb,
            sizeof( Buffer ),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg(
            MSG_NTFSINFO_STATS,
            QuadToPaddedHexText( pvdb->VolumeSerialNumber.QuadPart ),  //  Serial number in hex
            pevd->MajorVersion,
            pevd->MinorVersion,
            QuadToPaddedHexText( pvdb->NumberSectors.QuadPart ),
            QuadToPaddedHexText( pvdb->TotalClusters.QuadPart ),
            QuadToPaddedHexText( pvdb->FreeClusters.QuadPart ),
            QuadToPaddedHexText( pvdb->TotalReserved.QuadPart ),
            pvdb->BytesPerSector,
            pvdb->BytesPerCluster,
            pvdb->BytesPerFileRecordSegment,
            pvdb->ClustersPerFileRecordSegment,
            QuadToPaddedHexText( pvdb->MftValidDataLength.QuadPart ),
            QuadToPaddedHexText( pvdb->MftStartLcn.QuadPart ),
            QuadToPaddedHexText( pvdb->Mft2StartLcn.QuadPart ),
            QuadToPaddedHexText( pvdb->MftZoneStart.QuadPart ),
            QuadToPaddedHexText( pvdb->MftZoneEnd.QuadPart )
            );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }
    return ExitCode;
}


INT
GetFileSystemStatistics(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the file system statistics for the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getfss <volume pathname>'.

Return Value:

    None

--*/
{
    #define FS_STAT(_f)   FsStat( FsStats, StrucSize, offsetof(FILESYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )
    #define FAT_STAT(_f)  FsStat( FatFsStats, StrucSize, offsetof(FAT_FILE_SYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )
    #define NTFS_STAT(_f) FsStat( NtfsFsStats, StrucSize, offsetof(NTFS_FILE_SYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )

    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    PFILESYSTEM_STATISTICS FsStats = NULL;
    DWORD OutBufferSize;
    DWORD BytesReturned;
    SYSTEM_INFO SysInfo;
    PNTFS_FILE_SYSTEM_STATISTICS NtfsFsStats = NULL;
    PFAT_FILE_SYSTEM_STATISTICS FatFsStats = NULL;
    ULONG StrucSize;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_GETFSS );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcsncat( FileName, argv[0], (sizeof(FileName)/sizeof(WCHAR))-wcslen(FileName) );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GetSystemInfo( &SysInfo );

        OutBufferSize = max(sizeof(NTFS_FILE_SYSTEM_STATISTICS),sizeof(FAT_FILE_SYSTEM_STATISTICS)) * SysInfo.dwNumberOfProcessors;

        FsStats = (PFILESYSTEM_STATISTICS) malloc ( OutBufferSize );
        if (FsStats == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_FILESYSTEM_GET_STATISTICS,
            NULL,
            0,
            FsStats,
            OutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        switch (FsStats->FileSystemType) {
            case FILESYSTEM_STATISTICS_TYPE_NTFS:
                DisplayMsg( MSG_FSTYPE_NTFS );
                NtfsFsStats = (PNTFS_FILE_SYSTEM_STATISTICS) FsStats;
                StrucSize = sizeof(NTFS_FILE_SYSTEM_STATISTICS);
                break;

            case FILESYSTEM_STATISTICS_TYPE_FAT:
                DisplayMsg( MSG_FSTYPE_FAT );
                FatFsStats = (PFAT_FILE_SYSTEM_STATISTICS) FsStats;
                StrucSize = sizeof(FAT_FILE_SYSTEM_STATISTICS);
                break;
        }

        DisplayMsg(
            MSG_GENERAL_FSSTAT,
            QuadToDecimalText( FS_STAT(UserFileReads)),
            QuadToDecimalText( FS_STAT(UserFileReadBytes)),
            QuadToDecimalText( FS_STAT(UserDiskReads)),
            QuadToDecimalText( FS_STAT(UserFileWrites)),
            QuadToDecimalText( FS_STAT(UserFileWriteBytes)),
            QuadToDecimalText( FS_STAT(UserDiskWrites)),
            QuadToDecimalText( FS_STAT(MetaDataReads)),
            QuadToDecimalText( FS_STAT(MetaDataReadBytes)),
            QuadToDecimalText( FS_STAT(MetaDataDiskReads)),
            QuadToDecimalText( FS_STAT(MetaDataWrites)),
            QuadToDecimalText( FS_STAT(MetaDataWriteBytes)),
            QuadToDecimalText( FS_STAT(MetaDataDiskWrites))
            );

        //
        // Print FileSystem specific data
        //

        switch (FsStats->FileSystemType) {
            case FILESYSTEM_STATISTICS_TYPE_FAT:
                DisplayMsg(
                    MSG_FAT_FSSTA,
                    QuadToDecimalText( FAT_STAT(Fat.CreateHits)),
                    QuadToDecimalText( FAT_STAT(Fat.SuccessfulCreates)),
                    QuadToDecimalText( FAT_STAT(Fat.FailedCreates)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedReads)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedReadBytes)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedWrites)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedWriteBytes)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedDiskReads)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedDiskWrites))
                    );
                break;

            case FILESYSTEM_STATISTICS_TYPE_NTFS:
                DisplayMsg(
                    MSG_NTFS_FSSTA,
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.Mft2Writes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.Mft2WriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileWriteBytes))
                    );

                //
                // Still some more fields left
                //
                break;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (FsStats) {
            free( FsStats );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the main header file.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#ifndef _FSCUTL_
#define _FSCUTL_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>
#include <malloc.h>
#include <time.h>
#include <errno.h>
#include <limits.h>

#include <windows.h>
#include <winioctl.h>

#include <objbase.h>
#include <locale.h>

#include "msg.h"

#ifdef _cplusplus
extern "C" {
#endif


#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#define QuadAlign(P) (((((ULONG)(P)) + 7) & 0xfffffff8))

#define STRUCT_COUNT(n, type, name_length)                                         \
        ((((n) * QuadAlign(sizeof(type)) + ((name_length) * sizeof(WCHAR))) + \
          sizeof(type) - 1) /                                             \
         sizeof(type))
         
#define UnsignedI64NumberCheck(v,p) ((*p) != L'\0' || ((v) == _UI64_MAX && errno == ERANGE))
#define UnsignedNumberCheck(v,p)    ((*p) != L'\0' || ((v) == ULONG_MAX && errno == ERANGE))

#define SHIFT(c,v)      ((c)--,(v)++)


extern BOOL RunningOnWin2K;

//
//  Exit codes.  Note that we will treat asking for usage information as a success
//

#define EXIT_CODE_SUCCESS   0
#define EXIT_CODE_FAILURE   1



//
// Function Prototypes
//

INT
Help (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ListDrives (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DriveType (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
VolumeInfo (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DiskFreeSpace (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DismountVolume(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
MarkVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetFileSystemStatistics(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetNtfsVolumeData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
IsVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateOrGetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
EnumUsnData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ReadFileUsnData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateHardLinkFile(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FindFilesBySid(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetSparse(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuerySparse(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetSparseRange(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuerySparseRange(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetZeroData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryAllocatedRanges(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
RegistryQueryValueKey(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
RegistrySetValueKey(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetDiskQuotaViolation(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DisableQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
TrackQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
EnforceQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuotaControl(
    IN PWSTR Drive,
    IN ULONG QuotaControBits
    );

INT
ChangeDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetValidDataLength(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateNewFile(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetShortName(
    IN INT argc,
    IN PWSTR argv[]
    );

VOID
DisplayError(
    void
    );

BOOL
IsUserAdmin(
    VOID
    );

BOOL
IsVolumeLocalNTFS(
    WCHAR DriveLetter
    );

BOOL
IsVolumeNTFS(
    PWCHAR path
    );

BOOL
IsVolumeLocal(
    WCHAR DriveLetter
    );

PWSTR
GetFullPath(
    IN PWSTR FilenameIn
    );

VOID
DisplayMsg(
    LONG msgId,
    ...
    );

VOID DisplayErrorMsg(
    IN LONG msgId,
    ...
    );

BOOL
EnablePrivilege(
    LPCWSTR SePrivilege
    );

__int64  __cdecl My_wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    );

unsigned __int64  __cdecl My_wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	);

unsigned long __cdecl My_wcstoul (
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    );

PWSTR
QuadToDecimalText(
    ULONGLONG Value
    );

PWSTR
QuadToHexText(
    ULONGLONG Value
    );

PWSTR
QuadToPaddedHexText(
    ULONGLONG Value
    );

INT
UsnHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuotaHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DirtyHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FsInfoHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ReparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
BehaviorHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FileHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
VolumeHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ObjectIdHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
HardLinkHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

#ifdef _cplusplus
}
#endif

#endif // _FSCUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\quota.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    quota.c

Abstract:

    This file contains code for commands that affect quotas.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


#define BUFFER_SIZE                      1024
#define IO_FILE_QUOTA_THRESHOLD          0x40040024L
#define IO_FILE_QUOTA_LIMIT              0x40040025L

#define SID_MAX_LENGTH                   (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

INT
QuotaHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_QUOTA );
    return EXIT_CODE_SUCCESS;
}

HANDLE
QuotaOpenVolume(
    IN PWSTR Drive
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    WCHAR Buffer[MAX_PATH];
    UNICODE_STRING FileName;


    swprintf(
        Buffer,
        L"\\DosDevices\\%s\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION",
        Drive
        );

    RtlInitUnicodeString( &FileName, Buffer );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
        &hFile,
        FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );
    if (!NT_SUCCESS( Status )) {
        DisplayErrorMsg( RtlNtStatusToDosError( Status ), Drive );
        return INVALID_HANDLE_VALUE;
    }

    return hFile;
}

INT
QuotaControl(
    IN PWSTR Drive,
    IN ULONG QuotaControlBits
    )
{
    HANDLE Handle = INVALID_HANDLE_VALUE;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_CONTROL_INFORMATION ControlInfo;
    INT ExitCode = EXIT_CODE_SUCCESS;
    
    do {
        if (!IsVolumeLocalNTFS( Drive[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        Handle = QuotaOpenVolume( Drive );
        if (Handle == INVALID_HANDLE_VALUE) {
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        //
        //  get the current state of quota tracking on this volume
        //

        Status = NtQueryVolumeInformationFile(
            Handle,
            &IoStatus,
            &ControlInfo,
            sizeof( ControlInfo ),
            FileFsControlInformation
            );

        if (!NT_SUCCESS( Status )) {
            DisplayErrorMsg( RtlNtStatusToDosError( Status ));
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        //
        //  Set in the new control bits
        //
        
        ControlInfo.FileSystemControlFlags &= ~FILE_VC_QUOTA_MASK;
        ControlInfo.FileSystemControlFlags |= QuotaControlBits;

        //
        //  Set the control info back onto the volume
        //

        Status = NtSetVolumeInformationFile(
            Handle,
            &IoStatus,
            &ControlInfo,
            sizeof( ControlInfo ),
            FileFsControlInformation
            );

        if (!NT_SUCCESS( Status )) {
            DisplayErrorMsg( RtlNtStatusToDosError( Status ));
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

    } while (FALSE);
    

    if (Handle != INVALID_HANDLE_VALUE) {
        CloseHandle( Handle );
    }

    return ExitCode;
}



INT
DisableQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Disables quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_DISABLE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
            
    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_NONE );
}

INT
TrackQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Tracks quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_TRACK );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_TRACK );
}

INT
EnforceQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Enforces quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_ENFORCE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_ENFORCE );
}

INT
GetDiskQuotaViolation(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for querying the disk quota violation.

Arguments:

    argc - The argument count.
    argv - Array of strings of the form:
           ' fscutl getdskqv '

Return Value:

    None

--*/
{
    HANDLE handle = NULL;
    EVENTLOGRECORD *pevlr, *ptr;
    PWCHAR EventString;
    DWORD dwRead;
    DWORD dwNeeded;
    BOOLEAN flag = TRUE;
    BOOL Status;
    PSID psid;
    SID_NAME_USE Use;
    WCHAR Name[MAX_PATH];
    DWORD dwNameSize;
    WCHAR Domain[MAX_PATH];
    DWORD dwDomainSize;
    WCHAR Log[2][16] = { L"System", L"Application" };
    WORD index;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {
        
        if (argc != 0) {
            DisplayMsg( MSG_USAGE_QUOTA_VIOLATIONS );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }
        
        for ( index = 0 ; index < 2 ; index++ ) {
            handle = OpenEventLog( NULL, Log[index] );
            if ( handle == NULL ) {
                DisplayMsg( MSG_COULD_NOT_OPEN_EVENTLOG );
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }
            ptr = pevlr = (EVENTLOGRECORD *) malloc (BUFFER_SIZE);
            DisplayMsg( MSG_SEARCHING_EVENTLOG, Log[index] );

            while(ReadEventLog(
                    handle,
                    EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                    0,
                    pevlr,
                    BUFFER_SIZE,
                    &dwRead,
                    &dwNeeded))
            {
                while(dwRead > 0)   {
                    if (pevlr->EventID == IO_FILE_QUOTA_THRESHOLD || pevlr->EventID == IO_FILE_QUOTA_LIMIT) {
                        flag = FALSE;
                        switch(pevlr->EventID) {
                            case IO_FILE_QUOTA_THRESHOLD :
                                DisplayMsg( MSG_QUOTA_THREASHOLD );
                                break;
                            case IO_FILE_QUOTA_LIMIT:
                                DisplayMsg( MSG_QUOTA_LIMIT );
                                break;
                        }

                        DisplayMsg( MSG_EVENT_ID, pevlr->EventID );
                        
                        switch(pevlr->EventType) {
                            case EVENTLOG_ERROR_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_ERROR );
                                break;
                            case EVENTLOG_WARNING_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_WARNING );
                                break;
                            case EVENTLOG_INFORMATION_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_INFORMATION );
                                break;
                            case EVENTLOG_AUDIT_SUCCESS:
                                DisplayMsg( MSG_EVENT_TYPE_AUDIT_SUCCESS );
                                break;
                            case EVENTLOG_AUDIT_FAILURE:
                                DisplayMsg( MSG_EVENT_TYPE_AUDIT_FAILURE );
                                break;
                        }
                        
                        DisplayMsg( MSG_EVENT_CATEGORY, pevlr->EventCategory );
                        DisplayMsg( MSG_EVENT_SOURCE, (LPWSTR)((LPBYTE) pevlr + sizeof(EVENTLOGRECORD)) );

                        if (pevlr->UserSidOffset > 0) {
                            psid = (PSID) ( (PBYTE)pevlr + pevlr->UserSidOffset );
                            
                            dwNameSize = MAX_PATH;
                            dwDomainSize = MAX_PATH;

                            Status = LookupAccountSid(
                                NULL,
                                psid,
                                Name,
                                &dwNameSize,
                                Domain,
                                &dwDomainSize,
                                &Use
                                );
                            if (Status) {
                                DisplayMsg( MSG_USERNAME, Domain, Name );
                            }
                        }
                        if (pevlr->NumStrings == 2) {
                            EventString = (PWCHAR) ((PBYTE)pevlr + pevlr->StringOffset);
                            EventString += wcslen( EventString ) + 1;
                            DisplayMsg( MSG_EVENT_DATA, EventString );
                        }
                    }
                    dwRead -= pevlr->Length;
                    pevlr = (EVENTLOGRECORD *)((PBYTE) pevlr + pevlr->Length);
                }
                pevlr = ptr;
            }
            CloseEventLog(handle);
            handle = NULL;
        }

        if (flag) {
            DisplayMsg( MSG_GOOD_QUOTA );
        }

    } finally {

        if (handle != NULL) {
            CloseHandle( handle );
        }

    }
    
    return ExitCode;
}

PWSTR
FileTimeToString(
    PLARGE_INTEGER FileTime
    )
{
    ULONG ElapsedSeconds;

    if (RtlTimeToSecondsSince1970( FileTime, &ElapsedSeconds )) {
        PWSTR TimeString = _wctime( (time_t*)&ElapsedSeconds );
        if (TimeString) {
            TimeString[wcslen(TimeString)-1] = 0;
        }
        return TimeString;
    }
    return L"";
}

BOOL
GetUserSid(
    PWSTR UserName,
    PFILE_QUOTA_INFORMATION *QuotaInfoPtr,
    PFILE_GET_QUOTA_INFORMATION *SidListPtr
    )
{
    WCHAR Domain[128];
    ULONG DomainLength;
    SID_NAME_USE SidNameUse;


    *QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) ((PCHAR) *QuotaInfoPtr + (*QuotaInfoPtr)->NextEntryOffset);
    *SidListPtr = (PFILE_GET_QUOTA_INFORMATION) ((PCHAR) *SidListPtr + (*SidListPtr)->NextEntryOffset);

    (*QuotaInfoPtr)->SidLength = SID_MAX_LENGTH;
    DomainLength = sizeof(Domain);

    if (!LookupAccountName(
         NULL,
         UserName,
         &(*QuotaInfoPtr)->Sid,
         &(*QuotaInfoPtr)->SidLength,
         Domain,
         &DomainLength,
         &SidNameUse))
    {
        DomainLength = GetLastError();
        return FALSE;
    }

    //
    // Initialize the values to something resonable.
    //

    (*QuotaInfoPtr)->QuotaThreshold.QuadPart = ~0;
    (*QuotaInfoPtr)->QuotaLimit.QuadPart = ~0;

    (*QuotaInfoPtr)->SidLength = RtlLengthSid( &(*QuotaInfoPtr)->Sid);

    (*QuotaInfoPtr)->NextEntryOffset =
        FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) +
        QuadAlign((*QuotaInfoPtr)->SidLength);

    memcpy( &(*SidListPtr)->Sid, &(*QuotaInfoPtr)->Sid, (*QuotaInfoPtr)->SidLength);
    (*SidListPtr)->SidLength = (*QuotaInfoPtr)->SidLength;

    (*SidListPtr)->NextEntryOffset =
        FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) +
        QuadAlign((*SidListPtr)->SidLength);

    return TRUE;
}

BOOL
DumpVolumeQuotaInfo(
    IN HANDLE hFile,
    IN BOOL DisplayAlways
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_CONTROL_INFORMATION TempControlInfo = {0};
    ULONG StatusId;
    ULONG LoggingId;
    ULONG ValueId;


    Status = NtQueryVolumeInformationFile(
        hFile,
        &IoStatus,
        &TempControlInfo,
        sizeof(FILE_FS_CONTROL_INFORMATION),
        FileFsControlInformation
        );

    //
    //  If quotas aren't enforced or tracked, then quotas must be disabled.
    //
    
    if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) == FILE_VC_QUOTA_NONE) {
        StatusId = MSG_QUOTA_STATUS_DISABLED;
    } else if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) == FILE_VC_QUOTA_TRACK) {
        StatusId = MSG_QUOTA_STATUS_TRACKING;
    } else {
        ASSERT( TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_ENFORCE );
        StatusId = MSG_QUOTA_STATUS_ENFORCE;
    }
    
    if (!DisplayAlways) {
        return StatusId != MSG_QUOTA_STATUS_DISABLED;
    }

    switch (TempControlInfo.FileSystemControlFlags & (FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD)) {
        case FILE_VC_LOG_QUOTA_LIMIT:
            LoggingId = MSG_QUOTA_LOGGING_LIMITS;
            break;

        case FILE_VC_LOG_QUOTA_THRESHOLD:
            LoggingId = MSG_QUOTA_LOGGING_THRESH;
            break;

        case FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD:
            LoggingId = MSG_QUOTA_LOGGING_BOTH;
            break;

        case 0:
            LoggingId = MSG_QUOTA_LOGGING_EVENTS;
            break;
    }

    if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) {
        if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTAS_INCOMPLETE) {
            ValueId = MSG_QUOTA_VALUES_INCOMPLETE;
        } else {
            ValueId = MSG_QUOTA_VALUES_GOOD;
        }
    } else {
        ValueId = MSG_QUOTA_VALUES_GOOD;
    }

    DisplayMsg( MSG_USAGE_QUOTA_VOLUME_INFO, TempControlInfo.FileSystemControlFlags );
    DisplayMsg( StatusId );
    DisplayMsg( LoggingId );
    DisplayMsg( ValueId );
    DisplayMsg( MSG_USAGE_QUOTA_LIMITS,  
        QuadToPaddedHexText( TempControlInfo.DefaultQuotaThreshold.QuadPart ),
        QuadToPaddedHexText( TempControlInfo.DefaultQuotaLimit.QuadPart )
        );

    return TRUE;
}


VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN PWSTR ServerName
    )
{
    NTSTATUS Status;
    SID_NAME_USE SidNameUse;
    ULONG AccountLength, DomainLength;
    WCHAR AccountName[128];
    WCHAR DomainName[128];
    UNICODE_STRING String;

    AccountLength = sizeof(AccountName) - 1;
    DomainLength = sizeof(DomainName) - 1;

    if (FileQuotaInfo->SidLength == 0) {

        DisplayMsg( MSG_QUOTA_DUMP_DEFAULT );

    } else if (LookupAccountSid(
            ServerName,
            &FileQuotaInfo->Sid,
            AccountName,
            &AccountLength,
            DomainName,
            &DomainLength,
            &SidNameUse))
    {

        PWSTR String;

        AccountName[AccountLength] = 0;
        DomainName[DomainLength] = 0;

        DisplayMsg( MSG_QUOTA_SID_USER+SidNameUse-1, DomainName, AccountName );

    } else {

        DisplayError( );
    }

    DisplayMsg(
        MSG_QUOTA_DUMP_INFO,
        FileTimeToString(&FileQuotaInfo->ChangeTime),
        QuadToDecimalText( FileQuotaInfo->QuotaUsed.QuadPart ),
        QuadToDecimalText( FileQuotaInfo->QuotaThreshold.QuadPart ),
        QuadToDecimalText( FileQuotaInfo->QuotaLimit.QuadPart )
        );
}

INT
QueryDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    IO_STATUS_BLOCK IoStatus;
    FILE_QUOTA_INFORMATION QuotaInfo[STRUCT_COUNT(10, FILE_QUOTA_INFORMATION, 4)];
    INT ExitCode = EXIT_CODE_SUCCESS;

    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_QUERY, argv[1] );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    if (!IsVolumeLocalNTFS( argv[0][0] )) {
        DisplayMsg( MSG_NTFS_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    hFile = QuotaOpenVolume( argv[0] );
    if (hFile == INVALID_HANDLE_VALUE) {
        return EXIT_CODE_FAILURE;
    }

    if (!DumpVolumeQuotaInfo( hFile, FALSE )) {
        DisplayMsg( MSG_USAGE_QUOTA_REQUIRED, argv[0] );
        CloseHandle( hFile );
        return EXIT_CODE_FAILURE;
    }

    DumpVolumeQuotaInfo( hFile, TRUE );

    while (TRUE) {

        Status = NtQueryQuotaInformationFile(
            hFile,                      //  File Handle
            &IoStatus,                  //  IO status block
            QuotaInfo,                  //  Buffer
            sizeof(QuotaInfo),          //  Length
            TRUE,                      //  Return Single Entry
            NULL,                       //  SidList
            0,                          //  SidListLength
            NULL,                       //  StartSid
            FALSE                       //  RestartScan
            );

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_ENTRIES) {
                DisplayErrorMsg( RtlNtStatusToDosError( Status ));
                ExitCode = EXIT_CODE_FAILURE;
            }
            break;
        }

        DumpQuota( QuotaInfo, NULL );

    } 

    CloseHandle( hFile );

    return ExitCode;
}


INT
ChangeDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    IO_STATUS_BLOCK IoStatus;
    FILE_QUOTA_INFORMATION QuotaInfo[STRUCT_COUNT(10, FILE_QUOTA_INFORMATION, 4)];
    FILE_GET_QUOTA_INFORMATION SidList[STRUCT_COUNT(10, FILE_GET_QUOTA_INFORMATION, 4)];
    PFILE_QUOTA_INFORMATION QuotaInfoPtr;
    PFILE_GET_QUOTA_INFORMATION SidListPtr;
    ULONG BufferSize;
    ULONG SidListLength;
    PWSTR EndPtr;

    if (argc != 4) {
        DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    if (!IsVolumeLocalNTFS( argv[0][0] )) {
        DisplayMsg( MSG_NTFS_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    RtlZeroMemory(&QuotaInfo, sizeof(QuotaInfo));
    QuotaInfoPtr = QuotaInfo;
    RtlZeroMemory(&SidList, sizeof(SidList));
    SidListPtr = SidList;

    if (!GetUserSid( argv[3], &QuotaInfoPtr, &SidListPtr )) {
        DisplayError();
        return EXIT_CODE_FAILURE;
    }

    QuotaInfoPtr->QuotaThreshold.QuadPart = My_wcstoui64( argv[1], &EndPtr, 0 );
    if (UnsignedI64NumberCheck( QuotaInfoPtr->QuotaThreshold.QuadPart, EndPtr )) {

        DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
        return EXIT_CODE_FAILURE;
    }

    QuotaInfoPtr->QuotaLimit.QuadPart = My_wcstoui64( argv[2], &EndPtr, 0 );
    if (UnsignedI64NumberCheck( QuotaInfoPtr->QuotaLimit.QuadPart, EndPtr )) {

        DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
        return EXIT_CODE_FAILURE;
    }

    //
    // Terminate the list.
    //

    BufferSize = (ULONG)((PCHAR) QuotaInfoPtr - (PCHAR) QuotaInfo + QuotaInfoPtr->NextEntryOffset);
    QuotaInfoPtr->NextEntryOffset = 0;

    SidListLength = (ULONG)((PCHAR) SidListPtr - (PCHAR) SidList + SidListPtr->NextEntryOffset);
    SidListPtr->NextEntryOffset = 0;

    SidListPtr = SidList;

    //
    // Change it
    //

    hFile = QuotaOpenVolume( argv[0] );
    if (hFile == INVALID_HANDLE_VALUE) {
        DisplayError();
        return EXIT_CODE_FAILURE;
    }

    Status = NtSetQuotaInformationFile(
        hFile,
        &IoStatus,
        &QuotaInfo,
        sizeof(QuotaInfo)
        );
    if (!NT_SUCCESS( Status )) {
        DisplayErrorMsg( RtlNtStatusToDosError( Status ));
        CloseHandle( hFile );
        return EXIT_CODE_FAILURE;
    }

    CloseHandle( hFile );

    return EXIT_CODE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\objectid.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    objectid.c

Abstract:

    This file contains code for commands that affect object ids.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
ObjectIdHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_OBJECTID );
    return EXIT_CODE_SUCCESS;
}

VOID
PrintObjectId(
    PFILE_OBJECTID_BUFFER lpOutBuffer
    )
{
    INT Index;

    DisplayMsg( MSG_OBJECTID_TEXT );
    for ( Index = 0 ; Index < 16 ; Index++ ) {
        wprintf( L"%02x", lpOutBuffer->ObjectId[Index] );
    }

    wprintf( L"\n" );

    DisplayMsg( MSG_BIRTHVOLID_TEXT );
    for ( Index = 0 ; Index < 16 ; Index++ ) {
        wprintf( L"%02x", lpOutBuffer->BirthVolumeId[Index] );
    }

    wprintf( L"\n" );
    
    DisplayMsg( MSG_BIRTHOBJECTID_TEXT );
    for ( Index = 0 ; Index < 16 ; Index++ ) {
        wprintf( L"%02x", lpOutBuffer->BirthObjectId[Index] );
    }

    wprintf( L"\n" );
    
    DisplayMsg( MSG_DOMAINID_TEXT );
    for ( Index = 0 ; Index < 16 ; Index++ ) {
        wprintf( L"%02x", lpOutBuffer->DomainId[Index] );
    }
    wprintf( L"\n" );
    
}

UCHAR
GetNibbleValue(
    IN OUT PCWSTR *String
    )
{
    UCHAR v;
    WCHAR c;
    
    c = *(*String)++;
    c = (UCHAR) toupper( c );
    if (isdigit( c )) {
        v = c - L'0';
    } else if (isalpha( c ) && c <= L'F') {
        v = c - L'A' + 10;
    } else {
        (*String)--;
        return 0;
    }
    return v;
}

UCHAR
GetByteValue(
    IN OUT PCWSTR *String
    )
{
    UCHAR v = GetNibbleValue( String );
    v *= 16;
    v += GetNibbleValue( String );
    return v;
}


BOOL
ConvertStringToHexData(
    IN PCWSTR Arg,
    OUT PUCHAR Buffer
    )
{
    int i;

    for (i = 0; i < 16; i++) {
        Buffer[i] = GetByteValue( &Arg );
    }

    return *Arg == L'\0';
}


INT
SetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets the objectID for the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setoid <oid=val> <bvid=val> <boid=val> <did=val> <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PFILE_OBJECTID_BUFFER lpInBuffer = NULL;
    BOOL Status;
    DWORD nInBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 5) {
            DisplayMsg( MSG_USAGE_SETOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[4] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpInBuffer = (PFILE_OBJECTID_BUFFER) malloc ( nInBufferSize );
        if (lpInBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Convert the input strings into the correct data
        //

        if (!ConvertStringToHexData( argv[0], lpInBuffer->ObjectId)
            || !ConvertStringToHexData( argv[1], lpInBuffer->BirthVolumeId)
            || !ConvertStringToHexData( argv[2], lpInBuffer->BirthObjectId)
            || !ConvertStringToHexData( argv[3], lpInBuffer->DomainId)) {
            DisplayMsg( MSG_USAGE_SETOBJECTID );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        EnablePrivilege( SE_RESTORE_NAME );
        
        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_OBJECT_ID,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free(lpInBuffer);
        free( Filename );
    }
    return ExitCode;
}

INT
GetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the objectID associated with the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getoid <pathname> '.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PFILE_OBJECTID_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
          DisplayMsg( MSG_USAGE_GETOBJECTID );
          if (argc != 0) {
              ExitCode = EXIT_CODE_FAILURE;
          }
          leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeNTFS( Filename )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpOutBuffer = (PFILE_OBJECTID_BUFFER) malloc ( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_OBJECT_ID,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        
        if (!Status) {

            if (GetLastError( ) == ERROR_FILE_NOT_FOUND) {
                DisplayMsg( MSG_NO_OBJECT_ID );
            } else {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        PrintObjectId( lpOutBuffer );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free(lpOutBuffer);
        free( Filename );
    }
    
    return ExitCode;
}


INT
CreateOrGetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the objectID for the file, if it exists, else
    creates an objectID and returns it.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl crgetoid <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PFILE_OBJECTID_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_CREATEOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }


        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpOutBuffer = (PFILE_OBJECTID_BUFFER)  malloc ( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_CREATE_OR_GET_OBJECT_ID,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        PrintObjectId( lpOutBuffer );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (lpOutBuffer) {
            free(lpOutBuffer);
        }
        if (Filename) {
            free( Filename );
        }
    }

    return ExitCode;
}


INT
DeleteObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the objectID associated with the file
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl deloid <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    BOOL Status;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {


        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DELETEOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;}
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_OBJECT_ID,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\reparse.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    reparse.c

Abstract:

    This file contains code for commands that affect
    reparse points.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
ReparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_REPARSEPOINT );
    return EXIT_CODE_SUCCESS;
}

//
// Microsoft tags for reparse points.
//

#define MAX_REPARSE_DATA                          0x1000

INT
GetReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the reparse point for the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getrp <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    ULONG ulMask;
    WCHAR Buffer[256];
    LPWSTR GuidStr;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_GETREPARSE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + MAX_REPARSE_DATA;
        lpOutBuffer = (PREPARSE_GUID_DATA_BUFFER)  malloc ( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_REPARSE_POINT,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_GETREPARSE_TAGVAL, lpOutBuffer->ReparseTag );

        if (IsReparseTagMicrosoft( lpOutBuffer->ReparseTag )) {
            DisplayMsg( MSG_TAG_MICROSOFT );
        }
        if (IsReparseTagNameSurrogate( lpOutBuffer->ReparseTag )) {
            DisplayMsg( MSG_TAG_NAME_SURROGATE );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK) {
            DisplayMsg( MSG_TAG_SYMBOLIC_LINK );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {
            DisplayMsg( MSG_TAG_MOUNT_POINT );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_HSM) {
            DisplayMsg( MSG_TAG_HSM );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_SIS) {
            DisplayMsg( MSG_TAG_SIS );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_FILTER_MANAGER) {
            DisplayMsg( MSG_TAG_FILTER_MANAGER );
        }

        Status = StringFromIID( &lpOutBuffer->ReparseGuid, &GuidStr );
        if (Status != S_OK) {
            DisplayErrorMsg( Status );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_GETREPARSE_GUID, GuidStr, lpOutBuffer->ReparseDataLength );
        
        if (lpOutBuffer->ReparseDataLength != 0) {
            int i, j;
            WCHAR Buf[17];
            
            DisplayMsg( MSG_GETREPARSE_DATA );
            for (i = 0; i < lpOutBuffer->ReparseDataLength; i += 16 ) {
                wprintf( L"%04x: ", i );
                for (j = 0; j < 16 && j + i < lpOutBuffer->ReparseDataLength; j++) {
                    UCHAR c = lpOutBuffer->GenericReparseBuffer.DataBuffer[ i + j ];

                    if (c >= 0x20 && c <= 0x7F) {
                        Buf[j] = c;
                    } else {
                        Buf[j] = L'.';
                    }
                    
                    wprintf( L" %02x", c );
                }
                
                Buf[j] = L'\0';
                
                for ( ; j < 16; j++ ) {
                    wprintf( L"   " );
                }

                wprintf( L"  %s\n", Buf );
            }


        }


        CoTaskMemFree(GuidStr);

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpOutBuffer );
        free( Filename );
    }
    return ExitCode;
}


INT
DeleteReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the reparse point associated with
    the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl delrp <pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER lpInOutBuffer = NULL;
    DWORD nInOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_DELETE_REPARSE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInOutBufferSize = REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + MAX_REPARSE_DATA;
        lpInOutBuffer = (PREPARSE_GUID_DATA_BUFFER)  malloc ( nInOutBufferSize );
        if (lpInOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_REPARSE_POINT,
            NULL,
            0,
            (LPVOID) lpInOutBuffer,
            nInOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpInOutBuffer->ReparseDataLength = 0;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_REPARSE_POINT,
            (LPVOID) lpInOutBuffer,
            REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpInOutBuffer );
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\sparse.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sparse.c

Abstract:

    This file contains code for commands that affect
    sparse files.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
SparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_SPARSE );

    return EXIT_CODE_SUCCESS;
}

BOOL
GetSparseFlag( 
    HANDLE Handle
    )
/*++

Routine Description:

    Retrieves the sparse attribute bit from an open file handle. If there's
    an error (due to the file system not supporting FileAttributeTagInformation)
    then we assume that the file cannot be sparse.

Arguments:

    Handle - handle to the stream.

Return Value:

    TRUE => stream attached to Handle is sparse
    FALSE otherwise

--*/
{
    FILE_ATTRIBUTE_TAG_INFORMATION TagInformation;
    IO_STATUS_BLOCK iosb;
    NTSTATUS Status;

    Status = NtQueryInformationFile( Handle, 
                                     &iosb, 
                                     &TagInformation, 
                                     sizeof( TagInformation ), 
                                     FileAttributeTagInformation );

    if (NT_SUCCESS( Status ) && 
        (TagInformation.FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}



INT
SetSparse(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine set the file specified as sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL Status;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_SETSPARSE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_SPARSE,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}


INT
QuerySparse(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries the file specified to see if it is sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PVOID Frs;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
          DisplayMsg( MSG_QUERYSPARSE_USAGE );
          if (argc != 0) {
              ExitCode = EXIT_CODE_FAILURE;
          }
          leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_SPARSE_IS_SET );
        } else {
            DisplayMsg( MSG_SPARSE_ISNOT_SET );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
SetSparseRange(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets a range of the file as sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    FILE_ZERO_DATA_INFORMATION ZeroData;
    ULONG BytesReturned;
    BOOL b;
    PWSTR EndPtr;
    ULONGLONG v;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 3) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (!GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_FILE_IS_NOT_SPARSE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        v = My_wcstoui64( argv[1], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( v, EndPtr)) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        ZeroData.FileOffset.QuadPart = v;


        v = My_wcstoui64( argv[2], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( v, EndPtr)) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        ZeroData.BeyondFinalZero.QuadPart = v + ZeroData.FileOffset.QuadPart;

        b = DeviceIoControl(
            FileHandle,
            FSCTL_SET_ZERO_DATA,
            &ZeroData,
            sizeof(ZeroData),
            NULL,
            0,
            &BytesReturned,
            NULL
            );
        if (!b) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
QuerySparseRange(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries a range of the file specified to see if it is sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL b;
    FILE_ALLOCATED_RANGE_BUFFER RangesIn;
    PFILE_ALLOCATED_RANGE_BUFFER Ranges = NULL;
    ULONG NumRanges = 0;
    ULONG RangesSz = 0;
    ULONG BytesReturned;
    ULONG i;
    ULONG RangesReturned;
    LONGLONG LastOffset = 0;
    LARGE_INTEGER FileSize;
    ULONG gle = 0;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_QUERYSPARSE_RANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (!GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_FILE_IS_NOT_SPARSE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        NumRanges = 64;
        RangesSz = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NumRanges;
        Ranges = (PFILE_ALLOCATED_RANGE_BUFFER) malloc( RangesSz );
        if (Ranges == NULL) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        memset( Ranges, 0, RangesSz );

        GetFileSizeEx( FileHandle, &FileSize );

        RangesIn.FileOffset.QuadPart = 0;
        RangesIn.Length.QuadPart = FileSize.QuadPart;

        do {

            b = DeviceIoControl(
                FileHandle,
                FSCTL_QUERY_ALLOCATED_RANGES,
                &RangesIn,
                sizeof(RangesIn),
                Ranges,
                RangesSz,
                &BytesReturned,
                NULL
                );
            if (!b) {
                gle = GetLastError();
                if (gle == ERROR_INSUFFICIENT_BUFFER) {
                    //
                    //  No data were returned because the buffer is too small
                    //
                    free( Ranges );
                    NumRanges += 64;
                    RangesSz = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NumRanges;
                    Ranges = (PFILE_ALLOCATED_RANGE_BUFFER) malloc( RangesSz );
                    if (Ranges == NULL) {
                        DisplayError();
                        ExitCode = EXIT_CODE_FAILURE;
                        leave;
                    }
                    memset( Ranges, 0, RangesSz );
                } else if (gle == ERROR_MORE_DATA) {

                } else {
                    DisplayError();
                    ExitCode = EXIT_CODE_FAILURE;
                    leave;
                }
            }

            RangesReturned = BytesReturned / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

            for (i=0; i<RangesReturned; i++) {
                if (Ranges[i].FileOffset.QuadPart >= LastOffset) {
                    wprintf( L"sparse range: [%I64d] [%I64d]\n", Ranges[i].FileOffset.QuadPart, Ranges[i].Length.QuadPart );
                }
                LastOffset = Ranges[i].FileOffset.QuadPart;
            }

        } while(gle);

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Ranges );
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\usn.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usn.c

Abstract:

    This file contains code for commands that affect
    the usn journal.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


#define MAX_USN_DATA                              4096

INT
UsnHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_USN );
    return EXIT_CODE_SUCCESS;
}

__inline PUSN_RECORD
NextUsnRecord(
    const PUSN_RECORD input
    )
{
    ULONGLONG output;

    // Get the base address of the current record.
    (PUSN_RECORD) output = input;

    // Add the size of the record (structure + file name after the end
    // of the structure).
    output += input->RecordLength;

    // Round up the record size to match the 64-bit alignment, if the
    // size is not already a multiple of 8. Perform a bitwise AND
    // operation here instead of division because it is much faster than
    // division. However, the bitwise AND operation only works because
    // the divisor 8 is a power of 2.

    if (output & 8-1) {
        // Round down to nearest multiple of 8.
        output &= -8;
        // Then add 8.
        output += 8;
    }

    return((PUSN_RECORD) output);
}

VOID
DisplayUsnRecord(
    const PUSN_RECORD UsnRecord
    )
{

    WCHAR DateString[128];
    WCHAR TimeString[128];
    TIME_FIELDS TimeFields;
    SYSTEMTIME SystemTime;

    RtlTimeToTimeFields(&UsnRecord->TimeStamp, &TimeFields);

    SystemTime.wYear         = TimeFields.Year        ;
    SystemTime.wMonth        = TimeFields.Month       ;
    SystemTime.wDayOfWeek    = TimeFields.Weekday     ;
    SystemTime.wDay          = TimeFields.Day         ;
    SystemTime.wHour         = TimeFields.Hour        ;
    SystemTime.wMinute       = TimeFields.Minute      ;
    SystemTime.wSecond       = TimeFields.Second      ;
    SystemTime.wMilliseconds = TimeFields.Milliseconds;


    GetDateFormat( LOCALE_USER_DEFAULT, 
       DATE_SHORTDATE, 
       &SystemTime, 
       NULL, 
       DateString, 
       sizeof( DateString ) / sizeof( DateString[0] ));

    GetTimeFormat( LOCALE_USER_DEFAULT, 
       FALSE, 
       &SystemTime, 
       NULL, 
       TimeString, 
       sizeof( TimeString ) / sizeof( TimeString[0] ));

    DisplayMsg(
        MSG_USNRECORD,
        UsnRecord->MajorVersion,
        UsnRecord->MinorVersion,
        QuadToPaddedHexText( UsnRecord->FileReferenceNumber ),
        QuadToPaddedHexText( UsnRecord->ParentFileReferenceNumber ),
        QuadToPaddedHexText( UsnRecord->Usn ),
        QuadToPaddedHexText( UsnRecord->TimeStamp.QuadPart ),
        TimeString, DateString,
        UsnRecord->Reason,
        UsnRecord->SourceInfo,
        UsnRecord->SecurityId,
        UsnRecord->FileAttributes,
        UsnRecord->FileNameLength,
        UsnRecord->FileNameOffset,
        UsnRecord->FileNameLength/sizeof(WCHAR),
        UsnRecord->FileName
        );
}


INT
CreateUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine create the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl crusnj m=<max-value> a=<alloc-delta> <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    CREATE_USN_JOURNAL_DATA InBuffer;
    ULONGLONG MaxSize;
    ULONGLONG AllocDelta;
    PWSTR EndPtr;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 3) {
            DisplayMsg( MSG_USAGE_CREATEUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[2][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[2] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (_wcsnicmp( argv[0], L"m=", 2) 
            || wcslen( argv[0] ) == 2) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        if (_wcsnicmp( argv[1], L"a=", 2)
            || wcslen( argv[1] ) == 2) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[1] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        MaxSize = My_wcstoui64( argv[0] + 2, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( MaxSize, EndPtr )) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        AllocDelta = My_wcstoui64( argv[1] + 2, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( AllocDelta, EndPtr )) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[1] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        InBuffer.MaximumSize = MaxSize;
        InBuffer.AllocationDelta = AllocDelta;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_CREATE_USN_JOURNAL,
            &InBuffer,
            sizeof(InBuffer),
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
QueryUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl queryusnj <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    USN_JOURNAL_DATA UsnJournalData;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_QUERYUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_USN_JOURNAL,
            NULL,
            0,
            &UsnJournalData,
            sizeof(USN_JOURNAL_DATA),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg(
            MSG_QUERYUSN,
            QuadToPaddedHexText( UsnJournalData.UsnJournalID ),
            QuadToPaddedHexText( UsnJournalData.FirstUsn ),
            QuadToPaddedHexText( UsnJournalData.NextUsn ),
            QuadToPaddedHexText( UsnJournalData.LowestValidUsn ),
            QuadToPaddedHexText( UsnJournalData.MaxUsn ),
            QuadToPaddedHexText( UsnJournalData.MaximumSize ),
            QuadToPaddedHexText( UsnJournalData.AllocationDelta )
            );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
DeleteUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl delusnj <flags> <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DELETE_USN_JOURNAL_DATA DeleteUsnJournalData;
    USN_JOURNAL_DATA UsnJournalData;
    INT i;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc < 2) {
            DisplayMsg( MSG_USAGE_DELETEUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[argc-1][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[argc-1] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_USN_JOURNAL,
            NULL,
            0,
            &UsnJournalData,
            sizeof(USN_JOURNAL_DATA),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DeleteUsnJournalData.DeleteFlags = USN_DELETE_FLAG_DELETE ;

        for (i = 0; i < argc - 1; i++) {
            if (argv[i][0] == L'/' && wcslen( argv[i] ) == 2) {
                switch (towupper( argv[i][1] ) ) {
                case L'D':
                    DeleteUsnJournalData.DeleteFlags |= USN_DELETE_FLAG_DELETE ;
                    continue;

                case L'N':
                    DeleteUsnJournalData.DeleteFlags |= USN_DELETE_FLAG_NOTIFY ;
                    continue;
                }

            }
            DisplayMsg( MSG_INVALID_PARAMETER, argv[i] );
            DisplayMsg( MSG_USAGE_DELETEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;

        }

        DeleteUsnJournalData.UsnJournalID = UsnJournalData.UsnJournalID;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_USN_JOURNAL,
            &DeleteUsnJournalData,
            sizeof(DELETE_USN_JOURNAL_DATA),
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}

INT
EnumUsnData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine enumerated the USN data associated with the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl enusndata <file ref#> <lowUsn> <highUsn> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    MFT_ENUM_DATA MftEnumData;
    PVOID lpOutBuffer;
    DWORD nOutBufferSize;
    PUSN_RECORD UsnRecord;
    WORD Index;
    LONG Length;
    PWSTR EndStr;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 4) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[argc-1][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, argv[argc-1] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = MAX_USN_DATA;
        lpOutBuffer = (PVOID) malloc ( nOutBufferSize );

        MftEnumData.StartFileReferenceNumber = My_wcstoui64( argv[0], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.StartFileReferenceNumber, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        MftEnumData.LowUsn = My_wcstoui64( argv[1], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.LowUsn, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        MftEnumData.HighUsn = My_wcstoui64( argv[2], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.HighUsn, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        while (TRUE) {
            Status = DeviceIoControl(
                FileHandle,
                FSCTL_ENUM_USN_DATA,
                &MftEnumData,
                sizeof(MFT_ENUM_DATA),
                lpOutBuffer,
                nOutBufferSize,
                &BytesReturned,
                (LPOVERLAPPED)NULL
                );
            if (!Status) {
                if (GetLastError() != ERROR_HANDLE_EOF) {
                    DisplayError();
                    ExitCode = EXIT_CODE_FAILURE;
                }
                leave;
            }

            if ( BytesReturned < sizeof( ULONGLONG ) + sizeof( USN_RECORD )) {
                break;
            }

            UsnRecord = (PUSN_RECORD) ((PBYTE)lpOutBuffer + sizeof( ULONGLONG ));
            while ((PBYTE)UsnRecord < (PBYTE)lpOutBuffer + BytesReturned) {
                DisplayMsg(
                    MSG_ENUMDATA,
                    QuadToPaddedHexText( UsnRecord->FileReferenceNumber ),
                    QuadToPaddedHexText( UsnRecord->ParentFileReferenceNumber ),
                    QuadToPaddedHexText( UsnRecord->Usn ),
                    UsnRecord->SecurityId,
                    UsnRecord->Reason,
                    UsnRecord->FileNameLength,
                    UsnRecord->FileNameLength / sizeof(WCHAR),
                    UsnRecord->FileName
                    );
                UsnRecord = NextUsnRecord( UsnRecord );
            }
            MftEnumData.StartFileReferenceNumber = *(PLONGLONG)lpOutBuffer;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (lpOutBuffer) {
            free( lpOutBuffer );
        }

    }

    return ExitCode;
}


INT
ReadFileUsnData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine reads the usn data for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl rdusndata <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DWORD nOutBufferSize;
    PUSN_RECORD UsnRecord;
    PWSTR FullName;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_READDATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        FullName = GetFullPath( argv[0] );

        if (!FullName) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (!IsVolumeLocalNTFS( FullName[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcscat( FileName, FullName );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = MAX_USN_DATA;
        UsnRecord = (PUSN_RECORD) malloc ( nOutBufferSize );

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_READ_FILE_USN_DATA,
            NULL,
            0,
            UsnRecord,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayUsnRecord( UsnRecord );
    
    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (UsnRecord) {
            free( UsnRecord );
        }

        free( FullName );

    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\volume.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    volume.c

Abstract:

    This file contains code for all commands that effect a volume

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
VolumeHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_VOLUME );

    return EXIT_CODE_SUCCESS;
}

DWORD
QueryHardDiskNumber(
    IN UCHAR DriveLetter
    )
{
    WCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(
        driveName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(
        h,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &number,
        sizeof(number),
        &bytes,
        NULL
        );

    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


INT
DismountVolume(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine dismounts the volume.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl dismountv <volume pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesReturned;
    WCHAR FileName[MAX_PATH];
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DISMOUNTV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, L"\\\\.\\" );
        wcsncat( FileName, argv[0], (sizeof(FileName)/sizeof(WCHAR))-wcslen(FileName) );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DISMOUNT_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
DiskFreeSpace(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine provides information about free disk space in the
    directory path passed in.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
           'fscutl df <drive name>'.

Return Value:

    None

--*/
{
    ULARGE_INTEGER FreeBytesAvailableToCaller; // receives the number of bytes on disk available to the caller
    ULARGE_INTEGER TotalNumberOfBytes;         // receives the number of bytes on disk
    ULARGE_INTEGER TotalNumberOfFreeBytes;     // receives the free bytes on disk
    BOOL Status;                               // return status
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DF );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = GetDiskFreeSpaceEx(
            argv[0],
            &FreeBytesAvailableToCaller,
            &TotalNumberOfBytes,
            &TotalNumberOfFreeBytes
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_DISKFREE, 
                    QuadToDecimalText( TotalNumberOfFreeBytes.QuadPart ), 
                    QuadToDecimalText( TotalNumberOfBytes.QuadPart ), 
                    QuadToDecimalText( FreeBytesAvailableToCaller.QuadPart ));

    } finally {

    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fu\utility.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This file contains utility functions that are
    used by all other files in this project.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
Help(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine lists out the various command supported by the
    tool.

Arguments:

    None

Return Value:

    None

--*/
{
    DisplayMsg( MSG_USAGE );
    return EXIT_CODE_SUCCESS;
}

HANDLE NtDllHandle = INVALID_HANDLE_VALUE;

VOID
DisplayErrorMsg(
    LONG msgId,
    ...
    )
/*++

Routine Description:

    This routine displays the error message correspnding to
    the error indicated by msgId.

Arguments:

    msgId - the errorId. This is either the Win32 status code or the message ID.

Return Value:

    None

--*/
{
    
    va_list args;
    LPWSTR lpMsgBuf;

    va_start( args, msgId );
    
    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_ERROR,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        NULL
        ))
    {
        wprintf( L"%ws", lpMsgBuf );
        LocalFree( lpMsgBuf );
    }

    if (FormatMessage(
        (msgId >= MSG_FIRST_MESSAGE_ID ? FORMAT_MESSAGE_FROM_HMODULE :
                                        FORMAT_MESSAGE_FROM_SYSTEM)
         | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        msgId,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        &args
        ))
    {
        wprintf( L" %ws \n", (LPSTR)lpMsgBuf );
        LocalFree( lpMsgBuf );
    } else {
        if (NtDllHandle == INVALID_HANDLE_VALUE) {
            NtDllHandle = GetModuleHandle( L"NTDLL" );
        }
        
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID)NtDllHandle,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args))
        {
            wprintf( L" %ws \n", (LPSTR)lpMsgBuf );
            LocalFree( lpMsgBuf );
        } else {
            wprintf( L"Unable to format message for id %x - %x\n", msgId, GetLastError( ));
        }
    }
    
    va_end( args );
}


VOID
DisplayMsg(
    LONG msgId,
    ...
    )
/*++

Routine Description:

    This routine displays the error message correspnding to
    the error indicated by msgId.

Arguments:

    msgId - the errorId. This is either the Win32 status or the 
        message Id

Return Value:

    None

--*/
{
    va_list args;
    LPWSTR lpMsgBuf;


    va_start( args, msgId );

    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        msgId,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        &args
        ))
    {
        wprintf( L"%ws", (LPSTR)lpMsgBuf );
        LocalFree( lpMsgBuf );
    } else {
        if (NtDllHandle == INVALID_HANDLE_VALUE) {
            NtDllHandle = GetModuleHandle( L"NTDLL" );
        }
        
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID)NtDllHandle,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args))
        {
            wprintf( L" %ws \n", (LPSTR)lpMsgBuf );
            LocalFree( lpMsgBuf );
        } else {
            wprintf( L"Unable to format message for id %x - %x\n", msgId, GetLastError( ));
        }
    }
    va_end( args );
}

VOID
DisplayError(
    void
    )
/*++

Routine Description:

    This routine displays the last error message.

Arguments:

    None

Return Value:

    None

--*/
{
    DisplayErrorMsg( GetLastError() );
}


BOOL
EnablePrivilege(
    LPCWSTR SePrivilege
    )
{
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    BOOL                b = TRUE;
    BOOL                fRc;
    LUID                LuidPrivilege;

    //
    // Make sure we have access to adjust and to get the old
    // token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token))
    {
        return( FALSE );
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SePrivilege, &LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)
        calloc(1,sizeof(TOKEN_PRIVILEGES) +
               (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL)
    {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    pbOldPriv = OldPriv;
    fRc = AdjustTokenPrivileges( Token,
                                 FALSE,
                                 NewPrivileges,
                                 1024,
                                 (PTOKEN_PRIVILEGES)pbOldPriv,
                                 &cbNeeded );

    if (!fRc)
    {
        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pbOldPriv = (PBYTE)calloc(1,cbNeeded);
            if (pbOldPriv == NULL)
            {
                CloseHandle(Token);
                return(FALSE);
            }

            fRc = AdjustTokenPrivileges( Token,
                                         FALSE,
                                         NewPrivileges,
                                         cbNeeded,
                                         (PTOKEN_PRIVILEGES)pbOldPriv,
                                         &cbNeeded );
        }
    }

    CloseHandle( Token );

    return( b );
}

BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    BOOL b = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup = NULL;

    ImpersonateSelf( SecurityImpersonation );
    
    //
    // Open the process token.
    //
    
    if (OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, FALSE, &Token)) {
        try {

            //
            //  Get SID for Administrators group
            //

            b = AllocateAndInitializeSid(
                    &NtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &AdministratorsGroup
                    );
            if (!b) {
                leave;
            }

            //
            //  Check to see if that group is currently enabled.  Failure
            //  means that we aren't administrator
            //

            if (!CheckTokenMembership( Token, AdministratorsGroup, &b )) {
                printf("Failure - %d\n", GetLastError( ));
                b = FALSE;
            }

        } finally {
            CloseHandle(Token);
        }

    }
    
    RevertToSelf( );
    return(b);
}


BOOL
IsVolumeLocalNTFS(
    WCHAR DriveLetter
    )
{
    BOOL b;
    ULONG i;
    WCHAR DosName[16];
    WCHAR PhysicalName[MAX_PATH];


    DosName[0] = DriveLetter;
    DosName[1] = L':';
    DosName[2] = L'\\';
    DosName[3] = L'\0';

    switch (GetDriveType( DosName )) {
    case DRIVE_UNKNOWN:
    case DRIVE_REMOTE:
        return FALSE;
    }
    
    b = GetVolumeInformation(
        DosName,
        NULL,
        0,
        NULL,
        &i,
        &i,
        PhysicalName,
        sizeof(PhysicalName)/sizeof(WCHAR)
        );
    if (!b ) {
        DisplayError();
        return FALSE;
    }

    if (_wcsicmp( PhysicalName, L"NTFS" ) != 0) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsVolumeNTFS(
    PWCHAR path
    )
{
    //
    //  Scan backwards through the path looking for \ and trying at each level until we
    //  get to the root. We'll terminate it there and pass it to GetVolumeInformation
    //

    PWCHAR LastBackSlash = path + wcslen( path );
    WCHAR c;
    BOOL b;
    ULONG i;
    WCHAR PhysicalName[MAX_PATH];

    
    while (TRUE) {
        while (TRUE) {
            if (LastBackSlash < path) {
                DisplayError();
                return FALSE;
            }

            if (*LastBackSlash == L'\\') {
                break;
            }

            LastBackSlash--;
        }

        c = LastBackSlash[1];
        LastBackSlash[1] = L'\0';

        b = GetVolumeInformation(
            path,
            NULL,
            0,
            NULL,
            &i,
            &i,
            PhysicalName,
            sizeof(PhysicalName)/sizeof(WCHAR)
            );

        LastBackSlash[1] = c;
        LastBackSlash--;

        if ( b ) {
            return _wcsicmp( PhysicalName, L"NTFS" ) == 0;
        }
    }
}

BOOL
IsVolumeLocal(
    WCHAR DriveLetter
    )
{
    BOOL b;
    ULONG i;
    WCHAR DosName[16];
    WCHAR PhysicalName[MAX_PATH];


    DosName[0] = DriveLetter;
    DosName[1] = L':';
    DosName[2] = L'\\';
    DosName[3] = L'\0';

    switch (GetDriveType( DosName )) {
    case DRIVE_UNKNOWN:
    case DRIVE_REMOTE:
        return FALSE;
    }
    return TRUE;
}

PWSTR
GetFullPath(
    IN PWSTR FilenameIn
    )
{
    WCHAR Filename[MAX_PATH];
    PWSTR FilePart;

    if (!GetFullPathName( FilenameIn, sizeof(Filename)/sizeof(WCHAR), Filename, &FilePart )) {
        return NULL;
    }

    return _wcsdup( Filename );
}

//
//  I64-width number formatting is broken in FormatMessage.  We have to convert the numbers
//  ourselves and then display them as strings.  Rather than declaring buffers on the stack,
//  we will allocate space dynamically, and format the text into that spot.
//
//  While *TECHNICALLY* this is a leak, the utility quickly exits.
//

#define NUMERICBUFFERLENGTH 40

PWSTR
QuadToDecimalText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%I64u", Value );
    return Buffer;
}

PWSTR
QuadToHexText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%I64x", Value );
    return Buffer;
}

PWSTR
QuadToPaddedHexText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%016I64x", Value );
    return Buffer;
}

#if TRUE
/***
*wcstoq, wcstouq(nptr,endptr,ibase) - Convert ascii string to un/signed	__int64.
*
*Purpose:
*	Convert an ascii string to a 64-bit __int64 value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First wchar_t = '0', second wchar_t = 'x' or 'X',
*		    use base 16.
*		(b) First wchar_t = '0', use base 8
*		(c) First wchar_t in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then wcstoq/wcstouq places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		wcstoq -- _I64_MAX or _I64_MIN
*		wcstouq -- _UI64_MAX
*		wcstoq/wcstouq -- errno == ERANGE
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstouq called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl wcstoxq (
	const wchar_t *nptr,
	const wchar_t **endptr,
	int ibase,
	int flags
	)
{
	const wchar_t *p;
	wchar_t c;
	unsigned __int64 number;
	unsigned digval;
	unsigned __int64 maxval;

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read wchar_t */
    while ( iswspace(c) )
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (c != '0')
			ibase = 10;
		else if (*p == 'x' || *p == 'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
		if (c == '0' && (*p == 'x' || *p == 'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = _UI64_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if ( isdigit((unsigned)c) )
			digval = c - '0';
		else if ( isalpha((unsigned)c) )
			digval = toupper(c) - 'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned __int64)digval <= _UI64_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
        /* store beginning of string in endptr later on */
	   	p = nptr;
		number = 0L;		/* return 0 */
	}
	else if ((flags & FL_OVERFLOW) ||
             (!(flags & FL_UNSIGNED) &&
              (number & ((unsigned __int64)_I64_MAX+1)))) {
		/* overflow occurred or signed overflow occurred */
		errno = ERANGE;
		if (flags & FL_UNSIGNED)
			number = _UI64_MAX;
		else
			/* set error code, will be negated if necc. */
			number = _I64_MAX;
        flags &= ~FL_NEG;
    	}
    else if ((flags & FL_UNSIGNED) && (flags & FL_NEG)) {
        //  Disallow a negative sign if we're reading an unsigned
        number = 0L;
        p = nptr;
    }

	if (endptr != NULL)
		/* store pointer to wchar_t that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned __int64)(-(__int64)number);

	return number;			/* done. */
}


__int64  __cdecl My_wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    )
{
    return (__int64) wcstoxq(nptr, endptr, ibase, 0);
}
unsigned __int64  __cdecl My_wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return wcstoxq(nptr, endptr, ibase, FL_UNSIGNED);
}

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*           (a) First char = '0', second char = 'x' or 'X',
*               use base 16.
*           (b) First char = '0', use base 8
*           (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*           result
*
*       Overflow return:
*           wcstol -- LONG_MAX or LONG_MIN
*           wcstoul -- ULONG_MAX
*           wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*           0
*           endptr = nptr*
*
*Exceptions:
*       None.
*
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl wcstoxl (
        const wchar_t *nptr,
        const wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;           /* p is our scanning pointer */
        number = 0;         /* start with zero */

        c = *p++;           /* read char */

        while ( iswspace(c) )
            c = *p++;       /* skip whitespace */

        if (c == '-') {
            flags |= FL_NEG;    /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;       /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
            /* bad base! */
            if (endptr)
                /* store beginning of string in endptr */
                *endptr = nptr;
            return 0L;      /* return 0 */
        }
        else if (ibase == 0) {
            /* determine base free-lance, based on first two chars of
               string */
            if (c != L'0')
                ibase = 10;
            else if (*p == L'x' || *p == L'X')
                ibase = 16;
            else
                ibase = 8;
        }

        if (ibase == 16) {
            /* we might have 0x in front of number; remove if there */
            if (c == L'0' && (*p == L'x' || *p == L'X')) {
                ++p;
                c = *p++;   /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {  /* exit in middle of loop */

            /* make sure c is not too big */
            if ( (unsigned)c > UCHAR_MAX )
                break;

            /* convert c to value */
            if ( iswdigit(c) )
                digval = c - L'0';
            else if ( iswalpha(c))
                digval = towupper(c) - L'A' + 10;
            else
                break;

            if (digval >= (unsigned)ibase)
                break;      /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) {
                /* we won't overflow, go ahead and multiply */
                number = number * ibase + digval;
            }
            else {
                /* we would have overflowed -- set the overflow flag */
                flags |= FL_OVERFLOW;
            }

            c = *p++;       /* read next digit */
        }

        --p;                /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;
            number = 0L;        /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                number = ULONG_MAX;
            else
                number = LONG_MAX;
            flags &= ~FL_NEG;
        }
        else if ((flags & FL_UNSIGNED) && (flags & FL_NEG)) {
            //  Disallow a negative sign if we're reading an unsigned
            number = 0L;
            p = nptr;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = p;

        if (flags & FL_NEG)
            /* negate result if there was a neg sign */
            number = (unsigned long)(-(long)number);

        return number;          /* done. */
}

long __cdecl My_wcstol (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (long) wcstoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl My_wcstoul (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}

#else
#define My_wcstoui64    _wcstoui64
#define My_wcstoul      _wcstoul
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\ntfskd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NtfsKd.c

Abstract:

    KD Extension Api for examining Ntfs specific data structures

Author:

    Keith Kaplan [KeithKa]    24-Apr-1996
    Portions by Jeff Havens
    Ported to IA64 (wesw)     5-Aug-2000

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#undef FlagOn
#undef WordAlign
#undef LongAlign
#undef QuadAlign
#undef DebugPrint
#undef MAXULONGLONG

#define KDEXT
#include "gentable.h"

#undef DebugTrace
#include <cc.h>

#undef UpdateSequenceStructureSize
#undef UpdateSequenceArraySize
#include <lfsdisk.h>
#pragma hdrstop


#define AVERAGE(TOTAL,COUNT) ((COUNT) != 0 ? (TOTAL)/(COUNT) : 0)

const UCHAR FileSignature[4] = {'F', 'I', 'L', 'E'};


VOID
ResetFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );

VOID
DumpFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );


/*
 * Dump structures
 */

typedef struct _STATE {
    ULONG mask;
    ULONG value;
    CHAR *pszname;
} STATE;

STATE CcbState[] = {

    {   CCB_FLAG_IGNORE_CASE,               CCB_FLAG_IGNORE_CASE,               "IgnoreCase"},
    {   CCB_FLAG_OPEN_AS_FILE,              CCB_FLAG_OPEN_AS_FILE,              "OpenAsFile"},
    {   CCB_FLAG_WILDCARD_IN_EXPRESSION,    CCB_FLAG_WILDCARD_IN_EXPRESSION,    "WildcardInExpression"},
    {   CCB_FLAG_OPEN_BY_FILE_ID,           CCB_FLAG_OPEN_BY_FILE_ID,           "OpenByFileId"},
    {   CCB_FLAG_USER_SET_LAST_MOD_TIME,    CCB_FLAG_USER_SET_LAST_MOD_TIME,    "SetLastModTime"},
    {   CCB_FLAG_USER_SET_LAST_CHANGE_TIME, CCB_FLAG_USER_SET_LAST_CHANGE_TIME, "SetLastChangeTime"},
    {   CCB_FLAG_USER_SET_LAST_ACCESS_TIME, CCB_FLAG_USER_SET_LAST_ACCESS_TIME, "SetLastAccessTime"},
    {   CCB_FLAG_TRAVERSE_CHECK,            CCB_FLAG_TRAVERSE_CHECK,            "TraverseCheck"},
    {   CCB_FLAG_RETURN_DOT,                CCB_FLAG_RETURN_DOT,                "ReturnDot"},
    {   CCB_FLAG_RETURN_DOTDOT,             CCB_FLAG_RETURN_DOTDOT,             "ReturnDotDot"},
    {   CCB_FLAG_DOT_RETURNED,              CCB_FLAG_DOT_RETURNED,              "DotReturned"},
    {   CCB_FLAG_DOTDOT_RETURNED,           CCB_FLAG_DOTDOT_RETURNED,           "DotDotReturned"},
    {   CCB_FLAG_DELETE_FILE,               CCB_FLAG_DELETE_FILE,               "DeleteFile"},
    {   CCB_FLAG_DENY_DELETE,               CCB_FLAG_DENY_DELETE,               "DenyDelete"},
    {   CCB_FLAG_ALLOCATED_FILE_NAME,       CCB_FLAG_ALLOCATED_FILE_NAME,       "AllocatedFileName"},
    {   CCB_FLAG_CLEANUP,                   CCB_FLAG_CLEANUP,                   "Cleanup"},
    {   CCB_FLAG_SYSTEM_HIVE,               CCB_FLAG_SYSTEM_HIVE,               "SystemHive"},
    {   CCB_FLAG_PARENT_HAS_DOS_COMPONENT,  CCB_FLAG_PARENT_HAS_DOS_COMPONENT,  "ParentHasDosComponent"},
    {   CCB_FLAG_DELETE_ON_CLOSE,           CCB_FLAG_DELETE_ON_CLOSE,           "DeleteOnClose"},
    {   CCB_FLAG_CLOSE,                     CCB_FLAG_CLOSE,                     "Close"},
    {   CCB_FLAG_UPDATE_LAST_MODIFY,        CCB_FLAG_UPDATE_LAST_MODIFY,        "UpdateLastModify"},
    {   CCB_FLAG_UPDATE_LAST_CHANGE,        CCB_FLAG_UPDATE_LAST_CHANGE,        "UpdateLastChange"},
    {   CCB_FLAG_SET_ARCHIVE,               CCB_FLAG_SET_ARCHIVE,               "SetArchive"},
    {   CCB_FLAG_DIR_NOTIFY,                CCB_FLAG_DIR_NOTIFY,                "DirNotify"},
    {   CCB_FLAG_ALLOW_XTENDED_DASD_IO,     CCB_FLAG_ALLOW_XTENDED_DASD_IO,     "AllowExtendedDasdIo"},
    {   CCB_FLAG_READ_CONTEXT_ALLOCATED,    CCB_FLAG_READ_CONTEXT_ALLOCATED,    "ReadContextAllocated"},
    {   CCB_FLAG_DELETE_ACCESS,             CCB_FLAG_DELETE_ACCESS,             "DeleteAccess"},

    { 0 }
};

STATE FcbState[] = {

    {   FCB_STATE_FILE_DELETED,             FCB_STATE_FILE_DELETED,             "FileDeleted" },
    {   FCB_STATE_NONPAGED,                 FCB_STATE_NONPAGED,                 "Nonpaged" },
    {   FCB_STATE_PAGING_FILE,              FCB_STATE_PAGING_FILE,              "PagingFile" },
    {   FCB_STATE_DUP_INITIALIZED,          FCB_STATE_DUP_INITIALIZED,          "DupInitialized" },
    {   FCB_STATE_UPDATE_STD_INFO,          FCB_STATE_UPDATE_STD_INFO,          "UpdateStdInfo" },
    {   FCB_STATE_PRIMARY_LINK_DELETED,     FCB_STATE_PRIMARY_LINK_DELETED,     "PrimaryLinkDeleted" },
    {   FCB_STATE_IN_FCB_TABLE,             FCB_STATE_IN_FCB_TABLE,             "InFcbTable" },
    {   FCB_STATE_SYSTEM_FILE,              FCB_STATE_SYSTEM_FILE,              "SystemFile" },
    {   FCB_STATE_COMPOUND_DATA,            FCB_STATE_COMPOUND_DATA,            "CompoundData" },
    {   FCB_STATE_COMPOUND_INDEX,           FCB_STATE_COMPOUND_INDEX,           "CompoundIndex" },
    {   FCB_STATE_LARGE_STD_INFO,           FCB_STATE_LARGE_STD_INFO,           "LargeStdInfo" },
    {   FCB_STATE_MODIFIED_SECURITY,        FCB_STATE_MODIFIED_SECURITY,        "ModifiedSecurity" },
    {   FCB_STATE_DIRECTORY_ENCRYPTED,      FCB_STATE_DIRECTORY_ENCRYPTED,      "DirectoryEncrypted" },
    {   FCB_STATE_VALID_USN_NAME,           FCB_STATE_VALID_USN_NAME,           "ValidUsnName" },
    {   FCB_STATE_USN_JOURNAL,              FCB_STATE_USN_JOURNAL,              "UsnJournal" },
    {   FCB_STATE_ENCRYPTION_PENDING,       FCB_STATE_ENCRYPTION_PENDING,       "EncryptionPending" },

    { 0 }
};

STATE NtfsFlags[] = {

    {   NTFS_FLAGS_SMALL_SYSTEM,            NTFS_FLAGS_SMALL_SYSTEM,            "SmallSystem" },
    {   NTFS_FLAGS_MEDIUM_SYSTEM,           NTFS_FLAGS_MEDIUM_SYSTEM,           "MediumSystem" },
    {   NTFS_FLAGS_LARGE_SYSTEM,            NTFS_FLAGS_LARGE_SYSTEM,            "LargeSystem" },
    {   NTFS_FLAGS_CREATE_8DOT3_NAMES,      NTFS_FLAGS_CREATE_8DOT3_NAMES,      "Create8dot3names" },
    {   NTFS_FLAGS_ALLOW_EXTENDED_CHAR,     NTFS_FLAGS_ALLOW_EXTENDED_CHAR,     "AllowExtendedChar" },
    {   NTFS_FLAGS_DISABLE_LAST_ACCESS,     NTFS_FLAGS_DISABLE_LAST_ACCESS,     "DisableLastAccess" },
    {   NTFS_FLAGS_ENCRYPTION_DRIVER,       NTFS_FLAGS_ENCRYPTION_DRIVER,       "EncryptionDriver" },

    { 0 }
};

STATE ScbState[] = {

    {   SCB_STATE_TRUNCATE_ON_CLOSE,        SCB_STATE_TRUNCATE_ON_CLOSE,        "TruncateOnClose" },
    {   SCB_STATE_DELETE_ON_CLOSE,          SCB_STATE_DELETE_ON_CLOSE,          "DeleteOnClose" },
    {   SCB_STATE_CHECK_ATTRIBUTE_SIZE,     SCB_STATE_CHECK_ATTRIBUTE_SIZE,     "CheckAttributeSize" },
    {   SCB_STATE_ATTRIBUTE_RESIDENT,       SCB_STATE_ATTRIBUTE_RESIDENT,       "AttributeResident" },
    {   SCB_STATE_UNNAMED_DATA,             SCB_STATE_UNNAMED_DATA,             "UnnamedData" },
    {   SCB_STATE_HEADER_INITIALIZED,       SCB_STATE_HEADER_INITIALIZED,       "HeaderInitialized" },
    {   SCB_STATE_NONPAGED,                 SCB_STATE_NONPAGED,                 "Nonpaged" },
    {   SCB_STATE_USA_PRESENT,              SCB_STATE_USA_PRESENT,              "UsaPresent" },
    {   SCB_STATE_ATTRIBUTE_DELETED,        SCB_STATE_ATTRIBUTE_DELETED,        "AttributeDeleted" },
    {   SCB_STATE_FILE_SIZE_LOADED,         SCB_STATE_FILE_SIZE_LOADED,         "FileSizeLoaded" },
    {   SCB_STATE_MODIFIED_NO_WRITE,        SCB_STATE_MODIFIED_NO_WRITE,        "ModifiedNoWrite" },
    {   SCB_STATE_SUBJECT_TO_QUOTA,         SCB_STATE_SUBJECT_TO_QUOTA,         "SubjectToQuota" },
    {   SCB_STATE_UNINITIALIZE_ON_RESTORE,  SCB_STATE_UNINITIALIZE_ON_RESTORE,  "UninitializeOnRestore" },
    {   SCB_STATE_RESTORE_UNDERWAY,         SCB_STATE_RESTORE_UNDERWAY,         "RestoreUnderway" },
    {   SCB_STATE_NOTIFY_ADD_STREAM,        SCB_STATE_NOTIFY_ADD_STREAM,        "NotifyAddStream" },
    {   SCB_STATE_NOTIFY_REMOVE_STREAM,     SCB_STATE_NOTIFY_REMOVE_STREAM,     "NotifyRemoveStream" },
    {   SCB_STATE_NOTIFY_RESIZE_STREAM,     SCB_STATE_NOTIFY_RESIZE_STREAM,     "NotifyResizeStream" },
    {   SCB_STATE_NOTIFY_MODIFY_STREAM,     SCB_STATE_NOTIFY_MODIFY_STREAM,     "NotifyModifyStream" },
    {   SCB_STATE_TEMPORARY,                SCB_STATE_TEMPORARY,                "Temporary" },
    {   SCB_STATE_WRITE_COMPRESSED,         SCB_STATE_WRITE_COMPRESSED,         "Compressed" },
    {   SCB_STATE_REALLOCATE_ON_WRITE,      SCB_STATE_REALLOCATE_ON_WRITE,      "DeallocateOnWrite" },
    {   SCB_STATE_DELAY_CLOSE,              SCB_STATE_DELAY_CLOSE,              "DelayClose" },
    {   SCB_STATE_WRITE_ACCESS_SEEN,        SCB_STATE_WRITE_ACCESS_SEEN,        "WriteAccessSeen" },
    {   SCB_STATE_CONVERT_UNDERWAY,         SCB_STATE_CONVERT_UNDERWAY,         "ConvertUnderway" },
    {   SCB_STATE_VIEW_INDEX,               SCB_STATE_VIEW_INDEX,               "ViewIndex" },
    {   SCB_STATE_DELETE_COLLATION_DATA,    SCB_STATE_DELETE_COLLATION_DATA,    "DeleteCollationData" },
    {   SCB_STATE_VOLUME_DISMOUNTED,        SCB_STATE_VOLUME_DISMOUNTED,        "VolumeDismounted" },
    {   SCB_STATE_PROTECT_SPARSE_MCB,       SCB_STATE_PROTECT_SPARSE_MCB,       "ProtectSparseMcb" },
    {   SCB_STATE_MULTIPLE_OPENS,           SCB_STATE_MULTIPLE_OPENS,           "MultipleOpens" },

    { 0 }
};

STATE ScbPersist[] = {

    {   SCB_PERSIST_USN_JOURNAL,            SCB_PERSIST_USN_JOURNAL,            "UsnJournal" },

    { 0 }
};

STATE VcbState[] = {

    {   VCB_STATE_VOLUME_MOUNTED,           VCB_STATE_VOLUME_MOUNTED,           "Mounted" },
    {   VCB_STATE_LOCKED,                   VCB_STATE_LOCKED,                   "Locked" },
    {   VCB_STATE_REMOVABLE_MEDIA,          VCB_STATE_REMOVABLE_MEDIA,          "RemovableMedia" },
    {   VCB_STATE_VOLUME_MOUNTED_DIRTY,     VCB_STATE_VOLUME_MOUNTED_DIRTY,     "MountedDirty" },
    {   VCB_STATE_RESTART_IN_PROGRESS,      VCB_STATE_RESTART_IN_PROGRESS,      "RestartInProgress" },
    {   VCB_STATE_FLAG_SHUTDOWN,            VCB_STATE_FLAG_SHUTDOWN,            "FlagShutdown" },
    {   VCB_STATE_NO_SECONDARY_AVAILABLE,   VCB_STATE_NO_SECONDARY_AVAILABLE,   "NoSecondaryAvailable" },
    {   VCB_STATE_RELOAD_FREE_CLUSTERS,     VCB_STATE_RELOAD_FREE_CLUSTERS,     "ReloadFreeClusters" },
    {   VCB_STATE_PRELOAD_MFT,              VCB_STATE_PRELOAD_MFT,              "PreloadMft" },
    {   VCB_STATE_VOL_PURGE_IN_PROGRESS,    VCB_STATE_VOL_PURGE_IN_PROGRESS,    "VolPurgeInProgress" },
    {   VCB_STATE_TEMP_VPB,                 VCB_STATE_TEMP_VPB,                 "TempVpb" },
    {   VCB_STATE_PERFORMED_DISMOUNT,       VCB_STATE_PERFORMED_DISMOUNT,       "PerformedDismount" },
    {   VCB_STATE_VALID_LOG_HANDLE,         VCB_STATE_VALID_LOG_HANDLE,         "ValidLogHandle" },
    {   VCB_STATE_DELETE_UNDERWAY,          VCB_STATE_DELETE_UNDERWAY,          "DeleteUnderway" },
    {   VCB_STATE_REDUCED_MFT,              VCB_STATE_REDUCED_MFT,              "ReducedMft" },
    {   VCB_STATE_EXPLICIT_LOCK,            VCB_STATE_EXPLICIT_LOCK,            "ExplicitLock" },
    {   VCB_STATE_DISALLOW_DISMOUNT,        VCB_STATE_DISALLOW_DISMOUNT,        "DisallowDismount" },
    {   VCB_STATE_VALID_OBJECT_ID,          VCB_STATE_VALID_OBJECT_ID,          "ValidObjectId" },
    {   VCB_STATE_OBJECT_ID_CLEANUP,        VCB_STATE_OBJECT_ID_CLEANUP,        "ObjectIdCleanup" },
    {   VCB_STATE_USN_DELETE,               VCB_STATE_USN_DELETE,               "UsnDelete" },
    {   VCB_STATE_USN_JOURNAL_PRESENT,      VCB_STATE_USN_JOURNAL_PRESENT,      "UsnJournalPresent" },
    {   VCB_STATE_EXPLICIT_DISMOUNT,        VCB_STATE_EXPLICIT_DISMOUNT,        "ExplicitDismount" },

    { 0 }
};

STATE LcbState[] = {
    {   LCB_STATE_DELETE_ON_CLOSE,          LCB_STATE_DELETE_ON_CLOSE,          "DeleteOnClose" },
    {   LCB_STATE_LINK_IS_GONE,             LCB_STATE_LINK_IS_GONE,             "LinkIsGone" },
    {   LCB_STATE_EXACT_CASE_IN_TREE,       LCB_STATE_EXACT_CASE_IN_TREE,       "ExactCaseInTree" },
    {   LCB_STATE_IGNORE_CASE_IN_TREE,      LCB_STATE_IGNORE_CASE_IN_TREE,      "IgnoreCaseInTree" },
    {   LCB_STATE_DESIGNATED_LINK,          LCB_STATE_DESIGNATED_LINK,          "DesignatedLink" },
    {   LCB_STATE_VALID_HASH_VALUE,         LCB_STATE_VALID_HASH_VALUE,         "ValidHashValue" },

    { 0 }
};

char* LogOperation[] = {

    { "Noop                         " },
    { "CompensationLogRecord        " },
    { "InitializeFileRecordSegment  " },
    { "DeallocateFileRecordSegment  " },
    { "WriteEndOfFileRecordSegment  " },
    { "CreateAttribute              " },
    { "DeleteAttribute              " },
    { "UpdateResidentValue          " },
    { "UpdateNonresidentValue       " },
    { "UpdateMappingPairs           " },
    { "DeleteDirtyClusters          " },
    { "SetNewAttributeSizes         " },
    { "AddIndexEntryRoot            " },
    { "DeleteIndexEntryRoot         " },
    { "AddIndexEntryAllocation      " },
    { "DeleteIndexEntryAllocation   " },
    { "WriteEndOfIndexBuffer        " },
    { "SetIndexEntryVcnRoot         " },
    { "SetIndexEntryVcnAllocation   " },
    { "UpdateFileNameRoot           " },
    { "UpdateFileNameAllocation     " },
    { "SetBitsInNonresidentBitMap   " },
    { "ClearBitsInNonresidentBitMap " },
    { "HotFix                       " },
    { "EndTopLevelAction            " },
    { "PrepareTransaction           " },
    { "CommitTransaction            " },
    { "ForgetTransaction            " },
    { "OpenNonresidentAttribute     " },
    { "OpenAttributeTableDump       " },
    { "AttributeNamesDump           " },
    { "DirtyPageTableDump           " },
    { "TransactionTableDump         " },
    { "UpdateRecordDataRoot         " },
    { "UpdateRecordDataAllocation   " }
};

#define LastLogOperation 0x22

char* AttributeTypeCode[] = {

    { "$UNUSED                " },   //  (0X0)
    { "$STANDARD_INFORMATION  " },   //  (0x10)
    { "$ATTRIBUTE_LIST        " },   //  (0x20)
    { "$FILE_NAME             " },   //  (0x30)
    { "$OBJECT_ID             " },   //  (0x40)
    { "$SECURITY_DESCRIPTOR   " },   //  (0x50)
    { "$VOLUME_NAME           " },   //  (0x60)
    { "$VOLUME_INFORMATION    " },   //  (0x70)
    { "$DATA                  " },   //  (0x80)
    { "$INDEX_ROOT            " },   //  (0x90)
    { "$INDEX_ALLOCATION      " },   //  (0xA0)
    { "$BITMAP                " },   //  (0xB0)
    { "$REPARSE_POINT         " },   //  (0xC0)
    { "$EA_INFORMATION        " },   //  (0xD0)
    { "$EA                    " },   //  (0xE0)
    { "   INVALID TYPE CODE   " },   //  (0xF0)
    { "$LOGGED_UTILITY_STREAM " }    //  (0x100)
};


char * LogEvent[] =
{
    "SCE_VDL_CHANGE",
    "SCE_ZERO_NC",
    "SCE_ZERO_C",
    "SCE_READ",
    "SCE_WRITE",
    "SCE_ZERO_CAV",
    "SCE_ZERO_MF",
    "SCE_ZERO_FST",
    "SCE_CC_FLUSH",
    "SCE_CC_FLUSH_AND_PURGE",
    "SCE_WRITE_FILE_SIZES",
    "SCE_ADD_ALLOCATION",     
    "SCE_ADD_SP_ALLOCATION",
    "SCE_SETCOMP_ADD_ALLOCATION",     
    "SCE_SETSPARSE_ADD_ALLOCATION",   
    "SCE_MOD_ATTR_ADD_ALLOCATION",    
    "SCE_REALLOC1",                   
    "SCE_REALLOC2",                   
    "SCE_REALLOC3",                   
    "SCE_SETCOMPRESS",                
    "SCE_SETSPARSE",                  
    "SCE_ZERO_STREAM",                
    "SCE_VDD_CHANGE",                 
    "SCE_CC_SET_SIZE",
    "SCE_ZERO_C_TAIL_COMPRESSION",
    "SCE_ZERO_C_HEAD_COMPRESSION",
    "SCE_MAX_EVENT"
};


struct {
    NODE_TYPE_CODE TypeCode;
    char *Text;
} NodeTypeCodes[] = {
    {   NTFS_NTC_DATA_HEADER,       "Data Header" },
    {   NTFS_NTC_VCB,               "Vcb" },
    {   NTFS_NTC_FCB,               "Fcb" },
    {   NTFS_NTC_SCB_INDEX,         "ScbIndex" },
    {   NTFS_NTC_SCB_ROOT_INDEX,    "ScbRootIndex" },
    {   NTFS_NTC_SCB_DATA,          "ScbData" },
    {   NTFS_NTC_SCB_MFT,           "ScbMft" },
    {   NTFS_NTC_SCB_NONPAGED,      "ScbNonPaged" },
    {   NTFS_NTC_CCB_INDEX,         "CcbIndex" },
    {   NTFS_NTC_CCB_DATA,          "CcbData" },
    {   NTFS_NTC_IRP_CONTEXT,       "IrpContext" },
    {   NTFS_NTC_LCB,               "Lcb" },
    {   NTFS_NTC_PREFIX_ENTRY,      "PrefixEntry" },
    {   NTFS_NTC_QUOTA_CONTROL,     "QuotaControl" },
    {   NTFS_NTC_USN_RECORD,        "UsnRecord" },
    {   0,                          "Unknown" }
};



ULONG
MyGetFieldData(
    IN  ULONG64 TypeAddress,
    IN  PUCHAR  Type,
    IN  PUCHAR  Field,
    IN  ULONG   OutSize,
    OUT PULONG64 pOutValue,
    OUT PULONG64 pOutAddress
   )

/*++

Routine Description:

    Retrieves the symbol information for a field within a structure.

Arguments:

    TypeAddress - Virtual address of the structure
    Type - Qualified type string
    Field - Field name
    OutSize - Size of the field
    pOutValue - Value of the vield
    pOutAddress - Virtual address of the field

Return Value:

    Zero is success otherwise failure.

--*/

{
    ULONG RetVal = 0;
    FIELD_INFO flds = {
        Field,
        NULL,
        OutSize,
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS,
        0,
        pOutValue
    };
    SYM_DUMP_PARAM Sym = {
        sizeof(SYM_DUMP_PARAM),
        Type,
        DBG_DUMP_NO_PRINT,
        TypeAddress,
        NULL,
        NULL,
        NULL,
        1,
        &flds
    };

    ZeroMemory( pOutValue, OutSize );
    RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

    if (OutSize < flds.size) {
        if (OutSize == sizeof(ULONG64)) {
            *pOutValue = Sym.Fields->address;
        } else {
            memset( pOutValue, 0, OutSize );
        }
    }

    if (pOutAddress) {
        if (RetVal == 0) {
            *pOutAddress = Sym.Fields->address;
        } else {
            *pOutAddress = 0;
        }
    }

    return RetVal;
}


VOID
DumpValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Prints the value of a 64/32 bit value based on
    a symbol name and address.

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    None.

--*/

{
    static ULONG64 ValueBuffer[128];
    ULONG64 Value,OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    dprintf( "\n(%03x) ", (ULONG)(OutputAddress-Address) );
    dprintf( " %s", FormatValue(Value) );
    dprintf( "  %s ", Field );
}


VOID
DumpPtrValue(
    IN ULONG64 Address,
    IN PCHAR TextStr
    )

/*++

Routine Description:

    Prints the value of a pointer.

Arguments:

    Address - Virtual address of the value
    TextStr - Tag to print with the pointer value

Return Value:

    None.

--*/

{
    ULONG64 PtrValue;
    ULONG BytesRead;
    if (ReadMemory( Address, &PtrValue, sizeof(PtrValue), &BytesRead )) {
        dprintf( "\n       %s  %s", FormatValue(PtrValue), TextStr );
    }
}


ULONG64
ReadValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 64/32 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 64/32 bit value or zero.

--*/

{
    static ULONG64 ValueBuffer[128];
    ULONG64 Value,OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


ULONG
ReadUlongValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 32 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 32 bit value or zero.

--*/

{
    static ULONG ValueBuffer[128];
    ULONG Value;
    ULONG64 OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


USHORT
ReadShortValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 16 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 16 bit value or zero.

--*/

{
    static USHORT ValueBuffer[128];
    USHORT Value;
    ULONG64 OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


VOID
DumpUnicodeString(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Prints the value (the actual string) of a string
    contained in a UNICODE_STRING structure

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the string
    Field - Field name for the string

Return Value:

    None.

--*/

{
    ULONG64 Value;
    ULONG64 OutputAddress;
    USHORT Length;
    ULONG64 BufferAddr;
    PWSTR Buffer;
    if (MyGetFieldData( Address, Type, Field, 0, (PVOID)&Value, &OutputAddress ) == 0) {
        if (ReadMemory( OutputAddress, &Length, sizeof(Length), (PULONG)&Value )) {
            if (Length) {
                GetFieldOffset( "UNICODE_STRING", "Buffer", (PULONG)&Value );
                OutputAddress += Value;
                if (ReadMemory( OutputAddress, &BufferAddr, GetTypeSize("PWSTR"), (PULONG)&Value )) {
                    if (BufferAddr) {
                        Buffer = (PWSTR) malloc( Length + sizeof(WCHAR) );
                        if (Buffer) {
                            if (ReadMemory( BufferAddr, Buffer, Length, (PULONG)&Value )) {
                                Buffer[Length/sizeof(WCHAR)] = 0;
                                dprintf( "\n(%03x)  %s  %s [%ws]",
                                    (ULONG)(OutputAddress-Address),
                                    FormatValue(BufferAddr),
                                    Field,
                                    Buffer
                                    );
                                free( Buffer );
                                return;
                            }
                            free( Buffer );
                        }
                    }
                }
            }
        }
    }
    dprintf( "\n(%03x)  %16x  %s",
        (ULONG)(OutputAddress-Address),
        0,
        Field
        );
    return;
}


BOOL
DumpString(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   LengthField,
    IN PCHAR   StringField
    )

/*++

Routine Description:

    Prints the value (the actual string) of a string
    contained in a structure with a corresponding
    length field as another field member.

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the string
    LengthField - Field name for the length value
    StringField - Field name for the string

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    BOOL Result = FALSE;
    ULONG Length;
    PWSTR String;
    ULONG Offset;

    //
    // read in the length
    //

    if (LengthField == NULL) {
        Length = GetTypeSize(StringField) / sizeof(WCHAR);
    } else {
        Length = (ULONG)ReadValue( Address, Type, LengthField );
    }

    if (Length) {

        Length *= sizeof(WCHAR);

        //
        // allocate some memory to hold the file name
        //

        String = malloc( Length + sizeof(WCHAR) );
        if (String) {

            //
            //  get the field offset of the string
            //

            if (!GetFieldOffset( Type, StringField, &Offset )) {

                //
                //  compute the address of the string
                //

                Address += Offset;

                //
                //  read the unicode characters for the string
                //

                if (ReadMemory( Address, String, Length, &Offset )) {

                    //
                    // zero terminate the string so we can print it out properly
                    //

                    String[Length/sizeof(WCHAR)] = 0;

                    //
                    // finally print the data
                    //

                    dprintf( "%ws", String );

                    Result = TRUE;
                }
            }

            //
            // free the string memory
            //

            free( String );
        }
    }

    return Result;
}


ULONG64
ReadArrayValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field,
    IN ULONG   Index
    )

/*++

Routine Description:

    Reads a value/element contained in an array.

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the array
    Field - Field name for the array
    Index - The element that is requested

Return Value:

    The element value or zero

--*/

{
    CHAR Buff[64];
    sprintf( Buff, "%s[%d]", Field, Index );
    return ReadValue( Address, Type, Buff );
}


ULONG
GetOffset(
   IN LPSTR Type,
   IN LPSTR Field
   )

/*++

Routine Description:

    Gets the offset for a field within a structure

Arguments:

    Type - Qualified type string for the structure containing the field
    Field - Field name

Return Value:

    The offset value or zero

--*/

{
    FIELD_INFO flds = {
        (PUCHAR)Field,
        (PUCHAR)"",
        0,
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
        0,
        NULL};

    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM),
       (PUCHAR)Type,
       DBG_DUMP_NO_PRINT,
       0,
       NULL,
       NULL,
       NULL,
       1,
       &flds
    };

    ULONG Err;

    Sym.nFields = 1;
    Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
    if (Err == 0) {
        return (ULONG) (flds.address - Sym.addr);
    }
    return -1;
}


PSTR
FormatValue(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.  This version does not print
    leading 0's.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same print.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    #define MAX_FORMAT_STRINGS 8
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if ((KdDebuggerData.KernBase >> 32) != 0) {
        //
        // we're on a 64bit machines
        //
        sprintf( string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr );
    } else {
        sprintf( string, "%08x", (ULONG)addr );
    }
    return string;
}


VOID
PrintState(
    STATE *ps,
    ULONG state
    )

/*++

Routine Description:

    Prints a state string based on the provided state value

Arguments:

    ps - State string array
    State - State value

Return Value:

    None

--*/

{
    ULONG ul = 0;

    while (ps->mask != 0) {
        ul |= ps->mask;
        if ((state & ps->mask) == ps->value) {
            dprintf(" %s", ps->pszname);
        }
        ps++;
    }
    state &= ~ul;
    if (state != 0) {
        dprintf(" +%lx!!", state);
    }
    dprintf("\n");
}


const char *
TypeCodeGuess (
    IN NODE_TYPE_CODE TypeCode
    )

/*++

Routine Description:

    Guess at a structure's type code

Arguments:

    TypeCode - Type code from the data structure

Return Value:

    None

--*/

{
    int i = 0;

    while (NodeTypeCodes[i].TypeCode != 0 &&
           NodeTypeCodes[i].TypeCode != TypeCode) {

        i++;

    }

    return NodeTypeCodes[i].Text;
}


VOID
FindData(
    IN ULONG64 FileObjectAddress,
    IN ULONG64 Offset,
    IN BOOL Trace,
    OUT PULONG64 DataAddress
    )

/*++

Routine Description:

    Find the cache address for a given file object at the given offset.

Arguments:

    FileObjectAddress - Gives the address of the file object to dump

    Offset - Gives the offset within the file to dump

    DataAddress - Where to store the address of the data.  This will
                  contain 0 if the data at the given offset is not mapped.

Return Value:

    None.

--*/

{
    ULONG64 VacbAddr;          //  the address of the vacb
    ULONG64 VacbAddrAddr;      //  the address of the address of the vacb
    ULONG VacbNumber;
    ULONG OffsetWithinVacb;
    ULONG Level;
    ULONG Shift;
    ULONG OffsetForLevel;
    LONGLONG OriginalOffset = Offset;
    ULONG PtrSize = GetTypeSize("PVOID");
    ULONG Type, InVacbsOffset;
    ULONG64 SectionObjectPointer, SharedCacheMap, Vacbs, SectionSize_Quad;

    *DataAddress = 0;

    if (Trace) {
        dprintf( "\n  FindData for FileObject %08p", FileObjectAddress );
    }
    
    if (GetFieldValue(FileObjectAddress, "FILE_OBJECT", "Type", Type)) {
        dprintf("Unable to read FILE_OBJECT at %p\n", FileObjectAddress);
        return;
    }

    //
    //  Before we get into too much trouble, make sure this looks like a FileObject.
    //

    //
    //  Type of a FileObject must be IO_TYPE_FILE.
    //

    if (Type != IO_TYPE_FILE) {

        dprintf( "\nFILE_OBJECT type signature does not match, type code is %s",
                 TypeCodeGuess((USHORT) Type ));
        return;
    }

    GetFieldValue(FileObjectAddress, "FILE_OBJECT", 
                  "SectionObjectPointer", SectionObjectPointer);

    if (Trace) {
        dprintf( "   Section Object Pointers: %08p", SectionObjectPointer );
    }
    
    if (GetFieldValue(SectionObjectPointer, 
                      "SECTION_OBJECT_POINTERS",
                      "SharedCacheMap",
                      SharedCacheMap)) {
        dprintf("Unable to read SECTION_OBJECT_POINTERS at %p\n", SectionObjectPointer);
        return;
    }

    if (Trace) {
        dprintf( "\n  Shared Cache Map: %08p", SharedCacheMap );
    }
    
    if (GetFieldValue(SharedCacheMap, 
                      "SHARED_CACHE_MAP",
                      "Vacbs",
                      Vacbs)) {
        dprintf("Unable to read SHARED_CACHE_MAP at %p\n", SharedCacheMap);
        return;
    }
    GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                  "SectionSize.QuadPart", SectionSize_Quad);

    OffsetWithinVacb = (((ULONG) Offset) & (VACB_MAPPING_GRANULARITY - 1));
    GetFieldOffset("SHARED_CACHE_MAP", "InitialVacbs", &InVacbsOffset);

    if (Trace) {
        dprintf( "         File Offset: %I64x ", Offset );
    }
    

    if (Vacbs == (SharedCacheMap + InVacbsOffset)) {
        
        //
        //  Small file case -- we're using one of the Vacbs in the Shared Cache Map's
        //  embedded array.
        //

        CHAR Buff[50];

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);

        if (VacbNumber >= PREALLOCATED_VACBS) {

            dprintf( "\nInvalid VacbNumber for resident Vacb" );
            return;
        }

        sprintf(Buff, "InitialVacbs[%d]", VacbNumber);
        GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                      Buff, VacbAddr);

        if (Trace) {
            dprintf( "in VACB number %x", VacbNumber );
        }

    } else if (SectionSize_Quad <= VACB_SIZE_OF_FIRST_LEVEL) {

        //
        //  Medium file case -- we're using a single level (linear) structure to
        //  store the Vacbs.
        //

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);
        VacbAddrAddr = Vacbs + (VacbNumber * PtrSize);
        if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        }

        if (Trace) {
            dprintf( "in VACB number %x", VacbNumber );
        }

    } else {

        //
        //  Large file case -- multilevel Vacb storage.
        //

        Level = 0;
        Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
        
        //
        //  Loop to calculate how many levels we have and how much we have to
        //  shift to index into the first level.
        //

        do {

            Level += 1;
            Shift += VACB_LEVEL_SHIFT;

        } while (SectionSize_Quad > ((ULONG64)1 << Shift));
    
        //
        //  Now descend the tree to the bottom level to get the caller's Vacb.
        //



        Shift -= VACB_LEVEL_SHIFT;
//        dprintf( "Shift: 0x%x\n", Shift );

        OffsetForLevel = (ULONG) (Offset >> Shift);
        VacbAddrAddr = Vacbs + (OffsetForLevel * PtrSize);
        if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        } 

        while ((VacbAddr != 0) && (Level != 0)) {

            Level -= 1;

            Offset &= ((LONGLONG)1 << Shift) - 1;

            Shift -= VACB_LEVEL_SHIFT;

//            dprintf( "Shift: 0x%x\n", Shift );

            OffsetForLevel = (ULONG) (Offset >> Shift);
            VacbAddrAddr = VacbAddr + (OffsetForLevel * PtrSize);
            if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
                dprintf("Unable to read at %p\n", VacbAddrAddr);
                return;
            } 
        }
    }

    if (VacbAddr != 0) {
        ULONG64 Base;

        if (Trace) {
            dprintf( "\n  Vacb: %08p", VacbAddr );
        }
        
        if (GetFieldValue(VacbAddr, "_VACB", "BaseAddress", Base)) {
            dprintf("Unable to read VACB base address at %p.", VacbAddr);
            return;
        }

        if (Trace) {
            dprintf( "\n  Your data is at: %08p", (Base + OffsetWithinVacb) );
        }
        *DataAddress = Base + OffsetWithinVacb;

    } else {

        if (Trace) {
            dprintf( "\n  Data at offset %I64x not mapped", OriginalOffset );
        }
    }

    return;
}


DECLARE_DUMP_FUNCTION( DumpCcb )

/*++

Routine Description:

    Dump a specific ccb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(CCB), "NodeTypeCode" );

    //
    //  Before we get into too much trouble, make sure this looks like a ccb.
    //

    //
    //  Type of an fcb record must be NTFS_NTC_CCB_DATA or NTFS_NTC_CCB_INDEX
    //

    if (Value != NTFS_NTC_CCB_DATA && Value != NTFS_NTC_CCB_INDEX) {
        dprintf( "\nCCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ));
        return;
    }

    //
    //  Having established that this looks like a ccb, let's dump the
    //  interesting parts.
    //

    dprintf( "\nCcb: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(CCB), "Flags" );
    PrintState( CcbState, (ULONG)Value );

    DumpValue( Address, SYM(CCB), "Flags" );

    dprintf( "\n      OpenType: " );

    Value = ReadValue( Address, SYM(CCB), "TypeOfOpen" );

    switch (Value) {
        case UserFileOpen :
           dprintf( "UserFileOpen" );
           break;

        case UserDirectoryOpen :
           dprintf( "UserDirectoryOpen" );
           break;

        case UserVolumeOpen :
           dprintf( "UserVolumeOpen" );
           break;

        case StreamFileOpen :
           dprintf( "StreamFileOpen" );
           break;

        case UserViewIndexOpen :
           dprintf( "UserViewIndexOpen" );
           break;
    }

    DumpUnicodeString( Address, SYM(CCB), "FullFileName" );

    DumpValue( Address, SYM(CCB), "LastFileNameOffset" );
    DumpValue( Address, SYM(CCB), "EaModificationCount" );
    DumpValue( Address, SYM(CCB), "NextEaOffset" );
    DumpValue( Address, SYM(CCB), "Lcb" );
    DumpValue( Address, SYM(CCB), "TypeOfOpen" );
    DumpValue( Address, SYM(CCB), "IndexContext" );
    DumpValue( Address, SYM(CCB), "QueryLength" );
    DumpValue( Address, SYM(CCB), "QueryBuffer" );
    DumpValue( Address, SYM(CCB), "IndexEntryLength" );
    DumpValue( Address, SYM(CCB), "IndexEntry" );
    DumpValue( Address, SYM(CCB), "LcbLinks.Flink" );
    DumpValue( Address, SYM(CCB), "FcbToAcquire" );

    dprintf( "\n" );
}


ULONG
DumpFcbLinks(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for FcbLinks

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Lcb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
        DumpLcb( Lcb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
        dprintf( "\n    Lcb %s", FormatValue(Lcb) );
    }

    return FALSE;
}


ULONG
DumpScbLinks(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for ScbLinks

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Scb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG Offset = 0;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
       DumpScb( Scb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
       dprintf( "\n    Scb %s", FormatValue(Scb) );
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpFcb )

/*++

Routine Description:

    Dump a specific fcb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FCB), "NodeTypeCode" );

    //
    //  Before we get into too much trouble, make sure this looks like an fcb.
    //

    //
    //  Type of an fcb record must be NTFS_NTC_FCB
    //

    if (Value != NTFS_NTC_FCB) {
        dprintf( "\nFCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    dprintf( "\nFcb: %s", FormatValue(Address) );

    //
    //  Having established that this looks like an fcb, let's dump the
    //  interesting parts.
    //

    PrintState( FcbState, (ULONG)ReadValue( Address, SYM(FCB), "FcbState" ) );

    DumpValue( Address, SYM(FCB), "FcbState" );
    DumpValue( Address, SYM(FCB), "FileReference" );
    DumpValue( Address, SYM(FCB), "CleanupCount" );
    DumpValue( Address, SYM(FCB), "CloseCount" );
    DumpValue( Address, SYM(FCB), "ReferenceCount" );
    DumpValue( Address, SYM(FCB), "FcbDenyDelete" );
    DumpValue( Address, SYM(FCB), "FcbDeleteFile" );
    DumpValue( Address, SYM(FCB), "BaseExclusiveCount" );
    DumpValue( Address, SYM(FCB), "EaModificationCount" );
    DumpValue( Address, SYM(FCB), "Vcb" );
    DumpValue( Address, SYM(FCB), "FcbMutex" );
    DumpValue( Address, SYM(FCB), "Resource" );
    DumpValue( Address, SYM(FCB), "PagingIoResource" );
    DumpValue( Address, SYM(FCB), "InfoFlags" );
    DumpValue( Address, SYM(FCB), "LinkCount" );
    DumpValue( Address, SYM(FCB), "TotalLinks" );
    DumpValue( Address, SYM(FCB), "SharedSecurity" );
    DumpValue( Address, SYM(FCB), "QuotaControl" );
    DumpValue( Address, SYM(FCB), "ClassId" );
    DumpValue( Address, SYM(FCB), "OwnerId" );
    DumpValue( Address, SYM(FCB), "DelayedCloseCount" );
    DumpValue( Address, SYM(FCB), "SecurityId" );
    DumpValue( Address, SYM(FCB), "FcbUsnRecord" );

    //
    // walk the queue of links for this file
    //

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    dprintf( "\n\nLinks:" );
    Value = ReadValue( Address, SYM(FCB), "LcbQueue.Flink" );
    if (Value) {
        ListType( SYM(LCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, DumpFcbLinks );
    }

    dprintf( "\n\nStreams:" );
    Value = ReadValue( Address, SYM(FCB), "ScbQueue.Flink" );
    if (Value) {
        ListType( SYM(SCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, DumpScbLinks );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpFcbTable )

/*++

Routine Description:

    Dump the fcb table.

Arguments:

    Address - Gives the address of the fcb table to dump

Return Value:

    None

--*/

{
    ULONG64 Value;
    ULONG64 TableElemAddr;
    ULONG64 RestartKey;
    ULONG64 FcbAddr;
    ULONG Offset1;
    ULONG Offset2;
    PWSTR FileName;
    BOOL GotIt;


    INIT_DUMP();

    //
    //  Dump the FcbTable
    //

    Value = ReadValue( Address, SYM(RTL_AVL_TABLE), "CompareRoutine" );
    if (Value != GetExpression("NTFS!NtfsFcbTableCompare")) {
        dprintf( "\nThe address [%s] does not seem to point to a FCB table", FormatValue(Address) );
        return;
    }

    dprintf( "\n FcbTable %s", FormatValue(Address) );

    dprintf( "\n FcbTable has %x elements", (ULONG)ReadValue( Address, SYM(RTL_AVL_TABLE), "NumberGenericTableElements" ) );

    RestartKey = 0;

    for (TableElemAddr = KdEnumerateGenericTableWithoutSplaying(Address, &RestartKey);
         TableElemAddr != 0;
         TableElemAddr = KdEnumerateGenericTableWithoutSplaying(Address, &RestartKey)) {

        FcbAddr = ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "Fcb" );

        if (Options >= 1) {

            DumpFcb( FcbAddr, 0, Options - 2, Processor, hCurrentThread );

        } else {

            GotIt = FALSE;

            //
            //  get the address of the FCB.LcbQueue LIST_ENTRY
            //

            Value = ReadValue( FcbAddr, SYM(FCB), "LcbQueue.Flink" );
            if (Value) {

                //
                //  get the offset of the LCB.FcbLinks LIST_ENTRY
                //

                if (!GetFieldOffset( SYM(LCB), "FcbLinks.Flink", &Offset1 )) {

                    //
                    //  get the field offset of the FCB.LcbQueue LIST_ENTRY
                    //

                    if (!GetFieldOffset( SYM(FCB), "LcbQueue.Flink", &Offset2 )) {

                        //
                        //  check to see if the list is empty
                        //

                        if (Value != FcbAddr+Offset2) {

                            //
                            //  compute the address of the LCB
                            //

                            Value -= Offset1;

                            //
                            //  get the length of the file name
                            //

                            Offset2 = (ULONG)(ReadValue( Value, SYM(LCB), "FileNameLength" ) * GetTypeSize("WCHAR"));

                            if (Offset2) {

                                //
                                // allocate some memory to hold the file name
                                //

                                FileName = malloc( Offset2 + GetTypeSize("WCHAR") );
                                if (FileName) {

                                    //
                                    //  get the field offset of the LCB.FileName
                                    //

                                    if (!GetFieldOffset( SYM(LCB), "FileName", &Offset1 )) {

                                        //
                                        //  compute the address of the file name character array
                                        //

                                        Value += Offset1;

                                        //
                                        //  read the unicode characters for the file name
                                        //

                                        if (ReadMemory( Value, FileName, Offset2, (PULONG)&Offset1 )) {

                                            //
                                            // zero terminate the name so we can print it out properly
                                            //

                                            FileName[Offset2/GetTypeSize("WCHAR")] = 0;

                                            //
                                            // finally print the data
                                            //

                                            GotIt = TRUE;

                                            dprintf( "\n     Fcb %s for FileReference %08lx FcbTableElement %s %ws 0x%x",
                                                     FormatValue(FcbAddr),
                                                     (ULONG)ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "FileReference.SegmentNumberLowPart" ),
                                                     FormatValue(TableElemAddr),
                                                     FileName,
                                                     (ULONG)ReadValue( FcbAddr, SYM(FCB), "CleanupCount" )
                                                     );
                                        }
                                    }

                                    //
                                    // free the file name memory
                                    //

                                    free( FileName );
                                }
                            }
                        }
                    }
                }
            }
            if (!GotIt) {
                dprintf( "\n     Fcb %s for FileReference %08lx FcbTableElement %s <filename unavailable> 0x%x",
                         FormatValue(FcbAddr),
                         (ULONG)ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "FileReference.SegmentNumberLowPart" ),
                         FormatValue(TableElemAddr),
                         (ULONG)ReadValue( FcbAddr, SYM(FCB), "CleanupCount" )
                         );
            }
        }

        if (CheckControlC( )) {
            break;
        }
    } //  endfor
}


DECLARE_DUMP_FUNCTION( DumpFileObject )

/*++

Routine Description:

    Dump a FileObject.

Arguments:

    Address - Gives the address of the FileObject to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FILE_OBJECT), "Type" );
    if (Value != IO_TYPE_FILE) {
        dprintf( "Invalid signature, probably not a file object" );
        return;
    }

    dprintf( "\nFileObject: %p", Address );

    Value = ReadValue( Address, SYM(FILE_OBJECT), "FsContext" );
    if (Value) {
        DumpScb( Value, 0, Options, Processor, hCurrentThread );
        Value = ReadValue( Address, SYM(FILE_OBJECT), "FsContext2" );
        if (Value) {
            DumpCcb( Value, 0, Options, Processor, hCurrentThread );
        }
    }

    DumpValue( Address, SYM(FILE_OBJECT), "DeviceObject" );
    DumpValue( Address, SYM(FILE_OBJECT), "Vpb" );
    DumpValue( Address, SYM(FILE_OBJECT), "FsContext" );
    DumpValue( Address, SYM(FILE_OBJECT), "FsContext2" );
    DumpValue( Address, SYM(FILE_OBJECT), "SectionObjectPointer" );
    DumpValue( Address, SYM(FILE_OBJECT), "PrivateCacheMap" );
    DumpValue( Address, SYM(FILE_OBJECT), "FinalStatus" );
    DumpValue( Address, SYM(FILE_OBJECT), "RelatedFileObject" );
    DumpValue( Address, SYM(FILE_OBJECT), "LockOperation" );
    DumpValue( Address, SYM(FILE_OBJECT), "DeletePending" );
    DumpValue( Address, SYM(FILE_OBJECT), "ReadAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "WriteAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "DeleteAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedRead" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedWrite" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedDelete" );
    DumpValue( Address, SYM(FILE_OBJECT), "Flags" );
    DumpUnicodeString( Address, SYM(FILE_OBJECT), "FileName" );
    DumpValue( Address, SYM(FILE_OBJECT), "CurrentByteOffset" );
    DumpValue( Address, SYM(FILE_OBJECT), "Waiters" );
    DumpValue( Address, SYM(FILE_OBJECT), "Busy" );
    DumpValue( Address, SYM(FILE_OBJECT), "LastLock" );
    DumpValue( Address, SYM(FILE_OBJECT), "Lock" );
    DumpValue( Address, SYM(FILE_OBJECT), "Event" );
    DumpValue( Address, SYM(FILE_OBJECT), "CompletionContext" );

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpFileObjectFromIrp )

/*++

Routine Description:

    Dump a FileObject given an Irp.

Arguments:

    Address - Gives the address of the Irp where the FileObject can be found

Return Value:

    None

--*/
{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(IRP), "Type" );
    if (Value != IO_TYPE_IRP) {
        dprintf( "IRP signature does not match, probably not an IRP\n" );
        return;
    }

    dprintf( "\nIrp: %s", FormatValue(Address) );

    //
    //  only the current irp stack is worth dumping
    //  the - 1 is there because irp.CurrentLocation is 1 based
    //

    Value = Address + GetTypeSize(NT(IRP)) + (GetTypeSize(NT(IO_STACK_LOCATION)) * (ReadValue( Address, NT(IRP), "CurrentLocation" ) - 1));
    Value = ReadValue( Value, NT(IO_STACK_LOCATION), "FileObject" );
    DumpFileObject( Value, 0, Options, Processor, hCurrentThread );
}


DECLARE_DUMP_FUNCTION( DumpFileRecord )

/*++

Routine Description:

    Dump a FileRecord given a FileObject or Fcb.

Arguments:

    Address - Gives the address of a FileObject or Fcb.

Return Value:

    None

--*/
{
    ULONG64 Value;
    ULONG64 DataAddress;
    ULONG64 ScbAddress;
    ULONG64 FcbAddress;
    ULONG64 VcbAddress;
    ULONG64 FoAddress;


    INIT_DUMP();

    Value = ReadValue( Address, NT(FILE_OBJECT), "Type" );
    switch (Value) {
        case IO_TYPE_FILE:
            dprintf( "\nFileObject: %s", FormatValue(Address) );
            ScbAddress = ReadValue( Address, NT(FILE_OBJECT), "FsContext" );
            if (ScbAddress == 0) {
                dprintf( "No FsContext in the file object" );
                return;
            }
            FcbAddress = ReadValue( ScbAddress, SYM(SCB), "Fcb" );
            break;

        case NTFS_NTC_FCB:
            dprintf( "\nFcb: %s", FormatValue(Address) );
            FcbAddress = Address;
            ScbAddress = 0;
            break;

        case NTFS_NTC_SCB_DATA:
        case NTFS_NTC_SCB_INDEX:
            dprintf( "\nScb: %s", FormatValue(Address) );
            ScbAddress = Address;
            FcbAddress = ReadValue( ScbAddress, SYM(SCB), "Fcb" );
            break;

        default:
            dprintf( "Invalid signature, not a file object or Fcb" );
            return;
    }

    VcbAddress = ReadValue( FcbAddress, SYM(FCB), "Vcb" );
    dprintf( "    Vcb: %s", FormatValue(VcbAddress) );

    dprintf( "    FRS: %08lx,%04lx",
             ReadValue( FcbAddress, SYM(FCB), "FileReference.SegmentNumberLowPart" ),
             ReadValue( FcbAddress, SYM(FCB), "FileReference.SequenceNumber" ));

    ScbAddress = ReadValue( VcbAddress, SYM(VCB), "MftScb" );
    dprintf( "    MftScb: %s", FormatValue(ScbAddress) );

    dprintf( "reading fo in mftscb 0x%x 0x%x\n", GetOffset( SYM(SCB), "Header.FilterContexts" ), GetOffset( SYM(SCB), "Header.PendingEofAdvances" ) );

    FoAddress = ReadValue( ScbAddress, SYM(SCB), "FileObject" );
    dprintf( "finding data in mft fo 0x%s\n", FormatValue(FoAddress) );

    FindData( FoAddress,
              ReadValue( FcbAddress, SYM(FCB), "FileReference.SegmentNumberLowPart" ) * ReadValue( VcbAddress, SYM(VCB), "BytesPerFileRecordSegment" ),
              Options,
              &DataAddress
              );

    if (DataAddress == 0) {

        dprintf( "\nFileRecord is not mapped" );

    } else {

        dprintf( "\nFileRecord at: %s", FormatValue(DataAddress) );
        DumpFileRecordContents( DataAddress, 0, Options, Processor, hCurrentThread );
    }
}


DECLARE_DUMP_FUNCTION( DumpFileRecordContents )

/*++

Routine Description:

    Dump a FileObject's contents given a pointer to where the FR is cached.

Arguments:

    Address - Gives the address where the FR is cached.

Return Value:

    None

--*/
{
    ULONG64 Value;
    ULONG64 AttrAddress;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FILE_RECORD_SEGMENT_HEADER), "MultiSectorHeader.Signature" );
    if ((ULONG)Value != *(PULONG)FileSignature) {
        dprintf( "Not a file record %x", (ULONG)Value );
        return;
    }

    AttrAddress = Address + ReadValue( Address, SYM(FILE_RECORD_SEGMENT_HEADER), "FirstAttributeOffset" );

    while ((Value = ReadValue( AttrAddress, SYM(ATTRIBUTE_RECORD_HEADER), "TypeCode" )) != 0xffffffff) {
        dprintf( "\nAttribute type %x %s", (ULONG)Value, AttributeTypeCode[Value/0x10] );
        dprintf( " at offset %x", AttrAddress - Address );
        AttrAddress += ReadValue( AttrAddress, SYM(ATTRIBUTE_RECORD_HEADER), "RecordLength" );
        if (CheckControlC()) {
            break;
        }
    }
}


DECLARE_DUMP_FUNCTION( DumpIrpContext )

/*++

Routine Description:

    Dump an IrpContext.

Arguments:

    Address - Gives the address of the IrpContext to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    dprintf( "\nIrpContext: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(IRP_CONTEXT), "NodeTypeCode" );
    if (Value != NTFS_NTC_IRP_CONTEXT) {
        dprintf( "\nIRP_CONTEXT signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    Value = ReadValue( Address, SYM(IRP_CONTEXT), "OriginatingIrp" );
    if (Value) {
        DumpFileObjectFromIrp( Value, 0, Options, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpIrpContextFromThread )

/*++

Routine Description:

    Dump an IrpContext given a Thread.

Arguments:

    Address - Gives the address of the Thread where the IrpContext can be found

Return Value:

    None

--*/
{
    ULONG64 Value;


    INIT_DUMP();

    //
    //  Lookup the current thread if the user didn't specify one.
    //

    if (Address == 0) {
        GetCurrentThreadAddr( Processor, &Address );
    }

    Value = ReadValue( Address, NT(ETHREAD), "TopLevelIrp" );
    if (Value) {
        dprintf( "\nThread %s", FormatValue(Address) );
        Value = ReadValue( Value, SYM(TOP_LEVEL_CONTEXT), "ThreadIrpContext" );
        DumpIrpContext( Value, 0, Options, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpLcb )

/*++

Routine Description:

    Dump an Lcb.

Arguments:

    Address - Gives the address of the Lcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(LCB), "NodeTypeCode" );
    if (Value != NTFS_NTC_LCB) {
        dprintf( "\nLCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    dprintf( "\nLcb: %s", FormatValue(Address) );

    PrintState( LcbState, (ULONG)ReadValue( Address, SYM(LCB), "LcbState" ) );

    DumpUnicodeString( Address, SYM(LCB), "FileName" );
    DumpValue( Address, SYM(LCB), "Scb" );
    DumpValue( Address, SYM(LCB), "Fcb" );
}


DECLARE_DUMP_FUNCTION( DumpLogFile )

/*++

Routine Description:

    Dump a log file.

Arguments:

    Address - Gives the address of the Vcb whose log file should be dumped

Return Value:

    None

--*/

{
    ULONG64 Value;
    ULONG64 VcbAddress;
    ULONG64 LogFileSize;
    ULONG64 LogFileScb;
    ULONG SeqNumberBits;
    ULONG64 LogFileOffset;
    LONG LogFileMask;
    USHORT RedoOperation;
    USHORT UndoOperation;
    ULONG64 LogDataAddress;


    INIT_DUMP();

    LogFileOffset = Options;

    Value = ReadValue( Address, SYM(VCB), "NodeTypeCode" );

    switch (Value) {
        case NTFS_NTC_FCB:
            dprintf( "\nFcb: %s", FormatValue(Address) );
            VcbAddress = ReadValue( Address, SYM(FCB), "Vcb" );
            break;

        case NTFS_NTC_VCB:
            dprintf( "\nVcb: %s", FormatValue(Address) );
            VcbAddress = Address;
            break;

        default:
            dprintf( "\nSignature is not an FCB or VCB, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value) );
            return;
    }

    if (LogFileOffset == 0) {
        LogFileOffset = ReadValue( VcbAddress, SYM(VCB), "LastRestartArea.QuadPart" );
    }

    dprintf( "    Starting at LSN: 0x%016I64x", LogFileOffset );

    LogFileScb = ReadValue( VcbAddress, SYM(VCB), "LogFileScb" );
    LogFileSize = ReadValue( LogFileScb, SYM(SCB), "Header.FileSize.QuadPart" );

    for (SeqNumberBits=0; LogFileSize!=0; SeqNumberBits+=1,LogFileSize=((ULONGLONG)(LogFileSize)) >> 1 ) {
    }

    LogFileMask = (1 << (SeqNumberBits - 3)) - 1;

    while (TRUE) {

        LogFileOffset &= LogFileMask;           // clear some bits
        LogFileOffset = LogFileOffset << 3;     // multiply by 8

        Value = ReadValue( VcbAddress, SYM(VCB), "LogFileObject" );
        FindData( Value, LogFileOffset, FALSE, &LogDataAddress );

        if (LogDataAddress != 0) {

            //
            //  It's mapped.
            //

            RedoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "RedoOperation" );
            UndoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "UndoOperation" );

            if (RedoOperation <= LastLogOperation && UndoOperation <= LastLogOperation) {
                dprintf( "\nRedo: %s", LogOperation[RedoOperation] );
                dprintf( "    Undo: %s", LogOperation[UndoOperation] );
                dprintf( "    Lsn: 0x%08lx", (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ThisLsn.LowPart" ) );
            }

        } else {
            break;
        }

        if (CheckControlC()) {
            break;
        }

        LogFileOffset = (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientUndoNextLsn.LowPart" );

        if (LogFileOffset == 0) {
            break;
        }
    }
}


DECLARE_DUMP_FUNCTION( DumpTransaction )

/*++

Routine Description:

    Dump a log file.

Arguments:

    Address - Gives the address of the irpcontext to trace the transaction for

Return Value:

    None

--*/

{   ULONG64 TransactionId;
    ULONG64 VcbAddress;
    ULONG64 TransactionTable;
    LSN FirstLsn;
    LSN CurrentLsn;
    ULONG64 LogFileObject;
    ULONG64 LogFileSize;
    ULONG64 LogFileScb;
    ULONG SeqNumberBits;
    ULONG64 LogFileOffset;
    LONG LogFileMask;
    USHORT RedoOperation;
    USHORT UndoOperation;
    ULONG64 LogDataAddress;
    ULONG64 MftScbAddress;
    ULONG64 MftFileObject;
    ULONG64 DataAddress;
    USHORT Type;
    
    INIT_DUMP();

    //
    //  Determine what type of input it is
    //  

    Type = (USHORT) ReadValue( Address, SYM(IRP_CONTEXT), "NodeTypeCode"  );
    
    if (Type == NTFS_NTC_FCB) {

        //
        //  Its an Fcb so read the filerecord and find the last LSN on disk from it
        //  

        VcbAddress = ReadValue( Address, SYM(FCB), "Vcb" );
        MftScbAddress = ReadValue( VcbAddress, SYM(VCB), "MftScb" );
        MftFileObject = ReadValue( MftScbAddress, SYM(SCB), "FileObject" );
        
        FindData( MftFileObject,
                  ReadValue( Address, SYM(FCB), "FileReference.SegmentNumberLowPart" ) * ReadValue( VcbAddress, SYM(VCB), "BytesPerFileRecordSegment" ),
                  0,
                  &DataAddress
                  );

        CurrentLsn.QuadPart = ReadValue( DataAddress, SYM(FILE_RECORD_SEGMENT_HEADER), "Lsn" ); 

        dprintf( "Searching for last LSN: 0x%I64x on disk for file: 0x%I64x\n\n", CurrentLsn,
                 ReadValue( Address, SYM(FCB), "FileReference.SegmentNumberLowPart" ));

    } else if (Type == NTFS_NTC_VCB ) {

        //
        //  Its a vcb and  filerecord so directly get the last LSN from it
        //  
        
        VcbAddress = Address;
        CurrentLsn.QuadPart = ReadValue( Options, SYM(FILE_RECORD_SEGMENT_HEADER), "Lsn" ); 

        dprintf( "0x%x\n", Options );
        dprintf( "Searching for last LSN: 0x%I64x on disk for file: 0x%I64x\n\n", CurrentLsn,
                 ReadValue( Options, SYM(FILE_RECORD_SEGMENT_HEADER), "SegmentNumberLowPart" ));

    } else if (Type == NTFS_NTC_IRP_CONTEXT) {

        //
        //  Read in the transaction id and then find the transaction entry in the table
        // 

        TransactionId = ReadValue( Address, SYM(IRP_CONTEXT), "TransactionId" );
        VcbAddress = ReadValue( Address, SYM(IRP_CONTEXT), "Vcb" );
        TransactionTable = ReadValue( VcbAddress, SYM(VCB), "TransactionTable.Table" );
        FirstLsn.QuadPart = ReadValue( TransactionTable + TransactionId, SYM( TRANSACTION_ENTRY), "FirstLsn.QuadPart" );
        CurrentLsn.QuadPart = ReadValue( TransactionTable + TransactionId, SYM( TRANSACTION_ENTRY), "PreviousLsn.QuadPart" );

        if (TransactionId == 0) {
            dprintf( "No transaction active for this irpcontext\n" );
            return;
        }
        dprintf( "Transaction: 0x%I64x from Lsn: 0x%I64x to 0x%I64x\n\n", TransactionId, FirstLsn, CurrentLsn );

    } else {
        dprintf( "Unknown type 0x%x for ptr 0x%p\n", Type, Address );
        return;
    }

    LogFileScb = ReadValue( VcbAddress, SYM(VCB), "LogFileScb" );
    LogFileSize = ReadValue( LogFileScb, SYM(SCB), "Header.FileSize.QuadPart" );
    LogFileObject = ReadValue( VcbAddress, SYM(VCB), "LogFileObject" );

    for (SeqNumberBits=0; LogFileSize!=0; SeqNumberBits+=1,LogFileSize=((ULONGLONG)(LogFileSize)) >> 1 ) {
    }

    LogFileMask = (1 << (SeqNumberBits - 3)) - 1;
    LogFileOffset = CurrentLsn.QuadPart;

    while (TRUE) {

        LogFileOffset &= LogFileMask;           // clear some bits
        LogFileOffset = LogFileOffset << 3;     // multiply by 8

        FindData( LogFileObject, LogFileOffset, FALSE, &LogDataAddress );

        if (LogDataAddress != 0) {

            //
            //  It's mapped.
            //

            RedoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "RedoOperation" );
            UndoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "UndoOperation" );

            if (RedoOperation <= LastLogOperation && UndoOperation <= LastLogOperation) {
                dprintf( "Record: %p Lsn: %I64x Prev: %I64x Undo: %I64x\n", 
                         LogDataAddress,
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ThisLsn.QuadPart" ),
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientPreviousLsn.QuadPart" ),
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientUndoNextLsn.QuadPart" ) );

                dprintf( "Redo: %s Undo: %s\n\n", LogOperation[RedoOperation], LogOperation[UndoOperation] );
            }

        } else {
            dprintf( "Data not mapped in log for offset: 0x%I64x\n", LogFileOffset );
            break;
        }

        if (CheckControlC()) {
            break;
        }

        LogFileOffset = (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientPreviousLsn.QuadPart" );

        if (LogFileOffset == 0) {
            break;
        }
    }
}



DECLARE_DUMP_FUNCTION( DumpMcb )

/*++

Routine Description:

    Dump an Mcb.

Arguments:

    Address - Gives the address of the Mcb to dump

Return Value:

    None

--*/

{
    ULONG64 NtfsMcbArray;
    ULONG64 MappingPairsAddress;
    ULONG RangeIdx;
    ULONG NtfsMcbArraySizeInUse;


    INIT_DUMP();

    dprintf( "\nNtfsMcb: %s", FormatValue(Address) );

    DumpValue( Address, SYM(NTFS_MCB), "FcbHeader" );
    DumpValue( Address, SYM(NTFS_MCB), "PoolType" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySizeInUse" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySize" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArray" );
    DumpValue( Address, SYM(NTFS_MCB), "FastMutex" );

    NtfsMcbArray = ReadValue( Address, SYM(NTFS_MCB), "NtfsMcbArray" );
    NtfsMcbArraySizeInUse = (ULONG)ReadValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySizeInUse" );

    for (RangeIdx=0; RangeIdx<NtfsMcbArraySizeInUse; RangeIdx++) {

        dprintf( "\n    Range %d", RangeIdx );

        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "StartingVcn" );
        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "EndingVcn" );
        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "NtfsMcbEntry" );

        MappingPairsAddress = ReadValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "NtfsMcbEntry" ) +
                              GetOffset(SYM(NTFS_MCB_ENTRY),"LargeMcb") +
                              GetOffset(SYM(LARGE_MCB),"Mapping");

        DumpPtrValue( MappingPairsAddress, "MappingPairs" );

        //
        //  Go on to the next range.
        //

        NtfsMcbArray += GetTypeSize(SYM(NTFS_MCB_ARRAY));

        if (CheckControlC()) {
            break;
        }
    }

    dprintf( "\n" );
}


ULONG
DumpVcbQueue(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for the Vcb Queue

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Vcb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 Vpb;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
        DumpVcb( Vcb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
        Vpb = ReadValue( Vcb, SYM(VCB), "Vpb" );
        dprintf( "\n   Vcb %s label: ", FormatValue(Vcb) );
        if (!DumpString( Vpb, NT(VPB), "VolumeLabelLength", "VolumeLabel" )) {
            dprintf( "<label unavailable>" );
        }
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpNtfsData )

/*++

Routine Description:

    Dump the list of Vcbs for the global NtfsData.

Arguments:

    Options - If 1, we recurse into the Vcbs and dump them

Return Value:

    None

--*/

{
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;


    INIT_DUMP();

    Address = GetExpression( "Ntfs!NtfsData" );

    dprintf( "\nNtfsData: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(NTFS_DATA), "NodeTypeCode" );
    if (Value != NTFS_NTC_DATA_HEADER) {
        dprintf( "\nNtfsData signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    PrintState( NtfsFlags, (ULONG)ReadValue( Address, SYM(NTFS_DATA), "Flags" ) );

    //
    // dump the vcb queue (mounted volumes)
    //

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    Value = ReadValue( Address, SYM(NTFS_DATA), "VcbQueue.Flink" );
    if (Value) {
        ListType( SYM(VCB), Value, TRUE, "VcbLinks.Flink", (PVOID)&dec, DumpVcbQueue );
    }

    dprintf( "\n" );

    DumpValue( Address, SYM(NTFS_DATA), "DriverObject" );
    DumpValue( Address, SYM(NTFS_DATA), "Resource" );
    DumpValue( Address, SYM(NTFS_DATA), "AsyncCloseActive" );
    DumpValue( Address, SYM(NTFS_DATA), "ReduceDelayedClose" );
    DumpValue( Address, SYM(NTFS_DATA), "AsyncCloseCount" );
    DumpValue( Address, SYM(NTFS_DATA), "OurProcess" );
    DumpValue( Address, SYM(NTFS_DATA), "DelayedCloseCount" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeFcbTableSize" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceSize" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceTotal" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceMiss" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceArray" );
    DumpValue( Address, SYM(NTFS_DATA), "Flags" );
}


DECLARE_DUMP_FUNCTION( DumpScb )

/*++

Routine Description:

    Dump an Scb.

Arguments:

    Address - Gives the address of the Scb to dump

    Options - If 1, we dump the Fcb & Vcb for this Scb

Return Value:

    None

--*/

{
    ULONG64 Value = 0;


    INIT_DUMP();

    _try {

        Value = ReadValue( Address, SYM(SCB), "ScbState" );
        if (!Value) {
            _leave;
        }

        dprintf( "\nScb: %s", FormatValue(Address) );

        PrintState( ScbState, (ULONG)Value );

        dprintf( "\nScbPersist:" );
        PrintState( ScbPersist, (ULONG)ReadValue( Address, SYM(SCB), "ScbPersist" ) );

        Value = ReadValue( Address, SYM(FSRTL_COMMON_FCB_HEADER), "NodeTypeCode" );
        if (!Value) {
            _leave;
        }
        dprintf( "\n  ScbType: " );

        switch ( Value ) {

            case NTFS_NTC_SCB_INDEX:

               dprintf( "Index" );
               break;

            case NTFS_NTC_SCB_ROOT_INDEX:

               dprintf( "RootIndex" );
               break;

            case NTFS_NTC_SCB_DATA:

               dprintf( "Data" );
               break;

            case NTFS_NTC_SCB_MFT:

               dprintf( "Mft" );
               break;

            default:

               dprintf( "!!!UNKNOWN SCBTYPE!!!, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
               break;
        }

        if (Options >= 1) {

            Value = ReadValue( Address, SYM(SCB), "Fcb" );
            if (Value) {
                DumpFcb( Value, 0, Options - 1, Processor, hCurrentThread );
            }
            Value = ReadValue( Address, SYM(SCB), "Vcb" );
            if (Value) {
                DumpVcb( Value, 0, Options - 1, Processor, hCurrentThread );
            }

        } else {

            DumpValue( Address, SYM(SCB), "Fcb" );
            DumpValue( Address, SYM(SCB), "Vcb" );
            DumpValue( Address, SYM(SCB), "Mcb" );
            DumpValue( Address, SYM(SCB), "NonCachedCleanupCount" );
            DumpValue( Address, SYM(SCB), "CleanupCount" );
            DumpValue( Address, SYM(SCB), "CloseCount" );
            DumpValue( Address, SYM(SCB), "ShareAccess" );
            DumpValue( Address, SYM(SCB), "AttributeTypeCode" );
            DumpValue( Address, SYM(SCB), "AttributeName.Length" );
            DumpValue( Address, SYM(SCB), "AttributeName.Buffer" );
            DumpValue( Address, SYM(SCB), "AttributeFlags" );
            DumpValue( Address, SYM(SCB), "CompressionUnit" );
            DumpValue( Address, SYM(SCB), "FileObject" );
            DumpValue( Address, SYM(SCB), "NonpagedScb" );
            DumpValue( Address, SYM(SCB), "EncryptionContext" );
        }

    } finally {

    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpVcb )

/*++

Routine Description:

    Dump a Vcb.

Arguments:

    Address - Gives the address of the Vcb to dump

    Options - If 1, we also dump the root Lcb and the Fcb table
              If 2, we dump everything for option 1, and also dump the Fcbs in the Fcb table

Return Value:

    None

--*/

{
    ULONG64 Value = 0;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(VCB), "NodeTypeCode" );

    dprintf( "\n  Vcb: %s", FormatValue(Address) );

    if (Value != NTFS_NTC_VCB) {

        dprintf( "\nVCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    PrintState( VcbState, (ULONG)ReadValue( Address, SYM(VCB), "VcbState" ) );

    DumpValue( Address, SYM(VCB), "CleanupCount" );
    DumpValue( Address, SYM(VCB), "CloseCount" );
    DumpValue( Address, SYM(VCB), "ReadOnlyCloseCount" );
    DumpValue( Address, SYM(VCB), "SystemFileCloseCount" );
    DumpValue( Address, SYM(VCB), "UsnJournal" );
    DumpValue( Address, SYM(VCB), "MftScb" );
    DumpValue( Address, SYM(VCB), "Mft2Scb" );
    DumpValue( Address, SYM(VCB), "LogFileScb" );
    DumpValue( Address, SYM(VCB), "VolumeDasdScb" );
    DumpValue( Address, SYM(VCB), "RootIndexScb" );
    DumpValue( Address, SYM(VCB), "BitmapScb" );
    DumpValue( Address, SYM(VCB), "AttributeDefTableScb" );
    DumpValue( Address, SYM(VCB), "UpcaseTableScb" );
    DumpValue( Address, SYM(VCB), "BadClusterFileScb" );
    DumpValue( Address, SYM(VCB), "QuotaTableScb" );
    DumpValue( Address, SYM(VCB), "ReparsePointTableScb" );
    DumpValue( Address, SYM(VCB), "OwnerIdTableScb" );
    DumpValue( Address, SYM(VCB), "SecurityDescriptorStream" );
    DumpValue( Address, SYM(VCB), "SecurityIdIndex" );
    DumpValue( Address, SYM(VCB), "SecurityDescriptorHashIndex" );
    DumpValue( Address, SYM(VCB), "ExtendDirectory" );
    DumpValue( Address, SYM(VCB), "ObjectIdTableScb" );
    DumpValue( Address, SYM(VCB), "MftBitmapScb" );
    DumpValue( Address, SYM(VCB), "RootLcb" );
    DumpValue( Address, SYM(VCB), "FcbTable" );
    DumpValue( Address, SYM(VCB), "Statistics" );
    DumpValue( Address, SYM(VCB), "Resource" );

    if (Options < 0) {

        ResetFileSystemStatistics( Address, Processor, hCurrentThread );

    } else if (Options >= 2) {

        DumpFileSystemStatistics( Address, Processor, hCurrentThread );

    } else if (Options >= 1) {

        DumpLcb( ReadValue( Address, SYM(VCB), "RootLcb" ), 0, Options - 1, Processor, hCurrentThread );
        DumpFcbTable( ReadValue( Address, SYM(VCB), "FcbTable" ), 0, Options - 1, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


VOID
ResetFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump the file system statitics of a vcb

Arguments:

    Vcb - Suppplies a pointer to a vcb that the debugger has already loaded.

Return Value:

    None

--*/

{
    ULONG Result;
    PUCHAR Stat;
    ULONG64 StatsAddr;

    dprintf( "\n" );
    dprintf( "\n" );

    //
    //  Write the Statistics structure based on the processor, but
    //  skip over the file system type and version field.
    //

    Result = GetTypeSize(SYM(FILE_SYSTEM_STATISTICS));
    Stat = malloc( Result );
    if (Stat) {
        StatsAddr = ReadValue( VcbAddress, SYM(VCB), "Statistics" );
        if (StatsAddr) {
            if (!WriteMemory( StatsAddr + (Result * Processor) + GetOffset(SYM(FILE_SYSTEM_STATISTICS),"Common.UserFileReads"),
                               &Stat,
                               Result - GetOffset(SYM(FILE_SYSTEM_STATISTICS),"Common.UserFileReads"),
                               &Result) ) {

                dprintf( "%s: Unable to reset Statistics\n", FormatValue(StatsAddr) );
            }
        }
        free( Stat );
        dprintf( "**** %s: Resetting Filesystem Statistics complete ****\n", FormatValue(StatsAddr) );
    }

    DumpFileSystemStatistics( VcbAddress, Processor, hCurrentThread );
}


VOID
DumpFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump the file system statitics of a vcb

Arguments:

    Vcb - Suppplies a pointer to a vcb that the debugger has already loaded.

Return Value:

    None

--*/

{
    ULONG Result;
    ULONG64 StatsAddr;
    FILE_SYSTEM_STATISTICS Stat;

    ULONG TotalReads;
    ULONG TotalReadBytes;
    ULONG TotalWrites;
    ULONG TotalWriteBytes;

    ULONG TotalClustersReturned;

    ULONG AverageRequestSize;
    ULONG AverageRunSize;
    ULONG AverageHintSize;
    ULONG AverageCacheSize;
    ULONG AverageCacheMissSize;

    UNREFERENCED_PARAMETER( hCurrentThread );

    //
    //  Read in the Statistics structure based on the processor
    //

    StatsAddr = ReadValue( VcbAddress, SYM(VCB), "Statistics" );

    if ( !ReadMemory( StatsAddr + (GetTypeSize(SYM(FILE_SYSTEM_STATISTICS)) * Processor),
                      &Stat,
                      GetTypeSize(SYM(FILE_SYSTEM_STATISTICS)),
                      &Result) ) {

        dprintf( "%08lx: Unable to read Statistics\n", StatsAddr );
        return;
    }

    //
    //  Sum up all the paging i/o reads and writes
    //

    TotalReads      = Stat.Common.UserFileReads      + Stat.Common.MetaDataReads      + Stat.Ntfs.UserIndexReads      + Stat.Ntfs.LogFileReads;
    TotalReadBytes  = Stat.Common.UserFileReadBytes  + Stat.Common.MetaDataReadBytes  + Stat.Ntfs.UserIndexReadBytes  + Stat.Ntfs.LogFileReadBytes;
    TotalWrites     = Stat.Common.UserFileWrites     + Stat.Common.MetaDataWrites     + Stat.Ntfs.UserIndexWrites     + Stat.Ntfs.LogFileWrites;
    TotalWriteBytes = Stat.Common.UserFileWriteBytes + Stat.Common.MetaDataWriteBytes + Stat.Ntfs.UserIndexWriteBytes + Stat.Ntfs.LogFileWriteBytes;

    //
    //  Sum up the total number of clusters returned
    //

    TotalClustersReturned = Stat.Ntfs.Allocate.HintsClusters + Stat.Ntfs.Allocate.CacheClusters + Stat.Ntfs.Allocate.CacheMissClusters;

    //
    //  Compute the average cluster count requested, returned, from hints, and from the cache, and cache misses.
    //

    AverageRequestSize   = AVERAGE(Stat.Ntfs.Allocate.Clusters, Stat.Ntfs.Allocate.Calls);
    AverageRunSize       = AVERAGE(TotalClustersReturned, Stat.Ntfs.Allocate.RunsReturned);

    AverageHintSize      = AVERAGE(Stat.Ntfs.Allocate.HintsClusters, Stat.Ntfs.Allocate.HintsHonored);
    AverageCacheSize     = AVERAGE(Stat.Ntfs.Allocate.CacheClusters, Stat.Ntfs.Allocate.Cache);
    AverageCacheMissSize = AVERAGE(Stat.Ntfs.Allocate.CacheMissClusters, Stat.Ntfs.Allocate.CacheMiss);

    dprintf( "\n" );
    dprintf( "\n      File System Statistics @ %s for Processor = %d", FormatValue(StatsAddr), Processor );
    dprintf( "\n        FileSystemType / Version = %d / %d", Stat.Common.FileSystemType, Stat.Common.Version );
    dprintf( "\n" );
    dprintf( "\n        Exceptions LogFileFull = %ld Other = %ld", Stat.Ntfs.LogFileFullExceptions, Stat.Ntfs.OtherExceptions );
    dprintf( "\n" );
    dprintf( "\n                       Reads       Bytes     Writes       Bytes" );
    dprintf( "\n                       -----       -----     ------       -----" );
    dprintf( "\n" );
    dprintf( "\n        UserFile  %10ld (%10ld)%10ld (%10ld)",           Stat.Common.UserFileReads,       Stat.Common.UserFileReadBytes,  Stat.Common.UserFileWrites,       Stat.Common.UserFileWriteBytes );
    dprintf( "\n         UserDisk %10ld             %10ld",              Stat.Common.UserDiskReads,       Stat.Common.UserDiskWrites );
    dprintf( "\n" );
    dprintf( "\n        MetaData  %10ld (%10ld)%10ld (%10ld)",           Stat.Common.MetaDataReads,       Stat.Common.MetaDataReadBytes,  Stat.Common.MetaDataWrites,       Stat.Common.MetaDataWriteBytes );
    dprintf( "\n         MetaDisk %10ld             %10ld",              Stat.Common.MetaDataDiskReads,   Stat.Common.MetaDataDiskWrites );
    dprintf( "\n" );
    dprintf( "\n         Mft      %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.MftReads,       Stat.Ntfs.MftReadBytes,       Stat.Ntfs.MftWrites,       Stat.Ntfs.MftWriteBytes );
    dprintf( "\n         Mft2                            %10ld (%10lx)",                                                         Stat.Ntfs.Mft2Writes,      Stat.Ntfs.Mft2WriteBytes );
    dprintf( "\n         RootIndex%10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.RootIndexReads, Stat.Ntfs.RootIndexReadBytes, Stat.Ntfs.RootIndexWrites, Stat.Ntfs.RootIndexWriteBytes );
    dprintf( "\n         Bitmap   %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.BitmapReads,    Stat.Ntfs.BitmapReadBytes,    Stat.Ntfs.BitmapWrites,    Stat.Ntfs.BitmapWriteBytes );
    dprintf( "\n         MftBitmap%10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.MftBitmapReads, Stat.Ntfs.MftBitmapReadBytes, Stat.Ntfs.MftBitmapWrites, Stat.Ntfs.MftBitmapWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        UserIndex %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.UserIndexReads, Stat.Ntfs.UserIndexReadBytes, Stat.Ntfs.UserIndexWrites, Stat.Ntfs.UserIndexWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        LogFile   %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.LogFileReads,   Stat.Ntfs.LogFileReadBytes,   Stat.Ntfs.LogFileWrites,   Stat.Ntfs.LogFileWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        TOTAL     %10ld (%10ld)%10ld (%10ld)",           TotalReads, TotalReadBytes, TotalWrites, TotalWriteBytes );
    dprintf( "\n" );
    dprintf( "\n                                 Write   Create  SetInfo    Flush" );
    dprintf( "\n                                 -----   ------  -------    -----" );
    dprintf( "\n        MftWritesUserLevel       %5d    %5d    %5d    %5d", Stat.Ntfs.MftWritesUserLevel.Write,       Stat.Ntfs.MftWritesUserLevel.Create,       Stat.Ntfs.MftWritesUserLevel.SetInfo,       Stat.Ntfs.MftWritesUserLevel.Flush );
    dprintf( "\n        Mft2WritesUserLevel      %5d    %5d    %5d    %5d", Stat.Ntfs.Mft2WritesUserLevel.Write,      Stat.Ntfs.Mft2WritesUserLevel.Create,      Stat.Ntfs.Mft2WritesUserLevel.SetInfo,      Stat.Ntfs.Mft2WritesUserLevel.Flush );
    dprintf( "\n        BitmapWritesUserLevel    %5d    %5d    %5d",        Stat.Ntfs.BitmapWritesUserLevel.Write,    Stat.Ntfs.BitmapWritesUserLevel.Create,    Stat.Ntfs.BitmapWritesUserLevel.SetInfo );
    dprintf( "\n        MftBitmapWritesUserLevel %5d    %5d    %5d    %5d", Stat.Ntfs.MftBitmapWritesUserLevel.Write, Stat.Ntfs.MftBitmapWritesUserLevel.Create, Stat.Ntfs.MftBitmapWritesUserLevel.SetInfo, Stat.Ntfs.MftBitmapWritesUserLevel.Flush );
    dprintf( "\n" );
    dprintf( "\n                   FlushForLogFileFull  LazyWriter  UserRequest" );
    dprintf( "\n                   -------------------  ----------  -----------" );
    dprintf( "\n        MftWrites                %5d       %5d        %5d", Stat.Ntfs.MftWritesFlushForLogFileFull,       Stat.Ntfs.MftWritesLazyWriter,       Stat.Ntfs.MftWritesUserRequest );
    dprintf( "\n        Mft2Writes               %5d       %5d        %5d", Stat.Ntfs.Mft2WritesFlushForLogFileFull,      Stat.Ntfs.Mft2WritesLazyWriter,      Stat.Ntfs.Mft2WritesUserRequest );
    dprintf( "\n        BitmapWrites             %5d       %5d        %5d", Stat.Ntfs.BitmapWritesFlushForLogFileFull,    Stat.Ntfs.BitmapWritesLazyWriter,    Stat.Ntfs.BitmapWritesUserRequest );
    dprintf( "\n        MftBitmapWrites          %5d       %5d        %5d", Stat.Ntfs.MftBitmapWritesFlushForLogFileFull, Stat.Ntfs.MftBitmapWritesLazyWriter, Stat.Ntfs.MftBitmapWritesUserRequest );
    dprintf( "\n" );
    dprintf( "\n        Allocate                              Total     Average" );
    dprintf( "\n        Clusters        Runs       Hints   Clusters     RunSize" );
    dprintf( "\n                        ----       -----   --------     -------" );
    dprintf( "\n        Requested %10ld  %10ld %10ld  %10ld", Stat.Ntfs.Allocate.Calls, Stat.Ntfs.Allocate.Hints, Stat.Ntfs.Allocate.Clusters, AverageRequestSize );
    dprintf( "\n        Returned  %10ld  %10ld %10ld  %10ld", Stat.Ntfs.Allocate.RunsReturned, Stat.Ntfs.Allocate.HintsHonored, TotalClustersReturned, AverageRunSize );
    dprintf( "\n" );
    dprintf( "\n        FromHints %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.HintsHonored, Stat.Ntfs.Allocate.HintsClusters, AverageHintSize );
    dprintf( "\n        CacheHit  %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.Cache, Stat.Ntfs.Allocate.CacheClusters, AverageCacheSize );
    dprintf( "\n        CacheMiss %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.CacheMiss, Stat.Ntfs.Allocate.CacheMissClusters, AverageCacheMissSize );
    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpSysCache )

/*++

Routine Description:

    Dump the syscache buffers.  The target system must have been
    built with syscache enabled.

Arguments:

    Address - Gives the address of the Vcb to dump

Return Value:

    None

--*/

{
    ULONG SyscacheLogEntryCount;
    ULONG CurrentSyscacheLogEntry;
    PSYSCACHE_LOG pLog = NULL;
    int iEnd;
    int iStart;
    int iTemp;
    int iIndex;


    INIT_DUMP();

    if (GetOffset( SYM(VCB), "SyscacheScb" ) == -1) {
        //
        // the system was not built with syscache debug
        //
        dprintf( "\nthe target system does not have syscache debug enabled\n" );
        return;
    }

    if (Options != 0) {
        dprintf( "Direct buffer dump\n" );
        dprintf("Num Entries: 0x%x\n", Options );
        dprintf("Current Entry: 0x%x\n", Options );

        CurrentSyscacheLogEntry = Options;
        SyscacheLogEntryCount = Options;

        pLog = (PSYSCACHE_LOG) malloc( GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount );
        if (!pLog) {
            return;
        }

        if (!ReadMemory( Address, pLog, GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount, &iTemp )) {

            dprintf( "Unable to read SCB.SyscacheLog\n" );
            return;
        }


    } else {
        SyscacheLogEntryCount = ReadUlongValue(Address,SYM(SCB),"SyscacheLogEntryCount");
        CurrentSyscacheLogEntry = ReadUlongValue(Address,SYM(SCB),"CurrentSyscacheLogEntry");
        dprintf("Num Entries: 0x%x\n", SyscacheLogEntryCount );
        dprintf("Current Entry: 0x%x\n", ReadUlongValue(Address,SYM(SCB),"CurrentSyscacheLogEntry") );

        pLog = (PSYSCACHE_LOG) malloc( GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount );
        if (!pLog) {
            return;
        }

        if (!ReadMemory( ReadValue(Address,SYM(SCB),"SyscacheLog"), pLog,
                         GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount, &iTemp )) {

            dprintf( "Unable to read SCB.SyscacheLog\n" );
            return;
        }
    }

    if (CurrentSyscacheLogEntry > SyscacheLogEntryCount) {
        iStart = CurrentSyscacheLogEntry;
        iEnd = CurrentSyscacheLogEntry + SyscacheLogEntryCount;;
    } else {
        iStart = 0;
        iEnd = CurrentSyscacheLogEntry;
    }

    for (iIndex= iStart; iIndex < iEnd; iIndex++) {

        iTemp = iIndex % SyscacheLogEntryCount;

        if (iStart == 0) {
            dprintf("Entry: 0x%x\n", iIndex);
        } else {
            dprintf("Entry: 0x%x\n", iIndex - SyscacheLogEntryCount);
        }

        dprintf("Event: 0x%x ", pLog[iTemp ].Event);
        if (pLog[iTemp].Event < SCE_MAX_EVENT) {
            dprintf("(%s)\n", LogEvent[pLog[iTemp].Event]);
        } else {
            dprintf("\n");
        }

        dprintf("Flags: 0x%x (", pLog[iTemp].Flags);
        if (pLog[iTemp].Flags & SCE_FLAG_WRITE) {
            dprintf("write ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_READ) {
            dprintf("read ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_PAGING) {
            dprintf("paging io ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_ASYNC) {
            dprintf("asyncfileobj ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_ALLOC) {
            dprintf("setalloc ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_EOF) {
            dprintf("seteof ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_CANT_WAIT) {
            dprintf("cantwait ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SYNC_PAGING) {
            dprintf("synchpaging ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_LAZY_WRITE) {
            dprintf("lazywrite ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_CACHED) {
             dprintf("cached ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_ON_DISK_READ) {
             dprintf("fromdisk ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_RECURSIVE) {
             dprintf("recursive ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_NON_CACHED) {
             dprintf("noncached ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_UPDATE_FROM_DISK) {
            dprintf("updatefromdisk ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_COMPRESSED) {
            dprintf("compressed ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_VDL) {
            dprintf("setvdl ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_FASTIO) {
            dprintf("fastio ");
        }

        dprintf(")\n");
        dprintf("Start: 0x%I64x Range: 0x%I64x Result: 0x%I64x\n",
                pLog[iTemp].Start, pLog[iTemp].Range, pLog[iTemp].Result);

        dprintf("\n");
    }

    if (pLog) {
        free(pLog);
    }
}


DECLARE_DUMP_FUNCTION( DumpExtents )

/*++

Routine Description:

    Dump the extents for a file

Arguments:

    Address - Gives the address of the Vcb to dump

Return Value:

    None

--*/

{
    UCHAR FormCode;
    PVOID Buffer;
    PBYTE TempByte;
    ULONG ChangedLCNBytes;
    ULONG ChangedVCNBytes;
    ULONG Increment;
    ULONG Index;
    ULONG Increment2;
    ULONG LCN = 0;
    ULONG VCN = 0;
    ULONG RecordLength;
    USHORT MappingPairsOffset;


    INIT_DUMP();

    FormCode = (UCHAR)ReadValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "FormCode" );
    if (!(FormCode & NONRESIDENT_FORM)) {
        dprintf( "resident attribute\n" );
        return;
    }

    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.MappingPairsOffset" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.LowestVcn" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.HighestVcn" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.AllocatedLength" );

    dprintf( "\n" );

    RecordLength = ReadUlongValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "RecordLength" );
    if (!RecordLength) {
        return;
    }

    MappingPairsOffset = ReadShortValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.MappingPairsOffset" );
    if (!MappingPairsOffset) {
        return;
    }

    RecordLength -= MappingPairsOffset;

    Buffer = malloc( RecordLength );
    if (!ReadMemory( Address+MappingPairsOffset, Buffer, RecordLength, &RecordLength )) {
        dprintf( "Unable to read memory at %s\n", FormatValue(Address+MappingPairsOffset) );
        free( Buffer );
        return;
    }

    TempByte = Buffer;

    //
    // walk byte stream
    //

    while(*TempByte != 0) {
        ChangedLCNBytes = *TempByte >> 4;
        ChangedVCNBytes = *TempByte & (0x0f);

        TempByte++;

        for (Increment=0, Index=0; Index < ChangedVCNBytes; Index++) {
            Increment+= *TempByte++ << (8 * Index);
        }

        for (Increment2 =0, Index=0; Index < ChangedLCNBytes; Index++) {
            Increment2+= *TempByte++ << (8 * Index);
        }

        //
        // if last bit is set (this is a neg) extend with 0xff
        //

        if (0x80 & (*(TempByte-1))) {
            for(; Index < GetTypeSize("ULONG"); Index++) {
                Increment2 += 0xff << (8 * Index);
            }
        }

        LCN += Increment2;
        dprintf( "LCN: 0x%x  VCN: 0x%x Clusters: 0x%x ", LCN, VCN, Increment );

        for (Index = ChangedLCNBytes + ChangedVCNBytes + 1; Index > 0; Index--) {
            dprintf( "%02x", *(TempByte - Index));
        }
        dprintf( "\n" );

        VCN += Increment;
    }

    free( Buffer );
}


ULONG
ThreadListCallback(
    IN PFIELD_INFO listElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for cachedrecords to check for cached file records

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 ThreadAddress=listElement->address;
    ULONG64 TopLevelIrp;
    ULONG NtfsSig;
    ULONG64 ThreadIrpContext;
    int Index;
    ULONG RecordSize;
    ULONG64 RecordAddress;
    ULONG64 FileRecordBcb;
    ULONG64 FileRecord;
    ULONG UnsafeSegmentNumber;

    TopLevelIrp = ReadValue( ThreadAddress, NT(ETHREAD), "TopLevelIrp" );

    if (TopLevelIrp) {
        NtfsSig = ReadUlongValue( TopLevelIrp, SYM(TOP_LEVEL_CONTEXT), "Ntfs" );

        if (NtfsSig == 0x5346544e) {
            ThreadIrpContext = ReadValue( TopLevelIrp, SYM(TOP_LEVEL_CONTEXT), "ThreadIrpContext" );
            if (ThreadIrpContext) {
                RecordSize = GetTypeSize(SYM(IRP_FILE_RECORD_CACHE_ENTRY));
                RecordAddress = ThreadIrpContext + GetOffset(SYM(IRP_CONTEXT),"FileRecordCache");

                dprintf ("record: 0x%x\n", RecordAddress );

                for (Index=0; Index<IRP_FILE_RECORD_MAP_CACHE_SIZE; Index++) {

                    FileRecord = ReadValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "FileRecord" );
                    FileRecordBcb = ReadValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "FileRecordBcb" );

                    if (FileRecord) {
                        UnsafeSegmentNumber = ReadUlongValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "UnsafeSegmentNumber" );
                        dprintf( "Thread: 0x%s FileRecord: 0x%s Bcb: 0x%s SegmentNum: 0x%x\n",
                                 FormatValue(ThreadAddress),
                                 FormatValue(FileRecord),
                                 FormatValue(FileRecordBcb),
                                 UnsafeSegmentNumber
                                 );
                    }
                    RecordAddress += RecordSize;
                }
            }
        }
    }

    return FALSE;
}


ULONG
ProcessListCallback(
    IN PFIELD_INFO listElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for cachedrecords to check for cached file records

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 ProcAddress=listElement->address;
    ULONG64 FirstThread;


    FirstThread = ReadValue( ProcAddress, NT(EPROCESS), "Pcb.ThreadListHead.Flink" );
    if (FirstThread) {
        ListType( NT(ETHREAD), FirstThread, 1, "Tcb.ThreadListEntry.Flink", (PVOID)dec, &ThreadListCallback );
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpCachedRecords )

/*++

Routine Description:

    Walk all processes and dump any which are holding filerecords cached in
    irpcontexts

Arguments:

    arg - none

Return Value:

    None

--*/

{
    ULONG64 FirstProcess;
    DUMP_ENUM_CONTEXT dec;

    INIT_DUMP();


    FirstProcess = ReadValue( KdDebuggerData.PsActiveProcessHead, NT(LIST_ENTRY), "Flink" );
    if (FirstProcess == 0) {
        dprintf( "Unable to read _LIST_ENTRY @ %s \n", FormatValue(KdDebuggerData.PsActiveProcessHead) );
        return;
    }

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    ListType( NT(EPROCESS), FirstProcess, 1, "ActiveProcessLinks.Flink", (PVOID)&dec, &ProcessListCallback );
}


DECLARE_DUMP_FUNCTION( DumpHashTable )

/*++

Routine Description:

    Dump a prefix hash table

Arguments:

    arg - none

Return Value:

    None

--*/

{
    ULONG64 HashSegmentsOffset;
    ULONG64 HashSegmentAddress;
    ULONG64 HashSegmentPtr;
    ULONG HashEntrySize;
    DWORD Index;
    DWORD Index2;
    ULONG BytesRead;
    ULONG64 NextAddr;
    ULONG PtrSize;


    INIT_DUMP();

    dprintf( "Hash Table: 0x%s\n", FormatValue(Address) );
    dprintf( "Max Buckets: 0x%x  Splitpoint: 0x%x\n",
        ReadUlongValue( Address, SYM(NTFS_HASH_TABLE), "MaxBucket" ),
        ReadUlongValue( Address, SYM(NTFS_HASH_TABLE), "SplitPoint" ) );

    HashSegmentsOffset = GetOffset(SYM(NTFS_HASH_TABLE),"HashSegments");
    HashEntrySize = GetTypeSize(SYM(NTFS_HASH_ENTRY));
    PtrSize = GetTypeSize(SYM(PVOID));
    HashSegmentAddress = Address + HashSegmentsOffset;

    for (Index=0; Index<HASH_MAX_SEGMENT_COUNT; Index++) {
        HashSegmentAddress += (Index * PtrSize);
        if (ReadMemory( HashSegmentAddress, &HashSegmentPtr, PtrSize, &BytesRead ) && HashSegmentPtr) {
            for (Index2=0; Index2<HASH_MAX_INDEX_COUNT; Index2++) {
                NextAddr = HashSegmentPtr + (Index2 * PtrSize);
                while (NextAddr) {
                    if (Address2 == 0 || ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashLcb" ) == Address2) {
                        dprintf( "Lcb: 0x%s Hash: 0x%x\n",
                            FormatValue(ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashLcb" )),
                            ReadUlongValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashValue" ) );
                    }
                    NextAddr = ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "NextEntry" );
                    if (CheckControlC()) {
                        return;
                    }
                }
                if (CheckControlC()) {
                    return;
                }
            }
        }
        if (CheckControlC()) {
            return;
        }
    }
}


ULONG
FindIndexScb(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function to locate the index scb

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Scb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;


    if (CheckControlC()) {
        return TRUE;
    }

    if (ReadValue( Scb, SYM(SCB), "AttributeTypeCode" ) == $INDEX_ALLOCATION) {
        dec->ReturnValue = Scb;
        return TRUE;
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpFcbLcbChain )

/*++

Routine Description:

    Dump a fcb - lcb - chain to find the bottom

Arguments:

    arg - the initial fcb

Return Value:

    None

--*/

{
    ULONG64 FcbAddress = Address;
    ULONG64 ScbAddress = 0;
    ULONG64 LcbAddress = 0;
    ULONG64 Link = 0;
    DUMP_ENUM_CONTEXT dec;
    ULONG64 Value;

    INIT_DUMP();


    do {

        if (ReadValue( FcbAddress, SYM(FCB), "NodeTypeCode" ) != NTFS_NTC_FCB) {
            dprintf( "Not an FCB at 0x%s\n", FormatValue(FcbAddress) );
            return;
        }

        //
        // initialize the enum context for all out enumerations
        //

        dec.hCurrentThread = hCurrentThread;
        dec.Processor = Processor;
        dec.Options = Options;
        dec.ReturnValue = 0;

        //
        //   Find the index SCB
        //

        Value = ReadValue( FcbAddress, SYM(FCB), "ScbQueue.Flink" );
        if (Value) {
            ListType( SYM(SCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, FindIndexScb );
            if (dec.ReturnValue) {
                ScbAddress = dec.ReturnValue;
            }
        }

        if (ScbAddress == 0) {
            dprintf( "unable to find index scb in fcb: 0x%s\n", FormatValue(FcbAddress) );
            return;
        }

        dprintf( "Scb: 0x%s, NameLen: 0x%x Counts: 0x%x 0x%x\n",
            FormatValue(ScbAddress),
            ReadShortValue( ScbAddress, SYM(SCB), "ScbType.Index.NormalizedName.MaximumLength" ),
            ReadUlongValue( ScbAddress, SYM(SCB), "CleanupCount" ),
            ReadUlongValue( ScbAddress, SYM(SCB), "CloseCount" )
            );

        Value = ReadValue( ScbAddress, SYM(SCB), "ScbType.Index.LcbQueue.Flink" );

        if (Value != (ScbAddress + GetOffset(SYM(SCB),"Index.LcbQueue.Flink"))) {

            //
            //  Read the 1st lcb
            //

            LcbAddress = Value - GetOffset(SYM(LCB),"ScbLinks");

            dprintf( "lcb: 0x%s Cleanup: 0x%x fcb: 0x%s\n",
                FormatValue(LcbAddress),
                ReadUlongValue( LcbAddress, SYM(LCB), "CleanupCount" ),
                FormatValue(ReadValue( LcbAddress, SYM(LCB), "Fcb" ))
                );

            FcbAddress = ReadValue( LcbAddress, SYM(LCB), "Fcb" );

        } else {

            dprintf( "lcbqueue empty: 0x%s\n", FormatValue(ScbAddress) );
            return;
        }

        if (CheckControlC()) {
            return;
        }

    } while ( TRUE );
}


ULONG
EnumOverflow(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function to dump the overflow queue

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 IrpContext = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 OriginatingIrp;
    ULONG64 MdlAddress;


    if (CheckControlC()) {
        return TRUE;
    }

    OriginatingIrp = ReadValue( IrpContext, SYM(IRP_CONTEXT), "OriginatingIrp" );
    if (OriginatingIrp) {
        dprintf( "0x%s 0x%x ", FormatValue(OriginatingIrp), ReadValue( OriginatingIrp, SYM(IRP), "Cancel" ) );
        MdlAddress = ReadValue( OriginatingIrp, SYM(IRP), "MdlAddress" );
        if (MdlAddress) {
            dprintf( "0x%s", FormatValue(ReadValue( MdlAddress, NT(MDL), "Process" )) );
        }
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpOverflow )

/*++

Routine Description:

    Dump the overflow queue

Arguments:

    arg - Vcb

Return Value:

    None

--*/

{
    ULONG64 VcbAddress;
    ULONG64 VdoAddress;
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;

    INIT_DUMP();


    VcbAddress = Address;
    VdoAddress = VcbAddress - GetOffset(SYM(VOLUME_DEVICE_OBJECT),"Vcb");

    dprintf( "Volume Device: 0x%s Vcb: 0x%s  OverflowCount: 0x%x\n",
        FormatValue(VdoAddress), FormatValue(VcbAddress),
        ReadUlongValue( VdoAddress, SYM(VOLUME_DEVICE_OBJECT), "OverflowQueueCount" ) );

    dprintf("\nIrpContext Irp Cancelled Process\n");

    Value = ReadValue( VdoAddress, SYM(VOLUME_DEVICE_OBJECT), "OverflowQueue.Flink" );

    if (Value && Value != VdoAddress + GetOffset(SYM(VOLUME_DEVICE_OBJECT),"OverflowQueue.Flink")) {

        dec.hCurrentThread = hCurrentThread;
        dec.Processor = Processor;
        dec.Options = Options;
        dec.ReturnValue = 0;

        ListType( SYM(IRP_CONTEXT), Value, TRUE, "ListEntry.Flink", (PVOID)&dec, EnumOverflow );
    }
}


DECLARE_DUMP_FUNCTION( DumpCachedRuns )

/*++

Routine Description:

    Dumps the cached runs array
    
Arguments:

    Address - Gives the address of the cached runs array to be dumped

Return Value:

    None

--*/

{
    ULONG64 AvailRuns;
    ULONG64 MaxUsed;
    ULONG64 ClusterRunSize;
    int Index;
    LCN Lcn;
    LONGLONG Length;
    ULONG64 LcnArray;
    USHORT LenIndex;
    ULONG64 LengthArray;
    ULONG BytesRead;
    USHORT WindowStart;
    USHORT WindowEnd;
    ULONG DelWindowIndex = 0;
    ULONG64 DelArray;
    ULONG64 DelWindowSize;
    ULONG64 DelLengthCount;
    LONGLONG PrevLength = -1;

    INIT_DUMP();

    dprintf( "CachedRun: %p ", Address );

    AvailRuns = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "Avail" );
    MaxUsed = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "Used" );
    ClusterRunSize = GetTypeSize( SYM(NTFS_LCN_CLUSTER_RUN) );
    LcnArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "LcnArray" );
    LengthArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "LengthArray" );
    DelLengthCount = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "DelLengthCount" );
    DelArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "DeletedLengthWindows" );
    DelWindowSize = GetTypeSize( SYM(NTFS_DELETED_RUNS) );

    if (DelWindowIndex < DelLengthCount) {

        WindowStart = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "StartIndex" );
        WindowEnd = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "EndIndex" );
        DelWindowIndex++;
    }

    dprintf( "Avail: 0x%I64x Used: 0x%I64x\n", AvailRuns, MaxUsed );
                          
    dprintf( "Lcns ranges sorted by length\n\n" );

    for (Index=0; Index < MaxUsed; Index++) {

        if (Index == WindowStart) {

            dprintf( "DeleteWindow: 0x%x to 0x%x\n", WindowStart, WindowEnd );

            Index = WindowEnd;

            if (DelWindowIndex < DelLengthCount) {

                WindowStart = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "StartIndex" );
                WindowEnd = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "EndIndex" );
                DelWindowIndex++;
            }
            continue;
        }

        ReadMemory( LengthArray + Index * sizeof( USHORT ), &LenIndex, sizeof( USHORT ), &BytesRead );

        if (NTFS_CACHED_RUNS_DEL_INDEX != LenIndex) {
            
            Lcn = ReadValue( LcnArray + LenIndex * (ClusterRunSize), SYM(NTFS_LCN_CLUSTER_RUN), "Lcn" );
            Length = ReadValue( LcnArray + LenIndex * (ClusterRunSize), SYM(NTFS_LCN_CLUSTER_RUN), "RunLength" );

            if (Length < PrevLength) {
                dprintf( "WARNING: OUT OF ORDER ENTRY\n" );
            }
            PrevLength = Length;

            dprintf( "0x%x: LcnIndex: 0x%x Lcn: 0x%I64x Length: 0x%I64x\n", Index, LenIndex, Lcn, Length );

        }

        if (CheckControlC()) {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 6, 0, EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\gentable.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#pragma hdrstop



ULONG64
KdParent (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlParent macro, but works in the kernel debugger.
    The description of RtlParent follows:

    The macro function Parent takes as input a pointer to a splay link in a
    tree and returns a pointer to the splay link of the parent of the input
    node.  If the input node is the root of the tree the return value is
    equal to the input value.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the  parent of the input
                       node.  If the input node is the root of the tree the
                       return value is equal to the input value.

--*/

{
    ULONG64 Parent = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "Parent",
                        Parent) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return Parent;
}



ULONG64
KdLeftChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlLeftChild macro, but works in the kernel debugger.
    The description of RtlLeftChild follows:

    The macro function LeftChild takes as input a pointer to a splay link in
    a tree and returns a pointer to the splay link of the left child of the
    input node.  If the left child does not exist, the return value is NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    ULONG64 - Pointer to the splay link of the left child of the input node.
                       If the left child does not exist, the return value is NULL.

--*/

{
    ULONG64 LeftChild = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "LeftChild",
                        LeftChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return LeftChild;
}



ULONG64
KdRightChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlRightChild macro, but works in the kernel debugger.
    The description of RtlRightChild follows:

    The macro function RightChild takes as input a pointer to a splay link
    in a tree and returns a pointer to the splay link of the right child of
    the input node.  If the right child does not exist, the return value is
    NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the right child of the input node.
                       If the right child does not exist, the return value is NULL.

--*/

{
    ULONG64 RightChild = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "RightChild",
                        RightChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return RightChild;
}



BOOLEAN
KdIsLeftChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsLeftChild macro, but works in the kernel debugger.
    The description of RtlIsLeftChild follows:

    The macro function IsLeftChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the left child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the left child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdLeftChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsRightChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsRightChild macro, but works in the kernel debugger.
    The description of RtlIsRightChild follows:

    The macro function IsRightChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the right child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the right child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdRightChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsGenericTableEmpty (
    IN ULONG64 Table
    )

/*++

Routine Description:

    Analogous to RtlIsGenericTableEmpty, but works in the kernel debugger.
    The description of RtlIsGenericTableEmpty follows:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{
    ULONG64 TableRoot = 0;

    if (GetFieldValue(Table, "RTL_AVL_TABLE", "TableRoot", TableRoot)) {
        return TRUE;
    }

    //
    // Table is empty if the root pointer is null.
    //

    return ((TableRoot)?(FALSE):(TRUE));

}



ULONG64
KdRealSuccessor (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlRealSuccessor, but works in the kernel debugger.
    The description of RtlRealSuccessor follows:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    ULONG64 Ptr = 0;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = KdRightChild(Links)) != 0) {

        while (KdLeftChild(Ptr) != 0) {
            Ptr = KdLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (KdIsRightChild(Ptr)) {
        Ptr = KdParent(Ptr);
    }

    if (KdIsLeftChild(Ptr)) {
        return KdParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return 0;

}



ULONG64
KdEnumerateGenericTableWithoutSplaying (
    IN ULONG64  pTable,
    IN PULONG64 RestartKey
    )

/*++

Routine Description:

    Analogous to RtlEnumerateGenericTableWithoutSplaying, but works in the
    kernel debugger.  The description of RtlEnumerateGenericTableWithoutSplaying
    follows:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    ULONG NumElements;
    ULONG64 TableRoot;


    if ( GetFieldValue(pTable,
                       "RTL_AVL_TABLE",
                       "NumberGenericTableElements",
                       NumElements) ) {
        dprintf( "%s: Unable to read pTable\n", FormatValue(pTable) );
        return 0;
    }

    if ( GetFieldValue(pTable,
                       "RTL_AVL_TABLE",
                       "BalancedRoot.RightChild",
                       TableRoot) ) {
        dprintf( "%s: Unable to read pTable root\n", FormatValue(pTable) );
        return 0;
    }

    if (!NumElements) {

        //
        // Nothing to do if the table is empty.
        //

        return 0;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        ULONG64 NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == 0) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = TableRoot;
                KdLeftChild(NodeToReturn);
                NodeToReturn = KdLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // KdRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = KdRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   (NodeToReturn+GetTypeSize("RTL_BALANCED_LINKS")/*+GetTypeSize("PVOID")*/)
                  :0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\ntfskdapi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NtfsKd.c

Abstract:

    KD Extension Api for examining Ntfs specific data structures

Author:

    Keith Kaplan [KeithKa]    24-Apr-96
    Portions by Jeff Havens

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

KDDEBUGGER_DATA64 KdDebuggerData;

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "NTFS Debugger Extensions:\n",
    "cachedrecords               Dump all threads with cached filerecord bcbs",
    "cachedruns [addr]           Dump the given cached run array ",
    "ccb        [addr]           Dump Cache Control Block",
    "fcb        [addr] [1|2|...] Dump File Control Block",
    "fcbtable   [addr] [1|2|...] Dump File Control Block Table",
    "file       [addr] [1|2|...] Dump File Object",
    "filerecord [addr]           Dump the on-disk file record if cached, addr can be a fileobj, fcb or scb",
    "foirp      [addr] [1|2|...] Dump File Object by IRP address",
    "hashtable  [addr]           Dump an lcb hashtable",
    "icthread   [addr] [1|2|...] Dump IrpContext by thread address",
    "irpcontext [addr] [1|2|...] Dump IrpContext structure",
    "lcb        [addr]           Dump Link Control Block",
    "mcb        [addr]           Dump Map Control Block",
    "ntfsdata          [1|2|...] Dump NtfsData structure",
    "ntfshelp                    Dump this display",
    "scb        [addr] [1|2|...] Dump Stream Control Block",
    "transaction [addr]          Dump the transaction attached to an irpcontext",
    "vcb        [addr] [0|1|2]   Dump Volume Control Block",
    0
};



VOID
ParseAndDump (
    IN PCHAR args,
    IN BOOL NoOptions,
    IN STRUCT_DUMP_ROUTINE DumpFunction,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:

    None

--*/

{
    CHAR StringStructToDump[1024];
    CHAR StringStructToDump2[1024];
    ULONG64 StructToDump = 0;
    ULONG64 StructToDump2 = 0;
    LONG Options;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump = 0;
    Options = 0;

    StringStructToDump[0] = '\0';

    if (*args) {
        if (NoOptions) {
            sscanf(args,"%s %s", StringStructToDump, StringStructToDump2 );
            if (!GetExpressionEx(args,&StructToDump, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump);
                return;
            }
            if (!GetExpressionEx(args,&StructToDump2, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump2);
                return;
            }
        } else {
            sscanf(args,"%s %lx", StringStructToDump, &Options );
            if (!GetExpressionEx(args,&StructToDump, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump);
                return;
            }
        }
    }

    (*DumpFunction) ( StructToDump, StructToDump2, Options, Processor, hCurrentThread );

    dprintf( "\n" );
}


VOID
PrintHelp (
    VOID
    )
/*++

Routine Description:

    Dump out one line of help for each DECLARE_API

Arguments:

    None

Return Value:

    None

--*/
{
    int i;

    for( i=0; Extensions[i]; i++ ) {
        dprintf( "   %s\n", Extensions[i] );
    }
}


DECLARE_API( ccb )

/*++

Routine Description:

    Dump ccb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( fcb )

/*++

Routine Description:

    Dump fcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( fcbtable )

/*++

Routine Description:

    Dump fcb table struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcbTable, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( file )

/*++

Routine Description:

    Dump FileObject struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileObject, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( filerecord )

/*++

Routine Description:

    Dump file record struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileRecord, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( foirp )

/*++

Routine Description:

    Dump FileObject struct, given an irp

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileObjectFromIrp, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( icthread )

/*++

Routine Description:

    Dump IrpContext struct, given a Thread

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpIrpContextFromThread, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( irpcontext )

/*++

Routine Description:

    Dump IrpContext

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpIrpContext, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( lcb )

/*++

Routine Description:

    Dump lcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpLcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( logfile )

/*++

Routine Description:

    Dump log file

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpLogFile, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( mcb )

/*++

Routine Description:

    Dump mcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpMcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( ntfsdata )

/*++

Routine Description:

    Dump the NtfsData struct

Arguments:

    arg - [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpNtfsData, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( ntfshelp )

/*++

Routine Description:

    Dump help message

Arguments:

    None

Return Value:

    None

--*/

{
    INIT_API();

    PrintHelp();
}


DECLARE_API( scb )

/*++

Routine Description:

    Dump Scb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpScb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( vcb )

/*++

Routine Description:

    Dump Vcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpVcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( dsc )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpSysCache, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( cachedrecords )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCachedRecords, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( extents )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpExtents, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( hashtable )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, TRUE, (STRUCT_DUMP_ROUTINE) DumpHashTable, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( dumpchain )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcbLcbChain, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( overflow )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpOverflow, (USHORT)dwProcessor, hCurrentThread );
}




DECLARE_API( cachedruns )

/*++

Routine Description:

    Dump the cached runs structure

Arguments:

    arg - [cached runs address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCachedRuns, (USHORT)dwProcessor, hCurrentThread );
}



DECLARE_API( transaction )

/*++

Routine Description:

    Dump the transaction associated with the given irpcontext

Arguments:

    arg - [irpcontext]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpTransaction, (USHORT)dwProcessor, hCurrentThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\gentable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/


PRTL_SPLAY_LINKS
KdParent (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdLeftChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdRightChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

BOOLEAN
KdIsLeftChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsRightChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );

PRTL_SPLAY_LINKS
KdRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    );

ULONG64
KdEnumerateGenericTableWithoutSplaying (
    IN ULONG64 pTable,
    IN ULONG64 *RestartKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfskd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE
#define RTL_USE_AVL_TABLES 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#include <memory.h>

#include <fsrtl.h>

#undef CREATE_NEW
#undef OPEN_EXISTING

#include <ntfsproc.h>

PSTR
FormatValue(
    ULONG64 addr
    );

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif //  DBG

//
//  We're 64 bit aware
//          

#define KDEXT_64BIT

#define KDEXT_64BIT
#include <wdbgexts.h>

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

typedef PVOID (*STRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN ULONG64 Address2,
    IN LONG Options,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );

#define DECLARE_DUMP_FUNCTION(s)                   \
    VOID                                           \
    s(                                             \
        IN ULONG64 Address,                        \
        IN ULONG64 Address2,                       \
        IN LONG Options,                           \
        IN USHORT Processor,                       \
        IN HANDLE hCurrentThread                   \
     )

#define INIT_DUMP()                                                     \
    UNREFERENCED_PARAMETER( Address );                                  \
    UNREFERENCED_PARAMETER( Address2 );                                 \
    UNREFERENCED_PARAMETER( Options );                                  \
    UNREFERENCED_PARAMETER( Processor );                                \
    UNREFERENCED_PARAMETER( hCurrentThread );

#define INIT_API()                                                      \
    UNREFERENCED_PARAMETER( hCurrentProcess );                          \
    UNREFERENCED_PARAMETER( hCurrentThread );                           \
    UNREFERENCED_PARAMETER( dwCurrentPc );                              \
    UNREFERENCED_PARAMETER( dwProcessor );                              \
    UNREFERENCED_PARAMETER( args );                                     \
    if (GetExpression( "NTFS!NtfsData" ) == 0) {                        \
        Ioctl( IG_RELOAD_SYMBOLS, "NTFS.SYS", 8 );                      \
    }                                                                   \
    if (KdDebuggerData.KernBase == 0) {                                 \
        KdDebuggerData.Header.OwnerTag = KDBG_TAG;                      \
        KdDebuggerData.Header.Size = sizeof(KdDebuggerData);            \
        if (!Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof(KdDebuggerData) )) {   \
            KdDebuggerData.KernBase = 1;                                \
        }                                                               \
    }

extern KDDEBUGGER_DATA64 KdDebuggerData;


#define SYM(s)  "NTFS!" #s
#define NT(s)   "NT!" #s


typedef struct _DUMP_ENUM_CONTEXT {
    ULONG Options;
    USHORT Processor;
    HANDLE hCurrentThread;
    ULONG64 ReturnValue;
} DUMP_ENUM_CONTEXT, *PDUMP_ENUM_CONTEXT;


//
// prototypes
//

DECLARE_DUMP_FUNCTION( DumpCachedRecords );
DECLARE_DUMP_FUNCTION( DumpCcb );
DECLARE_DUMP_FUNCTION( DumpExtents );
DECLARE_DUMP_FUNCTION( DumpFcb );
DECLARE_DUMP_FUNCTION( DumpFcbLcbChain );
DECLARE_DUMP_FUNCTION( DumpFcbTable );
DECLARE_DUMP_FUNCTION( DumpFileObject );
DECLARE_DUMP_FUNCTION( DumpFileObjectFromIrp );
DECLARE_DUMP_FUNCTION( DumpFileRecord );
DECLARE_DUMP_FUNCTION( DumpFileRecordContents );
DECLARE_DUMP_FUNCTION( DumpHashTable );
DECLARE_DUMP_FUNCTION( DumpIrpContext );
DECLARE_DUMP_FUNCTION( DumpIrpContextFromThread );
DECLARE_DUMP_FUNCTION( DumpLcb );
DECLARE_DUMP_FUNCTION( DumpLogFile );
DECLARE_DUMP_FUNCTION( DumpMcb );
DECLARE_DUMP_FUNCTION( DumpNtfsData );
DECLARE_DUMP_FUNCTION( DumpOverflow );
DECLARE_DUMP_FUNCTION( DumpScb );
DECLARE_DUMP_FUNCTION( DumpSysCache );
DECLARE_DUMP_FUNCTION( DumpVcb );
DECLARE_DUMP_FUNCTION( DumpCachedRuns );
DECLARE_DUMP_FUNCTION( DumpTransaction );

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\enumfile.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    enumfile.c

Abstract:

    This module contains tests for enumeration-by-fileref and bulk security test

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#include <ddeml.h>      // for CP_WINUNICODE

#include <objidl.h>

extern "C"
{
#include <propapi.h>
}

#include <stgprop.h>

#include <stgvar.hxx>
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

#define QuadAlign(P) (                \
    ((((ULONG)(P)) + 7) & 0xfffffff8) \
)


//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}


void
BulkSecurityTest (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    IO_STATUS_BLOCK Iosb;


    //
    //  Open the file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OPEN,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
        return;
    }

#define SECURITY_COUNT  10
    char InputBuffer[sizeof( BULK_SECURITY_TEST_DATA ) - sizeof( ULONG ) + SECURITY_COUNT * sizeof( ULONG )];
    PBULK_SECURITY_TEST_DATA SecurityData = (PBULK_SECURITY_TEST_DATA) InputBuffer;

    SecurityData->DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA;
    for (int i = 0; i < SECURITY_COUNT; i++) {
        SecurityData->SecurityIds[i] = 0xFF + i;
    }
    
    NTSTATUS Output[SECURITY_COUNT];

    Status = NtFsControlFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &Iosb,
        FSCTL_SECURITY_ID_CHECK,
        &InputBuffer,
        sizeof( InputBuffer ),
        Output,
        sizeof( Output ));

    printf( "Bulk test returned %x\n", Status );
    for (i = 0; i < SECURITY_COUNT; i++) {
        printf( " Status[%d] = %x\n", i, Output[i] );
    }

    NtClose( Handle );
}

void
EnumFile (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    char InputBuffer[10];
    char OutputBuffer[200];
    IO_STATUS_BLOCK Iosb;


    //
    //  Open the file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OPEN,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
        return;
    }

    //
    //  Set up input data
    //

    MFT_ENUM_DATA EnumData = { 1, 0, 1 };

    //
    //  Set up output buffer
    //
    
    BYTE Output[4096];

    while (TRUE) {
        
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_ENUM_USN_DATA,
            &EnumData,
            sizeof( EnumData ),
            Output,
            sizeof( Output ));

        if (!NT_SUCCESS( Status )) {
            printf( "NtfsControlFile returned %x\n", Status );
            break;
        }

        //
        //  Display output buffer
        //

        printf( "Length is %x\n", Iosb.Information );

        if (Iosb.Information < sizeof( ULONGLONG ) + sizeof( USN_RECORD )) {
            break;
        }

        printf( "Next file reference is %16I64x\n", *(PULONGLONG)Output );
        
        PUSN_RECORD UsnRecord = (PUSN_RECORD) (Output + sizeof( ULONGLONG ));

        while ((PBYTE)UsnRecord < Output + Iosb.Information) {
            printf( "FR %16I64x  Parent %016I64x  Usn %016I64x  SecurityId %08x  Reason %08x  Name(%d): '%.*ws'\n",
                   UsnRecord->FileReferenceNumber,
                   UsnRecord->ParentFileReferenceNumber,
                   UsnRecord->Usn,
                   UsnRecord->SecurityId,
                   UsnRecord->Reason,
                   UsnRecord->FileNameLength,
                   UsnRecord->FileNameLength / sizeof( WCHAR ),
                   UsnRecord->FileName );

            ULONG Length = sizeof( USN_RECORD ) + UsnRecord->FileNameLength - sizeof( WCHAR );
            Length = QuadAlign( Length );
            UsnRecord = (PUSN_RECORD) Add2Ptr( UsnRecord, Length );
        }

        EnumData.StartFileReferenceNumber = *(PLONGLONG)Output;
    }
    
    
    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

}




#define SHIFT(c,v)  ((c)--,(v)++)

int __cdecl
main (
    int argc,
    char **argv)
{
    SHIFT( argc, argv );
    
    if (argc > 0) {
        if (!strcmp( *argv, "-e")) {
    
            SHIFT( argc, argv );
            
            while (argc != 0) {
                EnumFile( *argv );
                SHIFT( argc, argv );
            }
        } else {
            BulkSecurityTest( *argv );
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\findfile.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    findfile.cxx

Abstract:

    This module contains tests for finding files by sid

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#define SID_MAX_LENGTH        \
    (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

__inline
VOID *
Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}

__inline
ULONG
QuadAlign( ULONG Value )
{
    return (Value + 7) & ~7;
}

//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    if (RelatedObject == NULL) {
        
        RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    } else {
        
        RtlInitUnicodeString(&str, pwszFile);

    }

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		RelatedObject,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

int __cdecl
main (
    int argc,
    char **argv)
{
    
    if (argc != 3) {
        printf( "Usage: findfile [user] [dir]\n" );
        return 1;
    }
    
    WCHAR FileName[MAX_PATH];
    SzToWsz( FileName, argv[2] );
    
    HANDLE Handle;
    NTSTATUS Status = OpenObject( FileName,
                                  NULL,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  FILE_READ_ATTRIBUTES,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  FILE_OPEN,
                                  &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "OpenObject returned %x\n", Status );
        return 1;
    }

    struct {
        ULONG Restart;
        BYTE Sid[SID_MAX_LENGTH];
    } FsCtlInput;
    
    ULONG SidLength = sizeof( FsCtlInput.Sid );
    CHAR Domain[MAX_PATH];
    ULONG DomainLength = sizeof( Domain );
    SID_NAME_USE SidNameUse;

    if (!LookupAccountName( NULL,
                            argv[1],
                            FsCtlInput.Sid, 
                            &SidLength,
                            Domain,
                            &DomainLength,
                            &SidNameUse )
        ) {

        printf( "LookupAccountName failed %x\n", GetLastError( ));
        return 1;
    }

    IO_STATUS_BLOCK Iosb;
    
    FsCtlInput.Restart = 1;
    
    BYTE Output[MAX_PATH + 10];
    
    while (TRUE) {
    
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_FIND_FILES_BY_SID,
            &FsCtlInput,
            sizeof( FsCtlInput ),
            NULL,
            sizeof( Output ));
        
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_FIND_FILES_BY_SID,
            &FsCtlInput,
            sizeof( FsCtlInput ),
            Output,
            sizeof( Output ));
        
        FsCtlInput.Restart = 0;
    
        if (!NT_SUCCESS( Status ) && Status != STATUS_BUFFER_OVERFLOW) {
            printf( "NtfsControlFile returned %x\n", Status );
            return 1;
        }
    
        //
        //  Display output buffer
        //
    
        printf( "Length is %x\n", Iosb.Information );
    
        if (Iosb.Information == 0) {
            break;
        }
    
        PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION) Output;
    
        while ((PBYTE)FileNameInfo < Output + Iosb.Information) {
            ULONG Length = 
                sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ) + 
                FileNameInfo->FileNameLength;

            printf( "%d: '%.*ws' ", 
                    FileNameInfo->FileNameLength,
                    FileNameInfo->FileNameLength / sizeof( WCHAR ),
                    FileNameInfo->FileName );

            HANDLE ChildHandle;
            WCHAR ChildFileName[ MAX_PATH ];
            
            RtlMoveMemory( ChildFileName, FileNameInfo->FileName, FileNameInfo->FileNameLength );
            ChildFileName[FileNameInfo->FileNameLength / sizeof( WCHAR )] = L'\0';
            Status = OpenObject( ChildFileName,
                                 Handle,
                                 FILE_SYNCHRONOUS_IO_NONALERT,
                                 FILE_READ_ATTRIBUTES,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 &ChildHandle );

            if (!NT_SUCCESS( Status )) {
                printf( "\nUnable to open child - %x\n", Status );
            } else {
                BYTE FileName[MAX_PATH+10];
                IO_STATUS_BLOCK Iosb2;

                Status = NtQueryInformationFile(
                    ChildHandle,
                    &Iosb2,
                    FileName,
                    sizeof( FileName ),
                    FileNameInformation );

                if (!NT_SUCCESS( Status )) {
                    printf( "\nNtQUeryInformationFile failed - %x\n", Status );
                } else {
                    PFILE_NAME_INFORMATION fn = (PFILE_NAME_INFORMATION) FileName;
                    printf( "%.*ws\n", fn->FileNameLength / sizeof( WCHAR ), fn->FileName );
                }

                NtClose( ChildHandle );
            }

            FileNameInfo = 
                (PFILE_NAME_INFORMATION) Add2Ptr( FileNameInfo, QuadAlign( Length ));
        }
    }
    
    
    //
    //  Close the file
    //
    
    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bkup.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    bkup.c - test backup read / write

Abstract:

    Driver for backup read/write

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <tchar.h>


//
//
//

#define SHIFTBYN(c,v,n) ((c) -= (n), (v) += (n))
#define SHIFT(c,v) SHIFTBYN( (c), (v), 1 )

void Usage( void )
{
    fprintf( stderr, "Usage:  bkup [-r file] performs backup read, output to stdout\n" );
    fprintf( stderr, "             [-w backupimage newfile] performs backup write\n" );
}

int __cdecl
main (
    int argc,
    char **argv
    )
{
    SHIFT( argc, argv );
    
    if (argc == 2 && !strcmp( *argv, "-r" )) {
        SHIFT( argc, argv );
        
        HANDLE h = CreateFile( *argv,               //  file name
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                                                    //  desired access
                               FILE_SHARE_READ,     //  share mode
                               NULL,                //  security
                               OPEN_EXISTING,       //  disposition
                               0,                   //  flags and attributes
                               0 );                 //  template file

        if (h == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile returned %x\n", GetLastError( ));
            return 1;
        }

        BYTE *p = new BYTE[65536];
        ULONG Length, Written;
        
        PVOID Context = NULL;
        
        while (TRUE) {
            if (!BackupRead( h, p, 65536, &Length, FALSE, TRUE, &Context )) {
                fprintf( stderr, "BackupRead returned %x\n", GetLastError( ));
                return 1;
            }
            
            if (Length == 0) {
                break;
            }
            
            fprintf( stderr, "Transferring %x\n", Length );
            if (!WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), p, Length, &Written, NULL ))
            {
                fprintf( stderr, "WriteFile returned %x\n", GetLastError( ));
                return 1;
            }
        }
    } else if (argc == 3 && !strcmp( *argv, "-w" )) {
        SHIFT( argc, argv );

        HANDLE hOld = CreateFile( *argv,            //  file name
                                  FILE_READ_DATA,   //  desired access
                                  FILE_SHARE_READ,  //  share mode
                                  NULL,             //  security
                                  OPEN_EXISTING,    //  disposition
                                  0,                //  flags and attributes
                                  0 );              //  template file

        if (hOld == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile destination returned %x\n", GetLastError( ));
            return 1;
        }

        SHIFT( argc, argv );
        
        HANDLE hNew = CreateFile( *argv,            //  file name
                                  FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES,
                                                    //  desired access
                                  FALSE,            //  share mode
                                  NULL,             //  security
                                  CREATE_ALWAYS,    //  disposition
                                  0,                //  flags and attributes
                                  0 );              //  template file

        if (hNew == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile destination returned %x\n", GetLastError( ));
            return 1;
        }

        BYTE *p = new BYTE[127];
        ULONG Length, Written;
        
        PVOID Context = NULL;
        
        while (TRUE) {
            if (!ReadFile( hOld, p, 127, &Length, NULL )) {
                fprintf( stderr, "ReadFile returned %x\n", GetLastError( ));
                return 1;
            }
            
            if (Length == 0) {
                break;
            }

            fprintf( stderr, "Transferring %x\n", Length );
            
            if (!BackupWrite( hNew, p, Length, &Written, FALSE, TRUE, &Context )) {
                fprintf( stderr, "BackupWrite returned %x\n", GetLastError( ));
                return 1;
            }
        }
    } else {
        Usage( );
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\opentest.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    proptest.c

Abstract:

    This module contains tests for Ntfs Property support.

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#include <ddeml.h>      // for CP_WINUNICODE

#include <objidl.h>

extern "C"
{
#include <propapi.h>
}

#include <stgprop.h>

#include <stgvar.hxx>
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>

#include <propvar.h>


//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

void
OpenTest (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    char InputBuffer[10];
    char OutputBuffer[200];
    IO_STATUS_BLOCK Iosb;


    //
    //  OPENTEST file count
    //
    
    //
    //  Create the new file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_CREATE,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
    }

    //
    //  Write a small amount of data
    //

    Status = NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, InputBuffer, 10, NULL, NULL );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to write %s - %x\n", FileName, Status );
    }
    
    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

    //
    //  Overwrite the file
    //

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OVERWRITE,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to overwrite %s - %x\n", FileName, Status );
    }

    //
    //  Write a small amount of data
    //

    Status = NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, InputBuffer, 10, NULL, NULL );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to write %s - %x\n", FileName, Status );
    }

    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

    //
    //  Delete the file
    //

    {    
        OBJECT_ATTRIBUTES oa;
        UNICODE_STRING str;
    
        RtlDosPathNameToNtPathName_U( WFileName, &str, NULL, NULL );
    
        InitializeObjectAttributes(
            &oa,
            &str,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);
    
        Status = NtDeleteFile( &oa );
    
        RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);

        if (!NT_SUCCESS( Status )) {
            printf( "Unable to delete %s - %x\n", FileName, Status );
        }
        
    }
}



int __cdecl
main (
    int argc,
    char **argv)
{
    DbgPrint( "--------------------------------------------\n" );
    while (--argc != 0) {
        OpenTest( *++argv );
    }
    DbgPrint( "--------------------------------------------\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\rentest.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    rentest.c

Abstract:

    This module contains tests for stream rename support

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#define DEFAULT_DATA_STREAM "::$DATA"

//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    if (RelatedObject == NULL) {
        
        RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    } else {
        
        RtlInitUnicodeString(&str, pwszFile);

    }

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		RelatedObject,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

typedef enum {
    NoTarget,
    EmptyTarget,
    NonZeroTarget
} TARGET_STATUS;

typedef enum {
    EmptySource,
    SmallSource,
    BigSource
} SOURCE_STATUS;

void
StickDataIn (
    HANDLE Handle,
    char *SomeData,
    SOURCE_STATUS SourceStatus
    )
{
    if (SourceStatus == EmptySource) {
    
    } else if (SourceStatus == SmallSource) {
        IO_STATUS_BLOCK Iosb;
        
        NTSTATUS Status = 
            NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, SomeData, strlen( SomeData ), NULL, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "Unable to stick data in - %x\n", Status );
        }
    
        NtFlushBuffersFile( Handle, &Iosb );
    
    } else if (SourceStatus == BigSource) {
        IO_STATUS_BLOCK Iosb;
        LARGE_INTEGER Offset;

        Offset.QuadPart = 1024 * 1024;
        
        NTSTATUS Status = 
            NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, SomeData, strlen( SomeData ), &Offset, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "Unable to stick data in - %x\n", Status );
        }
        
        NtFlushBuffersFile( Handle, &Iosb );
    }
    
}

void
CheckData (
    HANDLE Handle,
    char *Data,
    SOURCE_STATUS SourceStatus,
    int Line
    )
{
    if (SourceStatus == EmptySource) {
        //
        //  Verify that the source is zero bytes long
        //
    
    } else if (SourceStatus == SmallSource) {
        IO_STATUS_BLOCK Iosb;
        char *FileData = new char[ strlen( Data )];
        
        NTSTATUS Status = 
            NtReadFile( Handle, NULL, NULL, NULL, &Iosb, FileData, strlen( Data ), NULL, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "line %d Unable to read data  - %x\n", Line, Status );
        }

        if (memcmp( Data, FileData, strlen( Data ))) {
            printf( "line %d small data is different\n", Line );
            printf( "File: '%.*s'  Test: '%s'\n", strlen( Data ), FileData, Data );
        }
    
        delete [] FileData;

    } else if (SourceStatus == BigSource) {
        IO_STATUS_BLOCK Iosb;
        char *FileData = new char[ strlen( Data )];
        LARGE_INTEGER Offset;

        Offset.QuadPart = 1024 * 1024;
        
        NTSTATUS Status = 
            NtReadFile( Handle, NULL, NULL, NULL, &Iosb, FileData, strlen( Data ), &Offset, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "line %d Unable to read data in - %x\n", Line, Status );
        }

        if (memcmp( Data, FileData, strlen( Data ))) {
            printf( "line %d large data is different\n", Line );
            printf( "File: '%.*s'  Test: '%s'\n", strlen( Data ), FileData, Data );
        }
    
        delete [] FileData;
    }
}

#define TESTONE                                                 \
        printf( "TestOne( %s, %s, %x, %x, %x, Line %d ): ",     \
                SourceStream, TargetStream,                     \
                TargetStatus, ReplaceIfExists, ExpectedStatus,  \
                Line )

#define CLOSE(h)    {                                   \
    NTSTATUS TmpStatus = NtClose(h);                    \
    h = INVALID_HANDLE_VALUE;                           \
    if (!NT_SUCCESS( TmpStatus )) {                     \
        TESTONE; printf( "Couldn't close handle @ %d\n", __LINE__ );   \
    }                                                   \
}

//
//  Open a handle relative to the parent of the Source stream.
//  

void
TestOne (
    char *FileName,
    char *SourceStream,
    SOURCE_STATUS SourceStatus,
    char *TargetStream,
    TARGET_STATUS TargetStatus,
    BOOLEAN ReplaceIfExists,
    NTSTATUS ExpectedStatus,
    int Line
    )
{
    NTSTATUS Status;
    WCHAR UnicodeFullSourceStreamName[MAX_PATH];
    WCHAR UnicodeFullTargetStreamName[MAX_PATH];
    WCHAR UnicodeTargetStreamName[MAX_PATH];
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    
    //
    //  Convert names to unicode and form complete source name
    //

    SzToWsz( UnicodeFullSourceStreamName, FileName );
    SzToWsz( UnicodeFullSourceStreamName + wcslen( UnicodeFullSourceStreamName ), SourceStream );
    SzToWsz( UnicodeTargetStreamName, TargetStream );
    SzToWsz( UnicodeFullTargetStreamName, FileName );
    SzToWsz( UnicodeFullTargetStreamName + wcslen( UnicodeFullTargetStreamName ), TargetStream );
    
    //
    //  Create/open source stream 
    //

    Status = OpenObject( UnicodeFullSourceStreamName,
                         NULL,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA | DELETE,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         &SourceHandle );

    if (!NT_SUCCESS( Status )) {
        TESTONE; printf( "unable to open source stream - %x\n", Status );
    }

    //
    //  Stick data into source
    //

    StickDataIn( SourceHandle, SourceStream, SourceStatus );

    //
    //  If target is not supposed to exist
    //

    if (TargetStatus == NoTarget) {
        
        //
        //  Create/Open target stream with delete-on-close
        //

        Status = OpenObject( UnicodeFullTargetStreamName,              
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE,
                             FILE_READ_DATA | FILE_WRITE_DATA | DELETE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             &TargetHandle );
        
        //
        //  Close target stream (do the delete)
        //

        if (NT_SUCCESS( Status )) {
            CLOSE( TargetHandle );
        } else {
            TESTONE; printf( "Unable to set NoTarget on %s - %x\n", TargetStream, Status );
        }
    
    } else {
        
        //
        //  Create/open target stream
        //
        
        Status = OpenObject( UnicodeFullTargetStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             &TargetHandle );
        if (!NT_SUCCESS( Status )) {
            TESTONE; printf( "unable to open target for sizing %x\n", Status );
        }

        FILE_END_OF_FILE_INFORMATION EndOfFile;
        EndOfFile.EndOfFile.QuadPart = 0i64;
        
        IO_STATUS_BLOCK Iosb;
        Status = NtSetInformationFile( TargetHandle,
                                       &Iosb,
                                       &EndOfFile,
                                       sizeof( EndOfFile ),
                                       FileEndOfFileInformation );

        
        //
        //  If target has data in it
        //
        
        if (TargetStatus == NonZeroTarget) {
            
            //
            //  Stick data into target
            //

            StickDataIn( TargetHandle, TargetStream, SmallSource );

        }

        //
        //  Close target
        //

        CLOSE( TargetHandle );

    }

    //
    //  Set up FileRenameInformation
    //
    
    char buffer[sizeof( FILE_RENAME_INFORMATION ) + MAX_PATH * sizeof( WCHAR )];
    PFILE_RENAME_INFORMATION FileRenameInformationBlock = (PFILE_RENAME_INFORMATION) buffer;

    FileRenameInformationBlock->ReplaceIfExists = ReplaceIfExists;
    FileRenameInformationBlock->RootDirectory = NULL;
    FileRenameInformationBlock->FileNameLength = strlen( TargetStream ) * sizeof( WCHAR );
    SzToWsz( FileRenameInformationBlock->FileName, TargetStream );
    
    //
    //  Attempt to rename
    //

    IO_STATUS_BLOCK Iosb;
    Status = NtSetInformationFile( SourceHandle,
                                   &Iosb,
                                   FileRenameInformationBlock,
                                   sizeof( buffer ),
                                   FileRenameInformation );

    //
    //  Check output status codes
    //

    if (Status != ExpectedStatus) {
        TESTONE; printf( "status was %x\n", Status );
    }
    
    //
    //  Close Source stream
    //

    CLOSE( SourceHandle );
    
    //
    //  If we succeeded in tehe rename
    //

    if (NT_SUCCESS( Status )) {
        //
        //  Verify that the source stream no longer exists
        //
    
        Status = OpenObject( UnicodeFullSourceStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             &SourceHandle );
    
        //
        //  Verify that the source does/doesn't exist as appropriate
        //
    
        if (NT_SUCCESS( Status )) {
            
            if (!strcmp( SourceStream, DEFAULT_DATA_STREAM )) {
                //  Default data stream still exists.  No problem
            } else {
                TESTONE; printf( "source stream still exists\n" );
            }
            
            CLOSE( SourceHandle );
    
        } else if (!strcmp( SourceStream, DEFAULT_DATA_STREAM )) {
            TESTONE; printf( "failed to open default data stream - %x\n", Status );
        } else {
            //  failed to open previous source stream.  No problem
        }

        //
        //  Reopen the target stream (formerly source stream)
        //
        
        Status = OpenObject( UnicodeFullTargetStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             &TargetHandle );

        if (!NT_SUCCESS( Status )) {
            TESTONE; printf( "unable to open target for verification %x\n", Status );
        }

        //
        //  Verify the contents
        //

        CheckData( TargetHandle, SourceStream, SourceStatus, Line );

        CLOSE( TargetHandle );
    }
}


void
RenameTest (
    char *FileName
    )
{
    //  Test:
    //      ::$Data to :New             Succeed
    //      ::$Data to :NonZero         Fail always
    //      ::$Data to :Empty           Succeed if ReplaceIfExists
    //      :Test to ::$Data <empty>    Succeed if ReplaceIfExists
    //      :Test to ::$Data <nonzero>  Fail always
    //
    //      XXX:Test to YYY:Test        Fail always
    //

    //      ::$Data to :New             Succeed
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    
    //      ::$Data to :NonZero         Fail always
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    
    //      ::$Data to :Empty           Succeed if ReplaceIfExists
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );

    //      :Test to ::$Data <empty>    Succeed if ReplaceIfExists
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    
    //      :Test to ::$Data <nonzero>  Fail always
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );

    //      :Test to :New               Succeed
    TestOne( FileName, ":Test",             EmptySource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );

    //      :Test to :NonZero           Fail always
    TestOne( FileName, ":Test",             EmptySource, ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    
    //      :Test to :Empty             Succeed if ReplaceIfExists
    TestOne( FileName, ":Test",             EmptySource, ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    
}



int __cdecl
main (
    int argc,
    char **argv)
{
    DbgPrint( "--------------------------------------------\n" );
    while (--argc != 0) {
        RenameTest( *++argv );
    }
    DbgPrint( "--------------------------------------------\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\quota.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>

#define QuadAlign(n) (((n) + (sizeof(LONGLONG) - 1)) & ~(sizeof(LONGLONG) - 1))
#define DwordAlign(n)(((n) + (sizeof(ULONG) - 1)) & ~(sizeof(ULONG) - 1))

#define STRUCT_COUNT(n, type, name_length)                                         \
        ((((n) * QuadAlign(sizeof(type)) + ((name_length) * sizeof(WCHAR))) + \
          sizeof(type) - 1) /                                             \
         sizeof(type))

#define SID_MAX_LENGTH        \
    (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

#define DISK_EVENT_MODULE "System"

#define IO_FILE_QUOTA_THRESHOLD          ((NTSTATUS)0x40040024L)
#define IO_FILE_QUOTA_LIMIT              ((NTSTATUS)0x80040025L)

VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION pfqi,
    IN PCHAR SeverName
    );

CHAR *
FileTimeToString(
    FILETIME *pft
    );

VOID
PrintError(
    ULONG ErrorCode
    );

VOID
Usage();

BOOLEAN QuickSid;

VOID
STDMETHODVCALLTYPE
main(
    int Argc,
    char *Argv[]
    )

{
    HANDLE FileHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ANSI_STRING DiskName;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG BufferSize;
    ULONG SidListLength;
    LONG i;
    PWCHAR Wstr;
    PEVENTLOGRECORD EventLogRecord;
    FILE_QUOTA_INFORMATION QuotaInfo[STRUCT_COUNT(10, FILE_QUOTA_INFORMATION, 4)];
    FILE_QUOTA_INFORMATION TempQuotaInfo[STRUCT_COUNT(1, FILE_QUOTA_INFORMATION, 32)];
    FILE_GET_QUOTA_INFORMATION SidList[STRUCT_COUNT(10, FILE_GET_QUOTA_INFORMATION, 4)];
    PFILE_GET_QUOTA_INFORMATION SidListPtr;
    PFILE_QUOTA_INFORMATION QuotaInfoPtr;
    FILE_FS_CONTROL_INFORMATION ControlInfo;
    FILE_FS_CONTROL_INFORMATION TempControlInfo;
    PCHAR ServerName = NULL;
    SID_NAME_USE SidNameUse;
    LARGE_INTEGER TempLargeInt;
    ULONG ErrorCode;
    ULONG DomainLength;
    CHAR Domain[100];
    PCHAR TempPtr;
    BOOLEAN UserGiven = 0;
    BOOLEAN DriveLetter = 0;
    BOOLEAN EventLog = 0;
    BOOLEAN SettingDefault = 0;
    BOOLEAN DefaultGiven = 0;
    BOOLEAN DeletingUser = 0;

    struct {
        UCHAR DefaultLimit : 1;
        UCHAR DefaultThreshold : 1;
        UCHAR Flags : 1;
    } DefaultFlags = { 0, 0, 0 };

    if (Argc < 2) {
        printf ( "Processor feature is %d\n", IsProcessorFeaturePresent(0));
        Usage();
        exit(1);
    }

    RtlZeroMemory(&QuotaInfo, sizeof(QuotaInfo));
    QuotaInfoPtr = QuotaInfo;
    RtlZeroMemory(&SidList, sizeof(SidList));
    SidListPtr = SidList;

    RtlInitString( &DiskName, "\\DosDevices\\d:\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION" );
    RtlAnsiStringToUnicodeString( &NameString, &DiskName, TRUE );

    // Look for the d and repleace it with the requested Argument.

    for (Wstr = NameString.Buffer; *Wstr != L'd'; Wstr++);

    for (i = 1; i < Argc; i++) {

        if (*Argv[i] != '-') {

            if (DriveLetter || !isalpha(*Argv[i])) {
                Usage();
                exit(1);
            }

            TempPtr =  Argv[i];
            *Wstr = RtlAnsiCharToUnicodeChar( &TempPtr );
            DriveLetter++;
            continue;
        }

        switch (Argv[i][1]) {
        case 'd':

            DefaultGiven = 1;
            SettingDefault = 1;
            break;

        case 'e':

            if (EventLog) {
                Usage();
                exit(1);
            }

            if (Argv[i][2] == '\0') {
                i++;
                if (i < Argc && Argv[i][0] == '\\') {
                    ServerName = Argv[i];
                }

            } else {

                ServerName = &Argv[i][2];
            }

            EventLog++;
            break;

        case 'u':

            QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) ((PCHAR) QuotaInfoPtr +
                                QuotaInfoPtr->NextEntryOffset);

            SidListPtr = (PFILE_GET_QUOTA_INFORMATION) ((PCHAR) SidListPtr +
                                SidListPtr->NextEntryOffset);

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing user name\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            QuotaInfoPtr->SidLength = SID_MAX_LENGTH;
            DomainLength = sizeof(Domain);

            if (!LookupAccountName( NULL,
                                    TempPtr,
                                    &QuotaInfoPtr->Sid,
                                    &QuotaInfoPtr->SidLength,
                                    Domain,
                                    &DomainLength,
                                    &SidNameUse)) {

                printf("%s: Bad acccount name %s. Error = %d\n",
                       Argv[0],
                       TempPtr,
                       ErrorCode = GetLastError());

                PrintError( ErrorCode );
                exit(1);
            }

            //
            // Initialize the values to something resonable.
            //

            QuotaInfoPtr->QuotaThreshold.QuadPart = ~0I64;
            QuotaInfoPtr->QuotaLimit.QuadPart = ~0I64;

            QuotaInfoPtr->SidLength = RtlLengthSid( &QuotaInfoPtr->Sid);

            QuotaInfoPtr->NextEntryOffset =
                            FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) +
                            QuadAlign(QuotaInfoPtr->SidLength);

            memcpy( &SidListPtr->Sid, &QuotaInfoPtr->Sid, QuotaInfoPtr->SidLength);
            SidListPtr->SidLength = QuotaInfoPtr->SidLength;

            SidListPtr->NextEntryOffset =
                            FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) +
                            QuadAlign(SidListPtr->SidLength);


            SettingDefault = 0;
            UserGiven++;
            break;

        case 't':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing Argument\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }


            if (!sscanf( TempPtr, "%I64i", &TempLargeInt)) {
                printf("%s: Missing threshold value\n", Argv[0] );
                exit(1);
            }

            if (SettingDefault) {
                ControlInfo.DefaultQuotaThreshold = TempLargeInt;
                DefaultFlags.DefaultThreshold = TRUE;

            } else {
                QuotaInfoPtr->QuotaThreshold = TempLargeInt;
            }

            break;

        case 'l':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing limit value\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            if (!sscanf( TempPtr, "%I64i", &TempLargeInt)) {
                printf("%s: Missing value\n", Argv[0] );
                exit(1);
            }

            if (SettingDefault) {
                ControlInfo.DefaultQuotaLimit = TempLargeInt;
                DefaultFlags.DefaultLimit = TRUE;

            } else {
                QuotaInfoPtr->QuotaLimit = TempLargeInt;

                if (TempLargeInt.QuadPart == -2i64) {
                    DeletingUser = TRUE;
                }
            }

            break;

        case 'q':
            QuickSid++;
            break;

        case 'f':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing flag setting\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            switch (*TempPtr) {
            case 'e':
                ControlInfo.FileSystemControlFlags |= FILE_VC_QUOTA_ENFORCE;
                break;

            case 't':
                ControlInfo.FileSystemControlFlags |= FILE_VC_QUOTA_TRACK;
                break;

            case 'd':
                ControlInfo.FileSystemControlFlags &= ~(FILE_VC_QUOTA_MASK |
                                                        FILE_VC_LOG_QUOTA_LIMIT |
                                                        FILE_VC_LOG_QUOTA_THRESHOLD);
                break;

            default:

                printf("%s: Invalid or missing flag setting.\n", Argv[0] );
                Usage();
                exit(1);
            }

            while (*++TempPtr != '\0') {
                switch (*TempPtr) {
                case 'l':
                    ControlInfo.FileSystemControlFlags |= FILE_VC_LOG_QUOTA_LIMIT;
                    break;
                case 't':
                    ControlInfo.FileSystemControlFlags |= FILE_VC_LOG_QUOTA_THRESHOLD;
                    break;
                default:

                    printf("%s: Invalid flag setting.\n", Argv[0] );
                    Usage();
                    exit(1);

                }

            }

            DefaultGiven = 1;
            DefaultFlags.Flags = TRUE;
            break;

        default:
            printf("%s: Invalid or missing flag setting.\n", Argv[0] );

        case '?':
            Usage();
            exit(1);
            break;

        }
    }

    if (DriveLetter == 0  && EventLog == 0 ) {
        printf("%s: Missing drive-letter\n", Argv[0] );
    }

    if (EventLog &&
        (DriveLetter || UserGiven)) {
        Usage();
        exit(1);
    }

    if (EventLog) {

        //
        //  Open the event log and read andy events.
        //

        FileHandle = OpenEventLog( ServerName, DISK_EVENT_MODULE );

        if (FileHandle == NULL) {
                printf("%s: Event log open failed. %s. Error = %d\n",
                       Argv[0],
                       ServerName == NULL ? "Local machine" : ServerName,
                       ErrorCode = GetLastError());

                PrintError( ErrorCode );
                exit(1);
        }

        while (ReadEventLog( FileHandle,
                             EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                             0,
                             QuotaInfo,
                             sizeof(QuotaInfo),
                             &BufferSize,
                             &i )) {

            if (BufferSize == 0) {
                break;
            }

            for (EventLogRecord = (PEVENTLOGRECORD) QuotaInfo;
                 (PCHAR) EventLogRecord  < (PCHAR) QuotaInfo + BufferSize;
                 EventLogRecord = (PEVENTLOGRECORD)((PCHAR) EventLogRecord +
                                            EventLogRecord->Length)) {

                if (EventLogRecord->EventID == IO_FILE_QUOTA_THRESHOLD) {
                    printf( "Quota threshold event at: %s",
                            ctime( &EventLogRecord->TimeGenerated ));
                } else if (EventLogRecord->EventID == IO_FILE_QUOTA_LIMIT) {
                    printf( "Quota limit event at: %s",
                            ctime( &EventLogRecord->TimeGenerated ));
                } else {
                    continue;
                }

                //
                //  Look for the device name. It is the second string.
                //

                TempPtr = ((PCHAR) EventLogRecord +
                          EventLogRecord->StringOffset);

                printf( "    on device %s\n", TempPtr );

                TempPtr = ((PCHAR) EventLogRecord +
                          EventLogRecord->DataOffset +
                          FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData ));

                //
                //  Need to align the buffer.
                //

                RtlCopyMemory( TempQuotaInfo,
                               TempPtr,
                               EventLogRecord->DataLength -
                               FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData ));

                DumpQuota( TempQuotaInfo, ServerName );
            }
        }

        ErrorCode = GetLastError();

        if (ErrorCode =! ERROR_HANDLE_EOF) {
            printf("%s: Event log read failed. Error = %d\n",
                   Argv[0],
                   ErrorCode);

            PrintError( ErrorCode );
        }

        CloseEventLog( FileHandle );

        exit(0);
    }

    //
    // Terminate the list.
    //

    BufferSize = (PCHAR) QuotaInfoPtr - (PCHAR) QuotaInfo +
            QuotaInfoPtr->NextEntryOffset;
    QuotaInfoPtr->NextEntryOffset = 0;

    SidListLength = (PCHAR) SidListPtr - (PCHAR) SidList +
            SidListPtr->NextEntryOffset;
    SidListPtr->NextEntryOffset = 0;

    SidListPtr = SidList;


    InitializeObjectAttributes( &ObjectAttributes,
                                  &NameString,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL );

    Status = NtOpenFile( &FileHandle,
                         FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (!NT_SUCCESS( Status )) {
        printf( "Error opening input file %S; error was: %lx\n", NameString.Buffer, Status );
        PrintError( Status );
        exit(1);
    }


    if (DefaultGiven) {

        Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               &TempControlInfo,
                                               sizeof( FILE_FS_CONTROL_INFORMATION ),
                                               FileFsControlInformation );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtQueryVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

        if (DefaultFlags.Flags) {
            TempControlInfo.FileSystemControlFlags &= ~FILE_VC_QUOTA_MASK;
            TempControlInfo.FileSystemControlFlags |=
                ControlInfo.FileSystemControlFlags;
        }

        if (DefaultFlags.DefaultLimit) {
            TempControlInfo.DefaultQuotaLimit = ControlInfo.DefaultQuotaLimit;
        }

        if (DefaultFlags.DefaultThreshold) {
            TempControlInfo.DefaultQuotaThreshold = ControlInfo.DefaultQuotaThreshold;
        }

        Status = NtSetVolumeInformationFile( FileHandle,
                                           &IoStatus,
                                           &TempControlInfo,
                                           sizeof( FILE_FS_CONTROL_INFORMATION ),
                                           FileFsControlInformation );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtSetVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }
    }

    Status = NtQueryVolumeInformationFile( FileHandle,
                                           &IoStatus,
                                           &TempControlInfo,
                                           sizeof( FILE_FS_CONTROL_INFORMATION ),
                                           FileFsControlInformation );

    printf( "FileSystemControlFlags = %8lx\n", TempControlInfo.FileSystemControlFlags);
    if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) ==
        FILE_VC_QUOTA_NONE) {

        TempPtr = "Quotas are disabled on this volume";
    } else if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) ==
        FILE_VC_QUOTA_TRACK) {

        TempPtr = "Quota tracking is enabled on this volume";

    }else if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_ENFORCE) {

        TempPtr = "Quota tracking and enforment is enabled on this volume";

    }

    printf("%s.\n", TempPtr);

    switch (TempControlInfo.FileSystemControlFlags &
            (FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD)) {
    case FILE_VC_LOG_QUOTA_LIMIT:
        printf("Logging enable for quota limits.\n");
        break;
    case FILE_VC_LOG_QUOTA_THRESHOLD:
        printf("Logging enable for quota thresholds.\n");
        break;
    case FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD:
        printf("Logging enable for quota limits and threshold.\n");
        break;
    case 0:
        printf("Logging for quota events is not enabled.\n");
        break;
    }

    if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) {
        if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTAS_INCOMPLETE) {
            TempPtr = "The quota values are incomplete.\n";
        } else
        {
            TempPtr = "The quota values are up to date.\n";
        }

        printf(TempPtr);
    }

    printf("Default Quota Threshold = %16I64x\n", TempControlInfo.DefaultQuotaThreshold.QuadPart);
    printf("Default Quota Limit     = %16I64x\n\n", TempControlInfo.DefaultQuotaLimit.QuadPart);

    if (UserGiven) {

        Status = NtSetQuotaInformationFile( FileHandle,
                                           &IoStatus,
                                           QuotaInfo,
                                           BufferSize );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtSetVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

    }

    if (!UserGiven || DeletingUser) {
        SidListPtr = NULL;
        SidListLength = 0;
    }

    do {

        Status = NtQueryQuotaInformationFile( FileHandle,
                                              &IoStatus,
                                              QuotaInfo,
                                              sizeof(QuotaInfo),
                                              FALSE,
                                              SidListPtr,
                                              SidListLength,
                                              NULL,
                                              FALSE );

        if (!NT_SUCCESS( Status ) && Status != STATUS_NO_MORE_ENTRIES) {
            printf( "Error NtQueryVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

        QuotaInfoPtr = QuotaInfo;

        while (TRUE) {

            DumpQuota( QuotaInfoPtr, ServerName );

            if (QuotaInfoPtr->NextEntryOffset == 0) {
                break;
            }

            QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) ((PCHAR) QuotaInfoPtr +
                            QuotaInfoPtr->NextEntryOffset);

        }
    } while ( Status != STATUS_NO_MORE_ENTRIES );

    NtClose( FileHandle );
}

VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN PCHAR ServerName
    )
{
    SID_NAME_USE SidNameUse;
    ULONG AccountLength, DomainLength;
    ULONG ErrorCode;
    char AccountName[128];
    char DomainName[128];
    UNICODE_STRING String;
    NTSTATUS Status;

    AccountLength = sizeof(AccountName) - 1;
    DomainLength = sizeof(DomainName) - 1;

    if (FileQuotaInfo->SidLength == 0) {

        printf( "Default quota values \n" );

    } else if (QuickSid) {

        String.Buffer = (PWCHAR) AccountName;
        String.MaximumLength = sizeof( AccountName );
        String.Length = 0;

        Status = RtlConvertSidToUnicodeString( &String,
                                               &FileQuotaInfo->Sid,
                                               FALSE );

        if (!NT_SUCCESS(Status)) {
            printf("DumpQuota: RtlConvertSidToUnicodeString failed. Error = %d\n",
               Status);
            PrintError( Status );
        } else {
            printf( "SID Value       = %S\n", String.Buffer );
        }

    } else if (LookupAccountSidA(
            ServerName,
            &FileQuotaInfo->Sid,
            AccountName,
            &AccountLength,
            DomainName,
            &DomainLength,
            &SidNameUse))
    {
        char *String;

        AccountName[AccountLength] = '\0';
        DomainName[DomainLength] = '\0';
        switch (SidNameUse)
        {
            case SidTypeUser:           String = "User"; break;
            case SidTypeGroup:          String = "Group"; break;
            case SidTypeDomain:         String = "Domain"; break;
            case SidTypeAlias:          String = "Alias"; break;
            case SidTypeWellKnownGroup: String = "WellKnownGroup"; break;
            case SidTypeDeletedAccount: String = "DeletedAccount"; break;
            case SidTypeInvalid:        String = "Invalid"; break;
            default:                    String = "Unknown"; break;
        }
        printf(
            "SID Name        = %s\\%s (%s)\n",
            DomainName,
            AccountName,
            String);

    } else {

        printf("DumpQuota: Bad acccount SID. Error = %d\n",
               ErrorCode = GetLastError());
        PrintError( ErrorCode );

    }

    printf("Change time     = %s\n", FileTimeToString((PFILETIME) &FileQuotaInfo->ChangeTime));
    printf("Quota Used      = %16I64x\n", FileQuotaInfo->QuotaUsed.QuadPart);
    printf("Quota Threshold = %16I64x\n", FileQuotaInfo->QuotaThreshold.QuadPart);
    printf("Quota Limit     = %16I64x\n\n", FileQuotaInfo->QuotaLimit.QuadPart);

}

char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

CHAR *
FileTimeToString(FILETIME *FileTime)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;
    static char Buffer[32];

    Buffer[0] = '\0';
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return("Time???");
        }
        sprintf(
            Buffer,
            "%s %s %2d %2d:%02d:%02d %4d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wYear);
    }
    return(Buffer);
}

VOID
PrintError(ULONG ErrorCode)
{
    UCHAR ErrorBuffer[80];
    ULONG Count;
    HMODULE FileHandle = NULL;
    ULONG Flags = FORMAT_MESSAGE_FROM_SYSTEM;

    if (ErrorCode > MAXLONG) {
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        FileHandle = LoadLibrary( "ntdll" );
        if (FileHandle == NULL) {
            ULONG ErrorCode;

            printf("PrintError: LoadLibrary filed. Error = %d\n",
                   ErrorCode = GetLastError());

            PrintError( ErrorCode );
        }

    }

    Count = FormatMessage(Flags,
                  FileHandle,
                  ErrorCode,
                  0,
                  ErrorBuffer,
                  sizeof(ErrorBuffer),
                  NULL
                  );

    if (Count != 0) {
        printf("Error was: %s\n", ErrorBuffer);
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }

    if (FileHandle != NULL) {
        FreeLibrary( FileHandle );
    }
}

VOID
Usage()
{
    printf( "Usage: %s -e [\\ServerName] | drive-letter  [-q ] [ -f e|t|d [lt] ] [-d | -u account-name -t Threshold -l Limit] \n", __argv[0] );
    printf( "    -e [\\ServerName] Print quota events from specified server default is local.\n");
    printf( "    [-q] Quick print Sids. \n");
    printf( "    [-f e|t|d[lt] ] Set volume quota flags (For example -f elt ): \n");
    printf( "        [e]nforce quota limits.\n" );
    printf( "        [t]rack quota usage.\n" );
    printf( "        [d]isable quotas.\n" );
    printf( "        [l]imit events should be logged.\n" );
    printf( "        [t]threhold events should be logged.\n" );
    printf( "    [-d] Set default user quota values.\n");
    printf( "    [-u AccountName] Set quota values for user. \n");
    printf( "    [-l Limit] Set 64-Bit limit value preivously specified user. \n");
    printf( "        A limit of -2 indicates a defunct user can be removed. \n");
    printf( "    [-t Threshold] Set 64-Bit threshold value preivously specified user. \n\n");
    printf( "    Example:\n    %s d -f elt -d -t 4194304 -l 5242880 -u administrators -l 0xffffffffffffffff -t 0xffffffffffffffff\n",  __argv[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\analyze\analyze.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       analyze.cxx
//
//  Contents:   program to analyze the lock order table
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    3-16-2000   benl   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#define _NTFS_NTFSDBG_DEFINITIONS_
#include "lockorder.h"

typedef struct {
    LIST_ENTRY Links;
    NTFS_RESOURCE_NAME Resource;
} RESOURCE_LIST, *PRESOURCE_LIST;

typedef struct {
    NTFS_RESOURCE_NAME Resource;
    LIST_ENTRY Links;
    NTFS_OWNERSHIP_STATE EndState;
} RESOURCE_STATE_LIST, *PRESOURCE_STATE_LIST;

//
//  structure used to track the order a state is reached by
//  

typedef struct {
    NTFS_OWNERSHIP_STATE State;
    BOOLEAN ReachedByRelease;
    LIST_ENTRY Links;          //  RESOURCE_LIST
} RESOURCE_STATE_ORDER, *PRESOURCE_STATE_ORDER;


//+---------------------------------------------------------------------------
//
//  Function:   CompareRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]  -- 
//              [First]  -- 
//              [Second] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

RTL_GENERIC_COMPARE_RESULTS CompareRoutine( struct _RTL_GENERIC_TABLE *Table, PVOID First, PVOID Second )
{
    PULONG FirstUlong = (PULONG)First;
    PULONG SecondUlong = (PULONG)Second;

    if (*FirstUlong == *SecondUlong) {
        return GenericEqual;
    } else if (*FirstUlong < *SecondUlong) {
        return GenericLessThan;
    } else {
        return GenericGreaterThan;
    }
} // CompareRoutine


//+---------------------------------------------------------------------------
//
//  Function:   AllocateRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]    -- 
//              [ByteSize] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

PVOID AllocateRoutine( struct _RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return malloc( ByteSize );
} // AllocateRoutine


//+---------------------------------------------------------------------------
//
//  Function:   FreeRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]  -- 
//              [Buffer] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

VOID FreeRoutine( struct _RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    free( Buffer );
} // FreeRoutine


//+---------------------------------------------------------------------------
//
//  Function:   FindOrInsertStateOrder
//
//  Synopsis:   
//
//  Arguments:  [Table]   -- 
//              [Element] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void FindOrInsertStateOrder( PRTL_GENERIC_TABLE StateTable, NTFS_OWNERSHIP_STATE State )
{
    RESOURCE_STATE_ORDER TemplateState;
    PRESOURCE_STATE_ORDER NewState;

    TemplateState.State = State;
    if (!(RtlLookupElementGenericTable( StateTable, &TemplateState ))) {
        NewState = (PRESOURCE_STATE_ORDER)RtlInsertElementGenericTable( StateTable, &TemplateState, sizeof( TemplateState ), NULL );
        InitializeListHead( &NewState->Links );
        NewState->ReachedByRelease = FALSE;
    }
} // FindOrInsertStateOrder


//+---------------------------------------------------------------------------
//
//  Function:   FindOrInsertStateList
//
//  Synopsis:   
//
//  Arguments:  [StateTable] -- 
//              [Resource]   -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void FindOrInsertStateList( PRTL_GENERIC_TABLE StateTable, NTFS_RESOURCE_NAME Resource )
{
    RESOURCE_STATE_LIST TemplateState;
    PRESOURCE_STATE_LIST NewState;

    TemplateState.Resource = Resource;
    if (!(RtlLookupElementGenericTable( StateTable, &TemplateState ))) {
        NewState = (PRESOURCE_STATE_LIST)RtlInsertElementGenericTable( StateTable, &TemplateState, sizeof( TemplateState ), NULL );
        InitializeListHead( &NewState->Links );
    }
} // FindOrInsertStateList


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   
//
//  Arguments:  [argc] -- 
//              [argv] -- 
//
//  Returns:    
//
//  History:    3-16-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void __cdecl main (int argc, char *argv[])
{
    int NumTransitions;
    int Index;
    int Index2;
    
    PRESOURCE_LIST Entry;
    PRESOURCE_LIST Entry2;
    PRESOURCE_STATE_LIST EntryState;
    PRESOURCE_STATE_LIST EntryState2;
    BOOLEAN Skipped;
    BOOLEAN FoundState;
    BOOLEAN Verbose = FALSE;

    PRESOURCE_STATE_ORDER State;
    PRESOURCE_STATE_ORDER EndState;
    PRESOURCE_STATE_ORDER EndState2;
    
    RTL_GENERIC_TABLE StateTable;
    RTL_GENERIC_TABLE ResourceTable;
    RESOURCE_STATE_ORDER StateOrder;
    
    RESOURCE_STATE_LIST StateListOrderTemplate;
    PRESOURCE_STATE_LIST StateListOrder;

    PVOID Key;
    int StateCheck;
    

    if (argc > 1) {
        if (argv[1][0] == '-') {
            switch (argv[1][1]) {
            case 'v':
                Verbose = TRUE;
                break;
            default:
                printf( "Usage: analyze [-v]\nThis program analyzes ntfs's lock order state table\n");
                break;
            }
        }
    }

    //
    //  Discover transition states
    //  

    RtlInitializeGenericTable( &StateTable, CompareRoutine, AllocateRoutine, FreeRoutine, NULL );
    RtlInitializeGenericTable( &ResourceTable, CompareRoutine, AllocateRoutine, FreeRoutine, NULL );

    StateOrder.ReachedByRelease = FALSE;

    NumTransitions = sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTable[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTable[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTable[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableRelease ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableRelease[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableRelease[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableRelease[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableAcquire ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableAcquire[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableAcquire[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableAcquire[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableUnsafe ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableUnsafe[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableUnsafe[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableUnsafe[Index].End );
    }

    printf( "%d states and %d resources referenced in transition tables\n\n", 
            StateTable.NumberGenericTableElements,
            ResourceTable.NumberGenericTableElements );

/*
    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, TRUE );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, FALSE )) {
            
        printf("0x%x\n", State->State );

    }
*/

    //
    //  Visit each transition state until we know the full paths
    // 

    do {

        Skipped = FALSE;
        FoundState = FALSE;
        Key = NULL;
        
        for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key );
             State != 0;
             State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key )) {

//            printf( "State: 0x%x\n", State->State );

            //
            //  We don't know this state yet
            //  

            if ((State->State != None) && IsListEmpty( &State->Links)) {
                if (Verbose) {
                    printf( "skipping state 0x%x\n", State->State );
                }
                Skipped = TRUE;
                continue;
            }

            //
            //  Look in the release only paths 1st    
            //

            NumTransitions = sizeof( OwnershipTransitionTableRelease ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
            for (Index=0; Index < NumTransitions; Index++) {

                if (OwnershipTransitionTableRelease[Index].Begin == State->State &&
                    OwnershipTransitionTableRelease[Index].End != None) {

                    StateOrder.State = OwnershipTransitionTableRelease[Index].End;
                    EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                    //
                    //  Is this a new state?
                    //  
                    
                    if (EndState && IsListEmpty( &EndState->Links )) {

                        FoundState = TRUE;
                        EndState->ReachedByRelease = TRUE;

                        if (Verbose) {
                            printf( "removing resource: 0x%x to state: 0x%x from 0x%x during release\n", 
                                    OwnershipTransitionTableRelease[Index].Acquired, 
                                    OwnershipTransitionTableRelease[Index].End, 
                                    State->State );
                        }

                        //
                        //  Add the old state's resource except for the resource being released
                        //  

                        if (State->State != None) {
                            Entry = (PRESOURCE_LIST)&State->Links;
                            do {
                                Entry = (PRESOURCE_LIST)Entry->Links.Flink;

                                if (Entry->Resource != OwnershipTransitionTableRelease[Index].Acquired) {
                                    
                                    Entry2 = new RESOURCE_LIST;
                                    Entry2->Resource = Entry->Resource;
                                    
                                    InsertTailList( &EndState->Links, &Entry2->Links );
                                }
                            } while ( Entry->Links.Flink != &State->Links );
                        }
                    }  //  endif the new state is unknown
                }  //  endif rule beginning matches the state
            }  // endfor over rules
        
            //  
            //  Then look in the acquire paths
            // 
         
            NumTransitions = sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
            for (Index=0; Index < NumTransitions; Index++) {

                if (OwnershipTransitionTable[Index].Begin == State->State) {

                    StateOrder.State = OwnershipTransitionTable[Index].End;
                    EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                    EndState->ReachedByRelease = FALSE;

                    //
                    //  If we already know this state - then doublecheck this is an identical path
                    //  

                    if (EndState && !IsListEmpty( &EndState->Links )) {

                        Entry = (PRESOURCE_LIST)EndState->Links.Flink;
                        if (Entry->Resource != NtfsResourceExVcb) {
                            Entry = (PRESOURCE_LIST)EndState->Links.Blink;
                            if (OwnershipTransitionTable[Index].Acquired != Entry->Resource ) {
                                printf( "2 paths to state: 0x%x 0x%x 0x%x\n", OwnershipTransitionTable[Index].End, Entry->Resource, OwnershipTransitionTable[Index].Acquired );
                            } 
                        }

                    } else {

                        FoundState = TRUE;

                        if (Verbose) {
                            printf( "adding resource: 0x%x to state: 0x%x from 0x%x\n", 
                                    OwnershipTransitionTable[Index].Acquired, 
                                    OwnershipTransitionTable[Index].End, 
                                    State->State );
                        }
                        
                        //
                        //  Add the old state's resource
                        //  

                        if (State->State != None) {
                            Entry = (PRESOURCE_LIST)&State->Links;
                            do {
                                Entry = (PRESOURCE_LIST)Entry->Links.Flink;

                                Entry2 = new RESOURCE_LIST;
                                Entry2->Resource = Entry->Resource;

                                InsertTailList( &EndState->Links, &Entry2->Links );

                            } while ( Entry->Links.Flink != &State->Links );
                        }

                        //
                        //  Finally add the transition resource into this state
                        //  

                        Entry = new RESOURCE_LIST;
                        Entry->Resource = OwnershipTransitionTable[Index].Acquired;

                        InsertTailList( &EndState->Links, &Entry->Links );

                    }
                }
            }
        }
        
        if (Verbose) {
            printf( "pass done\n" );
        }

    } while (FoundState && Skipped);

    //
    //  Printout state maps
    // 
        
    printf( "State Map\n" );

    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, TRUE );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, FALSE )) {

        StateCheck = 0;
        
        if (!IsListEmpty( &State->Links )) {

            Entry = (PRESOURCE_LIST)&State->Links;
            do {
                Entry = (PRESOURCE_LIST)Entry->Links.Flink;
                        
                StateCheck |= Entry->Resource;
                printf( "%x -> ", Entry->Resource );
        
            } while ( Entry->Links.Flink != &State->Links );
            printf( "state %x\n", State->State );

            if ((int)State->State != StateCheck) {
                printf( "State transistions do not make sense, check the state definition\n" );
            }

        }  else {
            printf( "unreachable state: 0x%x\n", State->State );
        }
    }

    //
    //  Now build up individual transitions
    // 

    printf( "Subtransitions\n" );

    
    Key = NULL;

    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key )) {
    
        if (!IsListEmpty( &State->Links )) {

  //          printf( "State: 0x%x\n", State->State );

            Entry = (PRESOURCE_LIST)&State->Links;
            do {
                Entry = (PRESOURCE_LIST)Entry->Links.Flink;
                        
                Entry2 = Entry;
                while (Entry2->Links.Flink != &State->Links) {
                    BOOLEAN Found;

                    Entry2 = (PRESOURCE_LIST)Entry2->Links.Flink;

                    //
                    //  First search if transition exists already from Entry->Resource to Entry2->Resource
                    //  
                    
                    Found = FALSE;
                    StateListOrderTemplate.Resource = Entry->Resource;
                    StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );
                    
                    if (!IsListEmpty( &StateListOrder->Links )) {

//                        printf( "FirstLink: 0x%x\n", StateListOrder->Links.Flink );

                        EntryState2 = StateListOrder;
                        do {
                            EntryState2 = CONTAINING_RECORD( EntryState2->Links.Flink, RESOURCE_STATE_LIST, Links );
                            if (EntryState2->Resource == Entry2->Resource) {

                                PRESOURCE_LIST OldEntry;

                                //
                                //  Always choose state that started without vcb
                                //

                                StateOrder.State = EntryState2->EndState;
                                EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                OldEntry = (PRESOURCE_LIST)EndState->Links.Flink;

                                if ((OldEntry->Resource == NtfsResourceSharedVcb) ||
                                    (OldEntry->Resource == NtfsResourceExVcb)) {

                                    EntryState2->EndState = State->State;
                                }

                                Found = TRUE;
                                break;
                            }

                        } while ( EntryState2->Links.Flink != &StateListOrder->Links );
                    }

                    if (!Found) {
                        
                        //
                        //  Look for conflicts since its new
                        //  

                        StateListOrderTemplate.Resource = Entry2->Resource;
                        StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );

//                        printf( "Resource: 0x%x, empty: %d\n", StateListOrder->Resource, IsListEmpty( &StateListOrder->Links ) );

                        if (StateListOrder && !IsListEmpty( &StateListOrder->Links )) {

                            EntryState2 = StateListOrder;

                            do {
                                EntryState2 = CONTAINING_RECORD( EntryState2->Links.Flink, RESOURCE_STATE_LIST, Links );

                                if ((EntryState2->Resource == Entry->Resource)) {
                                    printf( "possible conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );
                                }

//                              printf( "check from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );                                

                                StateOrder.State = EntryState2->EndState;
                                EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                StateOrder.State = State->State;
                                EndState2 = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                if ((EntryState2->Resource == Entry->Resource) &&
                                    !EndState->ReachedByRelease && 
                                    !EndState2->ReachedByRelease) {

                                    //
                                    //  Now check if vcb locks it out
                                    // 

                                    if (!(((((PRESOURCE_LIST)(EndState2->Links.Flink))->Resource == NtfsResourceSharedVcb) ||
                                         ((PRESOURCE_LIST)(EndState2->Links.Flink))->Resource == NtfsResourceExVcb) &&

                                        ((((PRESOURCE_LIST)(EndState->Links.Flink))->Resource == NtfsResourceSharedVcb) ||
                                         ((PRESOURCE_LIST)(EndState->Links.Flink))->Resource == NtfsResourceExVcb))) {
                                        
                                        printf( "Suborder conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State->State, EntryState2->EndState );
                                        break;
                                    } else {
//                                        printf( "NonSuborder conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );
                                    }
                                }

                            } while ( EntryState2->Links.Flink != &StateListOrder->Links );
                        } else {
    //                        printf ("Unfound resource: 0x%x 0x%x\n", Entry2->Resource, StateListOrder );
                        }

                        StateListOrderTemplate.Resource = Entry->Resource;
                        StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );

                        EntryState = new RESOURCE_STATE_LIST;
                        EntryState->Resource = Entry2->Resource;
                        EntryState->EndState = State->State;

      //                  printf( "Adding 0x%x to list for resource 0x%x\n", EntryState, Entry->Resource );
                        
                        InsertTailList( &StateListOrder->Links, &EntryState->Links );
                    }
                }
                
            } while ( Entry->Links.Flink != &State->Links );
        }
    }

    //
    //  Dump the inidivual transitions
    // 

    Key = NULL;
    for (StateListOrder = (PRESOURCE_STATE_LIST) RtlEnumerateGenericTableWithoutSplaying( &ResourceTable, &Key );
         StateListOrder != 0;
         StateListOrder = (PRESOURCE_STATE_LIST) RtlEnumerateGenericTableWithoutSplaying( &ResourceTable, &Key )) {

        if (!IsListEmpty( &StateListOrder->Links )) {
            EntryState = StateListOrder;
            do {
                EntryState = CONTAINING_RECORD( EntryState->Links.Flink, RESOURCE_STATE_LIST, Links );
                printf( "0x%x -> 0x%x endstate:0x%x\n ", StateListOrder->Resource, EntryState->Resource, EntryState->EndState );

            } while ( EntryState->Links.Flink != &StateListOrder->Links );
        }
    }
    
} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tbuffer.c ===
#include "brian.h"

//
//  Local constants and procedure declarations.
//
#define CHAR_POSITION               51
#define COPY_BUFF_SRC_DEFAULT       0
#define COPY_BUFF_DST_DEFAULT       0
#define COPY_BUFF_SRC_OFF_DEFAULT   0
#define COPY_BUFF_DST_OFF_DEFAULT   0
#define COPY_BUFF_LENGTH_DEFAULT    0

#define DISPLAY_INDEX_DEFAULT       0
#define DISPLAY_OFFSET_DEFAULT      0
#define DISPLAY_LENGTH_DEFAULT      0x100

#define ALLOC_ZERO_BITS_DEFAULT     0
#define ALLOC_REGION_SIZE_DEFAULT   0x100
#define ALLOC_VERBOSE_DEFAULT       TRUE
#define ALLOC_DISPLAY_PARMS_DEFAULT FALSE

ULONG
PrintDwords (
    IN PULONG BufferAddress,
    IN ULONG CountWords
    );

ULONG
PrintWords (
    IN PUSHORT BufferAddress,
    IN ULONG CountWords
    );

ULONG
PrintBytes (
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    );

VOID
PrintChars(
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    );

VOID
ClearBuffer(
    IN ULONG Index
    );

VOID
DisplayBuffer (
    IN ULONG Index,
    IN ULONG StartOffset,
    IN ULONG DisplayLength,
    IN ULONG DisplaySize
    );

VOID
CopyBuffer(
    IN ULONG SrcIndex,
    IN ULONG DstIndex,
    IN ULONG Length,
    IN ULONG SrcOffset,
    IN ULONG DstOffset
    );

VOID
FillBuffer (
    IN ULONG Index,
    IN PVOID Structure,
    IN ULONG Length
    );

NTSTATUS
FullAllocMem(
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
FullDeallocMem(
    IN ULONG Index,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );


VOID
InitBuffers (
    )
{
    NtCreateEvent( &BufferEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Buffers, sizeof( Buffers ));
}


VOID
UninitBuffers (
    )
{
    USHORT Index;

    //
    //  Deallocate any buffers remaining.
    //

    for (Index = 0; Index < MAX_BUFFERS; Index++) {

        DeallocateBuffer( Index );
    }
}


NTSTATUS
AllocateBuffer (
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex
    )
{
    NTSTATUS Status;
    PVOID BufferAddress;
    ULONG Index;

    BufferAddress = NULL;

    //
    //  Wait for the buffer event.
    //

    if ((Status = NtWaitForSingleObject( BufferEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    try {

        //
        //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
        //  if not found.
        //
        for (Index = 0; Index < MAX_BUFFERS; Index++) {

            if (!Buffers[Index].Used) {

                break;
            }
        }

        if (Index >= MAX_BUFFERS) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        //  Otherwise allocate the virtual memory.  If no error occurs, then
        //  store the data in the buffer array.
        //

        } else if ((Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                      &BufferAddress,
                                                      ZeroBits,
                                                      RegionSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE )) == STATUS_SUCCESS) {

            Buffers[Index].Buffer = BufferAddress;
            Buffers[Index].Length = (ULONG) *RegionSize;
            Buffers[Index].Used = TRUE;
        }

        //
        //  Set the buffer event back to the signalled state.
        //

        *BufferIndex = Index;


        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nAllocate Buffer:  Abnormal termination\n" );
        }

        NtSetEvent( BufferEvent, NULL );
    }
    return Status;
}


NTSTATUS
DeallocateBuffer (
    IN ULONG Index
    )
{
    NTSTATUS Status;

    //
    //  Wait for the buffer event.
    //
    if ((Status = NtWaitForSingleObject( BufferEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    try {

        if (Index <= MAX_BUFFERS
            && Buffers[Index].Used) {

            SIZE_T RegionSize = Buffers[Index].Length;

            Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                          (PVOID *) &Buffers[Index].Buffer,
                                          &RegionSize,
                                          MEM_RELEASE );

            Buffers[Index].Used = FALSE;
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDeallocate Buffer:  Abnormal termination\n" );
        }

        NtSetEvent( BufferEvent, NULL );
    }

    return Status;
}


BOOLEAN
BufferInfo (
    IN ULONG Index,
    OUT PVOID *BufferAddress,
    OUT PULONG RegionSize
    )
{

    if (Index >= MAX_BUFFERS || !Buffers[Index].Used) {

        return FALSE;
    }

    *BufferAddress = Buffers[Index].Buffer;
    *RegionSize = Buffers[Index].Length;

    return TRUE;
}


VOID
InputClearBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG Index;
    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    Index = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {
        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Index = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: clb -b<digits> \n" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n\n" );


    //
    //  Else call our copy buffer routine.
    //
    } else {

        ClearBuffer( Index );
    }

    return;
}


VOID
ClearBuffer(
    IN ULONG Index
    )
{
    //
    //  Check for an invalid index.
    //

    if (!Buffers[Index].Used) {

        printf( "\nClearBuffer:  Invalid buffer" );

    } else {

        RtlZeroMemory( Buffers[Index].Buffer, Buffers[Index].Length );
    }

    return;
}


VOID
DisplayBuffer (
    IN ULONG Index,
    IN ULONG StartOffset,
    IN ULONG DisplayLength,
    IN ULONG DisplaySize
    )
{
    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[Index].Used) {

        printf( "\nDisplayBuffer: Index refers to invalid buffer" );

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (StartOffset >= Buffers[Index].Length) {

        printf( "\nDisplayBuffer: Start offset is invalid" );

    //
    //  Else compute the legal display length and output to the screen.
    //

    } else {

        ULONG LegalLength;
        ULONG FullLines;
        PCHAR BufferAddress;
        ULONG SpacesFilled;

        //
        //  The legal display length is the minimum of the remaining
        //  bytes in the buffer and the desired display length.
        //

        LegalLength = Buffers[Index].Length - StartOffset;
        LegalLength = min( LegalLength, DisplayLength );
        BufferAddress = Buffers[Index].Buffer;

        //
        //  Display the display information.
        //

        printf( "\nIndex -> %u, Buffer Base -> %p, ", Index, BufferAddress );
        printf( "Buffer Offset -> %08lx, Bytes -> %u", StartOffset, LegalLength );
        printf( "\n" );

        BufferAddress += StartOffset;

        //
        //  Compute the number and display the full lines.
        //

        FullLines = LegalLength / 16;

        while (FullLines--) {

            if (DisplaySize == sizeof( UCHAR )) {

                PrintBytes( BufferAddress, 16 );

            } else if (DisplaySize == sizeof( WCHAR )) {

                PrintWords( (PVOID) BufferAddress, 8 );

            } else {

                PrintDwords( (PVOID) BufferAddress, 4 );
            }

            printf( "  " );

            PrintChars( BufferAddress, 16 );
            BufferAddress += 16;
        }

        //
        //  Display the remaining bytes.
        //

        if (DisplaySize == sizeof( UCHAR )) {

            SpacesFilled = PrintBytes( BufferAddress, LegalLength % 16 );

        } else if (DisplaySize == sizeof( WCHAR )) {

            SpacesFilled = PrintWords( (PVOID) BufferAddress, LegalLength % 8 );

        } else {

            SpacesFilled = PrintDwords( (PVOID) BufferAddress, LegalLength % 4 );
        }

        if (SpacesFilled) {

            SpacesFilled = CHAR_POSITION - SpacesFilled;
            while ( SpacesFilled-- ) {

                printf( " " );
            }
        }

        PrintChars( BufferAddress, LegalLength % 16 );
        printf( "\n\n" );
    }

    return;
}


ULONG
PrintBytes (
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    )
{
    ULONG CountSpaces;
    ULONG RemainingChars;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountChars * 3 + (CountChars ? 1 : 0);
    RemainingChars = CountChars - min( CountChars, 8 );
    CountChars = min( CountChars, 8 );

    //
    //  Print the first 8 bytes (if possible).
    //

    if (CountChars) {

        printf( "\n" );

        while (CountChars--) {

            printf( "%02x ", *((PUCHAR) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingChars--) {

            printf( "%02x ", *((PUCHAR) BufferAddress++) );
        }

    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


ULONG
PrintWords (
    IN PWCHAR BufferAddress,
    IN ULONG CountWords
    )
{
    ULONG CountSpaces;
    ULONG RemainingWords;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountWords * 5 + (CountWords ? 1 : 0);
    RemainingWords = CountWords - min( CountWords, 4 );
    CountWords = min( CountWords, 4 );

    //
    //  Print the first 4 words (if possible).
    //

    if (CountWords) {

        printf( "\n" );

        while (CountWords--) {

            printf( "%04x ", *((PWCHAR) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingWords--) {

            printf( "%04x ", *((PWCHAR) BufferAddress++) );
        }
    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


ULONG
PrintDwords (
    IN PULONG BufferAddress,
    IN ULONG CountDwords
    )
{
    ULONG CountSpaces;
    ULONG RemainingDwords;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountDwords * 7 + (CountDwords ? 1 : 0);
    RemainingDwords = CountDwords - min( CountDwords, 8 );
    CountDwords = min( CountDwords, 8 );

    //
    //  Print the first 2 Dwords (if possible).
    //

    if (CountDwords) {

        printf( "\n" );

        while (CountDwords--) {

            printf( "%08x ", *((PULONG) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingDwords--) {

            printf( "%08x ", *((PULONG) BufferAddress++) );
        }
    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


VOID
PrintChars(
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    )
{
    ULONG RemainingChars;

    //
    //  Initialize the local variables.
    //

    RemainingChars = CountChars - min( CountChars, 8 );
    CountChars = min( CountChars, 8 );

    //
    //  Print the first 8 bytes (if possible).
    //

    if (CountChars) {

        while (CountChars--) {

            if (*BufferAddress > 31
                 && *BufferAddress != 127) {

                printf( "%c", *BufferAddress );

            } else {

                printf( "." );

            }

            BufferAddress++;

        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingChars--) {

            if (*BufferAddress > 31
                && *BufferAddress != 127) {

                printf( "%c", *BufferAddress );

            } else {

                printf( "." );
            }

            BufferAddress++;
        }
    }

    return;
}


VOID
InputDisplayBuffer(
    IN PCHAR ParamBuffer,
    IN ULONG DisplaySize
    )
{
    ULONG DisplayLength;
    ULONG DisplayOffset;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;
    BufferIndex = DISPLAY_INDEX_DEFAULT;
    DisplayOffset = DISPLAY_OFFSET_DEFAULT;
    DisplayLength = DISPLAY_LENGTH_DEFAULT;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the display length.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DisplayLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check the display offset.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DisplayOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: db [options]* -i<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -l<digits>   Display length" );
        printf( "\n           -o<digits>   Display starting offset" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        DisplayBuffer( BufferIndex, DisplayOffset, DisplayLength, DisplaySize );
    }
}


VOID
InputCopyBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG SrcIndex;
    ULONG DstIndex;
    ULONG Length;
    ULONG SrcOffset;
    ULONG DstOffset;
    BOOLEAN DstSpecified;
    BOOLEAN SrcSpecified;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    SrcIndex = COPY_BUFF_SRC_DEFAULT;
    DstIndex = COPY_BUFF_DST_DEFAULT;
    Length = COPY_BUFF_SRC_OFF_DEFAULT;
    SrcOffset = COPY_BUFF_DST_OFF_DEFAULT;
    DstOffset = COPY_BUFF_LENGTH_DEFAULT;

    DstSpecified = FALSE;
    SrcSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if ( *ParamBuffer ) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the destination index.
                //
                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DstIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    DstSpecified = TRUE;

                    break;

                //
                //  Check source starting offset.
                //

                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SrcOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check copy length.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check the source index.
                //
                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SrcIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    SrcSpecified = TRUE;

                    break;

                //
                //  Check destination offset.
                //
                case 't' :
                case 'T' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DstOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!SrcSpecified || !DstSpecified) {

        printf( "\n   Usage: cb [options]* -d<digits> [options]* -s<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -d<digits>   Destination index" );
        printf( "\n           -f<digits>   Source offset" );
        printf( "\n           -l<digits>   Transfer length" );
        printf( "\n           -s<digits>   Source index" );
        printf( "\n           -t<digits>   Destination offset" );
        printf( "\n\n" );


    //
    //  Else call our copy buffer routine.
    //
    } else {

        CopyBuffer( SrcIndex,
                    DstIndex,
                    Length,
                    SrcOffset,
                    DstOffset );

    }
}


VOID
CopyBuffer(
    IN ULONG SrcIndex,
    IN ULONG DstIndex,
    IN ULONG Length,
    IN ULONG SrcOffset,
    IN ULONG DstOffset
    )
{
    //
    //  Check for an invalid source index.
    //

    if (!Buffers[SrcIndex].Used) {

        printf( "\nCopyBuffer:  Invalid source buffer" );

    //
    //  Otherwise check for an invalid destination index.
    //

    } else if (!Buffers[DstIndex].Used) {

        printf( "\nCopyBuffer:  Invalid destination buffer" );


    //
    //  Test for an invalid source offset.
    //

    } else if (SrcOffset >= Buffers[SrcIndex].Length) {

        printf( "\nCopyBuffer:  Source offset is invalid" );

    //
    //  Test for an invalid destination offset.
    //

    } else if (DstOffset >= Buffers[DstIndex].Length) {

        printf( "\nCopyBuffer:  Destination offset is invalid" );

    //
    //  This statement handles the case of two correct indexes and offsets.
    //

    } else {

        ULONG LegalLength;
        PCHAR SrcAddress;
        PCHAR DstAddress;

        //
        //  Adjust the length according to the source buffer size.
        //

        LegalLength = Buffers[SrcIndex].Length - SrcOffset;
        LegalLength = min( LegalLength, Length );
        Length = Buffers[DstIndex].Length - DstOffset;
        LegalLength = min( LegalLength, Length );

        SrcAddress = Buffers[SrcIndex].Buffer + SrcOffset;
        DstAddress = Buffers[DstIndex].Buffer + DstOffset;

        //
        //  Display the header information.
        //

        printf( "\nSource index -> %2u, Source base -> %p, Source offset -> %08lx, ",
                  SrcIndex, 
                  Buffers[SrcIndex].Buffer,
                  SrcOffset );

        printf( "\n  Dest index -> %2u,   Dest base -> %p,   Dest offset -> %08lx, ",
                  DstIndex, 
                  Buffers[DstIndex].Buffer, 
                  DstOffset );

        printf( "\nLength -> %u", Length );

        //
        //  Perform the transfer for non-zero lengths only.
        //

        if (Length) {

            RtlMoveMemory( DstAddress, SrcAddress, Length );
        }
    }

    return;
}


VOID
InputAllocMem(
    IN PCHAR ParamBuffer
    )
{
    ULONG ZeroBits;
    SIZE_T RegionSize;
    ULONG BufferIndex;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    ZeroBits = ALLOC_ZERO_BITS_DEFAULT;
    RegionSize = ALLOC_REGION_SIZE_DEFAULT;
    VerboseResults = ALLOC_VERBOSE_DEFAULT;
    DisplayParms = ALLOC_DISPLAY_PARMS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if ( *ParamBuffer ) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update zero bits.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ZeroBits = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the region size.
                //
                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    RegionSize = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;
                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: am [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Zero bits" );
        printf( "\n           -r<digits>   Region size" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n\n" );


    //
    //  Else call our allocation routine.
    //
    } else {

        FullAllocMem(
                ZeroBits,
                &RegionSize,
                &BufferIndex,
                VerboseResults,
                DisplayParms
                );

    }
}

NTSTATUS
FullAllocMem(
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (DisplayParms) {

        printf( "\nAlloc Memory Parameters" );
        printf( "\n   Zero Bits               -> %ld", ZeroBits );
        printf( "\n   Region Size             -> %ld", *RegionSize );
        printf( "\n\n" );
    }

    //
    //  Try to get the next buffer.
    //

    Status = AllocateBuffer( ZeroBits, RegionSize, BufferIndex );

    //
    //  Print the results if verbose.
    //

    if (VerboseResults) {

        printf( "\nAllocMem:    Status           -> %08lx", Status );
        printf( "\n             RegionSize       -> %08lx", *RegionSize );
        printf( "\n             BufferIndex      -> %ld", *BufferIndex );
        printf( "\n\n" );
    }

    return Status;
}


VOID
InputDeallocMem(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;

    //
    //  Set the defaults.
    //

    VerboseResults = ALLOC_VERBOSE_DEFAULT;
    DisplayParms = ALLOC_DISPLAY_PARMS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Find the Index value.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;
                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dm [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer Index number" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n\n" );


    //
    //  Else call our allocation routine.
    //
    } else {

        FullDeallocMem(
                BufferIndex,
                VerboseResults,
                DisplayParms );
    }
}


NTSTATUS
FullDeallocMem(
    IN ULONG Index,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (DisplayParms) {

        printf( "\nDealloc Memory Parameters" );
        printf( "\n   Buffer Index             -> %ld", Index );
        printf( "\n\n" );
    }

    //
    //  Try to free the desired buffer.
    //

    Status = DeallocateBuffer( Index );

    //
    //  Print the results if verbose.
    //

    if (VerboseResults) {

        printf( "\nDeallocMem:    Status           -> %08lx", Status );
        printf( "\n\n" );
    }

    return Status;
}


VOID InputFillBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN HaveStructure = FALSE;

    MFT_ENUM_DATA EnumUsnData;
    READ_USN_JOURNAL_DATA ReadUsnJournal;
    CREATE_USN_JOURNAL_DATA CreateUsnJournal;
    LARGE_INTEGER LargeIntegerInput;
    FILE_ALLOCATED_RANGE_BUFFER AllocatedRangeBuffer;

    PVOID StructurePointer;
    ULONG StructureSize;

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;

    RtlZeroMemory( &EnumUsnData, sizeof( MFT_ENUM_DATA ));
    RtlZeroMemory( &ReadUsnJournal, sizeof( READ_USN_JOURNAL_DATA ));
    RtlZeroMemory( &CreateUsnJournal, sizeof( CREATE_USN_JOURNAL_DATA ));
    RtlZeroMemory( &LargeIntegerInput, sizeof( LARGE_INTEGER ));
    RtlZeroMemory( &AllocatedRangeBuffer, sizeof( FILE_ALLOCATED_RANGE_BUFFER ));

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                BOOLEAN SwitchBool;

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the structure to fill.
                //
                case 's' :
                case 'S' :


                    SwitchBool = TRUE;
                    ParamBuffer++;
                    if (*ParamBuffer
                        && *ParamBuffer != ' '
                        && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                        case 'b' :
                        case 'B' :

                            HaveStructure = TRUE;

                            StructurePointer = &LargeIntegerInput;
                            StructureSize = sizeof( LARGE_INTEGER );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    LargeIntegerInput.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'c' :
                        case 'C' :

                            HaveStructure = TRUE;

                            StructurePointer = &AllocatedRangeBuffer;
                            StructureSize = sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    AllocatedRangeBuffer.FileOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    AllocatedRangeBuffer.Length.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        default :

                            NOTHING;
                        }
                    }

                    break;

                default :

                    NOTHING;
                }

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fb -b<digits> -s<struct>[options]* \n" );
        printf( "\n           -sa[options]      Get Volume Bitmap" );
        printf( "\n                 a<digits>       Starting lcn" );
        printf( "\n           -sb[options]      Query Retrieval Pointers" );
        printf( "\n                 a<digits>       Starting vcn" );
        printf( "\n           -sc[options]      Query Allocated Ranges" );
        printf( "\n                 a<digits>       FileOffset" );
        printf( "\n                 b<digits>       Length" );

        printf( "\n\n" );

    //
    //  Else fill the buffer.
    //
    } else if (HaveStructure) {

        FillBuffer( BufferIndex, StructurePointer, StructureSize );
    }
}


VOID InputFillBufferUsn(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN HaveStructure = FALSE;

    MFT_ENUM_DATA EnumUsnData;
    READ_USN_JOURNAL_DATA ReadUsnJournal;
    CREATE_USN_JOURNAL_DATA CreateUsnJournal;
    DELETE_USN_JOURNAL_DATA DeleteUsnJournal;

    PVOID StructurePointer;
    ULONG StructureSize;

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;

    RtlZeroMemory( &EnumUsnData, sizeof( MFT_ENUM_DATA ));
    RtlZeroMemory( &ReadUsnJournal, sizeof( READ_USN_JOURNAL_DATA ));
    RtlZeroMemory( &CreateUsnJournal, sizeof( CREATE_USN_JOURNAL_DATA ));
    RtlZeroMemory( &DeleteUsnJournal, sizeof( DELETE_USN_JOURNAL_DATA ));

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                BOOLEAN SwitchBool;

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the structure to fill.
                //
                case 's' :
                case 'S' :


                    SwitchBool = TRUE;
                    ParamBuffer++;
                    if (*ParamBuffer
                        && *ParamBuffer != ' '
                        && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        //
                        //  ENUM_USN_DATA
                        //

                        case 'a' :
                        case 'A' :

                            HaveStructure = TRUE;

                            StructurePointer = &EnumUsnData;
                            StructureSize = sizeof( MFT_ENUM_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    EnumUsnData.LowUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    EnumUsnData.HighUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'c' :
                                case 'C' :

                                    ParamBuffer++;
                                    EnumUsnData.StartFileReferenceNumber = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'b' :
                        case 'B' :

                            HaveStructure = TRUE;

                            StructurePointer = &ReadUsnJournal;
                            StructureSize = sizeof( READ_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    ReadUsnJournal.StartUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    ReadUsnJournal.ReasonMask = AsciiToInteger( ParamBuffer );
                                    break;

                                case 'c' :
                                case 'C' :

                                    ParamBuffer++;
                                    ReadUsnJournal.ReturnOnlyOnClose = AsciiToInteger( ParamBuffer );
                                    break;

                                case 'd' :
                                case 'D' :

                                    ParamBuffer++;
                                    ReadUsnJournal.Timeout = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'e' :
                                case 'E' :

                                    ParamBuffer++;
                                    ReadUsnJournal.BytesToWaitFor = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'f' :
                                case 'F' :

                                    ParamBuffer++;
                                    ReadUsnJournal.UsnJournalID = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'c' :
                        case 'C' :

                            HaveStructure = TRUE;

                            StructurePointer = &CreateUsnJournal;
                            StructureSize = sizeof( CREATE_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    CreateUsnJournal.MaximumSize = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    CreateUsnJournal.AllocationDelta = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'd' :
                        case 'D' :

                            HaveStructure = TRUE;

                            StructurePointer = &DeleteUsnJournal;
                            StructureSize = sizeof( DELETE_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    DeleteUsnJournal.UsnJournalID = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        default :

                            NOTHING;
                        }
                    }

                    break;

                default :

                    NOTHING;
                }

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fbusn -b<digits> -s<struct>[options]* \n" );
        printf( "\n           -sa[options]      Enum Usn Data" );
        printf( "\n                 a<digits>       Low usn" );
        printf( "\n                 b<digits>       High usn" );
        printf( "\n                 c<digits>       File ref" );
        printf( "\n           -sb[options]      Read Usn Data" );
        printf( "\n                 a<digits>       Start usn" );
        printf( "\n                 b<digits>       Reason mask" );
        printf( "\n                 c<digits>       Return only on close" );
        printf( "\n                 d<digits>       Timeout" );
        printf( "\n                 e<digits>       Bytes to wait for" );
        printf( "\n                 f<digits>       Journal id" );
        printf( "\n           -sc[options]      Create Usn Data" );
        printf( "\n                 a<digits>       Maximum size" );
        printf( "\n                 b<digits>       Allocation delta" );
        printf( "\n           -sd[options]      Delete Usn Journal Data" );
        printf( "\n                 a<digits>       Usn journal id" );

        printf( "\n\n" );

    //
    //  Else fill the buffer.
    //
    } else if (HaveStructure) {

        FillBuffer( BufferIndex, StructurePointer, StructureSize );
    }
}


VOID
FillBuffer (
    IN ULONG Index,
    IN PVOID Structure,
    IN ULONG Length
    )
{
    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[Index].Used) {

        printf( "\nFillBuffer: Index refers to invalid buffer" );

    //
    //  Else copy as much of the data as will fit into the buffer.
    //

    } else {

        if (Length > Buffers[Index].Length) {

            Length = Buffers[Index].Length;
        }

        RtlCopyMemory( Buffers[Index].Buffer, Structure, Length );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tbreak.c ===
#include "brian.h"


VOID
InputBreak (
    IN PCHAR ParamBuffer
    )
{
    DbgBreakPoint();

    return;

    UNREFERENCED_PARAMETER( ParamBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\prmptsup.c ===
#include "brian.h"

PCHAR
SwallowNonWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    )
{
    ULONG LocalCount = 0;

    while (*Ptr) {

        if (*Ptr == ' ' || *Ptr == '\t' ) {

            break;
        }

        LocalCount += 1;
        Ptr++;
    }

    *Count = LocalCount;
    return Ptr;
}

PCHAR
SwallowWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    )
{
    ULONG LocalCount = 0;

    while (*Ptr != '\0') {

        if (*Ptr != ' ' && *Ptr != '\t') {

            break;
        }

        LocalCount += 1;
        Ptr++;
    }

    *Count = LocalCount;
    return Ptr;
}

ULONG
AnalyzeBuffer (
    PCHAR *BuffPtr,
    PULONG ParamStringLen
    )
{
    ULONG BytesSwallowed;
    ULONG Count;
    PCHAR CurrentChar;

    if (!ExtractCmd( BuffPtr, &BytesSwallowed )) {

        return SHELL_UNKNOWN;
    }

    //
    //  Lower case the command string.
    //

    for (Count = 0, CurrentChar = *BuffPtr; Count < BytesSwallowed; Count++, CurrentChar++) {

        if ((*CurrentChar <= 'Z') && (*CurrentChar >= 'A')) {

            *CurrentChar += ('a' - 'A');
        }
    }

    *ParamStringLen = BytesSwallowed;

    if ((BytesSwallowed == 2) &&
        RtlEqualMemory( *BuffPtr, "op", 2 )) {

        return SHELL_OPEN;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "die", 3 )) {

        return SHELL_EXIT;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "clb", 3 )) {

        return SHELL_CLEAR_BUFFER;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "db", 2 )) {

        return SHELL_DISPLAY_BYTES;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dw", 2 )) {

        return SHELL_DISPLAY_WORDS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dd", 2 )) {

        return SHELL_DISPLAY_DWORDS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "cb", 2 )) {

        return SHELL_COPY_BUFFER;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "am", 2 )) {

        return SHELL_ALLOC_MEM;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dm", 2 )) {

        return SHELL_DEALLOC_MEM;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "fb", 2 )) {

        return SHELL_FILL_BUFFER;

    } else if ((BytesSwallowed == 5) &&
               RtlEqualMemory( *BuffPtr, "fbusn", 5 )) {

        return SHELL_FILL_BUFFER_USN;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "pea", 3 )) {

        return SHELL_PUT_EA;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "fea", 3 )) {

        return SHELL_FILL_EA;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "di", 2 )) {

        return SHELL_DISPLAY_HANDLE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "cl", 2 )) {

        return SHELL_CLOSE_HANDLE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "rd", 2 )) {

        return SHELL_READ_FILE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "pa", 2 )) {

        return SHELL_PAUSE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "qea", 3 )) {

        return SHELL_QUERY_EAS;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "sea", 3 )) {

        return SHELL_SET_EAS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "br", 2 )) {

        return SHELL_BREAK;

    } else if ((BytesSwallowed == 4) &&
               RtlEqualMemory( *BuffPtr, "oplk", 4 )) {

        return SHELL_OPLOCK;

    } else if ((BytesSwallowed == 4) &&
               RtlEqualMemory( *BuffPtr, "fsct", 4 )) {

        return SHELL_FSCTRL;

    } else if ((BytesSwallowed == 6) &&
               RtlEqualMemory( *BuffPtr, "sparse", 6 )) {

        return SHELL_SPARSE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "usn", 3 )) {

        return SHELL_USN;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "rp", 2 )) {

        return SHELL_REPARSE;

    } else if ((BytesSwallowed == 5) &&
               RtlEqualMemory( *BuffPtr, "ioctl", 4 )) {

        return SHELL_IOCTL;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "wr", 2 )) {

        return SHELL_WRITE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qd", 2 )) {

        return SHELL_QDIR;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqd", 3 )) {

        return SHELL_DISPLAY_QDIR;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qf", 2 )) {

        return SHELL_QFILE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqf", 3 )) {

        return SHELL_DISPLAY_QFILE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "ncd", 3 )) {

        return SHELL_NOTIFY_CHANGE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "et", 2 )) {

        return SHELL_ENTER_TIME;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dt", 2 )) {

        return SHELL_DISPLAY_TIME;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "sf", 2 )) {

        return SHELL_SETFILE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qv", 2 )) {

        return SHELL_QUERY_VOLUME;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqv", 3 )) {

        return SHELL_DISPLAY_QVOL;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "sv", 2 )) {

        return SHELL_SET_VOLUME;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "can", 2 )) {

        return SHELL_CANCEL_IO;
    }

    return SHELL_UNKNOWN;
}

BOOLEAN
ExtractCmd (
    PCHAR *BufferPtr,
    PULONG BufferLen
    )
{
    BOOLEAN Status;
    PCHAR CurrentLoc;
    PCHAR StartLoc;
    ULONG BytesSwallowed;

    //
    //  Remember the total length and the starting position.
    //  Bytes swallowed is zero.
    //

    CurrentLoc = *BufferPtr;
    BytesSwallowed = 0;
    Status = TRUE;

    //
    //  Swallow leading white spaces.
    //

    CurrentLoc = SwallowWhite (CurrentLoc, &BytesSwallowed);

    //
    //  If first character is NULL, then there was no command.
    //

    if (!*CurrentLoc) {

        Status = FALSE;

    //
    //  Else find the next white space.
    //

    } else {

        StartLoc = CurrentLoc;

        CurrentLoc = SwallowNonWhite (CurrentLoc, &BytesSwallowed);
    }

    //
    //  Update the passed in values.
    //  Return the status of this operation.
    //

    *BufferPtr = StartLoc;
    *BufferLen = BytesSwallowed;

    return Status;
}

VOID
CommandSummary ()
{
    printf( "\nBSHELL Command Summary" );
    printf( "\n\tdie      Exit BSHELL" );
    printf( "\n\tpa       Pause input" );
    printf( "\n\tbr       Break into debugger" );
    printf( "\n" );
    printf( "\n\top       Open a file, directory or volume" );
    printf( "\n\tcan      Cancel IO on a handle" );
    printf( "\n\tcl       Close a file handle" );
    printf( "\n" );
    printf( "\n\tqd       Query directory operation" );
    printf( "\n\tdqd      Disply query directory buffer" );
    printf( "\n\tncd      Notify change directory" );
    printf( "\n" );
    printf( "\n\trd       Read from a file" );
    printf( "\n\twr       Write to a file" );
    printf( "\n" );
    printf( "\n\tqf       Query file information" );
    printf( "\n\tdqf      Display query file buffer" );
    printf( "\n\tsf       Set file information" );
    printf( "\n" );
    printf( "\n\tqv       Query volume information" );
    printf( "\n\tdqv      Display volume informatin" );
    printf( "\n\tsv       Set volume information" );
    printf( "\n" );
    printf( "\n\tfsct     Fsctrl operation" );
    printf( "\n\tsparse   Sparse file operation" );
    printf( "\n\tusn      Usn operation" );
    printf( "\n\trp       Reparse operation" );
    printf( "\n\toplk     Oplock operation" );
    printf( "\n\tioctl    Ioctl operation" );
    printf( "\n" );
    printf( "\n\tclb      Clear a buffer" );
    printf( "\n\tdb       Display a buffer in bytes" );
    printf( "\n\tdw       Display a buffer in words" );
    printf( "\n\tdd       Display a buffer in dwords" );
    printf( "\n\tcb       Copy a buffer" );
    printf( "\n\tfb       Fill a buffer" );
    printf( "\n\tfbusn    Fill a usn fsctl buffer" );
    printf( "\n" );
    printf( "\n\tam       Allocate memory" );
    printf( "\n\tdm       Deallocate memory" );
    printf( "\n" );
    printf( "\n\tdi       Display information on an index" );
    printf( "\n" );
    printf( "\n\tqea      Query the ea's for a file" );
    printf( "\n\tsea      Set the ea's for a file" );
    printf( "\n\tpea      Store an ea name in a buffer for query ea" );
    printf( "\n\tfea      Store an ea name in a buffer to set an ea" );
    printf( "\n" );
    printf( "\n\tet       Enter a time value into a buffer" );
    printf( "\n\tdt       Display a buffer as a time value" );
    printf( "\n\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\bshell.c ===
#include "brian.h"

//
//  Global variables
//
BUFFER_ELEMENT Buffers[MAX_BUFFERS];
HANDLE BufferEvent = NULL;

//
//  Control if debug prints go to the debug screen or the console.  By
//  default they go to the debug screen.  In Synchronous mode they go
//  to the console.
//

ULONG (*DbgPrintLocation)(PCH Format,...) = DbgPrint;

//
//  Flag if we are in Synchronous mode or not.  In Synchronous mode all
//  commands (except OPLOCKS) are executed Synchronously with the shell.
//  The default mode is NOT Synchronous mode.
//

BOOLEAN SynchronousCmds = FALSE;

//
//  If set do to give the BSHELL prompt
//

BOOLEAN BatchMode = FALSE;


//
//  Prototypes
//

int
ParseCmdLine (
    int argc,
    char *argv[]
    );

void
DisplayUsage();


//
//  Main Routine
//

#if i386
__cdecl
#endif
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOLEAN ExitWhile = FALSE;
    UCHAR Buffer[256];
    PCHAR ParamString;
    ULONG ParamStringLen;

    InitBuffers();
    InitHandles();
    InitEvents();

    if (!ParseCmdLine( argc, argv ))
        return STATUS_SUCCESS;

    while (!ExitWhile) {

        ParamString = Buffer;

        if (!BatchMode) { 

            printf( "\nBSHELL> " );
            if (gets( ParamString ) == NULL)        //exit on error
                return;

            printf( " " );

        } else {

            if (gets( ParamString ) == NULL)        //exit on error
                return;

            printf("BSHELL> %s\n",ParamString);
        }

        fflush( stdout );

        ParamStringLen = strlen( ParamString );

        switch (AnalyzeBuffer( &ParamString, &ParamStringLen )) {

        case SHELL_EXIT:

            ExitWhile = TRUE;
            break;

        case SHELL_OPEN:

            InputOpenFile( ParamString + ParamStringLen );
            break;

        case SHELL_CLEAR_BUFFER:

            InputClearBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_BYTES:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( CHAR ));
            break;

        case SHELL_DISPLAY_WORDS:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( WCHAR ));
            break;

        case SHELL_DISPLAY_DWORDS:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( ULONG ));
            break;

        case SHELL_COPY_BUFFER:

            InputCopyBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_ALLOC_MEM:

            InputAllocMem( ParamString + ParamStringLen );
            break;

        case SHELL_DEALLOC_MEM:

            InputDeallocMem( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_BUFFER:

            InputFillBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_BUFFER_USN:

            InputFillBufferUsn( ParamString + ParamStringLen );
            break;

        case SHELL_PUT_EA:

            InputPutEaName( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_EA:

            InputFillEaBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_HANDLE:

            InputDisplayHandle( ParamString + ParamStringLen );
            break;

        case SHELL_CLOSE_HANDLE:

            InputCloseIndex( ParamString + ParamStringLen );
            break;

        case SHELL_CANCEL_IO:

            InputCancelIndex( ParamString + ParamStringLen );
            break;

        case SHELL_READ_FILE:

            InputRead( ParamString + ParamStringLen );
            break;

        case SHELL_PAUSE:

            InputPause( ParamString + ParamStringLen );
            break;

        case SHELL_QUERY_EAS:

            InputQueryEa( ParamString + ParamStringLen );
            break;

        case SHELL_SET_EAS:

            InputSetEa( ParamString + ParamStringLen );
            break;

        case SHELL_BREAK:

            InputBreak( ParamString + ParamStringLen );
            break;

        case SHELL_OPLOCK:

            InputOplock( ParamString + ParamStringLen );
            break;

        case SHELL_WRITE:

            InputWrite( ParamString + ParamStringLen );
            break;

        case SHELL_QDIR:

            InputQDir( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QDIR:

            InputDisplayQDir( ParamString + ParamStringLen );
            break;

        case SHELL_QFILE:

            InputQFile( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QFILE:

            InputDisplayQFile( ParamString + ParamStringLen );
            break;

        case SHELL_NOTIFY_CHANGE:

            InputNotifyChange( ParamString + ParamStringLen );
            break;

        case SHELL_ENTER_TIME:

            InputEnterTime( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_TIME:

            InputDisplayTime( ParamString + ParamStringLen );
            break;

        case SHELL_SETFILE:

            InputSetFile( ParamString + ParamStringLen );
            break;

        case SHELL_QUERY_VOLUME:

            InputQVolume( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QVOL:

            InputDisplayQVolume( ParamString + ParamStringLen );
            break;

        case SHELL_SET_VOLUME:

            InputSetVolume( ParamString + ParamStringLen );
            break;

        case SHELL_FSCTRL:

            InputFsctrl( ParamString + ParamStringLen );
            break;

        case SHELL_SPARSE:

            InputSparse( ParamString + ParamStringLen );
            break;

        case SHELL_USN:

            InputUsn( ParamString + ParamStringLen );
            break;

        case SHELL_REPARSE:

            InputReparse( ParamString + ParamStringLen );
            break;

        case SHELL_IOCTL:

            InputDevctrl( ParamString + ParamStringLen );
            break;

        default :

            //
            //  Print out the possible command.
            //

            CommandSummary();
        }
    }

    UninitEvents();
    UninitBuffers();
    UninitHandles();

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( envp );
}



int
ParseCmdLine (
    int argc,
    char *argv[]
    )
{
    int i,j;
    char *cp;

    for (i=1; i < argc; i++) {
        cp = argv[i];

        //
        //  See if a switch was specified
        //

        if (cp[0] == '-' || cp[0] == '/') {

            for (j=1; cp[j] != 0; j++) {

                switch (cp[j]) {
                    //
                    //  Handle the "synchronous" switch
                    //

                    case 's':
                    case 'S':
                        SynchronousCmds = TRUE;
                        DbgPrintLocation = printf;
                        break;

                    //
                    //  Handle the "prompt" switch
                    //

                    case 'b':
                    case 'B':
                        BatchMode = TRUE;
                        SynchronousCmds = TRUE;
                        DbgPrintLocation = printf;
                        break;

                    //
                    //  Display usage for unknown switch
                    //

                    case 'h':
                    case 'H':
                    case '?':
                    default:
                        DisplayUsage();
                        return FALSE;
                }
            }

        } else {

            //
            //  Display usage for unknown parameters
            //

            DisplayUsage();
            return FALSE;
        }
    }
    return TRUE;
}



void
DisplayUsage()
{
    printf("\nUsage:  bshell [/bs]\n"
           "    /b      - Execute in batch mode (which also sets synchronous mode)\n"
           "    /s      - Execute commands synchronously\n"
          );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\brian.h ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>

extern BOOLEAN SynchronousCmds;
extern ULONG (*DbgPrintLocation)(PCH Format,...);



ULONG
GetLastError(
    VOID
    );

HANDLE
CreateThread(
    IN PVOID lpThreadAttributes,
    IN ULONG dwStackSize,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG dwCreationFlags,
    OUT PVOID lpThreadId
    );

#define FlagOn( Flags,SingleFlag ) (             \
    (BOOLEAN)(((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )

//
//  Shell constants
//

#define SHELL_UNKNOWN                   0
#define SHELL_EXIT                      1
#define SHELL_OPEN                      2
#define SHELL_CLEAR_BUFFER              3
#define SHELL_DISPLAY_BYTES             4
#define SHELL_COPY_BUFFER               5
#define SHELL_ALLOC_MEM                 6
#define SHELL_DEALLOC_MEM               7
#define SHELL_PUT_EA                    8
#define SHELL_FILL_EA                   9
#define SHELL_DISPLAY_HANDLE            10
#define SHELL_CLOSE_HANDLE              11
#define SHELL_READ_FILE                 12
#define SHELL_PAUSE                     13
#define SHELL_QUERY_EAS                 14
#define SHELL_SET_EAS                   15
#define SHELL_BREAK                     16
#define SHELL_OPLOCK                    17
#define SHELL_WRITE                     18
#define SHELL_QDIR                      19
#define SHELL_DISPLAY_QDIR              20
#define SHELL_QFILE                     21
#define SHELL_DISPLAY_QFILE             22
#define SHELL_NOTIFY_CHANGE             23
#define SHELL_ENTER_TIME                24
#define SHELL_DISPLAY_TIME              25
#define SHELL_SETFILE                   26
#define SHELL_QUERY_VOLUME              27
#define SHELL_DISPLAY_QVOL              28
#define SHELL_SET_VOLUME                29
#define SHELL_FSCTRL                    30
#define SHELL_IOCTL                     31
#define SHELL_CANCEL_IO                 32
#define SHELL_SPARSE                    33
#define SHELL_USN                       34
#define SHELL_FILL_BUFFER               35
#define SHELL_FILL_BUFFER_USN           36
#define SHELL_DISPLAY_WORDS             37
#define SHELL_DISPLAY_DWORDS            38
#define SHELL_REPARSE                   39

#define try_return(S) { S; goto try_exit; }
#define bprint (*DbgPrintLocation)(

//
//  Support routines contained in prmptsup.c
//

PCHAR
SwallowNonWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    );

PCHAR
SwallowWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    );

ULONG
AnalyzeBuffer (
    PCHAR *BuffPtr,
    PULONG ParamStringLen
    );

BOOLEAN
ExtractCmd (
    PCHAR *BufferPtr,
    PULONG BufferLen
    );

VOID
CommandSummary ();

//
//  Routines contained in topen.c
//

VOID
InputOpenFile(
    IN PCHAR ParamBuffer
    );

#define ROUND_UP( x, y )  ((ULONG)(x) + ((y)-1) & ~((y)-1))

//
//  Routines contained in tbuffer.c
//

#define MAX_BUFFERS                 200

typedef struct _BUFFER_ELEMENT {

    PCHAR   Buffer;
    ULONG   Length;
    BOOLEAN Used;

} BUFFER_ELEMENT, *PBUFFER_ELEMENT;

extern BUFFER_ELEMENT Buffers[MAX_BUFFERS];
extern HANDLE BufferEvent;

VOID
InitBuffers (
    );

VOID
UninitBuffers (
    );

NTSTATUS
AllocateBuffer (
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex
    );

NTSTATUS
DeallocateBuffer (
    IN ULONG Index
    );

BOOLEAN
BufferInfo (
    IN ULONG Index,
    OUT PVOID *BufferAddress,
    OUT PULONG RegionSize
    );

VOID
InputClearBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayBuffer(
    IN PCHAR ParamBuffer,
    IN ULONG DisplaySize
    );

VOID
InputCopyBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputAllocMem(
    IN PCHAR ParamBuffer
    );

VOID
InputDeallocMem(
    IN PCHAR ParamBuffer
    );

VOID
InputFillBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputFillBufferUsn(
    IN PCHAR ParamBuffer
    );

//
//  Ea routines contained in tea.c
//

VOID
InputPutEaName(
    IN PCHAR ParamBuffer
    );

VOID
InputFillEaBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputQueryEa(
    IN PCHAR ParamBuffer
    );

VOID
InputSetEa(
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in thandle.c
//

#define MAX_HANDLES                 200

typedef struct _HANDLE_ELEMENT {

    HANDLE Handle;
    BOOLEAN Used;

} HANDLE_ELEMENT, *PHANDLE_ELEMENT;

HANDLE_ELEMENT Handles[MAX_HANDLES];
HANDLE HandleEvent;

VOID
InitHandles (
    );

VOID
UninitHandles (
    );

NTSTATUS
ObtainIndex (
    OUT PUSHORT NewIndex
    );

NTSTATUS
FreeIndex (
    IN USHORT Index
    );

VOID
InputDisplayHandle (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tclose.c
//

VOID
InputCloseIndex (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tevent.c
//

#define MAX_EVENTS                  200

typedef struct _EVENT_ELEMENT {

    HANDLE Handle;
    BOOLEAN Used;

} EVENT_ELEMENT, *PEVENT_ELEMENT;

EVENT_ELEMENT Events[MAX_EVENTS];
HANDLE EventEvent;

VOID
InitEvents (
    );

VOID
UninitEvents (
    );

NTSTATUS
ObtainEvent (
    OUT PUSHORT NewIndex
    );

VOID
FreeEvent (
    IN USHORT Index
    );

//
//  Routines contained in tread.c
//

VOID
InputRead(
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tpause.c
//

VOID
InputPause (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tbreak.c
//

VOID
InputBreak (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in toplock.c
//

VOID
InputOplock (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tdevctl.c
//

VOID
InputDevctrl (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tfsctrl.c
//

VOID
InputFsctrl (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tsparse.c
//

VOID
InputSparse (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tusn.c
//

VOID
InputUsn (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in treparse.c
//

VOID
InputReparse (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in twrite.c
//

VOID
InputWrite (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tqdir.c
//

VOID
InputQDir (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQDir (
    IN PCHAR ParamBuffer
    );

VOID
DisplayQDirNames (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirFullDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirIdFullDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQBothDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQIdBothDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQOleDirs (
    IN USHORT BufferIndex
    );

//
//  Routines contained in ttime.c
//

VOID
InputEnterTime (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayTime (
    IN PCHAR ParamBuffer
    );

VOID
PrintTime (
    IN PTIME Time
    );

VOID
BPrintTime (
    IN PTIME Time
    );

//
//  Routines contained in tmisc.c
//

VOID
PrintLargeInteger (
    IN PLARGE_INTEGER LargeInt
    );

ULONG
AsciiToInteger (
    IN PCHAR Ascii
    );

ULONGLONG
AsciiToLargeInteger (
    IN PCHAR Ascii
    );

//
//  Routines contained in tqfile.c
//

VOID
InputQFile (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQFile (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tnotify.c
//

VOID
InputNotifyChange (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tsetfile.c
//

VOID
InputSetFile (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tqvolume.c
//

VOID
InputQVolume (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQVolume (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tsetvol.c
//

VOID
InputSetVolume (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tcancel.c
//

VOID
InputCancelIndex (
    IN PCHAR ParamBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tcancel.c ===
#include "brian.h"

VOID
CancelIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    );


VOID
InputCancelIndex (
    IN PCHAR ParamBuffer
    )
{
    BOOLEAN Verbose;
    BOOLEAN HandleFound;
    BOOLEAN DisplayParms;
    ULONG ThisHandleIndex;

    //
    //  Set the defaults.
    //
    Verbose = TRUE;
    DisplayParms = FALSE;
    HandleFound = FALSE;

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Recover a handle.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ThisHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HandleFound = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Verbose = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Verbose = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

            } else {

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

            }

        //
        //  Else break.
        //
        } else {

            break;

        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !HandleFound ) {

        printf( "\n    Usage:  can [options]*\n" );
        printf( "\n          Options:" );
        printf( "\n                    -i<index number>   Input a index to cancel" );
        printf( "\n                    -v[t|f]            Verbose mode for subsequent handles" );
        printf( "\n                    -y                 Display parameters before call" );
        printf( "\n\n" );

    } else {

        CancelIndex( (USHORT) ThisHandleIndex,
                     DisplayParms,
                     Verbose );
    }

    return;
}


VOID
CancelIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    Iosb.Status = 0;
    Iosb.Information = 0;

    //
    //  Display parameters if requested.
    //

    if (DisplayParameters) {

        printf( "\nCancel Index Parameters" );
        printf( "\n\tIndex      -> %04x", Index );
        printf( "\n\n" );
    }

    if (Index >= MAX_HANDLES) {

        printf( "\n\tCancel Index:  Invalid index value" );
        Status = STATUS_INVALID_HANDLE;

    } else if (!Handles[Index].Used) {

        printf( "\n\tCancelIndex:   Index is unused" );
        Status = STATUS_INVALID_HANDLE;

    } else {

        Status = NtCancelIoFile( Handles[Index].Handle, &Iosb );
        if (VerboseResults) {

            printf( "\nCancelIndex:   Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                printf( "\nCancelIndex:   Iosb.Information  -> %08lx", Iosb.Information );
                printf( "\nCancelIndex:   Iosb.Status       -> %08lx", Iosb.Status );
            }

            printf( "\n" );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tea.c ===
#include "brian.h"

#define PEAN_INDEX_DEFAULT          0
#define PEAN_OFFSET_DEFAULT         0
#define PEAN_NEXT_OFFSET_DEFAULT    NULL
#define PEAN_ACT_NEXT_OFF_DEFAULT   0
#define PEAN_NAME_DEFAULT           NULL
#define PEAN_VERBOSE_DEFAULT        TRUE
#define PEAN_DISPLAY_PARMS_DEFAULT  FALSE
#define PEAN_MORE_EAS_DEFAULT       FALSE

#define FEA_INDEX_DEFAULT               0
#define FEA_OFFSET_DEFAULT              0
#define FEA_NEXT_OFFSET_DEFAULT         NULL
#define FEA_ACT_NEXT_OFF_DEFAULT        0
#define FEA_NAME_DEFAULT                NULL
#define FEA_VALUE_DEFAULT               NULL
#define FEA_FLAGS_DEFAULT               NULL
#define FEA_ACTUAL_FLAGS_DEFAULT        0
#define FEA_VERBOSE_DEFAULT             TRUE
#define FEA_DISPLAY_PARMS_DEFAULT       FALSE
#define FEA_MORE_EAS_DEFAULT            FALSE

#define QEA_FILE_HANDLE_DEFAULT         0
#define QEA_BUFFER_INDEX_DEFAULT        0
#define QEA_BUFFER_LENGTH_DEFAULT       NULL
#define QEA_RETURN_SINGLE_DEFAULT       FALSE
#define QEA_EA_NAME_BUFFER_DEFAULT      NULL
#define QEA_EA_NAME_BUFFER_LEN_DEFAULT  NULL
#define QEA_EA_INDEX_DEFAULT            NULL
#define QEA_RESTART_SCAN_DEFAULT        FALSE
#define QEA_VERBOSE_DEFAULT             TRUE

#define SEA_FILE_HANDLE_DEFAULT         0
#define SEA_BUFFER_INDEX_DEFAULT        0
#define SEA_BUFFER_LENGTH_DEFAULT       NULL
#define SEA_VERBOSE_DEFAULT             FALSE

NTSTATUS
PutEaName(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PSTRING Name,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms,
    IN BOOLEAN MoreEas
    );

NTSTATUS
FillEaBuffer(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PUCHAR Flags,
    IN PSTRING Name,
    IN PSTRING Value,
    IN BOOLEAN MoreEas,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
QueryEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN ReturnSingleEntry,
    IN PULONG EaNameBuffer OPTIONAL,
    IN PULONG EaNameBufferLength OPTIONAL,
    IN PULONG EaIndex,
    IN BOOLEAN RestartScan,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
SetEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );


VOID
InputPutEaName(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    ULONG Offset;
    PULONG NextOffset;
    ULONG ActualNextOffset;
    PSTRING Name;
    STRING ActualName;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    PCHAR EaNameTemp;
    BOOLEAN MoreEas;

    BufferIndex = PEAN_INDEX_DEFAULT;
    Offset = PEAN_OFFSET_DEFAULT;
    NextOffset = PEAN_NEXT_OFFSET_DEFAULT;
    ActualNextOffset = PEAN_ACT_NEXT_OFF_DEFAULT;
    Name = PEAN_NAME_DEFAULT;
    VerboseResults = PEAN_VERBOSE_DEFAULT;
    DisplayParms = PEAN_DISPLAY_PARMS_DEFAULT;
    MoreEas = PEAN_MORE_EAS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check if we're adding more eas.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        MoreEas = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        MoreEas = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Get the Ea name.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    EaNameTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ActualName.Buffer = EaNameTemp;
                        ActualName.Length = (SHORT) DummyCount;
                        ActualName.MaximumLength = (SHORT) DummyCount;
                        Name = &ActualName;

                    } else {

                        Name = NULL;
                    }

                    ParamReceived = TRUE;
                    break;

                //
                //  Update offset to store the information.
                //
                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Offset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the next offset field.
                //
                case 'x' :
                case 'X' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualNextOffset = AsciiToInteger( ParamBuffer );

                    NextOffset = &ActualNextOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if( !ParamReceived ) {

        printf( "\n   Usage: pea [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -n<ea name>  EaName to store in buffer" );
        printf( "\n           -o<digits>   Offset in buffer to store data" );
        printf( "\n           -x<digits>   Value for next offset field" );
        printf( "\n           -m[t|f]      More Eas coming (Fills next offset field)" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our put ea name routine.
    //
    } else {

        PutEaName( BufferIndex,
                   Offset,
                   NextOffset,
                   Name,
                   VerboseResults,
                   DisplayParms,
                   MoreEas );

    }


}

NTSTATUS
PutEaName(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PSTRING Name,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms,
    IN BOOLEAN MoreEas
    )
{
    NTSTATUS Status;
    ULONG DataLength;

    //
    //  Display parameters if requested.
    //

    if (DisplayParms) {

        printf( "\nPut Ea Name Parameters" );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer offset           -> %08lx", Offset );
        if (NextOffset) {

            printf( "\n   Next offset             -> %08lx", *NextOffset );

        }
        if (Name) {

            printf( "\n   Ea name                 -> %S", &Name );
        }

        printf( "\n   MoreEas                 -> %d", MoreEas );
        printf( "\n\n" );
    }

    if (Name) {

        DataLength = 6 + Name->Length;

    } else {

        DataLength = 5;
    }

    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nPutEaName: Index refers to invalid buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (Offset >= Buffers[BufferIndex].Length) {

        printf( "\nPutEaName: Start offset is invalid" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if length is insufficient to store all of the data
    //  display message.
    //

    } else if (DataLength >= Buffers[BufferIndex].Length) {

        printf( "\nPutEaName: Data won't fit in buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else store the data in the buffer.
    //

    } else {

        PFILE_GET_EA_INFORMATION EaNameBuffer;

        EaNameBuffer = (PFILE_GET_EA_INFORMATION)
                        (Buffers[BufferIndex].Buffer + Offset);

        //
        //  Store the next offset if specified.
        //

        if (NextOffset) {

            EaNameBuffer->NextEntryOffset = *NextOffset;
        }

        //
        //  Store the name and name length if specified.
        //

        if (Name) {

            EaNameBuffer->EaNameLength = (UCHAR) Name->Length;
            RtlMoveMemory( EaNameBuffer->EaName, Name->Buffer, Name->Length );
        }

        if (MoreEas) {

            EaNameBuffer->NextEntryOffset = (DataLength + 3) & ~3;
        }

        Status = STATUS_SUCCESS;
    }

    if (Verbose) {

        printf( "\nPutEaName:   Status           -> %08lx\n", Status );
        printf( "             Following offset -> %ld\n",
                  (DataLength + Offset + 3) & ~3 );
    }

    return Status;
}


VOID
InputFillEaBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    ULONG Offset;
    PULONG NextOffset;
    ULONG ActualNextOffset;
    PSTRING Name;
    STRING ActualName;
    PSTRING Value;
    STRING ActualValue;
    PUCHAR Flags;
    UCHAR ActualFlags;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN MoreEas;
    PCHAR StringTemp;

    BufferIndex = FEA_INDEX_DEFAULT;
    Offset = FEA_OFFSET_DEFAULT;
    NextOffset = FEA_NEXT_OFFSET_DEFAULT;
    ActualNextOffset = FEA_ACT_NEXT_OFF_DEFAULT;
    Name = FEA_NAME_DEFAULT;
    Value = FEA_VALUE_DEFAULT;
    Flags = FEA_FLAGS_DEFAULT;
    ActualFlags = FEA_ACTUAL_FLAGS_DEFAULT;
    MoreEas = FEA_MORE_EAS_DEFAULT;
    VerboseResults = FEA_VERBOSE_DEFAULT;
    DisplayParms = FEA_DISPLAY_PARMS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the flags field.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while( *ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t' ) {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            ActualFlags |= FILE_NEED_EA;

                            Flags = &ActualFlags;

                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;
                        }


                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the Ea name.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    StringTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ActualName.Buffer = StringTemp;
                    ActualName.Length = (SHORT) DummyCount;
                    ActualName.MaximumLength = (SHORT) DummyCount;
                    Name = &ActualName;

                    break;

                //
                //  Get the Ea value.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Remember the buffer offset and get the value.
                    //
                    ParamBuffer++;
                    StringTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ActualValue.Buffer = StringTemp;
                    ActualValue.Length = (SHORT) DummyCount;
                    ActualValue.MaximumLength = (SHORT) DummyCount;
                    Value = &ActualValue;

                    break;

                //
                //  Check if we're adding more eas.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        MoreEas = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        MoreEas = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update offset to store the information.
                //
                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Offset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the next offset field.
                //
                case 'x' :
                case 'X' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualNextOffset = AsciiToInteger( ParamBuffer );

                    NextOffset = &ActualNextOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fea [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -f<chars>    Ea flags to store in buffer" );
        printf( "\n           -n<chars>    EaName to store in buffer" );
        printf( "\n           -l<chars>    Ea value to store in buffer" );
        printf( "\n           -m[t|f]      More Eas coming (Fills next offset field)" );
        printf( "\n           -o<digits>   Offset in buffer to store data" );
        printf( "\n           -x<digits>   Value for next offset field" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our put ea name routine.
    //
    } else {

        FillEaBuffer( BufferIndex,
                      Offset,
                      NextOffset,
                      Flags,
                      Name,
                      Value,
                      MoreEas,
                      VerboseResults,
                      DisplayParms );

    }

    return;
}

NTSTATUS
FillEaBuffer(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PUCHAR Flags,
    IN PSTRING Name,
    IN PSTRING Value,
    IN BOOLEAN MoreEas,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms
    )
{

    NTSTATUS Status;
    ULONG DataLength;

    //
    //  Display parameters if requested.
    //

    if (DisplayParms) {

        printf( "\nFill Ea Buffer Parameters" );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer offset           -> %08lx", Offset );
        if (NextOffset) {

            printf( "\n   Next offset             -> %08lx", *NextOffset );
        }

        if (Flags) {

            printf( "\n   Flags                   -> %02x", *Flags );
        }

        if (Name) {

            printf( "\n   Ea name                 -> %S", Name );
        }

        if (Value) {

            printf( "\n   Value                   -> %S", Value );
        }

        printf( "\n   MoreEas                 -> %d", MoreEas );
        printf( "\n\n" );

    }

    DataLength = 0;

    if (NextOffset) {

	DataLength = 4;
    }

    if (Flags) {

        DataLength = 5;
    }

    if (Name) {

        DataLength = 9 + Name->Length;

        if (Value) {

            if (Value->Length) {

                DataLength += (Value->Length + 4);
            }
        }

    } else if (Value) {

        DataLength = 9;

        if (Value->Length) {

            DataLength = 9 + (Value->Length + 4);
        }
    }

    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nFillEaBuffer: Index refers to invalid buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (Offset >= Buffers[BufferIndex].Length) {

        printf( "\nFillEaBuffer: Start offset is invalid" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if length is insufficient to store all of the data
    //  display message.
    //

    } else if (DataLength >= Buffers[BufferIndex].Length) {

        printf( "\nFillEaBuffer: Data won't fit in buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else store the data in the buffer.
    //

    } else {

	PFILE_FULL_EA_INFORMATION EaBuffer;

	EaBuffer = (PFILE_FULL_EA_INFORMATION)
                   (Buffers[BufferIndex].Buffer + Offset);

        //
        //  Store the next offset if specified.
        //

        if (NextOffset) {

            EaBuffer->NextEntryOffset = *NextOffset;
        }

        //
        //  Store the flags if specified.
        //

        if (Flags) {

            EaBuffer->Flags = *Flags;
        }

        //
        //  Store the name and name length if specified.
        //

        if (Name) {

            EaBuffer->EaNameLength = (UCHAR) Name->Length;
            RtlMoveMemory( EaBuffer->EaName, Name->Buffer, Name->Length );
            EaBuffer->EaName[Name->Length] = '\0';

        }

        //
        //  Store the value if specified.
        //

        if (Value) {

            ULONG Index;
            USHORT ValueLength;
            PUSHORT ActualValueLength;

            ValueLength = (USHORT) (Value->Length ? Value->Length + 4 : 0);

            Index = DataLength - 8 - Value->Length - 4;

            EaBuffer->EaValueLength = ValueLength;

            if (ValueLength) {

                EaBuffer->EaName[Index++] = (CHAR) 0xFD;
                EaBuffer->EaName[Index++] = (CHAR) 0xFF;

                ActualValueLength = (PUSHORT) &EaBuffer->EaName[Index++];

                *ActualValueLength = Value->Length;

                Index++;

                RtlMoveMemory( &EaBuffer->EaName[Index],
                            Value->Buffer,
                            Value->Length );
            }
        }

        //
        //  Update the next entry field automatically.
        //

        if (MoreEas && !NextOffset) {

            EaBuffer->NextEntryOffset = (DataLength + 3) & ~3;
        }

        Status = STATUS_SUCCESS;
    }

    if (Verbose) {

        printf( "\nFillEaBuffer:   Status           -> %08lx\n", Status );
        printf( "                Following offset -> %ld\n",
                  (DataLength + Offset + 3) & ~3 );

    }

    return Status;
}


VOID
InputQueryEa(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileHandleIndex;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG BufferIndex;
    PULONG BufferLength;
    ULONG ActualBufferLength;
    BOOLEAN ReturnSingleEntry;
    PULONG EaNameBuffer;
    ULONG ActualEaNameBuffer;
    PULONG EaNameBufferLength;
    ULONG ActualEaNameBufferLength;
    PULONG EaIndex;
    ULONG ActualEaIndex;
    BOOLEAN RestartScan;

    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Initialize to the default value.
    //

    FileHandleIndex = QEA_FILE_HANDLE_DEFAULT;
    BufferIndex = QEA_BUFFER_INDEX_DEFAULT;
    BufferLength = QEA_BUFFER_LENGTH_DEFAULT;
    ReturnSingleEntry = QEA_RETURN_SINGLE_DEFAULT;
    EaNameBuffer = QEA_EA_NAME_BUFFER_DEFAULT;
    EaNameBufferLength = QEA_EA_NAME_BUFFER_LEN_DEFAULT;
    EaIndex = QEA_EA_INDEX_DEFAULT;
    RestartScan = QEA_RESTART_SCAN_DEFAULT;
    VerboseResults = QEA_VERBOSE_DEFAULT;

    //
    //  Initialize the other interesting values.
    //

    ActualBufferLength = 0;
    ActualEaNameBuffer = 0;
    ActualEaNameBufferLength = 0;
    ActualEaIndex = 0;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the length of the Ea name buffer.
                //

                case 'g' :
                case 'G' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaNameBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaNameBufferLength = &ActualEaNameBufferLength;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the EA index to start from.
                //
                case 'e' :
                case 'E' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaIndex = &ActualEaIndex;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferLength = &ActualBufferLength;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the ea name buffer to use.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaNameBuffer = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaNameBuffer = &ActualEaNameBuffer;

                    ParamReceived = TRUE;

                    break;

                //
                //  Set or clear the restart flag
                //

                case 'r' :
                case 'R' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        RestartScan = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        RestartScan = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;

                    break;

                //
                //  Set or clear the single ea flag.
                //

                case 's' :
                case 'S' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        ReturnSingleEntry = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        ReturnSingleEntry = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qea [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -b<digits>   Output buffer index" );
        printf( "\n           -l<digits>   Declared length of output buffer (Optional)" );
        printf( "\n           -n<digits>   Ea name buffer index" );
        printf( "\n           -g<digits>   Declared length of ea name buffer (Optional)" );
        printf( "\n           -e<digits>   Ea index to start from" );
        printf( "\n           -r[t|f]      Restart scan" );
        printf( "\n           -s[t|f]      Return single entry" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our query ea routine.
    //
    } else {

        QueryEa( FileHandleIndex,
                 &IoStatusBlock,
                 BufferIndex,
                 BufferLength,
                 ReturnSingleEntry,
                 EaNameBuffer,
                 EaNameBufferLength,
                 EaIndex,
                 RestartScan,
                 VerboseResults,
                 DisplayParms );
    }

    return;
}


NTSTATUS
QueryEa (
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN ReturnSingleEntry,
    IN PULONG EaNameBuffer OPTIONAL,
    IN PULONG EaNameBufferLength OPTIONAL,
    IN PULONG EaIndex,
    IN BOOLEAN RestartScan,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )

{
    NTSTATUS Status;

    //
    //  Perform initialization.
    //

    IoStatusBlock->Status = STATUS_SUCCESS;
    IoStatusBlock->Information = 0;

    //
    //  If the buffer index is unused, display an error message.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nQueryEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the ea name buffer is specified but unused, display
    //  an error message.
    //

    } else if (EaNameBuffer && !Buffers[*EaNameBuffer].Used) {

        printf( "\nQueryEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Display the parameters if requested, then call the query Ea
    //  routine.  Display the results if requested.
    //

    } else {

        if (DisplayParms) {

            printf( "\nQuery Ea Parameters" );
            printf( "\n   Handle index            -> %ld", FileHandleIndex );
            printf( "\n   Buffer index length     -> %lx",
                      BufferLength ? *BufferLength : Buffers[BufferIndex].Length );
            printf( "\n   Return single entry     -> %ld", ReturnSingleEntry );
            if (EaNameBuffer) {

                printf( "\n   Ea name buffer index    -> %ld",
                          *EaNameBuffer );

                printf( "\n   Ea name buffer length   -> %lx",
                          EaNameBufferLength ? *EaNameBufferLength : Buffers[*EaNameBuffer].Length );

            }

            if (EaIndex) {

                printf( "\n   Ea index to start at    -> %ld", *EaIndex );

            }
            printf( "\n   Restart scan            -> %ld", RestartScan );
            printf( "\n\n" );

        }

        Status = NtQueryEaFile( Handles[FileHandleIndex].Handle,
                                IoStatusBlock,
                                Buffers[BufferIndex].Buffer,
                                BufferLength
                                ? *BufferLength
                                : Buffers[BufferIndex].Length,
                                ReturnSingleEntry,
                                EaNameBuffer
                                ? Buffers[*EaNameBuffer].Buffer
                                : NULL,
                                EaNameBuffer
                                ? (EaNameBufferLength
                                   ? *EaNameBufferLength
                                   : Buffers[*EaNameBuffer].Length)
                                : 0,
                                EaIndex,
                                RestartScan );
    }

    if (VerboseResults) {

        printf( "\nQuery Ea:  Status           -> %08lx\n", Status );

        if (NT_SUCCESS( Status )) {

            printf( "           Iosb.Information   -> %08lx\n", IoStatusBlock->Information );
            printf( "           Iosb.Status        -> %08lx", IoStatusBlock->Status );
        }

        printf( "\n" );
    }

    return Status;
}


VOID
InputSetEa(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileHandleIndex;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG BufferIndex;
    PULONG BufferLength;
    ULONG ActualBufferLength;

    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Initialize to the default value.
    //

    FileHandleIndex = SEA_FILE_HANDLE_DEFAULT;
    BufferIndex = SEA_BUFFER_INDEX_DEFAULT;
    BufferLength = SEA_BUFFER_LENGTH_DEFAULT;
    VerboseResults = SEA_VERBOSE_DEFAULT;

    //
    //  Initialize the other interesting values.
    //

    ActualBufferLength = 0;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived =TRUE;

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferLength = &ActualBufferLength;

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

               case 'z' :
               case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: sea [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -b<digits>   Output buffer index" );
        printf( "\n           -l<digits>   Declared length of output buffer (Optional)" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our query ea routine.
    //
    } else {

        SetEa( FileHandleIndex,
               &IoStatusBlock,
               BufferIndex,
               BufferLength,
               VerboseResults,
               DisplayParms );

    }

    return;
}

NTSTATUS
SetEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    if (DisplayParms) {

        printf( "\nSet Ea Parameters" );
        printf( "\n   Handle index            -> %ld", FileHandleIndex );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer index length     -> %lx",
                  BufferLength ? *BufferLength : Buffers[BufferIndex].Length );
        printf( "\n\n" );
    }

    //
    //  Perform initialization.
    //

    Status = STATUS_SUCCESS;
    IoStatusBlock->Status = STATUS_SUCCESS;
    IoStatusBlock->Information = 0;

    //
    //  If the buffer index is unused, display an error message.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nSetEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  If the handle index is unused, display an error message.
    //

    } else if (!Handles[FileHandleIndex].Used) {

        printf( "\nSetEa: Index refers to invalid file handle" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Display the parameters if requested, then call the query Ea
    //  routine.  Display the results if requested.
    //

    } else {

        Status = NtSetEaFile( Handles[FileHandleIndex].Handle,
                              IoStatusBlock,
                              Buffers[BufferIndex].Buffer,
                              BufferLength
                              ? *BufferLength
                              : Buffers[BufferIndex].Length );
    }

    if (VerboseResults) {

        printf( "\nSet Ea:  Status           -> %08lx\n", Status );

        if (NT_SUCCESS( Status )) {

            printf( "         Iosb.Information   -> %08lx\n", IoStatusBlock->Information );
            printf( "         Iosb.Status        -> %08lx", IoStatusBlock->Status );
        }

        printf( "\n" );
    }

    return IoStatusBlock->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\thandle.c ===
#include "brian.h"

VOID
DisplayHandle (
    IN USHORT Index
    );


VOID
InitHandles (
    )
{
    NtCreateEvent( &HandleEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Handles, sizeof( Handles ));
}


VOID
UninitHandles (
    )
{
    USHORT Index;

    //
    //  Close any handles.
    //

    for (Index = 0; Index < MAX_HANDLES; Index++) {

        if (Handles[Index].Used) {

            NtClose( Handles[Index].Handle );
        }
    }
}


NTSTATUS
ObtainIndex (
    OUT PUSHORT NewIndex
    )
{
    NTSTATUS Status;
    USHORT Index;

    //
    //  Wait for the handle event
    //

    if ((Status = NtWaitForSingleObject( HandleEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
    //  if not found.
    //

    for (Index = 0; Index < MAX_HANDLES; Index++) {

        if (!Handles[Index].Used) {

            break;
        }
    }

    if (Index >= MAX_HANDLES) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    //
    //  Otherwise reserve this handle index.
    //

    } else {

        Handles[Index].Used = TRUE;
        *NewIndex = Index;

        Status = STATUS_SUCCESS;
    }

    NtSetEvent( HandleEvent, NULL );

    return Status;
}


NTSTATUS
FreeIndex (
    IN USHORT Index
    )

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  Return immediately if beyond the end of the valid handles.
    //

    if (Index >= MAX_HANDLES) {

        return Status;
    }

    //
    //  Grab the event for the handles.
    //

    if ((Status = NtWaitForSingleObject( HandleEvent, FALSE, NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Mark the index as unused and close the file object if present.
    //

    if (Handles[Index].Handle) {

        Status = NtClose( Handles[Index].Handle );
    }

    if (Handles[Index].Used) {

        Handles[Index].Used = FALSE;
    }

    NtSetEvent( HandleEvent, NULL );

    return Status;
}


VOID
InputDisplayHandle (
    IN PCHAR ParamBuffer
    )
{
    ULONG Index;
    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    Index = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Index = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: di -i<digits> \n" );
        printf( "\n           -i<digits>   Handle index" );
        printf( "\n\n" );

    //
    //  Else call our copy buffer routine.
    //
    } else {

        DisplayHandle( (USHORT) Index );
    }

    return;
}


VOID
DisplayHandle (
    IN USHORT Index
    )

{
    printf( "\n" );
    printf( "\nIndex -> %04x,  Handle -> %p, Used -> %04x",
            Index,
            Handles[Index].Handle,
            Handles[Index].Used );
    printf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tevent.c ===
#include "brian.h"


VOID
InitEvents (
    )
{
    NtCreateEvent( &EventEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Events, sizeof( Events ));
}


VOID
UninitEvents (
    )
{
    USHORT Index;

    //
    //  Release any current events.
    //

    for (Index = 0; Index < MAX_EVENTS; Index++) {

        if (Events[Index].Used) {

            NtSetEvent( Events[Index].Handle, NULL );
        }
    }
}


NTSTATUS
ObtainEvent (
    OUT PUSHORT NewIndex
    )
{
    NTSTATUS Status;
    USHORT Index;

    //
    //  Wait for the handle event
    //

    if ((Status = NtWaitForSingleObject( EventEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
    //  if not found.
    //

    for (Index = 0; Index < MAX_EVENTS; Index++) {

        if (!Events[Index].Used) {

            break;
        }
    }

    if (Index >= MAX_EVENTS) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    //
    //  Otherwise reserve this event index.
    //

    } else {

        Status = NtCreateEvent( &Events[Index].Handle,
                                SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if (NT_SUCCESS( Status )) {

            Events[Index].Used = TRUE;
            *NewIndex = Index;
        }
    }

    NtSetEvent( EventEvent, NULL );

    return Status;
}


VOID
FreeEvent (
    IN USHORT Index
    )
{
    //
    //  Return immediately if beyond the end of the valid events.
    //

    if (Index >= MAX_EVENTS) {

        return;
    }

    //
    //  Grab the event for the events.
    //

    if (NtWaitForSingleObject( EventEvent, FALSE, NULL ) != STATUS_SUCCESS) {

        return;
    }

    //
    //  Mark the index as unused and release the event if held.
    //

    if (Events[Index].Used) {

        Events[Index].Used = FALSE;
        NtSetEvent( Events[Index].Handle, NULL );
    }

    NtSetEvent( EventEvent, NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tfsctrl.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestFsctrl (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputFsctrl(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputFsctrl:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputFsctrl:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_LOCK_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_UNLOCK_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_DISMOUNT_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = FSCTL_MARK_VOLUME_DIRTY;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            IoControlCode = FSCTL_IS_PATHNAME_VALID;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            IoControlCode = FSCTL_QUERY_RETRIEVAL_POINTERS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            IoControlCode = FSCTL_GET_COMPRESSION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'h' :
                        case 'H' :
                            IoControlCode = FSCTL_SET_COMPRESSION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'i' :
                        case 'I' :
                            IoControlCode = FSCTL_MARK_AS_SYSTEM_HIVE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'j' :
                        case 'J' :
                            IoControlCode = FSCTL_FILESYSTEM_GET_STATISTICS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'k' :
                        case 'K' :
                            IoControlCode = FSCTL_IS_VOLUME_DIRTY;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'l' :
                        case 'L' :
                            IoControlCode = FSCTL_GET_NTFS_VOLUME_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'm' :
                        case 'M' :
                            IoControlCode = FSCTL_GET_VOLUME_BITMAP;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'n' :
                        case 'N' :
                            IoControlCode = FSCTL_GET_NTFS_FILE_RECORD;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'o' :
                        case 'O' :
                            IoControlCode = FSCTL_MOVE_FILE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'p' :
                        case 'P' :
                            IoControlCode = FSCTL_ALLOW_EXTENDED_DASD_IO;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'q' :
                        case 'Q' :
                            IoControlCode = FSCTL_GET_RETRIEVAL_POINTERS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'r' :
                        case 'R' :

                            IoControlCode = FSCTL_SET_ENCRYPTION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 's' :
                        case 'S' :
                            IoControlCode = FSCTL_EXTEND_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 't' :
                        case 'T' :
                            IoControlCode = FSCTL_FIND_FILES_BY_SID;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'u' :
                        case 'U' :
                            IoControlCode = FSCTL_MARK_HANDLE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'v' :
                        case 'V' :
                            IoControlCode = FSCTL_FILE_PREFETCH;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: fsct -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Fsctrl operation" );
        printf( "\n                 -oa             Lock volume" );
        printf( "\n                 -ob             Unlock volume" );
        printf( "\n                 -oc             Dismount volume" );
        printf( "\n                 -od             Mark volume dirty" );
        printf( "\n                 -oe             Is pathname valid" );
        printf( "\n                 -of             Query retrieval pointers" );
        printf( "\n                 -og             Get compression" );
        printf( "\n                 -oh             Set compression" );
        printf( "\n                 -oi             Mark as system hive" );
        printf( "\n                 -oj             Get statistics" );
        printf( "\n                 -ok             Is volume dirty" );
        printf( "\n                 -ol             Get Ntfs volume data" );
        printf( "\n                 -om             Get volume bitmap" );
        printf( "\n                 -on             Get Ntfs file record" );
        printf( "\n                 -oo             Move file" );
        printf( "\n                 -op             Set Dasd IO" );
        printf( "\n                 -oq             Get retrieval pointers" );
        printf( "\n                 -or             Set encryption" );
        printf( "\n                 -os             Extend volume" );
        printf( "\n                 -ot             Query files by SID" );
        printf( "\n                 -ou             Mark handle" );
        printf( "\n                 -ov             File prefetch" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputFsctrl:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nFsctrl Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Fsctrl operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {
             
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestFsctrl,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputFsctrl:  Spawning thread fails -> %d\n", GetLastError() );
                }
            } else {

                RequestFsctrl( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestFsctrl (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestFsctrl:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestFsctrl:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tFsctrl:  Wait for event failed -> %08lx", Status );
                }
            }

            if (!NT_ERROR( Status )) {

                bprint  "\nRequestFsctrl:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestFsctrl:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestFsctrl:  Thread not terminated\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tmisc.c ===
#include "brian.h"

VOID
PrintLargeInteger (
    IN PLARGE_INTEGER LargeInt
    )
{
    printf( "%08lx:%08lx", LargeInt->HighPart, LargeInt->LowPart );
    return;
}

ULONG
AsciiToInteger (
    IN PCHAR Ascii
    )
{
    BOOLEAN DoHex = FALSE;
    LONG Integer = 0;
    PCHAR c;

    while (*Ascii) {

        if (Integer == 0 &&
            (*Ascii == 'x' || *Ascii == 'X')) {

            DoHex = TRUE;

        } else {
        
            if (DoHex) {

                *Ascii = (CHAR) toupper( *Ascii );

                if (*Ascii < '0' ||
                    (*Ascii > '9' &&
                     (*Ascii < 'A' || *Ascii > 'F'))) {

                    break;
                }

                Integer *= 16;
                Integer += ( *Ascii - ( *Ascii > '9' ? ('A' - 10) : '0' ));
                
            } else {

                if (*Ascii < '0' || *Ascii > '9') {

                    break;
                }

                Integer *= 10;
                Integer += (*Ascii - '0');
            }
        }

        Ascii++;
    }

    return Integer;
}

ULONGLONG
AsciiToLargeInteger (
    IN PCHAR Ascii
    )
{
    BOOLEAN DoHex = FALSE;
    ULONGLONG Integer = 0;
    PCHAR c;

    while (*Ascii) {

        if (Integer == 0 &&
            (*Ascii == 'x' || *Ascii == 'X')) {

            DoHex = TRUE;

        } else {
        
            if (DoHex) {

                *Ascii = (CHAR) toupper( *Ascii );

                if (*Ascii < '0' ||
                    (*Ascii > '9' &&
                     (*Ascii < 'A' || *Ascii > 'F'))) {

                    break;
                }

                Integer *= 16;
                Integer += ( *Ascii - ( *Ascii > '9' ? ('A' - 10) : '0' ));
                
            } else {

                if (*Ascii < '0' || *Ascii > '9') {

                    break;
                }

                Integer *= 10;
                Integer += (*Ascii - '0');
            }
        }

        Ascii++;
    }

    return Integer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tclose.c ===
#include "brian.h"

VOID
CloseIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    );


VOID
InputCloseIndex (
    IN PCHAR ParamBuffer
    )
{
    BOOLEAN Verbose;
    BOOLEAN HandleFound;
    BOOLEAN DisplayParms;
    ULONG ThisHandleIndex;

    //
    //  Set the defaults.
    //
    Verbose = TRUE;
    DisplayParms = FALSE;
    HandleFound = FALSE;

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Recover a handle.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ThisHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HandleFound = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Verbose = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Verbose = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

            } else {

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

            }

        //
        //  Else break.
        //
        } else {

            break;

        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !HandleFound ) {

        printf( "\n    Usage:  cl [options]*\n" );
        printf( "\n          Options:" );
        printf( "\n                    -i<index number>   Input a index to close" );
        printf( "\n                    -v[t|f]            Verbose mode for subsequent handles" );
        printf( "\n                    -y                 Display parameters before call" );
        printf( "\n\n" );

    } else {

        CloseIndex( (USHORT) ThisHandleIndex,
                    DisplayParms,
                    Verbose );
    }

    return;
}


VOID
CloseIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    )
{
    NTSTATUS Status;

    //
    //  Display parameters if requested.
    //

    if (DisplayParameters) {

        printf( "\nClose Index Parameters" );
        printf( "\n\tIndex      -> %04x", Index );
        printf( "\n\n" );
    }

    if (Index >= MAX_HANDLES) {

        printf( "\n\tClose Index:  Invalid index value" );
        Status = STATUS_INVALID_HANDLE;

    } else if (!Handles[Index].Used) {

        printf( "\n\tCloseIndex:   Index is unused" );
        Status = STATUS_INVALID_HANDLE;

    } else {

        Status = FreeIndex( Index );
        if (VerboseResults) {

            printf( "\n  FreeIndex:                  Status   -> %08lx\n\n", Status );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tdevctrl.c ===
#include "brian.h"

typedef struct _ASYNC_DEVCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_DEVCTRL, *PASYNC_DEVCTRL;


VOID
RequestDevCtrl (
    IN PASYNC_DEVCTRL DevCtrl
    );

//
//  Local procedures
//


VOID
InputDevctrl (
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputDevCtrl:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputDevCtrl:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = IOCTL_CDROM_DISK_TYPE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = IOCTL_CDROM_READ_TOC;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = IOCTL_DISK_EJECT_MEDIA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = IOCTL_STORAGE_EJECT_MEDIA;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: ioctl -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         DevCtrl operation" );
        printf( "\n                 -oa             Cdrom disk type" );
        printf( "\n                 -ob             Cdrom read TOC" );
        printf( "\n                 -oc             Disk eject media" );
        printf( "\n                 -od             Storage eject media" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_DEVCTRL AsyncDevCtrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_DEVCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputDevCtrl:  Unable to allocate async structure" );

        } else {

            AsyncDevCtrl = (PASYNC_DEVCTRL) Buffers[AsyncIndex].Buffer;

            AsyncDevCtrl->FileIndex = FileIndex;
            AsyncDevCtrl->UseEvent = UseEvent;
            AsyncDevCtrl->ApcRoutine = ApcRoutine;
            AsyncDevCtrl->ApcContext = ApcContext;
            AsyncDevCtrl->IoControlCode = IoControlCode;
            AsyncDevCtrl->InputBuffer = InputBuffer;
            AsyncDevCtrl->InputBufferLength = InputBufferLength;
            AsyncDevCtrl->OutputBuffer = OutputBuffer;
            AsyncDevCtrl->OutputBufferLength = OutputBufferLength;
            AsyncDevCtrl->VerboseResults = VerboseResults;
            AsyncDevCtrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nDevCtrl Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   DevCtrl operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestDevCtrl,
                                             AsyncDevCtrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputDevCtrl:  Spawning thread fails -> %d\n", GetLastError() );
                }
            } else {

                RequestDevCtrl( AsyncDevCtrl );
            }
        }
    }

    return;
}

VOID
RequestDevCtrl (
    IN PASYNC_DEVCTRL DevCtrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (DevCtrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestDevCtrl:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        Status = NtDeviceIoControlFile( Handles[DevCtrl->FileIndex].Handle,
                                        ThisEvent,
                                        DevCtrl->ApcRoutine,
                                        DevCtrl->ApcContext,
                                        &IoSb,
                                        DevCtrl->IoControlCode,
                                        DevCtrl->InputBuffer,
                                        DevCtrl->InputBufferLength,
                                        DevCtrl->OutputBuffer,
                                        DevCtrl->OutputBufferLength );

        if (DevCtrl->VerboseResults) {

            bprint  "\nRequestDevCtrl:  Status            -> %08lx\n", Status );

            if (DevCtrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tDevctrl:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestDevCtrl:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestDevCtrl:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( DevCtrl->AsyncIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestDevCtrl:  Thread not terminated\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tnotify.c ===
#include "brian.h"

typedef struct _ASYNC_NOTIFY {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_NOTIFY, *PASYNC_NOTIFY;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define LENGTH_DEFAULT              0
#define FILTER_DEFAULT              FILE_NOTIFY_CHANGE_FILE_NAME
#define WATCH_TREE_DEFAULT          FALSE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullNotify(
    IN OUT PASYNC_NOTIFY AsyncNotify
    );


VOID
InputNotifyChange(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = LENGTH_DEFAULT;
    CompletionFilter = FILTER_DEFAULT;
    WatchTree = WATCH_TREE_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we should watch the tree.
                //

                case 'w' :
                case 'W' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        WatchTree = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        WatchTree = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the completion filter.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_FILE_NAME;
                            break;

                        case 'b' :
                        case 'B' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_DIR_NAME;
                            break;

                        case 'c' :
                        case 'C' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
                            break;

                        case 'd' :
                        case 'D' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_SIZE;
                            break;

                        case 'e' :
                        case 'E' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
                            break;

                        case 'f' :
                        case 'F' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;
                            break;

                        case 'g' :
                        case 'G' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_CREATION;
                            break;

                        case 'h' :
                        case 'H' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_EA;
                            break;

                        case 'i' :
                        case 'I' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_SECURITY;
                            break;

                        case 'j' :
                        case 'J' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_NAME;
                            break;

                        case 'k' :
                        case 'K' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            break;

                        case 'l' :
                        case 'L' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_WRITE;
                            break;

                        case 'y' :
                        case 'Y' :

                            CompletionFilter = FILE_NOTIFY_VALID_MASK;
                            break;

                        case 'z' :
                        case 'Z' :

                            CompletionFilter = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: ncd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -b<digits>   Buffer to store results" );
        printf( "\n           -l<digits>   Stated length of buffer" );
        printf( "\n           -f<chars>    Completion filter" );
        printf( "\n           -w[t|f]      Watch directory tree" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our notify routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_NOTIFY AsyncNotify;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_NOTIFY );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputRead:  Unable to allocate async structure" );

        } else {

            AsyncNotify = (PASYNC_NOTIFY) Buffers[AsyncIndex].Buffer;

            AsyncNotify->FileIndex = (USHORT) FileIndex;
            AsyncNotify->UseEvent = UseEvent;
            AsyncNotify->ApcRoutine = ApcRoutine;
            AsyncNotify->ApcContext = ApcContext;


            AsyncNotify->BufferIndex = BufferIndex;
            AsyncNotify->BufferIndexPtr = BufferIndexPtr
                                          ? &AsyncNotify->BufferIndex
                                          : BufferIndexPtr;
            AsyncNotify->Length = Length;

            AsyncNotify->CompletionFilter = CompletionFilter;
            AsyncNotify->WatchTree = WatchTree;

            AsyncNotify->DisplayParms = DisplayParms;
            AsyncNotify->VerboseResults = VerboseResults;
            AsyncNotify->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullNotify,
                                             AsyncNotify,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputNotify:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }
            } else {

                FullNotify( AsyncNotify );
            }
        }
    }
    return;
}


VOID
FullNotify(
    IN OUT PASYNC_NOTIFY AsyncNotify
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindNotifyBuffer = FALSE;

    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncNotify->DisplayParms) {

        bprint  "\nNotify Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncNotify->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncNotify->BufferIndexPtr );
        if (AsyncNotify->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncNotify->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncNotify->Length );

        bprint  "\n   CompletionFilter        -> %08lx", AsyncNotify->CompletionFilter );
        bprint  "\n   WatchTree               -> %d", AsyncNotify->WatchTree );
        bprint  "\n   UseEvent                -> %d", AsyncNotify->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncNotify->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncNotify->ApcContext );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncNotify->BufferIndexPtr == NULL ) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullNotify:  Unable to allocate a notify buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullNotify:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindNotifyBuffer = TRUE;

            AsyncNotify->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncNotify->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullNotify:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncNotify->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullNotify:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncNotify->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullNotify:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtNotifyChangeDirectoryFile( Handles[AsyncNotify->FileIndex].Handle,
                                              ThisEvent,
                                              AsyncNotify->ApcRoutine,
                                              AsyncNotify->ApcContext,
                                              &Iosb,
                                              Buffers[ThisBufferIndex].Buffer,
                                              AsyncNotify->Length,
                                              AsyncNotify->CompletionFilter,
                                              AsyncNotify->WatchTree );

        if (AsyncNotify->VerboseResults) {

            bprint  "\nNotifyChangeDir:  Status            -> %08lx\n", Status );

            if (AsyncNotify->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tNotifyChangeDir:  Wait for event failed -> %08lx\n", Status );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nNotifyChangeDir:  Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\nNotifyChangeDir:  Iosb.Status       -> %08lx", Iosb.Status );
            }

            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncNotify->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\topen.c ===
#include "brian.h"

typedef struct _ASYNC_OPEN {

    ACCESS_MASK DesiredAccess;
    PLARGE_INTEGER AllocationSizePtr;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    PVOID EaBuffer;
    ULONG EaLength;
    STRING ObjectName;
    PUSHORT RootDirIndexPtr;
    USHORT RootDirIndex;
    ULONG Attributes;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    BOOLEAN DisplayParameters;
    BOOLEAN VerboseResults;
    BOOLEAN AnsiName;
    USHORT AsyncIndex;
    USHORT NameIndex;

} ASYNC_OPEN, *PASYNC_OPEN;

#define DESIRED_ACCESS_DEFAULT      (SYNCHRONIZE | GENERIC_READ)
#define ALLOCATION_SIZE_DEFAULT     0L
#define FILE_ATTRIBUTES_DEFAULT     FILE_ATTRIBUTE_NORMAL
#define SHARE_ACCESS_DEFAULT        FILE_SHARE_READ
#define CREATE_DISP_DEFAULT         FILE_OPEN
#define CREATE_OPTIONS_DEFAULT      FILE_SYNCHRONOUS_IO_ALERT
#define EA_LENGTH_DEFAULT           0L
#define ATTRIBUTES_DEFAULT          OBJ_CASE_INSENSITIVE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     TRUE
#define ANSI_NAME_DEFAULT           FALSE
#define EXACT_NAME_DEFAULT          FALSE

VOID
FullOpen (
    IN PASYNC_OPEN AsyncOpen
    );


VOID
InputOpenFile (
    IN PCHAR ParamBuffer
    )
{
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER AllocationSize;
    PLARGE_INTEGER AllocationSizePtr;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    PVOID EaBuffer;
    USHORT BufferIndex;
    ULONG EaLength;
    STRING ObjectName;
    USHORT NameIndex;
    PUSHORT RootDirIndexPtr;
    USHORT RootDirIndex;
    ULONG Attributes;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    BOOLEAN DisplayParameters;
    BOOLEAN VerboseResults;
    BOOLEAN AnsiName;
    BOOLEAN ExactName;
    BOOLEAN FileNameFound;
    BOOLEAN LastInput;
    BOOLEAN NameIndexAllocated;
    PUCHAR FileName;
    USHORT AsyncIndex;

    //
    //  Set the defaults for the open and the return values.
    //

    DesiredAccess = DESIRED_ACCESS_DEFAULT;
    AllocationSize = RtlConvertUlongToLargeInteger( ALLOCATION_SIZE_DEFAULT );
    AllocationSizePtr = NULL;
    FileAttributes = FILE_ATTRIBUTES_DEFAULT;
    ShareAccess = SHARE_ACCESS_DEFAULT;
    CreateDisposition = CREATE_DISP_DEFAULT;
    CreateOptions = CREATE_OPTIONS_DEFAULT;
    EaBuffer = NULL;
    EaLength = EA_LENGTH_DEFAULT;
    ObjectName.MaximumLength = 256;
    ObjectName.Length = 256;
    RootDirIndexPtr = NULL;
    RootDirIndex = 0;
    Attributes = ATTRIBUTES_DEFAULT;
    SecurityDescriptor = NULL;
    SecurityQualityOfService = NULL;
    DisplayParameters = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AnsiName = ANSI_NAME_DEFAULT;
    ExactName = EXACT_NAME_DEFAULT;

    NameIndexAllocated = FALSE;
    FileNameFound = FALSE;
    LastInput = TRUE;

    {
        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        RegionSize = 1024;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        if (!NT_SUCCESS( Status )) {

            printf("InputOpenFile:  Can't allocate name index buffer\n" );
            return;
        }

        NameIndexAllocated = TRUE;
        NameIndex = (USHORT) TempIndex;
        ObjectName.Buffer = Buffers[NameIndex].Buffer;
    }

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the file attributes.
                //
                case 'a' :
                case 'A' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            FileAttributes |= FILE_ATTRIBUTE_READONLY;
                            break;

                        case 'b' :
                        case 'B' :
                            FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
                            break;

                        case 'c' :
                        case 'C' :
                            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                            break;

                        case 'e' :
                        case 'E' :
                            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                            break;

                        case 'f' :
                        case 'F' :
                            FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                            break;

                        case 'g' :
                        case 'G' :
                            FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            break;

                        case 'h' :
                        case 'H' :
                            FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            break;

                        case 'i' :
                        case 'I' :
                            FileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
                            break;

                        case 'j' :
                        case 'J' :
                            FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;
                            break;

                        case 'k' :
                        case 'K' :
                            FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                            break;

                        case 'l' :
                        case 'L' :
                            FileAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                            break;

                        case 'm' :
                        case 'M' :
                            FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
                            break;

                        case 'n' :
                        case 'N' :
                            FileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
                            break;

                        case 'z' :
                        case 'Z' :
                            FileAttributes = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    if (BufferIndex <= MAX_BUFFERS) {

                        EaBuffer = Buffers[BufferIndex].Buffer;
                        EaLength = Buffers[BufferIndex].Length;

                    }

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    EaLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the desired access.
                //
                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            DesiredAccess |= FILE_READ_DATA;
                            break;

                        case 'b' :
                        case 'B' :

                            DesiredAccess |= FILE_WRITE_DATA;
                            break;

                        case 'c' :
                        case 'C' :

                            DesiredAccess |= FILE_APPEND_DATA;
                            break;

                        case 'd' :
                        case 'D' :

                            DesiredAccess |= FILE_READ_EA;
                            break;

                        case 'e' :
                        case 'E' :

                            DesiredAccess |= FILE_WRITE_EA;
                            break;

                        case 'f' :
                        case 'F' :

                            DesiredAccess |= FILE_EXECUTE;
                            break;

                        case 'g' :
                        case 'G' :

                            DesiredAccess |= FILE_DELETE_CHILD;
                            break;

                        case 'h' :
                        case 'H' :

                            DesiredAccess |= FILE_READ_ATTRIBUTES;
                            break;

                        case 'i' :
                        case 'I' :

                            DesiredAccess |= FILE_WRITE_ATTRIBUTES;
                            break;

                        case 'j' :
                        case 'J' :

                            DesiredAccess |= FILE_ALL_ACCESS;
                            break;

                        case 'k' :
                        case 'K' :

                            DesiredAccess |= SYNCHRONIZE;
                            break;

                        case 'l' :
                        case 'L' :

                            DesiredAccess |= DELETE;
                            break;

                        case 'm' :
                        case 'M' :

                            DesiredAccess |= READ_CONTROL;
                            break;

                        case 'n' :
                        case 'N' :

                            DesiredAccess |= WRITE_DAC;
                            break;

                        case 'o' :
                        case 'O' :

                            DesiredAccess |= WRITE_OWNER;
                            break;

                        case 'p' :
                        case 'P' :

                            DesiredAccess |= GENERIC_READ;
                            break;

                        case 'q' :
                        case 'Q' :

                            DesiredAccess |= GENERIC_WRITE;
                            break;

                        case 'r' :
                        case 'R' :

                            DesiredAccess |= GENERIC_EXECUTE;
                            break;

                        case 's' :
                        case 'S' :

                            DesiredAccess |= GENERIC_ALL;
                            break;

                        case 't' :

                            DesiredAccess |= MAXIMUM_ALLOWED;
                            break;

                        case 'z' :
                        case 'Z' :

                            DesiredAccess = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the filename.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    FileName = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ULONG ObjectNameIncrement = 0;

                        //
                        //  If the first character is a backslash then
                        //  we add the full 'dosdevices' prefix.
                        //

                        FileNameFound = TRUE;

                        if (!ExactName) {

                            if (*FileName == '\\') {

                                ObjectNameIncrement = sizeof( "DosDevices" );

                                RtlMoveMemory( ObjectName.Buffer,
                                               "\\DosDevices",
                                               sizeof( "\\DosDevices" ));
                            }
                        }

                        ObjectName.Length = (SHORT) (DummyCount + ObjectNameIncrement);

                        RtlMoveMemory( &ObjectName.Buffer[ObjectNameIncrement],
                                       FileName,
                                       DummyCount );

                    } else {

                        ULONG ObjectNameIncrement = 0;

                        FileNameFound = TRUE;

                        ObjectName.Length = (SHORT) (DummyCount + ObjectNameIncrement);
                    }

                    break;

                //
                //  Update the file Id.
                //

                case 'i' :
                case 'I' :

                    {
                        PLARGE_INTEGER FileId;
                        FileId = (PLARGE_INTEGER) ObjectName.Buffer;

                        //
                        //  Move to the next character, as long as there
                        //  are no white spaces continue analyzing letters.
                        //  On the first bad letter, skip to the next
                        //  parameter.
                        //

                        ParamBuffer++;

                        if (*ParamBuffer == '\0') {

                                break;
                        }

                        switch (*ParamBuffer) {

                        case 'l':
                        case 'L':

                            FileId->LowPart = AsciiToInteger( ++ParamBuffer );
                            ObjectName.Length = sizeof( LARGE_INTEGER );

                            break;

                        case 'h':
                        case 'H':

                            FileId->HighPart = AsciiToInteger( ++ParamBuffer );
                            ObjectName.Length = sizeof( LARGE_INTEGER );

                            break;
                        }

                        FileNameFound = TRUE;

                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        break;
                    }

                //
                //  Update the share access field.
                //
                case 'h' :
                case 'H' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            ShareAccess |= FILE_SHARE_READ;
                            break;

                        case 'b' :
                        case 'B' :

                            ShareAccess |= FILE_SHARE_WRITE;
                            break;

                        case 'c' :
                        case 'C' :

                            ShareAccess |= FILE_SHARE_DELETE;
                            break;

                        case 'z' :
                        case 'Z' :

                            ShareAccess = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the create options.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch( *ParamBuffer ) {

                        case 'a' :
                        case 'A' :

                            CreateOptions |= FILE_DIRECTORY_FILE;
                            break;

                        case 'b' :
                        case 'B' :

                            CreateOptions |= FILE_WRITE_THROUGH;
                            break;

                        case 'c' :
                        case 'C' :

                            CreateOptions |= FILE_SEQUENTIAL_ONLY;
                            break;

                        case 'd' :
                        case 'D' :

                            CreateOptions |= FILE_NO_INTERMEDIATE_BUFFERING;
                            break;

                        case 'e' :
                        case 'E' :

                            CreateOptions |= FILE_SYNCHRONOUS_IO_ALERT;
                            break;

                        case 'f' :
                        case 'F' :

                            CreateOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
                            break;

                        case 'g' :
                        case 'G' :

                            CreateOptions |= FILE_NON_DIRECTORY_FILE;
                            break;

                        case 'h' :
                        case 'H' :

                            CreateOptions |= FILE_CREATE_TREE_CONNECTION;
                            break;

                        case 'i' :
                        case 'I' :

                            CreateOptions |= FILE_COMPLETE_IF_OPLOCKED;
                            break;

                        case 'j' :
                        case 'J' :

                            CreateOptions |= FILE_OPEN_BY_FILE_ID;
                            break;

                        case 'k' :
                        case 'K' :

                            CreateOptions |= FILE_NO_EA_KNOWLEDGE;
                            break;

                        case 'l' :
                        case 'L' :

                            CreateOptions |= FILE_DELETE_ON_CLOSE;
                            break;

                        case 'm' :
                        case 'M' :

                            CreateOptions |= FILE_RESERVE_OPFILTER;
                            break;

                        case 'n' :
                        case 'N' :

                            CreateOptions |= FILE_OPEN_REPARSE_POINT;
                            break;

                        case 'o' :
                        case 'O' :

                            CreateOptions |= FILE_NO_COMPRESSION;
                            break;

                        case 'p' :
                        case 'P' :

                            CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
                            break;

                        case 'z' :
                        case 'Z' :

                            CreateOptions = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            Attributes |= OBJ_INHERIT;
                            break;

                        case 'b' :
                        case 'B' :

                            Attributes |= OBJ_PERMANENT;
                            break;

                        case 'c' :
                        case 'C' :

                            Attributes |= OBJ_EXCLUSIVE;
                            break;

                        case 'd' :
                        case 'D' :

                            Attributes |= OBJ_CASE_INSENSITIVE;
                            break;

                        case 'e' :
                        case 'E' :

                            Attributes |= OBJ_OPENIF;
                            break;

                        case 'z' :
                        case 'Z' :

                            Attributes = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the create disposition.
                //
                case 'p' :
                case 'P' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            CreateDisposition |= FILE_SUPERSEDE;
                            break;

                        case 'b' :
                        case 'B' :

                            CreateDisposition |= FILE_OPEN;
                            break;

                        case 'c' :
                        case 'C' :

                            CreateDisposition |= FILE_CREATE;
                            break;

                        case 'd' :
                        case 'D' :

                            CreateDisposition |= FILE_OPEN_IF;
                            break;

                        case 'e' :
                        case 'E' :

                            CreateDisposition |= FILE_OVERWRITE;
                            break;

                        case 'f' :
                        case 'F' :

                            CreateDisposition |= FILE_OVERWRITE_IF;
                            break;

                        case 'z' :
                        case 'Z' :

                            CreateDisposition = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if( !SwitchBool ) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Get a root directory handle.
                //
                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    RootDirIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    if( RootDirIndex <= MAX_HANDLES ) {

                        RootDirIndexPtr = &RootDirIndex;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the allocation size.
                //
                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    AllocationSize.QuadPart = AsciiToLargeInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    AllocationSizePtr = &AllocationSize;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Check for using name exactly as given.
                //

                case 'x' :
                case 'X' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        ExactName = TRUE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        ExactName = FALSE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Check for unicode or ansi file names.
                //

                case 'u' :
                case 'U' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        AnsiName = FALSE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        AnsiName = TRUE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParameters = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !FileNameFound ) {

        printf( "\n    Usage:  op [options]* -f<filename> | -i[l|h]<fileId> [options]*\n" );
        printf( "          Options:\n" );
        printf( "                    -f<filename>       Name of file to open\n" );
        printf( "                    -il<digits>        Low 32 bits of file id\n" );
        printf( "                    -ih<digits>        High 32 bits of file id\n" );
        printf( "                    -x[t|f]            Use name exactly (don't add \\DosDevices)\n" );
        printf( "                    -u[t|f]            Use unicode names \n" );
        printf( "                    -v[t|f]            Print out results\n" );
        printf( "                    -z                 Get additional input\n" );
        printf( "                    -y                 Display create parameters\n" );
        printf( "                    -b<digits>         Buffer index for Ea's\n" );
        printf( "                    -l<digits>         Stated length of Ea buffer\n" );
        printf( "                    -d<chars>          Modify Desired Access value\n" );
        printf( "                    -r<digits>         Relative directory handle index\n" );
        printf( "                    -o<chars>          Object Attributes\n" );
        printf( "                    -s<digits>         Allocation size\n" );
        printf( "                    -a<chars>          File Attribute values\n" );
        printf( "                    -h<chars>          Share Access values\n" );
        printf( "                    -p<chars>          Create Disposition values\n" );
        printf( "                    -n<chars>          Create Options values\n" );
        printf( "\n\n" );

        DeallocateBuffer( NameIndex );

    //
    //  Else return the status of opening the file.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_OPEN AsyncOpen;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_OPEN );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\tInputOpen:  Unable to allocate async structure\n" );
            DeallocateBuffer( NameIndex );

        } else {

            AsyncOpen = (PASYNC_OPEN) Buffers[AsyncIndex].Buffer;

            AsyncOpen->DesiredAccess = DesiredAccess;
            AsyncOpen->AllocationSize = AllocationSize;
            AsyncOpen->AllocationSizePtr = AllocationSizePtr
                                           ? &AsyncOpen->AllocationSize
                                           : NULL;
            AsyncOpen->FileAttributes = FileAttributes;
            AsyncOpen->ShareAccess = ShareAccess;
            AsyncOpen->CreateDisposition = CreateDisposition;
            AsyncOpen->CreateOptions = CreateOptions;
            AsyncOpen->EaBuffer = EaBuffer;
            AsyncOpen->EaLength = EaLength;
            AsyncOpen->ObjectName = ObjectName;
            AsyncOpen->RootDirIndex = RootDirIndex;
            AsyncOpen->RootDirIndexPtr = RootDirIndexPtr
                                         ? &AsyncOpen->RootDirIndex
                                         : NULL;
            AsyncOpen->Attributes = Attributes;
            AsyncOpen->SecurityDescriptor = SecurityDescriptor;
            AsyncOpen->SecurityQualityOfService = SecurityQualityOfService;
            AsyncOpen->DisplayParameters = DisplayParameters;
            AsyncOpen->VerboseResults = VerboseResults;
            AsyncOpen->AnsiName = AnsiName;
            AsyncOpen->AsyncIndex = AsyncIndex;
            AsyncOpen->NameIndex = NameIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullOpen,
                                             AsyncOpen,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputOpen:  Spawning thread fails -> %d\n", GetLastError() );
                    DeallocateBuffer( NameIndex );
                    DeallocateBuffer( AsyncIndex );
                    return;
                }

            } else {

                FullOpen( AsyncOpen );
            }
        }
    }

    return;
}


VOID
FullOpen (
    IN PASYNC_OPEN AsyncOpen
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeName;
    PUNICODE_STRING NameString;

    USHORT ThisIndex;

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = 0;

    //
    //  Check that the relative index is a valid value.
    //

    if (AsyncOpen->RootDirIndexPtr != NULL) {

        if (AsyncOpen->RootDirIndex >= MAX_HANDLES) {

            bprint  "\n" );
            bprint  "Relative index is invalid\n" );
            DeallocateBuffer( AsyncOpen->AsyncIndex );
            DeallocateBuffer( AsyncOpen->NameIndex );
            return;
        }

        ObjectAttributes.RootDirectory = Handles[AsyncOpen->RootDirIndex].Handle;

    } else {

        ObjectAttributes.RootDirectory = 0;
    }

    //
    //  Find a free index.
    //

    if (ObtainIndex( &ThisIndex ) != STATUS_SUCCESS) {

        bprint  "\n" );
        bprint  "Unable to get a new handle index \n" );
        return;
    }

    if (AsyncOpen->AnsiName
        || FlagOn( AsyncOpen->CreateOptions, FILE_OPEN_BY_FILE_ID )) {

        NameString = (PUNICODE_STRING) &AsyncOpen->ObjectName;

    } else {

        RtlAnsiStringToUnicodeString( &UnicodeName,
                                      &AsyncOpen->ObjectName,
                                      TRUE );

        NameString = &UnicodeName;
    }

    ObjectAttributes.Length = sizeof( OBJECT_ATTRIBUTES );
    ObjectAttributes.ObjectName = NameString;
    ObjectAttributes.SecurityDescriptor = AsyncOpen->SecurityDescriptor;
    ObjectAttributes.SecurityQualityOfService = AsyncOpen->SecurityQualityOfService;
    ObjectAttributes.Attributes = AsyncOpen->Attributes;

    if (AsyncOpen->DisplayParameters) {

        bprint  "\n" );
        bprint  "  CallOpenFile Parameters\n" );
        bprint  "\n" );
        bprint  "      DesiredAccess              -> %08lx\n", AsyncOpen->DesiredAccess );

        if (FlagOn( AsyncOpen->CreateOptions, FILE_OPEN_BY_FILE_ID )) {

            PLARGE_INTEGER FileId;

            FileId = (PLARGE_INTEGER) AsyncOpen->ObjectName.Buffer;

            bprint  "      FileId.LowPart             -> %08lx\n", FileId->LowPart );
            bprint  "      FileId.HighPart            -> %08lx\n", FileId->HighPart );

        } else {

            bprint  "      Filename                   -> %s\n", AsyncOpen->ObjectName.Buffer );
            bprint  "      FileNameLen                -> %ld\n", AsyncOpen->ObjectName.Length );
        }

        bprint  "      RootDirectoryIndexPtr      -> %ld\n", AsyncOpen->RootDirIndexPtr );
        if (AsyncOpen->RootDirIndexPtr != NULL) {

            bprint  "      RootDirectoryIndex         -> %ld\n", AsyncOpen->RootDirIndex );

        }
        bprint  "      SecurityDescriptor         -> %lx\n", AsyncOpen->SecurityDescriptor );
        bprint  "      SecurityQualityOfService   -> %lx\n", AsyncOpen->SecurityQualityOfService );
        bprint  "      Attributes                 -> %08lx\n", AsyncOpen->Attributes );
        bprint  "      AllocationSizePtr          -> %lx\n", AsyncOpen->AllocationSizePtr );

        if (AsyncOpen->AllocationSizePtr) {
            bprint  "      AllocationSize.LowPart     -> %lx\n", AsyncOpen->AllocationSize.LowPart );
            bprint  "      AllocationSize.HighPart    -> %lx\n", AsyncOpen->AllocationSize.HighPart );

        }
        bprint  "      FileAttributes             -> %08lx\n", AsyncOpen->FileAttributes );
        bprint  "      ShareAccess                -> %08lx\n", AsyncOpen->ShareAccess );
        bprint  "      CreateDisposition          -> %08lx\n", AsyncOpen->CreateDisposition );
        bprint  "      CreateOptions              -> %08lx\n", AsyncOpen->CreateOptions );
        bprint  "      EaBuffer                   -> %lx\n", AsyncOpen->EaBuffer );
        bprint  "      EaLength                   -> %ld\n", AsyncOpen->EaLength );
        bprint  "      AnsiName                   -> %04x\n", AsyncOpen->AnsiName );
        bprint  "\n" );
    }

    Status = NtCreateFile( &Handles[ThisIndex].Handle,
                           AsyncOpen->DesiredAccess,
                           &ObjectAttributes,
                           &Iosb,
                           AsyncOpen->AllocationSizePtr,
                           AsyncOpen->FileAttributes,
                           AsyncOpen->ShareAccess,
                           AsyncOpen->CreateDisposition,
                           AsyncOpen->CreateOptions,
                           AsyncOpen->EaBuffer,
                           AsyncOpen->EaLength );

    if (AsyncOpen->VerboseResults) {

        bprint  "\n" );
        bprint  "  OpenFile:                   Status   -> %08lx\n", Status );
        bprint  "\n" );
        bprint  "                      File Handle      -> 0x%lx\n", Handles[ThisIndex].Handle );
        bprint  "                      File HandleIndex -> %ld\n", ThisIndex );

        if (NT_SUCCESS( Status )) {

            bprint  "                      Io.Status        -> %08lx\n", Iosb.Status );
            bprint  "                      Io.Info          -> %08lx\n", Iosb.Information );
        }
        bprint "\n" );
    }

    if (!NT_SUCCESS( Status )) {

        FreeIndex( ThisIndex );
    }

    DeallocateBuffer( AsyncOpen->NameIndex );
    if (!AsyncOpen->AnsiName) {

        RtlFreeUnicodeString( &UnicodeName );
    }
    DeallocateBuffer( AsyncOpen->AsyncIndex );
    NtTerminateThread( 0, STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tqfile.c ===
#include "brian.h"

typedef struct _ASYNC_QFILE {

    USHORT FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_QFILE, *PASYNC_QFILE;

#define QFILE_LENGTH_DEFAULT        100
#define FILE_INFO_CLASS_DEFAULT     FileAllInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT       0

VOID
FullQFile(
    IN OUT PASYNC_QFILE AsyncQFile
    );

VOID
DisplayQFileBasicInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileStandardInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileInternalInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileEaInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAccessInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileNameInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFilePositionInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileModeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAlignmentInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAllInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileStreamInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAlternateNameInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileNetworkQueryInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayBasicInformation (
    IN PFILE_BASIC_INFORMATION FileInfo
    );

VOID
DisplayStandardInformation (
    IN PFILE_STANDARD_INFORMATION FileInfo
    );

VOID
DisplayInternalInformation (
    IN PFILE_INTERNAL_INFORMATION FileInfo
    );

VOID
DisplayEaInformation (
    IN PFILE_EA_INFORMATION FileInfo
    );

VOID
DisplayAccessInformation (
    IN PFILE_ACCESS_INFORMATION FileInfo
    );

VOID
DisplayNameInformation (
    IN PFILE_NAME_INFORMATION FileInfo
    );

VOID
DisplayPositionInformation (
    IN PFILE_POSITION_INFORMATION FileInfo
    );

VOID
DisplayModeInformation (
    IN PFILE_MODE_INFORMATION FileInfo
    );

VOID
DisplayAlignmentInformation (
    IN PFILE_ALIGNMENT_INFORMATION FileInfo
    );

VOID
DisplayStreamInformation (
    IN PFILE_STREAM_INFORMATION FileInfo
    );

VOID
DisplayNetworkOpenInformation (
    IN PFILE_NETWORK_OPEN_INFORMATION FileInfo
    );


VOID
InputQFile (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QFILE_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the information class.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileStandardInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileInternalInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileEaInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileAccessInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileNameInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileAlignmentInformation;
                            break;

                        case 'j' :
                        case 'J' :

                            FileInfoClass = FileAllInformation;
                            break;

                        case 'k' :
                        case 'K' :

                            FileInfoClass = FileStreamInformation;
                            break;

                        case 'l' :
                        case 'L' :

                            FileInfoClass = FileAlternateNameInformation;
                            break;

                        case 'm' :
                        case 'M' :

                            FileInfoClass = FileNetworkOpenInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qf [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QFILE AsyncQFile;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QFILE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQFile:  Unable to allocate async structure" );

        } else {

            AsyncQFile = (PASYNC_QFILE) Buffers[AsyncIndex].Buffer;

            AsyncQFile->FileIndex = (USHORT) FileIndex;

            AsyncQFile->BufferIndex = BufferIndex;
            AsyncQFile->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncQFile->BufferIndex
                                        : BufferIndexPtr;
            AsyncQFile->Length = Length;
            AsyncQFile->FileInfoClass = FileInfoClass;
            AsyncQFile->DisplayParms = DisplayParms;
            AsyncQFile->VerboseResults = VerboseResults;
            AsyncQFile->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQFile,
                                             AsyncQFile,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQFile:  Spawning thread fails -> %d\n", GetLastError() );

                    DeallocateBuffer( AsyncIndex );

                    return;
                }
            } else {

                FullQFile( AsyncQFile );
            }
        }
    }

    return;
}


VOID
FullQFile(
    IN OUT PASYNC_QFILE AsyncQFile
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    USHORT ThisBufferIndex;

    BOOLEAN UnwindQFileBuffer = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQFile->DisplayParms) {

        bprint  "\nQFile Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncQFile->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncQFile->BufferIndexPtr );
        if (AsyncQFile->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncQFile->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncQFile->Length );

        bprint  "\n   FileInfoClass           -> %08lx", AsyncQFile->FileInfoClass );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQFile->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullQFile:  Unable to allocate a query buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullQFile:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindQFileBuffer = TRUE;

            AsyncQFile->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQFile->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullQFile:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQFile->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullQFile:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Call the query file routine.
        //

        Status = NtQueryInformationFile( Handles[AsyncQFile->FileIndex].Handle,
                                         &Iosb,
                                         Buffers[ThisBufferIndex].Buffer,
                                         AsyncQFile->Length,
                                         AsyncQFile->FileInfoClass );

        UnwindQFileBuffer = FALSE;

        if (AsyncQFile->VerboseResults) {

            bprint  "\nQuery File:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n             Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n             Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQFileBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        DeallocateBuffer( AsyncQFile->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}


VOID
InputDisplayQFile (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileStandardInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileInternalInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileEaInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileAccessInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileNameInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileAlignmentInformation;
                            break;

                        case 'j' :
                        case 'J' :

                            FileInfoClass = FileAllInformation;
                            break;

                        case 'k' :
                        case 'K' :

                            FileInfoClass = FileStreamInformation;
                            break;

                        case 'l' :
                        case 'L' :

                            FileInfoClass = FileAlternateNameInformation;
                            break;

                        case 'm' :
                        case 'M' :

                            FileInfoClass = FileNetworkOpenInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqf [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileBasicInformation:

                DisplayQFileBasicInformation( (USHORT) BufferIndex );
                break;

            case FileStandardInformation:

                DisplayQFileStandardInformation( (USHORT) BufferIndex );
                break;

            case FileInternalInformation:

                DisplayQFileInternalInformation( (USHORT) BufferIndex );
                break;

            case FileEaInformation:

                DisplayQFileEaInformation( (USHORT) BufferIndex );
                break;

            case FileAccessInformation:

                DisplayQFileAccessInformation( (USHORT) BufferIndex );
                break;

            case FileNameInformation:

                DisplayQFileNameInformation( (USHORT) BufferIndex );
                break;

            case FilePositionInformation:

                DisplayQFilePositionInformation( (USHORT) BufferIndex );
                break;

            case FileModeInformation:

                DisplayQFileModeInformation( (USHORT) BufferIndex );
                break;

            case FileAlignmentInformation:

                DisplayQFileAlignmentInformation( (USHORT) BufferIndex );
                break;

            case FileAllInformation:

                DisplayQFileAllInformation( (USHORT) BufferIndex );
                break;

            case FileStreamInformation:

                DisplayQFileStreamInformation( (USHORT) BufferIndex );
                break;

            case FileAlternateNameInformation:

                DisplayQFileAlternateNameInformation( (USHORT) BufferIndex );
                break;

            case FileNetworkOpenInformation:

                DisplayQFileNetworkQueryInformation( (USHORT) BufferIndex );
                break;
        }
    }

}

VOID
DisplayQFileBasicInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_BASIC_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileBasicInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_BASIC_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nBasic File Information\n" );

        DisplayBasicInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileBasicInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileStandardInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_STANDARD_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileStandardInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_STANDARD_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nStandard File Information\n" );

        DisplayStandardInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileStandardInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileInternalInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_INTERNAL_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileInternalInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_INTERNAL_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nInternal File Information\n" );

        DisplayInternalInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileInternalInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileEaInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_EA_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileEaInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_EA_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nEa File Information\n" );

        DisplayEaInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileEaInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAccessInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ACCESS_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAccessInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ACCESS_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAccess File Information\n" );

        DisplayAccessInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAccessInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileNameInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NAME_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileNameInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nName File Information\n" );

        DisplayNameInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileNameInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFilePositionInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_POSITION_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFilePositionInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_POSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nPosition File Information\n" );

        DisplayPositionInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFilePositionInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileModeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_MODE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileModeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_MODE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nMode File Information\n" );

        DisplayModeInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileModeInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAlignmentInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ALIGNMENT_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAlignmentInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ALIGNMENT_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAlignment File Information\n" );

        DisplayAlignmentInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAlignmentInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAllInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ALL_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAllInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ALL_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAll File Information\n" );

        DisplayNameInformation( &FileInfo->NameInformation );
        DisplayBasicInformation( &FileInfo->BasicInformation );
        DisplayStandardInformation( &FileInfo->StandardInformation );
        DisplayInternalInformation( &FileInfo->InternalInformation );
        DisplayEaInformation( &FileInfo->EaInformation );
        DisplayAccessInformation( &FileInfo->AccessInformation );
        DisplayPositionInformation( &FileInfo->PositionInformation );
        DisplayModeInformation( &FileInfo->ModeInformation );
        DisplayAlignmentInformation( &FileInfo->AlignmentInformation );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileBasicInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileStreamInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_STREAM_INFORMATION FileInfo;
    ULONG NextOffset;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileStreamInformation:  Invalid buffer\n" );
        return;
    }

    try {

        NextOffset = 0;
        FileInfo = (PFILE_STREAM_INFORMATION) Buffers[BufferIndex].Buffer;


        printf( "\n\nStream File Information\n" );

        do {

            FileInfo = (PFILE_STREAM_INFORMATION) ((PUCHAR) FileInfo + NextOffset);

            DisplayStreamInformation( FileInfo );

            NextOffset = FileInfo->NextEntryOffset;

        } while ( NextOffset );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileStreamInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAlternateNameInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NAME_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAlternateNameInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAlternate Name File Information\n" );

        DisplayNameInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAlternateNameInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileNetworkQueryInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NETWORK_OPEN_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileNetworkQueryInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NETWORK_OPEN_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nNetwork Open File Information\n" );

        DisplayNetworkOpenInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileNetworkOpenInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayBasicInformation (
    IN PFILE_BASIC_INFORMATION FileInfo
    )
{
    printf( "\n\tCreation Time    -> " );
    PrintTime( &FileInfo->CreationTime );
    printf( "\n\tLast Access Time -> " );
    PrintTime( &FileInfo->LastAccessTime );
    printf( "\n\tLast Write Time  -> " );
    PrintTime( &FileInfo->LastWriteTime );
    printf( "\n\tChange Time      -> " );
    PrintTime( &FileInfo->ChangeTime );
    printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );

    return;
}

VOID
DisplayStandardInformation (
    IN PFILE_STANDARD_INFORMATION FileInfo
    )
{
    printf( "\n\tAllocation Size  -> " );
    PrintLargeInteger( &FileInfo->AllocationSize );
    printf( "\n\tEnd Of File      -> " );
    PrintLargeInteger( &FileInfo->EndOfFile );
    printf( "\n\tNumber of Links  -> %08lx", FileInfo->NumberOfLinks );
    printf( "\n\tDelete Pending   -> %04x", FileInfo->DeletePending );
    printf( "\n\tDirectory        -> %d", FileInfo->Directory );

    return;
}

VOID
DisplayInternalInformation (
    IN PFILE_INTERNAL_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Index.LowPart     -> %08lx", FileInfo->IndexNumber.LowPart );
    printf( "\n\tFile Index.HighPart    -> %08lx", FileInfo->IndexNumber.HighPart );

    printf( "\n\n\tFile Index.LowPart     -> %ld", FileInfo->IndexNumber.LowPart );
    printf( "\n\tFile Index.HighPart    -> %ld", FileInfo->IndexNumber.HighPart );

    return;
}

VOID
DisplayEaInformation (
    IN PFILE_EA_INFORMATION FileInfo
    )
{
    printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );

    return;
}

VOID
DisplayAccessInformation (
    IN PFILE_ACCESS_INFORMATION FileInfo
    )
{
    printf( "\n\tAccess Flags     -> %08lx", FileInfo->AccessFlags );

    return;
}

VOID
DisplayNameInformation (
    IN PFILE_NAME_INFORMATION FileInfo
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    UnicodeString.MaximumLength =
    UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
    UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

    UnicodeString.MaximumLength += 2;

    RtlUnicodeStringToAnsiString( &AnsiString,
                                  &UnicodeString,
                                  TRUE );

    printf( "\n\tFile Name        -> %s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );

    return;
}

VOID
DisplayPositionInformation (
    IN PFILE_POSITION_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Position    -> " );
    PrintLargeInteger( &FileInfo->CurrentByteOffset );

    return;
}

VOID
DisplayModeInformation (
    IN PFILE_MODE_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Mode        -> %08lx", FileInfo->Mode );

    return;
}

VOID
DisplayAlignmentInformation (
    IN PFILE_ALIGNMENT_INFORMATION FileInfo
    )
{
    printf( "\n\tAlignment        -> %08lx", FileInfo->AlignmentRequirement );

    return;
}

VOID
DisplayStreamInformation (
    IN PFILE_STREAM_INFORMATION FileInfo
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    printf( "\n\tStreamSize           -> " );
    PrintLargeInteger( &FileInfo->StreamSize );
    printf( "\n\tStreamAllocationSize -> " );
    PrintLargeInteger( &FileInfo->StreamAllocationSize );
    printf( "\n\tStreamNameLength     -> %08lx", FileInfo->StreamNameLength );

    UnicodeString.MaximumLength = (USHORT) FileInfo->StreamNameLength + 2;
    UnicodeString.Length = (USHORT) FileInfo->StreamNameLength;
    UnicodeString.Buffer = (PWSTR) &FileInfo->StreamName;

    RtlUnicodeStringToAnsiString( &AnsiString,
                                  &UnicodeString,
                                  TRUE );

    printf( "\n\tStream Name          -> %s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );
}

VOID
DisplayNetworkOpenInformation (
    IN PFILE_NETWORK_OPEN_INFORMATION FileInfo
    )
{
    printf( "\n\tCreation Time    -> " );
    PrintTime( &FileInfo->CreationTime );
    printf( "\n\tLast Access Time -> " );
    PrintTime( &FileInfo->LastAccessTime );
    printf( "\n\tLast Write Time  -> " );
    PrintTime( &FileInfo->LastWriteTime );
    printf( "\n\tChange Time      -> " );
    PrintTime( &FileInfo->ChangeTime );
    printf( "\n\tAllocation Size  -> " );
    PrintLargeInteger( &FileInfo->AllocationSize );
    printf( "\n\tEnd Of File      -> " );
    PrintLargeInteger( &FileInfo->EndOfFile );
    printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\toplock.c ===
#include "brian.h"

#define OPLOCK_VERBOSES_DEFAULT         TRUE

typedef struct _OPLOCK {

    ULONG FileHandleIndex;
    BOOLEAN VerboseResults;
    USHORT BufferIndex;

} OPLOCK, *POPLOCK;

//
//  Local procedures
//

VOID
RequestOplockI (
    IN POPLOCK Oplock
    );

VOID
RequestBatchOplock (
    IN POPLOCK Oplock
    );

VOID
RequestFilterOplock (
    IN POPLOCK Oplock
    );

VOID
RequestOplockII (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOplockBreak (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOplockBreakNo2 (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOpBatchBreakPending (
    IN POPLOCK Oplock
    );

VOID
OplockBreakNotify (
    IN POPLOCK Oplock
    );


VOID
InputOplock(
    IN PCHAR ParamBuffer
    )

{
    ULONG  Operation;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    POPLOCK Oplock;
    ULONG FileHandleIndex;

    VerboseResults = OPLOCK_VERBOSES_DEFAULT;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;
    FileHandleIndex = 0;

    Operation = (ULONG) -1;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            Operation = FSCTL_REQUEST_OPLOCK_LEVEL_1;
                            ParamReceived = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            Operation = FSCTL_REQUEST_OPLOCK_LEVEL_2;
                            ParamReceived = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            Operation = FSCTL_REQUEST_BATCH_OPLOCK;
                            ParamReceived = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            Operation = FSCTL_REQUEST_FILTER_OPLOCK;
                            ParamReceived = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            Operation = FSCTL_OPLOCK_BREAK_ACKNOWLEDGE;
                            ParamReceived = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            Operation = FSCTL_OPBATCH_ACK_CLOSE_PENDING;
                            ParamReceived = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            Operation = FSCTL_OPLOCK_BREAK_NOTIFY;
                            ParamReceived = TRUE;
                            break;

                        case 'h' :
                        case 'H' :
                            Operation = FSCTL_OPLOCK_BREAK_ACK_NO_2;
                            ParamReceived = TRUE;
                            break;

                        case 'z' :
                        case 'Z' :
                            ParamReceived = FALSE;
                            Operation = (ULONG) -1;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;

                        }


                        ParamBuffer++;

                    }

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: oplk -i<digits> -o<char> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -o<chars>    Oplock operation" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //
    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;
        USHORT BufferIndex;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( OPLOCK );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputOplock:  Unable to allocate async structure" );

        } else {

            Oplock = (POPLOCK) Buffers[BufferIndex].Buffer;

            Oplock->FileHandleIndex = FileHandleIndex;
            Oplock->VerboseResults = VerboseResults;
            Oplock->BufferIndex = BufferIndex;

            if (DisplayParms) {

                printf( "\nOplock Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileHandleIndex );
                printf( "\n   Oplock operation        -> %ld", Operation );
                printf( "\n   Structure buffer index  -> %d", BufferIndex );
                printf( "\n\n" );
            }

            switch (Operation) {

            case FSCTL_REQUEST_OPLOCK_LEVEL_1 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestOplockI,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_OPLOCK_LEVEL_2 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestOplockII,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_BATCH_OPLOCK :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestBatchOplock,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_FILTER_OPLOCK :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestFilterOplock,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOplockBreak,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPBATCH_ACK_CLOSE_PENDING :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOpBatchBreakPending,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_NOTIFY :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             OplockBreakNotify,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_ACK_NO_2 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOplockBreakNo2,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            default :

                printf( "\nInputOplock:  Invalid operation\n" );
                return;
            }


            if (ThreadHandle == 0) {

                printf( "\nInputOplock:  Spawning thread fails -> %d\n", GetLastError() );
            }
        }
    }
    return;
}

VOID
RequestOplockI (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestOplockI:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_OPLOCK_LEVEL_1,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestOplockI:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestOplockI:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestOplockI:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestOplockI:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestOplockI:  Thread not terminated\n" );
}

VOID
RequestBatchOplock (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestBatchOplock:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_BATCH_OPLOCK,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestBatchOplock:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestBatchOplock:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestBatchOplock:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestBatchOplock:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestBatchOplock:  Thread not terminated\n" );
}

VOID
RequestFilterOplock (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestFilterOplock:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_FILTER_OPLOCK,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestFilterOplock:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestFilterOplock:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nRequestFilterOplock:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nRequestFilterOplock:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestFilterOplock:  Thread not terminated\n" );
}

VOID
RequestOplockII (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestOplockII:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_OPLOCK_LEVEL_2,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestOplockII:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestOplockII:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nRequestOplockII:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nRequestOplockII:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestOplockII:  Thread not terminated\n" );
}


VOID
AcknowledgeOplockBreak (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOplockBreak:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_ACKNOWLEDGE,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOplockBreak:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOplockBreak:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOplockBreak:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOplockBreak:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nAcknowledgeOplockBreak:  Thread not terminated\n" );

}

VOID
AcknowledgeOplockBreakNo2 (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOplockBreakNo2:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_ACK_NO_2,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOplockBreakNo2:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOplockBreakNo2:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOplockBreakNo2:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOplockBreakNo2:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nAcknowledgeOplockBreak:  Thread not terminated\n" );

}

VOID
AcknowledgeOpBatchBreakPending (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOpBatchBreakPending:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPBATCH_ACK_CLOSE_PENDING,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOpBatchBreakPending:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOpBatchBreakPending:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOpBatchBreakPending:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOpBatchBreakPending:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nAcknowledgeOpBatchBreakPending:  Thread not terminated\n" );

}


VOID
OplockBreakNotify (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nOplockBreakNotify:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_NOTIFY,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nOplockBreakNotify:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tOplockBreakNotify:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nOplockBreakNotify:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nOplockBreakNotify:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nOplockBreakNotify:  Thread not terminated\n" );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tqdir.c ===
#include "brian.h"

typedef struct _ASYNC_QDIR {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    PUNICODE_STRING FileNamePtr;
    UNICODE_STRING FileName;
    BOOLEAN SingleEntry;
    BOOLEAN Restart;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;
    USHORT NameIndex;

} ASYNC_QDIR, *PASYNC_QDIR;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define QDIR_LENGTH_DEFAULT         100
#define FILE_INFO_CLASS_DEFAULT     FileBothDirectoryInformation
#define SINGLE_ENTRY_DEFAULT        FALSE
#define RESTART_DEFAULT             FALSE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT     0

VOID
FullQDir(
    IN OUT PASYNC_QDIR AsyncQDir
    );


VOID
InputQDir (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    PUNICODE_STRING FileNamePtr;
    UNICODE_STRING FileName;
    USHORT FileNameIndex;
    BOOLEAN SingleEntry;
    BOOLEAN Restart;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;
    PUCHAR FileNamePChar;
    BOOLEAN NameIndexAllocated;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QDIR_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    FileNamePtr = NULL;
    FileNameIndex = 0;
    SingleEntry = SINGLE_ENTRY_DEFAULT;
    Restart = RESTART_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    NameIndexAllocated = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    {
        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        RegionSize = 256;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        if (!NT_SUCCESS( Status )) {

            printf("\nInputQdir:  Can't allocate name index buffer" );
            return;
        }

        NameIndexAllocated = TRUE;
        FileNameIndex = (USHORT) TempIndex;
        FileName.Length = 256;
        FileName.MaximumLength = 256;
        FileName.Buffer = (PWSTR) Buffers[FileNameIndex].Buffer;
    }

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we want only a single entry.
                //

                case 's' :
                case 'S' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        SingleEntry = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        SingleEntry = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we want to restart the scan.
                //

                case 'r' :
                case 'R' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Restart = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Restart = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the filename.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    FileNamePChar = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ANSI_STRING AnsiString;

                        AnsiString.Length = (USHORT) DummyCount;
                        AnsiString.Buffer = FileNamePChar;

                        RtlAnsiStringToUnicodeString( &FileName,
                                                      &AnsiString,
                                                      FALSE );

                        FileNamePtr = (PUNICODE_STRING) &FileName;
                    }

                    break;


                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileNamesInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileDirectoryInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFullDirectoryInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileIdFullDirectoryInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileBothDirectoryInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileIdBothDirectoryInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FileObjectIdInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileQuotaInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileReparsePointInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -f<chars>    Search expression" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n             a            FileNamesInformation" );
        printf( "\n             b            FileDirectoryInformation" );
        printf( "\n             c            FileFullDirectoryInformation" );
        printf( "\n             d            FileIdFullDirectoryInformation" );
        printf( "\n             e            FileBothDirectoryInformation" );
        printf( "\n             f            FileIdBothObjectIdInformation" );
        printf( "\n             g            FileObjectIdInformation" );
        printf( "\n             h            FileQuotaInformation" );
        printf( "\n             i            FileReparsePointInformation" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -r[t|f]      Restart the search" );
        printf( "\n           -s[t|f]      Return single entry" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QDIR AsyncQDir;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QDIR );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQDir:  Unable to allocate async structure" );

        } else {

            AsyncQDir = (PASYNC_QDIR) Buffers[AsyncIndex].Buffer;

            AsyncQDir->FileIndex = (USHORT) FileIndex;
            AsyncQDir->UseEvent = UseEvent;
            AsyncQDir->ApcRoutine = ApcRoutine;
            AsyncQDir->ApcContext = ApcContext;

            AsyncQDir->BufferIndex = BufferIndex;
            AsyncQDir->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncQDir->BufferIndex
                                        : BufferIndexPtr;
            AsyncQDir->Length = Length;
            AsyncQDir->FileInfoClass = FileInfoClass;
            AsyncQDir->FileName = FileName;
            AsyncQDir->FileNamePtr = FileNamePtr
                                     ? &AsyncQDir->FileName
                                     : NULL;
            AsyncQDir->SingleEntry = SingleEntry;
            AsyncQDir->Restart = Restart;
            AsyncQDir->DisplayParms = DisplayParms;
            AsyncQDir->VerboseResults = VerboseResults;
            AsyncQDir->AsyncIndex = AsyncIndex;
            AsyncQDir->NameIndex = FileNameIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQDir,
                                             AsyncQDir,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQDir:  Spawning thread fails -> %d\n", GetLastError() );

                    if (AsyncQDir->FileNamePtr) {

                        DeallocateBuffer( FileNameIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullQDir( AsyncQDir );
            }
        }
    }

    return;
}


VOID
FullQDir(
    IN OUT PASYNC_QDIR AsyncQDir
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindQDirBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQDir->DisplayParms) {

        bprint  "\n" );
        bprint  "    QDir Parameters\n" );
        bprint  "       File Handle Index       -> %d\n", AsyncQDir->FileIndex );
        bprint  "       UseEvent                -> %d\n", AsyncQDir->UseEvent );
        bprint  "       ApcRoutine              -> %08lx\n", AsyncQDir->ApcRoutine );
        bprint  "       ApcContext              -> %08lx\n", AsyncQDir->ApcContext );
        bprint  "       Buffer Index Ptr        -> %08lx\n", AsyncQDir->BufferIndexPtr );
        if (AsyncQDir->BufferIndexPtr) {

            bprint  "       BufferIndex value       -> %04x\n", AsyncQDir->BufferIndex );
        }

        bprint  "       Length                  -> %08lx\n", AsyncQDir->Length );

        bprint  "       FileInfoClass           -> %08lx\n", AsyncQDir->FileInfoClass );

        bprint  "       FileNamePtr             -> %08lx\n", AsyncQDir->FileNamePtr );
        if (AsyncQDir->FileNamePtr) {

            bprint  "       Filename                -> %s\n", AsyncQDir->FileName.Buffer );
        }

        bprint  "       Single Entry            -> %04x\n", AsyncQDir->SingleEntry );
        bprint  "       Restart Scan            -> %04x\n", AsyncQDir->SingleEntry );

        bprint  "\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQDir->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "\tFullQDir:  Unable to allocate a query buffer\n" );
                try_return( Status );
            }

            bprint  "\tFullQDir:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );
            bprint  "\n" );

            UnwindQDirBuffer = TRUE;

            AsyncQDir->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQDir->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n" );
            bprint  "\tFullQDir:  The read buffer index is invalid\n" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQDir->FileIndex >= MAX_HANDLES) {

            bprint  "\n" );
            bprint  "\tFullQDir:  The file index is invalid\n" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncQDir->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "\tFullQDir:  Unable to allocate an event\n" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtQueryDirectoryFile( Handles[AsyncQDir->FileIndex].Handle,
                                       ThisEvent,
                                       AsyncQDir->ApcRoutine,
                                       AsyncQDir->ApcContext,
                                       &Iosb,
                                       Buffers[ThisBufferIndex].Buffer,
                                       AsyncQDir->Length,
                                       AsyncQDir->FileInfoClass,
                                       AsyncQDir->SingleEntry,
                                       AsyncQDir->FileNamePtr,
                                       AsyncQDir->Restart );

        UnwindQDirBuffer = FALSE;

        if (AsyncQDir->VerboseResults) {

            bprint  "\n" );
            bprint  "   Query Dir:  Status            -> %08lx\n", Status );

            if (AsyncQDir->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint "\n" );
                    bprint "\tQuery Dir:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "            Iosb.Information  -> %08lx\n", Iosb.Information );
                bprint  "            Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQDirBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        if (AsyncQDir->FileNamePtr) {

            DeallocateBuffer( AsyncQDir->NameIndex );
        }

        DeallocateBuffer( AsyncQDir->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}


VOID
InputDisplayQDir (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileNamesInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileDirectoryInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFullDirectoryInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileIdFullDirectoryInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileBothDirectoryInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileIdBothDirectoryInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqd [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileNamesInformation:

                DisplayQDirNames( (USHORT) BufferIndex );
                break;

            case FileDirectoryInformation:

                DisplayQDirDirs( (USHORT) BufferIndex );
                break;

            case FileFullDirectoryInformation:

                DisplayQDirFullDirs( (USHORT) BufferIndex );
                break;

            case FileIdFullDirectoryInformation:

                DisplayQDirIdFullDirs( (USHORT) BufferIndex );
                break;

            case FileBothDirectoryInformation:

                DisplayQBothDirs( (USHORT) BufferIndex );
                break;

            case FileIdBothDirectoryInformation:

                DisplayQIdBothDirs( (USHORT) BufferIndex );
                break;
        }
    }

}



VOID
DisplayQDirNames (
    IN USHORT BufferIndex
    )
{
    PFILE_NAMES_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirNames:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nNames Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_NAMES_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirNames:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_DIRECTORY_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nDirectory Information" );

        do {
            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_DIRECTORY_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\t                            " );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );
            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );
            printf( "\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirFullDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_FULL_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirFullDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nFull Directory Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_FULL_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirFullDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirIdFullDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_ID_FULL_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirIDFullDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nFull Directory Information with ID" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_ID_FULL_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );
            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );
            printf( "\n\tFile ID          -> " );
            PrintLargeInteger( &FileInfo->FileId );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirIdFullDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQBothDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_BOTH_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQBothDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nBoth Directory Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_BOTH_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            printf( "\n\tShrt Name Length -> %04x", FileInfo->ShortNameLength );

            UnicodeString.MaximumLength = (USHORT) FileInfo->ShortNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->ShortNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->ShortName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\tShort Name       -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );


            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQBothDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQIdBothDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_ID_BOTH_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQIdBothDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nBoth Directory Information with ID" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_ID_BOTH_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );
            printf( "\n\tFile ID          -> " );
            PrintLargeInteger( &FileInfo->FileId );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            printf( "\n\tShrt Name Length -> %04x", FileInfo->ShortNameLength );

            UnicodeString.MaximumLength = (USHORT) FileInfo->ShortNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->ShortNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->ShortName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\tShort Name       -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );


            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQIdBothDirs:  AbnormalTermination\n" );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tpause.c ===
#include "brian.h"

#define DEFAULT_SECONDS     3


VOID
InputPause (
    IN PCHAR ParamBuffer
    )
{
    TIME Time;

    Time.HighTime = -1;
    Time.LowTime = DEFAULT_SECONDS * -10000000;

    NtDelayExecution( FALSE, &Time );

    return;

    UNREFERENCED_PARAMETER( ParamBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tread.c ===
#include "brian.h"

typedef struct _ASYNC_READ {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_READ, *PASYNC_READ;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define READ_LENGTH_DEFAULT         100L
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullRead(
    IN OUT PASYNC_READ AsyncRead
    );


VOID
InputRead(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = READ_LENGTH_DEFAULT;
    ByteOffsetPtr = NULL;
    ByteOffset = RtlConvertUlongToLargeInteger( 0L );
    KeyPtr = NULL;
    Key = 0;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the key value.
                //

                case 'k' :
                case 'K' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Key = AsciiToInteger( ParamBuffer );
                    KeyPtr = &Key;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the offset of the read.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ByteOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                    ByteOffsetPtr = &ByteOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: rd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Read length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -k<digits>   Locked bytes key value" );
        printf( "\n           -o<digits>   Read offset" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_READ AsyncRead;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_READ );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputRead:  Unable to allocate async structure" );

        } else {

            AsyncRead = (PASYNC_READ) Buffers[AsyncIndex].Buffer;

            AsyncRead->FileIndex = (USHORT) FileIndex;
            AsyncRead->UseEvent = UseEvent;
            AsyncRead->ApcRoutine = ApcRoutine;
            AsyncRead->ApcContext = ApcContext;

            AsyncRead->BufferIndex = BufferIndex;
            AsyncRead->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncRead->BufferIndex
                                        : BufferIndexPtr;
            AsyncRead->Length = Length;
            AsyncRead->ByteOffset = ByteOffset;
            AsyncRead->ByteOffsetPtr = ByteOffsetPtr
                                       ? &AsyncRead->ByteOffset
                                       : ByteOffsetPtr;
            AsyncRead->Key = Key;
            AsyncRead->KeyPtr = KeyPtr
                                ? &AsyncRead->Key
                                : KeyPtr;

            AsyncRead->DisplayParms = DisplayParms;
            AsyncRead->VerboseResults = VerboseResults;
            AsyncRead->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullRead,
                                             AsyncRead,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputRead:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }

            } else {

                FullRead( AsyncRead );
            }
        }
    }
    return;
}


VOID
FullRead(
    IN OUT PASYNC_READ AsyncRead
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindReadBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncRead->DisplayParms) {

        bprint  "\nRead Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncRead->FileIndex );
        bprint  "\n   UseEvent                -> %d", AsyncRead->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncRead->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncRead->ApcContext );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncRead->BufferIndexPtr );
        if (AsyncRead->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncRead->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncRead->Length );

        bprint  "\n   Byte Offset Ptr         -> %08lx", AsyncRead->ByteOffsetPtr );
        if (AsyncRead->ByteOffsetPtr) {

            bprint  "\n   Byte Offset High        -> %08lx", AsyncRead->ByteOffset.HighPart );
            bprint  "\n   Byte Offset Low         -> %08lx", AsyncRead->ByteOffset.LowPart );
        }

        bprint  "\n   Key Ptr                 -> %08lx", AsyncRead->KeyPtr );

        if (AsyncRead->KeyPtr) {

            bprint  "\n   Key                     -> %ul", AsyncRead->Key );
        }

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncRead->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = AsyncRead->Length;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullRead:  Unable to allocate a read buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullRead:  Reading into buffer -> %04x", ThisBufferIndex );
            bprint  "\n" );

            UnwindReadBuffer = TRUE;

        } else {

            ThisBufferIndex = AsyncRead->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullRead:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncRead->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullRead:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncRead->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullRead:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtReadFile( Handles[AsyncRead->FileIndex].Handle,
                             ThisEvent,
                             AsyncRead->ApcRoutine,
                             AsyncRead->ApcContext,
                             &Iosb,
                             Buffers[ThisBufferIndex].Buffer,
                             AsyncRead->Length,
                             AsyncRead->ByteOffsetPtr,
              AsyncRead->KeyPtr );

        UnwindReadBuffer = FALSE;

        if (AsyncRead->VerboseResults) {

            bprint  "\nReadFile:  Status            -> %08lx", Status );

            if (AsyncRead->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tReadFile:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n           Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n           Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindReadBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncRead->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tqvolume.c ===
#include "brian.h"

typedef struct _ASYNC_QVOLUME {

    USHORT FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_QVOLUME, *PASYNC_QVOLUME;

#define QVOLUME_LENGTH_DEFAULT      100
#define FILE_INFO_CLASS_DEFAULT     FileFsVolumeInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT       0

VOID
FullQVolume(
    IN OUT PASYNC_QVOLUME AsyncQVolume
    );

VOID
DisplayFsVolumeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsSizeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsDeviceInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsAttributeInformation (
    IN USHORT BufferIndex
    );


VOID
InputQVolume (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QVOLUME_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the information class.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsVolumeInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileFsSizeInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFsDeviceInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileFsAttributeInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qv [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QVOLUME AsyncQVolume;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QVOLUME );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQVolume:  Unable to allocate async structure" );

        } else {

            AsyncQVolume = (PASYNC_QVOLUME) Buffers[AsyncIndex].Buffer;

            AsyncQVolume->FileIndex = (USHORT) FileIndex;

            AsyncQVolume->BufferIndex = BufferIndex;
            AsyncQVolume->BufferIndexPtr = BufferIndexPtr
                                           ? &AsyncQVolume->BufferIndex
                                           : BufferIndexPtr;
            AsyncQVolume->Length = Length;
            AsyncQVolume->FileInfoClass = FileInfoClass;
            AsyncQVolume->DisplayParms = DisplayParms;
            AsyncQVolume->VerboseResults = VerboseResults;
            AsyncQVolume->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQVolume,
                                             AsyncQVolume,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQVolume:  Spawning thread fails -> %d\n", GetLastError() );

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullQVolume( AsyncQVolume );
            }
        }
    }

    return;
}


VOID
FullQVolume(
    IN OUT PASYNC_QVOLUME AsyncQVolume
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    USHORT ThisBufferIndex;

    BOOLEAN UnwindQVolumeBuffer = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQVolume->DisplayParms) {

        bprint  "\nQVolume Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncQVolume->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncQVolume->BufferIndexPtr );
        if (AsyncQVolume->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncQVolume->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncQVolume->Length );

        bprint  "\n   FileInfoClass           -> %08lx", AsyncQVolume->FileInfoClass );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQVolume->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullQVolume:  Unable to allocate a query buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullQVolume:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindQVolumeBuffer = TRUE;

            AsyncQVolume->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQVolume->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullQVolume:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQVolume->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullQVolume:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Call the query file routine.
        //

        Status = NtQueryVolumeInformationFile( Handles[AsyncQVolume->FileIndex].Handle,
                                               &Iosb,
                                               Buffers[ThisBufferIndex].Buffer,
                                               AsyncQVolume->Length,
                                               AsyncQVolume->FileInfoClass );

        UnwindQVolumeBuffer = FALSE;

        if (AsyncQVolume->VerboseResults) {

            bprint  "\nQuery File:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n             Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n             Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQVolumeBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        DeallocateBuffer( AsyncQVolume->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}


VOID
InputDisplayQVolume (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :


                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsVolumeInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileFsSizeInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFsDeviceInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileFsAttributeInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqv [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileFsVolumeInformation :

                DisplayFsVolumeInformation( (USHORT) BufferIndex );
                break;

            case FileFsSizeInformation:

                DisplayFsSizeInformation( (USHORT) BufferIndex );
                break;

            case FileFsDeviceInformation:

                DisplayFsDeviceInformation( (USHORT) BufferIndex );
                break;

            case FileFsAttributeInformation:

                DisplayFsAttributeInformation( (USHORT) BufferIndex );
                break;
        }
    }

}

VOID
DisplayFsVolumeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_VOLUME_INFORMATION FileInfo;
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    BOOLEAN UnwindFreeAnsiString = FALSE;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsVolumeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_VOLUME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Volume Information\n" );

        printf( "\n\tVolume Creation Time       -> " );
        PrintTime( &FileInfo->VolumeCreationTime );
        printf( "\n\tVolume Serial Number       -> %08lx", FileInfo->VolumeSerialNumber );
        printf( "\n\tVolume Label Length        -> %08d", FileInfo->VolumeLabelLength );
        printf( "\n\tVolume Supports Objects    -> %01d", FileInfo->SupportsObjects );

        UnicodeString.MaximumLength =
        UnicodeString.Length = (USHORT) FileInfo->VolumeLabelLength;
        UnicodeString.Buffer = (PWSTR) &FileInfo->VolumeLabel;

        UnicodeString.MaximumLength += 2;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               TRUE );

        if (!NT_SUCCESS( Status )) {

            printf( "\nDisplay Volume Information: Unable to allocate Ansi -> %08lx\n", Status );
            try_return( NOTHING );
        }

        UnwindFreeAnsiString = TRUE;

        printf( "\n\tVolume Label               -> %s", AnsiString.Buffer );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsVolumeInformation:  AbnormalTermination\n" );
        }

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiString );
        }
    }

    return;
}

VOID
DisplayFsSizeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_SIZE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsSizeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_SIZE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Size Information\n" );

        printf( "\n\tTotal Allocation Units -> " );
        PrintLargeInteger( &FileInfo->TotalAllocationUnits );
        printf( "\n\tAvail Allocation Units -> " );
        PrintLargeInteger( &FileInfo->AvailableAllocationUnits );
        printf( "\n\tSectors Per Alloc Unit -> %08lx", FileInfo->SectorsPerAllocationUnit );
        printf( "\n\tBytes Per Sector       -> %08lx", FileInfo->BytesPerSector );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsSizeInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayFsDeviceInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_DEVICE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsDeviceInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_DEVICE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Device Information\n" );

        printf( "\n\tDevice Type     -> %08lx", FileInfo->DeviceType );
        printf( "\n\tCharacteristics -> %08lx", FileInfo->Characteristics );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsDeviceInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayFsAttributeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_ATTRIBUTE_INFORMATION FileInfo;
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    BOOLEAN UnwindFreeAnsiString = FALSE;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsAttributeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Attribute Information\n" );

        printf( "\n\tFile System Attributes     -> %08lx", FileInfo->FileSystemAttributes );
        printf( "\n\tMax Component Name Length  -> %08d", FileInfo->MaximumComponentNameLength );
        printf( "\n\tFile System Name Length    -> %08d", FileInfo->FileSystemNameLength );

        UnicodeString.MaximumLength =
        UnicodeString.Length = (USHORT) FileInfo->FileSystemNameLength;
        UnicodeString.Buffer = (PWSTR) &FileInfo->FileSystemName;

        UnicodeString.MaximumLength += 2;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               TRUE );

        if (!NT_SUCCESS( Status )) {

            printf( "\nDisplay Fs Attribute Information: Unable to allocate Ansi -> %08lx\n", Status );
            try_return( NOTHING );
        }

        UnwindFreeAnsiString = TRUE;

        printf( "\n\tFile System Name           -> %s", AnsiString.Buffer );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsAttributeInformation:  AbnormalTermination\n" );
        }

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiString );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\treparse.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestReparse (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputReparse(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputReparse:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputReparse:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_GET_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_SET_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_DELETE_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: rp -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Reparse operation" );
        printf( "\n                 -oa             Get Reparse" );
        printf( "\n                 -ob             Set Reparse" );
        printf( "\n                 -oc             Delete Reparse" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputReparse:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nSparse Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Sparse operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestReparse,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputReparse:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestReparse( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestReparse (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestReparse:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestReparse:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestReparse:  Wait for event failed -> %08lx", Status );
                }
            }

            if (!NT_ERROR( Status )) {

                bprint  "\nRequestReparse:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestReparse:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestSparse:  Thread not terminated\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tsetvol.c ===
#include "brian.h"

typedef struct _ASYNC_SET_VOLUME {

    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;

    ULONG LabelLength;
    PULONG LabelLengthPtr;
    USHORT LabelIndex;
    BOOLEAN LabelBufferAllocated;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_SET_VOLUME, *PASYNC_SET_VOLUME;

#define SET_VOLUME_LENGTH_DEFAULT       100
#define FILE_INFO_CLASS_DEFAULT     FileFsLabelInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

VOID
FullSetVolume(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    );

VOID
SetFsLabelInformation(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    );


VOID
InputSetVolume (
    IN PCHAR ParamBuffer
    )
{
    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;

    ANSI_STRING AnsiLabelString;
    ULONG LabelLength;
    PULONG LabelLengthPtr;
    USHORT LabelIndex;
    BOOLEAN LabelBufferAllocated;
    PUCHAR LabelPtr;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    BufferLengthPtr = NULL;

    LabelLengthPtr = NULL;
    LabelBufferAllocated = FALSE;
    LabelPtr = NULL;

    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {


                        //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                            if (*ParamBuffer == '\0') {

                                    break;
                            }

                            switch (*ParamBuffer) {

                            case 'b':
                            case 'B':

                                    BufferLength = AsciiToInteger( ++ParamBuffer );
                                    BufferLengthPtr = &BufferLength;

                                    break;

                            case 'l':
                            case 'L':

                                    LabelLength = AsciiToInteger( ++ParamBuffer );
                                    LabelLengthPtr = &LabelLength;

                                    break;
                            }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                        //
                        //  Update the label name.
                //

                        case 'f' :
                        case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                            if (*ParamBuffer == '\0') {

                                    break;
                            }

                            switch (*ParamBuffer) {

                            PUCHAR TempPtr;

                            case 'l':
                            case 'L':

                                //
                                //  Remember the buffer offset and get the filename.
                                //

                                ParamBuffer++;
                                TempPtr = ParamBuffer;
                                DummyCount = 0;
                                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                                //
                                //  If the name length is 0, then ignore this entry.
                                //

                                if (DummyCount) {

                            AnsiLabelString.Length = (USHORT) DummyCount;
                            AnsiLabelString.Buffer = TempPtr;

                                    LabelPtr = TempPtr;
                            LabelLength = (ULONG) RtlAnsiStringToUnicodeSize( &AnsiLabelString) - sizeof( WCHAR );
                                    LabelLengthPtr = &LabelLength;
                                }

                                break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                        //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                            FileIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                            break;

                        //
                //  Update the information class.
                        //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsLabelInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                            break;

                        case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //

                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //

                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: sv [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -lb<digits>  Buffer length" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -fl<name>    Name for label" );
        printf( "\n           -ll<digits>  Stated length of label" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_SET_VOLUME AsyncSetVolume;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_SET_VOLUME );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputSetFile:  Unable to allocate async structure" );

        } else {

            UNICODE_STRING UnicodeString;

            //
            //  If we need a buffer for the label, allocate it now.
            //

            if (LabelPtr == NULL) {

                RtlInitAnsiString( &AnsiLabelString, "" );
                LabelPtr = AnsiLabelString.Buffer;
                LabelLength = 100;
            }

            RegionSize = LabelLength;
            Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

            if (!NT_SUCCESS( Status )) {

                printf( "\n\tInputSetVolume:  Unable to allocate label structure" );

                DeallocateBuffer( AsyncIndex );
                return;
            }

            UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
            UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
            LabelIndex = (USHORT) TempIndex;
            LabelBufferAllocated = TRUE;

            //
            //  Store the name in the buffer.
            //

            RtlAnsiStringToUnicodeString( &UnicodeString,
                                          &AnsiLabelString,
                                          FALSE );

            AsyncSetVolume = (PASYNC_SET_VOLUME) Buffers[AsyncIndex].Buffer;

            AsyncSetVolume->FileIndex = (USHORT) FileIndex;

            AsyncSetVolume->BufferLength = BufferLength;
            AsyncSetVolume->BufferLengthPtr = BufferLengthPtr ?
                                              &AsyncSetVolume->BufferLength :
                                              NULL;

            AsyncSetVolume->FileInfoClass = FileInfoClass;

            AsyncSetVolume->LabelLength = LabelLength;
            AsyncSetVolume->LabelLengthPtr = LabelLengthPtr
                                             ? &AsyncSetVolume->LabelLength
                                             : NULL;
            AsyncSetVolume->LabelIndex = LabelIndex;
            AsyncSetVolume->LabelBufferAllocated = LabelBufferAllocated;

            AsyncSetVolume->DisplayParms = DisplayParms;
            AsyncSetVolume->VerboseResults = VerboseResults;
            AsyncSetVolume->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullSetVolume,
                                             AsyncSetVolume,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputSetVolume:  Spawning thread fails -> %d\n", GetLastError() );

                    if (LabelBufferAllocated) {

                        DeallocateBuffer( LabelIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullSetVolume( AsyncSetVolume );
            }
        }
    }

    return;
}


VOID
FullSetVolume(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    )
{
    try {

        //
        //  Case on the information type and call the appropriate routine.
        //

        switch (AsyncSetVolume->FileInfoClass) {

        case FileFsLabelInformation:

            SetFsLabelInformation( AsyncSetVolume );
            break;

        default:

            bprint  "\nFullSetVolume:  Unrecognized information class\n" );
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AsyncSetVolume->LabelBufferAllocated) {

            DeallocateBuffer( AsyncSetVolume->LabelIndex );
        }

        DeallocateBuffer( AsyncSetVolume->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}

VOID
SetFsLabelInformation(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    )
{
    NTSTATUS Status;

    PFILE_FS_LABEL_INFORMATION LabelInformation;
    USHORT BufferIndex;

    UNICODE_STRING UniLabel;
    ANSI_STRING AnsiLabel;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a label specified.
    //

    if (!AsyncSetVolume->LabelBufferAllocated) {

            bprint  "\nSet Label Information:  No label was specified\n" );
            return;
    }

    UniLabel.Buffer = (PWSTR) Buffers[AsyncSetVolume->LabelIndex].Buffer;
    UniLabel.MaximumLength =
    UniLabel.Length = (USHORT) AsyncSetVolume->LabelLength;

    UniLabel.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiLabel,
                                           &UniLabel,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nSetLabelInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetVolume->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetVolume->DisplayParms) {

            bprint  "\nSet LabelInformation Parameters" );
            bprint  "\n   File Handle Index       -> %d", AsyncSetVolume->FileIndex );

            bprint  "\n   BufferLengthPtr         -> %08lx", AsyncSetVolume->BufferLengthPtr );
            if (AsyncSetVolume->BufferLengthPtr) {

                bprint  "\n   BufferLength value      -> %08x", AsyncSetVolume->BufferLength );
            }

        bprint  "\n   Label length            -> %d", AsyncSetVolume->LabelLength );

        bprint  "\n   New label               -> %s", AnsiLabel.Buffer );

        bprint  "\n\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_FS_LABEL_INFORMATION ) + AsyncSetVolume->LabelLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\n\tSetLabelInformation:  Unable to allocate structure" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        LabelInformation = (PFILE_FS_LABEL_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        LabelInformation->VolumeLabelLength = AsyncSetVolume->LabelLength;
        RtlMoveMemory( LabelInformation->VolumeLabel,
                           UniLabel.Buffer,
                           AsyncSetVolume->LabelLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetVolumeInformationFile( Handles[AsyncSetVolume->FileIndex].Handle,
                                                             &Iosb,
                                                             LabelInformation,
                                                             AsyncSetVolume->BufferLengthPtr
                                                             ? AsyncSetVolume->BufferLength
                                                             : Buffers[BufferIndex].Length,
                                                             FileFsLabelInformation );

        if (AsyncSetVolume->VerboseResults) {

            bprint  "\nSetInformationFile:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n                     Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n                     Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint  "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiLabel );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tsetfile.c ===
#include "brian.h"

typedef struct _ASYNC_SETFILE {

    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;
    USHORT CreateTimeIndex;
    PUSHORT CreateTimePtr;
    USHORT LastAccessIndex;
    PUSHORT LastAccessPtr;
    USHORT LastWriteIndex;
    PUSHORT LastWritePtr;
    USHORT ChangeTimeIndex;
    PUSHORT ChangeTimePtr;
    ULONG FileAttributes;
    PULONG FileAttributesPtr;

    ULONG RenameLength;
    PULONG RenameLengthPtr;
    BOOLEAN ReplaceIfExists;
    USHORT RootDirectoryIndex;
    PUSHORT RootDirectoryPtr;
    USHORT RenameIndex;
    BOOLEAN RenameBufferAllocated;

    ULONG NameLength;
    PULONG NameLengthPtr;
    USHORT NameIndex;
    BOOLEAN NameBufferAllocated;

    ULONG ShortNameLength;
    PULONG ShortNameLengthPtr;
    USHORT ShortNameIndex;
    BOOLEAN ShortNameBufferAllocated;

    BOOLEAN DeleteFile;

    LARGE_INTEGER NewOffset;

    ULONG FileMode;

    LARGE_INTEGER NewAllocation;

    LARGE_INTEGER NewEof;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_SETFILE, *PASYNC_SETFILE;

#define SETFILE_LENGTH_DEFAULT      100
#define FILE_INFO_CLASS_DEFAULT     FileBasicInformation
#define REPLACE_IF_EXISTS_DEFAULT   TRUE
#define DELETE_FILE_DEFAULT         TRUE
#define FILE_MODE_DEFAULT           FILE_SYNCHRONOUS_IO_NONALERT
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     TRUE

VOID
FullSetFile(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetBasicInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetRenameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetShortNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetDispositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetPositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetModeInformation (
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetAllocationInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetEofInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );


VOID
InputSetFile (
    IN PCHAR ParamBuffer
    )
{
    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;
    USHORT CreateTimeIndex;
    PUSHORT CreateTimePtr;
    USHORT LastAccessIndex;
    PUSHORT LastAccessPtr;
    USHORT LastWriteIndex;
    PUSHORT LastWritePtr;
    USHORT ChangeTimeIndex;
    PUSHORT ChangeTimePtr;
    ULONG FileAttributes;
    PULONG FileAttributesPtr;

    ANSI_STRING AnsiRenameString;
    ULONG RenameLength;
    PULONG RenameLengthPtr;
    BOOLEAN ReplaceIfExists;
    USHORT RootDirectoryIndex;
    PUSHORT RootDirectoryPtr;
    USHORT RenameIndex;
    BOOLEAN RenameBufferAllocated;
    PUCHAR FileRenamePtr;

    ANSI_STRING AnsiNameString;
    ULONG NameLength;
    PULONG NameLengthPtr;
    USHORT NameIndex = 0;
    BOOLEAN NameBufferAllocated;
    PUCHAR FileNamePtr;

    ULONG ShortNameLength;
    PULONG ShortNameLengthPtr;
    USHORT ShortNameIndex = 0;
    BOOLEAN ShortNameBufferAllocated;
    PUCHAR FileShortNamePtr;

    BOOLEAN DeleteFile;

    LARGE_INTEGER NewOffset;

    ULONG FileMode;

    LARGE_INTEGER NewAllocation;

    LARGE_INTEGER NewEof;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    BufferLengthPtr = NULL;
    CreateTimePtr = NULL;
    LastAccessPtr = NULL;
    LastWritePtr = NULL;
    ChangeTimePtr = NULL;
    FileAttributes = 0;
    FileAttributesPtr = NULL;

    RenameLengthPtr = NULL;
    ReplaceIfExists = REPLACE_IF_EXISTS_DEFAULT;
    RootDirectoryPtr = NULL;
    RenameBufferAllocated = FALSE;
    FileRenamePtr = NULL;

    NameLengthPtr = NULL;
    NameBufferAllocated = FALSE;
    FileNamePtr = NULL;

    ShortNameLengthPtr = NULL;
    ShortNameBufferAllocated = FALSE;
    FileShortNamePtr = NULL;

    DeleteFile = DELETE_FILE_DEFAULT;

    NewOffset = RtlConvertUlongToLargeInteger( 0L );

    FileMode = FILE_MODE_DEFAULT;

    NewAllocation = NewOffset;

    NewEof = NewOffset;

    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {


                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'b':
                    case 'B':

                            BufferLength = AsciiToInteger( ++ParamBuffer );
                            BufferLengthPtr = &BufferLength;

                            break;

                    case 'r':
                    case 'R':

                            RenameLength = AsciiToInteger( ++ParamBuffer );
                            RenameLengthPtr = &RenameLength;

                            break;

                    case 'n':
                    case 'N':

                            NameLength = AsciiToInteger( ++ParamBuffer );
                            NameLengthPtr = &NameLength;

                            break;

                    case 's':
                    case 'S':

                            ShortNameLength = AsciiToInteger( ++ParamBuffer );
                            ShortNameLengthPtr = &ShortNameLength;

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the allocation size.
                //

                case 'n' :
                case 'N' :

                    NewAllocation.QuadPart = AsciiToLargeInteger( ++ParamBuffer );
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Update the End of file size.
                //

                case 'e' :
                case 'E' :

                    NewEof.QuadPart = AsciiToLargeInteger( ++ParamBuffer );
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the filenames.
                //

                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    PUCHAR TempPtr;

                    case 'r':
                    case 'R':

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiRenameString.Length = (USHORT) DummyCount;
                            AnsiRenameString.Buffer = TempPtr;

                            FileRenamePtr = TempPtr;
                            RenameLength = RtlAnsiStringToUnicodeSize( &AnsiRenameString) - sizeof( WCHAR );
                            RenameLengthPtr = &RenameLength;
                        }

                        break;

                    case 'n':
                    case 'N':

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiNameString.Length = (USHORT) DummyCount;
                            AnsiNameString.Buffer = TempPtr;

                            FileNamePtr = TempPtr;
                            NameLength = RtlAnsiStringToUnicodeSize( &AnsiNameString) - sizeof( WCHAR );
                            NameLengthPtr = &NameLength;
                        }

                        break;

                    case 's' :
                    case 'S' :

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiNameString.Length = (USHORT) DummyCount;
                            AnsiNameString.Buffer = TempPtr;

                            FileShortNamePtr = TempPtr;
                            ShortNameLength = RtlAnsiStringToUnicodeSize( &AnsiNameString) - sizeof( WCHAR );
                            ShortNameLengthPtr = &ShortNameLength;
                        }

                        break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the root directory index.
                //

                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    RootDirectoryIndex = (USHORT) AsciiToInteger( ParamBuffer );
                    RootDirectoryPtr = &RootDirectoryIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the information class.
                //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileRenameInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileLinkInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileDispositionInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FileAllocationInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileEndOfFileInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileShortNameInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the file mode information
                //

                case 'm' :
                case 'M' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileMode &= FILE_WRITE_THROUGH;
                            break;

                        case 'b' :
                        case 'B' :

                            FileMode &= FILE_SEQUENTIAL_ONLY;
                            break;

                        case 'c' :
                        case 'C' :

                            FileMode &= FILE_SYNCHRONOUS_IO_ALERT;
                            break;

                        case 'd' :
                        case 'D' :

                            FileMode &= FILE_SYNCHRONOUS_IO_NONALERT;
                            break;

                        case 'z' :
                        case 'Z' :

                            FileMode = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the file attributes.
                //

                case 'a' :
                case 'A' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            FileAttributes |= FILE_ATTRIBUTE_READONLY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'b' :
                        case 'B' :
                            FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'c' :
                        case 'C' :
                            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'e' :
                        case 'E' :
                            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'f' :
                        case 'F' :
                            FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'g' :
                        case 'G' :
                            FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'h' :
                        case 'H' :

                            FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'i' :
                        case 'I' :
                            FileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'j' :
                        case 'J' :
                            FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'k' :
                        case 'K' :
                            FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'l' :
                        case 'L' :
                            FileAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'm' :
                        case 'M' :
                            FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'n' :
                        case 'N' :
                            FileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'z' :
                        case 'Z' :

                            FileAttributes = 0;
                            FileAttributesPtr = NULL;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Check for time or date modification.
                //

                case 't' :
                case 'T' :

                    //
                    //  Check that there is another character.
                    //

                    ParamBuffer++;
                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'c':
                    case 'C':

                            CreateTimeIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                            CreateTimePtr = &CreateTimeIndex;

                            break;

                    case 'a':
                    case 'A':

                        LastAccessIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        LastAccessPtr = &LastAccessIndex;

                        break;

                    case 'w':
                    case 'W':

                        LastWriteIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        LastWritePtr = &LastWriteIndex;

                        break;

                    case 'g':
                    case 'G':

                        ChangeTimeIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        ChangeTimePtr = &ChangeTimeIndex;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                case 'p' :
                case 'P' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                            || *ParamBuffer == 't') {

                        ReplaceIfExists = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        ReplaceIfExists = FALSE;
                        ParamBuffer++;
                    }

                    break;

                    case 'd' :
                    case 'D' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        DeleteFile = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        DeleteFile = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the lower offset of the large integer.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    NewOffset.LowPart = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the upper offset of the large integer.
                //

                case 'u' :
                case 'U' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    NewOffset.HighPart = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //

                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //

                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        bprint  "\n" );
        printf( "   Usage: sf [options]* -i<index> [options]*\n" );
        printf( "       Options:\n" );
        printf( "           -i<digits>   File index\n" );
        printf( "           -lb<digits>  Buffer length\n" );
        printf( "           -c<char>     File information class\n" );
        printf( "           -tc<digits>  CreateTime buffer index\n" );
        printf( "           -ta<digits>  LastAccess buffer index\n" );
        printf( "           -tw<digits>  LastWrite buffer index\n" );
        printf( "           -tg<digits>  ChangeTime buffer index\n" );
        printf( "           -a<chars>    File attributes\n" );
        printf( "           -p[t|f]      Replace existing file on rename\n" );
        printf( "           -r<digits>   Root directory index for rename\n" );
        printf( "           -fr<name>    Name for rename\n" );
        printf( "           -fn<name>    New link name\n" );
        printf( "           -fs<name>    New short name\n" );
        printf( "           -lr<digits>  Stated length of rename\n" );
        printf( "           -ln<digits>  Stated length of new name\n" );
        printf( "           -ls<digits>  Stated length of new short name\n" );
        printf( "           -d[t|f]      Delete file\n" );
        printf( "           -o<digits>   Low word of new position\n" );
        printf( "           -u<digits>   High word of new position\n" );
        printf( "           -m<chars>    File mode information\n" );
        printf( "           -n<digits>   Quad word of new allocation size\n" );
        printf( "           -e<digits>   Quad word of new end of file\n" );
        printf( "           -v[t|f]      Verbose results\n" );
        printf( "           -y           Display parameters to query\n" );
        printf( "           -z           Additional input line\n" );
        printf( "\n" );

        //
        //  Else call our read routine.
        //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_SETFILE AsyncSetFile;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_SETFILE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\tInputSetFile:  Unable to allocate async structure\n" );

        } else {

            //
            //  If we need a buffer for the rename, allocate it now.
            //

            if (FileRenamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = RenameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate rename structure\n" );

                    DeallocateBuffer( AsyncIndex );
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                RenameIndex = (USHORT) TempIndex;
                RenameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiRenameString,
                                              FALSE );
            }

            //
            //  If we need a buffer for the new name, allocate it now.
            //

            if (FileNamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = NameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate new name structure\n" );

                    DeallocateBuffer( AsyncIndex );

                    if (NameBufferAllocated) {

                        DeallocateBuffer( NameIndex );
                    }
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                NameIndex = (USHORT) TempIndex;
                NameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiNameString,
                                              FALSE );
            }

            //
            //  If we need a buffer for the new short name, allocate it now.
            //

            if (FileShortNamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = ShortNameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate new short name structure\n" );

                    DeallocateBuffer( AsyncIndex );

                    if (ShortNameBufferAllocated) {

                        DeallocateBuffer( ShortNameIndex );
                    }
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                ShortNameIndex = (USHORT) TempIndex;
                ShortNameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiNameString,
                                              FALSE );
            }

            AsyncSetFile = (PASYNC_SETFILE) Buffers[AsyncIndex].Buffer;

            AsyncSetFile->FileIndex = (USHORT) FileIndex;

            AsyncSetFile->BufferLength = BufferLength;
            AsyncSetFile->BufferLengthPtr = BufferLengthPtr
                                            ? &AsyncSetFile->BufferLength
                                            : NULL;

            AsyncSetFile->FileInfoClass = FileInfoClass;

            AsyncSetFile->CreateTimeIndex = CreateTimeIndex;
            AsyncSetFile->CreateTimePtr = CreateTimePtr
                                          ? &AsyncSetFile->CreateTimeIndex
                                          : NULL;

            AsyncSetFile->LastAccessIndex = LastAccessIndex;
            AsyncSetFile->LastAccessPtr = LastAccessPtr
                                          ? &AsyncSetFile->LastAccessIndex
                                          : NULL;

            AsyncSetFile->LastWriteIndex = LastWriteIndex;
            AsyncSetFile->LastWritePtr = LastWritePtr
                                         ? &AsyncSetFile->LastWriteIndex
                                         : NULL;

            AsyncSetFile->ChangeTimeIndex = ChangeTimeIndex;
            AsyncSetFile->ChangeTimePtr = ChangeTimePtr
                                          ? &AsyncSetFile->ChangeTimeIndex
                                          : NULL;

            AsyncSetFile->FileAttributes = FileAttributes;
            AsyncSetFile->FileAttributesPtr = FileAttributesPtr
                                              ? &AsyncSetFile->FileAttributes
                                              : NULL;

            AsyncSetFile->RenameLength = RenameLength;
            AsyncSetFile->RenameLengthPtr = RenameLengthPtr
                                            ? &AsyncSetFile->RenameLength
                                            : NULL;
            AsyncSetFile->ReplaceIfExists = ReplaceIfExists;
            AsyncSetFile->RootDirectoryIndex = RootDirectoryIndex;
            AsyncSetFile->RootDirectoryPtr = RootDirectoryPtr
                                                             ? &AsyncSetFile->RootDirectoryIndex
                                                             : NULL;
            AsyncSetFile->RenameIndex = RenameIndex;
            AsyncSetFile->RenameBufferAllocated = RenameBufferAllocated;

            AsyncSetFile->NameLength = NameLength;
            AsyncSetFile->NameLengthPtr = NameLengthPtr
                                          ? &AsyncSetFile->NameLength
                                          : NULL;
            AsyncSetFile->NameIndex = NameIndex;
            AsyncSetFile->NameBufferAllocated = NameBufferAllocated;

            AsyncSetFile->ShortNameLength = ShortNameLength;
            AsyncSetFile->ShortNameLengthPtr = ShortNameLengthPtr
                                               ? &AsyncSetFile->ShortNameLength
                                               : NULL;
            AsyncSetFile->ShortNameIndex = ShortNameIndex;
            AsyncSetFile->ShortNameBufferAllocated = ShortNameBufferAllocated;

            AsyncSetFile->DeleteFile = DeleteFile;

            AsyncSetFile->NewOffset = NewOffset;

            AsyncSetFile->FileMode = FileMode;

            AsyncSetFile->NewAllocation = NewAllocation;

            AsyncSetFile->NewEof = NewEof;

            AsyncSetFile->DisplayParms = DisplayParms;
            AsyncSetFile->VerboseResults = VerboseResults;
            AsyncSetFile->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullSetFile,
                                             AsyncSetFile,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "InputSetFile:  Spawning thread fails -> %d\n", GetLastError() );

                    if (RenameBufferAllocated) {

                        DeallocateBuffer( RenameIndex );
                    }

                    if (NameBufferAllocated) {

                        DeallocateBuffer( NameIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullSetFile( AsyncSetFile );
            }
        }
    }

    return;
}



VOID
FullSetFile(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    try {

        //
        //  Case on the information type and call the appropriate routine.
        //

        switch (AsyncSetFile->FileInfoClass) {

        case FileBasicInformation:

            SetBasicInformation( AsyncSetFile );
            break;

        case FileRenameInformation:

            SetRenameInformation( AsyncSetFile );
            break;

        case FileLinkInformation:

            SetNameInformation( AsyncSetFile );
            break;

        case FileShortNameInformation:

            SetShortNameInformation( AsyncSetFile );
            break;

        case FileDispositionInformation:

            SetDispositionInformation( AsyncSetFile );
            break;

        case FilePositionInformation:

            SetPositionInformation( AsyncSetFile );
            break;

        case FileModeInformation:

            SetModeInformation( AsyncSetFile );
            break;

        case FileAllocationInformation :

            SetAllocationInformation( AsyncSetFile );
            break;

        case FileEndOfFileInformation :

            SetEofInformation( AsyncSetFile );
            break;

        default:

            bprint  "FullSetInfo:  Unrecognized information class\n" );
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AsyncSetFile->RenameBufferAllocated) {

            DeallocateBuffer( AsyncSetFile->RenameIndex );
        }

        if (AsyncSetFile->NameBufferAllocated) {

            DeallocateBuffer( AsyncSetFile->NameIndex );
        }

        DeallocateBuffer( AsyncSetFile->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}


VOID
SetBasicInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_BASIC_INFORMATION BasicInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    //
    //  Check the parameters for legality.  Void the pointers if the values
    //  are illegal.
    //

    if (AsyncSetFile->CreateTimePtr != NULL
        && (AsyncSetFile->CreateTimeIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->CreateTimeIndex].Used)) {

        bprint  "CreateTimeIndex %04d is invalid\n" );
        AsyncSetFile->CreateTimePtr = NULL;
    }

    if (AsyncSetFile->LastAccessPtr != NULL
        && (AsyncSetFile->LastAccessIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->LastAccessIndex].Used)) {

        bprint  "LastAccessIndex %04d is invalid\n" );
        AsyncSetFile->LastAccessPtr = NULL;
    }

    if (AsyncSetFile->LastWritePtr != NULL
        && (AsyncSetFile->LastWriteIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->LastWriteIndex].Used)) {

        bprint  "LastWriteIndex %04d is invalid\n" );
        AsyncSetFile->LastWritePtr = NULL;
    }

    if (AsyncSetFile->ChangeTimePtr != NULL
        && (AsyncSetFile->ChangeTimeIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->ChangeTimeIndex].Used)) {

        bprint  "ChangeTimeIndex %04d is invalid\n" );
        AsyncSetFile->ChangeTimePtr = NULL;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileBasicInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   CreateTimePtr           -> %08lx\n", AsyncSetFile->CreateTimePtr );

        if (AsyncSetFile->CreateTimePtr) {

            bprint  "   CreateTime              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->CreateTimeIndex].Buffer );
        }

        bprint  "   LastAccessPtr           -> %08lx\n", AsyncSetFile->LastAccessPtr );

        if (AsyncSetFile->LastAccessPtr) {

            bprint  "   LastAccess              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->LastAccessIndex].Buffer );
        }

        bprint  "   LastWritePtr            -> %08lx\n", AsyncSetFile->LastWritePtr );

        if (AsyncSetFile->LastWritePtr) {

            bprint  "   LastWrite               -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->LastWriteIndex].Buffer );
        }

        bprint  "   ChangeTimePtr           -> %08lx\n", AsyncSetFile->ChangeTimePtr );

        if (AsyncSetFile->ChangeTimePtr) {

            bprint  "   ChangeTime              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->ChangeTimeIndex].Buffer );
        }

        bprint  "   FileAttributesPtr       -> %08lx\n", AsyncSetFile->FileAttributesPtr );
        if (AsyncSetFile->FileAttributesPtr) {

            bprint  "   FileAttributes value    -> %08x\n", AsyncSetFile->FileAttributes );
        }

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_BASIC_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            bprint  "\tSetBasicInformation:  Unable to allocate structure\n" );
            try_return( NOTHING );
        }

        UnwindBufferIndex = TRUE;

        BasicInformation = (PFILE_BASIC_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        if (AsyncSetFile->CreateTimePtr) {

            BasicInformation->CreationTime = *((PTIME) Buffers[AsyncSetFile->CreateTimeIndex].Buffer);

        } else {

            BasicInformation->CreationTime.LowPart = 0;
            BasicInformation->CreationTime.HighPart = 0;
        }

        if (AsyncSetFile->LastAccessPtr) {

            BasicInformation->LastAccessTime = *((PTIME) Buffers[AsyncSetFile->LastAccessIndex].Buffer);

        } else {

            BasicInformation->LastAccessTime.LowPart = 0;
            BasicInformation->LastAccessTime.HighPart = 0;
        }

        if (AsyncSetFile->LastWritePtr) {

            BasicInformation->LastWriteTime = *((PTIME) Buffers[AsyncSetFile->LastWriteIndex].Buffer);

        } else {

            BasicInformation->LastWriteTime.LowPart = 0;
            BasicInformation->LastWriteTime.HighPart = 0;
        }

        if (AsyncSetFile->ChangeTimePtr) {

            BasicInformation->ChangeTime = *((PTIME) Buffers[AsyncSetFile->ChangeTimeIndex].Buffer);

        } else {

            BasicInformation->ChangeTime.LowPart = 0;
            BasicInformation->ChangeTime.HighPart = 0;
        }

        if (AsyncSetFile->FileAttributesPtr) {

            BasicInformation->FileAttributes = AsyncSetFile->FileAttributes;

        } else {

            BasicInformation->FileAttributes = 0;
        }

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       BasicInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileBasicInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetBasicInformation:        Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetRenameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_RENAME_INFORMATION RenameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UniRenameName;
    ANSI_STRING AnsiRenameName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a rename specified.
    //

    if (!AsyncSetFile->RenameBufferAllocated) {

        bprint  "Set Rename Information:  No rename was specified\n" );
        return;
    }

    UniRenameName.Buffer = (PWSTR) Buffers[AsyncSetFile->RenameIndex].Buffer;
    UniRenameName.MaximumLength =
    UniRenameName.Length = (USHORT) AsyncSetFile->RenameLength;

    UniRenameName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiRenameName,
                                           &UniRenameName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetFileRenameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileRenameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Replace existing file   -> %d\n", AsyncSetFile->ReplaceIfExists );

        bprint  "   Root directory pointer  -> %d\n", AsyncSetFile->RootDirectoryPtr );
        if (AsyncSetFile->RootDirectoryPtr) {

            bprint  "   Root directory index    -> %d\n", AsyncSetFile->RootDirectoryIndex );
        }

        bprint  "   Rename length           -> %d\n", AsyncSetFile->RenameLength );

        bprint  "   New file name           -> %s\n", AnsiRenameName.Buffer );
        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_RENAME_INFORMATION ) + AsyncSetFile->RenameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetRenameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        RenameInformation = (PFILE_RENAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        RenameInformation->ReplaceIfExists = AsyncSetFile->ReplaceIfExists;
        RenameInformation->RootDirectory = AsyncSetFile->RootDirectoryPtr
                                                           ? Handles[AsyncSetFile->RootDirectoryIndex].Handle
                                                           : 0;
        RenameInformation->FileNameLength = AsyncSetFile->RenameLength;
        RtlMoveMemory( RenameInformation->FileName,
                           UniRenameName.Buffer,
                           AsyncSetFile->RenameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       RenameInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileRenameInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetRenameInformation:       Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiRenameName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_RENAME_INFORMATION NameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a Name specified.
    //

    if (!AsyncSetFile->NameBufferAllocated) {

        bprint  "Set Name Information:  No Name was specified\n" );
        return;
    }

    UnicodeName.Buffer = (PWSTR) Buffers[AsyncSetFile->NameIndex].Buffer;
    UnicodeName.MaximumLength =
    UnicodeName.Length = (USHORT) AsyncSetFile->NameLength;

    UnicodeName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiName,
                                           &UnicodeName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetFileNameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileNameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Replace existing file   -> %d\n", AsyncSetFile->ReplaceIfExists );

        bprint  "   Root directory pointer  -> %d\n", AsyncSetFile->RootDirectoryPtr );
        if (AsyncSetFile->RootDirectoryPtr) {

            bprint  "   Root directory index    -> %d\n", AsyncSetFile->RootDirectoryIndex );
        }

        bprint  "   Name length             -> %d\n", AsyncSetFile->NameLength );

        bprint  "   New file name           -> %s\n", AnsiName.Buffer );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_RENAME_INFORMATION ) + AsyncSetFile->NameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetNameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        NameInformation = (PFILE_RENAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        NameInformation->ReplaceIfExists = AsyncSetFile->ReplaceIfExists;
        NameInformation->RootDirectory = AsyncSetFile->RootDirectoryPtr
                                         ? Handles[AsyncSetFile->RootDirectoryIndex].Handle
                                         : 0;

        NameInformation->FileNameLength = AsyncSetFile->NameLength;
        RtlMoveMemory( NameInformation->FileName,
                       UnicodeName.Buffer,
                       AsyncSetFile->NameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       NameInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileLinkInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetNameInformation:         Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetShortNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_NAME_INFORMATION NameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a Name specified.
    //

    if (!AsyncSetFile->ShortNameBufferAllocated) {

        bprint  "Set Short Name Information:  No Name was specified\n" );
        return;
    }

    UnicodeName.Buffer = (PWSTR) Buffers[AsyncSetFile->ShortNameIndex].Buffer;
    UnicodeName.MaximumLength =
    UnicodeName.Length = (USHORT) AsyncSetFile->ShortNameLength;

    UnicodeName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiName,
                                           &UnicodeName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetShortNameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileShortNameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Name length           -> %d\n", AsyncSetFile->ShortNameLength );

        bprint  "   New short name           -> %s\n", AnsiName.Buffer );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_NAME_INFORMATION ) + AsyncSetFile->ShortNameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetShortNameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        NameInformation = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        NameInformation->FileNameLength = AsyncSetFile->ShortNameLength;
        RtlMoveMemory( NameInformation->FileName,
                       UnicodeName.Buffer,
                       AsyncSetFile->ShortNameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       NameInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileShortNameInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetShortNameInformation:    Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetDispositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_DISPOSITION_INFORMATION DispositionInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileDispositionInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Delete file             -> %d\n", AsyncSetFile->DeleteFile );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_DISPOSITION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetDispositionInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        DispositionInformation = (PFILE_DISPOSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        DispositionInformation->DeleteFile = AsyncSetFile->DeleteFile;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       DispositionInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileDispositionInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetDispositionInformation:  Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetPositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_POSITION_INFORMATION PositionInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FilePositionInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Offset High         -> %08lx\n", AsyncSetFile->NewOffset.HighPart );
        bprint  "   New Offset Low          -> %08lx\n", AsyncSetFile->NewOffset.LowPart );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_POSITION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetPositionInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        PositionInformation = (PFILE_POSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        PositionInformation->CurrentByteOffset = AsyncSetFile->NewOffset;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       PositionInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FilePositionInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetInformationFile:         Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetModeInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_MODE_INFORMATION ModeInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileModeInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   File Mode               -> %08lx\n", AsyncSetFile->FileMode );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_MODE_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetModeInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        ModeInformation = (PFILE_MODE_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        ModeInformation->Mode = AsyncSetFile->FileMode;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       ModeInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileModeInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetModelInformation:        Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetAllocationInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_ALLOCATION_INFORMATION AllocationInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileAllocationInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Allocation High     -> %08lx\n", AsyncSetFile->NewAllocation.HighPart );
        bprint  "   New Allocation Low      -> %08lx\n", AsyncSetFile->NewAllocation.LowPart );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_ALLOCATION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetAllocationInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        AllocationInformation = (PFILE_ALLOCATION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        AllocationInformation->AllocationSize = AsyncSetFile->NewAllocation;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       AllocationInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileAllocationInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetAllocationInformation:   Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetEofInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_END_OF_FILE_INFORMATION EofInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileEofInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Eof High            -> %08lx\n", AsyncSetFile->NewEof.HighPart );
        bprint  "   New Eof Low             -> %08lx\n", AsyncSetFile->NewEof.LowPart );
        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_END_OF_FILE_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetEofInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        EofInformation = (PFILE_END_OF_FILE_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        EofInformation->EndOfFile = AsyncSetFile->NewEof;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       EofInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileEndOfFileInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetEOFInformation:          Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tusn.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestUsn (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputUsn(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputUsn:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputUsn:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_ENUM_USN_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_READ_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_CREATE_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = FSCTL_READ_FILE_USN_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            IoControlCode = FSCTL_WRITE_USN_CLOSE_RECORD;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            IoControlCode = FSCTL_QUERY_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            IoControlCode = FSCTL_DELETE_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: Usn -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Usn operation" );
        printf( "\n                 -oa             Enumerate Usn Data" );
        printf( "\n                 -ob             Read Usn Journal" );
        printf( "\n                 -oc             Create Usn Journal" );
        printf( "\n                 -od             Read File Usn Data" );
        printf( "\n                 -oe             Write Usn Close Record" );
        printf( "\n                 -of             Query Usn Journal" );
        printf( "\n                 -og             Delete Usn Journal" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputUsn:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nUsn Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Usn operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestUsn,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputUsn:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestUsn( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestUsn (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestUsn:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestUsn:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestUsn:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestUsn:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestUsn:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestUsn:  Thread not terminated\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\ttime.c ===
#include "brian.h"

VOID
FullEnterTime(
    PUSHORT BufferPointer,
    CSHORT Year,
    CSHORT Month,
    CSHORT Day,
    CSHORT Hour,
    CSHORT Minute,
    CSHORT Second,
    CSHORT MSecond
    );

VOID
FullDisplayTime (
    USHORT BufferIndex
    );

VOID
PrintTime (
    IN PTIME Time
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( Time, &TimeFields );

    printf( "%02u-%02u-%02u  %02u:%02u:%02u",
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year % 100,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second );

    return;
}

VOID
BPrintTime (
    IN PTIME Time
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( Time, &TimeFields );

    bprint  "%02u-%02u-%02u  %02u:%02u:%02u",
            TimeFields.Month,
            TimeFields.Day,
            ((USHORT) (TimeFields.Year - 1900)) > 100
            ? 0
            : TimeFields.Year - 1900,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second );

    return;
}

VOID
InputEnterTime (
    IN PCHAR ParamBuffer
    )
{
    USHORT ActualIndex;
    PUSHORT BufferPointer;

    CSHORT Year;
    CSHORT Month;
    CSHORT Day;
    CSHORT Hour;
    CSHORT Minute;
    CSHORT Second;
    CSHORT MSecond;

    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    ActualIndex = 0;
    BufferPointer = NULL;

    Year = 1601;
    Month = 1;
    Day = 1;
    Hour = 0;
    Minute = 0;
    Second = 0;
    MSecond = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {
        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualIndex = (USHORT) AsciiToInteger( ParamBuffer );
                    BufferPointer = &ActualIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the year value.
                //
                case 'y' :
                case 'Y' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Year = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Check the month value.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Month = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the day value.
                //

                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Day = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the hour value.
                //

                case 'h' :
                case 'H' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Hour = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the minute value.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Minute = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the second value.
                //

                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Second = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Check the millesecond value.
                //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    MSecond = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: et [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -y<digits>   Year (1601...)" );
        printf( "\n           -m<digits>   Month (1..12)" );
        printf( "\n           -d<digits>   Day (1..31)" );
        printf( "\n           -h<digits>   Hour (0..23)" );
        printf( "\n           -i<digits>   Minute (0..59)" );
        printf( "\n           -s<digits>   Second (0..59)" );
        printf( "\n           -c<digits>   Milleseconds (0..999)" );
        printf( "\n\n" );


    //
    //  Else call the routine to enter the time.
    //

    } else {

        FullEnterTime( BufferPointer,
                       Year,
                       Month,
                       Day,
                       Hour,
                       Minute,
                       Second,
                       MSecond );
    }

   return;
}

VOID
FullEnterTime(
    IN PUSHORT BufferPointer,
    IN CSHORT Year,
    IN CSHORT Month,
    IN CSHORT Day,
    IN CSHORT Hour,
    IN CSHORT Minute,
    IN CSHORT Second,
    IN CSHORT MSecond
    )
{
    NTSTATUS Status;
    TIME_FIELDS TimeFields;
    USHORT BufferIndex;

    //
    //  If we need a buffer, allocate it now.
    //

    try {

        if (BufferPointer == NULL) {

            SIZE_T ThisLength;
            ULONG TempIndex;

            ThisLength = sizeof( TIME );

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

            BufferPointer = &BufferIndex;

            if (!NT_SUCCESS( Status )) {

                printf( "\n\tFullEnterTime:  Unable to allocate a buffer -> %08lx",
                        Status );

                try_return( NOTHING );
            }

            printf( "\n\tFullEnterTime:  Using buffer -> %04x", *BufferPointer );
            printf( "\n" );
        }

        //
        //  Check that the buffer index is valid.
        //

        if (*BufferPointer >= MAX_BUFFERS) {

            printf( "\n\tFullEnterTime:  The buffer index is invalid" );
            try_return( NOTHING );
        }

        //
        //  Enter the values in the time field structure.
        //

        TimeFields.Year = Year;
        TimeFields.Month = Month;
        TimeFields.Day = Day;
        TimeFields.Hour = Hour;
        TimeFields.Minute = Minute;
        TimeFields.Second = Second;
        TimeFields.Milliseconds = MSecond;

        //
        //  Convert the time field to TIME format for our buffer.
        //

        if (!RtlTimeFieldsToTime( &TimeFields,
                                  (PTIME) Buffers[*BufferPointer].Buffer )) {

            printf( "\n\tFullEnterTime:  Invalid time format" );
            try_return( NOTHING );
        }

    try_exit: NOTHING;
    } finally {

    }

    return;
}

VOID
InputDisplayTime (
    IN PCHAR ParamBuffer
    )
{
    USHORT BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = 0;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqf [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        FullDisplayTime( BufferIndex );
    }

    return;
}


VOID
FullDisplayTime (
    USHORT BufferIndex
    )
{
    //
    //  Check that the buffer index is valid and the buffer is used.
    //

    if (BufferIndex >= MAX_BUFFERS
        || Buffers[BufferIndex].Used == FALSE) {

        bprint  "\n\tFullDisplayTime:  Invalid buffer index" );

    } else {

        printf( "\n\tFullDisplayTime:  Index %d    ", BufferIndex );
        PrintTime( (PTIME) Buffers[BufferIndex].Buffer );
    }

    printf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\twrite.c ===
#include "brian.h"

typedef struct _ASYNC_WRITE {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_WRITE, *PASYNC_WRITE;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define WRITE_LENGTH_DEFAULT         100L
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullWrite(
    IN OUT PASYNC_WRITE AsyncWrite
    );


VOID
InputWrite(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    ULONG TempIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN BufferReceived;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = WRITE_LENGTH_DEFAULT;
    ByteOffsetPtr = NULL;
    ByteOffset = RtlConvertUlongToLargeInteger( 0L );
    KeyPtr = NULL;
    Key = 0;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    BufferReceived = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferReceived = TRUE;
                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the key value.
                //

                case 'k' :
                case 'K' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Key = AsciiToInteger( ParamBuffer );
                    KeyPtr = &Key;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the offset of the transfer.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ByteOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                    ByteOffsetPtr = &ByteOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to write another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived && !BufferReceived) {

        printf( "\n   Usage: wr [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Write length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -k<digits>   Locked bytes key value" );
        printf( "\n           -o<digits>   Start offset to write" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our write routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_WRITE AsyncWrite;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_WRITE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputWrite:  Unable to allocate async structure" );

        } else {

            AsyncWrite = (PASYNC_WRITE) Buffers[AsyncIndex].Buffer;

            AsyncWrite->FileIndex = (USHORT) FileIndex;
            AsyncWrite->UseEvent = UseEvent;
            AsyncWrite->ApcRoutine = ApcRoutine;
            AsyncWrite->ApcContext = ApcContext;
            AsyncWrite->BufferIndex = BufferIndex;
            AsyncWrite->BufferIndexPtr = BufferIndexPtr
                                         ? &AsyncWrite->BufferIndex
                                         : BufferIndexPtr;
            AsyncWrite->Length = Length;
            AsyncWrite->ByteOffset = ByteOffset;
            AsyncWrite->ByteOffsetPtr = ByteOffsetPtr
                                        ? &AsyncWrite->ByteOffset
                                        : ByteOffsetPtr;
            AsyncWrite->Key = Key;
            AsyncWrite->KeyPtr = KeyPtr
                                 ? &AsyncWrite->Key
                                 : KeyPtr;
            AsyncWrite->DisplayParms = DisplayParms;
            AsyncWrite->VerboseResults = VerboseResults;
            AsyncWrite->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullWrite,
                                             AsyncWrite,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputWrite:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }
            } else  {

                FullWrite( AsyncWrite );
            }
        }
    }
    return;
}


VOID
FullWrite(
    IN OUT PASYNC_WRITE AsyncWrite
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindWriteBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncWrite->DisplayParms) {

        bprint  "\nWrite Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncWrite->FileIndex );
        bprint  "\n   UseEvent                -> %d", AsyncWrite->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncWrite->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncWrite->ApcContext );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncWrite->BufferIndexPtr );
        if (AsyncWrite->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncWrite->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncWrite->Length );

        bprint  "\n   Byte Offset             -> %08lx", AsyncWrite->ByteOffsetPtr );
        if ( AsyncWrite->ByteOffsetPtr ) {

            bprint  "\n   Byte Offset High        -> %08lx", AsyncWrite->ByteOffset.HighPart );
            bprint  "\n   Byte Offset Low         -> %08lx", AsyncWrite->ByteOffset.LowPart );
        }

        bprint  "\n   Key Ptr                 -> %08lx", AsyncWrite->KeyPtr );

        if (AsyncWrite->KeyPtr) {

            bprint  "\n   Key                     -> %ul", AsyncWrite->Key );
        }

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncWrite->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = AsyncWrite->Length;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullWrite:  Unable to allocate a Write buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullWrite:  Writeing into buffer -> %04x", ThisBufferIndex );

            UnwindWriteBuffer = TRUE;

        } else {

            ThisBufferIndex = AsyncWrite->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullWrite:  The Write buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncWrite->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullWrite:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncWrite->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullWrite:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the write routine.
        //

        Status = NtWriteFile( Handles[AsyncWrite->FileIndex].Handle,
                             ThisEvent,
                             AsyncWrite->ApcRoutine,
                             AsyncWrite->ApcContext,
                             &Iosb,
                             Buffers[ThisBufferIndex].Buffer,
                             AsyncWrite->Length,
                             AsyncWrite->ByteOffsetPtr,
              AsyncWrite->KeyPtr );

        UnwindWriteBuffer = FALSE;

        if (AsyncWrite->VerboseResults) {

            bprint  "\nWriteFIle:  Status            -> %08lx", Status );

            if (AsyncWrite->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tWriteFile:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n           Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n           Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindWriteBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncWrite->AsyncIndex );
    }

    NtTerminateThread( 0, STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\dismount\dismount.c ===
//  dismount.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];


    //
    //  Get parameter
    //

    if (argc < 2) {
    
        printf("This program dismounts a volume.\n\n");
        printf("usage: %s <driveletter>:\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    Status = NtFsControlFile( Volume,                          // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_DISMOUNT_VOLUME,           // FsControlCode
                              NULL,                            // input buffer
                              0,                               // input buffer length
                              NULL,                            // OutputBuffer for data from the FS
                              0);                              // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nDismount succeeded." );

    } else {

        printf( "\nDismount failed with status %x", Status );
    }

    CloseHandle( Volume );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\bshell\tsparse.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestSparse (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputSparse(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputSparse:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputSparse:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_SET_SPARSE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_SET_ZERO_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_QUERY_ALLOCATED_RANGES;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: Sparse -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Sparse operation" );
        printf( "\n                 -oa             Set Sparse" );
        printf( "\n                 -ob             Zero Range" );
        printf( "\n                 -oc             Query Allocated Ranges" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputSparse:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nSparse Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Sparse operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestSparse,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputSparse:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestSparse( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestSparse (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestSparse:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestSparse:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestSparse:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestSparse:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestSparse:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );

    bprint  "\nRequestSparse:  Thread not terminated\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\fastfind\fastfind.c ===
//  fastfind.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>
#include <myntfs.h>

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14

typedef struct _EXTENT {

    LONGLONG Vcn;
    LONGLONG Lcn;
    LONGLONG Length;

} EXTENT, *PEXTENT;

#define MAX_EXTENTS 64

//
//  Some globals.
//

LARGE_INTEGER MftStart;
ULONG ClusterSize;
ULONG FrsSize;
EXTENT Extents[MAX_EXTENTS];
ULONG DebugLevel;
UCHAR CacheBuffer[0x10000];   // max cluster size
LONGLONG CachedOffset = -1;
char mybuffer[32768];

LONGLONG
ComputeFileRecordLbo (
    IN ULONG MftIndex
    )
{
    LONGLONG vcn;
    LONGLONG lcn = 0;
    ULONG extentIndex;
    ULONG offsetWithinCluster;

    vcn = (MftIndex * FrsSize) / ClusterSize;

    for (extentIndex = 0; extentIndex < MAX_EXTENTS; extentIndex += 1) {

        if ((vcn >= Extents[extentIndex].Vcn) &&
            (vcn < Extents[extentIndex].Vcn + Extents[extentIndex].Length)) {

            lcn = Extents[extentIndex].Lcn + (vcn - Extents[extentIndex].Vcn);
        }
    }

    if (ClusterSize >= FrsSize ) {

        offsetWithinCluster = (MftIndex % (ClusterSize / FrsSize)) * FrsSize;        
        return (lcn * ClusterSize + offsetWithinCluster); 

    } else {

        //
        //  BUGBUG keithka 4/28/00 Handle old fashioned big frs and/or big
        //  clusters someday.
        //

        ASSERT( FALSE );
        return 0;
    }
}

VOID
FindAttributeInFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    IN PATTRIBUTE_RECORD_HEADER PreviousAttribute OPTIONAL,
    OUT PATTRIBUTE_RECORD_HEADER *Attribute
    )
// Attribute set to NULL if not found.
{
    PATTRIBUTE_RECORD_HEADER attr;

    *Attribute = NULL;
    
    if (FileRecord->Pad0[0] != 'F' ||
        FileRecord->Pad0[1] != 'I' ||
        FileRecord->Pad0[2] != 'L' ||
        FileRecord->Pad0[3] != 'E') {

        if (DebugLevel >= 1) {
        
            printf( "\nBad MFT record %c%c%c%c", 
                    FileRecord->Pad0[0],
                    FileRecord->Pad0[1],
                    FileRecord->Pad0[2],
                    FileRecord->Pad0[3] );
        }

        //
        //  This isn't a good file record, but that doesn't make this a corrupt volume.
        //  It's possible that this file record has never been used.  Since we don't look
        //  at the MFT bitmap, we don't know if this was expected to be a valid filerecord.
        //  The output Attribute is set to NULL already, so we can exit now.
        //

        return;
    }

    if (0 == (FileRecord->Flags & FILE_RECORD_SEGMENT_IN_USE)) {

        //
        //  File record not in use, skip it.
        //

        return;
    }

    if (NULL == PreviousAttribute) {

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR)FileRecord + FileRecord->FirstAttributeOffset);

    } else {

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR) PreviousAttribute + PreviousAttribute->RecordLength);

        if (((PUCHAR)attr - (PUCHAR)FileRecord) > (LONG) FrsSize) {

            ASSERT (FALSE);
            return;
        }
    }

    while (attr->TypeCode < TypeCode &&
           attr->TypeCode != $END) {

        ASSERT( attr->RecordLength < FrsSize );

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR) attr + attr->RecordLength);

        //
        //  BUGBUG keitha 4/20/00 need to handle attribute list case someday...
        //  It's relativley rare that an MFT gets so fragmented it needs an 
        //  attribute list.  Certainly rare enough to skip it for now in a 
        //  piece of test code.
        //
    }

    if (attr->TypeCode == TypeCode) {

        *Attribute = attr;
    }

    return;
}

BOOLEAN
FindNameInFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PWCHAR FileName,
    IN ULONG FileNameLength
    )
{
    PATTRIBUTE_RECORD_HEADER attr;
    PFILE_NAME fileNameAttr;
    ULONG cmpResult;

    FindAttributeInFileRecord( FileRecord,
                               $FILE_NAME,
                               NULL,
                               &attr );

    while (NULL != attr) {

        if (((PUCHAR)attr - (PUCHAR)FileRecord) > (LONG) FrsSize) {

            ASSERT( FALSE );
            return FALSE;
        }

        //
        //  Names shouldn't go nonresident.
        //

        if (attr->FormCode != RESIDENT_FORM) {

            ASSERT( FALSE );
            return FALSE;
        }

        fileNameAttr = (PFILE_NAME) ((PUCHAR)attr + attr->Form.Resident.ValueOffset);

        if (fileNameAttr->FileNameLength == FileNameLength) {
        
            cmpResult = wcsncmp( FileName,
                                 (PWCHAR) fileNameAttr->FileName,
                                 fileNameAttr->FileNameLength );

            if (0 == cmpResult) {

                return TRUE;
            }

        } else if (DebugLevel >= 3) {

            printf( "\nNot a match %S,%S", FileName, fileNameAttr->FileName );
        }

        //
        //  Find the next filename, if any.
        //

        FindAttributeInFileRecord( FileRecord,
                                   $FILE_NAME,
                                   attr,
                                   &attr );
    }

    return FALSE;
}


int
FsTestOpenById (
    IN UCHAR *ObjectId,
    IN HANDLE VolumeHandle
    )
{
    HANDLE File;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    NTSTATUS GetNameStatus;
    NTSTATUS CloseStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;
    WCHAR nameBuffer[MAX_PATH];
    PFILE_NAME_INFORMATION FileName;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants

    RtlInitUnicodeString( &str, Full );

    str.Length = 8;
    RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                   ObjectId,
                   8 );

    InitializeObjectAttributes( &ObjectAttributes,
                                &str,
                                OBJ_CASE_INSENSITIVE,
                                VolumeHandle,
                                NULL );

    Status = NtCreateFile( &File,
                           GENERIC_READ, 
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_BY_FILE_ID,
                           NULL,
                           0 );

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory( nameBuffer, sizeof(nameBuffer) );
        FileName = (PFILE_NAME_INFORMATION) &nameBuffer[0];
        FileName->FileNameLength = sizeof(nameBuffer) - sizeof(ULONG);

        GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                sizeof(nameBuffer),
                                                FileNameInformation );

        printf( "%S\n", FileName->FileName );

        CloseStatus = NtClose( File );

        if (!NT_SUCCESS( CloseStatus )) {

            printf( "\nCloseStatus %x", CloseStatus );
        }
    }

    return Status;
}

NTSTATUS
ReadFileRecord (
    IN HANDLE VolumeHandle,
    IN ULONG RecordIndex,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS status;
    LARGE_INTEGER byteOffset;
    IO_STATUS_BLOCK ioStatusBlock;    
    ULONG offsetWithinBuffer;

    byteOffset.QuadPart = ComputeFileRecordLbo( RecordIndex );

    if (FrsSize >= ClusterSize) {

        status = NtReadFile( VolumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &ioStatusBlock,
                             Buffer,
                             FrsSize,
                             &byteOffset,    //  ByteOffset
                             NULL );         //  Key

    } else {

        //
        //  Clusters bigger than filerecords, do cluster
        //  size reads and dice up the returns.
        //

        if ((-1 == CachedOffset) ||
            (byteOffset.QuadPart < CachedOffset) ||
            ((byteOffset.QuadPart + FrsSize) > (CachedOffset + ClusterSize))) {

            if (DebugLevel >= 1) {

                printf( "\nCache miss at %I64x", byteOffset.QuadPart );
            }

            status = NtReadFile( VolumeHandle,
                                 NULL,            //  Event
                                 NULL,            //  ApcRoutine
                                 NULL,            //  ApcContext
                                 &ioStatusBlock,
                                 CacheBuffer,
                                 ClusterSize,
                                 &byteOffset,    //  ByteOffset
                                 NULL );         //  Key

            if (STATUS_SUCCESS != status) {

                //
                //  The cache buffer may be junk now, reread it next time.
                //

                CachedOffset = -1;
                return status;
            }

            CachedOffset = byteOffset.QuadPart;
            offsetWithinBuffer = 0;

        } else {

            if (DebugLevel >= 1) {

                printf( "\nCache hit at %I64x", byteOffset.QuadPart );
            }
            offsetWithinBuffer = (ULONG) (byteOffset.QuadPart % CachedOffset);
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory( Buffer, CacheBuffer + offsetWithinBuffer, FrsSize );
    }

    return status;
}


int
FastFind (
    IN PWCHAR FileName,
    IN PWCHAR DriveLetter
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING str;
    NTSTATUS Status;
    NTSTATUS ReadStatus;
    NTSTATUS CloseStatus;
    LARGE_INTEGER byteOffset;
    LONGLONG mftBytesRead;
    HANDLE volumeHandle;
    DWORD WStatus;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants
    WCHAR Volume[] = VOLUME_PATH;
    BIOS_PARAMETER_BLOCK bpb;
    PPACKED_BOOT_SECTOR bootSector;
    PFILE_RECORD_SEGMENT_HEADER fileRecord;
    PATTRIBUTE_RECORD_HEADER attr;
    VCN nextVcn;
    VCN currentVcn;
    VCN vcnDelta;
    LCN currentLcn;
    LCN lcnDelta;
    PUCHAR bsPtr;
    UCHAR v;
    UCHAR l;
    UCHAR i;
    ULONG extentCount;
    ULONG recordIndex;
    ULONG mftRecords;
    ULONG fileNameLength;
    MFT_SEGMENT_REFERENCE segRef;

    RtlInitUnicodeString( &str, Full );

    RtlCopyMemory( &str.Buffer[FULL_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    str.Length = 0x1E;

    //
    //  Open the volume for relative opens.
    //

    RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    printf( "\nOpening volume handle, this may take a while..." );
    volumeHandle = CreateFileW( (PUSHORT) &Volume,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );

    if (volumeHandle == INVALID_HANDLE_VALUE) {

        WStatus = GetLastError();
        printf( "Unable to open %ws volume\n", &Volume );
        printf( "Error from CreateFile", WStatus );
        return WStatus;
    }

    printf( "\nVolume handle opened, starting MFT scan" );
    byteOffset.QuadPart = 0;

    ReadStatus = NtReadFile( volumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &IoStatusBlock,
                             mybuffer,
                             0x200,
                             &byteOffset,    //  ByteOffset
                             NULL );         //  Key

    if (STATUS_SUCCESS != ReadStatus) {

        printf( "\nBoot sector read failed with status %x", ReadStatus );
        goto exit;
    }

    bootSector = (PPACKED_BOOT_SECTOR) mybuffer;

    if (bootSector->Oem[0] != 'N' ||
        bootSector->Oem[1] != 'T' ||
        bootSector->Oem[2] != 'F' ||
        bootSector->Oem[3] != 'S') {

        printf( "\nNot an NTFS volume" );
        goto exit;
    }

    NtfsUnpackBios( &bpb, &bootSector->PackedBpb );

    ClusterSize = bpb.BytesPerSector * bpb.SectorsPerCluster;
    if (bootSector->ClustersPerFileRecordSegment < 0) {

        FrsSize = 1 << (-1 * bootSector->ClustersPerFileRecordSegment);

    } else {

        FrsSize = bootSector->ClustersPerFileRecordSegment * ClusterSize;
    }
    
    MftStart.QuadPart = ClusterSize * bootSector->MftStartLcn;

    mftBytesRead = 0;

    ReadStatus = NtReadFile( volumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &IoStatusBlock,
                             mybuffer,
                             FrsSize,
                             &MftStart,      //  ByteOffset
                             NULL );         //  Key

    if (STATUS_SUCCESS != ReadStatus) {

        printf( "\nMFT record 0 read failed with status %x", ReadStatus );
        goto exit;
    }

    mftBytesRead += IoStatusBlock.Information;

    FindAttributeInFileRecord( (PFILE_RECORD_SEGMENT_HEADER) mybuffer,
                               $DATA,
                               NULL,
                               &attr );
    
    if (NULL == attr) {

        printf( "\nMFT record 0 has no $DATA attribute" );
        goto exit;
    }

    if (attr->FormCode == RESIDENT_FORM) {

        printf( "\nVolume has very few files, use dir /s" );
        goto exit;        
    }

    //
    //  BUGBUG keithka 4/28/00 Handle MFT with more than 4billion entries.
    //

    ASSERT (attr->Form.Nonresident.FileSize <= MAXULONG);
    mftRecords = (ULONG) (attr->Form.Nonresident.FileSize / FrsSize);
    
    //
    //  Crack mapping pairs, read those clusters in a few big trnasfers, 
    //  seek out given filename in those buffers.
    //

    nextVcn = attr->Form.Nonresident.LowestVcn;
    currentLcn = 0;
    extentCount = 0;
    RtlZeroMemory( Extents, sizeof(Extents) );

    bsPtr = ((PUCHAR) attr) + attr->Form.Nonresident.MappingPairsOffset;

    while (*bsPtr != 0) {

        currentVcn = nextVcn;

        //
        //  Variable names v and l used for consistency with comments in 
        //  ATTRIBUTE_RECORD_HEADER struct explaining how to decompress
        //  mapping pair information.
        //
        
        v = (*bsPtr) & 0xf;
        l = ((*bsPtr) & 0xf0) >> 4;

        bsPtr += 1;

        for (vcnDelta = 0, i = 0; i < v; i++) {

            vcnDelta += *(bsPtr++) << (8 * i);
        }

        for (lcnDelta = 0, i = 0; i < l; i++) {

            lcnDelta += *(bsPtr++) << (8 * i);
        }

        //
        //  Sign extend.
        //

        if (0x80 & (*(bsPtr - 1))) {
        
            for(; i < sizeof(lcnDelta); i++) {

                lcnDelta += 0xff << (8 * i);
            }
        }

        currentLcn += lcnDelta;
        // printf( "\nVcn %I64x, Lcn %I64x, Length %I64x", currentVcn, currentLcn, vcnDelta );

        if (extentCount < MAX_EXTENTS) {

            Extents[extentCount].Vcn    = currentVcn;
            Extents[extentCount].Lcn    = currentLcn;
            Extents[extentCount].Length = vcnDelta;

            extentCount += 1;

        } else {

            printf( "\nExcessive MFT fragmentation, redefine MAX_EXTENTS and recompile" );
        }

        currentVcn += vcnDelta;
    }

    //
    //  Now we know where the MFT is, let's go read it.
    //

    fileNameLength = wcslen( FileName );

    for (recordIndex = 0; recordIndex <= mftRecords; recordIndex++) {

        ReadStatus = ReadFileRecord( volumeHandle,
                                     recordIndex,
                                     mybuffer );
                        
        if (STATUS_SUCCESS != ReadStatus) {

            printf( "\nMFT record read failed with status %x", ReadStatus );
            goto exit;
        }

        if (FindNameInFileRecord( (PFILE_RECORD_SEGMENT_HEADER) mybuffer,
                                  FileName,
                                  fileNameLength )) {

            //
            //  Found a match, open by id and retrieve name.
            //

            if (DebugLevel >= 1) {

                printf( "\nFound match in file %08x %08x\n", 
                        ((PFILE_RECORD_SEGMENT_HEADER) mybuffer)->SequenceNumber,
                        recordIndex );

            } else {

                printf( "\n" );
            }

            segRef.SegmentNumberLowPart = recordIndex;
            segRef.SegmentNumberHighPart = 0;
            segRef.SequenceNumber = ((PFILE_RECORD_SEGMENT_HEADER) mybuffer)->SequenceNumber;

            FsTestOpenById( (PUCHAR) &segRef, volumeHandle );
        }

        //
        //  The number 0x400 is completely arbitrary.  It's a reasonable interval
        //  of work to do before printing another period to tell the user we're 
        //  making progress still.
        //

        if (0 == (recordIndex % 0x400)) {

            printf( "." );
        }
    }

exit:
    if (volumeHandle != NULL) {

        CloseHandle( volumeHandle );
    }

    return 0;
}

VOID
FastFindHelp (
    char *ExeName
    )
{

    printf( "This program finds a file by scanning the MFT (ntfs only).\n\n" );
    printf( "usage: %s x: filename\n", ExeName );

    printf( "Where x: is the drive letter\n" );
    printf( "example:\n" );
    printf( "%s d: windows.h", ExeName );
}

VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    WCHAR drive;
    ANSI_STRING fileName;
    WCHAR uniBuff[MAX_PATH];
    UNICODE_STRING uniFileName;

    //
    //  Get parameters.
    //

    if (argc < 3) {

        FastFindHelp( argv[0] );
        return;
    }

    if (argc >= 4) {

        sscanf( argv[3], "%x", &DebugLevel );

    } else {

        DebugLevel = 0;
    }

    drive = *argv[1];

    RtlInitAnsiString( &fileName, argv[2] );
    uniFileName.Buffer = uniBuff;
    RtlAnsiStringToUnicodeString( &uniFileName, &fileName, FALSE );
    
    FastFind( uniFileName.Buffer, &drive );
 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\fastfind\myntfs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MyNtfs.h

Current Version Numbers:

    Major.Minor Version:  1.2

Abstract:

    This module defines some on-disk structure of the Ntfs file system as 
    needed by findfast.exe.

*/

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(D,S) {                                \
    *((UCHAR1 *)(D)) = *((UNALIGNED UCHAR1 *)(S)); \
}

#define CopyUchar2(D,S) {                                \
    *((UCHAR2 *)(D)) = *((UNALIGNED UCHAR2 *)(S)); \
}

#define CopyUchar4(D,S) {                                \
    *((UCHAR4 *)(D)) = *((UNALIGNED UCHAR4 *)(S)); \
}


typedef LONGLONG LCN;
typedef LCN *PLCN;

typedef LONGLONG VCN;
typedef VCN *PVCN;

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {

    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;

} BIOS_PARAMETER_BLOCK;

typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked
//  equivalent
//

#define NtfsUnpackBios(Bios,Pbios) {                                       \
    CopyUchar2(&((Bios)->BytesPerSector),    &(Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), &(Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   &(Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              &(Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       &(Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           &(Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             &(Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     &(Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   &(Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             &(Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     &(Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      &(Pbios)->LargeSectors     ); \
}

typedef ULONG ATTRIBUTE_TYPE_CODE;
typedef ATTRIBUTE_TYPE_CODE *PATTRIBUTE_TYPE_CODE;

//
//  System-defined Attribute Type Codes.  For the System-defined
//  attributes, the Unicode Name is exactly equal to the name of the
//  following symbols.  For this reason, all of the system-defined
//  attribute names start with "$", to always distinguish them when
//  attribute names are listed, and to reserve a namespace for
//  attributes defined in the future.  I.e., a User-Defined
//  attribute name will never collide with a current or future
//  system-defined attribute name if it does not start with "$".
//  User attribute numbers should not start until
//  $FIRST_USER_DEFINED_ATTRIBUTE, to allow the potential for
//  upgrading existing volumes with new user-defined attributes in
//  future versions of NTFS.  The tagged attribute list is
//  terminated with a lone-standing 0 ($END) - the rest of the
//  attribute record does not exist.
//
//  The type code value of 0 is reserved for convenience of the
//  implementation.
//

#define $UNUSED                          (0X0)

#define $STANDARD_INFORMATION            (0x10)
#define $ATTRIBUTE_LIST                  (0x20)
#define $FILE_NAME                       (0x30)
#define $OBJECT_ID                       (0x40)
#define $SECURITY_DESCRIPTOR             (0x50)
#define $VOLUME_NAME                     (0x60)
#define $VOLUME_INFORMATION              (0x70)
#define $DATA                            (0x80)
#define $INDEX_ROOT                      (0x90)
#define $INDEX_ALLOCATION                (0xA0)
#define $BITMAP                          (0xB0)
#define $REPARSE_POINT                   (0xC0)
#define $EA_INFORMATION                  (0xD0)
#define $EA                              (0xE0)
// #define $LOGGED_UTILITY_STREAM           (0x100) // defined in ntfsexp.h
#define $FIRST_USER_DEFINED_ATTRIBUTE    (0x1000)
#define $END                             (0xFFFFFFFF)

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                              //  offset = 0x000
    UCHAR Oem[8];                                                               //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                                      //  offset = 0x00B
    UCHAR Unused[4];                                                            //  offset = 0x024
    LONGLONG NumberSectors;                                                     //  offset = 0x028
    LCN MftStartLcn;                                                            //  offset = 0x030
    LCN Mft2StartLcn;                                                           //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                                          //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                               //  offset = 0x044
    UCHAR Reserved1[3];
    LONGLONG SerialNumber;                                                      //  offset = 0x048
    ULONG Checksum;                                                             //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                               //  offset = 0x054

} PACKED_BOOT_SECTOR;                                                           //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
//  The MFT Segment Reference is an address in the MFT tagged with
//  a circularly reused sequence number set at the time that the MFT
//  Segment Reference was valid.  Note that this format limits the
//  size of the Master File Table to 2**48 segments.  So, for
//  example, with a 1KB segment size the maximum size of the master
//  file would be 2**58 bytes, or 2**28 gigabytes.
//

typedef struct _MFT_SEGMENT_REFERENCE {

    //
    //  First a 48 bit segment number.
    //

    ULONG SegmentNumberLowPart;                                    //  offset = 0x000
    USHORT SegmentNumberHighPart;                                  //  offset = 0x004

    //
    //  Now a 16 bit nonzero sequence number.  A value of 0 is
    //  reserved to allow the possibility of a routine accepting
    //  0 as a sign that the sequence number check should be
    //  repressed.
    //

    USHORT SequenceNumber;                                          //  offset = 0x006

} MFT_SEGMENT_REFERENCE, *PMFT_SEGMENT_REFERENCE;                   //  sizeof = 0x008

//
//  A file reference in NTFS is simply the MFT Segment Reference of
//  the Base file record.
//

typedef MFT_SEGMENT_REFERENCE FILE_REFERENCE, *PFILE_REFERENCE;

//
//  File Record Segment.  This is the header that begins every File
//  Record Segment in the Master File Table.
//

typedef struct _FILE_RECORD_SEGMENT_HEADER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    UCHAR Pad0[0x10];                                               //  offset = 0x000

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    UCHAR Pad1[8];                                                  //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Current FRS record - this is here for recovery alone and added in 5.1
    //  Note: this is not aligned
    // 

    USHORT SegmentNumberHighPart;                                  //  offset = 0x02A
    ULONG SegmentNumberLowPart;                                    //  offset = 0x02C

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UCHAR Pad2[1];                                                  //  offset = 0x030

} FILE_RECORD_SEGMENT_HEADER;
typedef FILE_RECORD_SEGMENT_HEADER *PFILE_RECORD_SEGMENT_HEADER;

//
//  FILE_xxx flags.
//

#define FILE_RECORD_SEGMENT_IN_USE       (0x0001)
#define FILE_FILE_NAME_INDEX_PRESENT     (0x0002)
#define FILE_SYSTEM_FILE                 (0x0004)
#define FILE_VIEW_INDEX_PRESENT          (0x0008)

//
//  Attribute Record.  Logically an attribute has a type, an
//  optional name, and a value, however the storage details make it
//  a little more complicated.  For starters, an attribute's value
//  may either be resident in the file record segment itself, on
//  nonresident in a separate data stream.  If it is nonresident, it
//  may actually exist multiple times in multiple file record
//  segments to describe different ranges of VCNs.
//
//  Attribute Records are always aligned on a quad word (64-bit)
//  boundary.
//

typedef struct _ATTRIBUTE_RECORD_HEADER {

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE TypeCode;                                   //  offset = 0x000

    //
    //  Length of this Attribute Record in bytes.  The length is
    //  always rounded to a quad word boundary, if necessary.  Also
    //  the length only reflects the size necessary to store the
    //  given record variant.
    //

    ULONG RecordLength;                                             //  offset = 0x004

    //
    //  Attribute Form Code (see below)
    //

    UCHAR FormCode;                                                 //  offset = 0x008

    //
    //  Length of the optional attribute name in characters, or 0 if
    //  there is none.
    //

    UCHAR NameLength;                                               //  offset = 0x009

    //
    //  Offset to the attribute name from start of attribute record,
    //  in bytes, if it exists.  This field is undefined if
    //  NameLength is 0.
    //

    USHORT NameOffset;                                              //  offset = 0x00A

    //
    //  ATTRIBUTE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x00E

    //
    //  The following union handles the cases distinguished by the
    //  Form Code.
    //

    union {

        //
        //  Resident Form.  Attribute resides in file record segment.
        //

        struct {

            //
            //  Length of attribute value in bytes.
            //

            ULONG ValueLength;                                      //  offset = 0x010

            //
            //  Offset to value from start of attribute record, in
            //  bytes.
            //

            USHORT ValueOffset;                                     //  offset = 0x014

            //
            //  RESIDENT_FORM_xxx Flags.
            //

            UCHAR ResidentFlags;                                    //  offset = 0x016

            //
            //  Reserved.
            //

            UCHAR Reserved;                                         //  offset = 0x017

        } Resident;

        //
        //  Nonresident Form.  Attribute resides in separate stream.
        //

        struct {

            //
            //  Lowest VCN covered by this attribute record.
            //

            VCN LowestVcn;                                          //  offset = 0x010

            //
            //  Highest VCN covered by this attribute record.
            //

            VCN HighestVcn;                                         //  offset = 0x018

            //
            //  Offset to the Mapping Pairs Array  (defined below),
            //  in bytes, from the start of the attribute record.
            //

            USHORT MappingPairsOffset;                              //  offset = 0x020

            //
            //  Unit of Compression size for this stream, expressed
            //  as a log of the cluster size.
            //
            //      0 means file is not compressed
            //      1, 2, 3, and 4 are potentially legal values if the
            //          stream is compressed, however the implementation
            //          may only choose to use 4, or possibly 3.  Note
            //          that 4 means cluster size time 16.  If convenient
            //          the implementation may wish to accept a
            //          reasonable range of legal values here (1-5?),
            //          even if the implementation only generates
            //          a smaller set of values itself.
            //

            UCHAR CompressionUnit;                                  //  offset = 0x022

            //
            //  Reserved to get to quad word boundary.
            //

            UCHAR Reserved[5];                                      //  offset = 0x023

            //
            //  Allocated Length of the file in bytes.  This is
            //  obviously an even multiple of the cluster size.
            //  (Not present if LowestVcn != 0.)
            //

            LONGLONG AllocatedLength;                               //  offset = 0x028

            //
            //  File Size in bytes (highest byte which may be read +
            //  1).  (Not present if LowestVcn != 0.)
            //

            LONGLONG FileSize;                                      //  offset = 0x030

            //
            //  Valid Data Length (highest initialized byte + 1).
            //  This field must also be rounded to a cluster
            //  boundary, and the data must always be initialized to
            //  a cluster boundary. (Not present if LowestVcn != 0.)
            //

            LONGLONG ValidDataLength;                               //  offset = 0x038

            //
            //  Totally allocated.  This field is only present for the first
            //  file record of a compressed stream.  It represents the sum of
            //  the allocated clusters for a file.
            //

            LONGLONG TotalAllocated;                                //  offset = 0x040

            //
            //
            //  Mapping Pairs Array, starting at the offset stored
            //  above.
            //
            //  The Mapping Pairs Array is stored in a compressed
            //  form, and assumes that this information is
            //  decompressed and cached by the system.  The reason
            //  for compressing this information is clear, it is
            //  done in the hopes that all of the retrieval
            //  information always fits in a single file record
            //  segment.
            //
            //  Logically, the MappingPairs Array stores a series of
            //  NextVcn/CurrentLcn pairs.  So, for example, given
            //  that we know the first Vcn (from LowestVcn above),
            //  the first Mapping Pair tells us what the next Vcn is
            //  (for the next Mapping Pair), and what Lcn the
            //  current Vcn is mapped to, or 0 if the Current Vcn is
            //  not allocated.  (This is exactly the FsRtl MCB
            //  structure).
            //
            //  For example, if a file has a single run of 8
            //  clusters, starting at Lcn 128, and the file starts
            //  at LowestVcn=0, then the Mapping Pairs array has
            //  just one entry, which is:
            //
            //    NextVcn = 8
            //    CurrentLcn = 128
            //
            //  The compression is implemented with the following
            //  algorithm.  Assume that you initialize two "working"
            //  variables as follows:
            //
            //    NextVcn = LowestVcn (from above)
            //    CurrentLcn = 0
            //
            //  The MappingPairs array is byte stream, which simply
            //  store the changes to the working variables above,
            //  when processed sequentially.  The byte stream is to
            //  be interpreted as a zero-terminated stream of
            //  triples, as follows:
            //
            //    count byte = v + (l * 16)
            //
            //      where v = number of changed low-order Vcn bytes
            //            l = number of changed low-order Lcn bytes
            //
            //    v Vcn change bytes
            //    l Lcn change bytes
            //
            //  The byte stream terminates when a count byte of 0 is
            //  encountered.
            //
            //  The decompression algorithm goes as follows,
            //  assuming that Attribute is a pointer to the
            //  attribute record.
            //
            //  1.  Initialize:
            //          NextVcn = Attribute->LowestVcn;
            //          CurrentLcn = 0;
            //
            //  2.  Initialize byte stream pointer to: (PCHAR)Attribute +
            //      Attribute->AttributeForm->Nonresident->MappingPairsOffset
            //
            //  3.  CurrentVcn = NextVcn;
            //
            //  4.  Read next byte from stream.  If it is 0, then
            //      break, else extract v and l (see above).
            //
            //  5.  Interpret the next v bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to NextVcn.
            //      (It can really only be positive, but the Lcn
            //      change can be positive or negative.)
            //
            //  6.  Interpret the next l bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to
            //      CurrentLcn.  Remember, if this produces a
            //      CurrentLcn of 0, then the Vcns from the
            //      CurrentVcn to NextVcn-1 are unallocated.
            //
            //  7.  Update cached mapping information from
            //      CurrentVcn, NextVcn and CurrentLcn.
            //
            //  8.  Loop back to 3.
            //
            //  The compression algorithm should now be obvious, as
            //  it is the reverse of the above.  The compression and
            //  decompression algorithms will be available as common
            //  RTL routines, available to NTFS and file utilities.
            //
            //  In defense of this algorithm, not only does it
            //  provide compression of the on-disk storage
            //  requirements, but it results in a single
            //  representation, independent of disk size and file
            //  size.  Contrast this with solutions which are in use
            //  which define multiple sizes for virtual and logical
            //  cluster sizes, depending on the size of the disk,
            //  etc.  For example, two byte cluster numbers might
            //  suffice for a floppy, while four bytes would be
            //  required for most hard disks today, and five or six
            //  bytes are required after a certain number of
            //  gigabytes, etc.  This eventually results in more
            //  complex code than above (because of the cases) and
            //  worse yet - untested cases.  So, more important than
            //  the compression, the above algorithm provides one
            //  case which efficiently handles any size disk.
            //

        } Nonresident;

    } Form;

} ATTRIBUTE_RECORD_HEADER;
typedef ATTRIBUTE_RECORD_HEADER *PATTRIBUTE_RECORD_HEADER;

//
//  Attribute Form Codes
//

#define RESIDENT_FORM                    (0x00)
#define NONRESIDENT_FORM                 (0x01)

//
//  File Name attribute.  A file has one File Name attribute for
//  every directory it is entered into (hard links).
//

typedef struct _FILE_NAME {

    //
    //  This is a File Reference to the directory file which indexes
    //  to this name.
    //

    FILE_REFERENCE ParentDirectory;                                 //  offset = 0x000

    //
    //  Information for faster directory operations.
    //

    UCHAR Pad0[0x38];                                               //  offset = 0x008

    //
    //  Length of the name to follow, in (Unicode) characters.
    //

    UCHAR FileNameLength;                                           //  offset = 0x040

    //
    //  FILE_NAME_xxx flags
    //

    UCHAR Flags;                                                    //  offset = 0x041

    //
    //  First character of Unicode File Name
    //

    WCHAR FileName[1];                                              //  offset = 0x042

} FILE_NAME;
typedef FILE_NAME *PFILE_NAME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\logfile\dumplog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dumplog.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    8-24-1998   benl   Created
//
//----------------------------------------------------------------------------


#include "pch.hxx"
#include "utils.hxx"
#include "map.hxx"

typedef void * PSCB;
typedef bool (* PMATCH_FUNC)(PLFS_RECORD_HEADER pRecord, PVOID Context);

typedef struct {
    LONGLONG llFileRef;
    ULONG    AttrType;
} MYENTRY, *PMYENTRY;

typedef struct {
    VCN Vcn;
    int Offset;
} VCN_OFFSET, *PVCN_OFFSET;

typedef CMap<int, MYENTRY> OPEN_ATTR_MAP, *POPEN_ATTR_MAP;

//
//  Map of current lsn to start of transaction lsn
//  

typedef CMap<LONGLONG, ULONG> TRANSACTION_MAP, *PTRANSACTION_MAP;

typedef struct {
    LONGLONG        llFileRef;
    OPEN_ATTR_MAP * pAttrMap;
    INT             ClusterSize;
} FILEREF_MATCH_CTX, *PFILEREF_MATCH_CTX;

typedef struct {
    LONGLONG AddRecordLsn;
    LONGLONG AddRecordFileRef;
    LONGLONG AddRecordVcn;
    int      AddRecordClusterOffset;
} DEDUCE_CTX, *PDEDUCE_CTX;

#include <ntfslog.h>

typedef struct _LOGCB {
    LSN FirstLsn;
    LSN CurrentLsn;
} LOGCB, *PLOGCB;

#define WARNING_SIZE 50
#define LOG_PAGE 0x1000
#define TOTAL_PAGE_HEADER ALIGN(sizeof(LFS_RECORD_PAGE_HEADER) + ((LOG_PAGE / 0x200) * sizeof(USHORT)), sizeof(DWORD))

const char * gOpMap[] =
{
    "Noop",
    "CompensationLogRecord",
    "Init FRS",
    "Delete FRS",
    "Write EOF FRS",
    "CreateAttribute",
    "DeleteAttribute",
    "UpdateResidentValue",
    "UpdateNonresidentValue",
    "UpdateMappingPairs",
    "DeleteDirtyClusters",
    "SetNewAttributeSizes",
    "AddIndexEntryRoot",
    "DeleteIndexEntryRoot",
    "AddIndexEntryAllocation",
    "DeleteIndexEntryAllocation",
    "WriteEndOfIndexBuffer",
    "SetIndexEntryVcnRoot",
    "SetIndexEntryVcnAllocation",
    "UpdateFileNameRoot",
    "UpdateFileNameAllocation",
    "SetBitsInNonresidentBitMap",
    "ClearBitsInNonresidentBitMap",
    "HotFix",
    "EndTopLevelAction",
    "PrepareTransaction",
    "CommitTransaction",
    "ForgetTransaction",
    "OpenNonresidentAttribute",
    "OpenAttributeTableDump",
    "AttributeNamesDump",
    "DirtyPageTableDump",
    "TransactionTableDump",
    "UpdateRecordDataRoot",
    "UpdateRecordDataAllocation"
};

const char * gTransStateMap[] = {
    "TransactionUninitialized",
    "TransactionActive",
    "TransactionPrepared",
    "TransactionCommitted"
};

int gcOpMap = (sizeof(gOpMap) / sizeof(char *));
int gcTransStateMap = (sizeof(gTransStateMap) / sizeof(char *));
int gSeqNumberBits = 0;
int gLogFileSize = 0;

//flags
bool       gfDumpData = false;
int        giPagesBackToDump = 0;
bool       gfPrintHeaders = false;
LSN        gLsnToDump = {0,0};
VCN_OFFSET gVcnPairToMatch;
LCN        gLcnToMatch = 0;
LSN        gLsnToTrace = {0,0};
bool       gfDumpEverything = false;
LONG       glBitToMatch = -1; 
LONGLONG   gllFileToMatch = 0;
bool       gfScanForRestarts = false;
ULONG      gulClusterSize = 0;
LSN        gllRangeStart = {0,0};
LSN        gllRangeEnd = {0,0};
bool       gVerboseScan = false;
bool       gfScanTransactions = false;

//+---------------------------------------------------------------------------
//
//  Function:   LsnToOffset
//
//  Synopsis:   Transforms LSN to its offset in the logfile
//
//  Arguments:  [Lsn] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LONGLONG LsnToOffset(LONGLONG Lsn)
{
    return (ULONGLONG)(Lsn << gSeqNumberBits) >> (gSeqNumberBits - 3);
} // LsnToOffset


//+---------------------------------------------------------------------------
//
//  Function:   LsnToSequenceNumber
//
//  Synopsis:   Transforms LSN to its sequence number
//
//  Arguments:  [Lsn] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG LsnToSequenceNumber(LONGLONG Lsn)
{
    return (ULONG)(Lsn >> (sizeof(LONGLONG) * 8 - gSeqNumberBits));
} // LsnToOffset



//+---------------------------------------------------------------------------
//
//  Function:   MyReadFile
//
//  Synopsis:   Helper wrapper for ReadFile
//
//  Arguments:  [hFile]    --
//              [lpBuffer] --
//              [cbRange]  --
//              [pol]      --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MyReadFile(HANDLE hFile, BYTE * lpBuffer, DWORD cbRange, OVERLAPPED * pol)
{
    DWORD dwRead;

    if (!ReadFile(hFile, lpBuffer, cbRange, &dwRead, pol)) {
        printf("MyReadFile: ReadFile for 0x%x at 0x%x failed %d\n", cbRange, pol->Offset, GetLastError());
        return false;
    }

    if (dwRead != cbRange) {
        printf("MyReadFile: Only read: 0x%x\n", dwRead);
        return false;
    }

    return true;
} // MyReadFile

//+---------------------------------------------------------------------------
//
//  Function:   ApplySectorHdr
//
//  Synopsis:   Fixes up log record using multisector hdr
//
//  Arguments:  [pHdr] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool ApplySectorHdr(PMULTI_SECTOR_HEADER pHdr, ULONG LogOffset)
{
    int      iIndex;
    USHORT * pShort = NULL;
    USHORT   sKey;
    USHORT * pBuffer;

    if (*((DWORD *)pHdr->Signature) == 0xFFFFFFFF) {
        printf("Unused page!\n");
        return false;
    }

    if (*((DWORD *)pHdr->Signature) == 0x44414142) {
        printf("BAAD page!\n");
        return false;
    }


    if ((pHdr->UpdateSequenceArraySize != PAGE_SIZE / 0x200 + 1)) {
        printf("Bogus page!\n");
        return false;
    }

    pBuffer = (USHORT *)((BYTE *)pHdr + 0x1fe);
    pShort = (USHORT *) ((BYTE *)pHdr + pHdr->UpdateSequenceArrayOffset);
    sKey = *pShort;
    pShort++;

    //this should reflect the page size
    if (!(pHdr->UpdateSequenceArraySize == PAGE_SIZE / 0x200 + 1)) {
        
        printf( "BadSeqSize: 0x%x\n", pHdr->UpdateSequenceArraySize );
        return false;
    }

    for (iIndex=0; iIndex < pHdr->UpdateSequenceArraySize - 1; iIndex++) {

        if (sKey != *pBuffer) {
            printf( "USA Mismatch: 0x%x 0x%x at offset 0x%x\n", sKey, *pBuffer, LogOffset + (iIndex+1) * 0x200 );
        }

        *pBuffer = *pShort;
        pBuffer = (USHORT *)((BYTE *)pBuffer + 0x200);
        pShort++;
    }

    return true;
} // ApplySectorHdr


//+---------------------------------------------------------------------------
//
//  Function:   DumpSectorHdr
//
//  Synopsis:   Dump MultiSectorHdr
//
//  Arguments:  [pHdr] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpSectorHdr(PMULTI_SECTOR_HEADER pHdr)
{
    int      iIndex;
    USHORT * pShort = NULL;

    printf("Signature: %c%c%c%c\n", pHdr->Signature[0], pHdr->Signature[1],
           pHdr->Signature[2], pHdr->Signature[3]);
    printf("UpdateSequenceArrayOffset: 0x%x\n", pHdr->UpdateSequenceArrayOffset);
    printf("UpdateSequenceArraySize: 0x%x\n", pHdr->UpdateSequenceArraySize);

    pShort = (USHORT *) ((BYTE *)pHdr + pHdr->UpdateSequenceArrayOffset);

    for (iIndex=0; iIndex < pHdr->UpdateSequenceArraySize; iIndex++) {
        printf("0x%x ", *pShort);
        pShort++;
    }
    printf("\n");
} // DumpSectorHdr


//+---------------------------------------------------------------------------
//
//  Function:   DumpRestartPage
//
//  Synopsis: Dumps a lfs restart record page
//
//  Arguments:  [lpBuffer] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRestartPage(BYTE * lpBuffer)
{
    PLFS_RESTART_PAGE_HEADER pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpBuffer;
    PLFS_RESTART_AREA        pLfsRestart = 0;
    int                      iIndex;
    PLFS_CLIENT_RECORD       pClient = 0;

    printf("Restart Page\n");
    printf("ChkDskLsn: 0x%I64x\n", pRestartHdr->ChkDskLsn);
    printf("LogPageSize: 0x%x\n", pRestartHdr->LogPageSize);


    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);

    printf("\nLFS Restart Area\n");

    printf("CurrentLsn: 0x%I64x\n", pLfsRestart->CurrentLsn);
    printf("LogClients: %d\n", pLfsRestart->LogClients);
    printf("Flags: 0x%x\n", pLfsRestart->Flags);
    printf("LogPage RecordHeaderLength: 0x%x\n", pLfsRestart->RecordHeaderLength);
    printf("SeqNumberBits: 0x%x\n", pLfsRestart->SeqNumberBits);
    printf("LogFileSize: 0x%I64x\n", pLfsRestart->FileSize);

    printf("\nClients\n");

    pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);

    for (iIndex=0; iIndex < pLfsRestart->LogClients; iIndex++) {
        printf("Name: %*S\n", pClient->ClientNameLength, pClient->ClientName);
        printf("OldestLsn: 0x%I64x\n", pClient->OldestLsn);
        printf("ClientRestartLsn: 0x%I64x\n", pClient->ClientRestartLsn);

        pClient = pClient++;
    }

} // DumpRestartPage



//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttributeTable
//
//  Synopsis:   Dump the open attr table
//
//  Arguments:  [PRESTART_TABLE] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpOpenAttributeTable(PRESTART_TABLE pRestartTable)
{
    POPEN_ATTRIBUTE_ENTRY_V0 pEntry = 0;
    int                   iIndex;

    printf("\nOpenAttributeTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
            printf("FileRef: 0x%I64x\n", pEntry->FileReference);
            printf("LsnOfOpenRecord: 0x%I64x\n", pEntry->LsnOfOpenRecord);
            printf("AttributeTypeCode: 0x%x\n", pEntry->AttributeTypeCode);
//                    printf("AttributeName: 0x%x 0x%x\n\n",
//                           pEntry->AttributeName.Length,
//                           pEntry->AttributeName.Buffer);
        } else {
            printf("free\n");
        }
        pEntry++;
        printf("\n");

    }
} // DumpOpenAttributeTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpAttributeNames
//
//  Synopsis:   Dump the attribute names
//
//  Arguments:  [pNameEntry] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpAttributeNames(PATTRIBUTE_NAME_ENTRY pNameEntry, int TableSize)
{
    int cTraversed = 0;

    printf("\nAttributeNames\n");
    while (pNameEntry->Index != 0 || pNameEntry->NameLength != 0) {
        if (cTraversed >= TableSize) {
            printf("Table appears invalid\n");
            break;
        }

        printf("Index: 0x%x\n", pNameEntry->Index);
        printf("Name: %.*S\n", pNameEntry->NameLength / 2, pNameEntry->Name);
        cTraversed += sizeof(ATTRIBUTE_NAME_ENTRY) + pNameEntry->NameLength;
        pNameEntry = (PATTRIBUTE_NAME_ENTRY) ((BYTE *) pNameEntry +
                                              sizeof(ATTRIBUTE_NAME_ENTRY) + pNameEntry->NameLength);
        printf("\n");
    }
} // DumpAttributeNames



//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttribute
//
//  Synopsis:   
//
//  Arguments:  [pEntry]   -- 
//              [pName]    -- 
//              [cNameLen] -- 
//
//  Returns:    
//
//  History:    9-09-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void  DumpOpenAttribute(POPEN_ATTRIBUTE_ENTRY_V0 pEntry, WCHAR * pName, 
                        int cNameLen)
{  
    int iTemp = cNameLen / 2;

    printf("\n");
    if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
        printf("FileRef: 0x%I64x\n", pEntry->FileReference);
        printf("LsnOfOpenRecord: 0x%I64x\n", pEntry->LsnOfOpenRecord);
        printf("AttributeTypeCode: 0x%x\n", pEntry->AttributeTypeCode);
        if (cNameLen) {
            printf("Name: %.*S\n", iTemp, pName);
        }

    } else {
        printf("free\n");
    }
    printf("\n");
} // DumpOpenAttribute


//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttributeTable
//
//  Synopsis:   Dump the open attr table
//
//  Arguments:  [PRESTART_TABLE] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpDirtyPageTable(PRESTART_TABLE pRestartTable)
{
    PDIRTY_PAGE_ENTRY_V0 pEntry = 0;
    int                  iIndex;
    DWORD                iIndex2;

    printf("\nDirtyPageTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
            printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
            printf("TargetAttribute: 0x%x\n", pEntry->TargetAttribute);
            printf("LengthOfTransfer: 0x%x\n", pEntry->LengthOfTransfer);
            printf("VCN: 0x%I64x\n", pEntry->Vcn);
            printf("OldestLsn: 0x%I64x\n", pEntry->OldestLsn);
            printf("Lcns: ");
            for (iIndex2=0; iIndex2 < pEntry->LcnsToFollow; iIndex2++) {
                printf("0x%I64x ", pEntry->LcnsForPage[iIndex2]);
            }
            printf("\n\n");
            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0) - sizeof(LCN) + 
                                            pEntry->LcnsToFollow * sizeof(LCN));
        } else {
            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0));
//         printf("0x%x free: 0x%x\n\n", iIndex, pEntry->AllocatedOrNextFree);
        }
//      printf("\n");

    }
} // DumpOpenAttributeTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpTransactionTable
//
//  Synopsis:   
//
//  Arguments:  [pRestartTable] -- 
//
//  Returns:    
//
//  History:    9-11-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void DumpTransactionTable(PRESTART_TABLE pRestartTable)
{
    PTRANSACTION_ENTRY   pEntry = 0;
    int                  iIndex;
    int                  iIndex2;

    printf("\nTransactionTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (PTRANSACTION_ENTRY)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {

            printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
            printf("TransactionState: 0x%x (%s)\n", pEntry->TransactionState,
                   pEntry->TransactionState < gcTransStateMap ? gTransStateMap[pEntry->TransactionState] : "");
            printf("FirstLsn: 0x%I64x\n", pEntry->FirstLsn.QuadPart);
            printf("PreviousLsn: 0x%I64x\n", pEntry->PreviousLsn.QuadPart);
            printf("UndoNextLsn: 0x%I64x\n", pEntry->UndoNextLsn.QuadPart);
            printf("UndoRecords: 0x%x\n", pEntry->UndoRecords);
            printf("\n");
            
        }
        pEntry = (PTRANSACTION_ENTRY)((BYTE *)pEntry + sizeof(TRANSACTION_ENTRY));
        //      printf("\n");

    }
} // DumpTransactionTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpMappingPair
//
//  Synopsis:   
//
//  Arguments:  [Buffer] -- 
//              [Length] -- 
//
//  Returns:    
//
//  History:    5-02-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void DumpMappingPairs(PVOID Buffer, ULONG Length)
{
    BYTE * TempByte;
    BYTE * OldStart = NULL;
    ULONG ChangedLCNBytes;
    ULONG ChangedVCNBytes;
    ULONG Increment;
    ULONG Index;
    ULONG Increment2;
    ULONG LCN = 0;
    ULONG VCN = 0;

    //
    //  Try To Find Start
    //  

    for (Index=0; Index < Length; Index++) {

        TempByte = ((BYTE *)Buffer) + Index;

        while ((TempByte <= (BYTE*)Buffer + Length)  && (*TempByte != 0)) {

            ChangedLCNBytes = *TempByte >> 4;
            ChangedVCNBytes = *TempByte & (0x0f);

            if ((ChangedVCNBytes > 3) ||
                (ChangedLCNBytes > sizeof( LONGLONG )) || (ChangedVCNBytes > sizeof( LONGLONG ))) {

                //
                //  set tempbyte so we'll loop again if possible
                //  

                TempByte = (BYTE*)Buffer + Length  + 1;
                break;
            }

            TempByte += (ChangedLCNBytes + ChangedVCNBytes + 1);
        }

        if ((TempByte <= (BYTE*)Buffer + Length) && ((TempByte - (BYTE *)Buffer) > (LONG)Length - 8 )) {
            break;
        }
    }

    if (Index >= Length) {
        return;
    }
    
    printf( "Starting at offset: 0x%x\n", Index );

    TempByte = (BYTE *)Buffer + Index;

    //
    // walk byte stream
    //

    while(*TempByte != 0)
    {
        ChangedLCNBytes = *TempByte >> 4;
        ChangedVCNBytes = *TempByte & (0x0f);

        TempByte++;

        for(Increment=0, Index=0; Index < ChangedVCNBytes; Index++)
        {
            Increment+= *TempByte++ << (8 * Index);
        }

        for(Increment2 =0, Index=0; Index < ChangedLCNBytes; Index++)
        {
            Increment2+= *TempByte++ << (8 * Index);
        }

        //
        // if last bit is set (this is a neg) extend with 0xff
        //

        if (0x80 & (*(TempByte-1)))
        {
            for(; Index < sizeof(Increment2) ; Index++)
            {
                Increment2 += 0xff << (8 * Index);
            }
        }

        LCN += Increment2;
        printf( "LCN delta: 0x%x  VCN delta: 0x%x ", Increment2, Increment );

        for (Index = ChangedLCNBytes + ChangedVCNBytes + 1; Index > 0; Index--) {
            printf( "%02x", *(TempByte - Index));
        }
        printf( "\n" );

        VCN += Increment;

    } //endwhile

    printf("Total LcnDelta: 0x%x Total VCNDelta: 0x%x\n", LCN, VCN );

} // DumpMappingPair


//+---------------------------------------------------------------------------
//
//  Function:   DumpLogRecord
//
//  Synopsis: Dumps log records
//
//  Arguments:  [pRecord]  -- record to dump
//              [pAttrMap] -- ptr to open attribute table to use to translate
//                            TargetAttribute - if null no translation is done
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//              9-09-1998   benl   modified
//
//  Notes: either is a regular client record or a client restart area
//
//----------------------------------------------------------------------------

void DumpLogRecord(PLFS_RECORD_HEADER pRecord, OPEN_ATTR_MAP * pAttrMap)
{
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    BYTE *                   pData = 0;
    PRESTART_TABLE           pRestartTable = 0;
    PATTRIBUTE_NAME_ENTRY    pNameEntry = 0;
    POPEN_ATTRIBUTE_ENTRY_V0 pAttrEntry;
    LPWSTR                   lpName;
    MYENTRY *                pEntry;
    PRESTART_AREA            pRestartArea;

    printf("ThisLsn, PrevLsn, UndoLsn: 0x%I64x 0x%I64x 0x%I64x\n",
           pRecord->ThisLsn, pRecord->ClientPreviousLsn,
           pRecord->ClientUndoNextLsn);
    printf("Flags: 0x%x %s\n", pRecord->Flags, pRecord->Flags & LOG_RECORD_MULTI_PAGE ? "(multi-page)" : "");
    printf("ClientDataLength: 0x%x\n", pRecord->ClientDataLength);
    printf("TransactionId: 0x%x\n", pRecord->TransactionId);


    if (pRecord->RecordType == LfsClientRecord) {
        
        if (pRecord->ClientDataLength) {
            pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                                 sizeof(LFS_RECORD_HEADER));
    
            printf("Redo, Undo: (0x%x, 0x%x) (", pNtfsLog->RedoOperation,
                   pNtfsLog->UndoOperation);
            if (pNtfsLog->RedoOperation < gcOpMap ) {
                printf("%s, ", gOpMap[pNtfsLog->RedoOperation]);
            } else {
                printf("unknown, ");
            }
            if (pNtfsLog->UndoOperation < gcOpMap ) {
                printf("%s)\n", gOpMap[pNtfsLog->UndoOperation]);
            } else {
                printf("unknown)\n");
            }
    
            printf("RedoOffset RedoLength: (0x%x 0x%x)\n",
                   pNtfsLog->RedoOffset, pNtfsLog->RedoLength);
            printf("UndoOffset UndoLength: (0x%x 0x%x)\n",
                   pNtfsLog->UndoOffset, pNtfsLog->UndoLength);
    
    //        printf("0x%x 0x%x 0x%x 0x%x\n",pNtfsLog->RedoOffset,
    //               pNtfsLog->RedoLength, pNtfsLog->UndoLength, pNtfsLog->UndoOffset);
    
    
            printf("TargetAttribute: 0x%x\n", pNtfsLog->TargetAttribute);
            printf("RecordOffset: 0x%x\n", pNtfsLog->RecordOffset);
            printf("AttributeOffset: 0x%x\n", pNtfsLog->AttributeOffset);
            printf("ClusterBlockOffset: 0x%x\n", pNtfsLog->ClusterBlockOffset);
            printf("TargetVcn: 0x%I64x\n", pNtfsLog->TargetVcn);
    
            //
            //  If we were given an open attr map attempt to get the fileref from the
            //  target attribute
            //
    
            if (pAttrMap) {
                pEntry = pAttrMap->Lookup(pNtfsLog->TargetAttribute);
                if (pEntry) {
                    printf("FileRef: 0x%I64x\n", pEntry->llFileRef);
                    printf("Attribute: 0x%x\n", pEntry->AttrType);
                }
            }
    
    
            //
            //  Dump open-attr table
            //
    
    
            if (pNtfsLog->RedoOperation == OpenAttributeTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpOpenAttributeTable(pRestartTable);
            }
    
            if (pNtfsLog->RedoOperation == AttributeNamesDump) {
                pNameEntry = (PATTRIBUTE_NAME_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpAttributeNames(pNameEntry, pNtfsLog->RedoLength);
            }
    
            if (pNtfsLog->RedoOperation == OpenNonresidentAttribute) {
                pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                lpName = (LPWSTR)((BYTE *)pNtfsLog + pNtfsLog->UndoOffset);
                DumpOpenAttribute(pAttrEntry, lpName, pNtfsLog->UndoLength);
            }
    
            if (pNtfsLog->RedoOperation == DirtyPageTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpDirtyPageTable(pRestartTable);
            }
    
            if (pNtfsLog->RedoOperation == TransactionTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpTransactionTable(pRestartTable);
            }
    
    
    
            if (pNtfsLog->LcnsToFollow > WARNING_SIZE) {
                printf("LcnsToFollow: 0x%x is abnormally high probably not a valid record\n",
                       pNtfsLog->LcnsToFollow);
            } else {
                printf("LcnsForPage: ");
                for (iIndex=0; iIndex < pNtfsLog->LcnsToFollow; iIndex++) {
                    printf("0x%I64x ", pNtfsLog->LcnsForPage[iIndex]);
                }
            }
            printf("\n");
    
            if (gfDumpData) {

                //
                //  Its usually more useful to dump dwords except for the update
                //  filemappings case where its better to dump as bytes. If more
                //  exceptions popup make this logic a little nicer
                //
                
                if (pNtfsLog->RedoOperation && pNtfsLog->RedoLength) {
                    printf("Redo bytes\n");
                    pData = (BYTE *)pNtfsLog + pNtfsLog->RedoOffset;
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs ) {
                        DumpRawBytes(pData, pNtfsLog->RedoLength);
                    } else {
                        DumpRawDwords((DWORD *)pData, pNtfsLog->RedoLength);
                    }
/*                    
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs) {
                        printf("\n");
                        DumpMappingPairs( pData, pNtfsLog->RedoLength );
                        printf("\n");
                    }
*/                    
                }
                if (pNtfsLog->UndoOperation && pNtfsLog->UndoLength) {
                    printf("Undo bytes\n");
                    pData = (BYTE *)pNtfsLog + pNtfsLog->UndoOffset;
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs ) { 
                        DumpRawBytes(pData, pNtfsLog->UndoLength);
                    } else {
                        DumpRawDwords((DWORD *)pData, pNtfsLog->UndoLength);
                    }
  /*
                    if (pNtfsLog->UndoOperation == UpdateMappingPairs) {
                        printf("\n");
                        DumpMappingPairs( pData, pNtfsLog->UndoLength );
                        printf("\n");
                    }
*/                    
                }
            }

        }
    } else if (pRecord->RecordType == LfsClientRestart) {
        printf("\nClient Restart Record\n");
        pRestartArea = (PRESTART_AREA) ( (BYTE *)pRecord + sizeof(LFS_RECORD_HEADER) );

        printf( "Major, Minor Version: 0x%x,0x%x\n", 
                pRestartArea->MajorVersion, 
                pRestartArea->MinorVersion
              );
        printf( "StartOfCheckpoint: 0x%8I64x\n\n", pRestartArea->StartOfCheckpoint );
        printf( "OpenAttributeTableLsn: 0x%08I64x 0x%x bytes\n", 
                pRestartArea->OpenAttributeTableLsn,
                pRestartArea->OpenAttributeTableLength
              );
        printf( "AttributeNamesLsn:     0x%08I64x 0x%x bytes\n", 
                pRestartArea->AttributeNamesLsn,
                pRestartArea->AttributeNamesLength
              );
        printf( "DirtyPageTableLsn:     0x%08I64x 0x%x bytes\n", 
                pRestartArea->DirtyPageTableLsn,
                pRestartArea->DirtyPageTableLength
              );
        printf( "TransactionTableLsn:   0x%08I64x 0x%x bytes\n", 
                pRestartArea->TransactionTableLsn,
                pRestartArea->TransactionTableLength 
              );
        printf( "\nLowestOpenUsn: 0x%I64x\n", pRestartArea->LowestOpenUsn );

        //
        //  Older logs don't have these 2 fields
        //


        if (pRecord->ClientDataLength >= FIELD_OFFSET(RESTART_AREA, CurrentLsnAtMount)) {
            printf( "CurrentLsnAtMount: 0x%I64x\n", pRestartArea->CurrentLsnAtMount );
            printf( "BytesPerCluster: 0x%x\n", pRestartArea->BytesPerCluster );
        }

    }
} // DumpLogRecord


//+---------------------------------------------------------------------------
//
//  Function:   DumpRecordPage
//
//  Synopsis:   Dump page header for a record page
//
//  Arguments:  [lpBuffer] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRecordPage(BYTE * lpBuffer)
{
    PLFS_RECORD_PAGE_HEADER pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
    PLFS_RECORD_HEADER      pRecord = 0;
    INT                     iNextRecord;

    printf("Record Page\n");
//    printf("LastLsn: 0x%I64x\n", pHdr->Copy.LastLsn);
    printf("Flags: 0x%x %s\n", pHdr->Flags, pHdr->Flags & LOG_PAGE_LOG_RECORD_END ?
           "(record end in page)" : "");
    printf("LastEndLsn: 0x%I64x (0x%x)\n", pHdr->Header.Packed.LastEndLsn,
           ((pHdr->Header.Packed.LastEndLsn.LowPart << 3) & 0xfff));

//    printf("0x%x\n", (pHdr->Header.Packed.LastEndLsn.QuadPart << gSeqNumberBits) >> (gSeqNumberBits - 3));

    printf("NextRecordOffset: 0x%x\n", pHdr->Header.Packed.NextRecordOffset);

    iNextRecord = (pHdr->Header.Packed.LastEndLsn.LowPart << 3) & (LOG_PAGE - 1);

    pRecord = (PLFS_RECORD_HEADER)(lpBuffer + iNextRecord);

    DumpLogRecord(pRecord, NULL);

} // DumpRecordPage



//+---------------------------------------------------------------------------
//
//  Function:   DumpPage
//
//  Synopsis:   Dump out the given page of the logfile
//
//  Arguments:  [lpBuffer] -- page sized buffer in log
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//              8-24-1998   benl   modified
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpPage(BYTE * lpBuffer)
{
    PMULTI_SECTOR_HEADER  pMultiHdr = (PMULTI_SECTOR_HEADER) lpBuffer;

//    DumpSectorHdr(pMultiHdr);

    //
    //  Determine the record type
    //

    if (strncmp((char *)(pMultiHdr->Signature), "RSTR", 4) == 0) {
        DumpRestartPage(lpBuffer);
    } else if (strncmp((char *)(pMultiHdr->Signature), "RCRD", 4) == 0) {
        DumpRecordPage(lpBuffer);
    }
} // DumpPage


//+---------------------------------------------------------------------------
//
//  Function:   DumpPageLastLsns
//
//  Synopsis: Dump the last LSN in all the pages in the logfile
//
//  Arguments:  [hFile] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:  Used for debug purposes only right now
//
//----------------------------------------------------------------------------

void DumpPageLastLsns(HANDLE hFile)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     lsn;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));

    ol.Offset = LOG_PAGE * 4;

    while (ol.Offset) {
        if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
            printf("ReadFile failed %d\n", GetLastError());
            return;
        }

        if (dwRead != LOG_PAGE) {
            printf("Only read: 0x%x\n", dwRead);
            return;
        }

        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

//        DumpPage(lpBuffer);


        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            printf("Not record at 0x%x!\n", ol.Offset);
        } else {
            printf("0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
                   pHdr->Flags);
        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }

} // DumpLastLsns



//+---------------------------------------------------------------------------
//
//  Function:   ScanForLastLsn
//
//  Synopsis:   Starting from the current lsn hint walk fwd until we find the
//              the last lsn
//
//  Arguments:  [CurrentLsnHint] -- hint on where to start looking from
//
//  Returns: last lsn in logfile
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LSN ScanForLastLsn(HANDLE hFile, LSN CurrentLsnHint)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    LSN                     LsnMax;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_HEADER      pNextRecord = 0;

    LsnMax.QuadPart = 0;
    memset(&ol, 0, sizeof(ol));

    //
    //  Start 1 page before the hint
    //

    if (CurrentLsnHint.QuadPart) {
        ol.Offset = (ULONG)((LsnToOffset(CurrentLsnHint.QuadPart) & (~(LOG_PAGE - 1))) - LOG_PAGE);
    } else {
        ol.Offset = LOG_PAGE * 4;
    }

//    printf("Starting at: Lsn: 0x%I64x Offset: 0x%x\n", CurrentLsnHint, ol.Offset);

    while (true) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMax.QuadPart = 0;
            return LsnMax;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

//        DumpPage(lpBuffer);

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            //          printf("Not record at 0x%x!\n", ol.Offset);
            ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
        } else {

            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
//                printf("0x%x: LastEndLsn: 0x%I64x\n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart);

                if (pHdr->Header.Packed.LastEndLsn.QuadPart >= LsnMax.QuadPart) {
                    ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
                    LsnMax.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;

                    //check the next one if there is one in this page
                    if (pHdr->Header.Packed.NextRecordOffset < LOG_PAGE - sizeof(LFS_RECORD_HEADER)) {
                        pNextRecord = (PLFS_RECORD_HEADER)(lpBuffer + pHdr->Header.Packed.NextRecordOffset);
                        if (pNextRecord->ThisLsn.QuadPart > LsnMax.QuadPart) {
                            LsnMax.QuadPart = pNextRecord->ThisLsn.QuadPart;
                        }
                    }
                } else {
                    break;
                }
            } else {
//                printf("0x%x: NoEndingLsn\n", ol.Offset);
                ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
            }
        }
    }
    return LsnMax;
} // ScanForLast



//+---------------------------------------------------------------------------
//
//  Function:   ScanForFirstLsn
//
//  Synopsis: Returns earliest LSN in file
//
//  Arguments:  [hFile]   -- logfile handle
//              [Verbose] -- 
//
//  Returns: lsn or 0 if failure occurs
//
//  History:    8-25-1998   benl   Created
//              7-29-1999   benl   modified
//
//  Notes: Be ca
//
//----------------------------------------------------------------------------

LSN ScanForFirstLsn(HANDLE hFile, bool Verbose)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     LsnMin;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));
    ol.Offset = LOG_PAGE * 4;
    LsnMin.QuadPart = 0;

    while (ol.Offset) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMin.QuadPart = 0;
            return LsnMin;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
/*
        if (pHdr->Header.Packed.NextRecordOffset > LOG_PAGE) {
            printf("0x%x 0x%x\n", pHdr->Header.Packed.NextRecordOffset,
                   ol.Offset );
        }

        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);
*/
        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) == 0) {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END && Verbose) {
                printf( "0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x SeqNum: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
                       pHdr->Flags, LsnToSequenceNumber( pHdr->Header.Packed.LastEndLsn.QuadPart ) );
            }
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                if (LsnMin.QuadPart) {
                    if (LsnMin.QuadPart > pHdr->Header.Packed.LastEndLsn.QuadPart) {

                        //
                        //  If the last end lsn started before this page then its gone
                        //  since the page before this must have had a larger min lsn
                        //  so use the next lsn we find instead
                        //

                        if (LsnToOffset( pHdr->Header.Packed.LastEndLsn.QuadPart ) > ol.Offset ) {
                            LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                        }
                    }
//                    LsnMin.QuadPart = min(LsnMin.QuadPart, pHdr->Header.Packed.LastEndLsn.QuadPart);
                } else {
                    LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                }
            }

        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }                                                          

    return LsnMin;
} // ScanForFirstLsn


//+---------------------------------------------------------------------------
//
//  Function:   ScanForFirstLsn
//
//  Synopsis: Returns earliest LSN in file
//
//  Arguments:  [hFile]          -- logfile handle
//
//  Returns: lsn or 0 if failure occurs
//
//  History:    8-25-1998   benl   Created
//
//  Notes: Be ca
//
//----------------------------------------------------------------------------

LSN ScanForNextLsn(HANDLE hFile, LSN LsnStart )
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     LsnMin;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));
    ol.Offset = LOG_PAGE * 4;
    LsnMin.QuadPart = 0x7fffffffffffffffL;
    

    while (ol.Offset) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMin.QuadPart = LsnStart.QuadPart;        
            return LsnMin;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
/*
        if (pHdr->Header.Packed.NextRecordOffset > LOG_PAGE) {
            printf("0x%x 0x%x\n", pHdr->Header.Packed.NextRecordOffset,
                   ol.Offset );
        }

        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);
*/
        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) == 0) {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
//                printf( "0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x SeqNum: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
//                       pHdr->Flags, LsnToSequenceNumber( pHdr->Header.Packed.LastEndLsn.QuadPart ) );
            }
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                
                if (LsnMin.QuadPart > pHdr->Header.Packed.LastEndLsn.QuadPart &&
                    LsnStart.QuadPart < pHdr->Header.Packed.LastEndLsn.QuadPart) {

                    //
                    //  If the last end lsn started before this page then its gone
                    //  since the page before this must have had a larger min lsn
                    //  so use the next lsn we find instead
                    //

                    if (LsnToOffset( pHdr->Header.Packed.LastEndLsn.QuadPart ) > ol.Offset ) {
                        LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                    }
                }
            }

        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }                                                          

    return LsnMin;
} // ScanForFirstLsn


//+---------------------------------------------------------------------------
//
//  Function:   ScanBackPagesForLastLsn
//
//  Synopsis:   Given an end LSN find an LSN on n pages before it
//
//  Arguments:  [hFile]      -- logfile handle
//              [CurrentLsn] -- ending lsn
//              [iPageRange] -- how many pages earlier we want an lsn from
//
//  Returns: LSN iPageRange pages earlier in the log from CurrentLsn
//
//  History:    8-25-1998   benl   Created
//
//  Notes: iPageRange is treated like a hint the precise distance will vary
//
//----------------------------------------------------------------------------

LSN ScanBackPagesForLastLsn(HANDLE hFile, LSN CurrentLsn, int iPageRange)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    LSN                     Lsn;

    Lsn.QuadPart = 0;
    memset(&ol, 0, sizeof(ol));

    //
    //  Start iPageRange before the hint
    //
    ol.Offset = (ULONG)((LsnToOffset(CurrentLsn.QuadPart) & (~(LOG_PAGE - 1))) - (LOG_PAGE * iPageRange));

    printf("Starting at: Offset: 0x%x\n", ol.Offset);

    while (iPageRange) {
        if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
            printf("ReadFile failed %d\n", GetLastError());
            Lsn.QuadPart = 0;
            return Lsn;
        }

        if (dwRead != LOG_PAGE) {
            printf("Only read: 0x%x\n", dwRead);
            Lsn.QuadPart = 0;
            return Lsn;
        }

        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }
        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            printf("Not record at 0x%x!\n", ol.Offset);
        } else {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                printf("0x%x: LastEndLsn: 0x%I64x\n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart);
                Lsn.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                iPageRange--;
            } else {
                printf("0x%x: NoEndingLsn\n", ol.Offset);
            }
        }
        ol.Offset = (ol.Offset - LOG_PAGE) % gLogFileSize;
    }
    return Lsn;
} // ScanBackPagesForLastLsn


//+---------------------------------------------------------------------------
//
//  Function:   AddNewAttributes
//
//  Synopsis:   Add any new attributes from a dump or open to the table
//
//  Arguments:  [pRecord] -- 
//              [int]     -- 
//              [AttrMap] -- 
//
//  Returns:    
//
//  History:    9-09-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void AddNewAttributes(PLFS_RECORD_HEADER pRecord, CMap<int, MYENTRY>  & AttrMap)
{  
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    PRESTART_TABLE           pRestartTable = 0;
    PATTRIBUTE_NAME_ENTRY    pNameEntry = 0;
    POPEN_ATTRIBUTE_ENTRY_V0 pAttrEntry;
    POPEN_ATTRIBUTE_ENTRY    pNewAttrEntry;
    LPWSTR                   lpName;
    int                      iEntry;
    MYENTRY                  MyEntry;

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        if (pNtfsLog->RedoOperation == OpenAttributeTableDump) {

            //
            //  Walk table adding allocated entries
            //

            pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);

            pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
            pNewAttrEntry = (POPEN_ATTRIBUTE_ENTRY)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));

            for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {

                if (pRestartTable->EntrySize == sizeof( OPEN_ATTRIBUTE_ENTRY_V0 )) {
                    
                    if (pAttrEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                        iEntry = (ULONG)((BYTE *)pAttrEntry - (BYTE *)pRestartTable);
                        memcpy(&(MyEntry.llFileRef), &(pAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
                        MyEntry.AttrType = pAttrEntry->AttributeTypeCode;

                        if (AttrMap.Lookup(iEntry)) {
                            AttrMap.Replace(iEntry, MyEntry);
                        } else {
                            AttrMap.Insert(iEntry, MyEntry);
                        }
                    }
                    pAttrEntry++;

                } else {

                    if (pNewAttrEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                        iEntry = (ULONG)((BYTE *)pNewAttrEntry - (BYTE *)pRestartTable);
                        memcpy(&(MyEntry.llFileRef), &(pNewAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
                        MyEntry.AttrType = pNewAttrEntry->AttributeTypeCode;

                        if (AttrMap.Lookup(iEntry)) {
                            AttrMap.Replace(iEntry, MyEntry);
                        } else {
                            AttrMap.Insert(iEntry, MyEntry);
                        }
                    }
                    pNewAttrEntry++;
                }

            }
        }

        if (pNtfsLog->RedoOperation == AttributeNamesDump) {
            pNameEntry = (PATTRIBUTE_NAME_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
//         DumpAttributeNames(pNameEntry, pNtfsLog->RedoLength);
        }

        if (pNtfsLog->RedoOperation == OpenNonresidentAttribute) {
            pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            lpName = (LPWSTR)((BYTE *)pNtfsLog + pNtfsLog->UndoOffset);
            memcpy(&(MyEntry.llFileRef), &(pAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
            MyEntry.AttrType = pAttrEntry->AttributeTypeCode;

            if (AttrMap.Lookup(pNtfsLog->TargetAttribute)) {
                AttrMap.Replace(pNtfsLog->TargetAttribute, MyEntry);
            } else {
                AttrMap.Insert(pNtfsLog->TargetAttribute, MyEntry);
            }
        }
    }
} // AddNewAttributes


//+---------------------------------------------------------------------------
//
//  Function:   MatchVcn
//
//  Synopsis:   Simple function to match a record against a VCN
//
//  Arguments:  [pRecord] -- ptr to head of record
//              [Context] -- actually vcn ptr to match
//
//  Returns: true if match
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchVcn(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    VCN_OFFSET *               pVcnPair = (VCN_OFFSET *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    bool                     fRet = false;

    MYASSERT(pVcnPair);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->TargetVcn == pVcnPair->Vcn) {
            if ((pVcnPair->Offset == -1) || 
                (pVcnPair->Offset == pNtfsLog->ClusterBlockOffset)) {
                fRet = true;
            }
        }
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   MatchFileRef
//
//  Synopsis:   Match a given file ref
//
//  Arguments:  [pRecord] -- record to test
//              [Context] -- fileref to match
//
//  Returns:    
//
//  History:    9-11-1998   benl   Created
//
//  Notes:      Ignore SequenceNumber
//
//----------------------------------------------------------------------------

bool MatchFileRef(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PFILEREF_MATCH_CTX       pFileRefCtx = (PFILEREF_MATCH_CTX) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    bool                     fRet = false;
    MYENTRY *                pEntry;
    PFILE_REFERENCE          pFileRef1;
    PFILE_REFERENCE          pFileRef2;
    LONGLONG                 llFileRef;

    MYASSERT(pFileRefCtx);

    pFileRef1 = (PFILE_REFERENCE) (&(pFileRefCtx->llFileRef));

    AddNewAttributes(pRecord, *(pFileRefCtx->pAttrMap));

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        //
        //  Check directly using attribute table
        //


        pEntry = pFileRefCtx->pAttrMap->Lookup(pNtfsLog->TargetAttribute);
        if (pEntry)
        {
            pFileRef2 = (PFILE_REFERENCE) (&(pEntry->llFileRef));
            if ((pFileRef2->SegmentNumberLowPart == pFileRef1->SegmentNumberLowPart) &&
                (pFileRef2->SegmentNumberHighPart == pFileRef1->SegmentNumberHighPart)) {
                fRet = true;
            }
        }

        //
        //  Also check for someone with an equivalent vcn
        //

        if (pFileRefCtx->ClusterSize) {
            llFileRef = (LONGLONG)(pFileRef1->SegmentNumberLowPart) + 
                ((LONGLONG)(pFileRef1->SegmentNumberHighPart) << 32);

            //
            //  ClusterRatio is number of sector per cluster. FileRecord is 2 sectors big 0x400
            //

            if (pNtfsLog->TargetVcn ==  (llFileRef * 0x400 / pFileRefCtx->ClusterSize)) {
                if (pNtfsLog->ClusterBlockOffset * 0x200  == ((llFileRef * 0x400) % pFileRefCtx->ClusterSize)) {
                    fRet = true;
                }

            }

        }



    }

    return fRet;
} // MatchFileRef



//+---------------------------------------------------------------------------
//
//  Function:   MatchLcn
//
//  Synopsis:
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchLcn(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    LCN *                    pLCN = (LCN *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    bool                     fRet = false;

    MYASSERT(pLCN);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->LcnsToFollow) {
            for (iIndex=0; iIndex < pNtfsLog->LcnsToFollow; iIndex++) {
                if (pNtfsLog->LcnsForPage[iIndex] == *pLCN) {
                    fRet = true;
                    break;
                }
            }
        }

        if (pNtfsLog->RedoOperation == SetBitsInNonresidentBitMap) {

            PBITMAP_RANGE Range;

            Range = (PBITMAP_RANGE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset );
            if (Range->BitMapOffset == *pLCN % 0x8000) {
                fRet = true;
            }
        }

        if (pNtfsLog->RedoOperation == DirtyPageTableDump) {
            
            PRESTART_TABLE       pRestartTable;                
            PDIRTY_PAGE_ENTRY_V0 pEntry;
            ULONG                iIndex2;

            pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);

            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
            for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
                if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                    
                    for (iIndex2=0; iIndex2 < pEntry->LcnsToFollow; iIndex2++) {
                        if (pEntry->LcnsForPage[iIndex2] == *pLCN) {
                            fRet = true;
                            break;
                        }
                    }
                    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0) - sizeof(LCN) + 
                                                    pEntry->LcnsToFollow * sizeof(LCN));
                } else {
                    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0));
                }
            }
        }
    }

    return fRet;
} // MatchLcn


//+---------------------------------------------------------------------------
//
//  Function:   MatchAll
//
//  Synopsis:   Used to dump all lsns in range
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchAll(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    return true;
} // MatchAll


//+---------------------------------------------------------------------------
//
//  Function:   MatchRestartDumps
//
//  Synopsis:   Match if part of a restart table dump
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    9-16-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchRestartDumps(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    bool                     fRet = false;


    if (pRecord->RecordType == LfsClientRecord) {
        if (pRecord->ClientDataLength) {
            pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                                 sizeof(LFS_RECORD_HEADER));
            if (pNtfsLog->RedoOperation == OpenAttributeTableDump ||
                pNtfsLog->RedoOperation == AttributeNamesDump ||
                pNtfsLog->RedoOperation == DirtyPageTableDump ||
                pNtfsLog->RedoOperation == TransactionTableDump ) {
                    fRet = true;
            }
        }
    } else {

        //
        //  Always dump a restart area record
        //

        fRet = true;
    }
    return fRet;
} // MatchRestartDumps


//+---------------------------------------------------------------------------
//
//  Function:   MatchRecordNewAttributes
//
//  Synopsis:   Used to record open attributes during traversal
//
//  Arguments:  [pRecord] --  current record
//              [Context] --  an open attribute map
//
//  Returns:
//
//  History:       benl   Created
//              9-09-1998   benl   modified
//              9-09-1998   benl   modified
//
//  Notes: always returns false so nothing is printed
//
//----------------------------------------------------------------------------

bool MatchRecordNewAttributes(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    OPEN_ATTR_MAP * pMap = (OPEN_ATTR_MAP *) Context;

    AddNewAttributes(pRecord, *pMap);
    return false;
} // MatchRecordNewAttributes



//+---------------------------------------------------------------------------
//
//  Function:   MatchRecordNewAttributes
//
//  Synopsis:   Used to record open attributes during traversal
//
//  Arguments:  [pRecord] --  current record
//              [Context] --  an open attribute map
//
//  Returns:
//
//  History:       benl   Created
//              9-09-1998   benl   modified
//              9-09-1998   benl   modified
//
//  Notes: always returns false so nothing is printed
//
//----------------------------------------------------------------------------

bool MatchDeduceClusterSize(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PDEDUCE_CTX              DeduceCtx = (PDEDUCE_CTX) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    PINDEX_ENTRY             pEntry = NULL;
    
    MYASSERT(Context);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        if ((pNtfsLog->RedoOperation == AddIndexEntryAllocation) &&
            (pNtfsLog->RedoLength > 0)) {
            
            pEntry = (PINDEX_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            DeduceCtx->AddRecordFileRef = (LONGLONG)(pEntry->FileReference.SegmentNumberLowPart) +
                ((LONGLONG)(pEntry->FileReference.SegmentNumberHighPart) << 32);
            DeduceCtx->AddRecordLsn = pRecord->ThisLsn.QuadPart;

//            printf( "Found fileref add 0x%I64x at Lsn: 0x%I64x\n", DeduceCtx->AddRecordFileRef,
//                    DeduceCtx->AddRecordLsn );

        } else if ((pNtfsLog->RedoOperation == InitializeFileRecordSegment) &&
                   (pNtfsLog->RedoLength > 0) &&
                   (DeduceCtx->AddRecordLsn == pRecord->ClientPreviousLsn.QuadPart)) {

            DeduceCtx->AddRecordVcn = pNtfsLog->TargetVcn;
            DeduceCtx->AddRecordClusterOffset = pNtfsLog->ClusterBlockOffset;

            
//            printf( "Found file: 0x%I64x at VCN: 0x%I64x offset: 0x%x\n",
//                    DeduceCtx->AddRecordFileRef,
//                    DeduceCtx->AddRecordVcn, 
//                    DeduceCtx->AddRecordClusterOffset );

        }

    }

    return false;
} // MatchRecordNewAttributes


//+---------------------------------------------------------------------------
//
//  Function:   MatchGetClusterSize
//
//  Synopsis:   
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    12-30-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchGetClusterSize(PLFS_RECORD_HEADER pRecord, 
                         PVOID Context)
{
    PULONG          pClusterSize = (PULONG) Context;
    PRESTART_AREA   pRestartArea;
    
    MYASSERT(Context);

    if (pRecord->RecordType == LfsClientRestart) {
        pRestartArea = (PRESTART_AREA) ( (BYTE *)pRecord + sizeof(LFS_RECORD_HEADER) );

        *pClusterSize = pRestartArea->BytesPerCluster;

    } else {
        printf( "MatchGetClusterSize: not a client restart area\n" );
    }

    //
    //  Never print the match
    //
    return false;
} // MatchGetClusterSize


//+---------------------------------------------------------------------------
//
//  Function:   MatchBit
//
//  Synopsis:   Match nonres bitmap involving the given bit
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchBit(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    ULONG *                  plBit = (ULONG *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    PBITMAP_RANGE            pRange;
    bool                     fRet = false;

    MYASSERT(plBit);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->RedoOperation == SetBitsInNonresidentBitMap ||
            pNtfsLog->RedoOperation == ClearBitsInNonresidentBitMap) {
            MYASSERT(pNtfsLog->RedoLength == sizeof(BITMAP_RANGE));
            pRange = (PBITMAP_RANGE) ((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            if (pRange->BitMapOffset <= *plBit &&
                pRange->BitMapOffset + pRange->NumberOfBits >= *plBit) {
                fRet = true;
            }
        }
    }

    return fRet;
} // MatchBit


//+---------------------------------------------------------------------------
//
//  Function:   MatchTrace
//
//  Synopsis:   Function used to trace forward
//
//  Arguments:  [pRecord] -- record to check
//              [Context] -- prev. lsn to look for 
//
//  Returns:    
//
//  History:    7-29-1999   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchTrace(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PLSN LsnMatch = (PLSN) Context;

    if (pRecord->ClientPreviousLsn.QuadPart == LsnMatch->QuadPart) {
        LsnMatch->QuadPart = pRecord->ThisLsn.QuadPart;
        return true;
    } else {
        return false;
    }
} // MatchTrace


//+---------------------------------------------------------------------------
//
//  Function:   MatchTrackTransactions
//
//  Synopsis:   
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    5-09-2001   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchTrackTransactions(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PTRANSACTION_MAP Map = (PTRANSACTION_MAP) Context;
    PNTFS_LOG_RECORD_HEADER NtfsRecord = NULL;
    LONGLONG StartLsn;

    if (pRecord->ClientDataLength) {

        //
        //  If commit remove the transaction from the log
        // 
                 
        NtfsRecord = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord + sizeof(LFS_RECORD_HEADER));
    }

    //
    //  leave quickly for checkpoint records
    //

    if ((pRecord->RecordType == LfsClientRestart) ||
        (NtfsRecord->RedoOperation == OpenAttributeTableDump) ||
        (NtfsRecord->RedoOperation == AttributeNamesDump) ||
        (NtfsRecord->RedoOperation == DirtyPageTableDump) ||
        (NtfsRecord->RedoOperation == TransactionTableDump)) {

        return false;
    }

    //
    //  Update the current state of the transaction - if its new the prev lsn will == 0
    //  which won't be present and we'll add a new record - this also happens for partial transactions
    //  at the start of the log
    //  

    if (Map->Lookup( pRecord->ClientPreviousLsn.QuadPart ) != NULL) {
        if (!Map->Remove( pRecord->ClientPreviousLsn.QuadPart )){
            printf( "problem\n" );
        }
        Map->Insert( pRecord->ThisLsn.QuadPart,  NtfsRecord ? NtfsRecord->RedoOperation : -1 );

//        printf( "replaced %I64x\n", pRecord->ThisLsn.QuadPart );
    } else {
//        printf( "added %I64x\n", pRecord->ThisLsn.QuadPart );
        Map->Insert( pRecord->ThisLsn.QuadPart,  NtfsRecord ? NtfsRecord->RedoOperation : -1 );
    }
    
    if (NtfsRecord) {

        //
        //  If commit remove the transaction from the log
        // 
                 
        if (NtfsRecord->RedoOperation == ForgetTransaction) {
                                            
            
            if (!Map->Remove( pRecord->ThisLsn.QuadPart )) {
                printf( "remove %I64x failed\n", pRecord->ThisLsn.QuadPart );
            } else {
//                printf( "remove %I64x\n", pRecord->ThisLsn.QuadPart );
            }
        }
    } 
    
    return false;
} // MatchTrackTransactions



//+---------------------------------------------------------------------------
//
//  Function:   ScanLsnRangeForMatch
//
//  Synopsis:   Walk the range of LSN records and dump any that have to
//              do with the given VCN
//
//  Arguments:  [hFile]    -- logfile handle
//              [LsnFirst] -- beginning of LSN range
//              [LsnMax]   -- end of LSN range
//              [Vcn]      -- vcn to search
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:     VCN is the TargetVcn in the NTFS_LOG_RECORD_HEADER
//
//----------------------------------------------------------------------------

void ScanLsnRangeForMatch(HANDLE hFile, LSN LsnFirst, LSN LsnMax,
                          PMATCH_FUNC pMatchFunc, PVOID MatchContext)
{
    BYTE                    lpBuffer[LOG_PAGE];
    BYTE *                  pLargeBuffer = 0;
    INT                     cbOffset;
    INT                     cbPage;
    INT                     cbPageOffset;
    OVERLAPPED              ol;
    DWORD                   dwRead;
    PLFS_RECORD_HEADER      pRecord;
    PLFS_RECORD_HEADER      pNextRecord;
    bool                    fStartNextPage = false;
    int                     iIndex;
    LSN                     LsnNext = LsnFirst;
    int                     cbToRead;
    PNTFS_LOG_RECORD_HEADER pNtfsLog;
    int                     cbLargeBuf;
    CMap<int, MYENTRY>      AttrMap;
    PLFS_RECORD_PAGE_HEADER pHdr;
    ULONG                   ulTemp;
    ULONG                   SeqNum;
    bool                    ValidRecord = TRUE;


    memset(&ol, 0, sizeof(ol));

    do {

        cbOffset = (ULONG) LsnToOffset(LsnNext.QuadPart);
        cbPage = cbOffset & ~(LOG_PAGE - 1);

        //
        // Load the 1st page its in
        //

        ol.Offset = cbPage;
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            return;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            printf( "Failed to resolve USA sequence in page: 0x%x\n", cbPage );
            return;
        }
        fStartNextPage = false;

        do {
            LsnFirst = LsnNext;

            SeqNum = LsnToSequenceNumber( LsnFirst.QuadPart );
            cbOffset = (ULONG) LsnToOffset(LsnFirst.QuadPart);
            cbPageOffset = cbOffset & (LOG_PAGE - 1);
            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset);


            if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {

                //
                //  Let check the ping pong pages
                //  

                ulTemp = ol.Offset;
                ol.Offset = 0x2000;

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                    return;
                }
                ol.Offset = ulTemp;
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                {
                    break;
                }

                pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

                //
                //  If the ping-pong is no good go back to the old buffer and do
                //  a seq number jump
                //

                if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {
                    
                    ValidRecord = FALSE;

                    if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                        printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                        return;
                    }
                    if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                    {
                        break;
                    }
                    pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

                    printf("Warning: Lsn in record 0x%I64x doesn't match Lsn: 0x%I64x!!\n\n", pRecord->ThisLsn,
                           LsnFirst);

                    //
                    //  Start next page
                    // 
                    
                    pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
                    if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                        LsnNext.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                    } else {
                        fStartNextPage = true;
                    }

                } else {
                    ValidRecord = TRUE;
                }
            } else {
                ValidRecord = TRUE;
            }

            //
            //   If its in the page dump it directly o.w get the complete multipage record
            //

            if (ValidRecord) {
                if (!(pRecord->Flags & LOG_RECORD_MULTI_PAGE)) {

                    //
                    //  Add to OpenAttributeTable if necc.
                    //

                    AddNewAttributes(pRecord, AttrMap);

                    if (pMatchFunc(pRecord, MatchContext)) {
                        
                        printf("Offset: 0x%x\n", cbOffset);
                        DumpLogRecord(pRecord, &AttrMap);
                        printf("\n");

                    }
                    //advance to next
                    pNextRecord = (PLFS_RECORD_HEADER)((BYTE *)pRecord +
                                                       pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER));
                    if ((BYTE *)pNextRecord > &lpBuffer[LOG_PAGE - sizeof(LFS_RECORD_HEADER)]) {
                        fStartNextPage = true;
                    } else {
                        LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;

                        if (LsnNext.QuadPart == 0) {
                            fStartNextPage = true;
                        }
                    }
                } else {
                    //
                    //  Brute force scatter-gather
                    //


                    cbLargeBuf = 2 * sizeof(LFS_RECORD_HEADER) + pRecord->ClientDataLength;
                    if (LOG_PAGE - cbPageOffset > cbLargeBuf) {
                        printf("ClientDataLength 0x%x is invalid!\n", 
                               pRecord->ClientDataLength);
                        return;
                    }
                    pLargeBuffer = new BYTE[cbLargeBuf];
                    memcpy(pLargeBuffer, pRecord, LOG_PAGE - cbPageOffset);
                    pRecord = (PLFS_RECORD_HEADER) pLargeBuffer;
                    pLargeBuffer += LOG_PAGE - cbPageOffset;

                    for (iIndex = pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER) -
                         (LOG_PAGE - cbPageOffset);
                        iIndex > 0;
                        iIndex -= (LOG_PAGE - TOTAL_PAGE_HEADER)) {
                        ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                        if (ol.Offset == 0) {
                            ol.Offset = LOG_PAGE * 4;
                        }

                        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                            printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                            return;
                        }
                        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                        {
                            break;
                        }
                        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

                        //check if really need the ping-pong page
                        if ((pHdr->Flags & LOG_PAGE_LOG_RECORD_END) &&
                            (pHdr->Header.Packed.LastEndLsn.QuadPart < LsnFirst.QuadPart)) {

                            printf("At ping-pong\n");

                            ulTemp = ol.Offset;
                            ol.Offset = 0x2000;

                            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                                printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                                return;
                            }
                            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                            {
                                printf( "Invalid USA sequence\n" );
                                break;
                            }
                            pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

                            ol.Offset = ulTemp;
                        }

                        cbToRead = min(LOG_PAGE - TOTAL_PAGE_HEADER,
                                       iIndex + sizeof(LFS_RECORD_HEADER));
                        memcpy(pLargeBuffer, lpBuffer + TOTAL_PAGE_HEADER, cbToRead);
                        pLargeBuffer += cbToRead;
                    }

                    if (pRecord->ClientDataLength) {

                        //
                        //  Add to OpenAttributeTable if necc.
                        //

                        AddNewAttributes(pRecord, AttrMap);

                        if (pMatchFunc(pRecord, MatchContext)) {
                            printf("Offset: 0x%x\n", cbOffset);
                            DumpLogRecord(pRecord, &AttrMap);
                            printf("\n");
                        }
                    }

                    pNextRecord = (PLFS_RECORD_HEADER)(pLargeBuffer - sizeof(LFS_RECORD_HEADER));
                    if (-1 * iIndex < sizeof(LFS_RECORD_HEADER)) {
                        fStartNextPage = true;
                    } else {
                        LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
                    }
                    //remove the temp buffer and then restore the regular buffer
                    pLargeBuffer = (BYTE *)pRecord;
                    delete[] pLargeBuffer;
                }
            }

            if (fStartNextPage) {
                ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                if (ol.Offset == 0) {
                    ol.Offset = LOG_PAGE * 4;
                }

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    return;
                }
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                {
                    break;
                }
                pRecord = (PLFS_RECORD_HEADER) (lpBuffer + TOTAL_PAGE_HEADER);
                LsnNext.QuadPart = pRecord->ThisLsn.QuadPart;
                fStartNextPage = false;
            }

            //  Check for a sequence jump 
            //  if so then we need to rescam if it  has changed by 
            //  more than 1
            //  

            if (LsnToSequenceNumber( LsnNext.QuadPart ) != SeqNum ) {

                printf( "Sequence number jump 0x%x to 0x%x for LSN: 0x%I64x!\n\n", SeqNum, LsnToSequenceNumber( LsnNext.QuadPart ), LsnNext.QuadPart );

                if (LsnToSequenceNumber( LsnNext.QuadPart ) != SeqNum + 1) {

                    //  
                    //  Set to current so we exit this loop and scan for the next 
                    //  LSN
                    // 

                    LsnNext = LsnFirst;
                }
            }

        } while (LsnFirst.QuadPart < LsnMax.QuadPart && LsnFirst.QuadPart < LsnNext.QuadPart );
        
        LsnNext = ScanForNextLsn( hFile, LsnFirst );
        printf( "skip to 0x%I64x\n", LsnNext );

    } while ( LsnNext.QuadPart != LsnFirst.QuadPart && LsnNext.QuadPart < LsnMax.QuadPart );

    printf("At end page, Lsn: 0x%x 0x%I64x 0x%I64x\n", ol.Offset, LsnFirst, LsnNext);

} // ScanLsnRangeForMatch


//+---------------------------------------------------------------------------
//
//  Function:   TraceTransaction
//
//  Synopsis:   Given an lsn show the transaction its involved in
//
//  Arguments:  [hFile]    -- logfile handle
//              [Lsn]      -- lsn to check
//              [LsnFirst] -- 
//              [LsnMax]   -- ending lsn in the logfile
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//              7-29-1999   benl   modified
//
//  Notes: First use prev back pointers to find the beginning of the transaction
//         then just scan forwards for all pieces
//
//----------------------------------------------------------------------------

void TraceTransaction(HANDLE hFile, LSN Lsn, LSN LsnFirst, LSN LsnMax)                                       
{
    BYTE                    lpBuffer[LOG_PAGE];
    BYTE *                  pLargeBuffer = 0;
    INT                     cbOffset;
    INT                     cbPage;
    INT                     cbPageOffset;
    OVERLAPPED              ol;
    DWORD                   dwRead;
    PLFS_RECORD_HEADER      pRecord;
    PLFS_RECORD_HEADER      pNextRecord;
    bool                    fStartNextPage = false;
    int                     iIndex;
    LSN                     LsnTemp;
    LSN                     LsnNext;
    int                     cbToRead;
    CMap<int, MYENTRY>      AttrMap;


    memset(&ol, 0, sizeof(ol));

    do {
        cbOffset = (ULONG)(LsnToOffset(Lsn.QuadPart));
        cbPage = cbOffset & ~(LOG_PAGE - 1);
        cbPageOffset = cbOffset & (LOG_PAGE - 1);

        //
        // Load the 1st page its in
        //

        ol.Offset = cbPage;
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            return;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }
        pRecord = (PLFS_RECORD_HEADER)(lpBuffer + cbPageOffset);
        printf("ThisLsn, PrevLsn, UndoLsn: 0x%I64x 0x%I64x 0x%I64x\n",
               pRecord->ThisLsn, pRecord->ClientPreviousLsn,
               pRecord->ClientUndoNextLsn);
        fflush( stdout );

        MYASSERT(pRecord->ThisLsn.QuadPart == Lsn.QuadPart);
        if (pRecord->ClientPreviousLsn.QuadPart) {
            Lsn.QuadPart = pRecord->ClientPreviousLsn.QuadPart;
        }
    } while (pRecord->ClientPreviousLsn.QuadPart);

    printf("\n");

    //
    //  Buildup attribute names
    //
//    ScanLsnRangeForMatch(hFile, LsnFirst, Lsn, MatchRecordNewAttributes, &AttrMap);

    LsnTemp.QuadPart = 0;

    ScanLsnRangeForMatch( hFile, Lsn, LsnMax, MatchTrace, &LsnTemp );

    /*
    //
    //  Now Scan Forward dumping pieces - Lsn is set to LSN to match 0 to start and
    //  LsnNext is the next lsn to look at 
    //
    
    LsnNext = Lsn;
    Lsn.QuadPart = 0;
    
    do {
        LsnTemp = LsnNext;

        cbOffset = (ULONG)(LsnToOffset(LsnTemp.QuadPart));
        cbPageOffset = cbOffset & (LOG_PAGE - 1);
        pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset);

        if (pRecord->ThisLsn.QuadPart != LsnTemp.QuadPart) {
            ULONG ulTemp;

            //
            //  Let check the ping pong pages
            //  

            ulTemp = ol.Offset;
            ol.Offset = 0x2000;

            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                return;
            }
            ol.Offset = ulTemp;
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
            {
                break;
            }

            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

            //
            //  If the ping-pong is no good go back to the old buffer and do
            //  a seq number jump
            //

            if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {

                printf("Warning: Lsn in record 0x%I64x doesn't match Lsn: 0x%I64x!!\n\n", pRecord->ThisLsn,
                       LsnFirst);
                break;
            }
        }

        //
        //   If its in the page dump it directly o.w get the complete multipage record
        //

        if (!(pRecord->Flags & LOG_RECORD_MULTI_PAGE)) {
            //
            //  Check for matching Lsn prev
            //

            AddNewAttributes(pRecord, AttrMap);

            if (pRecord->ClientPreviousLsn.QuadPart == Lsn.QuadPart) {
                printf("Offset: 0x%x\n", cbOffset);
                DumpLogRecord(pRecord, &AttrMap);
                printf("\n");
                Lsn = pRecord->ThisLsn;
            }
            //advance to next
            pNextRecord = (PLFS_RECORD_HEADER)((BYTE *)pRecord +
                                               pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER));
            if ((BYTE *)pNextRecord > &lpBuffer[LOG_PAGE - sizeof(LFS_RECORD_HEADER)]) {
                fStartNextPage = true;
            } else {
                LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
            }
        } else {
            //
            //  Brute force scatter-gather
            //

            pLargeBuffer = new BYTE[2 * sizeof(LFS_RECORD_HEADER) + pRecord->ClientDataLength];
            memcpy(pLargeBuffer, pRecord, LOG_PAGE - cbPageOffset);
            pRecord = (PLFS_RECORD_HEADER) pLargeBuffer;
            pLargeBuffer += LOG_PAGE - cbPageOffset;

            for (iIndex = pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER) -
                 (LOG_PAGE - cbPageOffset);
                iIndex > 0;
                iIndex -= (LOG_PAGE - TOTAL_PAGE_HEADER)) {
                ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                if (ol.Offset == 0) {
                    ol.Offset = LOG_PAGE * 4;
                }

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                    return;
                }
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
                {
                    break;
                }
                cbToRead = min(LOG_PAGE - TOTAL_PAGE_HEADER,
                               iIndex + sizeof(LFS_RECORD_HEADER));
                memcpy(pLargeBuffer, lpBuffer + TOTAL_PAGE_HEADER, cbToRead);
                pLargeBuffer += cbToRead;
            }

            AddNewAttributes(pRecord, AttrMap);

            if (pRecord->ClientPreviousLsn.QuadPart == Lsn.QuadPart) {
                printf("Offset: 0x%x\n", cbOffset);
                DumpLogRecord(pRecord, &AttrMap);
                printf("\n");
                Lsn = pRecord->ThisLsn;
            }

            pNextRecord = (PLFS_RECORD_HEADER)(pLargeBuffer - sizeof(LFS_RECORD_HEADER));
            if (-1 * iIndex < sizeof(LFS_RECORD_HEADER)) {
                fStartNextPage = true;
            } else {
                LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
            }

            //remove the temp buffer and then restore the regular buffer
            pLargeBuffer = (BYTE *)pRecord;
            delete[] pLargeBuffer;
        }

        if (fStartNextPage) {
            ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
            if (ol.Offset == 0) {
                ol.Offset = LOG_PAGE * 4;
            }

            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                return;
            }
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
            {
                break;
            }
            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + TOTAL_PAGE_HEADER);
            LsnNext.QuadPart = pRecord->ThisLsn.QuadPart;
            fStartNextPage = false;
        }
    } while (LsnTemp.QuadPart < LsnMax.QuadPart  );

    printf("At end page, Lsn: 0x%x 0x%I64x\n", ol.Offset, LsnTemp);
*/
} // TraceTransaction


//+---------------------------------------------------------------------------
//
//  Function:   FindClusterRatio
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    12-30-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

ULONG FindClusterRatio(HANDLE hFile)
{
    BYTE                        lpRestartPage1[LOG_PAGE];
    BYTE                        lpRestartPage2[LOG_PAGE];
    LSN                         LsnRestart = {0,0};
    PLFS_RESTART_PAGE_HEADER    pRestartHdr;
    PLFS_RESTART_AREA           pLfsRestart1 = 0;
    PLFS_RESTART_AREA           pLfsRestart2 = 0;
    int                         iIndex;
    PLFS_CLIENT_RECORD          pClient = 0;
    ULONG                       ulClusterSize = 0;
    LSN                         LsnEnd;
    LSN                         LsnStart;
    DEDUCE_CTX                  DeduceCtx;


    __try {
        if (0xFFFFFFFF == SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) {
            printf("SetFilePtr failed %d\n", GetLastError());
            __leave;
        }

        //
        //  Read the two restart pages
        //

        if (!MyReadFile(hFile, lpRestartPage1, LOG_PAGE, NULL)) {
            __leave;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpRestartPage1, 0)) {
            __leave;
        }

        if (!MyReadFile(hFile, lpRestartPage2, LOG_PAGE, NULL)) {
            __leave;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpRestartPage2, 0x1000)) {
            __leave;
        }

        //
        //  Use the newer one of the two restart areas
        //

        pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpRestartPage1;
        pLfsRestart1 = (PLFS_RESTART_AREA) (lpRestartPage1 + pRestartHdr->RestartOffset);
        pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpRestartPage2;
        pLfsRestart2 = (PLFS_RESTART_AREA) (lpRestartPage2 + pRestartHdr->RestartOffset);

        if (pLfsRestart2->CurrentLsn.QuadPart > pLfsRestart1->CurrentLsn.QuadPart ) {
            pLfsRestart1 = pLfsRestart2;
        }

        //
        //  Find the Lsn for the current restart area
        //

        pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart1 + pLfsRestart1->ClientArrayOffset);

        for (iIndex=0; iIndex < pLfsRestart1->LogClients; iIndex++) {
            if (wcsncmp( pClient->ClientName, L"NTFS", 4 ) == 0) {
                LsnRestart.QuadPart = pClient->ClientRestartLsn.QuadPart;
            }
            pClient = pClient++;
        }

        if (LsnRestart.QuadPart == 0) {
            __leave;
        }

        printf( "Client restart area LSN: 0x%I64x\n", LsnRestart );
        ScanLsnRangeForMatch( hFile, LsnRestart, LsnRestart, MatchGetClusterSize, &ulClusterSize );

        //
        //  If this was an old logfile try to infer the cluster size anyway 
        //

        if (0 == ulClusterSize) {
            LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
            if (LsnStart.QuadPart == 0) {
                __leave;
            }
            LsnEnd = ScanForLastLsn(hFile, LsnStart);
            if (LsnEnd.QuadPart == 0) {
                __leave;
            }

            printf( "Scanning for cluster size\n" );
            memset( &DeduceCtx, 0, sizeof( DeduceCtx ) );
            ScanLsnRangeForMatch( hFile, LsnStart, LsnEnd, MatchDeduceClusterSize, &DeduceCtx );
            if (DeduceCtx.AddRecordVcn != 0 ) {
                ulClusterSize = (ULONG)(DeduceCtx.AddRecordFileRef / DeduceCtx.AddRecordVcn * 2);
            }
        }
    } __finally
    {
    }

    return ulClusterSize;
} // FindClusterRatio

//+---------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis: Reads restart pages determines more current one and records
//            global values
//
//  Arguments:  [hFile] --  handle to logfile
//              [Lcb]   --  lcb for log
//
//  Returns: true if successfule
//
//  History:    8-24-1998   benl   Created
//              8-25-1998   benl   modified
//
//  Notes: TODO: move all data from globals into lcb
//
//----------------------------------------------------------------------------

bool InitGlobals(HANDLE hFile, LOGCB & Logcb)
{
    BYTE                     lpBuffer[LOG_PAGE];
    PLFS_RESTART_PAGE_HEADER pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpBuffer;
    PLFS_RESTART_AREA        pLfsRestart = 0;
    int                      iIndex;
    PLFS_CLIENT_RECORD       pClient = 0;
    DWORD                    dwRead;
    OVERLAPPED               ol;

    memset(&ol, 0, sizeof(ol));

    //
    //  Read 1st restart area
    //

    if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
        printf("ReadFile failed %d\n", GetLastError());
        return false;
    }

    MYASSERT(strncmp((char *)(pRestartHdr->MultiSectorHeader.Signature), "RSTR", 4) == 0);

    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);
    gSeqNumberBits = pLfsRestart->SeqNumberBits;
    gLogFileSize = (ULONG)pLfsRestart->FileSize;
    Logcb.CurrentLsn = pLfsRestart->CurrentLsn;

    pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);
    MYASSERT(1 == pLfsRestart->LogClients);
    Logcb.FirstLsn = pClient->OldestLsn;
    //
    //  Read 2nd restart area
    //

    ol.Offset += LOG_PAGE;

    if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
        printf("ReadFile failed %d\n", GetLastError());
        return false;
    }

    MYASSERT(strncmp((char *)(pRestartHdr->MultiSectorHeader.Signature), "RSTR", 4) == 0);

    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);
    if (pLfsRestart->CurrentLsn.QuadPart > Logcb.CurrentLsn.QuadPart) {
        gSeqNumberBits = pLfsRestart->SeqNumberBits;
        gLogFileSize = (ULONG)(pLfsRestart->FileSize);
        Logcb.CurrentLsn = pLfsRestart->CurrentLsn;

        pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);
        MYASSERT(1 == pLfsRestart->LogClients);
        Logcb.FirstLsn = pClient->OldestLsn;
    }

    return true;
} // InitGlobals


//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void Usage()
{
    printf("Usage: dumplog logname [-l lsn] [-h] [-d] [-r] [-p pages] [-v vcn [clusterblockoffset]] [-t lsn] [-a]  [-L lcn] [-f fileref]\n");
    printf("    -p dumps the given number of pages of lsn records from the end \n");
    printf("       of the log\n");
    printf("    -h dumps the headers of the log including the 2 ping-pong pages\n");
    printf("    -d dumps the redo/undo data\n");
    printf("    -l lsn dumps the log record for the given lsn, the lsn should be in hex\n");
    printf("    -v vcn search for log records dealing with the given vcn in hex optionally\n");
    printf("       a cluster block offset can also be given\n");
    printf("    -t lsn dumps the transaction containing the given lsn which\n");
    printf("       should be in hex\n");
    printf("    -a dump the entire log\n");
    printf("    -L lcn searchs for log records containing the given lcn in hex\n");
    printf("    -f fileref seearchs for log records containing the given fileref \n");
    printf("       [ignores seq number]\n");
    printf("    -r scan for restart table dumps\n");
    printf("    -c [cluster size in hex] override cluster size rather than finding it\n");
    printf("    -R [start stop] dump records in range\n");
    printf("    -s verbose output during scans (shows last lsn for all pages) \n" );
    printf("    -T scan for uncommited transactions in the log\n" );
} // Usage


//+---------------------------------------------------------------------------
//
//  Function:   ParseParams
//
//  Synopsis:   Parse params and print a usage message
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:      Sets globals flags
//
//----------------------------------------------------------------------------

bool ParseParams(int argc, TCHAR * argv[])
{
    int         iIndex;
    bool        fRet = false;
    LONGLONG    llTemp;

    __try
    {
        if (argc < 2 || _tcscmp(argv[1], _T("-?")) == 0) {
            Usage();
            __leave;
        }

        //
        //   init globals
        //

        gVcnPairToMatch.Vcn = 0;
        gVcnPairToMatch.Offset = -1;



        for (iIndex=2; iIndex < argc; iIndex++) {
            if ((_tcslen(argv[iIndex]) > 1) &&  argv[iIndex][0] == _T('-')) {
                if (argv[iIndex][1] == _T('p') && iIndex < argc - 1) {
                    giPagesBackToDump = _ttoi(argv[iIndex+1]);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('l') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLsnToDump.QuadPart);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('v') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gVcnPairToMatch.Vcn);
                    iIndex++;
                    if ((iIndex + 1 < argc) && (argv[iIndex+1][0] != _T('-'))) {
                        HexStrToInt64(argv[iIndex+1], llTemp);
                        gVcnPairToMatch.Offset = (ULONG)llTemp;
                        iIndex++;
                    }
                } else if (argv[iIndex][1] == _T('t') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLsnToTrace.QuadPart);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('L') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLcnToMatch);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('b') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], llTemp);
                    glBitToMatch = (ULONG)llTemp;
                    iIndex++;
                } else if (argv[iIndex][1] == _T('h')) {
                    gfPrintHeaders = true;
                } else if (argv[iIndex][1] == _T('a')) {
                    gfDumpEverything = true;
                } else if (argv[iIndex][1] == _T('d')) {
                    gfDumpData = true;
                } else if (argv[iIndex][1] == _T('r')) {
                    gfScanForRestarts = true;
                } else if (argv[iIndex][1] == _T('f') && iIndex < argc - 1)  {
                    HexStrToInt64(argv[iIndex+1], gllFileToMatch);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('c') && (iIndex < argc - 1)) {
                    HexStrToInt64(argv[iIndex+1], llTemp);
                    iIndex++;
                    gulClusterSize = (ULONG)llTemp;
                } else if (argv[iIndex][1] == _T('R') && (iIndex < argc - 2)) {
                    HexStrToInt64(argv[iIndex+1], gllRangeStart.QuadPart);
                    HexStrToInt64(argv[iIndex+2], gllRangeEnd.QuadPart);
                    iIndex+=2;
                } else  if (argv[iIndex][1] == _T('s')) {
                    gVerboseScan = true;
                } else  if (argv[iIndex][1] == _T('T')) {
                    gfScanTransactions = true;
                } else {
                    Usage();
                    __leave;
                }
            } else {
                Usage();
                __leave;
            }
        }

        fRet = true;

    } __finally
    {
    }

    return fRet;
} // ParseParams


//+---------------------------------------------------------------------------
//
//  Function:   _tmain
//
//  Synopsis:
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

extern "C" {
int __cdecl _tmain (int argc, TCHAR *argv[])
{
    HANDLE              hFile;
    BYTE                lpBuffer[LOG_PAGE];
    DWORD               dwRead;
    int                 iIndex;
    LOGCB               Logcb;
    LSN                 LsnEnd;
    LSN                 LsnStart;
    LONGLONG            llOffset;
    FILEREF_MATCH_CTX   FileRefMatchCtx;
    OPEN_ATTR_MAP       AttrMap;
    ULONG               ulClusterSize = 0;

    if (!ParseParams(argc, argv)) {
        return 1;
    }


    hFile = CreateFile(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        _tprintf(_T("Failed to open %s, GLE=%d\n"), argv[1], GetLastError());
        return 1;
    }
    
    if (!InitGlobals(hFile, Logcb)) {
        return 1;
    }
    
    //
    //  Try to find the sectors per cluster which are in the restart pages
    //
    
    ulClusterSize = FindClusterRatio( hFile );    
    printf("Cluster Size: 0x%x\n", ulClusterSize );

    //
    //  Scan for partial transaction
    // 
    
    if (gfScanTransactions) {
        TRANSACTION_MAP Map;
        CMapIter< LONGLONG, ULONG > *Iter;
        LONGLONG Lsn1;
        ULONG Op;


        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN's between 0x%I64x and 0x%I64x for partial transactions\n\n", LsnStart,
               LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchTrackTransactions, &Map);

        printf( "Uncommited transactions\n\n" );

        Iter = Map.Enum();
        while (Iter->Next( Lsn1, Op )) {
            printf( "LSN: %I64x operation %s\n", Lsn1, (Op == -1) ? "Unknown" : gOpMap[ Op ] );
        }
        delete Iter;

    }

    //
    //  read front pages from the log
    //

    if (gfPrintHeaders) {
        if (0xFFFFFFFF == SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) {
            printf("SetFilePtr failed %d\n", GetLastError());
        }

        for (iIndex=0; iIndex < 4; iIndex++) {
            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, NULL)) {
                return 1;
            }
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, LOG_PAGE * iIndex))
            {
                break;
            }
            DumpPage(lpBuffer);
            printf("\n");
        }
    }

    //
    //  Dump Back Pages
    //

    if (giPagesBackToDump) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanBackPagesForLastLsn(hFile, LsnEnd, giPagesBackToDump);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Printing LSN's between 0x%I64x and 0x%I64x\n\n", LsnStart,
               LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchAll, NULL);
    }

    if (gLsnToDump.QuadPart) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        
        printf("Scanning LSN records for LSN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gLsnToDump.QuadPart, LsnStart, LsnEnd);
        ScanLsnRangeForMatch(hFile, gLsnToDump, gLsnToDump, MatchAll, NULL);
    }

    if (gVcnPairToMatch.Vcn) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for VCN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gVcnPairToMatch.Vcn, LsnStart, LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchVcn, &gVcnPairToMatch);
    }

    if (gLcnToMatch) {

        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for LCN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gLcnToMatch, LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchLcn, &gLcnToMatch);
    }

    if (gLsnToTrace.QuadPart) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Scanning LSN records for transaction contain LSN: 0x%I64x\n",
               gLsnToTrace);

        if ((gLsnToTrace.QuadPart < LsnStart.QuadPart) || (gLsnToTrace.QuadPart > LsnEnd.QuadPart )) {
            printf( "LSN out of range for the logfile\n" );
            return 1;
        }

        TraceTransaction(hFile, gLsnToTrace, LsnStart, LsnEnd);
    }

    if (gllFileToMatch) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Scanning LSN records for transaction contain file: 0x%I64x between 0x%I64x and 0x%I64x\n",
               gllFileToMatch, LsnStart, LsnEnd);

        FileRefMatchCtx.llFileRef = gllFileToMatch;
        FileRefMatchCtx.pAttrMap = &AttrMap;
        FileRefMatchCtx.ClusterSize = ulClusterSize;

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchFileRef, &FileRefMatchCtx);
        
    }

    if (gfDumpEverything) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Printing LSN records between 0x%I64x and 0x%I64x\n",
               LsnStart, LsnEnd );
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchAll, NULL);
    }

    if (glBitToMatch != -1) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for Bit: 0x%x  between 0x%I64x and 0x%I64x\n\n",
               glBitToMatch, LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchBit, &glBitToMatch);
    }

    if (gfScanForRestarts == TRUE) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for Restarts  between 0x%I64x and 0x%I64x\n\n",
               LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchRestartDumps, NULL);
    }


    if (gllRangeStart.QuadPart != 0) {
        printf("Printing LSN records between 0x%I64x and 0x%I64x\n\n",
               gllRangeStart, gllRangeEnd);

        ScanLsnRangeForMatch(hFile, gllRangeStart, gllRangeEnd, MatchAll, NULL);
    }

    printf("\n");

    CloseHandle(hFile);
    
    return 0;
} // _tmain
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\oidtst.c ===
//  oidtst.c

#include "oidtst.h"


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	)
{
	int Error;

    printf( "Status %x -- ", Status );

	switch(Status) {

	    case STATUS_ACCESS_DENIED:
			printf( "STATUS_ACCESS_DENIED\n" );
			break;

	    case STATUS_NOT_IMPLEMENTED:
			printf( "STATUS_NOT_IMPLEMENTED\n" );
			break;			

	    case STATUS_NOT_LOCKED:
			printf( "STATUS_NOT_LOCKED\n" );
			break;			
			
		case STATUS_OBJECTID_EXISTS:
			printf( "STATUS_OBJECTID_EXISTS\n" );
			break;

		case STATUS_BUFFER_OVERFLOW:
			printf( "STATUS_BUFFER_OVERFLOW\n" );
			break;

		case STATUS_NO_MORE_FILES:
			printf( "STATUS_NO_MORE_FILES\n" );
			break;

		case STATUS_DUPLICATE_NAME:
			printf( "STATUS_DUPLICATE_NAME\n" );
			break;

		case STATUS_OBJECT_NAME_COLLISION:
			printf( "STATUS_OBJECT_NAME_COLLISION\n" );
			break;

		case STATUS_OBJECT_NAME_NOT_FOUND:
			printf( "STATUS_OBJECT_NAME_NOT_FOUND\n" );
			break;

		case STATUS_INVALID_ADDRESS:
			printf( "STATUS_INVALID_ADDRESS\n" );
			break;

		case STATUS_INVALID_PARAMETER:
			printf( "STATUS_INVALID_PARAMETER\n" );
			break;

		case STATUS_OBJECT_PATH_NOT_FOUND:
			printf( "STATUS_OBJECT_PATH_NOT_FOUND\n" );
			break;

		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			printf( "STATUS_OBJECT_PATH_SYNTAX_BAD\n" );
			break;

		case STATUS_SUCCESS:
			printf( "STATUS_SUCCESS\n" );
			break;

		default:	  
			printf( "(unknown status code)\n" );
			break;
	}

    if (Status != STATUS_SUCCESS) {

		Error = GetLastError();
        printf( "GetLastError returned (dec): %d\n", Error );

		return 1;
    }       

	return 0;
}

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    )
{
    ULONG idx;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
//        printf( "%02x %c  ", Buffer[idx], Buffer[idx] );
        printf( "%02x ", Buffer[idx] );
    }
}

void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    )
{
    ULONG idx;
    ULONG Size = SizeInBytes / 4;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
        printf( "%08x ", Buffer[idx] );
    }
}
    
#if 0

void
FsTestDumpMenu(
		 void
		 )
{
    printf( "\n s -- Set object id" );	
    printf( "\n g -- Get object id" );	
    printf( "\n d -- Delete object id" );	
    printf( "\n o -- Open file by object id" );	
	printf( "\n q -- Quit" );	
}


int
FsTestDoCommand(
		   IN HANDLE hFile,
		   IN OUT OBJECTID *ObjectId
		  )

{
    char cmd[8];
	int retval = 0;
	HANDLE OpenedFile;
	
    printf( "\n -->" );

    scanf( "%s", cmd);

	switch(cmd[0]) {
	case 's':
		FsTestSetOid( hFile, *ObjectId );
		break;

	case 'g':
		FsTestGetOid( hFile, ObjectId );
		break;

	case 'd':
		FsTestDeleteOid( hFile, *ObjectId );
		break;

	case 'o':
		FsTestOpenByOid( *ObjectId, &OpenedFile );
		break;

	case 'q':
		retval = 1;
		break;

	default:
		printf( "\n Try again" );
    }

	return retval;
}


VOID
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
	OBJECTID ObjectId;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program tests object ids (ntfs only).\n\n");
        printf("usage: %s filename ObjectId\n", argv[0]);
        return;
    }

    hFile = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

	RtlZeroBytes( &ObjectId,
	 			  sizeof( ObjectId ) );

	sscanf( argv[2], "%d", &ObjectId.Lineage.Data1 );

	printf( "\nUsing file:%s, ObjectId:%d", argv[1], ObjectId.Lineage.Data1 );

	while (retval == 0) {

		FsTestDumpMenu();
		retval = FsTestDoCommand( hFile, &ObjectId );
	}

	CloseHandle( hFile );    

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\deloid\deloid.c ===
//  deloid.c

#include "oidtst.h"


int
FsTestDeleteOid( 
    IN HANDLE File
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( File,                     // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_DELETE_OBJECT_ID,   // FsControlCode
                              NULL,                     // input buffer
                              0,                        // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    if (argc < 2) {
        printf("This program deletes the object id (if any) from a file (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtCreateFile( &File,
                           GENERIC_WRITE | GENERIC_ALL | STANDARD_RIGHTS_ALL, 
                           &ObjAttr,
                           &IoStatusBlock,
                           NULL,                  
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,                  
                           0 );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error opening file %s %x\n", argv[1], Status );
        return;
    }

    printf( "\nUsing file:%s", argv[1] );

    FsTestDeleteOid( File );

    CloseHandle( File );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\logfile\randpeak.cxx ===
#include "pch.hxx"
#include "randpeak.hxx"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  randpeak.c  --  Functions to provide 32-bit random numbers, including  //
//                  a linear distribution (Random32 and RandomInRange),    //
//                  and a peaked distribution (RandomPeaked).              //
//                                                                         //
//                  Assumptions: ULONG is 32-bit unsigned data type, and   //
//                               BOOL is an integral boolean type.         //
//                                                                         //
//                               If MULTITHREADED is defined, critical     //
//                               section primitives must be defined and    //
//                               supported.                                //
//                                                                         //
//                               Two's complement wraparound (mod 2^32)    //
//                               occurs on addition and multiplication     //
//                               where result is greater than (2^32-1)     //
//                                                                         //
//                  Author: Tom McGuire (tommcg), 03/29/94                 //
//                                                                         //
//                  (C) Copyright 1994, Microsoft Corporation              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#define MULTIPLIER ((ULONG) 1664525 )   // From Knuth.  Guarantees 2^32 non-
                                        // repeating values.

ULONG ulInternalSeed;
ULONG ulInternalAdder;

#ifdef MULTITHREADED
    CRITICAL_SECTION ulInternalSeedCritSect;
    BOOL bInternalSeedCritSectInitialized;
#endif


ULONG BitReverse32( ULONG ulNumber ) {

    ULONG ulNewValue = 0;
    ULONG ulReadMask = 0x00000001;
    ULONG ulWriteBit = 0x80000000;

    do {
        if ( ulNumber & ulReadMask )
            ulNewValue |= ulWriteBit;
        ulReadMask <<= 1;
        ulWriteBit >>= 1;
        }
    while ( ulWriteBit );

    return ulNewValue;
    }


void SeedRandom32( ULONG ulSeed ) {

    //
    //  Assume this is called from a single thread only before any calls
    //  to Random32(), RandomInRange(), or RandomPeaked().
    //

#ifdef MULTITHREADED
    if ( ! bInternalSeedCritSectInitialized ) {
        InitializeCriticalSection( &ulInternalSeedCritSect );
        bInternalSeedCritSectInitialized = TRUE;
        }
#endif

    ulInternalSeed  = ulSeed;
    ulInternalAdder = ((( ulSeed ^ 0xFFFFFFFF ) | 0x00000001 ) & 0x7FFFFFFF );

    }


ULONG Random32( void ) {

    ULONG ulRand;

#ifdef MULTITHREADED
    EnterCriticalSection( &ulInternalSeedCritSect );
#endif

    ulRand = ( ulInternalSeed * MULTIPLIER ) + ulInternalAdder;
    ulInternalSeed = ulRand;

#ifdef MULTITHREADED
    LeaveCriticalSection( &ulInternalSeedCritSect );
#endif

    return BitReverse32( ulRand );
    }


ULONG RandomInRange( ULONG ulMinInclusive, ULONG ulMaxInclusive ) {

    ULONG ulRange = ( ulMaxInclusive - ulMinInclusive + 1 );
    ULONG ulRand  = Random32();

    if ( ulRange )
        ulRand %= ulRange;

    return ( ulRand + ulMinInclusive );
    }


ULONG RandomPeaked( ULONG ulMaxInclusive,
                    ULONG ulPeakFrequency,
                    ULONG ulPeakWidth,
                    ULONG ulPeakDensity,
                    ULONG ulPeakDecay ) {

    ULONG ulWhichPeak, ulPeakValue, ulRange, ulHigh, ulLow;

    ulWhichPeak = ( ulMaxInclusive / ulPeakFrequency );

    do {
        ulWhichPeak = RandomInRange( 0, ulWhichPeak );
        }
    while ( ulPeakDecay-- );

    ulPeakValue = ulWhichPeak * ulPeakFrequency;

    ulRange = ( ulPeakFrequency * ( ulPeakDensity + 1 )) / ( ulPeakDensity + 2 );

    while ( ulPeakDensity-- )
        ulRange = RandomInRange( ulPeakWidth / 2, ulRange );

    ulLow  = ( ulPeakValue > ulRange ) ? ( ulPeakValue - ulRange ) : 0;
    ulHigh = ( ulPeakValue + ulRange );

    if ( ulHigh > ulMaxInclusive )
        ulHigh = ulMaxInclusive;

    ulPeakValue = RandomInRange( ulLow, ulHigh );

    return ulPeakValue;

    }


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//   |                      Peaked Distribution                      |     //
//   |_                                                              |     //
//   | \                                                             |     //
//   |  \             _                                              |     //
//   |   \           / \              _                              |     //
//   |    \         /   \            / \            _                |     //
//   |     \       /     \          /   \          / \              _|     //
//   |      \_____/       \________/     \__    __/   \____________/ |     //
//   |_______________________________________________________________|     //
//   0                P              2P            nP               Max    //
//                                                                         //
//   The center of each peak occurs at ulPeakFreq intervals starting       //
//   from zero, and the tops of the peaks are linear-distributed across    //
//   ulPeakWidth (ie, +/- ulPeakWidth/2).  ulPeakDensity controls the      //
//   slope of the distribution off each peak with higher numbers causing   //
//   steeper slopes (and hence wider, lower valleys).  ulPeakDecay         //
//   controls the declining peak-to-peak slope with higher numbers         //
//   causing higher peaks near zero and lower peaks toward ulMax.          //
//   Note that ulPeakDensity and ulPeakDecay are computationally           //
//   expensive with higher values (they represent internal iteration       //
//   counts), so moderate numbers such as 3-5 for ulPeakDensity and        //
//   1-2 for ulPeakDecay are recommended.                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\logfile\utils.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       utils.cxx
//
//  Contents:   general purpose utility functions
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:      right now only operator<< for different types
//              must init crit sec for rand on your own
//
//  History:    9-11-1996   benl   Created
//
//----------------------------------------------------------------------------


#include "pch.hxx"

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include "mydebug.hxx"
#include "utils.hxx"
#include "randpeak.hxx"

static CRITICAL_SECTION gcsRand;
static BOOLEAN gfInit;

//+---------------------------------------------------------------------------
//
//  Function:   PrintGuid
//
//  Synopsis:
//
//  Arguments:  [file] --
//              [guid] --
//
//  Returns:
//
//  History:    1-27-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintGuid(FILE * file, const GUID & guid)
{
    INT iIndex;

    fprintf(file, "%08x-%04hx-%04hx-", guid.Data1, guid.Data2, guid.Data3);
    for (iIndex=0;iIndex < 8; iIndex++)
    {
        fprintf(file,"%01x", guid.Data4[iIndex]);
    }
} //PrintGuid


//+---------------------------------------------------------------------------
//
//  Function:   MyRand
//
//  Synopsis:   simple rand function
//
//  Arguments:  [dwLimit] --
//
//  Returns:    values btwn 0 and dwLimit inclusively
//
//  History:    10-23-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INT MyRand(INT iLimit)
{
    return RandomInRange(0, iLimit);
} //MyRand


//+---------------------------------------------------------------------------
//
//  Function:   MyRand64
//
//  Synopsis:   like above but for 64 bit integers
//
//  Arguments:  [llLimit] --
//
//  Returns:
//
//  History:    2-12-1997   benl   Created
//
//  Notes:      This works poorly - need a true 64bit random number generator
//
//----------------------------------------------------------------------------

LONGLONG MyRand64(LONGLONG llLimit)
{
    LARGE_INTEGER liTemp;

    liTemp.LowPart = Random32();
    liTemp.HighPart = Random32();

    return liTemp.QuadPart % llLimit;
} //MyRand64


//+---------------------------------------------------------------------------
//
//  Function:   MyRand16
//
//  Synopsis:   like above but for 16 bit integers
//
//  Arguments:  [sLimit] --
//
//  Returns:
//
//  History:    5-15-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SHORT MyRand16(SHORT sLimit)
{
    return (SHORT) RandomInRange(0, sLimit);
} // MyRand16


//+---------------------------------------------------------------------------
//
//  Function:   MySRand
//
//  Synopsis:   srand for threads
//
//  Arguments:  [dwBase] --
//
//  Returns:
//
//  History:    10-30-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID MySRand(DWORD & dwBase)
{
    if (!gfInit)
    {
        InitializeCriticalSection(&gcsRand);
        gfInit = TRUE;
    }

    EnterCriticalSection(&gcsRand);
    dwBase++;
    SeedRandom32(dwBase);
    LeaveCriticalSection(&gcsRand);
} //MySRand



//+---------------------------------------------------------------------------
//
//  Function:   SwapBuffers
//
//  Synopsis:   Swap two differently sized buffers such that
//              the info is split correctly between them
//              i.e if one is 40 bytes and the second 60 bytes
//              after its done the first one contains 40 bytes from the orig 2nd buffer
//              and the 2nd one contains the following orig 20 bytes of the 2nd buffer and
//              then the orig 40. bytes of the first buffer
//
//  Arguments:  [cbBuf1]   -- len of pBuffer1
//              [pBuffer1] -- buffer1
//              [cbBuf2]   -- len of pBuffer2
//              [pBuffer2] -- buffer2
//
//  Returns:
//
//  History:    9-29-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void SwapBuffers(INT cbBuf1, BYTE * pBuffer1, INT cbBuf2, BYTE * pBuffer2)
{
    BYTE * pTemp = new BYTE[cbBuf1];
    INT    iFirst;
    INT    iSecond;
    INT    iThird;

    memcpy(pTemp, pBuffer1, cbBuf1);

    iFirst = min(cbBuf1, cbBuf2);
    memcpy(pBuffer1, pBuffer2, iFirst);
    if (iFirst < cbBuf1)
    {
        memcpy(pBuffer1 + iFirst, pTemp, cbBuf1 - iFirst);
        iSecond = 0;
        iThird = cbBuf1 + iFirst;
    } else
    {
        memcpy(pBuffer2, pBuffer1 + iFirst, cbBuf2 - iFirst);
        iSecond = cbBuf2 - iFirst;
        iThird = 0;
    }
    memcpy(pBuffer2 + iSecond, pTemp + iThird, cbBuf2 - iSecond);

    if (pTemp)
    {
        delete[] pTemp;
    }
} // SwapBuffers



//+---------------------------------------------------------------------------
//
//  Function:   PrintByte
//
//  Synopsis:
//
//  Arguments:  [byte] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintByte(BYTE byte)
{
    printf("%02hx", byte);

} //PrintByte



//+---------------------------------------------------------------------------
//
//  Function:   PrintWord
//
//  Synopsis:
//
//  Arguments:  [bytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintWord(LPBYTE bytes)
{
    PrintByte(bytes[0]);
    printf(" ");
    PrintByte(bytes[1]);
} //PrintWord


//+---------------------------------------------------------------------------
//
//  Function:   PrintDWord
//
//  Synopsis:
//
//  Arguments:  [bytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintDWord(LPBYTE bytes)
{
    PrintWord(bytes);
    printf(" ");
    PrintWord(bytes + 2);
} //PrintDWord


//+---------------------------------------------------------------------------
//
//  Function:   DumpRawBytes
//
//  Synopsis:   Helper output function
//
//  Arguments:  [pBytes] --
//              [cBytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRawBytes(BYTE * pBytes, UINT cBytes)
{
    UINT iIndex;
    UINT iIndex2;

    if (0 == cBytes)
    {
        printf("Empty Buffer\n");
    }

/*
    if (cBytes < 16)
    {
        printf("%04x  ",iIndex * 16);
        for(iIndex=0; iIndex < cBytes; iIndex++)
        {
            PrintByte(*(pBytes + iIndex));
            printf(" ");
        }
    }
*/

    for (iIndex=0;iIndex < cBytes / 16; iIndex++)
    {
        printf("%04x  ",iIndex * 16);
        PrintDWord(pBytes + (iIndex * 16));
        printf(" ");
        PrintDWord(pBytes + (iIndex * 16 + 4));
        printf("  ");
        PrintDWord(pBytes + (iIndex * 16 + 8));
        printf(" ");
        PrintDWord(pBytes + (iIndex * 16 + 12));

        printf("  ");

        for (iIndex2=0;iIndex2 < 16; iIndex2++)
        {
            if (isgraph(pBytes[(iIndex*16) + iIndex2]))
            {
                printf("%c", pBytes[(iIndex*16) + iIndex2]);
            } else
            {
                printf(".");
            }

        }

        printf("\n");
    }

    //print trailing bytes
    printf("%04x  ", ((cBytes / 16) * 16));

    for (iIndex=0; iIndex < 16; iIndex++)
    {
        if (iIndex < cBytes % 16)
        {
            PrintByte(*(pBytes + ((cBytes / 16) * 16) + iIndex));
            printf(" ");
        } else
        {
            printf("   ");
        }
        //add byte separator if necc.
        if (iIndex && (iIndex % 7 == 0))
        {
            printf(" ");
        }

    }

    for (iIndex2=0; iIndex2 < cBytes % 16; iIndex2++)
    {
        if (isgraph(*(pBytes + ((cBytes / 16) * 16) + iIndex2)))
        {
            printf("%c", *(pBytes + ((cBytes / 16) * 16) + iIndex2));
        } else
        {
            printf(".");
        }
    }


    printf("\n");
} //DumpRawBytes


//+---------------------------------------------------------------------------
//
//  Function:   DumpRawDwords
//
//  Synopsis:
//
//  Arguments:  [pDwords] --
//              [cBytes]  --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRawDwords(DWORD * pDwords, UINT cBytes)
{
    UINT   iIndex;
    UINT   iIndex2;
    BYTE * pBytes;

    if (0 == cBytes)
    {
        printf("Empty Buffer\n");
    }

    for (iIndex=0; iIndex < cBytes / 16; iIndex++)
    {
        printf("%04x  ",iIndex * 16);

        printf("%08x ", pDwords[iIndex * 4]);
        printf("%08x ", pDwords[iIndex * 4 + 1]);
        printf("%08x ", pDwords[iIndex * 4 + 2]);
        printf("%08x ", pDwords[iIndex * 4 + 3]);

        printf("  ");

        pBytes = (BYTE *) (pDwords + (iIndex * 4));
        for (iIndex2=0; iIndex2 < 16; iIndex2++)
        {
            if (isgraph(pBytes[iIndex2]))
            {
                printf("%c", pBytes[iIndex2]);
            } else
            {
                printf(".");
            }
        }

        printf("\n");
    }

    //print trailing dwords
    printf("%04x  ", ((cBytes / 16) * 16));

    for (iIndex=0; iIndex < 4; iIndex++)
    {
        if (iIndex * 4 < cBytes % 16)
        {
            printf("%08x", pDwords[((cBytes / 16) * 4) +iIndex]);
            printf(" ");
        } else
        {
            printf("         ");
        }
    }

    printf("  ");

    pBytes = (BYTE *) (pDwords + ((cBytes / 16) * 4));
    for (iIndex2=0; iIndex2 < cBytes % 16; iIndex2++)
    {
        if (isgraph(*(pBytes + iIndex2)))
        {
            printf("%c", *(pBytes + iIndex2));
        } else
        {
            printf(".");
        }
    }


    printf("\n");
} // DumpRawDwords



//+---------------------------------------------------------------------------
//
//  Function:   HexStrToInt64
//
//  Synopsis:
//
//  Arguments:  [szIn]   --
//                   [i64Out] --
//
//  Returns:
//
//  History:    5-30-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void HexStrToInt64(LPCTSTR szIn, __int64 & i64Out)
{
    int i;
    const TCHAR * szTmp = szIn;

    i64Out = 0;

/*
    if (szTmp[0] != '0' && szTmp[1] != 'x') {
        return;
    }
    //move past prefix
    szTmp+=2;
*/
    while (*szTmp != _T('\0') &&
           (_istdigit(*szTmp) ||  (_totlower(*szTmp) >= 'a' && _totlower(*szTmp) <= 'f')))
    {
        i64Out *= 16;
        if (_istdigit(*szTmp))
        {
            i64Out +=  *szTmp - _T('0');
        } else
        {
            i64Out += _totlower(*szTmp) - _T('a') + 10;
        }
        szTmp++;
    } //endwhile
} //HexStrToInt64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\enumoid\enumoid.c ===
//  enumoid.c

#include "oidtst.h"


void
FsTestDumpObjIdIndexEntries (
    IN PFILE_OBJECTID_INFORMATION ObjIdInfo,
    IN ULONG_PTR LengthInBytes
    )

{
    ULONG ReturnedCount;
    ULONG Idx;

    ReturnedCount = (ULONG) LengthInBytes / sizeof( FILE_OBJECTID_INFORMATION );

    printf( "\n\nFound %x object id index entries", ReturnedCount );

    for (Idx = 0; Idx < ReturnedCount; Idx += 1) {

        printf( "\nEntry %x", Idx );
        FsTestHexDump( (UCHAR *)&ObjIdInfo[Idx].ObjectId, 16 );
        FsTestHexDump( (UCHAR *)&ObjIdInfo[Idx].ExtendedInfo, 16 );
    }
}


int
FsTestEnumerateOids (
	IN HANDLE hFile
	)
{
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
    FILE_OBJECTID_INFORMATION ObjIdInfo[4];
    BOOLEAN ReturnSingleEntry = TRUE;
    FILE_INFORMATION_CLASS InfoClass = FileObjectIdInformation;

	Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &ObjIdInfo[0],
                                   sizeof(ObjIdInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   NULL,     //  FileName
                                   TRUE );   //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpObjIdIndexEntries( &ObjIdInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {

        RtlFillMemory( ObjIdInfo, sizeof(ObjIdInfo), 0x51 );

	    Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       &ObjIdInfo[0],
                                       sizeof(ObjIdInfo),
                                       InfoClass,
                                       ReturnSingleEntry,
                                       NULL,     //  FileName
                                       FALSE );  //  RestartScan

        if (Status == STATUS_SUCCESS) {

            FsTestDumpObjIdIndexEntries( &ObjIdInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );

	return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program enumerates the object ids (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

	printf( "\nUsing directory:%s\n", Buffer );

	FsTestEnumerateOids( hFile );

	CloseHandle( hFile );

    return;
}

#if 0
////  graveyard
void
foobar() {

    UNICODE_STRING FakeFileName;
    UCHAR Buffer[16];

    FakeFileName.Length = FakeFileName.MaximumLength = 16;
    FakeFileName.Buffer = &Buffer[0];
    RtlZeroMemory( FakeFileName.Buffer, 16 );
    strcpy( FakeFileName.Buffer, "oidC" );

    printf( "\nWe'll restart from oid:" );
    FsTestHexDump( FakeFileName.Buffer, 16 );

    RtlFillMemory( ObjIdInfo, sizeof(ObjIdInfo), 0x51 );

    Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &ObjIdInfo[0],
                                   sizeof(ObjIdInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   &FakeFileName,     //  FileName
                                   FALSE );  //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpQuotaIndexEntries( QuotaInfo[0], IoStatusBlock.Information );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\enumr\enumr.c ===
//  enumr.c

#include "oidtst.h"


void
FsTestDumpReparsePointIndexEntries (
    IN PFILE_REPARSE_POINT_INFORMATION ReparsePointInfo,
    IN ULONG LengthInBytes
    )

{
    ULONG ReturnedCount;
    ULONG Idx;
    
    ReturnedCount = LengthInBytes / sizeof( FILE_REPARSE_POINT_INFORMATION );
    
    printf( "\n\nFound %x reparse point index entries", ReturnedCount );

    for (Idx = 0; Idx < ReturnedCount; Idx += 1) {

        printf( "\nEntry %x", Idx );
        printf( "\nTag %x", ReparsePointInfo[Idx].Tag );
        printf( "\nFileReference " );
        FsTestHexDumpLongs( &ReparsePointInfo[Idx].FileReference, 8 );
        printf( "\n" );
    }
}
   

int
FsTestEnumerateReparsePoints ( 
    IN HANDLE hFile
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    FILE_REPARSE_POINT_INFORMATION ReparsePointInfo[4];
    BOOLEAN ReturnSingleEntry = FALSE;
    FILE_INFORMATION_CLASS InfoClass = FileReparsePointInformation; 
    
    Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event 
                                   NULL,     //  ApcRoutine 
                                   NULL,     //  ApcContext 
                                   &IoStatusBlock,
                                   &ReparsePointInfo[0],
                                   sizeof(ReparsePointInfo),
                                   InfoClass, 
                                   ReturnSingleEntry,   
                                   NULL,     //  FileName 
                                   TRUE );   //  RestartScan 

    if (Status == STATUS_SUCCESS) {

        FsTestDumpReparsePointIndexEntries( &ReparsePointInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {     
        
        RtlFillMemory( ReparsePointInfo, sizeof(ReparsePointInfo), 0x51 );

        Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event 
                                       NULL,     //  ApcRoutine 
                                       NULL,     //  ApcContext 
                                       &IoStatusBlock,
                                       &ReparsePointInfo[0],
                                       sizeof(ReparsePointInfo),
                                       InfoClass, 
                                       ReturnSingleEntry,    
                                       NULL,     //  FileName 
                                       FALSE );  //  RestartScan 
        
        if (Status == STATUS_SUCCESS) {

            FsTestDumpReparsePointIndexEntries( &ReparsePointInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );
    
    return FsTestDecipherStatus( Status ); 
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;    
    char Buffer[80];

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program enumerates the reparse points (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
    
        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

    printf( "\nUsing directory:%s\n", Buffer );

    FsTestEnumerateReparsePoints( hFile );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\notify\notify.c ===
//  notify.c

#include "oidtst.h"


int
FsTestNotifyOidChange ( 
    IN HANDLE hFile
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR Buffer1[128];
    UCHAR Buffer2[128];
    PFILE_NOTIFY_INFORMATION NotifyBuffer1;
    PFILE_NOTIFY_INFORMATION NotifyBuffer2;
//    KEVENT Event1;
//    KEVENT Event2;

    RtlZeroMemory( &Buffer1[0], sizeof(Buffer1) );
    RtlZeroMemory( &Buffer2[0], sizeof(Buffer2) );

//    KeInitializeEvent( &Event1, NotificationEvent, FALSE );
//    KeInitializeEvent( &Event2, NotificationEvent, FALSE );
    
    Status = NtNotifyChangeDirectoryFile( hFile,
                                          NULL,     // Event 
                                          NULL,       // ApcRoutine 
                                          NULL,       // ApcContext 
                                          &IoStatusBlock,
                                          &Buffer1[0],
                                          sizeof(Buffer1),
                                          FILE_NOTIFY_CHANGE_FILE_NAME,
                                          TRUE );
#if 0
    Status = NtNotifyChangeDirectoryFile( hFile,
                                          NULL,     // Event 
                                          NULL,       // ApcRoutine 
                                          NULL,       // ApcContext 
                                          &IoStatusBlock,
                                          &Buffer2[0],
                                          sizeof(Buffer2),
                                          FILE_NOTIFY_CHANGE_FILE_NAME,
                                          TRUE );
#endif
    NotifyBuffer1 = (PFILE_NOTIFY_INFORMATION) &Buffer1[0];

    // NextEntryOffset
    printf( "\nAction %d", NotifyBuffer1->Action );
    printf( "\nLength %d", NotifyBuffer1->FileNameLength );
    
    printf( "\nObjectId " );
    FsTestHexDump( NotifyBuffer1->FileName, NotifyBuffer1->FileNameLength );
    printf( "\n" );

    return FsTestDecipherStatus( Status ); 
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;    
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program watches for changes to the object id index for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
    
        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

    printf( "\nUsing directory:%s\n", Buffer );

    FsTestNotifyOidChange( hFile );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\inc\oidtst.h ===
// oidtst.h


#ifndef _OIDTST_H_
#define _OIDTST_H_

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	);

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    );
    
void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    );
    
int
FsTestSetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER ObjectIdBuffer 
	);

int
FsTestGetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
	);

int
FsTestOpenByOid ( 
    IN UCHAR *ObjectId,
    IN ULONG ArgLength,
    IN PWCHAR DriveLetter
    );

int
FsTestDeleteOid( 
	IN HANDLE hFile
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\enumq\enumq.c ===
//  enumq.c

#include "oidtst.h"


void
FsTestDumpQuotaIndexEntries (
    IN PFILE_QUOTA_INFORMATION QuotaInfo,
    IN ULONG_PTR LengthInBytes
    )

{
    ULONG RemainingBytesToDump = (ULONG) LengthInBytes;
    ULONG Idx;
    ULONG CurrentEntrySize;

    PFILE_QUOTA_INFORMATION Ptr;

    printf( "\n\nFound %x quota index bytes", LengthInBytes );

    Ptr = QuotaInfo;

    Idx = 0;

    while (RemainingBytesToDump > 0) {

        printf( "\n\nEntry %x", Idx );

        printf( "\nQuotaUsed %i64", Ptr->QuotaUsed.QuadPart );
        printf( "\nQuotaLimit %i64", Ptr->QuotaLimit.QuadPart );
        printf( "\nSidLength %x", Ptr->SidLength );
        printf( "\nSid bytes are: " );
        FsTestHexDumpLongs( (PVOID) &Ptr->Sid, Ptr->SidLength );

        // why 0x38?  it's SIZEOF_QUOTA_USER_DATA (which isn't exported to this test) + 8 for quad alignment

        CurrentEntrySize = Ptr->SidLength + 0x38;
        Ptr = (PFILE_QUOTA_INFORMATION) ((PUCHAR)Ptr + CurrentEntrySize);

        RemainingBytesToDump -= CurrentEntrySize;

        Idx += 1;
    }
}


int
FsTestEnumerateQuota (
	IN HANDLE hFile
	)
{
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
    FILE_QUOTA_INFORMATION QuotaInfo[4];
    BOOLEAN ReturnSingleEntry = FALSE;
    FILE_INFORMATION_CLASS InfoClass = FileQuotaInformation;

    //
    //  Init with garbage so we can make sure Ntfs is doing its job.
    //

    RtlFillMemory( QuotaInfo, sizeof(QuotaInfo), 0x51 );

	Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &QuotaInfo[0],
                                   sizeof(QuotaInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   NULL,     //  FileName
                                   TRUE );   //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpQuotaIndexEntries( &QuotaInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {

        //
        //  Init with garbage so we can make sure Ntfs is doing its job.
        //

        RtlFillMemory( QuotaInfo, sizeof(QuotaInfo), 0x51 );

	    Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       &QuotaInfo[0],
                                       sizeof(QuotaInfo),
                                       InfoClass,
                                       ReturnSingleEntry,
                                       NULL,     //  FileName
                                       FALSE );  //  RestartScan

        if (Status == STATUS_SUCCESS) {

            FsTestDumpQuotaIndexEntries( &QuotaInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );

	return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program enumerates the quota (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

	printf( "\nUsing directory:%s\n", Buffer );

	FsTestEnumerateQuota( hFile );

	CloseHandle( hFile );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\oboid\oboid.c ===
//  oboid.c

#include "oidtst.h"

//
//  Build with USE_RELATIVE_OPEN set to one to use relative opens for
//  object IDs.  Build with USE_RELATIVE_OPEN set to zero to use a device
//  path open for object IDs.
//  Opens by File ID always use a relative open.
//

#define USE_RELATIVE_OPEN 1

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14


int
FsTestOpenByOid (
    IN UCHAR *ObjectId,
    IN ULONG ArgLength,
    IN PWCHAR DriveLetter
    )
{
    HANDLE File;
    HANDLE DumpFile;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    NTSTATUS ReadStatus;
    NTSTATUS WriteStatus;
    NTSTATUS GetNameStatus;
    NTSTATUS CloseStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;
    char mybuffer[32768];
    PFILE_NAME_INFORMATION FileName;
    LARGE_INTEGER ByteOffset;
    HANDLE VolumeHandle;
    DWORD WStatus;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants
    WCHAR Volume[] = VOLUME_PATH;
    ULONG BytesToWrite;

    RtlInitUnicodeString( &str, Full );

    RtlCopyMemory( &str.Buffer[FULL_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    str.Length = 0x1E;

    if (ArgLength == 32) {

        //
        //  Open by Object ID.
        //

#if USE_RELATIVE_OPEN

        //
        //  Open the volume for relative opens.
        //

        RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
        printf( "\nOpening volume handle, this may take a while..." );
        VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (VolumeHandle == INVALID_HANDLE_VALUE) {

            WStatus = GetLastError();
            printf( "Unable to open %ws volume\n", &Volume );
            printf( "Error from CreateFile", WStatus );
            return WStatus;
        }

        str.Length = 16;
        RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                       ObjectId,
                       16 );

#else

        //
        //  Form open path using a device prefix string.
        //

        str.Length = DEVICE_PREFIX_LEN+16;
        RtlCopyMemory( &str.Buffer[DEVICE_PREFIX_LEN/2],  //  DEVICE_PREFIX_LEN/2 goes past "\??\D:\"
                       ObjectId,
                       16 );

        VolumeHandle = NULL;

#endif

    } else if (ArgLength == 16) {

        //
        //  Open by File Reference Number (FileID),
        //  Relative opens from the Volume Handle.
        //

        RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
        printf( "\nOpening volume handle, this may take a while..." );
        VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (VolumeHandle == INVALID_HANDLE_VALUE ) {

            WStatus = GetLastError();
            printf( "Unable to open %ws volume\n", &Volume );
            printf( "Error from CreateFile", WStatus );
            return WStatus;
        }

        str.Length = 8;
        RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                       ObjectId,
                       8 );

    } else {

        return 0;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                &str,
                                OBJ_CASE_INSENSITIVE,
                                VolumeHandle,
                                NULL );

    Status = NtCreateFile( &File,
                           GENERIC_READ, // GENERIC_ALL | STANDARD_RIGHTS_ALL,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,                  // AllocationSize
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_BY_FILE_ID,
                           NULL,                  // EaBuffer
                           0 );

    if (NT_SUCCESS( Status )) {

        printf( "\nOpened file succesfully" );
#if 0
        ByteOffset.HighPart = ByteOffset.LowPart = 0;

        ReadStatus = NtReadFile( File,
                                 NULL,            //  Event
                                 NULL,            //  ApcRoutine
                                 NULL,            //  ApcContext
                                 &IoStatusBlock,
                                 mybuffer,
                                 sizeof(mybuffer),
                                 &ByteOffset,    //  ByteOffset
                                 NULL );         //  Key

        printf( "\nReadstatus %x, read %x bytes.  Here they are: ",
                ReadStatus,
                IoStatusBlock.Information );

        printf( "\n%s", mybuffer );

        printf( "\nThat's it" );
#endif

#if 1
        FileName = (PFILE_NAME_INFORMATION) &mybuffer[0];
        FileName->FileNameLength = sizeof(mybuffer) - sizeof(ULONG);

        GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                sizeof(mybuffer),
                                                FileNameInformation );

        printf( "\nGetNameStatus %x, Filename is ", GetNameStatus );
        printf( "%S\n", FileName->FileName );
#endif

#if 0

        DumpFile = CreateFile( "c:\\dumpfile",
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               0,
                               NULL );

        if (DumpFile == INVALID_HANDLE_VALUE) {

            printf( "Error opening dump file %x\n", GetLastError() );
            return FALSE;
        }

        ByteOffset.HighPart = ByteOffset.LowPart = 0;

        while(TRUE) {

            ReadStatus = NtReadFile( File,
                                     NULL,            //  Event
                                     NULL,            //  ApcRoutine
                                     NULL,            //  ApcContext
                                     &IoStatusBlock,
                                     mybuffer,
                                     sizeof(mybuffer),
                                     &ByteOffset,    //  ByteOffset
                                     NULL );         //  Key

            BytesToWrite = IoStatusBlock.Information;

            if (NT_SUCCESS( ReadStatus) &&
                BytesToWrite > 0) {

                WriteStatus = NtWriteFile( DumpFile,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatusBlock,
                                           mybuffer,
                                           BytesToWrite,
                                           &ByteOffset,
                                           NULL );

                printf( "\nOffset %x", ByteOffset.LowPart );
                ByteOffset.LowPart += BytesToWrite;

            } else {

                break;
            }
        }

        printf( "\n" );
        CloseStatus = NtClose( DumpFile );
#endif
        CloseStatus = NtClose( File );

        if (!NT_SUCCESS( CloseStatus )) {

            printf( "\nCloseStatus %x", CloseStatus );
        }
    }

    if (VolumeHandle != NULL) {

        CloseHandle( VolumeHandle );
    }

    return FsTestDecipherStatus( Status );
}

VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{
#define DEBSUB "GuidToStr:"

    if (pGuid != NULL) {

        sscanf( s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                &pGuid->Data1,
                &pGuid->Data2,
                &pGuid->Data3,
                &pGuid->Data4[0],
                &pGuid->Data4[1],
                &pGuid->Data4[2],
                &pGuid->Data4[3],
                &pGuid->Data4[4],
                &pGuid->Data4[5],
                &pGuid->Data4[6],
                &pGuid->Data4[7] );
    } else {

        sprintf( s, "<ptr-null>" );
    }
}

VOID
FsTestObOidHelp(
    char *ExeName
    )
{

    printf( "This program opens a file by its file id or object id (ntfs only).\n\n" );
    printf( "usage: %s x: [FileID | Raw ObjectId | Guid Display Format ObjectID]\n", ExeName );

    printf( "Where x: is the drive letter\n" );

    printf( "A FileID is a string of 16 hex digits with a space between each\n"
            "group of 8.  E.G. oboid 00010000 00000024\n\n" );

    printf( "A raw object ID is a string of 32 hex digits with a space\n"
            "between each group of 8\n"
            "E.G. ObjectId:df0700f8 00004fba 11d0c338 b81b485f\n\n" );

    printf( "A GUID display format object ID is a string of the form \n"
            "b81b486b-c338-11d0-ba4f0000f80007df\n"
            "See the struct def for GUID in sdk\\inc\\winnt.h for byte layout.\n" );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG ObjectId[4];
    ULONG Length;
    WCHAR Drive;

    //
    //  Get parameters.
    //

    if (argc < 3) {

        FsTestObOidHelp( argv[0] );
        return;
    }

    RtlZeroBytes( ObjectId,
                  sizeof( ObjectId ) );

    Length = strlen( argv[2] );

    if ((argc == 3) && (Length == 35) && (argv[2][8] == '-')) {

        StrToGuid( argv[2], (GUID *)ObjectId );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 6) {

        sscanf( argv[2], "%08x", &ObjectId[3] );
        sscanf( argv[3], "%08x", &ObjectId[2] );
        sscanf( argv[4], "%08x", &ObjectId[1] );
        sscanf( argv[5], "%08x", &ObjectId[0] );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 4) {

        sscanf( argv[2], "%08x", &ObjectId[1] );
        sscanf( argv[3], "%08x", &ObjectId[0] );
        printf( "\nUsing FileId: %08x %08x\n", ObjectId[1], ObjectId[0] );
        Length = 16;

    } else {

        printf("Arg (%s) invalid format.\n\n", argv[2]);
        FsTestObOidHelp( argv[0] );
    }

    Drive = *argv[1];
    FsTestOpenByOid( (PUCHAR) ObjectId, Length, &Drive );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\genoid\genoid.c ===
//  genoid.c

#include "oidtst.h"


int
FsTestGenOid( 
    IN HANDLE hFile, 
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_CREATE_OR_GET_OBJECT_ID,   // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is %s", ObjectIdBuffer->ObjectId );
        
        FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );
        
        printf( "\nExtended info is %s\n", ObjectIdBuffer->ExtendedInfo );
    }

    return FsTestDecipherStatus( Status );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    char mybuffer[100];
    NTSTATUS GetNameStatus;

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program finds the object id of a file and generates one if necessary (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    File = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    GetNameStatus = NtQueryInformationFile( File,
                                            &IoStatusBlock,
                                            mybuffer, 
                                            sizeof(mybuffer),
                                            FileNameInformation );
                                            
    printf( "\nGetNameStatus %x, Filename is:", GetNameStatus );        
    printf( "%S", (mybuffer + 4) );

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    printf( "\nUsing file:%s", argv[1] );

    FsTestGenOid( File, &ObjectIdBuffer );

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\getvid\getvid.c ===
//  getvid.c

#include "oidtst.h"


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

	FILE_OBJECTID_BUFFER ObjectIdBuffer;

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program finds the object id of a volume (ntfs only).\n\n");
        printf("usage: %s <drive letter>:\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    // RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    Status = NtQueryVolumeInformationFile( Volume,
                                           &IoStatusBlock,
                                           &ObjectIdBuffer, 
                                           sizeof(ObjectIdBuffer),
                                           FileFsObjectIdInformation );

    if (Status == STATUS_SUCCESS) {

        printf( "\nVolume Object Id is: " );
        FsTestHexDump( (UCHAR *)&ObjectIdBuffer.ObjectId, 16 );
        
        printf( "\nExtended info: " );
        FsTestHexDump( (UCHAR *)&ObjectIdBuffer.ExtendedInfo, 48 );
        
    } else {
    
        FsTestDecipherStatus( Status );
    }        
    
    CloseHandle( Volume );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\getoid\getoid.c ===
//  getoid.c

#include "oidtst.h"


int
FsTestGetOid(
    IN HANDLE hFile,
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_GET_OBJECT_ID,             // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is %s", ObjectIdBuffer->ObjectId );

        FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );

        printf( "\nObjectId:%08x %08x %08x %08x\n",
                *((PULONG)&ObjectIdBuffer->ObjectId[12]),
                *((PULONG)&ObjectIdBuffer->ObjectId[8]),
                *((PULONG)&ObjectIdBuffer->ObjectId[4]),
                *((PULONG)&ObjectIdBuffer->ObjectId[0]) );

        printf( "\nExtended info is %s\n", ObjectIdBuffer->ExtendedInfo );

        FsTestHexDump( ObjectIdBuffer->ExtendedInfo, 48 );
    }

    return FsTestDecipherStatus( Status );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    char mybuffer[100];
    NTSTATUS GetNameStatus;
    NTSTATUS GetFrsStatus;
    FILE_INTERNAL_INFORMATION InternalInfo;

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program finds the object id of a file (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    File = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    GetNameStatus = NtQueryInformationFile( File,
                                            &IoStatusBlock,
                                            mybuffer,
                                            sizeof(mybuffer),
                                            FileNameInformation );

    printf( "\nGetNameStatus %x, Filename is:", GetNameStatus );
    printf( "%S", (mybuffer + 4) );

    GetFrsStatus = NtQueryInformationFile( File,
                                           &IoStatusBlock,
                                           &InternalInfo,
                                           sizeof(InternalInfo),
                                           FileInternalInformation );

    printf( "\nGetFrsStatus %x, FRS is: (highpart lowpart )", GetFrsStatus );
    printf( "\n                         %08x %08x", InternalInfo.IndexNumber.HighPart, InternalInfo.IndexNumber.LowPart );

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    printf( "\nGetting object id for file:%s\n", argv[1] );

    FsTestGetOid( File, &ObjectIdBuffer );

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\offline\offline.c ===
//  offline.c

#include "oidtst.h"

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR ArgStr[2];

    if (argc < 3) {
        printf( "This program finds the object id of a file (ntfs only).\n\n" );
        printf( "usage: %s filename [+ | -]\n", argv[0] );
        printf( "example: %s foo.dll +\n", argv[0] );
        return;
    }

    File = CreateFile( argv[1],
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if (File == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    Status = NtQueryInformationFile( File,
                                     &IoStatusBlock,
                                     &BasicInfo, 
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (*argv[2] == '+') {

        BasicInfo.FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
        
    } else if (*argv[2] == '-') {

        BasicInfo.FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
        
    } else {

        printf( "Invalid parameter %s, use either + or -\n", argv[2] );
        Status = STATUS_INVALID_PARAMETER;
    }    
    
    if (NT_SUCCESS(Status)) {
    
        printf( "\nAdjusting offline attribute for file %s", argv[1] );
        
        Status = NtSetInformationFile( File,
                                       &IoStatusBlock,
                                       &BasicInfo, 
                                       sizeof(BasicInfo),
                                       FileBasicInformation );

        if (!NT_SUCCESS(Status)) {

            printf( "Error setting info%x\n", Status );
        }
    }

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\rootattr\rootattr.c ===
//  rootattr.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_BASIC_INFORMATION basicInfo;
    HANDLE hFile;
    NTSTATUS status;
    char buffer[260];

    //
    //  Get parameters
    //

    if (argc < 2) {

        printf("This program returns or sets the attributes for the root directory.\n\n");
        printf("usage: %s driveletter [new value]\n", argv[0]);
        return;
    }

    strcpy( buffer, argv[1] );
    strcat( buffer, "\\" );

    hFile = CreateFile( buffer,
                        MAXIMUM_ALLOWED,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s, error %d (decimal)\n", buffer, GetLastError() );
        return;
    }

    status = NtQueryInformationFile( hFile,
                                     &ioStatusBlock,
                                     &basicInfo,
                                     sizeof( basicInfo ),
                                     FileBasicInformation );

    if (!NT_SUCCESS( status )) {
    
    	printf( "Couldn't get attributes, error status %x\n", status );
    	CloseHandle( hFile );
        return;
    }

    printf( "Attributes for %s are currently: %0x\n", buffer, basicInfo.FileAttributes );

    if (argc >= 3) {

        //
        //  Third argument present, must be setting attributes.
        //

        sscanf( argv[2], "%02x", &basicInfo.FileAttributes );

        printf( "Setting attributes for %s to: %0x\n", buffer, basicInfo.FileAttributes );

        status = NtSetInformationFile( hFile,
                                       &ioStatusBlock,
                                       &basicInfo,
                                       sizeof( basicInfo ),
                                       FileBasicInformation );
        if (NT_SUCCESS( status )) {

            printf( "Set attributes succesfully\n" );

        } else {

        	printf( "Couldn't set attributes, error status %x\n", status );
    	}
    }

	CloseHandle( hFile );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\usntest\usntest.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    UsnTest.h

Abstract:

    This is the main header file for the UsnTest.

Author:

    Tom Miller 14-Jan-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


int
ProcessParameters(
    int argc,
    char *argv[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\syscache\dumplog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dumplog.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    2-05-2000   benl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct _SYSCACHE_LOG {
    int Event;
    int Flags;
    LONGLONG Start;
    LONGLONG Range;
    LONGLONG Result;
//    ULONG          ulDump;
} SYSCACHE_LOG, *PSYSCACHE_LOG;

typedef struct _ON_DISK_SYSCACHE_LOG {
    ULONG SegmentNumberUnsafe;    
    ULONG Reserved;
    int Event;
    int Flags;
    LONGLONG Start;
    LONGLONG Range;
    LONGLONG Result;
} ON_DISK_SYSCACHE_LOG, *PON_DISK_SYSCACHE_LOG;

#define SCE_VDL_CHANGE          0
#define SCE_ZERO_NC             1
#define SCE_ZERO_C              2
#define SCE_READ                3
#define SCE_WRITE               4
#define SCE_ZERO_CAV            5
#define SCE_ZERO_MF             6
#define SCE_ZERO_FST            7
#define SCE_CC_FLUSH            8
#define SCE_CC_FLUSH_AND_PURGE  9
#define SCE_WRITE_FILE_SIZES   10

#define SCE_MAX_EVENT           11


#define SCE_FLAG_WRITE 0x1
#define SCE_FLAG_READ  0x2
#define SCE_FLAG_PAGING 0x4
#define SCE_FLAG_ASYNC  0x8
#define SCE_FLAG_SET_ALLOC 0x10
#define SCE_FLAG_SET_EOF   0x20
#define SCE_FLAG_CANT_WAIT 0x40
#define SCE_FLAG_SYNC_PAGING 0x80
#define SCE_FLAG_LAZY_WRITE 0x100
#define SCE_FLAG_CACHED 0x200
#define SCE_FLAG_ON_DISK_READ 0x400
#define SCE_FLAG_RECURSIVE  0x800
#define SCE_FLAG_NON_CACHED  0x1000
#define SCE_FLAG_UPDATE_FROM_DISK  0x2000

#define SCE_MAX_FLAG   0x4000


char * LogEvent[] =
{
    "SCE_VDL_CHANGE",
    "SCE_ZERO_NC",
    "SCE_ZERO_C",
    "SCE_READ",
    "SCE_WRITE",
    "SCE_ZERO_CAV",
    "SCE_ZERO_MF",
    "SCE_ZERO_FST",
	"SCE_CC_FLUSH",
    "SCE_CC_FLUSH_AND_PURGE",
    "SCE_WRITE_FILE_SIZES",
    "SCE_MAX_EVENT"
};


void __cdecl main (int argc, char *argv[])
{
    HANDLE hFile;
    TCHAR szName[] = "c:\\$ntfs.log"; 
    UCHAR szBuffer[ 0x1000 ];
    PON_DISK_SYSCACHE_LOG pEntry;
    ULONG ulRet;
    int iIndex;

    if (argc < 2 || argv[1][0] == '\0') {
        printf( "Utility to dump $ntfs.log\n" );
        printf( "Usage: dumpsyscachelog drive:\n" );
        return;
    }
    
    szName[0] = argv[1][0];
    hFile = CreateFile( szName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "Open of %s failed %d\n", szName, GetLastError() );
        return;
    }

    do {
        if (!ReadFile( hFile,
                       &szBuffer,
                       sizeof( szBuffer ),
                       &ulRet,
                       NULL )) {

            printf( "ReadFile failed %d\n", GetLastError() );
            return;
        }

        pEntry = (PON_DISK_SYSCACHE_LOG)szBuffer;

        for (iIndex=0; iIndex < 0x1000 / sizeof( ON_DISK_SYSCACHE_LOG ); iIndex++)  {
            
            //
            //  Breakout if the segref is 0, we're at the end of the log
            //  

            if (pEntry->SegmentNumberUnsafe == 0) {
                return;
            } else {
                printf( "File: 0x%x ", pEntry->SegmentNumberUnsafe ); 
            }

            if (pEntry->Event < SCE_MAX_EVENT) {
                printf( "(%s)\n", LogEvent[pEntry->Event] );
            } else {
                printf( "\n" );
            }

            printf( "Flags: 0x%x (", pEntry->Flags);
            if (pEntry->Flags & SCE_FLAG_WRITE) {
                printf( "write " );
            }
            if (pEntry->Flags & SCE_FLAG_READ) {
                printf( "read " );
            }
            if (pEntry->Flags & SCE_FLAG_PAGING) {
                printf( "paging io " );
            }
            if (pEntry->Flags & SCE_FLAG_ASYNC) {
                printf( "asyncfileobj " );
            }
            if (pEntry->Flags & SCE_FLAG_SET_ALLOC) {
                printf( "setalloc " );
            }
            if (pEntry->Flags & SCE_FLAG_SET_EOF) {
                printf( "seteof " );
            }
            if (pEntry->Flags & SCE_FLAG_CANT_WAIT) {
                printf( "cantwait ");
            }
            if (pEntry->Flags & SCE_FLAG_SYNC_PAGING) {
                printf( "synchpaging " );
            }
            if (pEntry->Flags & SCE_FLAG_LAZY_WRITE) {
                printf( "lazywrite " );
            }
            if (pEntry->Flags & SCE_FLAG_CACHED) {
                 printf( "cached " );
            }
            if (pEntry->Flags & SCE_FLAG_ON_DISK_READ) {
                 printf( "fromdisk " );
            }
            if (pEntry->Flags & SCE_FLAG_RECURSIVE) {
                 printf( "recursive " );
            }
            if (pEntry->Flags & SCE_FLAG_NON_CACHED) {
                 printf( "noncached " );
            }

            if (pEntry->Flags & SCE_FLAG_UPDATE_FROM_DISK) {
                printf( "updatefromdisk " );
            }

            printf(")\n");
            printf("Start: 0x%I64x Range: 0x%I64x Result: 0x%I64x\n\n",
                    pEntry->Start, pEntry->Range, pEntry->Result);

            pEntry++;

        } //  endfor


    } while ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\setext\setext.c ===
// setext.c

#include "oidtst.h"


int
FsTestSetExtendedInfo( 
    IN HANDLE hFile, 
    IN PUCHAR ExtInfoBuffer
    )
{

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                    // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_SET_OBJECT_ID_EXTENDED,  // FsControlCode
                              ExtInfoBuffer,            // input buffer
                              48,                       // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0 );                      // OutputBuffer Length

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    UCHAR ExtInfoBuffer[48];
    int retval = 0;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program sets the object id extended info for a file (ntfs only).\n\n");
        printf("usage: %s filename ExtendedInfo\n", argv[0]);
        return;
    }

    hFile = CreateFile( argv[1],
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    RtlZeroBytes( ExtInfoBuffer, sizeof( ExtInfoBuffer ) );

    sscanf( argv[2], "%s", &ExtInfoBuffer );    

    printf( "\nUsing file:%s, ExtendedInfo:%s", 
            argv[1], 
            ExtInfoBuffer );

    FsTestSetExtendedInfo( hFile, ExtInfoBuffer );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\setoid\setoid.c ===
// setoid.c

#include "oidtst.h"


int
FsTestSetOid( 
    IN HANDLE hFile, 
    IN FILE_OBJECTID_BUFFER ObjectIdBuffer
    )
{

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                    // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_SET_OBJECT_ID,      // FsControlCode
                              &ObjectIdBuffer,          // input buffer
                              sizeof(ObjectIdBuffer),   // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

    //
    //  Get parameters.
    //

    if (argc < 4) {
    
        printf("This program sets an object id for a file (ntfs only).\n\n");
        printf("usage: %s filename ObjectId ExtendedInfo\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtCreateFile( &File,
                           GENERIC_WRITE | GENERIC_ALL | STANDARD_RIGHTS_ALL, 
                           &ObjAttr,
                           &IoStatusBlock,
                           NULL,                  
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,                  
                           0 );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error opening file %s %x\n", argv[1], Status );
        return;
    }

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    sscanf( argv[2], "%s", &ObjectIdBuffer.ObjectId );
    sscanf( argv[3], "%s", &ObjectIdBuffer.ExtendedInfo );    

    printf( "\nUsing file:%s, ObjectId:%s, ExtendedInfo:%s", 
            argv[1], 
            ObjectIdBuffer.ObjectId,
            ObjectIdBuffer.ExtendedInfo );

    FsTestSetOid( File, ObjectIdBuffer );

    CloseHandle( File );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\objectid\setvid\setvid.c ===
// setvid.c

#include "oidtst.h"


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

	FILE_OBJECTID_BUFFER ObjectIdBuffer;

    //
    //  Get parameters 
    //

    if (argc < 4) {
        printf("This program sets the object id for a volume (ntfs only).\n\n");
        printf("usage: %s <drive letter>: ObjectId ExtendedInfo\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    // RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    sscanf( argv[2], "%s", &ObjectIdBuffer.ObjectId );
    sscanf( argv[3], "%s", &ObjectIdBuffer.ExtendedInfo );	

    printf( "\nUsing ObjectId:%s, ExtendedInfo:%s\n", 
			ObjectIdBuffer.ObjectId,
			ObjectIdBuffer.ExtendedInfo );

    Status = NtSetVolumeInformationFile( Volume, 
                                         &IoStatusBlock,
                                         &ObjectIdBuffer,
                                         sizeof( ObjectIdBuffer ),
                                         FileFsObjectIdInformation );

    FsTestDecipherStatus( Status );
    
    CloseHandle( Volume );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\tests\usntest\usntest.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    UsnTest.c

Abstract:

    This is the main module for the UsnJournal test.

Author:

    Tom Miller 14-Jan-1997

Revision History:

--*/

#include "UsnTest.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>

//
//  Current delay is 10 seconds
//

#define DELAY_TIME                       ((LONGLONG)(-100000000))

void
UsnTest(
    IN PCHAR DrivePath,
    IN ULONG Async
    );

CHAR *
FileTimeToString(
    FILETIME *pft
    );


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    char *p;
    int i;
    char c;
    char DrivePath[ 4 ];
    ULONG Async = FALSE;

    if ( argc > 1 ) {
        if (argc > 2) {
            Async = TRUE;
        }
        while (--argc) {
            p = *++argv;
            if ( isalpha(*p) ) {
                sprintf( DrivePath, "%c:", *p );
                UsnTest( DrivePath, Async );
                break;
            }
        }
    } else {
        printf( "UsnTest <DriveLetter> [A](for asyncmode)" );
    }

    return( 0 );
}

void
UsnTest(
    IN PCHAR DrivePath,
    IN ULONG Async
    )

{
    UCHAR VolumePath[16];
    HANDLE VolumeHandle;
    HANDLE Event;
    DWORD ReturnedByteCount;
    CREATE_USN_JOURNAL_DATA CreateUsnJournalData = {0x800000, 0x100000};
    READ_USN_JOURNAL_DATA ReadUsnJournalData = {0, MAXULONG, 0, DELAY_TIME, 1};
    ULONGLONG Buffer[1024];
    PUSN_RECORD UsnRecord;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    //
    //  Create the event.
    //

    Status = NtCreateEvent( &Event, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );

    if (!NT_SUCCESS(Status)) {
        printf( "NtCreateEvent failed with %08lx\n", Status );
        return;
    }

    //
    //  Get a volume handle.
    //

    _strupr( DrivePath );
    sprintf( VolumePath, "\\\\.\\%s", DrivePath );
    VolumeHandle = CreateFile( VolumePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               (Async ? FILE_FLAG_OVERLAPPED : 0),
                               NULL );

    if (VolumeHandle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "UsnTest: Unable to open %s volume (%u)\n", &VolumePath, GetLastError() );
        return;
    }

    //
    //  Create the Usn Journal if it does not exist.
    //

    printf( "Creating UsnJournal on %s\n", DrivePath );

    if (!NT_SUCCESS( Status = NtFsControlFile( VolumeHandle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &Iosb,
                                               FSCTL_CREATE_USN_JOURNAL,
                                               &CreateUsnJournalData,
                                               sizeof(CreateUsnJournalData),
                                               NULL,
                                               0 ))) {

        printf( "Create Usn Journal failed (%08lx)\n", Status );
        return;

    } else {

        while (TRUE) {

            Status = NtFsControlFile( VolumeHandle,
                                      Async ? Event : NULL,
                                      NULL,
                                      NULL,
                                      &Iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &ReadUsnJournalData,
                                      sizeof(ReadUsnJournalData),
                                      &Buffer,
                                      sizeof(Buffer) );

            if (Status == STATUS_PENDING) {
                NtWaitForSingleObject( Event, TRUE, NULL );
            }

            if (NT_SUCCESS(Status)) {
                Status = Iosb.Status;
            }

            if (Status == STATUS_KEY_DELETED) {
                printf( "\n\nUsn %08lx, %08lx has been deleted, seeking to new journal start\n\n\n",
                        (ULONG)ReadUsnJournalData.StartUsn,
                        (ULONG)(ReadUsnJournalData.StartUsn >> 32) );
                ReadUsnJournalData.StartUsn = 0;
                continue;
            }

            if (!NT_SUCCESS(Status)) {
                printf( "Read Usn Journal failed (%08lx)\n", Status );
                return;
            }

            ReturnedByteCount = Iosb.Information;
            if (ReturnedByteCount != 0) {

                UsnRecord = (PUSN_RECORD)((PCHAR)&Buffer + sizeof(USN));
                ReturnedByteCount -= sizeof(USN);
                ReadUsnJournalData.StartUsn = *(USN *)&Buffer;
                printf( "Next Usn will be: %08lx, %08lx\n",
                        (ULONG)ReadUsnJournalData.StartUsn,
                        (ULONG)(ReadUsnJournalData.StartUsn >> 32) );
            }


            while (ReturnedByteCount != 0) {

                printf( "Usn: %08lx, %08lx, RecordLength: %lx, FileRef: %08lx, %08lx, ParentRef: %08lx, %08lx\n",
                        (ULONG)UsnRecord->Usn,
                        (ULONG)(UsnRecord->Usn >> 32),
                        UsnRecord->RecordLength,
                        (ULONG)UsnRecord->FileReferenceNumber,
                        (ULONG)(UsnRecord->FileReferenceNumber >> 32),
                        (ULONG)UsnRecord->ParentFileReferenceNumber,
                        (ULONG)(UsnRecord->ParentFileReferenceNumber >> 32) );
                printf( "    Reason: %08lx, SecurityId: %08lx, TimeStamp: %s\n    FileName: %S\n",
                        UsnRecord->Reason,
                        UsnRecord->SecurityId,
                        FileTimeToString((FILETIME *)&UsnRecord->TimeStamp),
                        &UsnRecord->FileName );

                if (UsnRecord->RecordLength <= ReturnedByteCount) {
                    ReturnedByteCount -= UsnRecord->RecordLength;
                    UsnRecord = (PUSN_RECORD)((PCHAR)UsnRecord + UsnRecord->RecordLength);
                } else {
                    printf( "********Bogus ReturnedByteCount: %08lx\n", UsnRecord->RecordLength );
                    ReturnedByteCount = 0;
                }
            }

            //
            //  Show the end of the request.
            //

            printf( "\n" );

            //
            //  Keep growing the data we will wait for, just to try some different cases.
            //  Basically this converges quickly to always waiting for a full buffer, or
            //  else the timeout.
            //

            if (ReadUsnJournalData.BytesToWaitFor < sizeof(Buffer)) {
                if (!Async || (ReadUsnJournalData.BytesToWaitFor < 512)) {
                    ReadUsnJournalData.BytesToWaitFor << 2;
                }
            }
        }
    }

    CloseHandle( VolumeHandle );
    return;
}


char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

CHAR *
FileTimeToString(FILETIME *FileTime)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;
    static char Buffer[32];

    Buffer[0] = '\0';
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return("Time???");
        }
        sprintf(
            Buffer,
            "%s %s %2d, %4d %02d:%02d:%02d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
    return(Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowbackp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowbackp.h

Abstract:

    This module implements all of the backup browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#ifndef _BOWBACKP_
#define _BOWBACKP_

DATAGRAM_HANDLER(
BowserHandleBecomeBackup
    );

DATAGRAM_HANDLER(
    BowserResetState
    );

VOID
BowserResetStateForTransport(
    IN PTRANSPORT TransportName,
    IN UCHAR NewState
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowdata.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowdata.c

Abstract:

    Redirector Data Variables

    This module contains all of the definitions of the redirector data
    structures.

Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Paging out these pagable variables actually GROWS the browser by 512 bytes
//  so it's not worth doing it.
//

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

LIST_ENTRY
BowserNameHead = {0};

LIST_ENTRY
BowserTransportHead = {0};

LARGE_INTEGER
BowserStartTime = {0};

PEPROCESS
BowserFspProcess = {0};

BOOLEAN
BowserLogElectionPackets = {0};

//
//  Time out FindMaster requests after 30 seconds.
//

ULONG
BowserFindMasterTimeout = 30;


ULONG
BowserMinimumConfiguredBrowsers = MIN_CONFIGURED_BROWSERS;

ULONG
BowserMaximumBrowseEntries = MAX_BROWSE_ENTRIES;


#if DBG
ULONG
BowserMailslotDatagramThreshold = 10;

ULONG
BowserGetBrowserListThreshold = 10;

ULONG
BowserServerDeletionThreshold = 20;

ULONG
BowserDomainDeletionThreshold = 50;

#else

ULONG
BowserMailslotDatagramThreshold = 0xffffffff;

ULONG
BowserGetBrowserListThreshold = 0xffffffff;

ULONG
BowserServerDeletionThreshold = 0xffffffff;

ULONG
BowserDomainDeletionThreshold = 0xffffffff;
#endif

ULONG
BowserRandomSeed = {0};

LONG
BowserNumberOfOpenFiles = {0};


//
//  A pointer to the browser's device object
//

PBOWSER_FS_DEVICE_OBJECT
BowserDeviceObject = {0};

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  The redirector name and other initialization parameters are protected
//  by the BowserDataResource.  All reads of the initialization variables
//  should acquire the name resource before they continue.
//
//

ERESOURCE
BowserDataResource = {0};

//
//      Browser static data protected by BowserDataResource.
//

BOWSERDATA
BowserData = {0};

ULONG BowserOperationCount = 0;

ULONG
BowserCurrentTime = {0};

KSPIN_LOCK
BowserTransportMasterNameSpinLock = {0};

LONG
BowserEventLogResetFrequency = {0};

LONG
BowserIllegalDatagramCount = {0};

BOOLEAN
BowserIllegalDatagramThreshold = {0};

LONG
BowserIllegalNameCount = {0};

BOOLEAN
BowserIllegalNameThreshold = {0};

ULONG
BowserNumberOfMissedMailslotDatagrams = {0};

ULONG
BowserNumberOfMissedGetBrowserServerListRequests = {0};

BOWSER_STATISTICS
BowserStatistics = {0};

KSPIN_LOCK
BowserStatisticsLock = {0};

BOOLEAN
BowserRefuseReset = FALSE;

#ifdef PAGED_DBG
ULONG ThisCodeCantBePaged = 0;
#endif

#if     DBG

LONG BowserDebugTraceLevel = /* DPRT_ERROR | DPRT_DISPATCH */
                /*DPRT_FSDDISP | DPRT_FSPDISP | DPRT_CREATE | DPRT_READWRITE |*/
                /*DPRT_CLOSE | DPRT_FILEINFO | DPRT_VOLINFO | DPRT_DIRECTORY |*/
                /*DPRT_FILELOCK | DPRT_CACHE | DPRT_EAFUNC | */
                /*DPRT_ACLQUERY | DPRT_CLEANUP | DPRT_CONNECT | DPRT_FSCTL |*/
                /*DPRT_TDI | DPRT_SMBBUF | DPRT_SMB | DPRT_SECURITY | */
                /*DPRT_SCAVTHRD | DPRT_QUOTA | DPRT_FCB | DPRT_OPLOCK | */
                /*DPRT_SMBTRACE | DPRT_INIT |*/0;

LONG BowserDebugLogLevel = /* DPRT_ERROR | DPRT_DISPATCH */
                /*DPRT_FSDDISP | DPRT_FSPDISP | DPRT_CREATE | DPRT_READWRITE |*/
                /*DPRT_CLOSE | DPRT_FILEINFO | DPRT_VOLINFO | DPRT_DIRECTORY |*/
                /*DPRT_FILELOCK | DPRT_CACHE | DPRT_EAFUNC | */
                /*DPRT_ACLQUERY | DPRT_CLEANUP | DPRT_CONNECT | DPRT_FSCTL |*/
                /*DPRT_TDI | DPRT_SMBBUF | DPRT_SMB | DPRT_SECURITY | */
                /*DPRT_SCAVTHRD | DPRT_QUOTA | DPRT_FCB | DPRT_OPLOCK | */
                /*DPRT_SMBTRACE | DPRT_INIT |*/0;

#endif                                  // BOWSERDBG

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

BOWSER_CONFIG_INFO
BowserConfigEntries[] = {
    { BOWSER_CONFIG_IRP_STACK_SIZE, &BowserIrpStackSize, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_MAILSLOT_THRESHOLD, &BowserMailslotDatagramThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_GETBLIST_THRESHOLD, &BowserGetBrowserListThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_SERVER_DELETION_THRESHOLD, &BowserServerDeletionThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_DOMAIN_DELETION_THRESHOLD, &BowserDomainDeletionThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_FIND_MASTER_TIMEOUT, &BowserFindMasterTimeout, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_MINIMUM_CONFIGURED_BROWSER, &BowserMinimumConfiguredBrowsers, REG_DWORD, sizeof(DWORD) },
    { BROWSER_CONFIG_MAXIMUM_BROWSE_ENTRIES, &BowserMaximumBrowseEntries, REG_DWORD, sizeof(DWORD) },
    { BROWSER_CONFIG_REFUSE_RESET, &BowserRefuseReset, REG_BOOLEAN, sizeof(DWORD) },
#if DBG
    { L"BowserDebugTraceLevel", &BowserDebugTraceLevel, REG_DWORD, sizeof(DWORD) },
    { L"BowserDebugLogLevel", &BowserDebugLogLevel, REG_DWORD, sizeof(DWORD) },
#endif
    { NULL, NULL, REG_NONE, 0}
};

ULONG
BowserIrpStackSize = BOWSER_DEFAULT_IRP_STACK_SIZE;

//
//      STRING containing name of bowser device
//

UNICODE_STRING
BowserNameString = {0};

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\announce.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    announce.h

Abstract:

    This module defines the structures for the bowsers server announcement
    table


Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#ifndef _ANNOUNCE_
#define _ANNOUNCE_

//
//  The ANNOUNCE_ENTRY structure is used to hold a server announcement
//  inside the bowser FSP announcement database.  This structure is allocated
//  out of paged pool.
//

//
//  Note that text strings are kept internally as unicode, not ANSI in the
//  announcement database.
//

#define ANNOUNCE_OLD_BACKUP 0x00000001

typedef struct _ANNOUNCE_ENTRY {
    CSHORT  Signature;
    CSHORT  Size;
    ULONG   ExpirationTime;                     // Time server was last seen.
    ULONG   SerialId;                           // Serial resume key.
    LIST_ENTRY BackupLink;                      // Link if backup browser.
    PBOWSER_NAME Name;                          // The domain this is on.
    USHORT  ServerBrowserVersion;               // Browser version of server.
    WCHAR   ServerName[NETBIOS_NAME_LEN+1];     // Server's name (UNICODE)
    ULONG   ServerType;                         // Bitmask of server type
    UCHAR   ServerVersionMajor;                 // Server's software version.
    UCHAR   ServerVersionMinor;                 // Server's software version II
    USHORT  ServerPeriodicity;                  // Server's announcement frequency in sec.
    ULONG   Flags;                              // Flags for server.
    ULONG   NumberOfPromotionAttempts;          // Number of times we tried to promote.
    WCHAR   ServerComment[LM20_MAXCOMMENTSZ+1]; // Servers comment (UNICODE).
} ANNOUNCE_ENTRY, *PANNOUNCE_ENTRY;

//
//  The VIEWBUFFER structure is a structure that is used to hold the contents
//  of a server announcement between the announcement being received in the
//  bowser's receive datagram indication routine and the announcement being
//  actually being placed into the announcement database.
//

typedef struct _VIEW_BUFFER {
    CSHORT  Signature;
    CSHORT  Size;
    union {
        LIST_ENTRY  NextBuffer;                 // Pointer to next buffer.
        WORK_QUEUE_ITEM WorkHeader;             // Executive worker item header.
    } Overlay;

    PTRANSPORT_NAME TransportName;

    BOOLEAN IsMasterAnnouncement;
    UCHAR   ServerName[NETBIOS_NAME_LEN+1];     // Server's name (ANSI).
    USHORT  ServerBrowserVersion;               // Browser version of server.
    UCHAR   ServerVersionMajor;                 // Server's software version.
    UCHAR   ServerVersionMinor;                 // Server's software version II
    USHORT  ServerPeriodicity;                  // Announcement freq. in sec.

    ULONG   ServerType;                         // Bitmask of server type

    UCHAR   ServerComment[LM20_MAXCOMMENTSZ+1]; // Servers comment (ANSI).
} VIEW_BUFFER, *PVIEW_BUFFER;


//
//  Specify the maximum number of threads that will be used to
//  process server announcements.
//
//
//  Since there is never any parallelism that can be gained from having
//  multiple threads, we limit this to 1 thread.
//

#define BOWSER_MAX_ANNOUNCE_THREADS 1

DATAGRAM_HANDLER(
    BowserHandleServerAnnouncement);

DATAGRAM_HANDLER(
    BowserHandleDomainAnnouncement);

RTL_GENERIC_COMPARE_RESULTS
BowserCompareAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

PVOID
BowserAllocateAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    );

VOID
BowserFreeAnnouncement (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );

PVIEW_BUFFER
BowserAllocateViewBuffer(
    VOID
    );

VOID
BowserFreeViewBuffer(
    IN PVIEW_BUFFER Buffer
    );

VOID
BowserProcessHostAnnouncement(
    IN PVOID Context
    );

VOID
BowserProcessDomainAnnouncement(
    IN PVOID Context
    );

VOID
BowserAgeServerAnnouncements(
    VOID
    );

NTSTATUS
BowserEnumerateServers(
    IN ULONG Level,
    IN PLUID LogonId OPTIONAL,
    IN OUT PULONG ResumeKey,
    IN ULONG ServerTypeMask,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    );

VOID
BowserAnnouncementDispatch (
    PVOID Context
    );


VOID
BowserDeleteGenericTable(
    IN PRTL_GENERIC_TABLE GenericTable
    );

NTSTATUS
BowserpInitializeAnnounceTable(
    VOID
    );

NTSTATUS
BowserpUninitializeAnnounceTable(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowdata.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowdata.h

Abstract:

    Redirector global data structure definition

Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/
#ifndef _BOWDATA_
#define _BOWDATA_


#define SERVERS_PER_BACKUP          32
#define MIN_CONFIGURED_BROWSERS     1
#define MAX_BROWSE_ENTRIES          (100000)
#define MASTER_TIME_UP              15*60*1000
#define NUMBER_IGNORED_PROMOTIONS   10

#define HOST_ANNOUNCEMENT_AGE 3

//
//
//
typedef struct _BowserData {
    BOOLEAN Initialized;                    // True iff redirector has been started
    LONG    NumberOfMailslotBuffers;        // Number of buffers to receive mailslots
    LONG    NumberOfServerAnnounceBuffers;  // Number of buffers for server announcements
    LONG    IllegalDatagramThreshold;       // Max number of illegal datagrams/frequency
    LONG    EventLogResetFrequency;         // Number of seconds between resetting counter.
    BOOLEAN ProcessHostAnnouncements;
    BOOLEAN MaintainServerList;
    BOOLEAN IsLanmanNt;
#ifdef ENABLE_PSEUDO_BROWSER
    DWORD   PseudoServerLevel;
#endif
} BOWSERDATA, *PBOWSERDATA;

typedef struct _BOWSER_CONFIG_INFO {
    LPWSTR      ConfigParameterName;
    PVOID       ConfigValue;
    ULONG       ConfigValueType;
    ULONG       ConfigValueSize;
} BOWSER_CONFIG_INFO, *PBOWSER_CONFIG_INFO;

extern
BOWSER_CONFIG_INFO
BowserConfigEntries[];

//
//  Private boolean type used by redirector only.
//
//  Maps to REG_DWORD, with value != 0
//

#define REG_BOOLEAN (0xffffffff)
#define REG_BOOLEAN_SIZE (sizeof(DWORD))

//
//
//
//  Bowser Data variables
//
//
//

extern
ERESOURCE
BowserNameResource;

extern
UNICODE_STRING
BowserNameString;

extern
LIST_ENTRY
BowserNameHead;

extern
KSPIN_LOCK
BowserTimeSpinLock;

extern
KSPIN_LOCK
BowserMailslotSpinLock;

extern
PKEVENT
BowserServerAnnouncementEvent;

extern
struct _BOWSER_FS_DEVICE_OBJECT *
BowserDeviceObject;

extern
ERESOURCE
BowserDataResource;                     // Resource controlling Bowser data.

extern
BOWSERDATA
BowserData;                             // Structure protected by resource

extern ULONG BowserOperationCount;

#define BOWSER_DEFAULT_IRP_STACK_SIZE 4

extern
ULONG
BowserIrpStackSize;

extern
ULONG
BowserCurrentTime;

extern
LARGE_INTEGER
BowserStartTime;

extern
KSPIN_LOCK
BowserTransportMasterNameSpinLock;

extern
PEPROCESS
BowserFspProcess;

extern
LONG
BowserEventLogResetFrequency;

extern
LONG
BowserIllegalDatagramCount;

extern
BOOLEAN
BowserIllegalDatagramThreshold;

extern
LONG
BowserIllegalNameCount;

extern
BOOLEAN
BowserIllegalNameThreshold;

extern
BOOLEAN
BowserLogElectionPackets;

extern
BOWSER_STATISTICS
BowserStatistics;

extern
KSPIN_LOCK
BowserStatisticsLock;

extern
ULONG
BowserNumberOfMissedMailslotDatagrams;

extern
ULONG
BowserNumberOfMissedGetBrowserServerListRequests;


extern
ULONG
BowserMailslotDatagramThreshold;

extern
ULONG
BowserGetBrowserListThreshold;

extern
ULONG
BowserServerDeletionThreshold;

extern
ULONG
BowserDomainDeletionThreshold;

extern
ULONG
BowserFindMasterTimeout;

extern
ULONG
BowserMinimumConfiguredBrowsers;

extern
ULONG
BowserMaximumBrowseEntries;

extern
BOOLEAN
BowserRefuseReset;

extern
ULONG
BowserRandomSeed;

extern
LONG
BowserNumberOfOpenFiles;

#endif          // _BOWDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowelect.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowelect.h

Abstract:

    This module

Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BOWELECT_
#define _BOWELECT_

//
//  Timer values to respond to election requests.
//

#define MASTER_ELECTION_DELAY        100        // Master waits this long.
#define BACKUP_ELECTION_DELAY_MIN    200        // Backup waits at least this long
#define BACKUP_ELECTION_DELAY_MAX    600        // but no longer than this.
#define ELECTION_DELAY_MIN           800        // Others wait at least this long
#define ELECTION_DELAY_MAX          3000        // but no longer than this.
#define ELECTION_RESPONSE_MIN        200        // Election response delay.
#define ELECTION_RESPONSE_MAX        900        // Max electionresponse delay

#define ELECTION_RESEND_DELAY       1000        // Resend election at this interval

#define ELECTION_COUNT                 4        // We must win election this many times.
#define ELECTION_MAX                  30        // Don't send more than 30 election
                                                // responses in an election
#define ELECTION_EXEMPT_TIME    (ELECTION_DELAY_MAX + (ELECTION_RESEND_DELAY*ELECTION_COUNT)*2)

#define FIND_MASTER_WAIT        (ELECTION_DELAY_MAX + ELECTION_RESEND_DELAY*(ELECTION_COUNT+2))
#define FIND_MASTER_DELAY       1500            //  Retry find master delay.
#define FIND_MASTER_COUNT       6               //  Number of times to retry FM


#define TRANSPORT_BIND_TIME     3*1000          // Number of milliseconds to bind to transport.

//
//  The reasonable amount of time that it would take for an election.
//

#define ELECTION_TIME ((ELECTION_DELAY_MAX * ELECTION_COUNT) + TRANSPORT_BIND_TIME)

DATAGRAM_HANDLER(
    BowserHandleElection
    );

NTSTATUS
BowserSendElection(
    IN PUNICODE_STRING NameToSend,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport,
    IN BOOLEAN SendActualBrowserInfo
    );

NTSTATUS
GetMasterName (
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

//NTSTATUS
//BowserBackupFindMaster(
//    IN PTRANSPORT Transport,
//    IN PREQUEST_ELECTION_1 ElectionResponse,
//    IN ULONG BytesAvailable
//    );

NTSTATUS
BowserFindMaster(
    IN PTRANSPORT Transport
    );

VOID
BowserLoseElection(
    IN PTRANSPORT Transport
    );

#endif // _BOWELECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowbackp.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowbackp.c

Abstract:

    This module implements all of the backup browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION


typedef struct _BECOME_BACKUP_CONTEXT {
    WORK_QUEUE_ITEM WorkHeader;
    PTRANSPORT_NAME TransportName;
    PBECOME_BACKUP_1 BecomeBackupRequest;
    ULONG BytesAvailable;
} BECOME_BACKUP_CONTEXT, *PBECOME_BACKUP_CONTEXT;

VOID
BowserBecomeBackupWorker(
    IN PVOID WorkItem
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserBecomeBackupWorker)
#endif


DATAGRAM_HANDLER(
    BowserHandleBecomeBackup
    )
/*++

Routine Description:
    Indicate that a machine should become a backup browser server.

    This routine is called on receipt of a BecomeBackup frame.

Arguments:
    IN PTRANSPORT Transport - The transport for the net we're on.
    IN PUCHAR MasterName - The name of the new master browser server.

Return Value
    None.

--*/
{
    // PTA_NETBIOS_ADDRESS Address = SourceAddress;
    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                BowserBecomeBackupWorker,
                NonPagedPool,
                DelayedWorkQueue,
                ReceiveFlags,
                FALSE                               // No response will be sent
                );
}

VOID
BowserBecomeBackupWorker(
    IN PVOID WorkItem
    )

{
    PPOST_DATAGRAM_CONTEXT Context = WorkItem;
    PIRP Irp = NULL;
    PTRANSPORT Transport = Context->TransportName->Transport;
    UNICODE_STRING UPromoteeName;
    OEM_STRING APromoteeName;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PBECOME_BACKUP_1 BecomeBackupRequest = Context->Buffer;

    PAGED_CODE();

    UPromoteeName.Buffer = NULL;

    LOCK_TRANSPORT(Transport);

    try {
        NTSTATUS Status;

        //
        //  If this packet was smaller than a minimal packet,
        //      ignore the packet.
        //

        if (Context->BytesAvailable <= FIELD_OFFSET(BECOME_BACKUP_1, BrowserToPromote)) {
            try_return(NOTHING);
        }

        //
        // If the packet doesn't have a zero terminated BrowserToPromote,
        //  ignore the packet.
        //

        if ( !IsZeroTerminated(
                BecomeBackupRequest->BrowserToPromote,
                Context->BytesAvailable - FIELD_OFFSET(BECOME_BACKUP_1, BrowserToPromote) ) ) {
            try_return(NOTHING);
        }


        RtlInitAnsiString(&APromoteeName, BecomeBackupRequest->BrowserToPromote);

        Status = RtlOemStringToUnicodeString(&UPromoteeName, &APromoteeName, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, APromoteeName.Buffer, APromoteeName.Length );
            try_return(NOTHING);
        }

        if (RtlEqualUnicodeString(&UPromoteeName, &Transport->DomainInfo->DomUnicodeComputerName, TRUE)) {

            if (PagedTransport->Role == Master) {

                BowserWriteErrorLogEntry(EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER,
                                        STATUS_UNSUCCESSFUL,
                                        NULL,
                                        0,
                                        0);

                try_return(NOTHING);

            }


            //
            //  Ignore become backup requests on point-to-point (RAS) links and
            //      transports which are actually duplicates of others.
            //

            if (PagedTransport->DisabledTransport) {
                try_return(NOTHING);
            }

            //
            //  Complete any the first become backup request outstanding against this
            //  workstation.
            //

            Irp = BowserDequeueQueuedIrp(&Transport->BecomeBackupQueue);

            if (Irp != NULL) {
                Irp->IoStatus.Information = 0;

                BowserCompleteRequest(Irp, STATUS_SUCCESS);
            }
        }


try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        if (UPromoteeName.Buffer != NULL) {
            RtlFreeUnicodeString(&UPromoteeName);
        }

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

    }

}

VOID
BowserResetStateForTransport(
    IN PTRANSPORT Transport,
    IN UCHAR NewState
    )
{
    PIRP Irp = NULL;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    //
    //  Complete a reset state IRP outstanding on this transport.
    //

    Irp = BowserDequeueQueuedIrp(&Transport->ChangeRoleQueue);

    if (Irp != NULL) {
        PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            RequestPacket->Parameters.ChangeRole.RoleModification = NewState;

            Irp->IoStatus.Information = sizeof(LMDR_REQUEST_PACKET);

            Status = STATUS_SUCCESS;
        }

        BowserCompleteRequest(Irp, Status);
    }

}

DATAGRAM_HANDLER(
    BowserResetState
    )
{
    PTRANSPORT Transport = TransportName->Transport;
    UCHAR NewState = (UCHAR)((PRESET_STATE_1)(Buffer))->Options;

    if (!BowserRefuseReset) {
        BowserResetStateForTransport(Transport, NewState);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowelect.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowelect.c

Abstract:

    This module implements all of the election related routines for the NT
    browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION


NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    );

LONG
BowserSetElectionCriteria(
    IN PPAGED_TRANSPORT Transport
    );

NTSTATUS
BowserElectMaster(
    IN PTRANSPORT Transport
    );

VOID
HandleElectionWorker(
    IN PVOID Ctx
    );


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, GetMasterName)
#pragma alloc_text(PAGE, HandleElectionWorker)
#pragma alloc_text(PAGE, BowserSetElectionCriteria)
#pragma alloc_text(PAGE, BowserStartElection)
#pragma alloc_text(PAGE, BowserElectMaster)
#pragma alloc_text(PAGE, BowserLoseElection)
#pragma alloc_text(PAGE, BowserFindMaster)
#pragma alloc_text(PAGE, BowserSendElection)
#endif


NTSTATUS
GetMasterName (
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS           Status;
    PTRANSPORT         Transport       = NULL;
    PPAGED_TRANSPORT   PagedTransport;
    PIO_STACK_LOCATION IrpSp           = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name)+3*sizeof(WCHAR)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from GetMasterName.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        dlog(DPRT_FSCTL,
             ("%s: %ws: NtDeviceIoControlFile: GetMasterName\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        PagedTransport->ElectionCount = ELECTION_COUNT;

        Status = BowserQueueNonBufferRequest(Irp,
                                         &Transport->FindMasterQueue,
                                         BowserCancelQueuedRequest
                                         );
        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        Status = BowserFindMaster(Transport);

        //
        //  If we couldn't initiate the find master process, complete all the
        //  queued find master requests.
        //

        if (!NT_SUCCESS(Status)) {
            BowserCompleteFindMasterRequests(Transport, &PagedTransport->MasterName, Status);
        }

        //
        //  Since we marked the IRP as pending, we need to return pending
        //  now.
        //

        try_return(Status = STATUS_PENDING);


try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return(Status);

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);

}


DATAGRAM_HANDLER(BowserHandleElection)
{
    // PTA_NETBIOS_ADDRESS Address = SourceAddress;

    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                HandleElectionWorker,
                NonPagedPool,
                CriticalWorkQueue,
                ReceiveFlags,
                FALSE                       // Response will be sent, but...
                );

}

VOID
HandleElectionWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PTRANSPORT_NAME TransportName = Context->TransportName;
    PREQUEST_ELECTION_1 ElectionResponse = Context->Buffer;
    ULONG BytesAvailable = Context->BytesAvailable;
    ULONG TimeUp;
    BOOLEAN Winner;
    PTRANSPORT Transport = TransportName->Transport;
    NTSTATUS Status;
    LONG ElectionDelay, NextElection;
    OEM_STRING ClientNameO;
    UNICODE_STRING ClientName;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    ClientName.Buffer = NULL;

    try {

        //
        //  If this packet was smaller than a minimal packet,
        //      ignore the packet.
        //

        if (BytesAvailable <= FIELD_OFFSET(REQUEST_ELECTION_1, ServerName)) {
            try_return(NOTHING);
        }

        //
        // If the packet doesn't have a zero terminated ServerName,
        //  ignore the packet.
        //

        if ( !IsZeroTerminated(
                ElectionResponse->ServerName,
                BytesAvailable - FIELD_OFFSET(REQUEST_ELECTION_1, ServerName) ) ) {
            try_return(NOTHING);
        }

        BowserStatistics.NumberOfElectionPackets += 1;

        //
        //  Remember the last time we heard an election packet.
        //

        PagedTransport->LastElectionSeen = BowserTimeUp();

        if (Transport->ElectionState == DeafToElections) {
            try_return(NOTHING);
        }

        //
        // If we've disable the transport for any reason,
        //  then we disregard all elections.
        //

        if (PagedTransport->DisabledTransport) {
            try_return(NOTHING);
        }

        //
        //  Convert the client name in the election packet to unicode so we can
        //  log it.
        //

        RtlInitString(&ClientNameO, ElectionResponse->ServerName);

        Status = RtlOemStringToUnicodeString(&ClientName, &ClientNameO, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, ClientNameO.Buffer, ClientNameO.Length );

            try_return(NOTHING);
        }

        if (BowserLogElectionPackets) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_RECEIVED, STATUS_SUCCESS, ElectionResponse, (USHORT)BytesAvailable, 2, ClientName.Buffer, PagedTransport->TransportName.Buffer);
        }

        dlog(DPRT_ELECT,
             ("%s: %ws: Received election packet from machine %s.  Version: %lx; Criteria: %lx; TimeUp: %lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             ElectionResponse->ServerName,
             ElectionResponse->Version,
             SmbGetUlong(&ElectionResponse->Criteria),
             SmbGetUlong(&ElectionResponse->TimeUp)));



        //
        //  Figure out our time up for the election compare.
        //
        //  If we're running an election, we'll use our advertised time, else
        //  we'll use our actual uptime. Also, if we're running an election
        //  we'll check to see if we sent this. If we're not running an election
        //  and we receive this, it's because the redirector didn't find a
        //  master, so we want to continue the election and become master.
        //

        if (Transport->ElectionState == RunningElection) {
            if (!strcmp(Transport->DomainInfo->DomOemComputerNameBuffer, ElectionResponse->ServerName)) {
                try_return(NOTHING);
            }

            //
            //  If this request was initiated from a client, ignore it.
            //
            if ((SmbGetUlong(&ElectionResponse->Criteria) == 0) &&
                (ElectionResponse->ServerName[0] == '\0')) {
                dlog(DPRT_ELECT,
                     ("%s: %ws: Dummy election request ignored during election.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));
                try_return(NOTHING);
            }

            if (PagedTransport->Role == Master) {
                ElectionDelay = BowserRandom(MASTER_ELECTION_DELAY);
            } else {
                ElectionDelay = ELECTION_RESPONSE_MIN + BowserRandom(ELECTION_RESPONSE_MAX-ELECTION_RESPONSE_MIN);
            }

        } else {

            //
            //  Starting a new election - set various election criteria
            //  including Uptime.
            //

            ElectionDelay = BowserSetElectionCriteria(PagedTransport);

        }

        TimeUp = PagedTransport->Uptime;

        if (ElectionResponse->Version != BROWSER_ELECTION_VERSION) {
            Winner = (ElectionResponse->Version < BROWSER_ELECTION_VERSION);
        } else if (SmbGetUlong(&ElectionResponse->Criteria) != PagedTransport->ElectionCriteria) {
            Winner = (SmbGetUlong(&ElectionResponse->Criteria) < PagedTransport->ElectionCriteria);
        } else if (TimeUp != SmbGetUlong(&ElectionResponse->TimeUp)) {
            Winner = TimeUp > SmbGetUlong(&ElectionResponse->TimeUp);
        } else {
            Winner = (strcmp(Transport->DomainInfo->DomOemDomainName, ElectionResponse->ServerName) <= 0);
        }

        //
        //  If we lost, we stop our timer and turn off our election flag, just
        //  in case we had an election or find master going. If we're a backup,
        //  we want to find out who the new master is, either from this election
        //  frame or waiting awhile and querying.
        //

        if (!Winner) {

            //
            //  Remember if we legitimately lost the last election, and if
            //  so, don't force an election if we see server announcements
            //  from a non DC, just give up.
            //

            PagedTransport->Flags |= ELECT_LOST_LAST_ELECTION;
        }

        if (!Winner || (PagedTransport->ElectionsSent > ELECTION_MAX)) {

            if (PagedTransport->IsPrimaryDomainController) {

                DWORD ElectionInformation[6];

                ElectionInformation[0] = ElectionResponse->Version;
                ElectionInformation[1] = SmbGetUlong(&ElectionResponse->Criteria);
                ElectionInformation[2] = SmbGetUlong(&ElectionResponse->TimeUp);
                ElectionInformation[3] = BROWSER_ELECTION_VERSION;
                ElectionInformation[4] = PagedTransport->ElectionCriteria;
                ElectionInformation[5] = TimeUp;

                //
                //  Write this information into the event log.
                //

                BowserWriteErrorLogEntry(EVENT_BOWSER_PDC_LOST_ELECTION,
                                            STATUS_SUCCESS,
                                            ElectionInformation,
                                            sizeof(ElectionInformation),
                                            2,
                                            ClientName.Buffer,
                                            PagedTransport->TransportName.Buffer);

                KdPrint(("HandleElectionWorker: Lose election, but we're the PDC.  Winner: Version: %lx; Criteria: %lx; Time Up: %lx; Name: %s\n",
                                ElectionResponse->Version,
                                SmbGetUlong(&ElectionResponse->Criteria),
                                SmbGetUlong(&ElectionResponse->TimeUp),
                                ElectionResponse->ServerName));

            }

            BowserLoseElection(Transport);

        } else {
            //
            //  We won this election, make sure that we don't think that we
            //  lost it.
            //

            PagedTransport->Flags &= ~ELECT_LOST_LAST_ELECTION;

            //
            //  If we won and we're not running an election, we'll start one.
            //  If we are running, we don't do anything because our timer will
            //  take care of it. If the NET_ELECTION flag is clear, we know
            //  timeup is approx. equal to time_up() because we set it above,
            //  so we'll use that. This algorithm includes a damping constant
            //  (we won't start an election  if we've just lost one in the
            //  last 1.5 seconds) to avoid election storms.
            //


            if (Transport->ElectionState != RunningElection) {

                //
                //  If we recently lost an election, then ignore the fact
                //  that we won, and pretend we lost this one.
                //

                if ((PagedTransport->TimeLastLost != 0) &&
                    ((BowserTimeUp() - PagedTransport->TimeLastLost) < ELECTION_EXEMPT_TIME)) {

                    dlog(DPRT_ELECT,
                         ("%s: %ws: Browser is exempt from election\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer ));

                    try_return(NOTHING);
                }

                dlog(DPRT_ELECT,
                     ("%s: %ws: Better criteria, calling elect_master in %ld milliseconds.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     ElectionDelay));

                //
                // Ensure the timer is running.
                //  We don't actually win the election until the timer expires.
                //

                Transport->ElectionState = RunningElection;

                PagedTransport->NextElection = 0;
            }

            PagedTransport->ElectionCount = ELECTION_COUNT;

            //
            //  Note: the next elect time must be computed into a signed
            //  integer in case the expiration time has already passed so
            //  don't try to optimize this code too much.
            //

            NextElection = PagedTransport->NextElection - (TimeUp - BowserTimeUp());

            if ((PagedTransport->NextElection == 0) || NextElection > ElectionDelay) {
                BowserStopTimer(&Transport->ElectionTimer);

                PagedTransport->NextElection = TimeUp + ElectionDelay;

                dlog(DPRT_ELECT,
                     ("%s: %ws: Calling ElectMaster in %ld milliseconds\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     ElectionDelay));

                BowserStartTimer(&Transport->ElectionTimer, ElectionDelay, BowserElectMaster, Transport);
            }
        }

try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);

        InterlockedDecrement( &BowserPostedCriticalDatagramCount );
        FREE_POOL(Context);

        if (ClientName.Buffer != NULL) {
            RtlFreeUnicodeString(&ClientName);
        }

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

LONG
BowserSetElectionCriteria(
    IN PPAGED_TRANSPORT PagedTransport
    )

/*++

Routine Description:
    Set election criteria for a network.

    Prepare for an election by setting Transport->ElectionCriteria based upon the local
    browser state.  Set Transport->Uptime to the current local up time.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    Number of milliseconds to delay before sending the election packet.

--*/
{
    LONG Delay;

    PAGED_CODE();

    PagedTransport->ElectionsSent = 0;   // clear bid counter
    PagedTransport->Uptime = BowserTimeUp();

    if (BowserData.IsLanmanNt) {
        PagedTransport->ElectionCriteria = ELECTION_CR_LM_NT;
    } else {
        PagedTransport->ElectionCriteria = ELECTION_CR_WIN_NT;
    }

    PagedTransport->ElectionCriteria |=
            ELECTION_MAKE_REV(BROWSER_VERSION_MAJOR, BROWSER_VERSION_MINOR);

    if (BowserData.MaintainServerList &&
            ((PagedTransport->NumberOfServersInTable +
             RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable)+
             RtlNumberGenericTableElements(&PagedTransport->DomainTable)) != 0)) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_CFG_BKP;
    }

    if (PagedTransport->IsPrimaryDomainController) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_PDC;
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_DOMMSTR;
    }

#ifdef ENABLE_PSEUDO_BROWSER
    if (BowserData.PseudoServerLevel == BROWSER_PSEUDO ||
        BowserData.PseudoServerLevel == BROWSER_SEMI_PSEUDO_NO_DMB ) {
        // Pseudo or Semi-Pseudo will win elections over peers
        // & in case of semi-pseudo except no DMB communications
        // all other functionality will remain on.
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_PSEUDO;
    }
#endif

    if (PagedTransport->Role == Master) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_MASTER;

        Delay = MASTER_ELECTION_DELAY;

    } else if (PagedTransport->IsPrimaryDomainController) {

        //
        //  If we are the PDC, we want to set our timeouts
        //  as if we were already the master.
        //
        //  This prevents us from getting into a situation where it takes
        //  more than ELECTION_DELAY_MAX to actually send out our response
        //  to an election.
        //

        Delay = MASTER_ELECTION_DELAY;

    } else if ((PagedTransport->Role == Backup) ||
               BowserData.IsLanmanNt) {
        //
        //  Likewise, if we are NTAS machines, we want to set out delay
        //  to match that of backup browsers (even if we're not a backup
        //  quite yet).
        //

        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_BACKUP;
        Delay = BACKUP_ELECTION_DELAY_MIN + BowserRandom(BACKUP_ELECTION_DELAY_MAX-BACKUP_ELECTION_DELAY_MIN);

    } else {
        Delay = ELECTION_DELAY_MIN + BowserRandom(ELECTION_DELAY_MAX-ELECTION_DELAY_MIN);
    }

    //
    // Assume for now that all wannish transports are running the WINS client.
    //
    if ( PagedTransport->Wannish ) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_WINS_CLIENT;
    }

    return Delay;
}

NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Initiate a browser election

    This routine is called when we are unable to find a master, and we want to
    elect one.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        // If we've disable the transport for any reason,
        //  then we disregard all elections.
        //

        if (PagedTransport->DisabledTransport) {
            try_return(Status = STATUS_UNSUCCESSFUL);
        }

        //
        // If we're deaf to elections, or aren't any kind of
        //  browser then we can't start elections either.
        //

        if (Transport->ElectionState == DeafToElections ||
            PagedTransport->Role == None) {
            try_return(Status = STATUS_UNSUCCESSFUL);
        }

        PagedTransport->ElectionCount = ELECTION_COUNT;

        Transport->ElectionState = RunningElection;

        BowserSetElectionCriteria(PagedTransport);

        Status = BowserElectMaster(Transport);
try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);

    }

    return Status;
}


NTSTATUS
BowserElectMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Elect a master browser server.

    This routine is called when we think there is no master and we need to
    elect one.  We check our retry count, and if it's non-zero we send an
    elect datagram to the group name. Otherwise we become the master ourselves.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/
{
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  If we're not running the election at this time, it means that
        //  between the time that we decided we were going to win the election
        //  and now, someone else announced with better criteria.  It is
        //  possible that this could happen if the announcement came in just
        //  before we ran (ie. if the announcement occured between when the
        //  timer DPC was queued and when the DPC actually fired).
        //

        if (Transport->ElectionState != RunningElection) {

            KdPrint(("BowserElectMaster: Lose election because we are no longer running the election\n"));

            BowserLoseElection(Transport);

        } else if (PagedTransport->ElectionCount != 0) {

            BowserStopTimer(&Transport->ElectionTimer);

            PagedTransport->ElectionCount -= 1;

            PagedTransport->ElectionsSent += 1;

            PagedTransport->NextElection = BowserTimeUp() + ELECTION_RESEND_DELAY;

            Status = BowserSendElection(&Transport->DomainInfo->DomUnicodeDomainName, BrowserElection, Transport, TRUE);

            // Lose the election if we can't send a datagram.
            if (!NT_SUCCESS(Status)) {
                BowserLoseElection(Transport);
                try_return(Status);
            }

            //
            //  If we were able to send the election,
            //  start the timer running.
            //

            BowserStartTimer(&Transport->ElectionTimer,
                    ELECTION_RESEND_DELAY,
                    BowserElectMaster,
                    Transport);


        } else {
            Transport->ElectionState = Idle;

            //
            //  If we're already the master we just return. This can happen if
            //  somebody starts an election (which we win) while we're already
            //  the master.
            //

            if (PagedTransport->Role != Master) {

                //
                //  We're the new master - we won!
                //

                BowserNewMaster(Transport, Transport->DomainInfo->DomOemComputerNameBuffer );

            } else {

                //
                // Were already the master. Make sure that all the backups
                // know this by sending an announcent
                //

                //
                //  This one's easy - simply set the servers announcement event to the
                //  signalled state.  If the server is running, this will force an
                //  announcement
                //

                KeSetEvent(BowserServerAnnouncementEvent, IO_NETWORK_INCREMENT, FALSE);
            }
        }

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}


VOID
BowserLoseElection(
    IN PTRANSPORT Transport
    )
{
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();


    LOCK_TRANSPORT(Transport);

    BowserStopTimer(&Transport->ElectionTimer);

    dlog(DPRT_ELECT,
        ("We lost the election\n",
        Transport->DomainInfo->DomOemDomainName,
        PagedTransport->TransportName.Buffer ));

    PagedTransport->TimeLastLost = BowserTimeUp();

    //
    //  We lost the election - we re-enter the idle state.
    //

    Transport->ElectionState = Idle;

    if (PagedTransport->Role == Master) {

        //
        //  If we lost, and we are currently a master, then tickle
        //  the browser service and stop being a master.
        //

        BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);

        //
        //  Remove all the entries on the server list for this
        //  transport.
        //

        LOCK_ANNOUNCE_DATABASE(Transport);

        //
        //  Flag that there should be no more announcements received on
        //  this name.
        //

        BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

//        KdPrint(("Deleting entire table on transport %wZ because we lost the election\n", &Transport->TransportName));

        BowserDeleteGenericTable(&PagedTransport->AnnouncementTable);

        BowserDeleteGenericTable(&PagedTransport->DomainTable);

        UNLOCK_ANNOUNCE_DATABASE(Transport);

#if 0
    } else if (Transport->Role == Backup) { // If we're a backup, find master
        dlog(DPRT_ELECT, ("We're a backup - Find the new master\n"));

        //
        //  If this guy is not the master, then we want to
        //  find a master at some later time.
        //

        Transport->ElectionCount = FIND_MASTER_COUNT;
        Transport->Uptime = Transport->TimeLastLost;
        BowserStopTimer(&Transport->FindMasterTimer);
        BowserStartTimer(&Transport->FindMasterTimer,
                                    FIND_MASTER_WAIT-(FIND_MASTER_WAIT/8)+ BowserRandom(FIND_MASTER_WAIT/4),
                                    BowserFindMaster,
                                    Transport);
#endif

    }

    UNLOCK_TRANSPORT(Transport);

}

NTSTATUS
BowserFindMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Find the master browser server.

    This routine attempts to find the master browser server by
    sending a request announcement message to the master. If no response is
    heard after a while, we assume the master isn't present and run and
    election.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/

{
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  If our count hasn't gone to 0 yet, we'll send a find master PDU.
        //

        if (PagedTransport->ElectionCount != 0) {

            PagedTransport->ElectionCount -= 1;       // Update count, and set timer

            BowserStopTimer(&Transport->FindMasterTimer);

            Status = BowserSendRequestAnnouncement(
                            &Transport->DomainInfo->DomUnicodeDomainName,
                            MasterBrowser,
                            Transport);

            if (NT_SUCCESS(Status) ||
                Status == STATUS_BAD_NETWORK_PATH) {
                //
                // We will retry on the following cases:
                //  - netbt returns success. Meaning I'll be looking for it.
                //  - nwlnknb returns STATUS_BAD_NETWORK_PATH meaning I can't find it.
                // In either case, we would try for ElectionCount times & then move
                // fwd to initiate elections. Otherwise we may end up in a state where because
                // we didn't find a master browser, we won't attempt to elect one & we'll fail
                // to become one. This will result w/ a domain w/ no master browser.
                //
                BowserStartTimer(&Transport->FindMasterTimer,
                        FIND_MASTER_DELAY,
                        BowserFindMaster,
                        Transport);
            } else {
                try_return(Status);
            }

        } else {
            ULONG CurrentTime;
            LONG TimeTilNextElection;

            //
            //  Count has expired, so we'll try to elect a new master.
            //

            dlog(DPRT_ELECT,
                 ("%s: %ws: Find_Master: Master not found, forcing election.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            if (BowserLogElectionPackets) {
                BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED, STATUS_SUCCESS, NULL, 0, 1, PagedTransport->TransportName.Buffer);
            }

            //
            //  If it's been more than a reasonable of time since the last
            //  election, force a new election, otherwise set a timer to
            //  start an election after a reasonable amount of time.
            //
            //
            //  Calculate the time until the next election only once
            //  since it is possible that we might cross over the ELECTION_TIME
            //  threshold while performing these checks.
            //

            CurrentTime = BowserTimeUp();
            if   ( CurrentTime >= PagedTransport->LastElectionSeen) {
                TimeTilNextElection = (ELECTION_TIME - (CurrentTime - PagedTransport->LastElectionSeen));
            } else {
                TimeTilNextElection = ELECTION_TIME;
            }

            if ( TimeTilNextElection <= 0 ) {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Last election long enough ago, forcing election\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                Status = BowserStartElection(Transport);

                //
                //  If we couldn't start the election, complete the find
                //  master requests with the appropriate error.
                //

                if (!NT_SUCCESS(Status)) {

                    //
                    //  Complete the requests with the current master name - it's
                    //  as good as anyone.
                    //

                    BowserCompleteFindMasterRequests(Transport, &PagedTransport->MasterName, Status);
                }

            } else {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Last election too recent, delay %ld before forcing election\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     TimeTilNextElection ));

                BowserStartTimer(&Transport->FindMasterTimer,
                     TimeTilNextElection,
                     BowserStartElection,
                     Transport);
            }


        }

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}


NTSTATUS
BowserSendElection(
    IN PUNICODE_STRING NameToSend OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport,
    IN BOOLEAN SendActualBrowserInfo
    )
{
    UCHAR Buffer[sizeof(REQUEST_ELECTION)+LM20_CNLEN+1];
    PREQUEST_ELECTION ElectionRequest = (PREQUEST_ELECTION) Buffer;
    ULONG ComputerNameSize;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    ElectionRequest->Type = Election;

    //
    // If this transport is disabled,
    //  don't send any election packets.
    //

    if ( PagedTransport->DisabledTransport ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  If we are supposed to send the actual browser info, and we are
    //  running the browser send a real election packet, otherwise we
    //  just want to send a dummy packet.
    //

    if (SendActualBrowserInfo &&
        (PagedTransport->ServiceStatus & (SV_TYPE_POTENTIAL_BROWSER | SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER))) {
        dlog(DPRT_ELECT,
             ("%s: %ws: Send true election.\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        //
        //  If this request comes as a part of an election, we want to send
        //  the accurate browser information.
        //

        ElectionRequest->ElectionRequest.Version = BROWSER_ELECTION_VERSION;

        ElectionRequest->ElectionRequest.TimeUp = PagedTransport->Uptime;

        ElectionRequest->ElectionRequest.Criteria = PagedTransport->ElectionCriteria;

        ElectionRequest->ElectionRequest.MustBeZero = 0;

        ComputerNameSize = Transport->DomainInfo->DomOemComputerName.Length;
        strcpy( ElectionRequest->ElectionRequest.ServerName,
                Transport->DomainInfo->DomOemComputerName.Buffer );

    } else {
        dlog(DPRT_ELECT,
             ("%s: %ws: Send dummy election.\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        //
        //  If we are forcing the election because we can't get a backup list,
        //  send only dummy information.
        //

        ElectionRequest->ElectionRequest.Version = 0;
        ElectionRequest->ElectionRequest.Criteria = 0;
        ElectionRequest->ElectionRequest.TimeUp = 0;
        ElectionRequest->ElectionRequest.ServerName[0] = '\0';
        ElectionRequest->ElectionRequest.MustBeZero = 0;
        ComputerNameSize = 0;
    }

    return BowserSendSecondClassMailslot(Transport,
                                NameToSend,
                                NameType,
                                ElectionRequest,
                                FIELD_OFFSET(REQUEST_ELECTION, ElectionRequest.ServerName)+ComputerNameSize+sizeof(UCHAR),
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL
                                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\announce.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    announce.c

Abstract:

    This module implements the routines needed to manage the bowser's
announcement table.


Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#include "precomp.h"
#pragma hdrstop


//
//  List containing the chain of server announcement buffers.  These structures
//  are allocated out of paged pool and are used to while transfering the
//  contents of the server announcement from the datagram reception indication
//  routine to the Bowser's FSP where they will be added to the announcement
//  database.
//

LIST_ENTRY
BowserViewBufferHead = {0};

KSPIN_LOCK
BowserViewBufferListSpinLock = {0};

LONG
BowserNumberOfServerAnnounceBuffers = {0};

BOOLEAN
PackServerAnnouncement (
    IN ULONG Level,
    IN ULONG ServerTypeMask,
    IN OUT LPTSTR *BufferStart,
    IN OUT LPTSTR *BufferEnd,
    IN ULONG_PTR BufferDisplacment,
    IN PANNOUNCE_ENTRY Announcement,
    OUT PULONG TotalBytesNeeded
    );


NTSTATUS
AgeServerAnnouncements(
    PTRANSPORT Transport,
    PVOID Context
    );

VOID
BowserPromoteToBackup(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    );

VOID
BowserShutdownRemoteBrowser(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    );

typedef struct _ENUM_SERVERS_CONTEXT {
    ULONG Level;
    PLUID LogonId;
    ULONG ServerTypeMask;
    PUNICODE_STRING DomainName OPTIONAL;
    PVOID OutputBuffer;
    PVOID OutputBufferEnd;
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
    ULONG ResumeKey;
    ULONG OriginalResumeKey;
} ENUM_SERVERS_CONTEXT, *PENUM_SERVERS_CONTEXT;

NTSTATUS
EnumerateServersWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserCompareAnnouncement)
#pragma alloc_text(PAGE, BowserAllocateAnnouncement)
#pragma alloc_text(PAGE, BowserFreeAnnouncement)
#pragma alloc_text(PAGE, BowserProcessHostAnnouncement)
#pragma alloc_text(PAGE, BowserProcessDomainAnnouncement)
#pragma alloc_text(PAGE, BowserAgeServerAnnouncements)
#pragma alloc_text(PAGE, AgeServerAnnouncements)
#pragma alloc_text(PAGE, BowserPromoteToBackup)
#pragma alloc_text(PAGE, BowserShutdownRemoteBrowser)
#pragma alloc_text(PAGE, BowserEnumerateServers)
#pragma alloc_text(PAGE, EnumerateServersWorker)
#pragma alloc_text(PAGE, PackServerAnnouncement)
#pragma alloc_text(PAGE, BowserDeleteGenericTable)
#pragma alloc_text(PAGE, BowserpInitializeAnnounceTable)
#pragma alloc_text(PAGE, BowserpUninitializeAnnounceTable)
#pragma alloc_text(PAGE4BROW, BowserFreeViewBuffer)
#pragma alloc_text(PAGE4BROW, BowserAllocateViewBuffer)
#pragma alloc_text(PAGE4BROW, BowserHandleServerAnnouncement)
#pragma alloc_text(PAGE4BROW, BowserHandleDomainAnnouncement)
#endif


INLINE
ULONG
BowserSafeStrlen(
    IN PSZ String,
    IN ULONG MaximumStringLength
    )
{
    ULONG Length = 0;

    while (MaximumStringLength-- && *String++) {
        Length += 1;
    }

    return Length;
}

DATAGRAM_HANDLER(
    BowserHandleServerAnnouncement
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable     - number of bytes in complete Tsdu
    IN PHOST_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken       - number of bytes used
    IN UCHAR Opcode             - the mailslot write opcode.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;
    ULONG HostNameLength                     = 0;
    ULONG CommentLength                      = 0;
    ULONG NameCommentMaxLength               = 0;
    PHOST_ANNOUNCE_PACKET_1 HostAnnouncement = Buffer;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfServerAnnouncements, 1);

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if ((TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == BrowserElection)) {
        ULONG ServerElectionVersion;
        //
        //  If this server announcement is sent to the master name, then
        //  it is a BROWSE_ANNOUNCE packet, not a HOST_ANNOUNCE (ie, it's an
        //  NT/WinBALL server, not a Lan Manager server.
        //
        //  We need to grovel the bits out of the packet in an appropriate
        //  manner.
        //

        PBROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement = (PBROWSE_ANNOUNCE_PACKET_1)HostAnnouncement;

        //
        //  If this packet was smaller than a minimal server announcement,
        //  ignore the request, it cannot be a legal request.
        //

        if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {

            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  This is a Lan Manager style server announcement.
        //

#if DBG
        ViewBuffer->ServerType = 0xffffffff;
#endif

        //
        //  Verify that this announcement is not going to blow away the view
        // buffer.
        //

        HostNameLength = BowserSafeStrlen(BROWSE_ANNC_NAME(BrowseAnnouncement),
                                        BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName));
        if (HostNameLength > NETBIOS_NAME_LEN-1) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        if (BowserSafeStrlen(BROWSE_ANNC_COMMENT(BrowseAnnouncement),
                BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) > LM20_MAXCOMMENTSZ) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        strncpy(ViewBuffer->ServerName, BROWSE_ANNC_NAME(BrowseAnnouncement),
                min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName),
                    NETBIOS_NAME_LEN));

        ViewBuffer->ServerName[NETBIOS_NAME_LEN] = '\0';

        strncpy(ViewBuffer->ServerComment, BROWSE_ANNC_COMMENT(BrowseAnnouncement),
                min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment), LM20_MAXCOMMENTSZ));

        ViewBuffer->ServerComment[LM20_MAXCOMMENTSZ] = '\0';

        ServerElectionVersion = SmbGetUlong(&BrowseAnnouncement->CommentPointer);

        //
        //  Save away the election version of this server.
        //

        if ((ServerElectionVersion >> 16) == 0xaa55) {
            ViewBuffer->ServerBrowserVersion = (USHORT)(ServerElectionVersion & 0xffff);
        } else {
            if (!(BrowseAnnouncement->Type & SV_TYPE_NT)) {
                ViewBuffer->ServerBrowserVersion = (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR;
            } else {
                ViewBuffer->ServerBrowserVersion = 0;
            }
        }

        ViewBuffer->ServerType = SmbGetUlong(&BrowseAnnouncement->Type);

        dprintf(DPRT_ANNOUNCE, ("Received announcement from %s on transport %lx.  Server type: %lx\n", ViewBuffer->ServerName, TransportName->Transport, ViewBuffer->ServerType));

        ViewBuffer->ServerVersionMajor = BrowseAnnouncement->VersionMajor;

        ViewBuffer->ServerVersionMinor = BrowseAnnouncement->VersionMinor;

        ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&BrowseAnnouncement->Periodicity) + 999) / 1000);

    } else {

        //
        //  If this packet was smaller than a minimal server announcement,
        //  ignore the request, it cannot be a legal request.
        //

        if (BytesAvailable < FIELD_OFFSET(HOST_ANNOUNCE_PACKET_1, NameComment)) {

            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  This is a Lan Manager style server announcement.
        //

#if DBG
        ViewBuffer->ServerType = 0xffffffff;
#endif

        //
        //  Verify that this announcement is not going to blow away the view
        // buffer.
        //

        NameCommentMaxLength = BytesAvailable - FIELD_OFFSET(HOST_ANNOUNCE_PACKET_1, NameComment);

        HostNameLength = BowserSafeStrlen(HOST_ANNC_NAME(HostAnnouncement),
                                          NameCommentMaxLength);

        if (HostNameLength > NETBIOS_NAME_LEN) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  We need to make sure that the hostname string was properly terminated
        //     before using HOST_ANNC_COMMENT (which calls strlen on the hostname string).
        //     The BowserSafeStrlen call above may have been terminated by the end of the
        //     input buffer.  If the length was terminated by the end of the buffer, the
        //     conditional below will fail.
        //

        if (HostNameLength < NameCommentMaxLength) {
            CommentLength = BowserSafeStrlen(HOST_ANNC_COMMENT(HostAnnouncement),
                                             NameCommentMaxLength - HostNameLength - 1);

            if (CommentLength > LM20_MAXCOMMENTSZ) {
                BowserFreeViewBuffer(ViewBuffer);

                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }

        if (HostNameLength) {
            RtlCopyMemory(ViewBuffer->ServerName,HOST_ANNC_NAME(HostAnnouncement),HostNameLength);
        }
        ViewBuffer->ServerName[HostNameLength] = '\0';
        if (CommentLength) {
            RtlCopyMemory(ViewBuffer->ServerComment,HOST_ANNC_COMMENT(HostAnnouncement),CommentLength);
        }
        ViewBuffer->ServerComment[CommentLength] = '\0';

        ViewBuffer->ServerBrowserVersion = (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR;

        ViewBuffer->ServerType = SmbGetUlong(&HostAnnouncement->Type);

        dprintf(DPRT_ANNOUNCE, ("Received announcement from %s on transport %lx.  Server type: %lx\n", ViewBuffer->ServerName, TransportName->Transport, ViewBuffer->ServerType));

        ViewBuffer->ServerVersionMajor = HostAnnouncement->VersionMajor;

        ViewBuffer->ServerVersionMinor = HostAnnouncement->VersionMinor;

        ViewBuffer->ServerPeriodicity = SmbGetUshort(&HostAnnouncement->Periodicity);

    }
    ViewBuffer->TransportName = TransportName;

    BowserReferenceTransportName(TransportName);
    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserHandlerServerAnnouncement.\n", TransportName->Transport));
    BowserReferenceTransport( TransportName->Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessHostAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    *BytesTaken = BytesAvailable;

    return STATUS_SUCCESS;
}

DATAGRAM_HANDLER(
    BowserHandleDomainAnnouncement
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable,    - number of bytes in complete Tsdu
    IN PBROWSE_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken,      - number of bytes used


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;
    PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement = Buffer;
    ULONG HostNameLength;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    //
    //  If we are not processing host announcements for this
    //  name, ignore this request.
    //

    if (!TransportName->ProcessHostAnnouncements) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfDomainAnnouncements, 1);

    //
    //  If this packet was smaller than a minimal server announcement,
    //  ignore the request, it cannot be a legal request.
    //

    if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    //  Verify that this announcement is not going to blow away the view
    // buffer.
    //

    HostNameLength = BowserSafeStrlen(BROWSE_ANNC_NAME(DomainAnnouncement),
             BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName));

    if (HostNameLength > NETBIOS_NAME_LEN) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

#if DBG
    ViewBuffer->ServerType = 0xffffffff;
#endif

    strncpy(ViewBuffer->ServerName, BROWSE_ANNC_NAME(DomainAnnouncement),
            min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName),
                NETBIOS_NAME_LEN));

    ViewBuffer->ServerName[CNLEN] = '\0';

    //
    //  The comment on a server announcement is the computer name.
    //

//    ASSERT (strlen(BROWSE_ANNC_COMMENT(DomainAnnouncement)) <= CNLEN);

    strncpy(ViewBuffer->ServerComment, BROWSE_ANNC_COMMENT(DomainAnnouncement),
            min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment),
            CNLEN));

    //
    //  Force a null termination at the appropriate time.
    //

    ViewBuffer->ServerComment[CNLEN] = '\0';

    ViewBuffer->TransportName = TransportName;

    if (SmbGetUlong(&DomainAnnouncement->Type) & SV_TYPE_DOMAIN_ENUM) {
        ViewBuffer->ServerType = SmbGetUlong(&DomainAnnouncement->Type);
    } else {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM;
    }

    ViewBuffer->ServerVersionMajor = DomainAnnouncement->VersionMajor;

    ViewBuffer->ServerVersionMinor = DomainAnnouncement->VersionMinor;

    ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&DomainAnnouncement->Periodicity) + 999) / 1000);

    BowserReferenceTransportName(TransportName);
    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserHandlerDomainAnnouncement.\n", TransportName->Transport));
    BowserReferenceTransport( TransportName->Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessDomainAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    *BytesTaken = BytesAvailable;

    return STATUS_SUCCESS;
}


RTL_GENERIC_COMPARE_RESULTS
BowserCompareAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
/*++

Routine Description:

    This routine will compare two server announcements to see how they compare

Arguments:

    IN PRTL_GENERIC_TABLE - Supplies the table containing the announcements
    IN PVOID FirstStuct - The first structure to compare.
    IN PVOID SecondStruct - The second structure to compare.

Return Value:

    Result of the comparison.

--*/
{
    UNICODE_STRING ServerName1, ServerName2;
    PANNOUNCE_ENTRY Server1 = FirstStruct;
    PANNOUNCE_ENTRY Server2 = SecondStruct;
    LONG CompareResult;

    PAGED_CODE();

    RtlInitUnicodeString(&ServerName1, Server1->ServerName);

    RtlInitUnicodeString(&ServerName2, Server2->ServerName);

    CompareResult = RtlCompareUnicodeString(&ServerName1, &ServerName2, FALSE);

    if (CompareResult < 0) {
        return GenericLessThan;
    } else if (CompareResult > 0) {
        return GenericGreaterThan;
    } else {
        return GenericEqual;
    }

    UNREFERENCED_PARAMETER(Table);

}

PVOID
BowserAllocateAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    )
/*++

Routine Description:

    This routine will allocate space to hold an entry in a generic table.

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN CLONG ByteSize - Supplies the number of bytes to allocate for the entry.


Return Value:

    None.

--*/
{
    PAGED_CODE();
    return ALLOCATE_POOL(PagedPool, ByteSize, POOL_ANNOUNCEMENT);
    UNREFERENCED_PARAMETER(Table);
}

VOID
BowserFreeAnnouncement (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine will free an entry in a generic table that is too old.

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN PVOID Buffer - Supplies the buffer to free.



Return Value:

    None.

--*/
{
    PAGED_CODE();

    FREE_POOL(Buffer);
    UNREFERENCED_PARAMETER(Table);
}

INLINE
BOOLEAN
BowserIsLegalBackupBrowser(
    IN PANNOUNCE_ENTRY Announcement,
    IN PUNICODE_STRING ComputerName
    )
{
    //
    //  If we received this announcement on an "otherdomain", we will ignore
    //  it.
    //

    if (Announcement->Name->NameType == OtherDomain) {
        return FALSE;
    }

    //
    //  If the server doesn't indicate that it's a legal backup browser, we
    //  want to ignore it.
    //

    if (!FlagOn(Announcement->ServerType, SV_TYPE_BACKUP_BROWSER)) {
        return FALSE;
    }

    //
    //  If the server is the master browser, then we want to ignore it.
    //

    if (FlagOn(Announcement->ServerType, SV_TYPE_MASTER_BROWSER)) {
        return FALSE;
    }

    //
    //  If the server is too old, we want to ignore it.
    //

    if (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR) {
        return FALSE;
    }

    //
    //  If the machine we're looking at is the current machine, then it cannot
    //  be a legal backup - it must be a stale announcement sent before we
    //  actually became the master.
    //

    if (RtlCompareMemory(Announcement->ServerName,
                         ComputerName->Buffer,
                         ComputerName->Length) == ComputerName->Length) {
        return FALSE;
    }

    return TRUE;
}

VOID
BowserProcessHostAnnouncement(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will put a server announcement into the server announcement
    table

Arguments:

    IN PWORK_HEADER Header - Supplies a pointer to a work header in a view buffer

Return Value:

    None.

--*/
{
    PVIEW_BUFFER ViewBuffer = Context;
    ANNOUNCE_ENTRY ProtoEntry;
    UNICODE_STRING TempUString;
    OEM_STRING TempAString;
    PANNOUNCE_ENTRY Announcement;
    BOOLEAN NewElement = FALSE;
    ULONG Periodicity;
    ULONG ExpirationTime;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport;
    PTRANSPORT_NAME TransportName = ViewBuffer->TransportName;
    PTRANSPORT Transport = TransportName->Transport;

    PAGED_CODE();
//    DbgBreakPoint();

    ASSERT (ViewBuffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    //
    //  If we're not a master browser on this transport, don't process the
    //  announcement.
    //  Or no-op for black hole server
    //

#ifdef ENABLE_PSEUDO_BROWSER
    ASSERT( BowserData.PseudoServerLevel != BROWSER_PSEUDO );
#endif

    if (Transport->PagedTransport->Role != Master) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the computername to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerName;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerName);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerName);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, TempAString.Buffer, TempAString.Length );

        BowserFreeViewBuffer(ViewBuffer);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);

        return;
    }

    //
    //  Convert the comment to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerComment;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerComment);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerComment);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, TempAString.Buffer, TempAString.Length );

        BowserFreeViewBuffer(ViewBuffer);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    ProtoEntry.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;

    ProtoEntry.Size = sizeof(ProtoEntry) -
                      sizeof(ProtoEntry.ServerComment) +
                      TempUString.Length + sizeof(WCHAR);

    ProtoEntry.ServerType = ViewBuffer->ServerType;

    ProtoEntry.ServerVersionMajor = ViewBuffer->ServerVersionMajor;

    ProtoEntry.ServerVersionMinor = ViewBuffer->ServerVersionMinor;

    ProtoEntry.Name = ViewBuffer->TransportName->PagedTransportName->Name;

    //
    //  Initialize the forward and backward link to NULL.
    //

    ProtoEntry.BackupLink.Flink = NULL;

    ProtoEntry.BackupLink.Blink = NULL;

    ProtoEntry.ServerPeriodicity = ViewBuffer->ServerPeriodicity;

    ProtoEntry.Flags = 0;

    ProtoEntry.ServerBrowserVersion = ViewBuffer->ServerBrowserVersion;


    PagedTransport = Transport->PagedTransport;

    //
    //  We're done with the view buffer, now free it.
    //

    BowserFreeViewBuffer(ViewBuffer);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        //
        //  If this guy isn't a server, then we're supposed to remove this
        //  guy from our list of servers.  We do this because the server (NT,
        //  WfW, and OS/2) will issue a dummy announcement with the
        //  appropriate bit turned off when they stop.
        //

        if (!FlagOn(ProtoEntry.ServerType, SV_TYPE_SERVER)) {

            //
            //  Look up this entry in the table.
            //

            Announcement = RtlLookupElementGenericTable(&PagedTransport->AnnouncementTable, &ProtoEntry);

            //
            //  The entry wasn't found, so just return, we got rid of it
            //  some other way (maybe from a timeout scan, etc).
            //

            if (Announcement == NULL) {
                try_return(NOTHING);
            }

            //
            //  If this element is on the backup list, remove it from the
            //  backup list.
            //

            if (Announcement->BackupLink.Flink != NULL) {
                ASSERT (Announcement->BackupLink.Blink != NULL);

                RemoveEntryList(&Announcement->BackupLink);

                PagedTransport->NumberOfBackupServerListEntries -= 1;

                Announcement->BackupLink.Flink = NULL;

                Announcement->BackupLink.Blink = NULL;
            }

            //
            //  Now delete the element from the announcement table.
            //

            BowserDereferenceName( Announcement->Name );
            if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
            }

            try_return(NOTHING);
        }

        Announcement = RtlInsertElementGenericTable(&PagedTransport->AnnouncementTable,
                            &ProtoEntry, ProtoEntry.Size, &NewElement);

        if (Announcement == NULL) {
            //
            //  We couldn't allocate pool for this announcement.  Skip it.
            //

            BowserStatistics.NumberOfMissedServerAnnouncements += 1;
            try_return(NOTHING);

        }

        // Indicate the name is referenced by the announce entry we just inserted.
        BowserReferenceName( ProtoEntry.Name );

        if (!NewElement) {

            ULONG NumberOfPromotionAttempts = Announcement->NumberOfPromotionAttempts;

            //
            //  If this announcement was a backup browser, remove it from the
            //  list of backup browsers.
            //

            if (Announcement->BackupLink.Flink != NULL) {
                ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

                ASSERT (Announcement->BackupLink.Blink != NULL);

                RemoveEntryList(&Announcement->BackupLink);

                PagedTransport->NumberOfBackupServerListEntries -= 1;

                Announcement->BackupLink.Flink = NULL;

                Announcement->BackupLink.Blink = NULL;

            }

            //
            //  If this is not a new announcement, copy the announcement entry
            //  with the new information.
            //

            // The Previous entry no longer references the name
            BowserDereferenceName( Announcement->Name );
            if ( Announcement->Size >= ProtoEntry.Size ) {
                CSHORT TempSize;
                TempSize = Announcement->Size;
                RtlCopyMemory( Announcement, &ProtoEntry, ProtoEntry.Size );
                Announcement->Size = TempSize;
            } else {
                if (!RtlDeleteElementGenericTable(
                                        &PagedTransport->AnnouncementTable,
                                        Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                } else {
                    Announcement = RtlInsertElementGenericTable(
                                        &PagedTransport->AnnouncementTable,
                                        &ProtoEntry,
                                        ProtoEntry.Size,
                                        &NewElement);

                    if (Announcement == NULL) {
                        BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                        try_return(NOTHING);
                    }
                    ASSERT( NewElement );
                }
            }

            if (ProtoEntry.ServerType & SV_TYPE_BACKUP_BROWSER) {
                Announcement->NumberOfPromotionAttempts = 0;
            } else {
                Announcement->NumberOfPromotionAttempts = NumberOfPromotionAttempts;
            }

        } else {

            //
            //  This is a new entry.  Initialize the number of promotion
            //  attempts to 0.
            //

            Announcement->NumberOfPromotionAttempts = 0;

            dlog( DPRT_MASTER,
                  ("%s: %ws: New server: %ws.  Periodicity: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));


            //
            // If there are too many entries,
            //  ditch this one.
            //

            if ( RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) > BowserMaximumBrowseEntries ) {

                dlog( DPRT_MASTER,
                      ("%s: %ws: New server (Deleted because too many): %ws.  Periodicity: %ld\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer,
                      Announcement->ServerName,
                      Announcement->ServerPeriodicity));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                }

                //
                // Chaulk it up as a missed announcement
                //
                BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                try_return(NOTHING);
            }
        }

        //
        //  If this new server is a legal backup browser (but not a master
        //  browser, link it into the announcement database).
        //
        //

        ASSERT (Announcement->BackupLink.Flink == NULL);
        ASSERT (Announcement->BackupLink.Blink == NULL);

        if (BowserIsLegalBackupBrowser(Announcement, &Transport->DomainInfo->DomUnicodeComputerName)) {

            InsertHeadList(&PagedTransport->BackupBrowserList, &Announcement->BackupLink);

            PagedTransport->NumberOfBackupServerListEntries += 1;

        }

        Periodicity = Announcement->ServerPeriodicity;

        ExpirationTime = BowserCurrentTime+(Periodicity*HOST_ANNOUNCEMENT_AGE);

        Announcement->ExpirationTime = ExpirationTime;
try_exit:NOTHING;
    } finally {

        UNLOCK_ANNOUNCE_DATABASE(Transport);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

VOID
BowserProcessDomainAnnouncement(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will put a server announcement into the server announcement
    table

Arguments:

    IN PWORK_HEADER Header - Supplies a pointer to a work header in a view buffer

Return Value:

    None.

--*/
{
    PVIEW_BUFFER ViewBuffer = Context;
    ANNOUNCE_ENTRY ProtoEntry;
    UNICODE_STRING TempUString;
    OEM_STRING TempAString;
    PANNOUNCE_ENTRY Announcement;
    BOOLEAN NewElement = FALSE;
    ULONG Periodicity;
    ULONG ExpirationTime;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport;
    PTRANSPORT_NAME TransportName = ViewBuffer->TransportName;
    PTRANSPORT Transport = TransportName->Transport;

    PAGED_CODE();
//    DbgBreakPoint();

    ASSERT (ViewBuffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    //
    //  If we're not a master browser on this transport, don't process the
    //  announcement.
    //  Or no-op for black hole server
    //

#ifdef ENABLE_PSEUDO_BROWSER
    ASSERT( BowserData.PseudoServerLevel != BROWSER_PSEUDO );
#endif
    if (ViewBuffer->TransportName->Transport->PagedTransport->Role != Master) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the computername to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerName;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerName);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerName);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the comment to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerComment;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerComment);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerComment);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    ProtoEntry.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;

    ProtoEntry.Size = sizeof(ProtoEntry) -
                      sizeof(ProtoEntry.ServerComment) +
                      TempUString.Length + sizeof(WCHAR);

    ProtoEntry.ServerType = ViewBuffer->ServerType;

    ProtoEntry.ServerVersionMajor = ViewBuffer->ServerVersionMajor;

    ProtoEntry.ServerVersionMinor = ViewBuffer->ServerVersionMinor;

    ProtoEntry.Name = ViewBuffer->TransportName->PagedTransportName->Name;

    ProtoEntry.ServerPeriodicity = ViewBuffer->ServerPeriodicity;

    ProtoEntry.BackupLink.Flink = NULL;

    ProtoEntry.BackupLink.Blink = NULL;

    ProtoEntry.Flags = 0;


    PagedTransport = Transport->PagedTransport;

    //
    //  We're done with the view buffer, now free it.
    //

    BowserFreeViewBuffer(ViewBuffer);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        Announcement = RtlInsertElementGenericTable(&PagedTransport->DomainTable,
                        &ProtoEntry, ProtoEntry.Size, &NewElement);

        if (Announcement == NULL) {
            //
            //  We couldn't allocate pool for this announcement.  Skip it.
            //

            BowserStatistics.NumberOfMissedServerAnnouncements += 1;
            try_return(NOTHING);

        }

        // Indicate the name is referenced by the announce entry we just inserted.
        BowserReferenceName( ProtoEntry.Name );

        if (!NewElement) {

            //
            //  If this is not a new announcement, copy the announcement entry
            //  with the new information.
            //

            // The Previous entry no longer references the name
            BowserDereferenceName( Announcement->Name );
            if ( Announcement->Size >= ProtoEntry.Size ) {
                CSHORT TempSize;
                TempSize = Announcement->Size;
                RtlCopyMemory( Announcement, &ProtoEntry, ProtoEntry.Size );
                Announcement->Size = TempSize;
            } else {
                if (!RtlDeleteElementGenericTable(
                                        &PagedTransport->DomainTable,
                                        Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                } else {
                    Announcement = RtlInsertElementGenericTable(
                                        &PagedTransport->DomainTable,
                                        &ProtoEntry,
                                        ProtoEntry.Size,
                                        &NewElement);

                    if (Announcement == NULL) {
                        BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                        try_return(NOTHING);
                    }
                    ASSERT( NewElement );
                }
            }
            dlog( DPRT_MASTER,
                  ("%s: %ws Domain:%ws P: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));

        } else {
            dlog( DPRT_MASTER,
                  ("%s: %ws New domain:%ws P: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));

            //
            // If there are too many entries,
            //  ditch this one.
            //

            if ( RtlNumberGenericTableElements(&PagedTransport->DomainTable) > BowserMaximumBrowseEntries ) {

                dlog( DPRT_MASTER,
                      ("%s: %ws New domain (deleted because too many):%ws P: %ld\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer,
                      Announcement->ServerName,
                      Announcement->ServerPeriodicity));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->DomainTable, Announcement)) {
//                    KdPrint(("Unable to delete element %ws\n", Announcement->ServerName));
                }

                //
                // Chaulk it up as a missed announcement
                //
                BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                try_return(NOTHING);
            }
        }

        Periodicity = Announcement->ServerPeriodicity;

        ExpirationTime = BowserCurrentTime+(Periodicity*HOST_ANNOUNCEMENT_AGE);

        Announcement->ExpirationTime = ExpirationTime;

try_exit:NOTHING;
    } finally {
        UNLOCK_ANNOUNCE_DATABASE(Transport);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

VOID
BowserAgeServerAnnouncements(
    VOID
    )
/*++

Routine Description:

    This routine will age server announcements in the server announce table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    BowserForEachTransport(AgeServerAnnouncements, NULL);

}

INLINE
BOOLEAN
BowserIsValidPotentialBrowser(
    IN PTRANSPORT Transport,
    IN PANNOUNCE_ENTRY Announcement
    )
{
    if (Announcement->Name->NameType != MasterBrowser) {
        return FALSE;
    }

    //
    //  If this guy is a potential browser, and is not
    //  currently a backup or master browser, promote
    //  him to a browser.
    //

    if (!(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy isn't either a master or backup browser already
    //

    if (Announcement->ServerType & (SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER)) {
        return FALSE;
    }

    //
    //  If this guy is running a current version of the browser.
    //

    if (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR) {
        return FALSE;
    }

    //
    //  If this machine is ourselves, and we've not yet announced ourselves as
    //  a master, don't promote ourselves.
    //

    if (!_wcsicmp(Announcement->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)) {
        return FALSE;
    }

    //
    //  If we've tried to promote this machine more than # of ignored promotions,
    //  we don't want to consider it either.
    //

    if (Announcement->NumberOfPromotionAttempts >= NUMBER_IGNORED_PROMOTIONS) {
        return FALSE;
    }

    return TRUE;
}

INLINE
BOOLEAN
BowserIsValidBackupBrowser(
    IN PTRANSPORT Transport,
    IN PANNOUNCE_ENTRY Announcement
    )
/*++

Routine Description:

    This routine determines if a server is eligable for demotion.

Arguments:

    PTRANSPORT Transport - Transport we are scanning.
    PANNOUNCE_ENTRY Announcement - Announce entry for server to check.

Return Value:

    BOOLEAN - True if browser is eligable for demotion

--*/

{
    PUNICODE_STRING PagedComputerName = &Transport->DomainInfo->DomUnicodeComputerName;
    //
    //  If the name came in on the master browser name
    //

    if (Announcement->Name->NameType != MasterBrowser) {
        return FALSE;
    }

    //
    //  And this guy is currently a backup browser,
    //

    if (!(Announcement->ServerType & SV_TYPE_BACKUP_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy was a promoted browser,
    //

    if (!(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy isn't an NTAS machine,
    //

    if (Announcement->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL)) {
        return FALSE;
    }

    //
    //  And this isn't ourselves.
    //

    if (RtlCompareMemory(Announcement->ServerName,
                         PagedComputerName->Buffer,
                         PagedComputerName->Length) == PagedComputerName->Length) {
        return FALSE;
    }

    //
    //  Then it's a valid backup browser to demote.
    //

    return TRUE;
}



NTSTATUS
AgeServerAnnouncements(
    PTRANSPORT Transport,
    PVOID Context
    )
/*++

Routine Description:

    This routine is the worker routine for BowserAgeServerAnnouncements.

    It is called for each of the serviced transports in the bowser and
    ages the servers received on each transport.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PANNOUNCE_ENTRY Announcement;
    ULONG BackupsNeeded;
    ULONG BackupsFound;
    ULONG NumberOfConfiguredBrowsers;
    PVOID ResumeKey = NULL;
    PVOID PreviousResumeKey = NULL;
    ULONG NumberOfServersDeleted = 0;
    ULONG NumberOfDomainsDeleted = 0;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    //
    // If we're not a master, don't bother.
    //

    if (PagedTransport->Role != Master) {
        UNLOCK_TRANSPORT(Transport);

        return STATUS_SUCCESS;
    }

    UNLOCK_TRANSPORT(Transport);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        BackupsFound = 0;
        NumberOfConfiguredBrowsers = 0;

        dlog(DPRT_MASTER,
             ("%s: %ws: Scavenge Servers:",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer));

        for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
             Announcement != NULL ;
             Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

            if (BowserCurrentTime > Announcement->ExpirationTime) {

                if (Announcement->Name->NameType != OtherDomain) {

                    if (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) {
                        //
                        //  This guy was a backup - indicate that we're not tracking
                        //  him any more.
                        //

                        PagedTransport->NumberOfBrowserServers -= 1;
                    }
                }

                dlog(DPRT_MASTER, ("%ws ", Announcement->ServerName));

                // Continue the search from where we found this entry.
                ResumeKey = PreviousResumeKey;

                BackupsFound = 0;

                NumberOfConfiguredBrowsers = 0;

                NumberOfServersDeleted += 1;

                //
                //  If this announcement was a backup browser, remove it from the
                //  list of backup browsers.
                //

                if (Announcement->BackupLink.Flink != NULL) {
                    ASSERT (Announcement->BackupLink.Blink != NULL);

                    ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

                    RemoveEntryList(&Announcement->BackupLink);

                    PagedTransport->NumberOfBackupServerListEntries -= 1;

                    Announcement->BackupLink.Flink = NULL;

                    Announcement->BackupLink.Blink = NULL;
                }

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                }

            } else {

                if (BowserIsLegalBackupBrowser(Announcement, &Transport->DomainInfo->DomUnicodeComputerName )) {

                    //
                    //  This announcement should be on the backup list.
                    //

                    ASSERT (Announcement->BackupLink.Flink != NULL);

                    ASSERT (Announcement->BackupLink.Blink != NULL);

                    //
                    // Found a backup that has not timed out.
                    //

                    BackupsFound++;

                }

                //
                //  If this machine is a DC or BDC and is an NT machine, then
                //  assume it's a Lanman/NT machine.
                //

                if (Announcement->ServerType & (SV_TYPE_DOMAIN_CTRL|SV_TYPE_DOMAIN_BAKCTRL)) {

                    //
                    //  If this DC is an NT DC, it is running the browser
                    //  service, and it is NOT the master, we consider it a
                    //  configured browser.
                    //

                    if ((Announcement->ServerType & SV_TYPE_NT)

                                    &&

                        (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER)

                                    &&

                        !(Announcement->ServerType & SV_TYPE_MASTER_BROWSER)) {

                        NumberOfConfiguredBrowsers += 1;
                    }
                } else {
                    //
                    //  If this guy isn't a DC, then if it is a backup browser
                    //  but not a potential browser, then it's a configured
                    //  browser (non-configured browsers get promoted).
                    //


                    if ((Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) &&
                        !(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
                        NumberOfConfiguredBrowsers += 1;
                    }
                }

                //
                // Remember where this valid entry was found.
                //

                PreviousResumeKey = ResumeKey;

            }
        }

        dlog(DPRT_MASTER, ("\n"));

        //
        //  If we've found enough configured backup servers, we don't need to
        //  promote any more backups.
        //
        //  Also don't attempt a promotion scan for the first MASTER_TIME_UP
        //  milliseconds (15 minutes) we are the master.
        //

        if ((BowserTimeUp() - PagedTransport->TimeMaster) > MASTER_TIME_UP) {

            //
            //  If there are fewer than the minimum configured browsers,
            //  rely only on the configured browsers.
            //

            if (NumberOfConfiguredBrowsers < BowserMinimumConfiguredBrowsers) {

                //
                //  We will need 1 backup for every SERVERS_PER_BACKUP servers in the domain.
                //

                PagedTransport->NumberOfBrowserServers = BackupsFound;

                BackupsNeeded = (RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) + (SERVERS_PER_BACKUP-1)) / SERVERS_PER_BACKUP;

                dlog(DPRT_MASTER,
                     ("%s: %ws: We need %lx backups, and have %lx.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     BackupsNeeded,
                     PagedTransport->NumberOfBrowserServers));

                if (PagedTransport->NumberOfBrowserServers < BackupsNeeded) {

                    //
                    // We only need this many more backup browsers.
                    //

                    BackupsNeeded = BackupsNeeded - PagedTransport->NumberOfBrowserServers;

                    //
                    //  We need to promote a machine to a backup if possible.
                    //

                    ResumeKey = NULL;

                    for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
                         Announcement != NULL ;
                         Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

                        //
                        //  If this announcement came from the master browser name
                        //

                        if (BowserIsValidPotentialBrowser(Transport, Announcement)) {

                            dlog(DPRT_MASTER,
                                 ("%s: %ws: Found browser to promote: %ws.\n",
                                 Transport->DomainInfo->DomOemDomainName,
                                 PagedTransport->TransportName.Buffer,
                                 Announcement->ServerName));

                            BowserPromoteToBackup(Transport, Announcement->ServerName);

                            //
                            //  Flag that we've attempted to promote this
                            //  browser.
                            //

                            Announcement->NumberOfPromotionAttempts += 1;

                            BackupsNeeded -= 1;

                            //
                            //  If we've promoted all the people we need to promote,
                            //  we're done, and can stop looping now.
                            //

                            if (BackupsNeeded == 0) {
                                    break;
                            }

                        } else if ((Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) &&
                            (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR)) {

                            //
                            //  If this guy is out of revision, shut him down.
                            //

                            BowserShutdownRemoteBrowser(Transport, Announcement->ServerName);
                        }
                    }
                }

            } else {

                //
                //  If we have enough configured browsers that we won't have
                //  any more backups, then demote all the non-configured
                //  browsers.
                //

                ResumeKey = NULL;

                for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
                     Announcement != NULL ;
                     Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

                    //
                    //  If this machine is a valid machine to demote, do it.
                    //

                    if (BowserIsValidBackupBrowser(Transport, Announcement)) {

                       //
                       //  This machine shouldn't be a backup, since we
                       //  already have enough machines to be backups.
                       //  Demote this backup browser.
                       //

                       BowserShutdownRemoteBrowser(Transport, Announcement->ServerName);
                    }
                }
            }
        }

        ResumeKey = NULL;
        PreviousResumeKey = NULL;

        dlog(DPRT_MASTER,
              ("%s: %ws: Scavenge Domains:",
              Transport->DomainInfo->DomOemDomainName,
              PagedTransport->TransportName.Buffer));

        for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->DomainTable, &ResumeKey) ;
             Announcement != NULL ;
             Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->DomainTable, &ResumeKey) ) {

            if (BowserCurrentTime > Announcement->ExpirationTime) {

                NumberOfDomainsDeleted += 1;

                // Continue the search from where we found this entry.
                ResumeKey = PreviousResumeKey;

                dlog(DPRT_MASTER, ("%ws ", Announcement->ServerName));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->DomainTable, Announcement)) {
//                    KdPrint(("Unable to delete element %ws\n", Announcement->ServerName));
                }
            } else {

                //
                // Remember where this valid entry was found.
                //

                PreviousResumeKey = ResumeKey;
            }
        }

        dlog(DPRT_MASTER, ("\n", Announcement->ServerName));

    } finally {

#if DBG
        //
        //  Log an indication that we might have deleted too many servers.
        //

        if (NumberOfServersDeleted > BowserServerDeletionThreshold) {
            dlog(DPRT_MASTER,
                 ("%s: %ws: Aged out %ld servers.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 NumberOfServersDeleted ));
        }

        if (NumberOfDomainsDeleted > BowserDomainDeletionThreshold) {
            dlog(DPRT_MASTER,
                 ("%s: %ws: Aged out %ld domains.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 NumberOfDomainsDeleted ));
        }
#endif

        UNLOCK_ANNOUNCE_DATABASE(Transport);
    }

    UNREFERENCED_PARAMETER(Context);
    return STATUS_SUCCESS;
}


VOID
BowserShutdownRemoteBrowser(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    )
/*++

Routine Description:

    This routine will send a request to the remote machine to make it become
    a browser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RESET_STATE ResetStateRequest;
    UNICODE_STRING Name;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    dlog(DPRT_BROWSER,
         ("%s: %ws: Demoting server %ws\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         ServerName ));

    RtlInitUnicodeString(&Name, ServerName);

    ResetStateRequest.Type = ResetBrowserState;

    ResetStateRequest.ResetStateRequest.Options = RESET_STATE_CLEAR_ALL;

    //
    //  Send this reset state (tickle) packet to the computer specified.
    //

    BowserSendSecondClassMailslot(Transport,
                                &Name,
                                ComputerName,
                                &ResetStateRequest,
                                sizeof(ResetStateRequest),
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL);

}

VOID
BowserPromoteToBackup(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    )
/*++

Routine Description:

    This routine will send a request to the remote machine to make it become
    a browser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR Buffer[LM20_CNLEN+1+sizeof(BECOME_BACKUP)];
    PBECOME_BACKUP BecomeBackup = (PBECOME_BACKUP)Buffer;
    UNICODE_STRING UString;
    OEM_STRING AString;
    NTSTATUS Status;
    ULONG BufferSize;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    dlog(DPRT_BROWSER,
         ("%s: %ws: Promoting server %ws to backup on %wZ\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         ServerName ));

    BecomeBackup->Type = BecomeBackupServer;

    RtlInitUnicodeString(&UString, ServerName);

    AString.Buffer = BecomeBackup->BecomeBackup.BrowserToPromote;
    AString.MaximumLength = (USHORT)(sizeof(Buffer)-FIELD_OFFSET(BECOME_BACKUP, BecomeBackup.BrowserToPromote));

    Status = RtlUnicodeStringToOemString(&AString, &UString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, UString.Buffer, UString.Length );
        return;
    }

    BufferSize = FIELD_OFFSET(BECOME_BACKUP, BecomeBackup.BrowserToPromote) +
                    AString.Length + sizeof(CHAR);

    BowserSendSecondClassMailslot(Transport,
                                NULL,
                                BrowserElection,
                                BecomeBackup,
                                BufferSize,
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL);

}


NTSTATUS
BowserEnumerateServers(
    IN ULONG Level,
    IN PLUID LogonId OPTIONAL,
    IN OUT PULONG ResumeKey,
    IN ULONG ServerTypeMask,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    )
/*++

Routine Description:

    This routine will enumerate the servers in the bowsers current announcement
    table.

Arguments:

    Level - The level of information to return

    LogonId - An optional logon id to indicate which user requested this info

    ResumeKey - The resume key (we return all entries after this one)

    ServerTypeMask - Mask of servers to return.

    TransportName - Name of the transport to enumerated on

    EmulatedDomainName - Name of the domain being emulated.

    DomainName OPTIONAL - Domain to filter (all if not specified)

    OutputBuffer - Buffer to fill with server info.

    OutputBufferSize - Filled in with size of buffer.

    EntriesRead - Filled in with the # of entries returned.

    TotalEntries - Filled in with the total # of entries.

    TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    LPTSTR               OutputBufferEnd;
    NTSTATUS             Status;
    ENUM_SERVERS_CONTEXT Context;
    PVOID                OriginalOutputBuffer = OutputBuffer;

    PAGED_CODE();

    OutputBuffer = ALLOCATE_POOL(PagedPool,OutputBufferSize,POOL_SERVER_ENUM_BUFFER);
    if (OutputBuffer == NULL) {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OutputBufferEnd = (LPTSTR)((PCHAR)OutputBuffer+OutputBufferSize);

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    Context.Level = Level;
    Context.LogonId = LogonId;
    Context.OriginalResumeKey = *ResumeKey;
    Context.ServerTypeMask = ServerTypeMask;
    Context.DomainName = DomainName;

    Context.OutputBufferSize = OutputBufferSize;
    Context.OutputBuffer = OutputBuffer;
    Context.OutputBufferDisplacement =
        ((PCHAR)OutputBuffer - ((PCHAR)OriginalOutputBuffer - OutputBufferDisplacement));
    Context.OutputBufferEnd = OutputBufferEnd;

    dlog(DPRT_SRVENUM, ("Enumerate Servers: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
        OutputBuffer, OutputBufferSize, OutputBufferEnd));

    if (TransportName == NULL) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        PTRANSPORT Transport;

        Transport = BowserFindTransport(TransportName, EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from BowserEnumerateServers.\n", Transport));

        if (Transport == NULL) {
            return(STATUS_OBJECT_NAME_NOT_FOUND);
        }

        dlog(DPRT_SRVENUM,
            ("%s: %ws: Enumerate Servers: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
            Transport->DomainInfo->DomOemDomainName,
            Transport->PagedTransport->TransportName.Buffer,
            OutputBuffer, OutputBufferSize, OutputBufferEnd));

        Status = EnumerateServersWorker(Transport, &Context);

        //
        //  Dereference the transport..

        BowserDereferenceTransport(Transport);

    }


    *EntriesRead = Context.EntriesRead;
    *TotalEntries = Context.TotalEntries;
    *TotalBytesNeeded = Context.TotalBytesNeeded;
    *ResumeKey = Context.ResumeKey;

    try {
        RtlCopyMemory(OriginalOutputBuffer,OutputBuffer,OutputBufferSize);
    } except (BR_EXCEPTION) {
        FREE_POOL(OutputBuffer);
        return(GetExceptionCode());
    }

    FREE_POOL(OutputBuffer);

    dlog(DPRT_SRVENUM, ("TotalEntries: %lx EntriesRead: %lx, TotalBytesNeeded: %lx\n", *TotalEntries, *EntriesRead, *TotalBytesNeeded));

    if (*EntriesRead == *TotalEntries) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_MORE_ENTRIES;
    }

}


NTSTATUS
EnumerateServersWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for GowserGetAnnounceTableSize.

    It is called for each of the serviced transports in the bowser and
    returns the size needed to enumerate the servers received on each transport.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PENUM_SERVERS_CONTEXT Context = Ctx;
    PANNOUNCE_ENTRY Announcement;
    NTSTATUS Status;
    ULONG AnnouncementIndex;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PUNICODE_STRING DomainName;

    PAGED_CODE();
    LOCK_ANNOUNCE_DATABASE_SHARED(Transport);

    if (Context->DomainName == NULL) {
        DomainName = &Transport->DomainInfo->DomUnicodeDomainName;
    } else {
        DomainName = Context->DomainName;
    }
    try {

        PVOID ResumeKey = NULL;

        for (AnnouncementIndex = 1,
             Announcement = RtlEnumerateGenericTableWithoutSplaying((Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ?
                                                        &PagedTransport->DomainTable :
                                                        &PagedTransport->AnnouncementTable),
                                                        &ResumeKey) ;

             Announcement != NULL ;

             AnnouncementIndex += 1,
             Announcement = RtlEnumerateGenericTableWithoutSplaying((Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ?
                                                        &PagedTransport->DomainTable :
                                                        &PagedTransport->AnnouncementTable),
                                                        &ResumeKey) ) {

            //
            //  If the type mask matches, check the domain supplied to make sure
            //  that this announcement is acceptable to the caller.
            //

            //
            //  If we are doing a domain enumeration, we want to use domains
            //  received on all names, otherwise we want to use names only
            //  seen on the domain being queried.
            //
            if ((AnnouncementIndex > Context->OriginalResumeKey) &&

                ((Announcement->ServerType & Context->ServerTypeMask) != 0) &&

                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ||
                 RtlEqualUnicodeString(DomainName, &Announcement->Name->Name, TRUE))
               ) {

                try {

                    //
                    //  We have an entry we can return to the user.
                    //

                    Context->TotalEntries += 1;

                    if (PackServerAnnouncement(Context->Level,
                                            Context->ServerTypeMask,
                                            (LPTSTR *)&Context->OutputBuffer,
                                            (LPTSTR *)&Context->OutputBufferEnd,
                                            Context->OutputBufferDisplacement,
                                            Announcement,
                                            &Context->TotalBytesNeeded)) {

                        Context->EntriesRead += 1;

                        //
                        //  Set the resume key in the structure to point to
                        //  the last entry we returned.
                        //

                        Context->ResumeKey = AnnouncementIndex;
                    }

                } except (BR_EXCEPTION) {

                    try_return(Status = GetExceptionCode());

                }
#if 0
            } else {
                if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ||
                    Context->ServerTypeMask == SV_TYPE_ALL ) {
                    KdPrint(("Skipping Announce entry %ws.  Index: %ld, ResumeKey: %ld, Domain: %wZ, %wZ\n",
                                Announcement->ServerName,
                                AnnouncementIndex,
                                Context->OriginalResumeKey,
                                &Announcement->Name->Name,
                                DomainName));
                }
#endif
            }
        }

        try_return(Status = STATUS_SUCCESS);

try_exit: {

#if 0

        if (Context->ServerTypeMask == SV_TYPE_ALL) {
            if (AnnouncementIndex-1 != RtlNumberGenericTableElements(&Transport->AnnouncementTable) ) {
                KdPrint(("Bowser: Announcement index != Number of elements in table (%ld, %ld) on transport %wZ\n", AnnouncementIndex-1, RtlNumberGenericTableElements(&Transport->AnnouncementTable), &Transport->TransportName ));

            }
        } else if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
            if (AnnouncementIndex-1 != RtlNumberGenericTableElements(&Transport->DomainTable) ) {
                KdPrint(("Bowser: Announcement index != Number of domains in table (%ld, %ld) on transport %wZ\n", AnnouncementIndex-1, RtlNumberGenericTableElements(&Transport->DomainTable), &Transport->TransportName ));

            }
        }


        if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
            if (Context->TotalEntries != RtlNumberGenericTableElements(&Transport->DomainTable)) {
                KdPrint(("Bowser: Returned EntriesRead == %ld, But %ld entries in table on transport %wZ\n", Context->TotalEntries, RtlNumberGenericTableElements(&Transport->DomainTable), &Transport->TransportName ));

            }
        } else if (Context->ServerTypeMask == SV_TYPE_ALL) {
            if (Context->TotalEntries != RtlNumberGenericTableElements(&Transport->AnnouncementTable)) {
               KdPrint(("Bowser: Returned EntriesRead == %ld, But %ld entries in table on transport %wZ\n", Context->TotalEntries, RtlNumberGenericTableElements(&Transport->AnnouncementTable), &Transport->TransportName ));

            }
        }

        if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM || Context->ServerTypeMask == SV_TYPE_ALL) {
            if (Context->EntriesRead <= 20) {
                KdPrint(("Bowser: Returned %s: EntriesRead == %ld (%ld/%ld) on transport %wZ. Resume handle: %lx, %lx\n",
                                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ? "domain" : "server"),
                                Context->EntriesRead,
                                RtlNumberGenericTableElements(&Transport->AnnouncementTable),
                                RtlNumberGenericTableElements(&Transport->DomainTable),
                                &Transport->TransportName,
                                Context->ResumeKey,
                                Context->OriginalResumeKey ));
            }

            if (Context->TotalEntries <= 20) {
                KdPrint(("Bowser: Returned %s: TotalEntries == %ld (%ld/%ld) on transport %wZ. Resume handle: %lx, %lx\n",
                                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ? "domain" : "server"),
                                Context->TotalEntries,
                                RtlNumberGenericTableElements(&Transport->AnnouncementTable),
                                RtlNumberGenericTableElements(&Transport->DomainTable),
                                &Transport->TransportName,
                                Context->ResumeKey,
                                Context->OriginalResumeKey ));
            }
        }
#endif

    }

    } finally {

        UNLOCK_ANNOUNCE_DATABASE(Transport);
    }


    return(Status);

}


BOOLEAN
PackServerAnnouncement (
    IN ULONG Level,
    IN ULONG ServerTypeMask,
    IN OUT LPTSTR *BufferStart,
    IN OUT LPTSTR *BufferEnd,
    IN ULONG_PTR BufferDisplacment,
    IN PANNOUNCE_ENTRY Announcement,
    OUT PULONG TotalBytesNeeded
    )

/*++

Routine Description:

    This routine packs a server announcement into the buffer provided updating
    all relevant pointers.


Arguments:

    IN ULONG Level - Level of information requested.

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                            Updated to point to the next buffer
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                                            point before the start of the
                                            strings being packed.
    IN PVOID UsersBufferStart - Supplies the start of the buffer in the users
                                            address space
    IN PANNOUNCE_ENTRY Announcement - Supplies the announcement to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                        entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/

{
    ULONG BufferSize;
    UNICODE_STRING UnicodeNameString, UnicodeCommentString;

    PSERVER_INFO_101 ServerInfo = (PSERVER_INFO_101 )*BufferStart;

    PAGED_CODE();

    switch (Level) {
    case 100:
        BufferSize = sizeof(SERVER_INFO_100);
        break;
    case 101:
        BufferSize = sizeof(SERVER_INFO_101);
        break;
    default:
        return FALSE;
    }

    *BufferStart = (LPTSTR)(((PUCHAR)*BufferStart) + BufferSize);

    dlog(DPRT_SRVENUM, ("Pack Announcement %ws (%lx) - %ws :", Announcement->ServerName, Announcement, Announcement->ServerComment));

    dlog(DPRT_SRVENUM, ("BufferStart: %lx, BufferEnd: %lx\n", ServerInfo, *BufferEnd));

    //
    //  Compute the length of the name.
    //

    RtlInitUnicodeString(&UnicodeNameString, Announcement->ServerName);

    ASSERT (UnicodeNameString.Length <= CNLEN*sizeof(WCHAR));

    RtlInitUnicodeString(&UnicodeCommentString, Announcement->ServerComment);

    ASSERT (UnicodeCommentString.Length <= LM20_MAXCOMMENTSZ*sizeof(WCHAR));

#if DBG
    if (ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
        ASSERT (UnicodeCommentString.Length <= CNLEN*sizeof(WCHAR));
    }
#endif
    //
    //  Update the total number of bytes needed for this structure.
    //

    *TotalBytesNeeded += UnicodeNameString.Length  + BufferSize + sizeof(WCHAR);

    if (Level == 101) {
        *TotalBytesNeeded += UnicodeCommentString.Length + sizeof(WCHAR);

        if (ServerTypeMask == SV_TYPE_BACKUP_BROWSER) {
            *TotalBytesNeeded += 2;
        }

    }

    if (*BufferStart >= *BufferEnd) {
        return FALSE;
    }

    //
    //  Assume an OS/2 platform ID, unless an NT server
    //

    if (Announcement->ServerType & SV_TYPE_NT) {
        ServerInfo->sv101_platform_id = PLATFORM_ID_NT;
    } else {
        ServerInfo->sv101_platform_id = PLATFORM_ID_OS2;
    }

    ServerInfo->sv101_name = UnicodeNameString.Buffer;

    ASSERT (UnicodeNameString.Length / sizeof(WCHAR) <= CNLEN);

    if (!BowserPackUnicodeString(
                            &ServerInfo->sv101_name,
                            UnicodeNameString.Length,
                            BufferDisplacment,
                            *BufferStart,
                            BufferEnd)) {

        dlog(DPRT_SRVENUM, ("Unable to pack name %ws into buffer\n", Announcement->ServerName));
        return FALSE;
    }

    if (Level > 100) {
        PUSHORT VersionPointer;

        ServerInfo->sv101_version_major = Announcement->ServerVersionMajor;
        ServerInfo->sv101_version_minor = Announcement->ServerVersionMinor;
        ServerInfo->sv101_type = Announcement->ServerType;

        ServerInfo->sv101_comment = UnicodeCommentString.Buffer;

        ASSERT (UnicodeCommentString.Length / sizeof(WCHAR) <= LM20_MAXCOMMENTSZ);

        if (!BowserPackUnicodeString(
                            &ServerInfo->sv101_comment,
                            UnicodeCommentString.Length,
                            BufferDisplacment,
                            *BufferStart,
                            BufferEnd)) {

            dlog(DPRT_SRVENUM, ("Unable to pack comment %ws into buffer\n", Announcement->ServerComment));
            return FALSE;
        }

        if (ServerTypeMask == SV_TYPE_BACKUP_BROWSER) {

            //
            //  If we can't fit a ushort into the buffer, return an error.
            //

            if ((*BufferEnd - *BufferStart) <= sizeof(USHORT)) {
                return FALSE;

            }

            //
            //  Back the buffer end by the size of a USHORT (to make room for
            //  this value).
            //

            (ULONG_PTR)*BufferEnd -= sizeof(USHORT);

            VersionPointer = (PUSHORT)*BufferEnd;

            *VersionPointer = Announcement->ServerBrowserVersion;


        }

    }

    return TRUE;
}




PVIEW_BUFFER
BowserAllocateViewBuffer(
    VOID
    )
/*++

Routine Description:

    This routine will allocate a view buffer from the view buffer pool.

    If it is unable to allocate a buffer, it will allocate the buffer from
    non-paged pool (up to the maximum configured by the user).


Arguments:

    None.


Return Value:

    ViewBuffr - The allocated buffer.

--*/
{
    KIRQL OldIrql;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

    if (!IsListEmpty(&BowserViewBufferHead)) {
        PLIST_ENTRY Entry = RemoveHeadList(&BowserViewBufferHead);

        RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

        return CONTAINING_RECORD(Entry, VIEW_BUFFER, Overlay.NextBuffer);
    }

    if (BowserNumberOfServerAnnounceBuffers <=
        BowserData.NumberOfServerAnnounceBuffers) {
        PVIEW_BUFFER ViewBuffer = NULL;

        BowserNumberOfServerAnnounceBuffers += 1;

        RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

        ViewBuffer = ALLOCATE_POOL(NonPagedPool, sizeof(VIEW_BUFFER), POOL_VIEWBUFFER);

        if (ViewBuffer == NULL) {
            ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

            BowserNumberOfServerAnnounceBuffers -= 1;

            BowserStatistics.NumberOfFailedServerAnnounceAllocations += 1;
            RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

            return NULL;
        }

        ViewBuffer->Signature = STRUCTURE_SIGNATURE_VIEW_BUFFER;

        ViewBuffer->Size = sizeof(VIEW_BUFFER);

        return ViewBuffer;
    }

    RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

    BowserStatistics.NumberOfMissedServerAnnouncements += 1;

    // run out of buffers.
    return NULL;
}

VOID
BowserFreeViewBuffer(
    IN PVIEW_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a view buffer to the view buffer pool.

Arguments:

    IN PVIEW_BUFFER Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ASSERT (Buffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

    InsertTailList(&BowserViewBufferHead, &Buffer->Overlay.NextBuffer);

    RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

}

NTSTATUS
BowserpInitializeAnnounceTable(
    VOID
    )
/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PAGED_CODE();

    InitializeListHead(&BowserViewBufferHead);

    //
    //  Allocate a spin lock to protect the view buffer chain.
    //

    KeInitializeSpinLock(&BowserViewBufferListSpinLock);

    BowserNumberOfServerAnnounceBuffers = 0;

    return STATUS_SUCCESS;

}
NTSTATUS
BowserpUninitializeAnnounceTable(
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER Buffer;

    PAGED_CODE();

    //
    //  Note: We don't need to protect this list while stopping because
    //  we have already unbound from all the loaded transports, thus no
    //  other announcements are being processed.
    //

    while (!IsListEmpty(&BowserViewBufferHead)) {
        PLIST_ENTRY Entry = RemoveHeadList(&BowserViewBufferHead);
        Buffer = CONTAINING_RECORD(Entry, VIEW_BUFFER, Overlay.NextBuffer);

        FREE_POOL(Buffer);
    }

    ASSERT (IsListEmpty(&BowserViewBufferHead));

    BowserNumberOfServerAnnounceBuffers = 0;

    return STATUS_SUCCESS;

}

VOID
BowserDeleteGenericTable(
    IN PRTL_GENERIC_TABLE GenericTable
    )
{
    PVOID TableElement;

    PAGED_CODE();

    //
    //  Enumerate the elements in the table, deleting them as we go.
    //

//    KdPrint("Delete Generic Table %lx\n", GenericTable));

    for (TableElement = RtlEnumerateGenericTable(GenericTable, TRUE) ;
         TableElement != NULL ;
         TableElement = RtlEnumerateGenericTable(GenericTable, TRUE)) {
        PANNOUNCE_ENTRY Announcement = TableElement;

        if (Announcement->BackupLink.Flink != NULL) {
            ASSERT (Announcement->BackupLink.Blink != NULL);

            ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

            RemoveEntryList(&Announcement->BackupLink);

            Announcement->BackupLink.Flink = NULL;

            Announcement->BackupLink.Blink = NULL;

        }

        BowserDereferenceName( Announcement->Name );
        RtlDeleteElementGenericTable(GenericTable, TableElement);
    }

    ASSERT (RtlNumberGenericTableElements(GenericTable) == 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowpub.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bowser.h

Abstract:

    This module is the main header file for the NT redirector file
    system.

Author:

    Darryl Havens (darrylh) 29-Jun-1989
    Larry Osterman (larryo) 06-May-1991


Revision History:


--*/


#ifndef _BOWPUB_
#define _BOWPUB_

struct _BOWSER_FS_DEVICE_OBJECT;

extern
struct _BOWSER_FS_DEVICE_OBJECT *
BowserDeviceObject;

NTSTATUS
BowserDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
BowserUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#include "fsddisp.h"

#endif // _BOWPUB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowmastr.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowmastr.h

Abstract:

    This module implements all of the master browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#ifndef _BOWMASTR_
#define _BOWMASTR_

typedef struct _QUEUED_GET_BROWSER_REQUEST {
    LIST_ENTRY Entry;
    ULONG Token;
    USHORT RequestedCount;
    USHORT ClientNameLength;
    LARGE_INTEGER TimeReceived;
#if DBG
    LARGE_INTEGER TimeQueued;
    LARGE_INTEGER TimeQueuedToBrowserThread;
#endif
    WCHAR  ClientName[1];
} QUEUED_GET_BROWSER_REQUEST, *PQUEUED_GET_BROWSER_REQUEST;


NTSTATUS
BowserBecomeMaster(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserMasterFindMaster(
    IN PTRANSPORT Transport,
    IN PREQUEST_ELECTION_1 ElectionRequest,
    IN ULONG BytesAvailable
    );

VOID
BowserNewMaster(
    IN PTRANSPORT Transport,
    IN PUCHAR MasterName
    );

VOID
BowserCompleteFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING MasterName,
    IN NTSTATUS Status
    );

DATAGRAM_HANDLER(
    BowserMasterAnnouncement
    );

VOID
BowserTimeoutFindMasterRequests(
    VOID
    );


#endif // _BOWMASTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowipx.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowipx.h

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#ifndef _BOWIPX_
#define _BOWIPX_

NTSTATUS
BowserIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
BowserIpxClaimBrowserName (
    IN PTRANSPORT_NAME TransportName
    );

//
// Transport Receive Datagram indication handlers
//

NTSTATUS
BowserIpxDatagramHandler (
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

//
// IPX packet types used by the browser
//

#define IPX_BROADCAST_PACKET 0x14
#define IPX_DIRECTED_PACKET 0x4

#endif  // _BOWIPX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowmastr.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowmastr.c

Abstract:

    This module implements all of the master browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION

NTSTATUS
StartProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

VOID
BowserMasterAnnouncementWorker(
    IN PVOID Ctx
    );

NTSTATUS
TimeoutFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PVOID Context

    );
NTSTATUS
BowserPrimeDomainTableWithOtherDomains(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserBecomeMaster)
#pragma alloc_text(PAGE, StartProcessingAnnouncements)
#pragma alloc_text(PAGE, BowserPrimeDomainTableWithOtherDomains)
#pragma alloc_text(PAGE, BowserNewMaster)
#pragma alloc_text(PAGE, BowserCompleteFindMasterRequests)
#pragma alloc_text(PAGE, BowserTimeoutFindMasterRequests)
#pragma alloc_text(PAGE, TimeoutFindMasterRequests)
#pragma alloc_text(PAGE, BowserMasterAnnouncementWorker)
#endif


NTSTATUS
BowserBecomeMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Make this machine a master browser.

    This routine is called when we are changing the state of a machine from
    backup to master browser.

Arguments:
    Transport - The transport on which to become a master.

Return Value
    NTSTATUS - The status of the upgrade operation.

--*/
{
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    try {

        LOCK_TRANSPORT(Transport);

        BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

        //
        //  Post the addname on this transport for the master name..
        //

        Status = BowserAllocateName(
                    &Transport->DomainInfo->DomUnicodeDomainName,
                    MasterBrowser,
                    Transport,
                    Transport->DomainInfo );

        if (NT_SUCCESS(Status)) {

            //
            //  Post the addname on this transport for the domain announcement.
            //

            Status = BowserAllocateName(&Transport->DomainInfo->DomUnicodeDomainName,
                                            DomainAnnouncement,
                                            Transport,
                                            Transport->DomainInfo );
        }

        //
        //  The addition of the name failed - we can't be a master any
        //  more.
        //

        if (!NT_SUCCESS(Status)) {

            try_return(Status);

        }

        PagedTransport->Role = Master;

        //
        //  Start processing host announcements on each of
        //  the names associated with the server.
        //

        BowserForEachTransportName(Transport, StartProcessingAnnouncements, NULL);

        //
        //  If we don't have any elements in our announcement table,
        //  send a request announcement packet to all the servers to
        //  allow ourselves to populate the table as quickly as possible.
        //


#ifdef ENABLE_PSEUDO_BROWSER
        if ((RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0 &&
            BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#else
        if ((RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0) {
#endif
            BowserSendRequestAnnouncement(&Transport->DomainInfo->DomUnicodeDomainName,
                                            PrimaryDomain,
                                            Transport);

        }


        //
        //  If we don't have any elements in our domain table,
        //  send a request announcement packet to all the servers to
        //  allow ourselves to populate the table as quickly as possible.
        //

#ifdef ENABLE_PSEUDO_BROWSER
        if ((RtlNumberGenericTableElements(&PagedTransport->DomainTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0 &&
            BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#else
        if ((RtlNumberGenericTableElements(&PagedTransport->DomainTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0) {
#endif
            BowserSendRequestAnnouncement(&Transport->DomainInfo->DomUnicodeDomainName,
                                            DomainAnnouncement,
                                            Transport);
        }

        PagedTransport->TimeMaster = BowserTimeUp();


        //
        //  Now walk the transport names associated with this transport and
        //  seed all the "otherdomains" into the browse list.
        //

        BowserForEachTransportName(
                Transport,
                BowserPrimeDomainTableWithOtherDomains,
                NULL);

        //
        //  Now complete any and all find master requests outstanding on this
        //  transport.
        //

        BowserCompleteFindMasterRequests(Transport, &Transport->DomainInfo->DomUnicodeComputerName, STATUS_REQUEST_NOT_ACCEPTED);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if (!NT_SUCCESS(Status)) {

            dlog(DPRT_ELECT|DPRT_MASTER,
                 ("%s: %ws: There's already a master on this net - we need to find who it is",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            //
            //  We couldn't become a master.  Reset our state and fail the
            //  promotion request.
            //

            PagedTransport->Role = PotentialBackup;

            PagedTransport->ElectionCount = ELECTION_COUNT;

            PagedTransport->Uptime = BowserTimeUp();

            Transport->ElectionState = Idle;

            //
            //  Stop processing host announcements on each of
            //  the names associated with the server.
            //

            BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

            //
            //  Stop any timers that are running (ie. if there's an election
            //  in progress)
            //

            BowserStopTimer(&Transport->ElectionTimer);

            //
            //  Delete the names we added above.
            //

            BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

            BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);


            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        }

        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}
NTSTATUS
StartProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (TransportName->NameType == TransportName->PagedTransportName->Name->NameType);

    if ((TransportName->NameType == OtherDomain) ||
        (TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == PrimaryDomain) ||
        (TransportName->NameType == BrowserElection) ||
        (TransportName->NameType == DomainAnnouncement)) {

        if (!TransportName->ProcessHostAnnouncements) {
            BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

            DISCARDABLE_CODE( BowserDiscardableCodeSection );

            TransportName->ProcessHostAnnouncements = TRUE;
        }

    }

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Context);
}

NTSTATUS
BowserPrimeDomainTableWithOtherDomains(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    if (TransportName->NameType == OtherDomain) {
        PPAGED_TRANSPORT PagedTransport = TransportName->Transport->PagedTransport;
        PTRANSPORT Transport = TransportName->Transport;
        ANNOUNCE_ENTRY OtherDomainPrototype;
        PANNOUNCE_ENTRY Announcement;
        BOOLEAN NewElement;

        RtlZeroMemory( &OtherDomainPrototype, sizeof(OtherDomainPrototype) );
        OtherDomainPrototype.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;
        OtherDomainPrototype.Size = sizeof(OtherDomainPrototype) -
                                    sizeof(OtherDomainPrototype.ServerComment) +
                                    Transport->DomainInfo->DomUnicodeComputerName.Length + sizeof(WCHAR);

        RtlCopyMemory(OtherDomainPrototype.ServerName, TransportName->PagedTransportName->Name->Name.Buffer, TransportName->PagedTransportName->Name->Name.Length);
        OtherDomainPrototype.ServerName[TransportName->PagedTransportName->Name->Name.Length / sizeof(WCHAR)] = UNICODE_NULL;

        RtlCopyMemory(OtherDomainPrototype.ServerComment, Transport->DomainInfo->DomUnicodeComputerName.Buffer, Transport->DomainInfo->DomUnicodeComputerName.Length);

        OtherDomainPrototype.ServerComment[Transport->DomainInfo->DomUnicodeComputerName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        OtherDomainPrototype.ServerType = SV_TYPE_DOMAIN_ENUM;

        OtherDomainPrototype.ServerVersionMajor = 2;

        OtherDomainPrototype.ServerVersionMinor = 0;

        OtherDomainPrototype.ServerPeriodicity = 0xffff;
        OtherDomainPrototype.ExpirationTime = 0xffffffff;

        OtherDomainPrototype.SerialId = 0;

        OtherDomainPrototype.Name = TransportName->PagedTransportName->Name;

        //
        //  Make sure that no-one else is messing with the domain list.
        //

        LOCK_ANNOUNCE_DATABASE(Transport);

        Announcement = RtlInsertElementGenericTable(&PagedTransport->DomainTable,
                        &OtherDomainPrototype, OtherDomainPrototype.Size, &NewElement);

        if (Announcement != NULL && NewElement ) {
            // Indicate the name is referenced by the announce entry we just inserted.
            BowserReferenceName( OtherDomainPrototype.Name );
        }

        UNLOCK_ANNOUNCE_DATABASE(Transport);

    }

    return(STATUS_SUCCESS);
}
VOID
BowserNewMaster(
    IN PTRANSPORT Transport,
    IN PUCHAR MasterName
    )
/*++

Routine Description:
    Flag that a machine is the new master browser server.

    This routine is called to register a new master browser server.

Arguments:
    IN PTRANSPORT Transport - The transport for the net we're on.
    IN PUCHAR MasterName - The name of the new master browser server.

Return Value
    None.

--*/
{
    PIRP Irp = NULL;
    WCHAR MasterNameBuffer[LM20_CNLEN+1];

    UNICODE_STRING UMasterName;
    OEM_STRING OMasterName;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    UMasterName.Buffer = MasterNameBuffer;
    UMasterName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);

    RtlInitAnsiString(&OMasterName, MasterName);

    Status = RtlOemStringToUnicodeString(&UMasterName, &OMasterName, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, OMasterName.Buffer, OMasterName.Length );
        return;
    }

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  There's a new master, we can stop our election timers.
        //

        PagedTransport->ElectionCount = 0;

        Transport->ElectionState = Idle;

        BowserStopTimer(&Transport->ElectionTimer);

        //
        //  Check to see if we are the winner of the election.  If we are
        //  we want to complete any BecomeMaster requests that are outstanding.
        //

        if (RtlEqualUnicodeString(&UMasterName, &Transport->DomainInfo->DomUnicodeComputerName, TRUE)) {

            //
            //  We're the new master for this domain.  Complete any BecomeMaster
            //  requests.
            //

            Irp = BowserDequeueQueuedIrp(&Transport->BecomeMasterQueue);

            if (Irp != NULL) {

                //
                //  Don't copy anything into the users buffer.
                //

                Irp->IoStatus.Information = 0;

                BowserCompleteRequest(Irp, STATUS_SUCCESS);
            } else {

                //
                //  Go deaf to elections until we can become a master.
                //

                Transport->ElectionState = DeafToElections;

                //
                //  If we're the master browser, stop being a master browser.
                //
                //

                if (PagedTransport->Role == MasterBrowser) {

                    //
                    //  Delete the names that make us a master.
                    //

                    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

                    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);

                }

                dlog(DPRT_MASTER,
                     ("%s: %ws: Unable to find a BecomeMasterIrp\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));
            }

            //
            //  Complete any outstanding find master requests with the special error MORE_PROCESSING_REQUIRED.
            //
            //  This will cause the browser service to promote itself.
            //

            BowserCompleteFindMasterRequests(Transport, &UMasterName, STATUS_MORE_PROCESSING_REQUIRED);

        } else {

            BowserCompleteFindMasterRequests(Transport, &UMasterName, STATUS_SUCCESS);

        }

    } finally {
        UNLOCK_TRANSPORT(Transport);
    }
}

VOID
BowserCompleteFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING MasterName,
    IN NTSTATUS Status
    )
{
    PIO_STACK_LOCATION IrpSp;
    PIRP Irp = NULL;
    BOOLEAN MasterNameChanged;
    WCHAR MasterNameBuffer[CNLEN+1];
    UNICODE_STRING MasterNameCopy;
    NTSTATUS UcaseStatus;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    MasterNameCopy.Buffer = MasterNameBuffer;
    MasterNameCopy.MaximumLength = sizeof(MasterNameBuffer);

    UcaseStatus = RtlUpcaseUnicodeString(&MasterNameCopy, MasterName, FALSE);

    if (!NT_SUCCESS(UcaseStatus)) {
        BowserLogIllegalName( UcaseStatus, MasterName->Buffer, MasterName->Length );

        return;
    }

    LOCK_TRANSPORT(Transport);

    MasterNameChanged = !RtlEqualUnicodeString(&MasterNameCopy, &PagedTransport->MasterName, FALSE);

    if (MasterNameChanged) {
       //
       //  If the master name changed, update the masters name in
       //  the transport structure.
       //

       RtlCopyUnicodeString(&PagedTransport->MasterName, &MasterNameCopy);

    }

    UNLOCK_TRANSPORT(Transport);

    do {

        //
        //  Complete any the find master requests outstanding against this
        //  workstation.
        //

        Irp = BowserDequeueQueuedIrp(&Transport->FindMasterQueue);

        if (MasterNameChanged &&
            (Irp == NULL)) {

            Irp = BowserDequeueQueuedIrp(&Transport->WaitForNewMasterNameQueue);

        }

        if (Irp != NULL) {
            PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

            if (NT_SUCCESS(Status)) {

                IrpSp = IoGetCurrentIrpStackLocation(Irp);

                if (MasterName->Length > (USHORT)(IrpSp->Parameters.DeviceIoControl.OutputBufferLength-
                                                          (FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name))+3*sizeof(WCHAR)) ) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    RequestPacket->Parameters.GetMasterName.Name[0] = L'\\';
                    RequestPacket->Parameters.GetMasterName.Name[1] = L'\\';
                    RtlCopyMemory(&RequestPacket->Parameters.GetMasterName.Name[2], MasterName->Buffer, MasterName->Length);
                    RequestPacket->Parameters.GetMasterName.Name[2+(MasterName->Length/sizeof(WCHAR))] = UNICODE_NULL;
                }

                dlog(DPRT_MASTER,
                     ("%s: %ws: Completing a find master request with new master %ws\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     RequestPacket->Parameters.GetMasterName.Name));

                RequestPacket->Parameters.GetMasterName.MasterNameLength = MasterName->Length+2*sizeof(WCHAR);

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name)+MasterName->Length+3*sizeof(WCHAR);

            }

            BowserCompleteRequest(Irp, Status);
        }

    } while ( Irp != NULL );
}


DATAGRAM_HANDLER(BowserMasterAnnouncement)
{
    PUCHAR  MasterName = ((PMASTER_ANNOUNCEMENT_1)Buffer)->MasterName;
    ULONG   i;

    //
    //  We need to make sure that the incoming packet contains a properly
    //     terminated ASCII string.
    //

    for (i = 0; i < BytesAvailable; i++) {
        if (MasterName[i] == '\0') {
            break;
        }
    }

    if (i == BytesAvailable) {
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                BowserMasterAnnouncementWorker,
                NonPagedPool,
                DelayedWorkQueue,
                ReceiveFlags,
                FALSE                   // No response will be sent.
                );
}

VOID
BowserMasterAnnouncementWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PTRANSPORT Transport = Context->TransportName->Transport;
    PCHAR LocalMasterName = (PCHAR)((PMASTER_ANNOUNCEMENT_1)Context->Buffer)->MasterName;
    size_t cbLocalMasterName;
    PIRP Irp;
    NTSTATUS Status;

    PAGED_CODE();

    Irp = BowserDequeueQueuedIrp(&Transport->WaitForMasterAnnounceQueue);

    if (Irp != NULL) {
        PIO_STACK_LOCATION IrpSp;
        PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        cbLocalMasterName = strlen(LocalMasterName);

        if (0 == cbLocalMasterName) {

            // ensure we didn't get an invalid NULL announcement
            // see bug 440813
            // The request completed successfully, but the data is trash.
            //  - we won't fail the IRP (another one is posted immediately
            //    upon completion anyway), but not process further this one.

            Irp->IoStatus.Information = 0;
            Status = STATUS_SUCCESS;
        }
        else if ((cbLocalMasterName + 1) * sizeof(WCHAR) >
                 (IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
                    FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name))) {
            //
            // ensure there's enough buffer space to return name. If not,
            // return error.
            //

            Irp->IoStatus.Information = 0;

            Status = STATUS_BUFFER_TOO_SMALL;
        } else {

            //
            // All is well. Fill info.
            //

            OEM_STRING MasterName;
            UNICODE_STRING MasterNameU;

            RtlInitString(&MasterName, LocalMasterName);

            Status = RtlOemStringToUnicodeString(&MasterNameU, &MasterName, TRUE);

            if ( NT_SUCCESS(Status) ) {
                RequestPacket->Parameters.WaitForMasterAnnouncement.MasterNameLength = MasterNameU.Length;

                RtlCopyMemory(RequestPacket->Parameters.WaitForMasterAnnouncement.Name, MasterNameU.Buffer, MasterNameU.Length);

                RequestPacket->Parameters.WaitForMasterAnnouncement.Name[MasterNameU.Length/sizeof(WCHAR)] = UNICODE_NULL;

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name)+MasterNameU.Length + sizeof(UNICODE_NULL);

                RtlFreeUnicodeString(&MasterNameU);

                Status = STATUS_SUCCESS;
            }
        }

        BowserCompleteRequest(Irp, Status);

    }

    BowserDereferenceTransportName(Context->TransportName);
    BowserDereferenceTransport(Transport);

    InterlockedDecrement( &BowserPostedDatagramCount );
    FREE_POOL(Context);

}


NTSTATUS
TimeoutFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{

    PAGED_CODE();

    //
    //  Perform an unprotected early out to prevent our calling into
    //  discardable code section during the scavenger.  Since the discardable
    //  code section is <4K, touching the code would have the effect of
    //  bringing the entire page into memory, which is a waste - since the
    //  scavenger runs every 30 seconds, this would cause the discardable
    //  code section to be a part of the browsers working set.
    //

    if (BowserIsIrpQueueEmpty(&Transport->FindMasterQueue)) {
        return STATUS_SUCCESS;
    }

    BowserTimeoutQueuedIrp(&Transport->FindMasterQueue, BowserFindMasterTimeout);

    return STATUS_SUCCESS;
}

VOID
BowserTimeoutFindMasterRequests(
    VOID
    )
{
    PAGED_CODE();

    BowserForEachTransport(TimeoutFindMasterRequests, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowname.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowname.c

Abstract:

    This module implements all of the routines to manage the NT bowser name
    manipulation routines

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct _ENUM_NAMES_CONTEXT {
    PDGRECEIVE_NAMES OutputBuffer;
    PDGRECEIVE_NAMES NextOutputBuffer;
    PVOID OutputBufferEnd;
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
} ENUM_NAMES_CONTEXT, *PENUM_NAMES_CONTEXT;

typedef struct _ADD_TRANSPORT_NAME_CONTEXT {
    LIST_ENTRY ListHead;
    UNICODE_STRING NameToAdd;
    DGRECEIVER_NAME_TYPE NameType;
} ADD_TRANSPORT_NAME_CONTEXT, *PADD_TRANSPORT_NAME_CONTEXT;

typedef struct _ADD_TRANSPORT_NAME_STRUCTURE {
    LIST_ENTRY Link;
    HANDLE ThreadHandle;
    PTRANSPORT Transport;
    UNICODE_STRING NameToAdd;
    DGRECEIVER_NAME_TYPE NameType;
    NTSTATUS Status;
} ADD_TRANSPORT_NAME_STRUCTURE, *PADD_TRANSPORT_NAME_STRUCTURE;


NTSTATUS
AddTransportName(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );


VOID
AsyncCreateTransportName(
    IN PVOID Ctx
    );

NTSTATUS
WaitForAddNameOperation(
    IN PADD_TRANSPORT_NAME_CONTEXT Context
    );

NTSTATUS
BowserDeleteNamesInDomain(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserDeleteNamesWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
EnumerateNamesTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
EnumerateNamesTransportNameWorker(
    IN PTRANSPORT_NAME TransportName,
    IN OUT PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserAllocateName)
#pragma alloc_text(PAGE, BowserAddDefaultNames)
#pragma alloc_text(PAGE, BowserDeleteDefaultDomainNames)
#pragma alloc_text(PAGE, AddTransportName)
#pragma alloc_text(PAGE, AsyncCreateTransportName)
#pragma alloc_text(PAGE, WaitForAddNameOperation)
#pragma alloc_text(PAGE, BowserDeleteNameByName)
#pragma alloc_text(PAGE, BowserDereferenceName)
#pragma alloc_text(PAGE, BowserReferenceName)
#pragma alloc_text(PAGE, BowserForEachName)
#pragma alloc_text(PAGE, BowserDeleteName)
#pragma alloc_text(PAGE, BowserDeleteNamesInDomain)
#pragma alloc_text(PAGE, BowserDeleteNamesWorker)
#pragma alloc_text(PAGE, BowserFindName)
#pragma alloc_text(PAGE, BowserEnumerateNamesInDomain)
#pragma alloc_text(PAGE, EnumerateNamesTransportWorker)
#pragma alloc_text(PAGE, EnumerateNamesTransportNameWorker)
#pragma alloc_text(INIT, BowserpInitializeNames)
#pragma alloc_text(PAGE, BowserpUninitializeNames)
#endif

NTSTATUS
BowserAllocateName(
    IN PUNICODE_STRING NameToAdd,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport OPTIONAL,
    IN PDOMAIN_INFO DomainInfo OPTIONAL
    )
/*++

Routine Description:

    This routine creates a browser name

Arguments:

    NameToAdd - Netbios name to add to one or more transports

    NameType - Type of the added name

    Transport - if specified, the name is added to this transport.
        If not specified, the name is added to all transports in the domain.

    DomainInfo - Specifies the emulated domain to add the name to.
        If not specified, the name is added to the specified transport.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PBOWSER_NAME NewName;
    NTSTATUS Status = STATUS_SUCCESS;
    OEM_STRING OemName;
    BOOLEAN ResourceLocked = FALSE;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    ResourceLocked = TRUE;

    //
    // If the name doesn't already exist,
    //  allocate one and fill it in.
    //

    NewName = BowserFindName(NameToAdd, NameType);

    if (NewName == NULL) {

        NewName = ALLOCATE_POOL( PagedPool,
                                 sizeof(BOWSER_NAME) +
                                    NameToAdd->Length+sizeof(WCHAR),
                                 POOL_BOWSERNAME);

        if (NewName == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        NewName->Signature = STRUCTURE_SIGNATURE_BOWSER_NAME;

        NewName->Size = sizeof(BOWSER_NAME);

        // This reference matches the one FindName would have done
        // above had it succeeded.
        NewName->ReferenceCount = 1;

        InitializeListHead(&NewName->NameChain);

        NewName->NameType = NameType;

        InsertHeadList(&BowserNameHead, &NewName->GlobalNext);

        NewName->Name.Buffer = (LPWSTR)(NewName+1);
        NewName->Name.MaximumLength = NameToAdd->Length + sizeof(WCHAR);
        RtlCopyUnicodeString(&NewName->Name, NameToAdd);

        //
        //  Null terminate the name in the buffer just in case.
        //

        NewName->Name.Buffer[NewName->Name.Length/sizeof(WCHAR)] = L'\0';

        //
        //  Uppercase the name.
        //

        Status = RtlUpcaseUnicodeStringToOemString(&OemName, &NewName->Name, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }

        Status = RtlOemStringToUnicodeString(&NewName->Name, &OemName, FALSE);

        RtlFreeOemString(&OemName);
        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }
    }


    if (ARGUMENT_PRESENT(Transport)) {

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        ResourceLocked = FALSE;

        Status = BowserCreateTransportName(Transport, NewName);
    } else {
        ADD_TRANSPORT_NAME_CONTEXT context;

        context.NameToAdd = *NameToAdd;
        context.NameType = NameType;

        InitializeListHead(&context.ListHead);

        Status = BowserForEachTransportInDomain( DomainInfo, AddTransportName, &context);

        //
        //  Since we will reference this name and transport while we
        //  are processing the list, we want to release the database resource
        //  now.
        //

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        ResourceLocked = FALSE;

        if (!NT_SUCCESS(Status)) {
            WaitForAddNameOperation(&context);
            goto ReturnStatus;
        }

        Status = WaitForAddNameOperation(&context);

    }

ReturnStatus:

    if (ResourceLocked) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  Delete this transport.
        //

        if (NewName != NULL) {

            if (!ARGUMENT_PRESENT(Transport)) {

                //
                //  Clean out any names that we may have added already.
                //

                BowserDeleteNamesInDomain( DomainInfo, &NewName->Name, NewName->NameType );
            }

        }

    }

    if (NewName != NULL) {
        BowserDereferenceName(NewName);
    }

    return Status;

}

NTSTATUS
BowserAddDefaultNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
/*++

Routine Description:

    Add the default names for a newly created transport.

    Add the ComputerName<00>, Domain<00>, Domain<1C>, and other domains.

    All of the newly added names are added in parallel to increase performance.

Arguments:

    Transport - The names are added to this transport.

    Context - If specified, a pointer to the UNICODE_STRING structure specifying
        the domain name to register.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS TempStatus;

    PLIST_ENTRY NameEntry;

    ADD_TRANSPORT_NAME_CONTEXT AddNameContext;
    PDOMAIN_INFO DomainInfo = Transport->DomainInfo;

    UNICODE_STRING EmulatedComputerName;
    UNICODE_STRING EmulatedDomainName;

    PAGED_CODE();


    //
    // Build the domain name and computer name to add.
    //

    EmulatedComputerName = DomainInfo->DomUnicodeComputerName;

    if ( Context == NULL ) {
        EmulatedDomainName = DomainInfo->DomUnicodeDomainName;
    } else {
        EmulatedDomainName = *((PUNICODE_STRING)Context);
    }

    //
    // Initialize the queue of threads
    //

    InitializeListHead(&AddNameContext.ListHead);

    //
    // Add the computer<00> name
    //

    AddNameContext.NameToAdd = EmulatedComputerName;
    AddNameContext.NameType = ComputerName;

    Status = AddTransportName( Transport, &AddNameContext);

    if ( !NT_SUCCESS(Status) ) {
        goto ReturnStatus;
    }

    //
    // Add the domain<00> name
    //

    AddNameContext.NameToAdd = EmulatedDomainName;
    AddNameContext.NameType = PrimaryDomain;

    Status = AddTransportName( Transport, &AddNameContext);

    if ( !NT_SUCCESS(Status) ) {
        goto ReturnStatus;
    }

    //
    // Add the domain<1C> name
    //

    if (BowserData.IsLanmanNt) {
        AddNameContext.NameToAdd = EmulatedDomainName;
        AddNameContext.NameType = DomainName;

        Status = AddTransportName( Transport, &AddNameContext);

        if ( !NT_SUCCESS(Status) ) {
            goto ReturnStatus;
        }
    }

    //
    // Add each of the OtherDomain<00> names
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    for (NameEntry = BowserNameHead.Flink;
         NameEntry != &BowserNameHead ;
         NameEntry = NameEntry->Flink) {

        PBOWSER_NAME Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        //
        // Only add the OtherDomains
        //

        if ( Name->NameType == OtherDomain ) {
            AddNameContext.NameToAdd = Name->Name;
            AddNameContext.NameType = OtherDomain;

            Status = AddTransportName( Transport, &AddNameContext);

            if ( !NT_SUCCESS(Status) ) {
                ExReleaseResourceLite(&BowserTransportDatabaseResource);
                goto ReturnStatus;
            }
        }

    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    Status = STATUS_SUCCESS;


ReturnStatus:

    //
    // Wait for any started threads to complete.
    //

    TempStatus = WaitForAddNameOperation(&AddNameContext);

    if ( NT_SUCCESS(Status) ) {
        Status = TempStatus;
    }

    return Status;

}

NTSTATUS
BowserDeleteDefaultDomainNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )

/*++

Routine Description:

    Worker routine to re-add all of the default names for the transport.

    This routine will be called when the domain is renamed.  All of the previous
    default names should be removed and the new default names should be added.

Arguments:

    Transport - Transport to add the names on.

    Context - Pointer to UNICODE_STRING identifying the domain name to remove

Return Value:

    NTSTATUS - Status of resulting operation.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING NameToRemove = (PUNICODE_STRING) Context;
    PAGED_CODE();

    //
    // This is a cleanup operation.  Don't fail if we can't remove the name.
    //
    (VOID) BowserDeleteTransportNameByName( Transport, NameToRemove, PrimaryDomain );
    (VOID) BowserDeleteTransportNameByName( Transport, NameToRemove, DomainName );

    return STATUS_SUCCESS;
}

NTSTATUS
WaitForAddNameOperation(
    IN PADD_TRANSPORT_NAME_CONTEXT Context
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS LocalStatus;

    PAGED_CODE();

    while (!IsListEmpty(&Context->ListHead)) {
        PLIST_ENTRY Entry;
        PADD_TRANSPORT_NAME_STRUCTURE addNameStruct;

        Entry = RemoveHeadList(&Context->ListHead);
        addNameStruct = CONTAINING_RECORD(Entry, ADD_TRANSPORT_NAME_STRUCTURE, Link);

        //
        //  We need to call the Nt version of this API, since we only have
        //  the handle to the thread.
        //
        //  Also note that we call the Nt version of the API.  This works
        //  because we are running in the FSP, and thus PreviousMode is Kernel.
        //

        LocalStatus = ZwWaitForSingleObject(addNameStruct->ThreadHandle,
                                    FALSE,
                                    NULL);

        ASSERT (NT_SUCCESS(LocalStatus));

        LocalStatus = ZwClose(addNameStruct->ThreadHandle);

        ASSERT (NT_SUCCESS(LocalStatus));

        //
        //  We've waited for this name to be added, now check its status.
        //

        if (!NT_SUCCESS(addNameStruct->Status)) {
            status = addNameStruct->Status;
        }

        FREE_POOL(addNameStruct);
    }

    //
    //  If we were able to successfully add all the names, then Status will
    //  still be STATUS_SUCCESS, however if any of the addnames failed,
    //  Status will be set to the status of whichever one of them failed.
    //

    return status;

}
NTSTATUS
AddTransportName(
    IN PTRANSPORT Transport,
    IN PVOID Ctx
    )
{
    PADD_TRANSPORT_NAME_CONTEXT context = Ctx;
    PADD_TRANSPORT_NAME_STRUCTURE addNameStructure;
    NTSTATUS status;
    PAGED_CODE();

    addNameStructure = ALLOCATE_POOL(PagedPool, sizeof(ADD_TRANSPORT_NAME_STRUCTURE), POOL_ADDNAME_STRUCT);

    if (addNameStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    addNameStructure->ThreadHandle = NULL;

    addNameStructure->Transport = Transport;

    if ( Transport )
    {
        // reference transport so it doesn't get deleted under us.
        BowserReferenceTransport(Transport);
    }

    addNameStructure->NameToAdd = context->NameToAdd;
    addNameStructure->NameType = context->NameType;

    status = PsCreateSystemThread(&addNameStructure->ThreadHandle,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    AsyncCreateTransportName,
                                    addNameStructure);

    if (!NT_SUCCESS(status)) {

        if ( Transport )
        {
            // dereference transport upon failure
            BowserDereferenceTransport(Transport);
        }

        FREE_POOL(addNameStructure);
        return status;
    }

    InsertTailList(&context->ListHead, &addNameStructure->Link);

    return STATUS_SUCCESS;

}

VOID
AsyncCreateTransportName(
    IN PVOID Ctx
    )
{
    PADD_TRANSPORT_NAME_STRUCTURE context = Ctx;

    PAGED_CODE();

    context->Status = BowserAllocateName(
                          &context->NameToAdd,
                          context->NameType,
                          context->Transport,
                          NULL );

    if ( context->Transport )
    {
        // referenced in calling AddTransportName()
        BowserDereferenceTransport(context->Transport);
    }
    //
    //  We're all done with this thread, terminate now.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);

}


NTSTATUS
BowserDeleteNameByName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING NameToDelete,
    IN DGRECEIVER_NAME_TYPE NameType
    )

/*++

Routine Description:

    This routine deletes a browser name

Arguments:

    IN PBOWSER_NAME Name - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PBOWSER_NAME Name = NULL;
    NTSTATUS Status;

    PAGED_CODE();
//    DbgBreakPoint();


    //
    // If the caller is deleting a specific name,
    //  ensure it exists.
    //

    if ( NameToDelete != NULL && NameToDelete->Length != 0 ) {
        Name = BowserFindName(NameToDelete, NameType);

        if (Name == NULL) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    //
    //  If there are still any names associated with this name,
    //  delete them.
    //

    Status = BowserDeleteNamesInDomain( DomainInfo, NameToDelete, NameType );

    //
    //  Remove the reference from the FindName.
    //

    if ( Name != NULL ) {
        BowserDereferenceName(Name);
    }

    return(Status);
}

VOID
BowserDereferenceName (
    IN PBOWSER_NAME Name
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name->ReferenceCount -= 1;

    if (Name->ReferenceCount == 0) {
        BowserDeleteName(Name);
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}


VOID
BowserReferenceName (
    IN PBOWSER_NAME Name
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name->ReferenceCount += 1;

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}


NTSTATUS
BowserForEachName (
    IN PNAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the names and call back the enum
    routine provided with each names.

Arguments:

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY NameEntry, NextEntry;
    PBOWSER_NAME Name = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = BowserNameHead.Flink ;
        NameEntry != &BowserNameHead ;
        NameEntry = NextEntry) {

        Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        BowserReferenceName(Name);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Name, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceName(Name);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = Name->GlobalNext.Flink;

        BowserDereferenceName(Name);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}


NTSTATUS
BowserDeleteName(
    IN PBOWSER_NAME Name
    )
/*++

Routine Description:

    This routine deletes a browser name

Arguments:

    IN PBOWSER_NAME Name - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PAGED_CODE();
    RemoveEntryList(&Name->GlobalNext);

    FREE_POOL(Name);

    return STATUS_SUCCESS;
}

NTSTATUS
BowserDeleteNamesInDomain(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine deletes all the transport names associated with a browser name

Arguments:

    DomainInfo - Identifies the emulated domain to have the specified names removed.

    Name - Specifies the transport name to delete.
        If not specified, all names of the specified name type are deleted.

    NameType - Specifies the name type of the name.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/
{
    NTSTATUS Status;
    BOWSER_NAME BowserName;

    PAGED_CODE();

    BowserName.Name = *Name;
    BowserName.NameType = NameType;

    Status = BowserForEachTransportInDomain( DomainInfo, BowserDeleteNamesWorker, &BowserName );

    return(Status);
}

NTSTATUS
BowserDeleteNamesWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserDeleteNamesInDomain.

    Delete all the specified name for the specified transport.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PBOWSER_NAME Name = (PBOWSER_NAME) Ctx;
    // Note the caller doesn't pass a real PBOWSER_NAME.

    PAGED_CODE();

    //
    // Delete all the specified names for the specified transport.
    //

    Status = BowserDeleteTransportNameByName( Transport, &Name->Name, Name->NameType );

    return Status;

}

PBOWSER_NAME
BowserFindName (
    IN PUNICODE_STRING NameToFind,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine scans the bowser name database to find a particular bowser name

Arguments:

    NameToFind - Supplies the name to find.

    NameType - Type of name to find


Return Value:

    PBOWSER_NAME - Returns the name found.

--*/
{
    PLIST_ENTRY NameEntry;
    PBOWSER_NAME Name;
    NTSTATUS Status;
    OEM_STRING OemName;
    UNICODE_STRING UpcasedName;

    PAGED_CODE();

    //
    //  Uppercase the name.
    //

    Status = RtlUpcaseUnicodeStringToOemString(&OemName, NameToFind, TRUE);

    if (!NT_SUCCESS(Status)) {
        return NULL;
    }

    Status = RtlOemStringToUnicodeString(&UpcasedName, &OemName, TRUE);

    RtlFreeOemString(&OemName);
    if (!NT_SUCCESS(Status)) {
        return NULL;
    }


    //
    // Loop through the list of names finding this one.
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name = NULL;
    for (NameEntry = BowserNameHead.Flink ;
        NameEntry != &BowserNameHead ;
        NameEntry = NameEntry->Flink) {

        Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        if ( Name->NameType == NameType &&
             RtlEqualUnicodeString( &Name->Name, &UpcasedName, FALSE ) ) {

            Name->ReferenceCount += 1;
            break;

        }

        Name = NULL;

    }

    RtlFreeUnicodeString( &UpcasedName );
    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    return Name;

}


NTSTATUS
BowserEnumerateNamesInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT Transport,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    )
/*++

Routine Description:

    This routine will enumerate all the names currently registered by any
    transport.

Arguments:

    DomainInfo - Emulated domain the names are to be enumerated for.
    Transport - Transport names are registered on
            NULL - Any transport.
    OutputBuffer - Buffer to fill with name info.
    OutputBufferSize - Filled in with size of buffer.
    EntriesRead - Filled in with the # of entries returned.
    TotalEntries - Filled in with the total # of entries.
    TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    PVOID              OutputBufferEnd;
    NTSTATUS           Status;
    ENUM_NAMES_CONTEXT Context;
    PVOID              TempOutputBuffer;

    PAGED_CODE();

    TempOutputBuffer = ALLOCATE_POOL(PagedPool,OutputBufferLength,POOL_NAME_ENUM_BUFFER);
    if (TempOutputBuffer == NULL) {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OutputBufferEnd = (PCHAR)TempOutputBuffer+OutputBufferLength;

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    try {
        Context.OutputBufferSize = OutputBufferLength;
        Context.NextOutputBuffer = Context.OutputBuffer = (PDGRECEIVE_NAMES) TempOutputBuffer;
        Context.OutputBufferDisplacement = (ULONG_PTR)((PCHAR)TempOutputBuffer - ((PCHAR)OutputBuffer - OutputBufferDisplacement));
        Context.OutputBufferEnd = OutputBufferEnd;

//        DbgPrint("Enumerate Names: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
//            TempOutputBuffer, OutputBufferLength, OutputBufferEnd);

        if ( Transport == NULL ) {
            Status = BowserForEachTransportInDomain(DomainInfo, EnumerateNamesTransportWorker, &Context);
        } else {
            Status = EnumerateNamesTransportWorker( Transport, &Context);
        }

        *EntriesRead = Context.EntriesRead;
        *TotalEntries = Context.TotalEntries;
        *TotalBytesNeeded = Context.TotalBytesNeeded;

        // Copy the fixed data
        RtlCopyMemory( OutputBuffer,
                       TempOutputBuffer,
                       (ULONG)(((LPBYTE)Context.NextOutputBuffer)-((LPBYTE)Context.OutputBuffer)) );

        // Copy the strings
        RtlCopyMemory( ((LPBYTE)OutputBuffer)+(ULONG)(((LPBYTE)Context.OutputBufferEnd)-((LPBYTE)Context.OutputBuffer)),
                       Context.OutputBufferEnd,
                       (ULONG)(((LPBYTE)OutputBufferEnd)-((LPBYTE)Context.OutputBufferEnd)) );

        if (*EntriesRead == *TotalEntries) {
            try_return(Status = STATUS_SUCCESS);
        } else {
            try_return(Status = STATUS_MORE_ENTRIES);
        }


try_exit:NOTHING;
    } except (BR_EXCEPTION) {

        Status = GetExceptionCode();
    }

    if (TempOutputBuffer != NULL ) {
       FREE_POOL(TempOutputBuffer);
    }

    return Status;

}

NTSTATUS
EnumerateNamesTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserEnumerateNamesInDomain.

    This routine is executed for each transport in the domain.
    It simply calls EnumerateNamesTransportNameWorker for each transport name on the
        transport.

Arguments:

    Transport - Transport whose names are to be added to the context.

    Ctx - Cumulative list of names.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;

    Status = BowserForEachTransportName( Transport, EnumerateNamesTransportNameWorker, Ctx);
    return Status;
}

NTSTATUS
EnumerateNamesTransportNameWorker(
    IN PTRANSPORT_NAME TransportName,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for EnumerateNamesTransportWorker.

    It is called for each of the transport name for each transport in the domain.
    It returns that name (supressing duplicates) in the buffer described in the context.

Arguments:

    TransportName - Transport name to be added to the context.

    Ctx - Cumulative list of names.

Return Value:

    Status of the operation.

--*/
{
    PENUM_NAMES_CONTEXT Context = Ctx;
    PBOWSER_NAME Name = TransportName->PagedTransportName->Name;
    ULONG i;

    PAGED_CODE();

    //
    // Skip Nameless transports
    //
    if ( Name->Name.Length == 0) {
        // Adding an empty name to the list can result w/ AV
        // on client end (see bug 377078).
        return ( STATUS_SUCCESS );
    }

    //
    // Check to see if this name has been packed yet.
    //
    //

    for ( i=0; i<Context->EntriesRead; i++ ) {

        if ( Name->NameType == Context->OutputBuffer[i].Type ) {
            UNICODE_STRING RelocatedString = Context->OutputBuffer[i].DGReceiverName;

            RelocatedString.Buffer = (LPWSTR)
                ((LPBYTE)RelocatedString.Buffer + Context->OutputBufferDisplacement);

            if ( RtlEqualUnicodeString( &RelocatedString, &Name->Name, FALSE ) ) {
                return(STATUS_SUCCESS);
            }
        }

    }

    //
    // This names hasn;t been packed yet,
    //  pack it.
    //

    Context->TotalEntries += 1;

    if ((ULONG_PTR)Context->OutputBufferEnd - (ULONG_PTR)Context->NextOutputBuffer >
                sizeof(DGRECEIVE_NAMES)+Name->Name.Length) {

        PDGRECEIVE_NAMES NameEntry = Context->NextOutputBuffer;

        Context->NextOutputBuffer += 1;
        Context->EntriesRead += 1;

        NameEntry->DGReceiverName = Name->Name;

        BowserPackNtString( &NameEntry->DGReceiverName,
                            Context->OutputBufferDisplacement,
                            (PCHAR)Context->NextOutputBuffer,
                            (PCHAR *)&Context->OutputBufferEnd
                            );

        NameEntry->Type = Name->NameType;

    }

    Context->TotalBytesNeeded += sizeof(DGRECEIVE_NAMES)+Name->Name.Length;


    return(STATUS_SUCCESS);

}

NTSTATUS
BowserpInitializeNames(
    VOID
    )
{
    PAGED_CODE();
    InitializeListHead(&BowserNameHead);

    return STATUS_SUCCESS;
}

VOID
BowserpUninitializeNames(
    VOID
    )
{
    PAGED_CODE();
    ASSERT (IsListEmpty(&BowserNameHead));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowname.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowname.h

Abstract:

    This module defines the name related structures for the NT datagram browser

Author:

    Larry Osterman (LarryO) 1-Jun-1990

Revision History:

    4-Sep-1991  LarryO

        Created

--*/

#ifndef _BOWNAME_
#define _BOWNAME_

struct _TRANSPORT;

typedef struct _BOWSER_NAME {
    CSHORT Signature;
    CSHORT Size;
    ULONG ReferenceCount;
    LIST_ENTRY GlobalNext;
    LIST_ENTRY NameChain;
    UNICODE_STRING Name;                // Text version of this name
    DGRECEIVER_NAME_TYPE NameType;      // Type of this name.
} BOWSER_NAME, *PBOWSER_NAME;


typedef
NTSTATUS
(*PNAME_ENUM_ROUTINE) (
    IN PBOWSER_NAME Name,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachName (
    IN PNAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserAllocateName(
    IN PUNICODE_STRING NameToAdd,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN struct _TRANSPORT *Transport OPTIONAL,
    IN PDOMAIN_INFO DomainInfo
    );

NTSTATUS
BowserDeleteName(
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserDeleteNameByName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType
    );

VOID
BowserReferenceName(
    IN PBOWSER_NAME Name
    );

VOID
BowserDereferenceName(
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserDeleteNameAddresses(
    IN PBOWSER_NAME Name
    );

PBOWSER_NAME
BowserFindName (
    IN PUNICODE_STRING NameToFind,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserEnumerateNamesInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN struct _TRANSPORT *Transport,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
BowserpInitializeNames(
    VOID
    );

VOID
BowserpUninitializeNames(
    VOID
    );

#endif  // _BOWNAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowipx.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtdi.c

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#include <isnkrnl.h>
#include <smbipx.h>
#pragma hdrstop

NTSTATUS
BowserHandleIpxDomainAnnouncement(
    IN PTRANSPORT Transport,
    IN PSMB_IPX_NAME_PACKET NamePacket,
    IN PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement,
    IN DWORD RequestLength,
    IN ULONG ReceiveFlags
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE4BROW, BowserHandleIpxDomainAnnouncement)
#endif

NTSTATUS
BowserIpxDatagramHandler (
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PVOID DatagramData;
    PINTERNAL_TRANSACTION InternalTransaction = NULL;
    ULONG DatagramDataSize;
    PTRANSPORT Transport = TdiEventContext;
    MAILSLOTTYPE Opcode;
    PSMB_IPX_NAME_PACKET NamePacket = Tsdu;
    PSMB_HEADER Smb = (PSMB_HEADER)(NamePacket+1);
    PCHAR ComputerName;
    PCHAR DomainName;
    PTRANSPORT_NAME TransportName = Transport->ComputerName;
    ULONG SmbLength = BytesIndicated - sizeof(SMB_IPX_NAME_PACKET);


    if (BytesAvailable > Transport->DatagramSize) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if (BytesIndicated <= sizeof(SMB_IPX_NAME_PACKET)) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // If we're not fully initialized yet,
    //  simply ignore the packet.
    //
    if (Transport->ComputerName == NULL ) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }


    ComputerName = ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName;
    DomainName = Transport->DomainInfo->DomNetbiosDomainName;

    //
    //  It's not for us, ignore the announcement.
    //

    if (NamePacket->NameType == SMB_IPX_NAME_TYPE_MACHINE) {

        // Mailslot messages are always sent as TYPE_MACHINE even when they're
        // to the DomainName (so allow both).
        if (!RtlEqualMemory(ComputerName, NamePacket->Name, SMB_IPX_NAME_LENGTH) &&
            !RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }
    } else if (NamePacket->NameType == SMB_IPX_NAME_TYPE_WORKKGROUP) {
        if (!RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }
    } else if (NamePacket->NameType != SMB_IPX_NAME_TYPE_BROWSER) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    //  Classify the incoming packet according to it's type.  Depending on
    //  the type, either process it as:
    //
    //  1) A server announcement
    //  2) An incoming mailslot
    //

    Opcode = BowserClassifyIncomingDatagram(Smb, SmbLength,
                                            &DatagramData,
                                            &DatagramDataSize);
    if (Opcode == MailslotTransaction) {

        //
        // BowserHandleMailslotTransaction will always receive the indicated bytes
        // expecting to find the SMB.  Tell the TDI driver we've already consumed
        // the IPX_NAME_PACKET to keep that assumption constant.
        //

        *BytesTaken = sizeof(SMB_IPX_NAME_PACKET);
        return BowserHandleMailslotTransaction(
                    Transport->ComputerName,
                    NamePacket->SourceName,
                    0,                              // No IP address
                    sizeof(SMB_IPX_NAME_PACKET),    // SMB offset into TSDU
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket );

    } else if (Opcode == Illegal) {

        //
        //  This might be illegal because it's a short packet.  In that
        //  case, handle it as if it were a short packet and deal with any
        //  other failures when we have the whole packet.
        //

        if (BytesAvailable != BytesIndicated) {
            return BowserHandleShortBrowserPacket(Transport->ComputerName,
                                                TdiEventContext,
                                                SourceAddressLength,
                                                SourceAddress,
                                                OptionsLength,
                                                Options,
                                                ReceiveDatagramFlags,
                                                BytesAvailable,
                                                BytesTaken,
                                                IoRequestPacket,
                                                BowserIpxDatagramHandler
                                                );
        }

        BowserLogIllegalDatagram( Transport->ComputerName,
                                  Smb,
                                  (USHORT)(SmbLength & 0xffff),
                                  NamePacket->SourceName,
                                  ReceiveDatagramFlags);
        return STATUS_REQUEST_NOT_ACCEPTED;

    } else {
        // PTA_NETBIOS_ADDRESS NetbiosAddress = SourceAddress;

        if (BowserDatagramHandlerTable[Opcode] == NULL) {
            return STATUS_SUCCESS;
        }

        //
        //  If this isn't the full packet, post a receive for it and
        //  handle it when we finally complete the receive.
        //

        if (BytesIndicated != BytesAvailable) {
            return BowserHandleShortBrowserPacket(Transport->ComputerName,
                                                    TdiEventContext,
                                                    SourceAddressLength,
                                                    SourceAddress,
                                                    OptionsLength,
                                                    Options,
                                                    ReceiveDatagramFlags,
                                                    BytesAvailable,
                                                    BytesTaken,
                                                    IoRequestPacket,
                                                    BowserIpxDatagramHandler
                                                    );
        }

        InternalTransaction = DatagramData;

        //
        //  If this is a workgroup announcement (a server announcement for another
        //  workgroup), handle it specially - regardless of the opcode, it's
        //  really a workgroup announcement.
        //

        if (NamePacket->NameType == SMB_IPX_NAME_TYPE_BROWSER) {

            if (Opcode == LocalMasterAnnouncement ) {

                NTSTATUS status;

                //
                //  If we're processing these announcements, then handle this
                //  as a domain announcement.
                //

                if (Transport->MasterBrowser &&
                    Transport->MasterBrowser->ProcessHostAnnouncements) {

                    status = BowserHandleIpxDomainAnnouncement(Transport,
                                            NamePacket,
                                            (PBROWSE_ANNOUNCE_PACKET_1)&InternalTransaction->Union.Announcement,
                                            SmbLength-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Smb),
                                            ReceiveDatagramFlags);
                } else {
                    status = STATUS_REQUEST_NOT_ACCEPTED;
                }

                //
                //  If this request isn't for our domain, we're done with it, if
                //  it's for our domain, then we need to do some more work.
                //

                if (!RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
                    return status;
                }
            } else {

                //
                //  This isn't a master announcement, so ignore it.
                //

                return STATUS_REQUEST_NOT_ACCEPTED;
            }

        }

        //
        //  Figure out which transportname is appropriate for the request:
        //
        //  There are basically 3 choices:
        //
        //      ComputeName (The default)
        //      MasterBrowser (if this is a server announcement)
        //      PrimaryDomain (if this is a request announcement)
        //      Election (if this is a local master announcement)

        if ((Opcode == WkGroupAnnouncement) ||
            (Opcode == HostAnnouncement)) {
            if (Transport->MasterBrowser == NULL ||
                !Transport->MasterBrowser->ProcessHostAnnouncements) {
                return STATUS_REQUEST_NOT_ACCEPTED;
            } else {
                TransportName = Transport->MasterBrowser;
            }

        } else if (Opcode == AnnouncementRequest) {
            TransportName = Transport->PrimaryDomain;

        } else if (Opcode == LocalMasterAnnouncement) {
            if (Transport->BrowserElection != NULL) {
                TransportName = Transport->BrowserElection;
            } else {
                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }

        ASSERT (DatagramDataSize == (SmbLength - ((PCHAR)InternalTransaction - (PCHAR)Smb)));

        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement));

        return BowserDatagramHandlerTable[Opcode](TransportName,
                                            &InternalTransaction->Union.Announcement,
                                            SmbLength-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Smb),
                                            BytesTaken,
                                            SourceAddress,
                                            SourceAddressLength,
                                            &NamePacket->SourceName,
                                            SMB_IPX_NAME_LENGTH,
                                            ReceiveDatagramFlags);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(ReceiveDatagramFlags);
}

NTSTATUS
BowserHandleIpxDomainAnnouncement(
    IN PTRANSPORT Transport,
    IN PSMB_IPX_NAME_PACKET NamePacket,
    IN PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement,
    IN DWORD RequestLength,
    IN ULONG ReceiveFlags
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN PSMB_IPX_NAME_PACKET NamePacket    - The name packet for this request.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;

    DISCARDABLE_CODE(BowserDiscardableCodeSection);

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfDomainAnnouncements, 1);

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    BowserCopyOemComputerName(ViewBuffer->ServerName, NamePacket->Name, SMB_IPX_NAME_LENGTH, ReceiveFlags);

    BowserCopyOemComputerName(ViewBuffer->ServerComment, NamePacket->SourceName, SMB_IPX_NAME_LENGTH, ReceiveFlags);

    if ( DomainAnnouncement->Type & SV_TYPE_NT ) {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM | SV_TYPE_NT;
    } else {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM;
    }

    ASSERT (Transport->MasterBrowser != NULL);

    ViewBuffer->TransportName = Transport->MasterBrowser;

    ViewBuffer->ServerVersionMajor = DomainAnnouncement->VersionMajor;

    ViewBuffer->ServerVersionMinor = DomainAnnouncement->VersionMinor;

    ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&DomainAnnouncement->Periodicity) + 999) / 1000);

    BowserReferenceTransportName(Transport->MasterBrowser);
    BowserReferenceTransport( Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessDomainAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowsecur.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Eyal Schwartz (EyalS) Dec-9-1998

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//
// Extern defined from #include <ob.h>.
// Couldn't include ob.h due to redefinition conflicts. We had attempted to change ntos\makefil0
// so as to include it in ntsrv.h, but decided we shouldn't expose it. This does the job.
//

NTSTATUS
ObGetObjectSecurity(
    IN PVOID Object,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PBOOLEAN MemoryAllocated
    );

VOID
ObReleaseObjectSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN MemoryAllocated
    );



// defines //

// pool tag
#define BOW_SECURITY_POOL_TAG           ( (ULONG)'seLB' )

// local prototypes //
NTSTATUS
BowserBuildDeviceAcl(
    OUT PACL *DeviceAcl
    );
NTSTATUS
BowserCreateAdminSecurityDescriptor(
    IN      PDEVICE_OBJECT      pDevice
    );




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(SECUR, BowserBuildDeviceAcl)
#pragma alloc_text(SECUR, BowserCreateAdminSecurityDescriptor)
#pragma alloc_text(SECUR, BowserInitializeSecurity)
#pragma alloc_text(SECUR, BowserSecurityCheck )
#endif


SECURITY_DESCRIPTOR
*g_pBowSecurityDescriptor = NULL;





// function implementation //
NTSTATUS
BowserBuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators and LocalSystem
    principals full access. All other principals have no access.

    Lifted form \nt\private\ntos\afd\init.c!AfdBuildDeviceAcl()
Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    // SeEnableAccessToExports();

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;

    AclLength = sizeof( ACL )                    +
                2 * sizeof( ACCESS_ALLOWED_ACE ) +
                RtlLengthSid( AdminsSid )         +
                RtlLengthSid( SystemSid )         -
                2 * sizeof( ULONG );

    NewAcl = ExAllocatePoolWithTag(
                 PagedPool,
                 AclLength,
                 BOW_SECURITY_POOL_TAG
                 );

    if (NewAcl == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = RtlCreateAcl (NewAcl, AclLength, ACL_REVISION );

    if (!NT_SUCCESS( Status )) {
        ExFreePool(
            NewAcl
            );
        return( Status );
    }

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION,
                 AccessMask,
                 AdminsSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION,
                 AccessMask,
                 SystemSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    *DeviceAcl = NewAcl;

    return( STATUS_SUCCESS );

} // BowBuildDeviceAcl


NTSTATUS
BowserCreateAdminSecurityDescriptor(
    IN      PDEVICE_OBJECT      pDevice
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to Administrtors and LocalSystem. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.
    LIfted form \nt\private\ntos\afd\init.c!AfdCreateAdminSecurityDescriptor()

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  rawAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  BowSecurityDescriptor;
    ULONG                 BowSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR) &buffer;
    PSECURITY_DESCRIPTOR  localBowAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;


#if 1
//
// this is the way AFD gets the object SD (the preferred way).
//
    status = ObGetObjectSecurity(
                 pDevice,
                 &BowSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        KdPrint((
            "Bowser: Unable to get security descriptor, error: %x\n",
            status
            ));
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }
#else
    //
    // Get a pointer to the security descriptor from the our device object.
    // If we can't access ob api's due to include dependencies, we'll use it directly.
    // ** Need to verify it is legal (I doubt it)**
    // Need to dump this as soon as we can fix ntos\makefil0 to include ob.h in
    // the generated ntsrv.h

    //
    BowSecurityDescriptor = pDevice->SecurityDescriptor;

    if ( !BowSecurityDescriptor )
    {
        KdPrint((
            "Bowser: Unable to get security descriptor, error: %x\n",
            status
            ));
        return  STATUS_INVALID_SECURITY_DESCR;
    }
#endif


    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    status = BowserBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        KdPrint(("Bowser: Unable to create Raw ACL, error: %x\n", status));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                localSecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );

    (VOID) RtlSetDaclSecurityDescriptor(
                localSecurityDescriptor,
                TRUE,
                rawAcl,
                FALSE
                );

    //
    // Make a copy of the Bow descriptor. This copy will be the raw descriptor.
    //
    BowSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      BowSecurityDescriptor
                                      );

    localBowAdminSecurityDescriptor = ExAllocatePoolWithTag (
                                        PagedPool,
                                        BowSecurityDescriptorLength,
                                        BOW_SECURITY_POOL_TAG
                                        );

    if (localBowAdminSecurityDescriptor == NULL) {
        KdPrint(("Bowser: couldn't allocate security descriptor\n"));
        goto error_exit;
    }

    RtlMoveMemory(
        localBowAdminSecurityDescriptor,
        BowSecurityDescriptor,
        BowSecurityDescriptorLength
        );

    g_pBowSecurityDescriptor = localBowAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &g_pBowSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        KdPrint(("Bowser: SeSetSecurity failed, %lx\n", status));
        ASSERT (g_pBowSecurityDescriptor==localBowAdminSecurityDescriptor);
        ExFreePool (g_pBowSecurityDescriptor);
        g_pBowSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (g_pBowSecurityDescriptor!=localBowAdminSecurityDescriptor) {
        ExFreePool (localBowAdminSecurityDescriptor);
    }

    status = STATUS_SUCCESS;

error_exit:

#if 1
//
// see remark above
//
    ObReleaseObjectSecurity(
        BowSecurityDescriptor,
        memoryAllocated
        );
#endif

    if (rawAcl!=NULL) {
        ExFreePool(
            rawAcl
            );
    }

    return(status);
}




NTSTATUS
BowserInitializeSecurity(
    IN      PDEVICE_OBJECT      pDevice
    )
/*++

Routine Description (BowserInitializeSecurity):

    Initialize Bowser security.

    - Create default bowser security descriptor based on device sercurity

Arguments:

    device:  opened device


Return Value:




Remarks:
    None.


--*/
{

    NTSTATUS Status;

    if ( g_pBowSecurityDescriptor )
    {
        return STATUS_SUCCESS;
    }

    ASSERT(pDevice);

    Status =  BowserCreateAdminSecurityDescriptor ( pDevice );

    return Status;
}




BOOLEAN
BowserSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    )
/*++

Routine Description:

    Lifted as is from \\index1\src\nt\private\ntos\afd\create.c!AfdPerformSecurityCheck

    Compares security context of the endpoint creator to that
    of the administrator and local system.

    Note: This is currently called only on IOCTL Irps. IOCRTLs don't have a create security
    context (only creates...), thus we should always capture the security context rather
    then attempting to extract it from the IrpSp.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PSECURITY_SUBJECT_CONTEXT pSubjectContext = &SubjectContext;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    PAGED_CODE();

    ASSERT (g_pBowSecurityDescriptor);

    //
    // Get security context from process.
    //

    SeCaptureSubjectContext(&SubjectContext);
    SeLockSubjectContext(pSubjectContext);

    //
    // Build access evaluation:
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();
    RtlMapGenericMask( &AccessMask, GenericMapping );


    //
    // AccessCheck test
    //
    accessGranted = SeAccessCheck(
                        g_pBowSecurityDescriptor,
                        pSubjectContext,
                        TRUE,
                        AccessMask,
                        0,
                        NULL,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );


    //
    // Verify consistency.
    //
#if DBG
    if (accessGranted) {
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
#endif

    //
    // Unlock & Release security subject context
    //
    SeUnlockSubjectContext(pSubjectContext);
    SeReleaseSubjectContext(pSubjectContext);

    return accessGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowsecur.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bowipx.h

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Eyal Schwartz (EyalS) 9-Dec-1998

Revision History:


--*/

#ifndef _BOWSECUR_
#define _BOWSECUR_

extern
SECURITY_DESCRIPTOR
*g_pBowSecurityDescriptor;


NTSTATUS
BowserInitializeSecurity(
    IN      PDEVICE_OBJECT      pDevice
    );

BOOLEAN
BowserSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    );



#endif          // _BOWSECUR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowtypes.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtypes.h

Abstract:

    This module contains all of the structure signature definitions for the
    NT datagram browser

Author:

    Larry Osterman (LarryO) 06-May-1991

Revision History:

    06-May-1991 LarryO

        Created

--*/

#ifndef _BOWSERTYPES_
#define _BOWSERTYPES_

#define STRUCTURE_SIGNATURE_WORK_QUEUE          0x0001
#define STRUCTURE_SIGNATURE_TRANSPORT           0x0002
#define STRUCTURE_SIGNATURE_TRANSPORTNAME       0x0003
#define STRUCTURE_SIGNATURE_VIEW_BUFFER         0x0004
#define STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY      0x0005
#define STRUCTURE_SIGNATURE_BOWSER_NAME         0x0006
#define STRUCTURE_SIGNATURE_MAILSLOT_BUFFER     0x0007
#define STRUCTURE_SIGNATURE_PAGED_TRANSPORT     0x0008
#define STRUCTURE_SIGNATURE_PAGED_TRANSPORTNAME 0x0009

#endif  // _BOWSERTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowtdi.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtdi.c

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#include <isnkrnl.h>
#include <smbipx.h>
#include <nbtioctl.h>
#pragma hdrstop

typedef struct _ENUM_TRANSPORTS_CONTEXT {
    PVOID OutputBuffer;
    PVOID OutputBufferEnd;
    PVOID LastOutputBuffer;         //  Points to the last entry in the list.
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
} ENUM_TRANSPORTS_CONTEXT, *PENUM_TRANSPORTS_CONTEXT;

NTSTATUS
EnumerateTransportsWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    );

ERESOURCE
BowserTransportDatabaseResource = {0};

//
// Code for tracking missing frees.
//

#define BR_ONE_D_STACK_SIZE 5
typedef struct _BrOneD {
    ULONG NameAdded;
    ULONG NameFreed;
    ULONG NameAddFailed;
    ULONG NameFreeFailed;
    ULONG NameAddStack[BR_ONE_D_STACK_SIZE];
    ULONG NameFreeStack[BR_ONE_D_STACK_SIZE];
} BR_ONE_D;
BR_ONE_D BrOneD;

//
//
//  Forward definitions of local routines.
//



NTSTATUS
BowserpTdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID TransportName
    );


NTSTATUS
BowserDetermineProviderInformation(
    IN PUNICODE_STRING TransportName,
    OUT PTDI_PROVIDER_INFO ProviderInfo,
    OUT PULONG IpSubnetNumber
    );

NTSTATUS
UnbindTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
BowserpTdiRemoveAddresses(
    IN PTRANSPORT Transport
    );

VOID
BowserDeleteTransport(
    IN PTRANSPORT Transport
    );

VOID
BowserpFreeTransport(
    IN PTRANSPORT Transport
    );



NTSTATUS
BowserSubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    );


NTSTATUS
BowserCompleteTdiRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CompleteSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    );

NTSTATUS
BowserEnableIpxDatagramSocket(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserOpenNetbiosAddress(
    IN PPAGED_TRANSPORT_NAME PagedTransportName,
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

VOID
BowserCloseNetbiosAddress(
    IN PTRANSPORT_NAME TransportName
    );

VOID
BowserCloseAllNetbiosAddresses(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserSendDatagram (
    IN PTRANSPORT Transport,
    IN PVOID RecipientAddress,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WaitForCompletion,
    IN PSTRING DestinationAddress OPTIONAL,
    IN BOOLEAN IsHostAnnouncment
    );

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN USHORT Socket
    );

NTSTATUS
BowserIssueTdiAction (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PVOID Action,
    IN ULONG ActionSize
    );

NTSTATUS
GetNetworkAddress (
    IN PTRANSPORT_NAME TransportName
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserTdiAllocateTransport)
#pragma alloc_text(PAGE, BowserUnbindFromAllTransports)
#pragma alloc_text(PAGE, UnbindTransportWorker)
#pragma alloc_text(PAGE, BowserFreeTransportByName)
#pragma alloc_text(PAGE, BowserTransportFlags)
#pragma alloc_text(PAGE, BowserEnumerateTransports)
#pragma alloc_text(PAGE, EnumerateTransportsWorker)
#pragma alloc_text(PAGE, BowserDereferenceTransport)
#pragma alloc_text(PAGE, BowserCreateTransportName)
#pragma alloc_text(PAGE, BowserpTdiRemoveAddresses)
#pragma alloc_text(PAGE, BowserFindTransportName)
#pragma alloc_text(PAGE, BowserFreeTransportName)
#pragma alloc_text(PAGE, BowserDeleteTransport)
#pragma alloc_text(PAGE, BowserpFreeTransport)
#pragma alloc_text(PAGE, BowserpTdiSetEventHandler)
#pragma alloc_text(PAGE, BowserBuildTransportAddress)
#pragma alloc_text(PAGE, BowserUpdateProviderInformation)
#pragma alloc_text(PAGE, BowserDetermineProviderInformation)
#pragma alloc_text(PAGE, BowserFindTransport)
#pragma alloc_text(PAGE, BowserForEachTransport)
#pragma alloc_text(PAGE, BowserForEachTransportName)
#pragma alloc_text(PAGE, BowserDeleteTransportNameByName)
#pragma alloc_text(PAGE, BowserSubmitTdiRequest)
#pragma alloc_text(PAGE, BowserSendDatagram)
#pragma alloc_text(PAGE, BowserSendSecondClassMailslot)
#pragma alloc_text(PAGE, BowserSendRequestAnnouncement)
#pragma alloc_text(INIT, BowserpInitializeTdi)
#pragma alloc_text(PAGE, BowserpUninitializeTdi)
#pragma alloc_text(PAGE, BowserDereferenceTransportName)
#pragma alloc_text(PAGE, BowserEnableIpxDatagramSocket)
#pragma alloc_text(PAGE, BowserOpenNetbiosAddress)
#pragma alloc_text(PAGE, BowserCloseNetbiosAddress)
#pragma alloc_text(PAGE, BowserCloseAllNetbiosAddresses)
#pragma alloc_text(PAGE, OpenIpxSocket)
#pragma alloc_text(PAGE, BowserIssueTdiAction)

#pragma alloc_text(PAGE4BROW, BowserCompleteTdiRequest)
#pragma alloc_text(PAGE4BROW, CompleteSendDatagram)
#endif

//
// Flag to indicate that a network isn't an IP network
//
#define BOWSER_NON_IP_SUBNET 0xFFFFFFFF


NTSTATUS
BowserTdiAllocateTransport (
    PUNICODE_STRING TransportName,
    PUNICODE_STRING EmulatedDomainName,
    PUNICODE_STRING EmulatedComputerName
    )

/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:

    TransportName - Supplies the name of the transport provider

    EmulatedDomainName - Supplies the name of the domain being emulated

    EmulatedComputerName - Supplies the name of the computer in the emulated domain.


Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PTRANSPORT NewTransport;
    BOOLEAN ResourceAcquired = FALSE;

    PAGED_CODE();

//    DbgBreakPoint();

    dlog(DPRT_TDI, ("%wZ: %wZ: BowserTdiAllocateTransport\n", EmulatedDomainName, TransportName));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    ResourceAcquired = TRUE;


    NewTransport = BowserFindTransport(TransportName, EmulatedDomainName );
    dprintf(DPRT_REF, ("Called Find transport %lx from BowserTdiAllocateTransport.\n", NewTransport));

    if (NewTransport == NULL) {
        PLIST_ENTRY NameEntry;
        PPAGED_TRANSPORT PagedTransport = NULL;
        PCHAR Where;
        ULONG PagedTransportSize;

        //
        // Allocate and initialize the constant parts of the transport structure.
        //

        NewTransport = ALLOCATE_POOL(NonPagedPool, sizeof(TRANSPORT), POOL_TRANSPORT);

        if (NewTransport == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        RtlZeroMemory( NewTransport, sizeof(TRANSPORT) );

        NewTransport->Signature = STRUCTURE_SIGNATURE_TRANSPORT;
        NewTransport->Size = sizeof(TRANSPORT);

        //
        // One reference for the rest of this procedure.
        //
        // We increment it later when we insert it in the global list.
        //
        NewTransport->ReferenceCount = 1;


        ExInitializeResourceLite(&NewTransport->BrowserServerListResource);

        KeInitializeEvent(&NewTransport->GetBackupListComplete, NotificationEvent, TRUE);

        ExInitializeResourceLite(&NewTransport->Lock);

        BowserInitializeIrpQueue(&NewTransport->BecomeBackupQueue);

        BowserInitializeIrpQueue(&NewTransport->BecomeMasterQueue);

        BowserInitializeIrpQueue(&NewTransport->FindMasterQueue);

        BowserInitializeIrpQueue(&NewTransport->WaitForMasterAnnounceQueue);

        BowserInitializeIrpQueue(&NewTransport->WaitForNewMasterNameQueue);

        BowserInitializeIrpQueue(&NewTransport->ChangeRoleQueue);

        BowserInitializeTimer(&NewTransport->ElectionTimer);

        BowserInitializeTimer(&NewTransport->FindMasterTimer);

        INITIALIZE_ANNOUNCE_DATABASE(NewTransport);



        //
        // Allocate and initialize the constant parts of the paged transport structure.
        //

        PagedTransportSize =sizeof(PAGED_TRANSPORT) +
                            max(sizeof(TA_IPX_ADDRESS), sizeof(TA_NETBIOS_ADDRESS)) +
                            sizeof(WCHAR) +     // alignment
                            (LM20_CNLEN+1)*sizeof(WCHAR) +
                            TransportName->Length + sizeof(WCHAR);


        PagedTransport = NewTransport->PagedTransport =
            ALLOCATE_POOL(PagedPool, PagedTransportSize, POOL_PAGED_TRANSPORT);

        if (PagedTransport == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        RtlZeroMemory( PagedTransport, PagedTransportSize );

        PagedTransport->NonPagedTransport = NewTransport;


        PagedTransport->Signature = STRUCTURE_SIGNATURE_PAGED_TRANSPORT;
        PagedTransport->Size = sizeof(PAGED_TRANSPORT);

        InitializeListHead(&PagedTransport->GlobalNext);
        InitializeListHead(&PagedTransport->NameChain);

        PagedTransport->Role = None;

        PagedTransport->IpSubnetNumber = BOWSER_NON_IP_SUBNET;

        PagedTransport->DisabledTransport = TRUE;
        PagedTransport->PointToPoint = FALSE;


        RtlInitializeGenericTable(&PagedTransport->AnnouncementTable,
                            BowserCompareAnnouncement,
                            BowserAllocateAnnouncement,
                            BowserFreeAnnouncement,
                            NULL);

        RtlInitializeGenericTable(&PagedTransport->DomainTable,
                            BowserCompareAnnouncement,
                            BowserAllocateAnnouncement,
                            BowserFreeAnnouncement,
                            NULL);

        InitializeListHead(&PagedTransport->BackupBrowserList);

        PagedTransport->NumberOfBackupServerListEntries = 0;


        // Put the MasterBrowserAddress at the end of the allocated buffer
        Where = (PCHAR)(PagedTransport+1);
        PagedTransport->MasterBrowserAddress.Buffer = Where;
        PagedTransport->MasterBrowserAddress.MaximumLength = max(sizeof(TA_IPX_ADDRESS),
                                                                 sizeof(TA_NETBIOS_ADDRESS));
        Where += PagedTransport->MasterBrowserAddress.MaximumLength;


        // Put the MasterName at the end of the allocated buffer
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        PagedTransport->MasterName.Buffer = (LPWSTR) Where;
        PagedTransport->MasterName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);
        Where += PagedTransport->MasterName.MaximumLength;


        // Put the TransportName at the end of the allocated buffer
        PagedTransport->TransportName.Buffer = (LPWSTR) Where;
        PagedTransport->TransportName.MaximumLength = TransportName->Length + sizeof(WCHAR);
        RtlCopyUnicodeString(&PagedTransport->TransportName, TransportName);
        Where += PagedTransport->TransportName.MaximumLength;


        //
        // Make this transport a part of a domain.
        //

        NewTransport->DomainInfo = BowserCreateDomain( EmulatedDomainName, EmulatedComputerName );

        if ( NewTransport->DomainInfo == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ReturnStatus;
        }

        //
        // Get info from the provider
        //  (e.g., RAS, Wannish, DatagramSize)

        Status= BowserUpdateProviderInformation( PagedTransport );

        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }

        PagedTransport->Flags = 0;


        //
        //  We ignore any and all errors that occur when we open the IPX socket.
        //


        //
        // Open the IPX mailslot socket.
        //

        Status = OpenIpxSocket(
                    &PagedTransport->IpxSocketHandle,
                    &NewTransport->IpxSocketFileObject,
                    &NewTransport->IpxSocketDeviceObject,
                    &PagedTransport->TransportName,
                    SMB_IPX_MAILSLOT_SOCKET
                    );

        if ( NT_SUCCESS(Status) ) {
            PagedTransport->Flags |= DIRECT_HOST_IPX;
            // We'll use type 20 packets to increase the reach of broadcasts
            // so don't treat this as a wannish protocol.
            PagedTransport->Wannish = FALSE;
        }

        //
        // Create the names for this transport.
        //  (Only if the caller asked us to)
        //
        // Being in the global list constitutes a reference.
        //

        InsertTailList(&BowserTransportHead, &PagedTransport->GlobalNext);
        BowserReferenceTransport( NewTransport );

        //
        // The names are added asynchronously in other threads that require this
        // resource.
        //
        if ( ResourceAcquired ) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            ResourceAcquired = FALSE;
        }

        Status = BowserAddDefaultNames( NewTransport, NULL );

        if ( !NT_SUCCESS(Status) ) {
            goto ReturnStatus;
        }


        //
        // Start receiving broadcasts on IPX now that the names exist.
        //

        if ( PagedTransport->Flags & DIRECT_HOST_IPX ) {
            //
            // Acquire the lock while referencing IpxSocket*
            ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
            ResourceAcquired = TRUE;
            BowserEnableIpxDatagramSocket(NewTransport);
        }

        //
        // Notify services that this transport is now bound
        //

        BowserSendPnp( NlPnpTransportBind,
                       NULL,    // All hosted domains
                       &PagedTransport->TransportName,
                       BowserTransportFlags(PagedTransport) );

    }

    Status = STATUS_SUCCESS;

ReturnStatus:

    if ( ResourceAcquired ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  Delete the transport.
        //

        if ( NewTransport != NULL ) {
            // Remove the global reference if in global list
            BowserDeleteTransport (NewTransport);
        }

    }

    // Remove the local reference
    if ( NewTransport != NULL ) {
        BowserDereferenceTransport( NewTransport );
    }

    return Status;
}

NTSTATUS
BowserUnbindFromAllTransports(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserForEachTransport(UnbindTransportWorker, NULL);

#if DBG
    if (NT_SUCCESS(Status)) {
        ASSERT (IsListEmpty(&BowserTransportHead));
    }
#endif
    return Status;
}


NTSTATUS
UnbindTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserUnbindFromAllTransports.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    //  Dereference the reference caused by the transport bind.
    //

    BowserDeleteTransport(Transport);

    //
    //  Return success.  We're done.
    //

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Ctx);
}




NTSTATUS
BowserFreeTransportByName (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName
    )

/*++

Routine Description:

    This routine will deallocate an allocated transport

Arguments:

    TransportName - Supplies a pointer to the name of the transport to free

    EmulatedDomainName - Name of the emulated domain whose transport is to be freed

Return Value:

    None.

--*/
{
    PTRANSPORT Transport;

    PAGED_CODE();
    dlog(DPRT_TDI, ("%wZ: %wZ: BowserFreeTransportByName: Remove transport\n", EmulatedDomainName, TransportName));

    Transport = BowserFindTransport(TransportName, EmulatedDomainName );
    dprintf(DPRT_REF, ("Called Find transport %lx from BowserFreeTransportByName.\n", Transport));

    if (Transport == NULL) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Remove the reference from the binding.
    //

    BowserDeleteTransport(Transport);

    //
    //  Remove the reference from the FindTransport.
    //

    BowserDereferenceTransport(Transport);

    return STATUS_SUCCESS;
}


NTSTATUS
BowserEnumerateTransports (
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement)
/*++

Routine Description:

    This routine will enumerate the servers in the bowsers current announcement
    table.

Arguments:

    IN ULONG ServerTypeMask - Mask of servers to return.
    IN PUNICODE_STRING DomainName OPTIONAL - Domain to filter (all if not specified)
    OUT PVOID OutputBuffer - Buffer to fill with server info.
    IN  ULONG OutputBufferSize - Filled in with size of buffer.
    OUT PULONG EntriesRead - Filled in with the # of entries returned.
    OUT PULONG TotalEntries - Filled in with the total # of entries.
    OUT PULONG TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    PVOID OutputBufferEnd;
    NTSTATUS Status;
    ENUM_TRANSPORTS_CONTEXT Context;
    PDOMAIN_INFO DomainInfo = NULL;
    PAGED_CODE();

    OutputBufferEnd = (PCHAR)OutputBuffer+OutputBufferLength;

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    try {
        Context.OutputBufferSize = OutputBufferLength;
        Context.OutputBuffer = OutputBuffer;
        Context.OutputBufferDisplacement = OutputBufferDisplacement;
        Context.OutputBufferEnd = OutputBufferEnd;
        Context.LastOutputBuffer = OutputBuffer;

        dlog(DPRT_FSCTL, ("Enumerate Transports: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
            OutputBuffer, OutputBufferLength, OutputBufferEnd));

        try {
            //
            // Find the primary domain.
            //
            // This call is intended to return the actual transport names and not the
            // network structure which are duplicated for each emulated domain.
            //

            DomainInfo = BowserFindDomain( NULL );
            // Failure case handled below

            //
            // Enumerate the transports.
            //
            if ( DomainInfo != NULL ) {
                Status = BowserForEachTransportInDomain( DomainInfo, EnumerateTransportsWorker, &Context);
            }

            *EntriesRead = Context.EntriesRead;
            *TotalEntries = Context.TotalEntries;
            *TotalBytesNeeded = Context.TotalBytesNeeded;

            if (*EntriesRead != 0) {
                ((PLMDR_TRANSPORT_LIST )Context.LastOutputBuffer)->NextEntryOffset = 0;
            }

            dlog(DPRT_FSCTL, ("TotalEntries: %lx EntriesRead: %lx, TotalBytesNeeded: %lx\n", *TotalEntries, *EntriesRead, *TotalBytesNeeded));

            if (*EntriesRead == *TotalEntries) {
                try_return(Status = STATUS_SUCCESS);
            } else {
                try_return(Status = STATUS_MORE_ENTRIES);
            }
try_exit:NOTHING;
        } finally {
            if ( DomainInfo != NULL ) {
                BowserDereferenceDomain( DomainInfo );
            }
        }
    }
    except ( BR_EXCEPTION ) {
        Status = GetExceptionCode();
    }

    return Status;

}

ULONG
BowserTransportFlags(
    IN PPAGED_TRANSPORT PagedTransport
    )
/*++

Routine Description:

    Return the user mode transport flags for this transport.

Arguments:

    PageTransport - Transport to return the flags for.

Return Value:


    The appropriate of the following flags:
        LMDR_TRANSPORT_WANNISH
        LMDR_TRANSPORT_RAS
        LMDR_TRANSPORT_IPX

--*/
{
    ULONG TransportFlags = 0;
    PAGED_CODE();

    if (PagedTransport->Wannish) {
        TransportFlags |= LMDR_TRANSPORT_WANNISH;
    }

    if (PagedTransport->IsPrimaryDomainController) {
        TransportFlags |= LMDR_TRANSPORT_PDC;
    }

    if (PagedTransport->PointToPoint) {
        TransportFlags |= LMDR_TRANSPORT_RAS;
    }

    if (PagedTransport->Flags & DIRECT_HOST_IPX) {
        TransportFlags |= LMDR_TRANSPORT_IPX;
    }

    return TransportFlags;
}


NTSTATUS
EnumerateTransportsWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserEnumerateTransports.

    It is called for each of the serviced transports in the bowser and
    returns the size needed to enumerate the servers received on each transport.

Arguments:

    None.

Return Value:


    None.

--*/
{
    PENUM_TRANSPORTS_CONTEXT Context        = Ctx;
    PPAGED_TRANSPORT         PagedTransport = Transport->PagedTransport;
    ULONG                    SizeNeeded     = sizeof(LMDR_TRANSPORT_LIST);

    PAGED_CODE();

    SizeNeeded += PagedTransport->TransportName.Length+sizeof(WCHAR);
    SizeNeeded =  ROUND_UP_COUNT(SizeNeeded,ALIGN_DWORD);

    Context->TotalEntries += 1;

    if ((ULONG_PTR)Context->OutputBufferEnd - (ULONG_PTR)Context->OutputBuffer > SizeNeeded) {
        PLMDR_TRANSPORT_LIST TransportEntry = (PLMDR_TRANSPORT_LIST)Context->OutputBuffer;

        Context->LastOutputBuffer = Context->OutputBuffer;

        Context->EntriesRead += 1;

        RtlCopyMemory(TransportEntry->TransportName, PagedTransport->TransportName.Buffer, PagedTransport->TransportName.Length+sizeof(WCHAR));

        //
        //  Null terminate the transport name.
        //

        TransportEntry->TransportName[PagedTransport->TransportName.Length/sizeof(WCHAR)] = '\0';

        TransportEntry->TransportNameLength = PagedTransport->TransportName.Length;

        TransportEntry->Flags |= BowserTransportFlags( PagedTransport );

        TransportEntry->NextEntryOffset = SizeNeeded;
        (PUCHAR)(Context->OutputBuffer) += SizeNeeded;
    }

    Context->TotalBytesNeeded += SizeNeeded;
    return(STATUS_SUCCESS);

}

VOID
BowserReferenceTransport(
    IN PTRANSPORT Transport
    )
{

    InterlockedIncrement(&Transport->ReferenceCount);
    dprintf(DPRT_REF, ("Reference transport %lx.  Count now %lx\n", Transport, Transport->ReferenceCount));

}

VOID
BowserDereferenceTransport(
    IN PTRANSPORT Transport
    )
{
    LONG Result;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


    if (Transport->ReferenceCount == 0) {
        InternalError(("Transport Reference Count mismatch\n"));
    }

    Result = InterlockedDecrement(&Transport->ReferenceCount);


    dlog(DPRT_REF, ("Dereference transport %lx.  Count now %lx\n", Transport, Transport->ReferenceCount));

    if (Result == 0) {
        //
        //  And free up the transport itself.
        //

        BowserpFreeTransport(Transport);
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}



NTSTATUS
BowserCreateTransportName (
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )

/*++

Routine Description:

    This routine creates a transport address object.

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    BOOLEAN ResourceAcquired = FALSE;

    PAGED_CODE();
    ASSERT(Transport->Signature == STRUCTURE_SIGNATURE_TRANSPORT);

    dlog(DPRT_TDI,
         ("%s: %ws: BowserCreateTransportName.  Name %wZ (%ld)\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         &Name->Name,
         Name->NameType ));

    //
    //  Link the transport_name structure into the transport list.
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    ResourceAcquired = TRUE;

    TransportName = BowserFindTransportName(Transport, Name);

    if (TransportName != NULL) {

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        return(STATUS_SUCCESS);
    }

#ifdef notdef
    //
    // Simply don't allocate certain names if the transport is disabled
    //

    if ( PagedTransport->DisabledTransport ) {
        if ( Name->NameType == PrimaryDomainBrowser ) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            return STATUS_SUCCESS;
        }
    }
#endif // notdef

    // s.b. assertion that we're attached to the system process
    // ASSERT (IoGetCurrentProcess() == BowserFspProcess);

    //
    //  Allocate a structure to refer to this name on the transport
    //

    TransportName = ALLOCATE_POOL(NonPagedPool, sizeof(TRANSPORT_NAME) +
                                                max(sizeof(TA_NETBIOS_ADDRESS),
                                                    sizeof(TA_IPX_ADDRESS)), POOL_TRANSPORTNAME);

    if (TransportName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto error_cleanup;
    }

    TransportName->PagedTransportName = PagedTransportName =
                                    ALLOCATE_POOL(PagedPool,
                                                  sizeof(PAGED_TRANSPORT_NAME),
                                                  POOL_PAGED_TRANSPORTNAME);

    if (PagedTransportName == NULL) {
        FREE_POOL( TransportName );
        TransportName = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto error_cleanup;
    }

    TransportName->Signature = STRUCTURE_SIGNATURE_TRANSPORTNAME;

    TransportName->Size = sizeof(TRANSPORT_NAME);

    TransportName->PagedTransportName = PagedTransportName;

    // This TransportName is considered to be referenced by the transport via
    // Transport->PagedTransport->NameChain.  The Name->NameChain isn't
    // considered to be a reference.
    //
    // The second reference is a local reference for the lifetime of this routine.
    //
    TransportName->ReferenceCount = 2;

    PagedTransportName->NonPagedTransportName = TransportName;

    PagedTransportName->Signature = STRUCTURE_SIGNATURE_PAGED_TRANSPORTNAME;

    PagedTransportName->Size = sizeof(PAGED_TRANSPORT_NAME);

    PagedTransportName->Name = Name;

    BowserReferenceName(Name);

    TransportName->Transport = Transport;

    // Don't reference the Transport.  When the transport is unbound, we'll
    // make sure all the transport names are removed first.
    // BowserReferenceTransport(Transport);

    PagedTransportName->Handle = NULL;

    TransportName->FileObject = NULL;

    TransportName->DeviceObject = NULL;

    InsertHeadList(&Transport->PagedTransport->NameChain, &PagedTransportName->TransportNext);

    InsertHeadList(&Name->NameChain, &PagedTransportName->NameNext);

    //
    //  If this is an OTHERDOMAIN, we want to process host announcements for
    //  the domain, if it isn't, we want to wait until we become a master.
    //

    if (Name->NameType == OtherDomain) {

        BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

        DISCARDABLE_CODE( BowserDiscardableCodeSection );

        TransportName->ProcessHostAnnouncements = TRUE;
    } else {
        TransportName->ProcessHostAnnouncements = FALSE;
    }

    //
    //  If this name is one of our special names, we want to remember it in
    //  the transport block.
    //

    switch (Name->NameType) {
    case ComputerName:
        Transport->ComputerName = TransportName;
        break;

    case PrimaryDomain:
        //
        // During domain rename we can temporarily have two primary names assigned.
        //  keep track of both names.
        //
        if ( Transport->PrimaryDomain != NULL ) {
            ASSERT( Transport->AltPrimaryDomain == NULL );
            Transport->AltPrimaryDomain = Transport->PrimaryDomain;
        }
        Transport->PrimaryDomain = TransportName;
        break;


    case MasterBrowser:
        Transport->MasterBrowser = TransportName;
        break;

    case BrowserElection:
        Transport->BrowserElection = TransportName;
        break;

    case PrimaryDomainBrowser:
        PagedTransport->IsPrimaryDomainController = TRUE;

        //
        // Notify services we are now a PDC.
        //

        BowserSendPnp(
            NlPnpNewRole,
            &Transport->DomainInfo->DomUnicodeDomainName,
            &Transport->PagedTransport->TransportName,
            BowserTransportFlags(Transport->PagedTransport) );

        break;
    }

    TransportName->TransportAddress.Buffer = (PCHAR)(TransportName+1);
    TransportName->TransportAddress.MaximumLength = max(sizeof(TA_NETBIOS_ADDRESS),
                                                        sizeof(TA_IPX_ADDRESS));

    //
    //  Figure out what this name is, so we can match against it when
    //  a datagram is received.
    //

    Status = BowserBuildTransportAddress(&TransportName->TransportAddress, &Name->Name, Name->NameType, Transport);

    if (!NT_SUCCESS(Status)) {
        goto error_cleanup;
    }

    TransportName->NameType = (CHAR)Name->NameType;

#if DBG
    if (Name->NameType == MasterBrowser) {
        //
        //  make sure that we never become a master without locking the discardable code.
        //

        DISCARDABLE_CODE( BowserDiscardableCodeSection );
    }
#endif

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    ResourceAcquired = FALSE;

    //
    //  On non direct host IPX transports, we need to add the name now.
    //

    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        Status = BowserOpenNetbiosAddress(PagedTransportName, Transport, Name);

        if (!NT_SUCCESS(Status)) {
            goto error_cleanup;
        }
    }

error_cleanup:
    if ( !NT_SUCCESS(Status) ) {
        dlog(DPRT_TDI,
             ("%s: %ws: BowserCreateTransportName fail.  Name %wZ (%ld) Status:%lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             &Name->Name,
             Name->NameType,
             Status ));

        //
        // Remove Transport->PagedTransport->NameChain reference
        //  (Unless another routine already has done that behind our back)
        //
        if (TransportName != NULL) {
            if ( PagedTransportName->TransportNext.Flink != NULL ) {
                BowserDereferenceTransportName(TransportName);
            }
        }
    }

    // Remove the local reference
    if (TransportName != NULL) {
        BowserDereferenceTransportName(TransportName);
    }

    if (ResourceAcquired) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }



    return Status;
}

NTSTATUS
BowserOpenNetbiosAddress(
    IN PPAGED_TRANSPORT_NAME PagedTransportName,
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )
{
    NTSTATUS Status;
    PFILE_FULL_EA_INFORMATION EABuffer = NULL;
    PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle = NULL;
    PFILE_OBJECT FileObject = NULL;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE( );

    try {
        //
        //  Now create the address object for this name.
        //

        EABuffer = ALLOCATE_POOL(PagedPool,
                                 sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                        max(sizeof(TA_NETBIOS_EX_ADDRESS), sizeof(TA_NETBIOS_ADDRESS)),
                                 POOL_EABUFFER);


        if (EABuffer == NULL) {
            try_return(Status = STATUS_INSUFFICIENT_RESOURCES)

        }

        EABuffer->NextEntryOffset = 0;
        EABuffer->Flags = 0;
        EABuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

        RtlCopyMemory(EABuffer->EaName, TdiTransportAddress, EABuffer->EaNameLength+1);

        EABuffer->EaValueLength = sizeof(TA_NETBIOS_ADDRESS);

        ASSERT (TransportName->TransportAddress.Length == sizeof(TA_NETBIOS_ADDRESS));
        RtlCopyMemory( &EABuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH+1],
                       TransportName->TransportAddress.Buffer,
                       EABuffer->EaValueLength );

        dlog(DPRT_TDI,
            ("%s: %ws: Create endpoint of %wZ (%ld) @(%lx)\n",
            Transport->DomainInfo->DomOemDomainName,
            Transport->PagedTransport->TransportName.Buffer,
            &PagedTransportName->Name->Name,
            PagedTransportName->Name->NameType,
            TransportName));

        InitializeObjectAttributes (&AddressAttributes,
                                            &Transport->PagedTransport->TransportName,    // Name
                                            OBJ_CASE_INSENSITIVE,// Attributes
                                            NULL,           // RootDirectory
                                            NULL);          // SecurityDescriptor

        Status = IoCreateFile( &Handle, // Handle
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &AddressAttributes, // Object Attributes
                                    &IoStatusBlock, // Final I/O status block
                                    NULL,           // Allocation Size
                                    FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                    FILE_SHARE_READ,// Sharing attributes
                                    FILE_OPEN_IF,   // Create disposition
                                    0,              // CreateOptions
                                    EABuffer,       // EA Buffer
                                    FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) +
                                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                    sizeof(TA_NETBIOS_ADDRESS), // EA length
                                    CreateFileTypeNone,
                                    NULL,
                                    IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                    IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy

        FREE_POOL(EABuffer);

        EABuffer = NULL;

        if (!NT_SUCCESS(Status)) {

            try_return(Status);

        }

        if (!NT_SUCCESS(Status = IoStatusBlock.Status)) {

            try_return(Status);

        }

        //
        //  Obtain a referenced pointer to the file object.
        //
        Status = ObReferenceObjectByHandle (
                                    Handle,
                                    0,
                                    *IoFileObjectType,
                                    KernelMode,
                                    (PVOID *)&FileObject,
                                    NULL
                                    );

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }



        //
        // Get another reference that lasts for the life of the TransportName
        //
        ObReferenceObject( FileObject );

        //
        //  Get the address of the device object for the endpoint.
        //
        DeviceObject = IoGetRelatedDeviceObject( FileObject );

        //
        // Note: due to bug 140751 we'll first set nbt's handler
        // to get it going & only then we would asign the handles
        // to the global structure. This is in order to prevent
        // execution of BowserCloseNetbiosAddress before setting
        // this handler. Otherwise, we can end up using closed
        // handles.
        //

        //
        // Enable receiving datagrams on this device.
        //
        Status = BowserpTdiSetEventHandler( DeviceObject,
                                            FileObject,
                                            TDI_EVENT_RECEIVE_DATAGRAM,
                                            (PVOID) BowserTdiReceiveDatagramHandler,
                                            TransportName);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        //
        // Tell Netbt to tell us the IP Address of the client.
        //

        if ( Transport->PagedTransport->Wannish ) {
            IO_STATUS_BLOCK IoStatusBlock;

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_NETBT_ENABLE_EXTENDED_ADDR,
                            NULL,
                            0,
                            NULL,
                            0 );

            if ( !NT_SUCCESS(Status) ) {
                dlog(DPRT_TDI, ("%lx: Can't request extended status from netbt\n", TransportName));
                try_return(Status);
            }

            ASSERT(Status != STATUS_PENDING);
        }

        //
        // Save the handles
        //
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        TransportName->FileObject = FileObject;
        TransportName->DeviceObject = DeviceObject;
        PagedTransportName->Handle = Handle;
        Handle = NULL;

        ExReleaseResourceLite(&BowserTransportDatabaseResource);


        dlog(DPRT_TDI, ("BowserCreateTransportName Succeeded.  Name: %lx, Handle: %lx\n", TransportName, PagedTransportName->Handle));
try_exit:NOTHING;
    } finally {
        if (EABuffer != NULL) {
            FREE_POOL(EABuffer);
        }

        if ( FileObject != NULL ) {
            ObDereferenceObject( FileObject );
        }

        if ( Handle != NULL ) {
            (VOID) ZwClose( Handle );
        }

        if (!NT_SUCCESS(Status)) {

            //
            // Count Number of failed adds of 1D name.
            //

            if ( TransportName->NameType == MasterBrowser ) {
                if (BrOneD.NameAddFailed < BR_ONE_D_STACK_SIZE ) {
                    BrOneD.NameAddStack[BrOneD.NameAddFailed] = Status;
                }
                BrOneD.NameAddFailed ++;
            }

            BowserCloseNetbiosAddress( TransportName );
        } else {

            //
            // Count Number of adds of 1D name.
            //

            if ( TransportName->NameType == MasterBrowser ) {
                BrOneD.NameAdded ++;
            }
        }
    }

    return Status;
}

VOID
BowserCloseNetbiosAddress(
    IN PTRANSPORT_NAME TransportName
    )

/*++

Routine Description:

    Closes the Netbios Address for a transport name.

Arguments:

    TransportName - Transport Name whose Netbios address is to be closed.


Return Value:

    None.

--*/

{
    NTSTATUS Status;
    // PTRANSPORT Transport = TransportName->Transport;
    PPAGED_TRANSPORT_NAME PagedTransportName = TransportName->PagedTransportName;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    if (PagedTransportName) {

        if ( PagedTransportName->Handle != NULL ) {
            BOOLEAN ProcessAttached = FALSE;

            if (IoGetCurrentProcess() != BowserFspProcess) {
                KeStackAttachProcess(BowserFspProcess, &ApcState );

                ProcessAttached = TRUE;
            }

            Status = ZwClose( PagedTransportName->Handle );

            if (ProcessAttached) {
                KeUnstackDetachProcess( &ApcState );
            }

            if (!NT_SUCCESS(Status)) {
                dlog(DPRT_TDI, ("BowserCloseNetbiosAddress: Free name %lx failed: %X, %lx Handle: %lx\n", TransportName, Status, PagedTransportName->Handle));

                //
                // Count Number of failed frees of 1D name.
                //

                if ( TransportName->NameType == MasterBrowser ) {
                    if (BrOneD.NameFreeFailed < BR_ONE_D_STACK_SIZE ) {
                        BrOneD.NameFreeStack[BrOneD.NameFreeFailed] = Status;
                    }
                    BrOneD.NameFreeFailed ++;
                }
            } else {

                //
                // Count Number of frees of 1D name.
                //

                if ( TransportName->NameType == MasterBrowser ) {
                    BrOneD.NameFreed ++;
                }
            }

            PagedTransportName->Handle = NULL;
        }
    }

    //
    // Dereference the FileObject ONLY after the handle is closed.
    //  The indication routine references FileObject with no synchronization.
    //  By closing the handle first, I know the TDI driver is out of the
    //  indication routine before I dereference the FileObject.
    //
    if ( TransportName->FileObject != NULL ) {
        ObDereferenceObject( TransportName->FileObject );
        TransportName->FileObject = NULL;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
}




VOID
BowserCloseAllNetbiosAddresses(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine closes all the Netbios address this transport has open
    to the TDI driver.

Arguments:

    Transport - The transport whose Netbios addresses are to be closed.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PLIST_ENTRY NameEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserCloseAllNetbiosAddresses: Close addresses for transport %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         Transport));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = Transport->PagedTransport->NameChain.Flink;
         NameEntry != &Transport->PagedTransport->NameChain;
         NameEntry = NextEntry) {

        PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
        PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

        NextEntry = NameEntry->Flink;

        BowserCloseNetbiosAddress(TransportName);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return;
}

NTSTATUS
BowserEnableIpxDatagramSocket(
    IN PTRANSPORT Transport
    )
{
    NTSTATUS status;
    NWLINK_ACTION action;

    PAGED_CODE( );

    //
    //  Put the endpoint in broadcast reception mode.
    //

    action.Header.TransportId = 'XPIM'; // "MIPX"
    action.Header.ActionCode = 0;
    action.Header.Reserved = 0;
    action.OptionType = TRUE;
    action.BufferLength = sizeof(action.Option);
    action.Option = MIPX_RCVBCAST;

    status = BowserIssueTdiAction(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                (PCHAR)&action,
                sizeof(action)
                );

    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Set the default packet type to 20 to force all browser packets
    // through routers.
    //

    action.Header.TransportId = 'XPIM'; // "MIPX"
    action.Header.ActionCode = 0;
    action.Header.Reserved = 0;
    action.OptionType = TRUE;
    action.BufferLength = sizeof(action.Option);
    action.Option = MIPX_SETSENDPTYPE;
    action.Data[0] = IPX_BROADCAST_PACKET;

    status = BowserIssueTdiAction(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                (PCHAR)&action,
                sizeof(action)
                );

    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Register the browser Receive Datagram event handler.
    //

    status = BowserpTdiSetEventHandler(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                BowserIpxDatagramHandler,
                Transport
                );

    if ( !NT_SUCCESS(status) ) {
//        INTERNAL_ERROR(
//            ERROR_LEVEL_EXPECTED,
//            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
//            status,
//            NULL
//            );
//        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }


    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( Transport->IpxSocketFileObject != NULL ) {
        ObDereferenceObject( Transport->IpxSocketFileObject );
        Transport->IpxSocketFileObject = NULL;
    }
    if ( Transport->PagedTransport->IpxSocketHandle != NULL ) {
        ZwClose( Transport->PagedTransport->IpxSocketHandle );
        Transport->PagedTransport->IpxSocketHandle = NULL;
    }

    return status;
}

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN USHORT Socket
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_FULL_EA_INFORMATION ea;
    TA_IPX_ADDRESS ipxAddress;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;

    CHAR buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_IPX_ADDRESS)];

    PAGED_CODE( );

    //
    // Build the IPX socket address.
    //

    length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                sizeof(TA_IPX_ADDRESS);
    ea = (PFILE_FULL_EA_INFORMATION)buffer;

    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = sizeof (TA_IPX_ADDRESS);

    RtlCopyMemory( ea->EaName, TdiTransportAddress, ea->EaNameLength + 1 );

    //
    // Create a copy of the NETBIOS address descriptor in a local
    // first, in order to avoid alignment problems.
    //

    ipxAddress.TAAddressCount = 1;
    ipxAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    ipxAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_IPX);
    ipxAddress.Address[0].Address[0].NetworkAddress = 0;
    RtlZeroMemory(ipxAddress.Address[0].Address[0].NodeAddress, sizeof(ipxAddress.Address[0].Address[0].NodeAddress));
    ipxAddress.Address[0].Address[0].Socket = Socket;

    RtlCopyMemory(
        &ea->EaName[ea->EaNameLength + 1],
        &ipxAddress,
        sizeof(TA_IPX_ADDRESS)
        );

    InitializeObjectAttributes( &objectAttributes, DeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = IoCreateFile (
                 Handle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &objectAttributes,     // object attributes
                 &iosb,                 // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 buffer,                // EA buffer
                 length,                // EA length
                 CreateFileTypeNone,
                 NULL,
                 IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                 IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy

    if ( !NT_SUCCESS(status) ) {
//        KdPrint(( "Status of opening ipx socket %x on %wZ is %x\n",
//                    Socket, DeviceName, status ));
        return status;
    }

//    KdPrint(( "IPX socket %x opened!\n", Socket ));

    status = ObReferenceObjectByHandle (
                                *Handle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)FileObject,
                                NULL
                                );
    if (!NT_SUCCESS(status)) {
        ZwClose(*Handle);
        *Handle = NULL;
        *DeviceObject = NULL;
    }
    else {
        *DeviceObject = IoGetRelatedDeviceObject(*FileObject);
    }

    return status;

} // OpenIpxSocket


VOID
BowserReferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    InterlockedIncrement(&TransportName->ReferenceCount);
}

NTSTATUS
BowserDereferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    NTSTATUS Status;
    LONG Result;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


    if (TransportName->ReferenceCount == 0) {
        InternalError(("Transport Name Reference Count mismatch\n"));
    }

    Result = InterlockedDecrement(&TransportName->ReferenceCount);

    if (Result == 0) {
        Status = BowserFreeTransportName(TransportName);
    } else {
        Status = STATUS_SUCCESS;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}




NTSTATUS
BowserpTdiRemoveAddresses(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine removes all the transport names associated with a transport

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY NameEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserpTdiRemoveAddresses: Remove addresses for transport %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         Transport));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = Transport->PagedTransport->NameChain.Flink;
         NameEntry != &Transport->PagedTransport->NameChain;
         NameEntry = NextEntry) {

        PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
        PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;
        NextEntry = NameEntry->Flink;

        //
        // Remove the TransportName from the list of transport names for
        // this transport.
        //
        ASSERT(PagedTransportName->TransportNext.Flink != NULL);
        RemoveEntryList(&PagedTransportName->TransportNext);
        PagedTransportName->TransportNext.Flink = NULL;
        PagedTransportName->TransportNext.Blink = NULL;


        //
        // Since we delinked it, we need to dereference it.
        //
        Status = BowserDereferenceTransportName(TransportName);

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            return(Status);
        }

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return STATUS_SUCCESS;
}

PTRANSPORT_NAME
BowserFindTransportName(
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )
/*++

Routine Description:

    This routine looks up a given browser name to find its associated
    transport address.

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.

    IN PBOWSER_NAME Name - Supplies the name to look up.

Return Value:

    The transport address found, or null.

--*/

{
    PLIST_ENTRY NameEntry;
    PTRANSPORT_NAME RetValue = NULL;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {
        for (NameEntry = Transport->PagedTransport->NameChain.Flink;
             NameEntry != &Transport->PagedTransport->NameChain;
             NameEntry = NameEntry->Flink) {

            PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
            PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

            if (PagedTransportName->Name == Name) {

                try_return(RetValue = TransportName);
            }

try_exit:NOTHING;
        }
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return RetValue;
}

NTSTATUS
BowserFreeTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    PTRANSPORT Transport = TransportName->Transport;
    PBOWSER_NAME Name = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = TransportName->PagedTransportName;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserFreeTransportName: Free name %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         TransportName));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Close the handle to the TDI driver.
    //
    BowserCloseNetbiosAddress( TransportName );

    //
    // If we received a message which re-referenced this transport name,
    //  just return now.  We'll be back when the reference count gets
    //  re-dereferenced to zero.
    //

    if ( TransportName->ReferenceCount != 0 ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        return STATUS_SUCCESS;
    }

    ASSERT (TransportName->ReferenceCount == 0);



    if (PagedTransportName) {


        //
        // If this transport name has not yet been delinked,
        //  delink it.
        //

        if ( PagedTransportName->TransportNext.Flink != NULL ) {
            // This should only happen on a failed transport name creation.
            RemoveEntryList(&PagedTransportName->TransportNext);
            PagedTransportName->TransportNext.Flink = NULL;
            PagedTransportName->TransportNext.Blink = NULL;
        }
        RemoveEntryList(&PagedTransportName->NameNext);


        //
        //  We're removing an OtherDomain - we can remove the reference to
        //  the discardable code section that was applied when the name was
        //  created.
        //

        if (PagedTransportName->Name->NameType == OtherDomain) {
            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        }

        Name = PagedTransportName->Name;

        FREE_POOL(PagedTransportName);
    }

    if (Name != NULL) {
        switch ( Name->NameType ) {
        case ComputerName:
            Transport->ComputerName = NULL;
            break;

        case PrimaryDomain:
            if ( Transport->PrimaryDomain == TransportName ) {
                Transport->PrimaryDomain = Transport->AltPrimaryDomain;
                Transport->AltPrimaryDomain = NULL;
            }
            if ( Transport->AltPrimaryDomain == TransportName ) {
                Transport->AltPrimaryDomain = NULL;
            }
            break;

        case MasterBrowser:
            Transport->MasterBrowser = NULL;
            break;

        case BrowserElection:
            Transport->BrowserElection = NULL;
            break;

        case PrimaryDomainBrowser:
            Transport->PagedTransport->IsPrimaryDomainController = FALSE;

            //
            // Notify services we are no longer a PDC
            //

            BowserSendPnp(
                NlPnpNewRole,
                &Transport->DomainInfo->DomUnicodeDomainName,
                &Transport->PagedTransport->TransportName,
                BowserTransportFlags(Transport->PagedTransport) );

            break;
        }

        BowserDereferenceName(Name);

    }

    FREE_POOL(TransportName);

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    dlog(DPRT_TDI,
         ("%s: %ws: BowserFreeTransportName: Free name %lx completed\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         TransportName));

    return(STATUS_SUCCESS);
}

VOID
BowserDeleteTransport(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    Delete a transport.

    The caller should have a single reference to the transport.  The actual
    transport structure will be deleted when that reference goes away.
    This routine will decrement the global reference made in
    BowserTdiAllocateTransport

Arguments:

    IN Transport - Supplies a transport structure to be deleted.

Return Value:

    None.

--*/

{
    LARGE_INTEGER Interval;
    PPAGED_TRANSPORT PagedTransport;
    PAGED_CODE();

    //
    // Do cleanup of the PagedTransport structure
    //

    PagedTransport = Transport->PagedTransport;
    if ( PagedTransport != NULL ) {

        //
        // Notify services that this transport is now unbound
        //

        BowserSendPnp(
                NlPnpTransportUnbind,
                NULL,    // All hosted domains
                &PagedTransport->TransportName,
                BowserTransportFlags(PagedTransport) );


        //
        // Prevent BowserFindTransport from adding any new references to the transport
        //

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        if (!PagedTransport->DeletedTransport ) {

            //
            // Don't actually delink the entry since routines like
            //  BowserForEachTransport expect a reference to this transport
            //  to be enough to keep the GlobalNext list intact.
            //
            PagedTransport->DeletedTransport = TRUE;

            //
            // Remove the global reference to the transport.
            //
            // Avoid removing the global reference if we aren't in the global list.
            //

            if ( !IsListEmpty( &PagedTransport->GlobalNext) ) {
                BowserDereferenceTransport( Transport );
            }
        }

        //
        // Close all handles to the TDI driver so we won't get any indications after
        //  we start cleaning up the Transport structure in BowserpFreeTransport.
        //

        BowserCloseAllNetbiosAddresses( Transport );

        if ( PagedTransport->IpxSocketHandle != NULL) {

            NTSTATUS LocalStatus;
            BOOLEAN ProcessAttached = FALSE;
            KAPC_STATE ApcState;

            if (IoGetCurrentProcess() != BowserFspProcess) {
                KeStackAttachProcess(BowserFspProcess, &ApcState );

                ProcessAttached = TRUE;
            }

            LocalStatus = ZwClose(PagedTransport->IpxSocketHandle);
            ASSERT(NT_SUCCESS(LocalStatus));

            if (ProcessAttached) {
                KeUnstackDetachProcess( &ApcState );
            }

            PagedTransport->IpxSocketHandle = NULL;

            if ( Transport->IpxSocketFileObject != NULL ) {
                ObDereferenceObject( Transport->IpxSocketFileObject );
                Transport->IpxSocketFileObject = NULL;
            }
            Transport->IpxSocketDeviceObject = NULL;
        }
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    //
    // Uninitialize the timers to ensure we aren't in a timer routine while
    // we are cleaning up.
    //

    BowserUninitializeTimer(&Transport->ElectionTimer);

    BowserUninitializeTimer(&Transport->FindMasterTimer);


    //
    // Delete any mailslot messages queued to the netlogon service.
    //

    BowserNetlogonDeleteTransportFromMessageQueue ( Transport );

    //
    // Loop until this transport has the last reference to each of the transport
    //  names.  Above, we prevented any new references.  Here we ensure that
    //  all of the existing references go away.
    //
    // If there is an existing reference to the transport name, the holder
    //  of that reference can feel free to add a reference to
    //  TRANSPORT_NAME->Transport.
    //


    if ( PagedTransport != NULL ) {

        PLIST_ENTRY NameEntry;
        PLIST_ENTRY NextEntry;

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        for (NameEntry = Transport->PagedTransport->NameChain.Flink;
             NameEntry &&
             (NameEntry != &Transport->PagedTransport->NameChain);
             NameEntry = NextEntry) {

            PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
            PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

            NextEntry = NameEntry->Flink;

            if ( TransportName->ReferenceCount != 1 ) {
                ExReleaseResourceLite(&BowserTransportDatabaseResource);
                Interval.QuadPart = -1000*1000; // .1 second
                KeDelayExecutionThread( KernelMode, FALSE, &Interval );
                ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
                NextEntry = Transport->PagedTransport->NameChain.Flink;
            }

        }

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }


    //
    // Loop until our caller has the last outstanding reference.
    //  This loop is the only thing preventing the driver from unloading while there
    //  are still references outstanding.
    //

    while ( Transport->ReferenceCount != 1) {
        Interval.QuadPart = -1000*1000; // .01 second
        KeDelayExecutionThread( KernelMode, FALSE, &Interval );
    }

}



VOID
BowserpFreeTransport(
    IN PTRANSPORT Transport
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Free the Paged transport, if necessary.
    //

    if (Transport->PagedTransport != NULL) {
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        //
        // Remove the entry from the global list if it is in it.
        //
        if ( !IsListEmpty( &PagedTransport->GlobalNext ) ) {
            ASSERT( PagedTransport->DeletedTransport );
            RemoveEntryList(&PagedTransport->GlobalNext);
        }

        //
        // Remove the Adresses.
        //
        //  Do this in a separate step from the Close in BowserDeleteTransport
        //  above to ensure the PrimaryDomain and ComputerName fields don't
        //  get cleared until all possible references are removed.
        //

        if (!IsListEmpty( &PagedTransport->NameChain)) {
            BowserpTdiRemoveAddresses(Transport);
        }

        BowserDeleteGenericTable(&PagedTransport->AnnouncementTable);

        BowserDeleteGenericTable(&PagedTransport->DomainTable);

        if (PagedTransport->BrowserServerListBuffer != NULL) {

            BowserFreeBrowserServerList(
                PagedTransport->BrowserServerListBuffer,
                PagedTransport->BrowserServerListLength
                );
        }

        FREE_POOL(PagedTransport);
    }

    if ( Transport->DomainInfo != NULL ) {
        BowserDereferenceDomain( Transport->DomainInfo );
    }


    ExDeleteResourceLite(&Transport->BrowserServerListResource);

    UNINITIALIZE_ANNOUNCE_DATABASE(Transport);

    ExDeleteResourceLite(&Transport->Lock);

    BowserUninitializeIrpQueue(&Transport->BecomeBackupQueue);

    BowserUninitializeIrpQueue(&Transport->BecomeMasterQueue);

    BowserUninitializeIrpQueue(&Transport->FindMasterQueue);

    BowserUninitializeIrpQueue(&Transport->WaitForMasterAnnounceQueue);

    BowserUninitializeIrpQueue(&Transport->ChangeRoleQueue);
    BowserUninitializeIrpQueue(&Transport->WaitForNewMasterNameQueue );

    FREE_POOL(Transport);

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
}



NTSTATUS
BowserpTdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    PAGED_CODE();
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = BowserSubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}

NTSTATUS
BowserIssueTdiAction (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PVOID Action,
    IN ULONG ActionSize
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS status;
    PIRP irp;
//    PIO_STACK_LOCATION irpSp;
    PMDL mdl;


    PAGED_CODE();

    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Action, ActionSize, FALSE, FALSE, NULL );

    if ( mdl == NULL ) {
        IoFreeIrp( irp );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool( mdl );

    TdiBuildAction(
        irp,
        DeviceObject,
        FileObject,
        NULL,
        NULL,
        mdl
        );

    irp->AssociatedIrp.SystemBuffer = Action;

    if (irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = BowserSubmitTdiRequest(FileObject, irp);

    IoFreeIrp(irp);

    IoFreeMdl(mdl);

    return status;
}


NTSTATUS
BowserBuildTransportAddress (
    IN OUT PANSI_STRING Address,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and converts it into an
    acceptable form for passing in as transport address.

Arguments:

    OUT PTA_NETBIOS_ADDRESS RemoteAddress, - Supplies the structure to fill in
    IN PUNICODE_STRING Name - Supplies the name to put into the transport

    Please note that it is CRITICAL that the TA_NETBIOS_ADDRESS pointed to by
    RemoteAddress be of sufficient size to hold the full network name.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OEM_STRING NetBiosName;
    PTRANSPORT_ADDRESS RemoteAddress = (PTRANSPORT_ADDRESS)Address->Buffer;
    PTDI_ADDRESS_NETBIOS NetbiosAddress = (PTDI_ADDRESS_NETBIOS)&RemoteAddress->Address[0].Address[0];

    PAGED_CODE();


    //
    // Ensure there is room for this address.
    //
    if ( Address->MaximumLength < sizeof(TA_NETBIOS_ADDRESS) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RemoteAddress->TAAddressCount = 1;
    RemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    RemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
    Address->Length = sizeof(TA_NETBIOS_ADDRESS);

    NetBiosName.Length = 0;
    NetBiosName.MaximumLength = NETBIOS_NAME_LEN;
    NetBiosName.Buffer = NetbiosAddress->NetbiosName;

    //
    // Domain announcements are to a constant Netbios name address.
    //
    switch (NameType) {
    case DomainAnnouncement:
        ASSERT (strlen(DOMAIN_ANNOUNCEMENT_NAME) == NETBIOS_NAME_LEN);
        RtlCopyMemory(NetBiosName.Buffer, DOMAIN_ANNOUNCEMENT_NAME, strlen(DOMAIN_ANNOUNCEMENT_NAME));

        NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
        break;


    //
    // All other names are upper case, OEM, and trailing blank filled.
    //
    default:

        if (RtlUnicodeStringToOemSize(Name) > NETBIOS_NAME_LEN) {
            return STATUS_BAD_NETWORK_PATH;
        }

        Status = RtlUpcaseUnicodeStringToOemString(&NetBiosName, Name, FALSE);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RtlCopyMemory(&NetBiosName.Buffer[NetBiosName.Length], "                ",
                                    NETBIOS_NAME_LEN-NetBiosName.Length);

        switch (NameType) {

        case ComputerName:
        case AlternateComputerName:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case DomainName:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = DOMAIN_CONTROLLER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;

        case BrowserServer:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = SERVER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case MasterBrowser:
            if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            } else {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = MASTER_BROWSER_SIGNATURE;
            }
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case PrimaryDomain:
        case OtherDomain:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = PRIMARY_DOMAIN_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;

        case PrimaryDomainBrowser:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = PRIMARY_CONTROLLER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case BrowserElection:
            if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            } else {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = BROWSER_ELECTION_SIGNATURE;
            }
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;


        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
BowserUpdateProviderInformation(
    IN OUT PPAGED_TRANSPORT PagedTransport
    )
/*++

Routine Description:

    This routine updates status bits in the PagedTransport based on querying
    the TDI driver.

    Most importantly, the transport will be disabled if the provider is RAS or
    doesn't yet have an IP address.

    A goal of this routine is to handle the case where there are multiple IP
    net cards on the same subnet.  In that case, we want only one such net
    card enabled for each emulated domain.

Arguments:

    PagedTransport - Transport to update

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    TDI_PROVIDER_INFO ProviderInfo;
    ULONG OldIpSubnetNumber;
    BOOLEAN DisableThisTransport = FALSE;

    PLIST_ENTRY TransportEntry;
    PPAGED_TRANSPORT CurrentPagedTransport;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Find out about the transport.
    //

    OldIpSubnetNumber = PagedTransport->IpSubnetNumber;

    Status = BowserDetermineProviderInformation(
                        &PagedTransport->TransportName,
                        &ProviderInfo,
                        &PagedTransport->IpSubnetNumber );

    if (!NT_SUCCESS(Status)) {
        goto ReturnStatus;
    }

    //
    //  We can only talk to transports that support a max datagram size.
    //

    if (ProviderInfo.MaxDatagramSize == 0) {
        Status = STATUS_BAD_REMOTE_ADAPTER;
        goto ReturnStatus;
    }

    PagedTransport->NonPagedTransport->DatagramSize = ProviderInfo.MaxDatagramSize;


    //
    // Remember various attributes of the provider
    //  (Never disable the PointToPoint bit.  NetBt forgets it when the
    //  RAS phone is hung up.)

    PagedTransport->Wannish = (BOOLEAN)((ProviderInfo.ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED) != 0);
    if (ProviderInfo.ServiceFlags & TDI_SERVICE_POINT_TO_POINT) {
        PagedTransport->PointToPoint = TRUE;
    }


    //
    // If this is a RAS transport or the IP Address is not yet known,
    //  disable browsing on the transport.
    //

    if ( PagedTransport->PointToPoint ||
         PagedTransport->IpSubnetNumber == 0 ) {
        DisableThisTransport = TRUE;
    }


    //
    // If this isn't an IP transport, we're done.
    //

    if ( PagedTransport->IpSubnetNumber == BOWSER_NON_IP_SUBNET ) {
        goto ReturnStatus;
    }

    //
    // In the loop below, we use OldIpSubnetNumber to determine if another
    //  transport should be enabled on that subnet.  If that will NEVER be
    //  appropriate, flag OldIpSubnetNumber now.
    //

    if ( OldIpSubnetNumber == 0 ||
         PagedTransport->DisabledTransport ||
         PagedTransport->IpSubnetNumber == OldIpSubnetNumber ) {
        OldIpSubnetNumber = BOWSER_NON_IP_SUBNET;
    }


    //
    // Loop through the transports enabling/disabling them as indicated by
    //  the comments below.
    //

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = CurrentPagedTransport->GlobalNext.Flink ) {

        CurrentPagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

        //
        // Ignore deleted transports.
        //
        if ( CurrentPagedTransport->DeletedTransport ) {
            continue;
        }

        //
        // If this transport isn't an IP transport,
        //  or this transport is a RAS transport,
        //  or this transport is the transport passed in,
        //  skip it and go on to the next one.
        //
        if ( CurrentPagedTransport->IpSubnetNumber == BOWSER_NON_IP_SUBNET ||
             CurrentPagedTransport->PointToPoint ||
             CurrentPagedTransport == PagedTransport ) {
            continue;
        }

        //
        // Special case this transport if it's currently disabled
        //

        if ( CurrentPagedTransport->DisabledTransport ) {

            //
            // If this transport is disabled and the transport passed in
            // used to be the enabled transport for the subnet,
            //  enable the transport
            //

            if ( CurrentPagedTransport->IpSubnetNumber == OldIpSubnetNumber ) {
                CurrentPagedTransport->DisabledTransport = FALSE;
            }

            //
            // In any case,
            //  that's all we need to do for a disabled transport.
            //

            continue;
        }


        //
        // If this transport is an enabled transport for the subnet of the one
        //  passed in,
        //  And this transport is for the same emulated domain as the one
        //  passed in,
        //  then disable the one passed in.
        //

        if ( CurrentPagedTransport->IpSubnetNumber ==
             PagedTransport->IpSubnetNumber &&
             CurrentPagedTransport->NonPagedTransport->DomainInfo == PagedTransport->NonPagedTransport->DomainInfo ) {
             DisableThisTransport = TRUE;
        }


    }



    //
    // Cleanup
    //
ReturnStatus:

    //
    // If we're disabling a previously enabled transport,
    //  ensure we're not the master browser.
    //
    if ( DisableThisTransport && !PagedTransport->DisabledTransport ) {
        PagedTransport->DisabledTransport = DisableThisTransport;
        BowserLoseElection( PagedTransport->NonPagedTransport );
    } else {
        PagedTransport->DisabledTransport = DisableThisTransport;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    return Status;
}

NTSTATUS
BowserDetermineProviderInformation(
    IN PUNICODE_STRING TransportName,
    OUT PTDI_PROVIDER_INFO ProviderInfo,
    OUT PULONG IpSubnetNumber
    )
/*++

Routine Description:

    This routine will determine provider information about a transport.

Arguments:

    TransportName - Supplies the name of the transport provider

    ProviderInfo - Returns information about the provider

    IpSubnetNumber - returns the Ip Subnet Number of this transport.
        BOWSER_NON_IP_SUBNET - If this isn't an IP transport
        0 - If the IP address isn't yet set
        Otherwise - the IP address anded with the subnet mask

Return Value:

    Status of operation.

--*/
{
    HANDLE TransportHandle = NULL;
    PFILE_OBJECT TransportObject = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;
    PMDL Mdl = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    InitializeObjectAttributes (&ObjAttributes,
                                    TransportName, // Name
                                    OBJ_CASE_INSENSITIVE, // Attributes
                                    NULL, // RootDirectory
                                    NULL); // SecurityDescriptor


    Status = IoCreateFile(&TransportHandle, // Handle
                                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                &ObjAttributes, // Object Attributes
                                &IoStatusBlock, // Final I/O status block
                                NULL,   // Allocation Size
                                FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                FILE_SHARE_READ, // Sharing attributes
                                FILE_OPEN_IF, // Create disposition
                                0,      // CreateOptions
                                NULL,   // EA Buffer
                                0,      // EA Buffer Length
                                CreateFileTypeNone,
                                NULL,
                                IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy


    if (!NT_SUCCESS(Status)) {

        goto ReturnStatus;
    }

    Status = ObReferenceObjectByHandle (
                                TransportHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&TransportObject,
                                NULL
                                );
    if (!NT_SUCCESS(Status)) {
        goto ReturnStatus;
    }

    DeviceObject = IoGetRelatedDeviceObject(TransportObject);

    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReturnStatus;
    }

    //
    //  Allocate an MDL to hold the provider info.
    //

    Mdl = IoAllocateMdl(ProviderInfo, sizeof(TDI_PROVIDER_INFO),
                        FALSE,
                        FALSE,
                        NULL);


    if (Mdl == NULL) {
        IoFreeIrp(Irp);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReturnStatus;
    }

    MmBuildMdlForNonPagedPool(Mdl);

    TdiBuildQueryInformation(Irp, DeviceObject, TransportObject,
                            NULL, NULL,
                            TDI_QUERY_PROVIDER_INFORMATION, Mdl);

    Status = BowserSubmitTdiRequest(TransportObject, Irp);

    IoFreeIrp(Irp);

    //
    // Get the IP address for this Transport.
    //

    if ( (ProviderInfo->ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED) == 0) {
        *IpSubnetNumber = BOWSER_NON_IP_SUBNET;
    } else {
        NTSTATUS TempStatus;
        IO_STATUS_BLOCK IoStatusBlock;
        ULONG IpAddressBuffer[2];   // IpAddress followed by subnet mask

        TempStatus = ZwDeviceIoControlFile(
                        TransportHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_NETBT_GET_IP_SUBNET,
                        NULL,
                        0,
                        &IpAddressBuffer,
                        sizeof(IpAddressBuffer) );

        if ( !NT_SUCCESS(TempStatus) ) {
            *IpSubnetNumber = BOWSER_NON_IP_SUBNET;
        } else {
            ASSERT(TempStatus != STATUS_PENDING);
            *IpSubnetNumber = IpAddressBuffer[0] & IpAddressBuffer[1];
        }
    }


ReturnStatus:
    if (Mdl != NULL) {
        IoFreeMdl(Mdl);
    }

    if (TransportObject != NULL) {
        ObDereferenceObject(TransportObject);
    }


    if (TransportHandle != NULL) {
        ZwClose(TransportHandle);
    }

    return(Status);
}




PTRANSPORT
BowserFindTransport (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName OPTIONAL
    )

/*++

Routine Description:

    This routine will locate a transport in the bowsers transport list.

Arguments:

    TransportName - Supplies the name of the transport provider

    EmulatedDomainName - Specifies the emulated domain whose transport is to be found.


Return Value:

    PTRANSPORT - NULL if no transport was found, TRUE if transport was found.

--*/
{
    PLIST_ENTRY TransportEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    PDOMAIN_INFO DomainInfo = NULL;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {

        //
        // Find the requested domain.
        //

        DomainInfo = BowserFindDomain( EmulatedDomainName );

        if ( DomainInfo != NULL ) {
            for (TransportEntry = BowserTransportHead.Flink ;
                TransportEntry != &BowserTransportHead ;
                TransportEntry = TransportEntry->Flink) {

                PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

                //
                // Ignore deleted transports.
                //
                if ( PagedTransport->DeletedTransport ) {
                    continue;
                }

                if ( PagedTransport->NonPagedTransport->DomainInfo == DomainInfo &&
                     RtlEqualUnicodeString(TransportName,
                                           &PagedTransport->TransportName, TRUE)) {

                    Transport = PagedTransport->NonPagedTransport;

                    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserFindTransport.\n", Transport));
                    BowserReferenceTransport( Transport );

                    try_return(Transport);
                }
            }
        }


        try_return(Transport = NULL);

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }
        ExReleaseResourceLite (&BowserTransportDatabaseResource);
    }

    return Transport;

}

NTSTATUS
BowserForEachTransportInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the transports and call back the enum
    routine provided with each transport.

Arguments:

    DomainInfo - Only call 'Routine' for transport in this domain.

    Routine - Routine to call for each transport

    Context - Parameter to pass to 'Routine'

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = NextEntry) {

        PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);
        Transport = PagedTransport->NonPagedTransport;

        //
        // Ignore deleted transports.
        //
        if ( PagedTransport->DeletedTransport ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }

        //
        // If transport isn't in the specified domain,
        //  ignore it.
        //

        if ( Transport->DomainInfo != DomainInfo ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }


        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserForEachTransportInDomain.\n", Transport));
        BowserReferenceTransport(Transport);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Transport, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceTransport(Transport);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = PagedTransport->GlobalNext.Flink;

        BowserDereferenceTransport(Transport);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}

NTSTATUS
BowserForEachTransport (
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the transports and call back the enum
    routine provided with each transport.

Arguments:


    Routine - Routine to call for each transport

    Context - Parameter to pass to 'Routine'

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = NextEntry) {

        PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

        //
        // Ignore deleted transports.
        //
        if ( PagedTransport->DeletedTransport ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }

        Transport = PagedTransport->NonPagedTransport;

        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserForEachTransport.\n", Transport));
        BowserReferenceTransport(Transport);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Transport, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceTransport(Transport);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = PagedTransport->GlobalNext.Flink;

        BowserDereferenceTransport(Transport);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}

NTSTATUS
BowserForEachTransportName(
    IN PTRANSPORT Transport,
    IN PTRANSPORT_NAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the names associated with a transport
    and call back the enum routine provided with each transport name.

Arguments:


Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {

        for (TransportEntry = Transport->PagedTransport->NameChain.Flink ;
             TransportEntry &&
             (TransportEntry != &Transport->PagedTransport->NameChain) ;
             TransportEntry = NextEntry) {

            PagedTransportName = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT_NAME, TransportNext);

            TransportName = PagedTransportName->NonPagedTransportName;
            BowserReferenceTransportName( TransportName );
            ExReleaseResourceLite(&BowserTransportDatabaseResource);

            Status = (Routine)(TransportName, Context);

            if (!NT_SUCCESS(Status)) {
                ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
                BowserDereferenceTransportName( TransportName );
                try_return(Status);
            }

            ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
            NextEntry = PagedTransportName->TransportNext.Flink;
            BowserDereferenceTransportName( TransportName );
        }

try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}

NTSTATUS
BowserDeleteTransportNameByName(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine deletes a transport name associated with a specific network.

Arguments:

    Transport - Specifies the transport on which to delete the name.

    Name - Specifies the transport name to delete.
        If not specified, all names of the specified name type are deleted.

    NameType - Specifies the name type of the name.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {
        for (TransportEntry = Transport->PagedTransport->NameChain.Flink ;
             TransportEntry != &Transport->PagedTransport->NameChain ;
             TransportEntry = NextEntry) {

            PagedTransportName = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT_NAME, TransportNext);

            TransportName = PagedTransportName->NonPagedTransportName;

            ASSERT (TransportName->NameType == PagedTransportName->Name->NameType);

            if ((TransportName->NameType == NameType) &&
                (Name == NULL ||
                 Name->Length == 0 ||
                RtlEqualUnicodeString(&PagedTransportName->Name->Name, Name, TRUE))) {
                NextEntry = TransportEntry->Flink;


                //
                // Remove the TransportName from the list of transport names for
                // this transport.
                //
                ASSERT( PagedTransportName->TransportNext.Flink != NULL);
                RemoveEntryList(&PagedTransportName->TransportNext);
                PagedTransportName->TransportNext.Flink = NULL;
                PagedTransportName->TransportNext.Blink = NULL;


                //
                // Since we delinked it, we need to dereference it.
                //
                Status = BowserDereferenceTransportName(TransportName);

                if (!NT_SUCCESS(Status)) {
                    try_return(Status);
                }

            } else {
                NextEntry = PagedTransportName->TransportNext.Flink;
            }

        }
try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}



NTSTATUS
BowserSubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, BowserCompleteTdiRequest, &Event, TRUE, TRUE, TRUE);

    //
    //  Submit the disconnect request
    //

    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        dlog(DPRT_TDI, ("BowserSubmitTdiRequest: submit request.  Status = %X", Status));
        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return Status;
    }

    if (Status == STATUS_PENDING) {

        dlog(DPRT_TDI, ("TDI request issued, waiting..."));

        Status = KeWaitForSingleObject(&Event, // Object to wait on.
                                    Executive,  // Reason for waiting
                                    KernelMode, // Processor mode
                                    FALSE,      // Alertable
                                    NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_TDI, ("Could not wait for operation to complete"));
            KeBugCheck( 666 );
        }

        Status = Irp->IoStatus.Status;
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    dlog(DPRT_TDI, ("TDI request complete\n"));

    return(Status);
}


NTSTATUS
BowserCompleteTdiRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Completion routine for SubmitTdiRequest operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    DISCARDABLE_CODE( BowserDiscardableCodeSection );
    dprintf(DPRT_TDI, ("CompleteTdiRequest: %lx\n", Context));

    //
    //  Set the event to the Signalled state with 0 priority increment and
    //  indicate that we will not be blocking soon.
    //

    KeSetEvent((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

    //  Quiet the compiler.

    if (Irp || DeviceObject){};
}

typedef struct _SEND_DATAGRAM_CONTEXT {
    PTDI_CONNECTION_INFORMATION ConnectionInformation;
    PVOID Header;
    BOOLEAN WaitForCompletion;
    KEVENT Event;
} SEND_DATAGRAM_CONTEXT, *PSEND_DATAGRAM_CONTEXT;


NTSTATUS
BowserSendDatagram (
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WaitForCompletion,
    IN PSTRING DestinationAddress OPTIONAL,
    IN BOOLEAN IsHostAnnouncement
    )

/*++

Routine Description:

    This routine sends a datagram to the specified domain.

Arguments:

    Domain - the name of the domain to send to.
                Please note that the DOMAIN is padded with spaces and
                terminated with the appropriate signature byte (00 or 07).

    Buffer - the message to send.

    BufferLength - the length of the buffer,

    IsHostAnnouncement - True if the datagram is a host announcement

Return Value:

    NTSTATUS - results of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG connectionInformationSize;
    PIRP irp = NULL;
    PMDL mdlAddress = NULL;
    PSEND_DATAGRAM_CONTEXT context = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
//    PTRANSPORT_NAME TComputerName;
    ANSI_STRING AnsiString;
    UCHAR IpxPacketType;
    PFILE_OBJECT    FileObject = NULL;
    PDEVICE_OBJECT  DeviceObject;
    PVOID pBuffToFree = Buffer;

    PAGED_CODE();

    //
    // Ensure the computername has been registered for this transport
    //
    if ( Transport->ComputerName == NULL ) {
        Status = STATUS_BAD_NETWORK_PATH;
        goto Cleanup;
    }

    //
    // Ensure the Device and File object are known.
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        DeviceObject = Transport->ComputerName->DeviceObject;
        FileObject = Transport->ComputerName->FileObject;
    } else {
        DeviceObject = Transport->IpxSocketDeviceObject;
        FileObject = Transport->IpxSocketFileObject;
    }

    if ( DeviceObject == NULL || FileObject == NULL ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        Status = STATUS_BAD_NETWORK_PATH;
        goto Cleanup;
    }

    if ( FileObject != NULL ) {
        ObReferenceObject( FileObject );
    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);


    //
    // Allocate a context describing this datagram send.
    //

    context = ALLOCATE_POOL(NonPagedPool, sizeof(SEND_DATAGRAM_CONTEXT), POOL_SENDDATAGRAM);

    if ( context == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    context->Header = NULL;
    context->ConnectionInformation = NULL;

    connectionInformationSize = sizeof(TDI_CONNECTION_INFORMATION) +
                                                max(sizeof(TA_NETBIOS_EX_ADDRESS),
                                                    sizeof(TA_IPX_ADDRESS));

    if (Domain == NULL) {
        Domain = &Transport->DomainInfo->DomUnicodeDomainName;
    }

    if (FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        PSMB_IPX_NAME_PACKET NamePacket;
        OEM_STRING NetBiosName;

        context->Header = ALLOCATE_POOL(NonPagedPool, BufferLength + sizeof(SMB_IPX_NAME_PACKET), POOL_SENDDATAGRAM);

        if ( context->Header == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NamePacket = context->Header;

        RtlZeroMemory(NamePacket->Route, sizeof(NamePacket->Route));

        NamePacket->Operation = SMB_IPX_MAILSLOT_SEND;

        switch (NameType) {
        case BrowserElection:
            if ( IsHostAnnouncement ) {
                NamePacket->NameType = SMB_IPX_NAME_TYPE_BROWSER;
            } else {
                NamePacket->NameType = SMB_IPX_NAME_TYPE_WORKKGROUP;
            }
            break;
        case ComputerName:
        case AlternateComputerName:
            NamePacket->NameType = SMB_IPX_NAME_TYPE_MACHINE;
            break;
        case MasterBrowser:
            NamePacket->NameType = SMB_IPX_NAME_TYPE_WORKKGROUP;
            break;
        //
        // Don't send on name types that direct host IPX can't handle.
        //
        // Domain(1B): Direct host IPX datagram receivers aren't particular
        // about the 16th byte of the netbios name.  Therefore, all of them
        // accept a Domain<1B> datagram.  However, such sends are destined
        // only to the PDC.
        //
        // Domain(1C): Domain(1C) is registered only by NT DCs.  However,
        // NT DCs don't completely support direct host IPX.  But they do
        // completely support NwLnkNb.
        //
        // We silently ingore these errors allowing the caller to duplicate
        // the send on NwLnkNb.

        case PrimaryDomainBrowser:
        case DomainName:

            Status = STATUS_SUCCESS;
            goto Cleanup;

        //
        // Fail on sends to non-sensical name types.
        //
        //  DomainAnnouncements aren't sent separately.
        //

        default:
            // Silently ignore the
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto Cleanup;
        }

        NamePacket->MessageId = 0;

        NetBiosName.Length = 0;
        NetBiosName.MaximumLength = SMB_IPX_NAME_LENGTH;
        NetBiosName.Buffer = NamePacket->Name;

        Status = RtlUpcaseUnicodeStringToOemString(&NetBiosName, Domain, FALSE);

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        RtlCopyMemory(&NetBiosName.Buffer[NetBiosName.Length], "                ",
                                    SMB_IPX_NAME_LENGTH-NetBiosName.Length);

        NamePacket->Name[SMB_IPX_NAME_LENGTH-1] = WORKSTATION_SIGNATURE;

        RtlCopyMemory(NamePacket->SourceName, ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName, SMB_IPX_NAME_LENGTH);

        RtlCopyMemory((NamePacket+1), Buffer, BufferLength);

        // Replace Buffer w/ IPX modified one.
        // - ensure cleanup will free input Buffer.
        ASSERT(Buffer == pBuffToFree);
        FREE_POOL(Buffer);
        pBuffToFree = NULL; // cleanup will free context->Header
        Buffer = context->Header;

        BufferLength += sizeof(SMB_IPX_NAME_PACKET);

    } else {
        // ensure consistency
        ASSERT(Buffer == pBuffToFree);
        context->Header = Buffer;
        pBuffToFree = NULL; // don't cleanup for async case.
    }

    context->ConnectionInformation = ALLOCATE_POOL(NonPagedPool,
                                connectionInformationSize, POOL_CONNECTINFO
                                );

    if ( context->ConnectionInformation == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    context->ConnectionInformation->UserDataLength = 0;
    context->ConnectionInformation->UserData = NULL;
    context->ConnectionInformation->OptionsLength = 0;
    context->ConnectionInformation->Options = NULL;

    AnsiString.Buffer = (PCHAR)(context->ConnectionInformation + 1);
    AnsiString.MaximumLength = (USHORT)(connectionInformationSize - sizeof(TDI_CONNECTION_INFORMATION));

    context->ConnectionInformation->RemoteAddress = AnsiString.Buffer;

    context->WaitForCompletion = WaitForCompletion;

//    ComputerName = Transport->ComputerName;

    if (!ARGUMENT_PRESENT(DestinationAddress)) {

        //
        //  If this is for our primary domain, and the request is destined
        //  for the master browser name, then stick in the address of our
        //  master browser if we know it.
        //

        if ((RtlCompareMemory(Domain->Buffer, ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName, SMB_IPX_NAME_LENGTH) == SMB_IPX_NAME_LENGTH) &&
            ( NameType == MasterBrowser ) &&
            (Transport->PagedTransport->MasterBrowserAddress.Length != 0) ) {

            //
            //  This is for our domain.  If it's for our master browser
            //  and we know who that is, we're done - copy over the master's address
            //  and send it.
            //

            ASSERT (Transport->PagedTransport->MasterBrowserAddress.Length == sizeof(TA_IPX_ADDRESS));

            RtlCopyMemory(context->ConnectionInformation->RemoteAddress,
                            Transport->PagedTransport->MasterBrowserAddress.Buffer,
                            Transport->PagedTransport->MasterBrowserAddress.Length);

            //
            // This is a directed packet, don't broadcast it.
            //
            IpxPacketType = IPX_DIRECTED_PACKET;
            context->ConnectionInformation->OptionsLength = sizeof(IpxPacketType);
            context->ConnectionInformation->Options = &IpxPacketType;

        } else if (FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {

            PTA_IPX_ADDRESS IpxAddress = (PTA_IPX_ADDRESS)AnsiString.Buffer;

            IpxAddress->TAAddressCount = 1;
            IpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
            IpxAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IPX;

            IpxAddress->Address[0].Address[0].NetworkAddress = 0;
            IpxAddress->Address[0].Address[0].NodeAddress[0] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[1] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[2] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[3] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[4] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[5] = 0xff;
            IpxAddress->Address[0].Address[0].Socket = SMB_IPX_MAILSLOT_SOCKET;

        } else {

            Status = BowserBuildTransportAddress(&AnsiString,
                                    Domain,
                                    NameType,
                                    Transport);

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            context->ConnectionInformation->RemoteAddressLength = AnsiString.Length;
        }

    } else {

        //
        //  This is already correctly formatted, so just put it on the wire.
        //

        RtlCopyMemory(context->ConnectionInformation->RemoteAddress, DestinationAddress->Buffer, DestinationAddress->Length);
        context->ConnectionInformation->RemoteAddressLength = DestinationAddress->Length;

        //
        // This is a directed packet, don't broadcast it.
        //
        IpxPacketType = IPX_DIRECTED_PACKET;
        context->ConnectionInformation->OptionsLength = sizeof(IpxPacketType);
        context->ConnectionInformation->Options = &IpxPacketType;

    }

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE);

    if (irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    mdlAddress = IoAllocateMdl(Buffer, BufferLength, FALSE, FALSE, NULL);

    if (mdlAddress == NULL) {
        IoFreeIrp(irp);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KeInitializeEvent(&context->Event, NotificationEvent, FALSE);

    MmBuildMdlForNonPagedPool(mdlAddress);

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    ASSERT (KeGetCurrentIrql() == 0);

    TdiBuildSendDatagram( irp,
                          DeviceObject,
                          FileObject,
                          CompleteSendDatagram,
                          context,
                          mdlAddress,
                          BufferLength,
                          context->ConnectionInformation);


    Status = IoCallDriver(DeviceObject, irp);

    ASSERT (KeGetCurrentIrql() == 0);

    if (WaitForCompletion) {

        ASSERT (KeGetCurrentIrql() == 0);
        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject(&context->Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        }

        IoFreeMdl(irp->MdlAddress);

        //
        //  Retrieve the status from the IRP.
        //

        Status = irp->IoStatus.Status;

        IoFreeIrp(irp);

    } else {
        //
        // Let completion routine free the context
        //
        context = NULL;
    }

    ASSERT (KeGetCurrentIrql() == 0);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    //
    // Free locally used resources
    //
Cleanup:

    if ( context != NULL ) {
        if ( context->Header != NULL &&
             context->Header != pBuffToFree ) {
            FREE_POOL( context->Header );
        }
        if (context->ConnectionInformation != NULL ) {
            FREE_POOL(context->ConnectionInformation);
        }
        FREE_POOL(context);
    }

    if (pBuffToFree) {
        FREE_POOL( pBuffToFree );
    }

    if ( FileObject != NULL ) {
        ObDereferenceObject( FileObject );
    }
    return Status;

} // BowserSendDatagram

NTSTATUS
CompleteSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    )

/*++

Routine Description:

    Completion routine for SubmitTdiRequest operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    PSEND_DATAGRAM_CONTEXT Context = Ctx;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    dprintf(DPRT_TDI, ("CompleteTdiRequest: %lx\n", Context));

    if (Context->WaitForCompletion) {

        //
        //  Set the event to the Signalled state with 0 priority increment and
        //  indicate that we will not be blocking soon.
        //

        KeSetEvent(&Context->Event, 0, FALSE);

    } else {
        FREE_POOL(Context->ConnectionInformation);

        FREE_POOL(Context->Header);

        FREE_POOL(Context);

        IoFreeMdl(Irp->MdlAddress);

        IoFreeIrp(Irp);

    }
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(DeviceObject);
}




NTSTATUS
BowserSendSecondClassMailslot (
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Message,
    IN ULONG MessageLength,
    IN BOOLEAN WaitForCompletion,
    IN PCHAR mailslotNameData,
    IN PSTRING DestinationAddress OPTIONAL
    )
{
    ULONG dataSize;
    ULONG transactionDataSize;
    ULONG smbSize;
    PSMB_HEADER header;
    PSMB_TRANSACT_MAILSLOT parameters;
    PSZ mailslotName;
    ULONG mailslotNameLength;
    PSZ domainInData;
    PVOID message;
    NTSTATUS status;

    PAGED_CODE();
    //
    // Determine the sizes of various fields that will go in the SMB
    // and the total size of the SMB.
    //

    mailslotNameLength = strlen( mailslotNameData );

    transactionDataSize = MessageLength;
    dataSize = mailslotNameLength + 1 + transactionDataSize;
    smbSize = sizeof(SMB_HEADER) + sizeof(SMB_TRANSACT_MAILSLOT) - 1 + dataSize;

    header = ALLOCATE_POOL( NonPagedPool, smbSize, POOL_MAILSLOT_HEADER );
    if ( header == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the header.  Most of the fields don't matter and are
    // zeroed.
    //

    RtlZeroMemory( header, smbSize );

    header->Protocol[0] = 0xFF;
    header->Protocol[1] = 'S';
    header->Protocol[2] = 'M';
    header->Protocol[3] = 'B';
    header->Command = SMB_COM_TRANSACTION;

    //
    // Get the pointer to the params and fill them in.
    //

    parameters = (PSMB_TRANSACT_MAILSLOT)( header + 1 );
    mailslotName = (PSZ)( parameters + 1 ) - 1;
    domainInData = mailslotName + mailslotNameLength + 1;
    message = domainInData;

    parameters->WordCount = 0x11;
    SmbPutUshort( &parameters->TotalDataCount, (USHORT)transactionDataSize );
    SmbPutUlong( &parameters->Timeout, 0x3E8 );                // !!! fix
    SmbPutUshort( &parameters->DataCount, (USHORT)transactionDataSize );
    SmbPutUshort(
        &parameters->DataOffset,
        (USHORT)( (ULONG_PTR)message - (ULONG_PTR)header )
        );
    parameters->SetupWordCount = 3;
    SmbPutUshort( &parameters->Opcode, MS_WRITE_OPCODE );
    SmbPutUshort( &parameters->Priority, 1);
    SmbPutUshort( &parameters->Class, 2 );
    SmbPutUshort( &parameters->ByteCount, (USHORT)dataSize );

    RtlCopyMemory( mailslotName, mailslotNameData, mailslotNameLength + 1 );
    RtlCopyMemory( message, Message, MessageLength );

    //
    // Send the actual mailslot message.
    //

    status = BowserSendDatagram( Transport,
                                 Domain,
                                 NameType,
                                 header,
                                 smbSize,
                                 WaitForCompletion,
                                 DestinationAddress,
                                 (BOOLEAN)(((PHOST_ANNOUNCE_PACKET)Message)->AnnounceType == LocalMasterAnnouncement) );

    return status;

} // BowserSendSecondClassMailslot


NTSTATUS
BowserSendRequestAnnouncement(
    IN PUNICODE_STRING DestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    )
{
    REQUEST_ANNOUNCE_PACKET AnnounceRequest;
    ULONG AnnouncementRequestLength;
    NTSTATUS Status;

    PAGED_CODE();
    //
    // If we don't
    AnnounceRequest.Type = AnnouncementRequest;

    AnnounceRequest.RequestAnnouncement.Flags = 0;

    strcpy( AnnounceRequest.RequestAnnouncement.Reply,
            Transport->DomainInfo->DomOemComputerName.Buffer );

    AnnouncementRequestLength = FIELD_OFFSET(REQUEST_ANNOUNCE_PACKET, RequestAnnouncement.Reply) +
                                Transport->DomainInfo->DomOemComputerName.Length + 1;

    Status = BowserSendSecondClassMailslot(Transport,
                                    DestinationName,
                                    NameType,
                                    &AnnounceRequest,
                                    AnnouncementRequestLength,
                                    TRUE,
                                    MAILSLOT_BROWSER_NAME,
                                    NULL);

    return Status;
}

VOID
BowserpInitializeTdi (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables used in the transport
    package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the Transport list chain
    //

    InitializeListHead(&BowserTransportHead);

    ExInitializeResourceLite(&BowserTransportDatabaseResource);

    KeInitializeSpinLock(&BowserTransportMasterNameSpinLock);

    BowserInitializeDomains();
}

VOID
BowserpUninitializeTdi (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables used in the transport
    package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    ASSERT (IsListEmpty(&BowserTransportHead));

    ExDeleteResourceLite(&BowserTransportDatabaseResource);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowtdi.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    tdi.h

Abstract:

    This module defines all the constructs that are used when referencing
    the TDI (Transport Driver Interface) driver in NT.

Author:

    Larry Osterman (LarryO) 1-Jun-1990

Revision History:

    1-Jun-1990  LarryO

        Created

--*/
#ifndef _BOWTDI_
#define _BOWTDI_


struct _TRANSPORT;

struct _TRANSPORT_NAME;

struct _BOWSER_TIMER;

typedef enum {
    None,
    PotentialBackup,
    Backup,
    Master
} BROWSERROLE, *PBROWSERROLES;

typedef enum {
    Idle,
    ElectionInProgress,
    RunningElection,
    DeafToElections                     // Set if no become master IRPs outstanding.
} ELECTIONROLE, *PELECTIONROLE;

struct _PAGED_TRANSPORT;
struct _PAGED_TRANSPORT_NAME;


typedef struct _TRANSPORT {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    ULONG ReferenceCount;               // Reference count for structure.

    struct _PAGED_TRANSPORT *PagedTransport;

    struct _TRANSPORT_NAME *ComputerName; // Computer name.
    struct _TRANSPORT_NAME *PrimaryDomain;// Primary domain.
    struct _TRANSPORT_NAME *AltPrimaryDomain;// Primary domain.
    struct _TRANSPORT_NAME *MasterBrowser;// Master browser name.
    struct _TRANSPORT_NAME *BrowserElection;// Master browser name.

    PDOMAIN_INFO DomainInfo;            // Domain being emulated.

    ULONG DatagramSize;                 // Size of largest DG in bytes.

    //
    //  The token is used to match incoming getbrowserserverlist responses with
    //  the request that they are associated with.
    //
    //  It is protected by the backup list spin lock, and is incremented every
    //  time we send a GetBackupList request.
    //

    ULONG BrowserServerListToken;       // Token for GetBrowserList request.

    PFILE_OBJECT    IpxSocketFileObject;
    PDEVICE_OBJECT  IpxSocketDeviceObject;

    PBACKUP_LIST_RESPONSE_1 BowserBackupList;

    //
    //  Role of workstation in election.
    //

    ELECTIONROLE ElectionState;

    ERESOURCE AnnounceTableLock;        // Lock for announce table.
    ERESOURCE Lock;                     // Lock protecting fields below.

    BOWSER_TIMER ElectionTimer;

    BOWSER_TIMER FindMasterTimer;

    //
    //  List of browser servers active
    //

    ERESOURCE BrowserServerListResource;// Resource protecting BrowserServerList.

    KEVENT GetBackupListComplete;

    IRP_QUEUE BecomeBackupQueue;

    IRP_QUEUE BecomeMasterQueue;

    IRP_QUEUE FindMasterQueue;

    IRP_QUEUE WaitForMasterAnnounceQueue;

    IRP_QUEUE ChangeRoleQueue;

    IRP_QUEUE WaitForNewMasterNameQueue;

} TRANSPORT, *PTRANSPORT;

typedef struct _PAGED_TRANSPORT {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    PTRANSPORT NonPagedTransport;

    LIST_ENTRY GlobalNext;              // Pointer to next transport.
    LIST_ENTRY NameChain;               // List of names bound to this xport.

    UNICODE_STRING TransportName;       // Name of transport

    ULONG NumberOfBrowserServers;       // Number of browser servers in table.
    ULONG NumberOfServersInTable;       // Number of servers in browser svc.
    RTL_GENERIC_TABLE AnnouncementTable; // Announcement table for xport
    RTL_GENERIC_TABLE DomainTable;      // Domain table for xport
    LIST_ENTRY BackupBrowserList;       // List of active backup browsers.
    ULONG NumberOfBackupServerListEntries;
    HANDLE          IpxSocketHandle;

    //
    //  WinBALL compatible browser fields.
    //

    BROWSERROLE Role;                   // Role of browser in domain.
    ULONG ServiceStatus;                // Status of browser service.

    ULONG ElectionCount;
    ULONG ElectionsSent;                // Number of election requests sent.
    ULONG NextElection;
    ULONG Uptime;
    ULONG TimeLastLost;
    ULONG ElectionCriteria;
    ULONG TimeMaster;                   // The time we became the master.
    ULONG LastElectionSeen;             // The last time we saw an election.
    ULONG OtherMasterTime;              // Next time we can complain about another master browser

    UNICODE_STRING MasterName;
    STRING         MasterBrowserAddress;

    PWCHAR *BrowserServerListBuffer;    // Buffer containing browser server names

    ULONG BrowserServerListLength;      // Number of browser servers in list.

    ULONG IpSubnetNumber;               //

    USHORT  Flags;                      // Flags for transport.
#define ELECT_LOST_LAST_ELECTION    0x0001  // True if we lost the last election.
#define DIRECT_HOST_IPX             0x8000  // True if Xport is a direct host IPX

    BOOLEAN Wannish;                    // True if transport is wannish.
    BOOLEAN PointToPoint;               // True if transport is a gateway (RAS).
    BOOLEAN IsPrimaryDomainController;  // True if transport has the Domain[1B] name registered
    BOOLEAN DisabledTransport;          // True if transport is disabled
    BOOLEAN DeletedTransport;           // True if transport has been deleted

} PAGED_TRANSPORT, *PPAGED_TRANSPORT;




typedef struct _TRANSPORT_NAME {
    USHORT  Signature;                   // Structure signature.
    USHORT  Size;                       // Structure size in bytes.
    CHAR    NameType;
    BOOLEAN ProcessHostAnnouncements;   // TRUE if processing announcements.
    LONG    ReferenceCount;             // Reference count for T.N.
    struct _PAGED_TRANSPORT_NAME *PagedTransportName;
    PTRANSPORT Transport;
    PFILE_OBJECT FileObject;            // File object for transport device
    PDEVICE_OBJECT DeviceObject;        // Device object for transport
    ANSI_STRING  TransportAddress;      // Transport address for user.
} TRANSPORT_NAME, *PTRANSPORT_NAME;

typedef struct _PAGED_TRANSPORT_NAME {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    PTRANSPORT_NAME NonPagedTransportName;
    PBOWSER_NAME Name;
    LIST_ENTRY TransportNext;           // Pointer to next name on transport.
    LIST_ENTRY NameNext;                // Pointer to next name on bowser name.
    HANDLE Handle;                      // Handle to transport endpoint
} PAGED_TRANSPORT_NAME, *PPAGED_TRANSPORT_NAME;

#define LOCK_TRANSPORT(Transport)   \
    ExAcquireResourceExclusiveLite(&(Transport)->Lock, TRUE);

#define LOCK_TRANSPORT_SHARED(Transport)   \
    ExAcquireResourceSharedLite(&(Transport)->Lock, TRUE);

#define UNLOCK_TRANSPORT(Transport) \
    ExReleaseResourceLite(&(Transport)->Lock);


#define INITIALIZE_ANNOUNCE_DATABASE(Transport) \
    ExInitializeResourceLite(&Transport->AnnounceTableLock);

#define UNINITIALIZE_ANNOUNCE_DATABASE(Transport) \
    ExDeleteResourceLite(&Transport->AnnounceTableLock);


#define LOCK_ANNOUNCE_DATABASE_SHARED(Transport)        \
    ExAcquireResourceSharedLite(&Transport->AnnounceTableLock,\
                            TRUE                        \
                            );

#define LOCK_ANNOUNCE_DATABASE(Transport)               \
    ExAcquireResourceExclusiveLite(&Transport->AnnounceTableLock,\
                            TRUE                        \
                            );

#define UNLOCK_ANNOUNCE_DATABASE(Transport) \
    ExReleaseResourceLite(&Transport->AnnounceTableLock);


//
//  The first parameter to the BowserEnumerateTransports routine.
//

typedef
NTSTATUS
(*PTRANSPORT_ENUM_ROUTINE) (
    IN PTRANSPORT Transport,
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(*PTRANSPORT_NAME_ENUM_ROUTINE) (
    IN PTRANSPORT_NAME Transport,
    IN OUT PVOID Context
    );


//
//  TDI Interface routines
//

NTSTATUS
BowserTdiAllocateTransport (
    PUNICODE_STRING TransportName,
    PUNICODE_STRING EmulatedDomainName,
    PUNICODE_STRING EmulatedComputerName
    );

PTRANSPORT_NAME
BowserFindTransportName(
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserCreateTransportName (
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserFreeTransportByName (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName
    );

NTSTATUS
BowserUnbindFromAllTransports(
    VOID
    );

NTSTATUS
BowserDeleteTransportNameByName(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserEnumerateTransports (
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement);

PTRANSPORT
BowserFindTransport (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName OPTIONAL
    );

VOID
BowserReferenceTransport (
    IN PTRANSPORT Transport
    );

VOID
BowserDereferenceTransport (
    IN PTRANSPORT Transport
    );


VOID
BowserReferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserDereferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserSendRequestAnnouncement(
    IN PUNICODE_STRING DestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    );

VOID
BowserpInitializeTdi (
    VOID
    );

VOID
BowserpUninitializeTdi (
    VOID
    );

NTSTATUS
BowserBuildTransportAddress (
    OUT PANSI_STRING RemoteAddress,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserFreeTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserForEachTransportInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachTransport (
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachTransportName (
    IN PTRANSPORT Transport,
    IN PTRANSPORT_NAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserSendSecondClassMailslot (
    IN PTRANSPORT Transport,
    IN PVOID RecipientAddress,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Message,
    IN ULONG MessageLength,
    IN BOOLEAN WaitForCompletion,
    IN PCHAR mailslotNameData,
    IN PSTRING DestinationAddress OPTIONAL
    );

NTSTATUS
BowserUpdateProviderInformation(
    IN OUT PPAGED_TRANSPORT PagedTransport
    );

NTSTATUS
BowserSetDomainName(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING DomainName
    );

NTSTATUS
BowserAddDefaultNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

NTSTATUS
BowserDeleteDefaultDomainNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

ULONG
BowserTransportFlags(
    IN PPAGED_TRANSPORT PagedTransport
    );

extern
LIST_ENTRY
BowserTransportHead;

extern
ERESOURCE
BowserTransportDatabaseResource;

#endif  // _BOWTDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowser.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bowser.h

Abstract:

    This module is the main header file for the NT redirector file
    system.

Author:

    Darryl Havens (darrylh) 29-Jun-1989
    Larry Osterman (larryo) 06-May-1991


Revision History:


--*/


#ifndef _BOWSER_
#define _BOWSER_

#ifndef BOWSERDBG
#define BOWSERDBG 0
#endif
//
//
//  Global include file definitions
//
//


#include <ntddbrow.h>                   // Browser FSCTL defs.

#include <lmcons.h>                     // Include global network constants

#include <tdikrnl.h>

#include <tdi.h>

#include <smbtypes.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbgtpt.h>
#include <smbipx.h>

#include <hostannc.h>                   // Host announcement structures.
#include <lmserver.h>



//
//
//  Separate include file definitions
//
//
//

#include "bowpub.h"                     // Public bowser definitions.

#include "bowtypes.h"                   // Bowser structure type definitions.

#include <bowdbg.h>                      // Debugging definitions.

#include "workque.h"                    // FSP/FSD worker queue functions.

#include "bowdata.h"                    // Global data variables.

#include "fspdisp.h"                    // Global FSP dispatch definitions.

#include "fsddisp.h"                    // Global FSP dispatch definitions.

#include "domain.h"                     // Domain emulation specific definitions.

#include "bowname.h"                    // Bowser name structure definitions.

#include "bowtimer.h"                   // Timer related routines

#include "bowtdi.h"                     // Bowser TDI specific definitions.

#include "receive.h"                    // Bowser receive engine code.

#include "announce.h"                   // Announcement related stuff

#include "mailslot.h"                   // Mailslot specific routines

#include "bowelect.h"                   // Election routines

#include "bowmastr.h"                   // Master related routines.

#include "bowbackp.h"                   // Backup related routines.

#include "brsrvlst.h"                   // Definitions for browser server list.

#include "bowipx.h"

#include "bowsecur.h"                   // definitions for security

#include <wchar.h>                      // CRT wide character routines

#include "..\rdbss\smb.mrx\ntbowsif.h"

//++
//
//  VOID
//  BowserCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--

#define BowserCompleteRequest(IRP,STATUS) {       \
    (IRP)->IoStatus.Status = (STATUS);            \
    if (NT_ERROR((STATUS))) {                     \
        (IRP)->IoStatus.Information = 0;          \
    }                                             \
    IoCompleteRequest( (IRP), 0 );                \
}



//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
      #define try_return(S)  { S; goto try_exit; }
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

#ifdef  _M_IX86
#define INLINE _inline
#else
#define INLINE
#endif

_inline BOOLEAN
IsZeroTerminated(
    IN PSZ String,
    IN ULONG MaximumStringLength
    )
//  Return TRUE if a zero terminator exists on String.
{
    while ( MaximumStringLength-- ) {
        if (*String++ == 0 ) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
BowserStopProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

BOOLEAN
BowserMapUsersBuffer (
    IN PIRP Irp,
    OUT PVOID *UserBuffer,
    IN ULONG Length
    );

NTSTATUS
BowserLockUsersBuffer (
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

NTSTATUS
BowserConvertType3IoControlToType2IoControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

ULONG
BowserPackNtString(
    PUNICODE_STRING string,
    ULONG_PTR BufferDisplacement,
    PCHAR dataend,
    PCHAR * laststring
    );

ULONG
BowserPackUnicodeString(
    IN OUT PWSTR * string,     // pointer by reference: string to be copied.
    IN ULONG StringLength,      // Length of this string.
    IN ULONG_PTR OutputBufferDisplacement,  // Amount to subtract from output buffer
    IN PVOID dataend,          // pointer to end of fixed size data.
    IN OUT PVOID * laststring  // pointer by reference: top of string data.
    );

ULONG
BowserTimeUp(
    VOID
    );

ULONG
BowserRandom(
    ULONG MaxValue
    );

VOID
_cdecl
BowserWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    );

VOID
BowserLogIllegalName(
    IN NTSTATUS NtStatusCode,
    IN PVOID NameBuffer,
    IN USHORT NameBufferSize
    );

VOID
BowserInitializeFsd(
    VOID
    );

VOID
BowserReferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    );

VOID
BowserDereferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    );
VOID
BowserInitializeDiscardableCode(
    VOID
    );

VOID
BowserUninitializeDiscardableCode(
    VOID
    );

NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    );


#endif // _BOWSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowtimer.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtimer.c

Abstract:

    This module implements all of the timer related routines for the NT
    browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop


BOOL bEnableExceptionBreakpoint = FALSE;



VOID
BowserTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BowserTimerDispatcher (
    IN PVOID Context
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserInitializeTimer)
#pragma alloc_text(PAGE4BROW, BowserUninitializeTimer)
#pragma alloc_text(PAGE4BROW, BowserStartTimer)
#pragma alloc_text(PAGE4BROW, BowserStopTimer)
#pragma alloc_text(PAGE4BROW, BowserTimerDispatcher)
#endif

LONG
BrExceptionFilter( EXCEPTION_POINTERS *    pException)
{
    //
    // Note: BrExceptionFilter is defined only for checked builds (ifdef DBG)
    //

    DbgPrint("[Browser] exception 0x%lx.\n", pException->ExceptionRecord->ExceptionCode );
    if ( bEnableExceptionBreakpoint &&
         pException->ExceptionRecord->ExceptionCode != STATUS_INSUFFICIENT_RESOURCES &&
         pException->ExceptionRecord->ExceptionCode != STATUS_WORKING_SET_QUOTA ) {
        DbgBreakPoint();
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
BowserInitializeTimer(
    IN PBOWSER_TIMER Timer
    )
{
    PAGED_CODE();

    KeInitializeTimer(&Timer->Timer);

    KeInitializeEvent(&Timer->TimerInactiveEvent, NotificationEvent, TRUE);

    KeInitializeSpinLock(&Timer->Lock);

    ExInitializeWorkItem(&Timer->WorkItem, BowserTimerDispatcher, Timer);

    Timer->AlreadySet = FALSE;
    Timer->Canceled = FALSE;
    Timer->SetAgain = FALSE;

    Timer->Initialized = TRUE;
}

VOID
BowserUninitializeTimer(
    IN PBOWSER_TIMER Timer
    )
/*++

Routine Description:
    Prepare the timer for being uninitialized.

Arguments:
    IN PBOWSER_TIMER Timer - Timer to stop

Return Value
    None.

--*/

{
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    Timer->Initialized = FALSE;

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    //
    //  First stop the timer.
    //

    BowserStopTimer(Timer);

    //
    //  Now wait to make sure that any the timer routine that is currently
    //  executing the timer completes.  This allows us to make sure that we
    //  never delete a transport while a timer routine is executing.
    //

    KeWaitForSingleObject(&Timer->TimerInactiveEvent, Executive, KernelMode, FALSE, NULL);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}

//  Notes for stopping a timer
//  ==========================
//
//  Timers run through various states. During some of them they cannot be
//  cancelled.  In order to guarantee that we can reliably stop and start
//  timers, they can only be started or stopped at LOW_LEVEL (ie, not from
//  DPC_LEVEL.
//
//  If the timer is not running then StopTimer does nothing.
//
//  If queued inside the kernel timer package then KeCancelTimer will work
//  and the timer contents cleaned up.
//
//  If the kernel timer package has queued the dpc routine then KeCancelTimer
//  will fail. We can flag the timer as canceled. BowserTimerDispatcher will
//  cleanup the timer when it fires.
//


//  Notes for starting a timer
//  ==========================
//
//  If StartTimer is called on a clean timer then it sets the contents
//  appropriately and gives the timer to the kernel timer package.
//
//  If the timer is canceled but not cleaned up then StartTimer will update
//  the contents of the timer to show where the new TimerRoutine and TimerContext.
//  it will indicate that the timer is no longer canceled and is now SetAgain.
//
//  If the timer is already SetAgain then StartTimer will update the contents
//  of the timer to hold the new TimerRoutine and TimerContext.
//
//  When BowserTimerDispatcher is called on a SetAgain timer, it sets the timer
//  to its normal state and gives the timer to the kernel timer package.
//


BOOLEAN
BowserStartTimer(
    IN PBOWSER_TIMER Timer,
    IN ULONG MillisecondsToExpireTimer,
    IN PBOWSER_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )
/*++

Routine Description:
    Set Timer to call TimerRoutine after MillisecondsToExpire. TimerRoutine
    is to be called at normal level.

Arguments:

    IN PBOWSER_TIMER Timer
    IN ULONG MillisecondsToExpireTimer
    IN PBOWSER_TIMER_ROUTINE TimerRoutine
    IN PVOID Context - Parameter to TimerRoutine

Return Value
    BOOLEAN - TRUE if timer set.

--*/
{
    LARGE_INTEGER Timeout;
    BOOLEAN ReturnValue;
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

    Timeout.QuadPart = (LONGLONG)MillisecondsToExpireTimer * (LONGLONG)(-10000);
//    Timeout = LiNMul(MillisecondsToExpireTimer, -10000);

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    if (!Timer->Initialized) {
        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return(FALSE);
    }

    dprintf(DPRT_TIMER, ("BowserStartTimer %lx, TimerRoutine %x.  Set to expire at %lx%lx (%ld/%ld ms)\n", Timer, TimerRoutine, Timeout.HighPart, Timeout.LowPart, -1 * Timeout.LowPart, MillisecondsToExpireTimer));

    //
    //  We shouldn't be able to start the timer while it is
    //  already running unless its also cancelled.
    //


    if (Timer->AlreadySet == TRUE) {

        if (Timer->Canceled) {

            //
            //  This timer has been canceled, but the canceled routine
            //  hasn't run yet.
            //
            //  Flag that the timer has been re-set, and return to
            //  the caller.  When the BowserTimerDispatch is finally
            //  executed, the new timer will be set.
            //

            Timer->Timeout = Timeout;

            Timer->TimerRoutine = TimerRoutine;

            Timer->SetAgain = TRUE;

            RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return(TRUE);

        }

        InternalError(("Timer started without already being set"));

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return(FALSE);

    }

    ASSERT (!Timer->Canceled);

    ASSERT (!Timer->SetAgain);

    Timer->Timeout = Timeout;

    Timer->TimerRoutine = TimerRoutine;

    Timer->TimerContext = Context;

    Timer->AlreadySet = TRUE;

    Timer->Canceled = FALSE;

    Timer->SetAgain = FALSE;

    //
    //  Set the inactive event to the not signalled state to indicate that
    //  there is timer activity outstanding.
    //

    KeResetEvent(&Timer->TimerInactiveEvent);

    //
    //  We are now starting the timer.  Initialize the DPC and
    //  set the timer.
    //

    KeInitializeDpc(&Timer->Dpc,
                    BowserTimerDpc,
                    Timer);

    ReturnValue = KeSetTimer(&Timer->Timer, Timeout, &Timer->Dpc);

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return ReturnValue;
}


VOID
BowserStopTimer(
    IN PBOWSER_TIMER Timer
    )
/*++

Routine Description:
    Stop the timer from calling the TimerRoutine.

Arguments:
    IN PBOWSER_TIMER Timer - Timer to stop

Return Value
    None.

--*/
{
    KIRQL OldIrql;

    //
    //  Do an unsafe test to see if the timer is already set, we can return.
    //

    if (!Timer->AlreadySet) {
        return;
    }

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    //  You can only stop a timer at LOW_LEVEL
    //

    ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    dprintf(DPRT_TIMER, ("BowserStopTimer %lx\n", Timer));

    //
    //  If the timer isn't running, just early out.
    //

    if (!Timer->AlreadySet) {

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    Timer->Canceled = TRUE;

    if (!KeCancelTimer(&Timer->Timer)) {

        //
        //  The timer has already fired. It could be in the dpc queue or
        //  the work queue. The timer is marked as canceled.
        //

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    //
    //  The timer was still in the kernel timer package so we cancelled the
    //  timer completely. Return timer to initial state.
    //

    Timer->AlreadySet = FALSE;

    //
    //  The timer isn't canceled, so it can't be reset.
    //

    Timer->SetAgain = FALSE;

    Timer->Canceled = FALSE;

    KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
//    DbgPrint("Cancel timer %lx complete\n", Timer);
}

VOID
BowserTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:
    This routine is called when the timeout expires. It is called at Dpc level
    to queue a WorkItem to a system worker thread.

Arguments:

    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2

Return Value
    None.

--*/
{
    PBOWSER_TIMER Timer = Context;

    ASSERT (Dpc == &Timer->Dpc);

    //    DbgPrint("Timer %lx fired\n", Timer);

    //
    // Due to bug 245645 we need to queue in delayed worker queue rather then execute timed tasks.
    // OLD WAY: ExQueueWorkItem(&Timer->WorkItem, DelayedWorkQueue);
    //

    BowserQueueDelayedWorkItem( &Timer->WorkItem );


    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

}

VOID
BowserTimerDispatcher (
    IN PVOID Context
    )
/*++

Routine Description:

    Call the TimerRoutine and cleanup.

Arguments:

    IN PVOID Context - Original parameter supplied to BowserStartTimer

Return Value
    None.

--*/
{
    IN PBOWSER_TIMER Timer = Context;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    try {
        KIRQL OldIrql;
        PBOWSER_TIMER_ROUTINE RoutineToCall;
        PVOID ContextForRoutine;

        ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

        //
        //  If the timer was uninitialized, return right away.
        //

        if (!Timer->Initialized) {

            dprintf(DPRT_TIMER, ("Timer %lx was uninitialized. Returning.\n", Timer));

            //
            //  Set the inactive event to the signalled state to indicate that
            //  the outstanding timer activity has completed.
            //

            KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
            RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return;
        }

        if (Timer->Canceled) {

            dprintf(DPRT_TIMER, ("Timer %lx was cancelled\n", Timer));

            //
            //  If the timer was reset, this indicates that the timer was
            //  canceled, but the timer was in the DPC (or executive worker)
            //  queue.  We want to re-run the timer routine.
            //

            if (Timer->SetAgain) {

                ASSERT (Timer->AlreadySet);

                Timer->SetAgain = FALSE;

                dprintf(DPRT_TIMER, ("Timer %lx was re-set. Re-setting timer\n", Timer));

                //
                //  We are now starting the timer.  Initialize the DPC and
                //  set the timer.
                //

                KeInitializeDpc(&Timer->Dpc,
                                BowserTimerDpc,
                                Timer);

                KeSetTimer(&Timer->Timer, Timer->Timeout, &Timer->Dpc);

                RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            } else {

                dprintf(DPRT_TIMER, ("Timer %lx was successfully canceled.\n", Timer));

                Timer->AlreadySet = FALSE;

                Timer->Canceled = FALSE;

                //
                //  Set the inactive event to the signalled state to indicate that
                //  the outstanding timer activity has completed.
                //

                KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
                RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            }

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return;
        }

        ASSERT (Timer->AlreadySet);

        ASSERT (!Timer->SetAgain);

        Timer->AlreadySet = FALSE;

        dprintf(DPRT_TIMER, ("Timer %lx fired. Calling %lx\n", Timer, Timer->TimerRoutine));

        //
        //  We release the spinlock so save timer contents locally.
        //

        RoutineToCall = Timer->TimerRoutine;

        ContextForRoutine = Timer->TimerContext;

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        RoutineToCall(ContextForRoutine);

        ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);
        if ( !Timer->AlreadySet ) {
            KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
        }
        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    } except (BR_EXCEPTION) {
#if DBG
        KdPrint(("BOWSER: Timer routine %lx faulted: %X\n", Timer->TimerRoutine, GetExceptionCode()));
        DbgBreakPoint();
#else
        KeBugCheck(9999);
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowtimer.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowtimer.h

Abstract:

    This module declares definitions dealing with bowser timers.

Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BOWTIMER_
#define _BOWTIMER_

struct _TRANSPORT;

typedef
NTSTATUS
(*PBOWSER_TIMER_ROUTINE)(
    IN struct _TRANSPORT *Transport
    );

//  BOWSER_TIMER flags:
//      Canceled is TRUE when a timer is cancelled but is already in
//      the dpc queue.
//
//      AlreadySet is used to ensure we stop the timer before restarting it.
//
//      Reset is set to TRUE when a timer has been stopped and restarted while
//      in the dpc queue. The Lock is used to ensure ordered access.
//      Note: a timer can be stopped and reset multiple times before it gets
//      to the front of the dpc queue.
//

typedef struct _BOWSER_TIMER {
    KDPC                    Dpc;
    KTIMER                  Timer;
    KSPIN_LOCK              Lock;
    KEVENT                  TimerInactiveEvent;
    PBOWSER_TIMER_ROUTINE   TimerRoutine;
    PVOID                   TimerContext;
    LARGE_INTEGER           Timeout;
    WORK_QUEUE_ITEM         WorkItem;
    BOOLEAN                 AlreadySet;
    BOOLEAN                 Initialized;
    BOOLEAN                 Canceled;
    BOOLEAN                 SetAgain;

} BOWSER_TIMER, *PBOWSER_TIMER;

VOID
BowserInitializeTimer(
    IN PBOWSER_TIMER Timer
    );

VOID
BowserStopTimer (
    IN PBOWSER_TIMER Timer
    );

VOID
BowserUninitializeTimer(
    IN PBOWSER_TIMER Timer
    );

BOOLEAN
BowserStartTimer (
    IN PBOWSER_TIMER Timer,
    IN ULONG MillisecondsToExpireTimer,
    IN PBOWSER_TIMER_ROUTINE TimerExpirationRoutine,
    IN PVOID Context
    );

#endif // _BOWTIMER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\bowutils.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowutils.c

Abstract:

    This module implements various useful routines for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    24-Sep-1991 larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserMapUsersBuffer)
#pragma alloc_text(PAGE, BowserLockUsersBuffer)
#pragma alloc_text(PAGE, BowserConvertType3IoControlToType2IoControl)
#pragma alloc_text(PAGE, BowserPackNtString)
#pragma alloc_text(PAGE, BowserPackUnicodeString)
#pragma alloc_text(PAGE, BowserRandom)
#pragma alloc_text(PAGE, BowserTimeUp)
#pragma alloc_text(PAGE, BowserReferenceDiscardableCode)
#pragma alloc_text(PAGE, BowserDereferenceDiscardableCode)
#pragma alloc_text(PAGE, BowserUninitializeDiscardableCode)
#pragma alloc_text(INIT, BowserInitializeDiscardableCode)

#if DBG
#ifndef PRODUCT1
#pragma alloc_text(PAGE, BowserTrace)
#endif
#pragma alloc_text(PAGE, BowserInitializeTraceLog)
#pragma alloc_text(PAGE, BowserOpenTraceLogFile)
#pragma alloc_text(PAGE, BowserUninitializeTraceLog)
#pragma alloc_text(PAGE, BowserDebugCall)
#endif

#endif

BOOLEAN
BowserMapUsersBuffer (
    IN PIRP Irp,
    OUT PVOID *UserBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will probe and lock the buffer described by the
    provided Irp.

Arguments:

    IN PIRP Irp - Supplies the IRP that is to be mapped.
    OUT PVOID *Buffer - Returns a buffer that maps the user's buffer in the IRP

Return Value:

    TRUE - The buffer was mapped into the current address space.
    FALSE - The buffer was NOT mapped in, it was already mappable.


--*/

{
    PAGED_CODE();

    if (Irp->MdlAddress) {
        *UserBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, LowPagePriority);
        return FALSE;
    } else {
        if (Irp->AssociatedIrp.SystemBuffer != NULL) {
            *UserBuffer = Irp->AssociatedIrp.SystemBuffer;

        } else if (Irp->RequestorMode != KernelMode) {
            PIO_STACK_LOCATION IrpSp;

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            if ((Length != 0) && (Irp->UserBuffer != 0)) {

                if ((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) ||
                    (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)) {
                    ULONG ControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

                    if ((ControlCode & 3) == METHOD_NEITHER) {
                        ProbeForWrite( Irp->UserBuffer,
                                        Length,
                                        sizeof(UCHAR) );
                    } else {
                        ASSERT ((ControlCode & 3) != METHOD_BUFFERED);
                        ASSERT ((ControlCode & 3) != METHOD_IN_DIRECT);
                        ASSERT ((ControlCode & 3) != METHOD_OUT_DIRECT);
                    }

                } else if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_SECURITY) ||
                    (IrpSp->MajorFunction == IRP_MJ_DIRECTORY_CONTROL)) {

                    ProbeForWrite( Irp->UserBuffer,
                           Length,
                           sizeof(UCHAR) );
                } else {
                    ProbeForRead( Irp->UserBuffer,
                          Length,
                          sizeof(UCHAR) );
                }
            }

            *UserBuffer = Irp->UserBuffer;
        }

        return FALSE;
    }

}

NTSTATUS
BowserLockUsersBuffer (
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine will probe and lock the buffer described by the
    provided Irp.

Arguments:

    IN PIRP Irp - Supplies the IRP that is to be locked.
    IN LOCK_OPERATION Operation - Supplies the operation type to probe.

Return Value:

    None.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    if ((Irp->MdlAddress == NULL)) {

        try {

            Irp->MdlAddress = IoAllocateMdl(Irp->UserBuffer,
                     BufferLength,
                     FALSE,
                     TRUE,
                     NULL);

            if (Irp->MdlAddress == NULL) {
               return(STATUS_INSUFFICIENT_RESOURCES);
            }


            //
            //  Now probe and lock down the user's data buffer.
            //

            MmProbeAndLockPages(Irp->MdlAddress,
                            Irp->RequestorMode,
                            Operation);

        } except (BR_EXCEPTION) {
            Status =  GetExceptionCode();

            if (Irp->MdlAddress != NULL) {
                //
                //  We blew up in the probe and lock, free up the MDL
                //  and set the IRP to have a null MDL pointer - we are failing the
                //  request
                //

                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
            }

        }

    }

    return Status;

}

NTSTATUS
BowserConvertType3IoControlToType2IoControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does the work necessary to convert a type 3 IoCtl to a
    type 2 IoCtl.  We do this when we have to pass a user IRP to the FSP.


Arguments:

    IN PIRP Irp - Supplies an IRP to convert
    IN PIO_STACK_LOCATION IrpSp - Supplies an Irp Stack location for convenience

Return Value:

    NTSTATUS - Status of operation

Note: This must be called in the FSD.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) {
        Status = BowserLockUsersBuffer(Irp, IoWriteAccess, IrpSp->Parameters.DeviceIoControl.OutputBufferLength);

        //
        //  If we were unable to lock the users output buffer, return now.
        //

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    }

    ASSERT (Irp->AssociatedIrp.SystemBuffer == NULL);

    try {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) {
            PCHAR InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            ULONG InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

            Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(PagedPool,
                                                            InputBufferLength, '  GD');

            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // If called from a user process,
            //  probe the buffer to ensure it is in the callers address space.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead( InputBuffer,
                              InputBufferLength,
                              sizeof(UCHAR));
            }

            RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer,
                       InputBuffer,
                       InputBufferLength);

            Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

        } else {
            Irp->AssociatedIrp.SystemBuffer = NULL;
        }

    } except (BR_EXCEPTION) {

        if (Irp->AssociatedIrp.SystemBuffer != NULL) {
           ExFreePool(Irp->AssociatedIrp.SystemBuffer);
        }
        return GetExceptionCode();

    }

    return STATUS_SUCCESS;
}

ULONG
BowserPackNtString(
    PUNICODE_STRING string,
    ULONG_PTR BufferDisplacement,
    PCHAR dataend,
    PCHAR * laststring
    )
/**     BowserPackNtString
 *
 *  BowserPackNtString is used to stuff variable-length data, which
 *  is pointed to by (surpise!) a pointer.  The data is assumed
 *  to be a nul-terminated string (ASCIIZ).  Repeated calls to
 *  this function are used to pack data from an entire structure.
 *
 *  Upon first call, the laststring pointer should point to just
 *  past the end of the buffer.  Data will be copied into the buffer from
 *  the end, working towards the beginning.  If a data item cannot
 *  fit, the pointer will be set to NULL, else the pointer will be
 *  set to the new data location.
 *
 *  Pointers which are passed in as NULL will be set to be pointer
 *  to and empty string, as the NULL-pointer is reserved for
 *  data which could not fit as opposed to data not available.
 *
 *  Returns:  0 if could not fit data into buffer
 *    else size of data stuffed (guaranteed non-zero)
 *
 *  See the test case for sample usage.  (tst/packtest.c)
 */

{
    LONG size;

    PAGED_CODE();

    dlog(DPRT_PACK, ("BowserPackNtString:\n"));
    dlog(DPRT_PACK, ("  string=%Fp, *string=%Fp, **string=\"%us\"\n",
                                                    string, *string, *string));
    dlog(DPRT_PACK, ("  end=%Fp\n", dataend));
    dlog(DPRT_PACK, ("  last=%Fp, *last=%Fp, **last=\"%us\"\n",
                                        laststring, *laststring, *laststring));

    ASSERT (dataend < *laststring);

    //
    //  is there room for the string?
    //

    size = string->Length;

    if ((*laststring - dataend) < size) {
        string->Length = 0;
        return(0);
    } else {
        *laststring -= size;
        RtlCopyMemory(*laststring, string->Buffer, size);
        string->Buffer = (PWSTR)((*laststring) - BufferDisplacement);
        return(size);
    }
}

ULONG
BowserPackUnicodeString(
    IN OUT PWCHAR * string,     // pointer by reference: string to be copied.
    IN ULONG StringLength,      // Length of this string (in bytes) (w/o trailing zero)
    IN ULONG_PTR OutputBufferDisplacement,  // Amount to subtract from output buffer
    IN PVOID dataend,          // pointer to end of fixed size data.
    IN OUT PVOID * laststring  // pointer by reference: top of string data.
    )

/*++

Routine Description:

    BowserPackUnicodeString is used to stuff variable-length data, which
    is pointed to by (surpise!) a pointer.  The data is assumed
    to be a nul-terminated string (ASCIIZ).  Repeated calls to
    this function are used to pack data from an entire structure.

    Upon first call, the laststring pointer should point to just
    past the end of the buffer.  Data will be copied into the buffer from
    the end, working towards the beginning.  If a data item cannot
    fit, the pointer will be set to NULL, else the pointer will be
    set to the new data location.

    Pointers which are passed in as NULL will be set to be pointer
    to and empty string, as the NULL-pointer is reserved for
    data which could not fit as opposed to data not available.

    See the test case for sample usage.  (tst/packtest.c)


Arguments:

    string - pointer by reference:  string to be copied.

    dataend - pointer to end of fixed size data.

    laststring - pointer by reference:  top of string data.

Return Value:

    0  - if it could not fit data into the buffer.  Or...

    sizeOfData - the size of data stuffed (guaranteed non-zero)

--*/

{
    DWORD  size;
    DWORD  Available       = (DWORD)((PCHAR)*laststring - (PCHAR)dataend);
    WCHAR  StringBuffer[1] = L"";

    PAGED_CODE();

    //
    //  Verify that there is room left for the string.  If a NULL string
    //    is input, there must be at least room for a UNICODE NULL, so set
    //    size to sizeof(WCHAR) in this case.
    //

    if (*string == NULL) {
        StringLength = 0;
        *string      = StringBuffer;
    }

    size = StringLength + sizeof(WCHAR);

    if (*laststring < dataend || size > Available) {
       *string = UNICODE_NULL;
       return(0);
    }

    *((PCHAR *)laststring) -= size;
    RtlCopyMemory(*laststring, *string, size-sizeof(WCHAR));
    *string = *laststring;
    (*string)[StringLength/2] = L'\0';
    *(PCHAR*)string -=OutputBufferDisplacement;
    return(size);

} // BowserUnicodePackString


ULONG
BowserTimeUp(
    VOID
    )
/*++

Routine Description:

    BowserTimeUp is used to return the number of seconds the browser has been
    running.


Arguments:

    None

Return Value:

    Number of seconds the browser has been up.

--*/
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeDelta;
    LARGE_INTEGER TimeUp;

    //
    //  These are the magic numbers needed to do our extended division.  The
    //  only numbers we ever need to divide by are
    //
    //      10,000 = convert 100ns tics to millisecond tics
    //
    //
    //  These values were stolen from ntos\rtl\time.c
    //

    LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13


    PAGED_CODE();

    KeQuerySystemTime(&CurrentTime);

    TimeDelta.QuadPart = CurrentTime.QuadPart - BowserStartTime.QuadPart;

    //
    //  TimeDelta is the number of 100ns units the bowser has been up.  Convert
    //  it to milliseconds using the magic routine.
    //

    TimeUp = RtlExtendedMagicDivide(TimeDelta, Magic10000, SHIFT10000);

    //
    //  Please note that TimeUp.LowPart wraps after about 49 days,
    //  this means that if a machine has been up for more than 49 days,
    //  we peg at 0xffffffff.
    //

    if (TimeUp.HighPart != 0) {
        return(0xffffffff);
    }

    return(TimeUp.LowPart);
}

ULONG
BowserRandom(
    IN ULONG MaxValue
    )
/*++

Routine Description:

    BowserRandom is used to return a random number between 0 and MaxValue

Arguments:

    MaxValue - The maximum value to return.

Return Value:

    Random # between 0 and MaxValue

--*/
{
    PAGED_CODE();

    return RtlRandom(&BowserRandomSeed) % MaxValue;
}


VOID
BowserReferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    BowserReferenceDiscardableCode is called to reference the browsers
    discardable code section.

    If the section is not present in memory, MmLockPagableCodeSection is
    called to fault the section into memory.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RdrReferenceDiscardableCode(SectionName);


}

VOID
BowserDereferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    BowserDereferenceDiscardableCode is called to dereference the browsers
    discardable code section.

    When the reference count drops to 0, a timer is set that will fire in <n>
    seconds, after which time the section will be unlocked.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    RdrDereferenceDiscardableCode(SectionName);
}

VOID
BowserInitializeDiscardableCode(
    VOID
    )
{
}

VOID
BowserUninitializeDiscardableCode(
    VOID
    )
{
    PAGED_CODE();
}

#if BOWSERPOOLDBG
typedef struct {
    ULONG Count;
    ULONG Size;
    PCHAR FileName;
    ULONG LineNumber;
} POOL_STATS, *PPOOL_STATS;


typedef struct _POOL_HEADER {
//    LIST_ENTRY ListEntry;
    ULONG NumberOfBytes;
    PPOOL_STATS Stats;
} POOL_HEADER, *PPOOL_HEADER;

ULONG CurrentAllocationCount;
ULONG CurrentAllocationSize;

ULONG NextFreeEntry = 0;

POOL_STATS PoolStats[POOL_MAXTYPE+1];

PVOID
BowserAllocatePool (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN ULONG Tag
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
#if 1
    ULONG i;
#endif

#if  POOL_TAGGING
    header = ExAllocatePoolWithTag( PoolType, sizeof(POOL_HEADER) + NumberOfBytes, Tag );
#else
    header = ExAllocatePool( PoolType, sizeof(POOL_HEADER) + NumberOfBytes );

#endif
    if ( header == NULL ) {
        return NULL;
    }
    header->NumberOfBytes = NumberOfBytes;

//    DbgPrint( "BOWSER: allocated type %d, size %d at %x\n", AllocationType, NumberOfBytes, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount++;
    CurrentAllocationSize += NumberOfBytes;
#if 1
    //
    //  Lets see if we've already allocated one of these guys.
    //


    for (i = 0;i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == LineNumber) &&
            (PoolStats[i].FileName == FileName)) {

            //
            //  Yup, remember this allocation and return.
            //

            header->Stats = &PoolStats[i];
            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    for (i = NextFreeEntry; i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == 0) &&
            (PoolStats[i].FileName == NULL)) {

            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;
            PoolStats[i].FileName = FileName;
            PoolStats[i].LineNumber = LineNumber;
            header->Stats = &PoolStats[i];

            NextFreeEntry = i+1;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    header->Stats = &PoolStats[i];
    PoolStats[POOL_MAXTYPE].Count++;
    PoolStats[POOL_MAXTYPE].Size += NumberOfBytes;
#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    return header + 1;
}

PVOID
BowserAllocatePoolWithQuota (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN ULONG Tag
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
#if 1
    ULONG i;
#endif

#if POOL_TAGGING
    header = ExAllocatePoolWithTagQuota( PoolType, sizeof(POOL_HEADER) + NumberOfBytes, Tag );
#else
    header = ExAllocatePoolWithQuota( PoolType, sizeof(POOL_HEADER) + NumberOfBytes );
#endif
    if ( header == NULL ) {
        return NULL;
    }
    header->NumberOfBytes = NumberOfBytes;

//    DbgPrint( "BOWSER: allocated type %d, size %d at %x\n", AllocationType, NumberOfBytes, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount++;
    CurrentAllocationSize += NumberOfBytes;
#if 1
    //
    //  Lets see if we've already allocated one of these guys.
    //


    for (i = 0;i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == LineNumber) &&
            (PoolStats[i].FileName == FileName)) {

            //
            //  Yup, remember this allocation and return.
            //

            header->Stats = &PoolStats[i];
            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    for (i = NextFreeEntry; i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == 0) &&
            (PoolStats[i].FileName == NULL)) {

            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;
            PoolStats[i].FileName = FileName;
            PoolStats[i].LineNumber = LineNumber;
            header->Stats = &PoolStats[i];

            NextFreeEntry = i+1;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    header->Stats = &PoolStats[i];
    PoolStats[POOL_MAXTYPE].Count++;
    PoolStats[POOL_MAXTYPE].Size += NumberOfBytes;

#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    return header + 1;
}

VOID
BowserFreePool (
    IN PVOID P
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
    PPOOL_STATS stats;
    ULONG size;

    header = (PPOOL_HEADER)P - 1;

    size = header->NumberOfBytes;
    stats = header->Stats;

//    if ( allocationType > POOL_MAXTYPE ) allocationType = POOL_MAXTYPE;
//    DbgPrint( "BOWSER: freed type %d, size %d at %x\n", allocationType, size, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount--;
    CurrentAllocationSize -= size;
#if 1
    stats->Count--;
    stats->Size -= size;
#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    ExFreePool( header );

    return;
}
#endif // BOWSERPOOLDBG

#if DBG

ERESOURCE
BrowserTraceLock;

HANDLE
BrowserTraceLogHandle = NULL;
UCHAR LastCharacter = '\n';

#ifndef PRODUCT1

VOID
BowserTrace(
    PCHAR FormatString,
    ...
    )

#define LAST_NAMED_ARGUMENT FormatString

{
    CHAR OutputString[1024];
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN ReleaseResource = FALSE;
    va_list ParmPtr;                    // Pointer to stack parms.
    KAPC_STATE ApcState;
    NTSTATUS Status;

    PAGED_CODE();


    if (BrowserTraceLogHandle == NULL) {

        // Attach to FSP when using handle
        if (IoGetCurrentProcess() != BowserFspProcess) {
            KeStackAttachProcess(BowserFspProcess, &ApcState );

            ProcessAttached = TRUE;
        }

        if (!NT_SUCCESS(BowserOpenTraceLogFile(L"\\SystemRoot\\Bowser.Log"))) {

            BrowserTraceLogHandle = (HANDLE) -1;

            if (ProcessAttached) {
                KeUnstackDetachProcess( &ApcState );
            }

            return;
        }

    } else if (BrowserTraceLogHandle == (HANDLE) -1) {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }

        return;
    }


    try {
        LARGE_INTEGER EndOfFile;

        ExAcquireResourceExclusive(&BrowserTraceLock, TRUE);
        ReleaseResource = TRUE;

        // re-verify we should be tracing (under lock).
        if (BrowserTraceLogHandle == NULL) {
            try_return(Status);
        }

        EndOfFile.HighPart = 0xffffffff;
        EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;

        if (LastCharacter == '\n') {
            LARGE_INTEGER SystemTime;
            TIME_FIELDS TimeFields;

            KeQuerySystemTime(&SystemTime);

            ExSystemTimeToLocalTime(&SystemTime, &SystemTime);

            RtlTimeToTimeFields(&SystemTime, &TimeFields);

            //
            //  The last character written was a newline character.  We should
            //  timestamp this record in the file.
            //
            sprintf(OutputString, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d: ",
                                                            TimeFields.Month,
                                                            TimeFields.Day,
                                                            TimeFields.Hour,
                                                            TimeFields.Minute,
                                                            TimeFields.Second,
                                                            TimeFields.Milliseconds);
            // Attach to FSP when using handle
            if (IoGetCurrentProcess() != BowserFspProcess) {
                KeStackAttachProcess(BowserFspProcess, &ApcState );

                ProcessAttached = TRUE;
            }

            if (!NT_SUCCESS(Status = ZwWriteFile(BrowserTraceLogHandle, NULL, NULL, NULL, &IoStatus, OutputString, strlen(OutputString), &EndOfFile, NULL))) {
                KdPrint(("Error writing time to Browser log file: %lX\n", Status));
                try_return(Status);
            }

            if (!NT_SUCCESS(IoStatus.Status)) {
                KdPrint(("Error writing time to Browser log file: %lX\n", IoStatus.Status));
                try_return(Status);
            }

            if (IoStatus.Information != strlen(OutputString)) {
                KdPrint(("Error writing time to Browser log file: %lX\n", IoStatus.Status));
                try_return(Status);
            }

        }

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        // Be in caller's process when referencing parameters.
        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
            ProcessAttached = FALSE;
        }

        //
        //  Format the parameters to the string.
        //

        vsprintf(OutputString, FormatString, ParmPtr);

        // Attach to FSP when using handle
        if (IoGetCurrentProcess() != BowserFspProcess) {
            KeStackAttachProcess(BowserFspProcess, &ApcState );

            ProcessAttached = TRUE;
        }

        if (!NT_SUCCESS(Status = ZwWriteFile(BrowserTraceLogHandle, NULL, NULL, NULL, &IoStatus, OutputString, strlen(OutputString), &EndOfFile, NULL))) {
            KdPrint(("Error writing string to Browser log file: %ld\n", Status));
            try_return(Status);
        }

        if (!NT_SUCCESS(IoStatus.Status)) {
            KdPrint(("Error writing string to Browser log file: %lX\n", IoStatus.Status));
            try_return(Status);
        }

        if (IoStatus.Information != strlen(OutputString)) {
            KdPrint(("Error writing string to Browser log file: %ld\n", IoStatus.Status));
            try_return(Status);
        }

        //
        //  Remember the last character output to the log.
        //

        LastCharacter = OutputString[strlen(OutputString)-1];

try_exit:NOTHING;
    } finally {
        if (ReleaseResource) {
            ExReleaseResource(&BrowserTraceLock);
        }
        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }
}

#endif

VOID
BowserInitializeTraceLog()
{

    PAGED_CODE();
    ExInitializeResource(&BrowserTraceLock);

}

NTSTATUS
BowserOpenTraceLogFile(
    IN PWCHAR TraceFile
    )
{
    UNICODE_STRING TraceFileName;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PAGED_CODE();

    RtlInitUnicodeString(&TraceFileName, TraceFile);

    InitializeObjectAttributes(&ObjA, &TraceFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = IoCreateFile(&BrowserTraceLogHandle,
                                        FILE_APPEND_DATA|SYNCHRONIZE,
                                        &ObjA,
                                        &IoStatusBlock,
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ,
                                        FILE_OPEN_IF,
                                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
                                        NULL,
                                        0,
                                        CreateFileTypeNone,
                                        NULL,
                                        IO_FORCE_ACCESS_CHECK |         // Ensure the user has access to the file
                                            IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                            IO_CHECK_CREATE_PARAMETERS  // But double check parameter consistancy
                                        );


    if (!NT_SUCCESS(Status)) {
        KdPrint(("Bowser: Error creating trace file %ws %lX\n", TraceFile, Status));

        return Status;
    }

    return Status;
}

VOID
BowserUninitializeTraceLog()
{
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ExDeleteResource(&BrowserTraceLock);

    if (BrowserTraceLogHandle != NULL) {
        if (IoGetCurrentProcess() != BowserFspProcess) {
            KeStackAttachProcess(BowserFspProcess, &ApcState );

            ProcessAttached = TRUE;
        }

        ZwClose(BrowserTraceLogHandle);

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    BrowserTraceLogHandle = NULL;
}

NTSTATUS
BowserDebugCall(
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS Status;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }


    try {
        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status=STATUS_BUFFER_TOO_SMALL);
        }

        if ( InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM ) {
            try_return(Status=STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Parameters.Debug.OpenLog && InputBuffer->Parameters.Debug.CloseLog) {
            try_return(Status=STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Parameters.Debug.OpenLog) {

            ENSURE_IN_INPUT_BUFFER_STR( InputBuffer->Parameters.Debug.TraceFileName);

            Status = BowserOpenTraceLogFile(InputBuffer->Parameters.Debug.TraceFileName);

        } else if (InputBuffer->Parameters.Debug.CloseLog) {
            Status = ZwClose(BrowserTraceLogHandle);

            if (NT_SUCCESS(Status)) {
                BrowserTraceLogHandle = NULL;
            }

        } else if (InputBuffer->Parameters.Debug.TruncateLog) {
            FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
            IO_STATUS_BLOCK IoStatus;

            if (BrowserTraceLogHandle == NULL) {
                try_return(Status=STATUS_INVALID_HANDLE);
            }

            EndOfFileInformation.EndOfFile.HighPart = 0;
            EndOfFileInformation.EndOfFile.LowPart = 0;

            Status = NtSetInformationFile(BrowserTraceLogHandle,
                                            &IoStatus,
                                            &EndOfFileInformation,
                                            sizeof(EndOfFileInformation),
                                            FileEndOfFileInformation);

        } else {
            BowserDebugLogLevel = InputBuffer->Parameters.Debug.DebugTraceBits;
            KdPrint(("Setting Browser Debug Trace Bits to %lx\n", BowserDebugLogLevel));
            Status = STATUS_SUCCESS;
        }

        try_return(Status);

    try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }

    }

    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

    !!! This module must be nonpageable.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local procedure forwards
//

VOID
BowserLogIllegalNameWorker(
    IN PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserWriteErrorLogEntry)
#pragma alloc_text(PAGE, BowserLogIllegalNameWorker )
#endif


ULONG
BowserSequenceNumber = 0;

//#pragma optimize("",off)

VOID
_cdecl
BowserWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{

    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    int TotalErrorLogEntryLength;
    ULONG SizeOfStringData = 0;
    va_list ParmPtr;                    // Pointer to stack parms.
    ULONG Length;

    PAGED_CODE();

    if (NumberOfInsertionStrings != 0) {
        ULONG i;

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1) {

            PWSTR String = va_arg(ParmPtr, PWSTR);

            Length = wcslen(String);
            while ( (Length > 0) && (String[Length-1] == L' ') ) {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength =
         min( ExtraInformationLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
              ERROR_LOG_MAXIMUM_SIZE );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)BowserDeviceObject,
        (UCHAR)TotalErrorLogEntryLength
        );

    if (ErrorLogEntry != NULL) {
        PCHAR DumpData;
        ULONG RemainingSpace = TotalErrorLogEntryLength -
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
        ULONG i;
        ULONG SizeOfRawData;

        if (RemainingSpace > SizeOfStringData) {
            SizeOfRawData = RemainingSpace - SizeOfStringData;
        } else {
            SizeOfStringData = RemainingSpace;

            SizeOfRawData = 0;
        }

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = UniqueErrorCode;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatusCode;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.LowPart = 0;
        ErrorLogEntry->DeviceOffset.HighPart = 0;
        ErrorLogEntry->SequenceNumber = (ULONG)BowserSequenceNumber ++;
        ErrorLogEntry->StringOffset = (USHORT)(ROUND_UP_COUNT(
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + SizeOfRawData,
                    ALIGN_WORD));

        DumpData = (PCHAR)ErrorLogEntry->DumpData;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if (( ARGUMENT_PRESENT( ExtraInformationBuffer )) &&
            ( SizeOfRawData != 0 )) {
            ULONG Length;

            Length = min(ExtraInformationLength, (USHORT)SizeOfRawData);
            RtlCopyMemory(
                DumpData,
                ExtraInformationBuffer,
                Length);
            ErrorLogEntry->DumpDataSize = (USHORT)Length;
        } else {
            ErrorLogEntry->DumpDataSize = 0;
        }

        ErrorLogEntry->NumberOfStrings = 0;

        if (NumberOfInsertionStrings != 0) {
            PWSTR StringOffset = (PWSTR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);
            PWSTR InsertionString;

            //
            // Set up ParmPtr to point to first of the caller's parameters.
            //

            va_start(ParmPtr, LAST_NAMED_ARGUMENT);

            for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1) {
                InsertionString = va_arg(ParmPtr, PWSTR);
                Length = wcslen(InsertionString);
                while ( (Length > 0) && (InsertionString[Length-1] == L' ') ) {
                    Length--;
                }

                if ( ((Length + 1) * sizeof(WCHAR)) > SizeOfStringData ) {
                    Length = (SizeOfStringData/sizeof(WCHAR))-1;
                }

                if ( Length > 0 ) {
                    RtlCopyMemory(StringOffset, InsertionString, Length*sizeof(WCHAR));
                    StringOffset += Length;
                    *StringOffset++ = L'\0';

                    SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                    ErrorLogEntry->NumberOfStrings += 1;
                }

            }

        }

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}

typedef struct _ILLEGAL_NAME_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    NTSTATUS EventStatus;
    NTSTATUS NtStatusCode;
    USHORT   BufferSize;
    UCHAR    Buffer[1];
} ILLEGAL_NAME_CONTEXT, *PILLEGAL_NAME_CONTEXT;

VOID
BowserLogIllegalName(
    IN NTSTATUS NtStatusCode,
    IN PVOID NameBuffer,
    IN USHORT NameBufferSize
    )
{
    KIRQL OldIrql;
    NTSTATUS ErrorStatus = STATUS_SUCCESS;

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    if (BowserIllegalNameCount > 0) {
        BowserIllegalNameCount -= 1;

        ErrorStatus = EVENT_BOWSER_NAME_CONVERSION_FAILED;

    } else if (!BowserIllegalNameThreshold) {
        BowserIllegalNameThreshold = TRUE;
        ErrorStatus = EVENT_BOWSER_NAME_CONVERSION_FAILED;
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

    if (ErrorStatus != STATUS_SUCCESS) {
        PILLEGAL_NAME_CONTEXT Context = NULL;

        Context = ALLOCATE_POOL(NonPagedPool, sizeof(ILLEGAL_NAME_CONTEXT)+NameBufferSize, POOL_ILLEGALDGRAM);

        if (Context != NULL) {
            Context->EventStatus = ErrorStatus;
            Context->NtStatusCode = NtStatusCode;
            Context->BufferSize = NameBufferSize;

            RtlCopyMemory( Context->Buffer, NameBuffer, NameBufferSize );

            ExInitializeWorkItem(&Context->WorkItem, BowserLogIllegalNameWorker, Context);

            BowserQueueDelayedWorkItem( &Context->WorkItem );
        }

    }
}


VOID
BowserLogIllegalNameWorker(
    IN PVOID Ctx
    )
{
    PILLEGAL_NAME_CONTEXT Context = Ctx;
    NTSTATUS EventContext = Context->EventStatus;

    PAGED_CODE();

    BowserWriteErrorLogEntry( Context->EventStatus,
                              Context->NtStatusCode,
                              Context->Buffer,
                              Context->BufferSize,
                              0 );

    FREE_POOL(Context);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\domain.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    Code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 23-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Module specific globals
//

// Serialized by BowserTransportDatabaseResource
LIST_ENTRY BowserServicedDomains = {0};

//
// Local procedure forwards.
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, BowserInitializeDomains)
#pragma alloc_text(PAGE, BowserCreateDomain)
#pragma alloc_text(PAGE, BowserSetDomainName)
#pragma alloc_text(PAGE, BowserFindDomain)
#pragma alloc_text(PAGE, BowserDereferenceDomain)
#endif


VOID
BowserInitializeDomains(
    VOID
    )

/*++

Routine Description:

    Initialize domain.c.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAGED_CODE();
    //
    // Initialize globals
    //

    InitializeListHead(&BowserServicedDomains);
}


PDOMAIN_INFO
BowserCreateDomain(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ComputerName
    )

/*++

Routine Description:

    Find the existing domain definition or create a new domain to browse on.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - emulated computer name for this domain.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found/created.  The found/created domain should be dereferenced
    using BowserDereferenceDomain.

--*/
{
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;
    ULONG OemComputerNameLength;

    PAGED_CODE();
    dlog(DPRT_DOMAIN, ("%wZ: BowserCreateDomain\n", DomainName));


    try {
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


        //
        // If the domain already exists, use it.
        //
        DomainInfo = BowserFindDomain( DomainName );

        if ( DomainInfo == NULL) {

            //
            // Allocate a structure describing the new domain.
            //

            DomainInfo = ALLOCATE_POOL(NonPagedPool, sizeof(DOMAIN_INFO), POOL_DOMAIN_INFO);

            if ( DomainInfo == NULL ) {
                try_return( Status = STATUS_NO_MEMORY );
            }
            RtlZeroMemory( DomainInfo, sizeof(DOMAIN_INFO) );


            //
            // Create an interim reference count for this domain.
            //
            // One for the caller.
            //
            // We don't increment the reference count for being in the global list since
            // the domain info structure is merely a performance enchancements that lives
            // only because it is referenced by a network.
            //

            DomainInfo->ReferenceCount = 1;

            //
            // Link the domain into the list of domains
            //
            //  The primary domain is at the front of the list.
            //

            InsertTailList(&BowserServicedDomains, &DomainInfo->Next);
        }

        //
        // Copy the DomainName into the structure
        //

        Status = BowserSetDomainName( DomainInfo, DomainName );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }


        //
        // Copy the OEM Computer name into the structure.
        //
        if ( ComputerName->Length > CNLEN*sizeof(WCHAR) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemComputerNameBuffer,
                                         sizeof(DomainInfo->DomOemComputerNameBuffer)-1,
                                         &OemComputerNameLength,
                                         ComputerName->Buffer,
                                         ComputerName->Length );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        DomainInfo->DomOemComputerNameBuffer[OemComputerNameLength] = '\0';
        DomainInfo->DomOemComputerName.Buffer = DomainInfo->DomOemComputerNameBuffer;
        DomainInfo->DomOemComputerName.Length = (USHORT)OemComputerNameLength;
        DomainInfo->DomOemComputerName.MaximumLength = (USHORT)(OemComputerNameLength + 1);

        //
        // Copy the upcased Unicode Computer name into the structure.
        //

        DomainInfo->DomUnicodeComputerName.Buffer = DomainInfo->DomUnicodeComputerNameBuffer;
        DomainInfo->DomUnicodeComputerName.MaximumLength = sizeof(DomainInfo->DomUnicodeComputerNameBuffer);

        Status = RtlOemStringToUnicodeString(&DomainInfo->DomUnicodeComputerName, &DomainInfo->DomOemComputerName, FALSE);

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        if ( !NT_SUCCESS(Status) && DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
            DomainInfo = NULL;
        }
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return DomainInfo;
}


NTSTATUS
BowserSetDomainName(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING DomainName
    )
/*++

Routine Description:

    Find the existing domain definition or create a new domain to browse on.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - emulated computer name for this domain.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    STRING OemDomainName;

    PAGED_CODE();

    try {
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        //
        // Copy the DomainName into the structure
        //

        Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemDomainName,
                                         sizeof(DomainInfo->DomOemDomainName),
                                         &DomainInfo->DomOemDomainNameLength,
                                         DomainName->Buffer,
                                         DomainName->Length );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        DomainInfo->DomOemDomainName[DomainInfo->DomOemDomainNameLength] = '\0';

        //
        // Build the domain name as a Netbios name
        //  Trailing blank filled and <00> 16th byte
        //

        RtlCopyMemory( DomainInfo->DomNetbiosDomainName,
                       DomainInfo->DomOemDomainName,
                       DomainInfo->DomOemDomainNameLength );
        RtlFillMemory( DomainInfo->DomNetbiosDomainName+DomainInfo->DomOemDomainNameLength,
                       NETBIOS_NAME_LEN-1-DomainInfo->DomOemDomainNameLength,
                       ' ');
        DomainInfo->DomNetbiosDomainName[NETBIOS_NAME_LEN-1] = PRIMARY_DOMAIN_SIGNATURE;


        //
        // Copy the upcased Unicode domain name into the structure.
        //

        OemDomainName.Buffer = DomainInfo->DomOemDomainName;
        OemDomainName.Length = (USHORT)DomainInfo->DomOemDomainNameLength;
        OemDomainName.MaximumLength = OemDomainName.Length + sizeof(WCHAR);

        DomainInfo->DomUnicodeDomainName.Buffer = DomainInfo->DomUnicodeDomainNameBuffer;
        DomainInfo->DomUnicodeDomainName.MaximumLength = sizeof(DomainInfo->DomUnicodeDomainNameBuffer);

        Status = RtlOemStringToUnicodeString(&DomainInfo->DomUnicodeDomainName, &OemDomainName, FALSE);

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}

PDOMAIN_INFO
BowserFindDomain(
    PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description:

    This routine will look up a domain given a name.

Arguments:

    DomainName - The name of the domain to look up.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using BowserDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;

    CHAR OemDomainName[DNLEN+1];
    DWORD OemDomainNameLength;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {


        // If no domain was specified
        //  try to return primary domain.
        //

        if ( DomainName == NULL || DomainName->Length == 0 ) {
            if ( !IsListEmpty( &BowserServicedDomains ) ) {
                DomainInfo = CONTAINING_RECORD(BowserServicedDomains.Flink, DOMAIN_INFO, Next);
            }


        //
        // If the domain name was specified,
        //  Find it in the list of domains.
        //
        } else {


            //
            // Convert the domain name to OEM for faster comparison
            //
            Status = RtlUpcaseUnicodeToOemN( OemDomainName,
                                             DNLEN,
                                             &OemDomainNameLength,
                                             DomainName->Buffer,
                                             DomainName->Length );


            if ( NT_SUCCESS(Status)) {

                //
                // The PrimaryDomainInfo structure is allocated with no
                //  domain name during bowser driver initialization.
                //  Detect that case here and always return that domain
                //  entry for all lookups.
                //
                if ( !IsListEmpty( &BowserServicedDomains ) ) {
                    DomainInfo = CONTAINING_RECORD(BowserServicedDomains.Flink, DOMAIN_INFO, Next);

                    if ( DomainInfo->DomOemDomainNameLength == 0 ) {
                        try_return( DomainInfo );
                    }

                }

                //
                // Loop trying to find this domain name.
                //

                for (DomainEntry = BowserServicedDomains.Flink ;
                     DomainEntry != &BowserServicedDomains;
                     DomainEntry = DomainEntry->Flink ) {

                    DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

                    if ( DomainInfo->DomOemDomainNameLength == OemDomainNameLength &&
                         RtlCompareMemory( DomainInfo->DomOemDomainName,
                                           OemDomainName,
                                           OemDomainNameLength ) == OemDomainNameLength ) {
                        try_return( DomainInfo );
                    }


                }

                DomainInfo = NULL;
            }

        }

try_exit:NOTHING;
    } finally {

        //
        // Reference the domain.
        //

        if ( DomainInfo != NULL ) {
            DomainInfo->ReferenceCount ++;
            dprintf(DPRT_REF, ("Reference domain %lx.  Count now %lx\n", DomainInfo, DomainInfo->ReferenceCount));
        }

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

    }

    return DomainInfo;
}


VOID
BowserDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Decrement the reference count on a domain.

    If the reference count goes to 0, remove the domain.

    On entry, the global BowserTransportDatabaseResource may not be locked

Arguments:

    DomainInfo - The domain to dereference

Return Value:

    None

--*/
{
    NTSTATUS Status;
    ULONG ReferenceCount;

    PAGED_CODE();

    //
    // Decrement the reference count
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    ReferenceCount = -- DomainInfo->ReferenceCount;
    if ( ReferenceCount == 0 ) {
        RemoveEntryList( &DomainInfo->Next );
    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    dprintf(DPRT_REF, ("Dereference domain %lx.  Count now %lx\n", DomainInfo, DomainInfo->ReferenceCount));

    if ( ReferenceCount != 0 ) {
        return;
    }


    //
    // Free the Domain Info structure.
    //
    dlog(DPRT_DOMAIN, ("%s: BowserDereferenceDomain: domain deleted.\n",
                          DomainInfo->DomOemDomainName ));
    FREE_POOL(DomainInfo );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\brsrvlst.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brsrvlst.c.

Abstract:

    This module implements the routines to manipulate WinBALL browser server
    lists.


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/

#define INCLUDE_SMB_TRANSACTION

#include "precomp.h"
#pragma hdrstop

#define SECONDS_PER_ELECTION (((((ELECTION_DELAY_MAX - ELECTION_DELAY_MIN) / 2)*ELECTION_COUNT) + 999) / 1000)

LARGE_INTEGER
BowserGetBrowserListTimeout = {0};

VOID
BowserGetBackupListWorker(
    IN PVOID Ctx
    );

NTSTATUS
BowserSendBackupListRequest(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain
    );

NTSTATUS
AddBackupToBackupList(
    IN PCHAR *BackupPointer,
    IN PCHAR BackupListStart,
    IN PANNOUNCE_ENTRY ServerEntry
    );

KSPIN_LOCK
BowserBackupListSpinLock = {0};

#define BOWSER_BACKUP_LIST_RESPONSE_SIZE    1024

NTSTATUS
BowserCheckForPrimaryBrowserServer(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

PVOID
BowserGetBackupServerListFromTransport(
    IN PTRANSPORT Transport
    );

VOID
BowserFreeTransportBackupList(
    IN PTRANSPORT Transport
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFreeBrowserServerList)
#pragma alloc_text(PAGE, BowserShuffleBrowserServerList)
#pragma alloc_text(INIT, BowserpInitializeGetBrowserServerList)
#pragma alloc_text(PAGE, BowserpUninitializeGetBrowserServerList)
#pragma alloc_text(PAGE, BowserSendBackupListRequest)
#pragma alloc_text(PAGE, BowserGetBackupListWorker)
#pragma alloc_text(PAGE, AddBackupToBackupList)
#pragma alloc_text(PAGE, BowserGetBrowserServerList)
#pragma alloc_text(PAGE, BowserCheckForPrimaryBrowserServer)
#pragma alloc_text(PAGE4BROW, BowserGetBackupServerListFromTransport)
#pragma alloc_text(PAGE4BROW, BowserFreeTransportBackupList)
#endif

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    )

/*++

Routine Description:

    This routine will free the list of browser servers associated with
    a transport.

Arguments:

    IN PTRANSPORT Transport - Supplies the transport whose buffer is to be freed

Return Value:

    None.

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < BrowserServerListLength ; i++) {
        FREE_POOL(BrowserServerList[i]);
    }

    FREE_POOL(BrowserServerList);

}

#define Swap(a,b)       \
    {                   \
        PWSTR t = a;    \
        a = b;          \
        b = t;          \
    }

NTSTATUS
BowserCheckForPrimaryBrowserServer(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PWSTR ServerName = Context;

    PAGED_CODE();

    //
    // Grab a lock on the BrowserServerList for this transport.
    //
    // Since this call is made with the BrowserServerList exclusively locked for one of the
    // transports, we can't wait for the lock (there would be an implicit violation of the
    // locking order).
    //
    // However, since this call is simply being used as an optimization, we'll simply skip
    //  the check when we have contention.
    //

    if (!ExAcquireResourceSharedLite(&Transport->BrowserServerListResource, FALSE)) {
        return STATUS_SUCCESS;
    }

    if (Transport->PagedTransport->BrowserServerListBuffer != NULL) {

        if (!_wcsicmp(ServerName, Transport->PagedTransport->BrowserServerListBuffer[0])) {
            ExReleaseResourceLite(&Transport->BrowserServerListResource);
            return STATUS_UNSUCCESSFUL;

        }
    }

    ExReleaseResourceLite(&Transport->BrowserServerListResource);
    return STATUS_SUCCESS;
}

VOID
BowserShuffleBrowserServerList(
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength,
    IN BOOLEAN IsPrimaryDomain,
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    This routine will shuffle the list of browser servers associated with
    a transport.

Arguments:


Return Value:

    None.

Note:
    We rely on the fact that the DLL will always pick the 0th entry in the
    list for the server to remote the API to.  We will first shuffle the
    list completely, then, if this is our primary domain, we will
    walk the list of domains and check to see if this entry is the 0th
    entry on any of the transports.  If it isn't, then we swap this entry
    with the 0th entry and return, since we've guaranteed that it's ok on
    all the other transports.


--*/
{
    ULONG NewIndex;
    ULONG i;
    PAGED_CODE();
    ASSERT ( BrowserServerListLength != 0 );

    //
    //  First thoroughly shuffle the list.
    //

    for (i = 0 ; i < BrowserServerListLength ; i++ ) {
        NewIndex = BowserRandom(BrowserServerListLength);

        Swap(BrowserServerList[i], BrowserServerList[NewIndex]);
    }

    //
    //  If we are querying our primary domain, we want to make sure that we
    //  don't have this server as the primary server for any other transports.
    //
    //
    //  The reason for this is that the NT product 1 redirector cannot connect
    //  to the same server on different transports, so it has to disconnect and
    //  reconnect to that server.  We can avoid this disconnect/reconnect
    //  overhead by making sure that the primary browse server (the 0th entry
    //  in the browse list) is different for all transports.
    //

    if (IsPrimaryDomain) {

        //
        //  Now walk through the server list and if the server at this index
        //  is the 0th entry for another transport, we want to swap it with the
        //  ith entry and keep on going.
        //

        for (i = 0 ; i < BrowserServerListLength ; i++ ) {
            if (NT_SUCCESS(BowserForEachTransportInDomain(DomainInfo, BowserCheckForPrimaryBrowserServer, BrowserServerList[i]))) {

                Swap(BrowserServerList[0], BrowserServerList[i]);

                //
                //  This server isn't the primary browser server for any other
                //  transports, we can return now, since we're done.
                //

                break;
            }
        }
    }
}

PVOID
BowserGetBackupServerListFromTransport(
    IN PTRANSPORT Transport
    )
{
    KIRQL OldIrql;
    PVOID BackupList;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    BackupList = Transport->BowserBackupList;

    Transport->BowserBackupList = NULL;

    RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);

    return BackupList;
}

VOID
BowserFreeTransportBackupList(
    IN PTRANSPORT Transport
    )
{
    KIRQL OldIrql;
    PVOID BackupList;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    if (Transport->BowserBackupList != NULL) {

        BackupList = Transport->BowserBackupList;

        Transport->BowserBackupList = NULL;

        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);

        FREE_POOL(BackupList);

    } else {
        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
    }

}

NTSTATUS
BowserGetBrowserServerList(
    IN PIRP Irp,
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PWSTR **BrowserServerList,
    OUT PULONG BrowserServerListLength
    )
/*++

Routine Description:

    This routine is the indication time processing needed to get a backup
    list response.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PUCHAR BackupPointer;
    ULONG i;
    PBACKUP_LIST_RESPONSE_1 BackupList = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

//    ASSERT (ExIsResourceAcquiredExclusiveLite(&Transport->BrowserServerListResource));

    //
    //  Initialize the browser server list to a known state.
    //

    *BrowserServerList = NULL;
    *BrowserServerListLength = 0;

    ASSERT (Transport->BowserBackupList == NULL);

    try {
        ULONG RetryCount = BOWSER_GETBROWSERLIST_RETRY_COUNT;

        //
        //  Allocate and save a buffer to hold the response server names.
        //

        Transport->BowserBackupList = ALLOCATE_POOL(NonPagedPool, Transport->DatagramSize, POOL_BACKUPLIST);

        if (Transport->BowserBackupList == NULL) {

            try_return(Status = STATUS_INSUFFICIENT_RESOURCES);

        }

        //
        //  This is a new request, so bump the token to indicate that this is
        //  a new GetBrowserServerList request.
        //

        ExInterlockedAddUlong(&Transport->BrowserServerListToken, 1, &BowserBackupListSpinLock);

        //
        //  We retry for 3 times, and we timeout the wait after 1 seconds.
        //  This means that in the worse case this routine takes 4 seconds
        //  to execute.
        //
        //

        while (RetryCount --) {
            ULONG Count = 0;

            //
            // Set the completion event to the not-signalled state.
            //

            KeResetEvent(&Transport->GetBackupListComplete);

            //
            //  Send the backup server list query.
            //

            Status = BowserSendBackupListRequest(Transport, DomainName);

            if (!NT_SUCCESS(Status)) {

                //
                //  If the send datagram failed, return a more browser like
                //  error.
                //

                try_return(Status = STATUS_NO_BROWSER_SERVERS_FOUND);
            }

            do {

                //
                //  Wait until either the server has responded to the request,
                //  or we give up.
                //

                Status = KeWaitForSingleObject(&Transport->GetBackupListComplete,
                                Executive,
                                KernelMode,
                                FALSE,
                                &BowserGetBrowserListTimeout);

                if (Status == STATUS_TIMEOUT) {

                    //
                    //  If this thread is terminating, then give up and return
                    //  a reasonable error to the caller.
                    //

                    if (PsIsThreadTerminating(Irp->Tail.Overlay.Thread)) {

                        Status = STATUS_CANCELLED;

                        break;
                    }
                }

            } while ( (Status == STATUS_TIMEOUT)

                                &&

                      (Count++ < BOWSER_GETBROWSERLIST_TIMEOUT) );

            //
            //  If the request succeeded, we can return
            //  right away.
            //

            if (Status != STATUS_TIMEOUT) {
                break;
            }

            //
            //  Force an election - We couldn't find a browser server.
            //

            dlog(DPRT_CLIENT,
                 ("%s: %ws: Unable to get browser server list - forcing election\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Uptime = BowserTimeUp();

            if (BowserLogElectionPackets) {
                BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED, STATUS_SUCCESS, NULL, 0, 1, PagedTransport->TransportName.Buffer);
            }

        }

        //
        //  If, after all this, we still timed out, return an error.
        //

        if (Status == STATUS_TIMEOUT) {

            //
            //  If it has been less than the maximum amount of time for an election plus some
            //  slop to allow the WfW machine to add the transport, don't
            //  send the election packet.
            //

            if ((PagedTransport->Role == None)

                    ||

                ((DomainName != NULL) &&
                 !RtlEqualUnicodeString(DomainName, &Transport->DomainInfo->DomUnicodeDomainName, TRUE)
                )

                ||

                ((BowserTimeUp() - PagedTransport->LastElectionSeen) > ELECTION_TIME )
               ) {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Starting election, domain %wZ.  Time Up: %lx, LastElectionSeen: %lx\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     (DomainName != NULL ? DomainName : &Transport->DomainInfo->DomUnicodeDomainName),
                     BowserTimeUp(),
                     Transport->PagedTransport->LastElectionSeen));


                BowserSendElection(DomainName,
                                   BrowserElection,
                                   Transport,
                                   FALSE);

            }

            try_return(Status = STATUS_NO_BROWSER_SERVERS_FOUND);
        }

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        //
        //  We now have a valid list of servers from the net.
        //
        //  Massage this list into a form that we can return.
        //

        BackupList = BowserGetBackupServerListFromTransport(Transport);

        *BrowserServerListLength = BackupList->BackupServerCount;

        *BrowserServerList = ALLOCATE_POOL(PagedPool | POOL_COLD_ALLOCATION, *BrowserServerListLength*sizeof(PWSTR), POOL_BROWSERSERVERLIST);

        if (*BrowserServerList == NULL) {
            try_return(Status = STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(*BrowserServerList, *BrowserServerListLength*sizeof(PWSTR));

        BackupPointer = BackupList->BackupServerList;

        for ( i = 0 ; i < (ULONG)BackupList->BackupServerCount ; i ++ ) {
            UNICODE_STRING UServerName;
            OEM_STRING AServerName;

            RtlInitAnsiString(&AServerName, BackupPointer);

            Status = RtlOemStringToUnicodeString(&UServerName, &AServerName, TRUE);

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            (*BrowserServerList)[i] = ALLOCATE_POOL(PagedPool | POOL_COLD_ALLOCATION, UServerName.Length+(sizeof(WCHAR)*3), POOL_BROWSERSERVER);

            if ((*BrowserServerList)[i] == NULL) {
                RtlFreeUnicodeString(&UServerName);
                try_return(Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            //
            //  Put "\\" at the start of the server name.
            //

            RtlCopyMemory((*BrowserServerList)[i], L"\\\\", 4);

            dlog(DPRT_CLIENT,
                 ("Packing server name %ws to %lx\n",
                 UServerName.Buffer, (*BrowserServerList)[i]));

            RtlCopyMemory(&((*BrowserServerList)[i])[2], UServerName.Buffer, UServerName.MaximumLength);

            //
            //  Bump the pointer to the backup server name.
            //

            BackupPointer += AServerName.Length + sizeof(CHAR);

            RtlFreeUnicodeString(&UServerName);

        }

        //
        //  Now shuffle the browser server list we got back from the server
        //  to ensure some degree of randomness in the choice.
        //

        BowserShuffleBrowserServerList(
            *BrowserServerList,
            *BrowserServerListLength,
            (BOOLEAN)(DomainName == NULL ||
                RtlEqualUnicodeString(&Transport->DomainInfo->DomUnicodeDomainName, DomainName, TRUE)),
            Transport->DomainInfo );

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if (!NT_SUCCESS(Status)) {

            if (*BrowserServerList != NULL) {

                for ( i = 0 ; i < *BrowserServerListLength ; i ++ ) {

                    if ((*BrowserServerList)[i] != NULL) {

                        FREE_POOL((*BrowserServerList)[i]);

                    }
                }

                FREE_POOL(*BrowserServerList);

                *BrowserServerList = NULL;

            }

            *BrowserServerListLength = 0;

            BowserFreeTransportBackupList(Transport);

        }

        if (BackupList != NULL) {
            FREE_POOL(BackupList);
        }

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }

    return Status;
}



DATAGRAM_HANDLER(
    BowserGetBackupListResponse
    )
/*++

Routine Description:

    This routine is the indication time processing needed to get a backup
    list response.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    PTRANSPORT              Transport   = TransportName->Transport;
    PBACKUP_LIST_RESPONSE_1 BackupList  = Buffer;
    KIRQL                   OldIrql;
    ULONG                   StringCount = 0;
    PUCHAR                  Walker      = BackupList->BackupServerList;
    PUCHAR                  BufferEnd   = ((PUCHAR)Buffer) + BytesAvailable;

    if (Transport->BowserBackupList == NULL) {
        dprintf(DPRT_CLIENT,("BOWSER: Received GetBackupListResponse while not expecting one\n"));
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ASSERT ( BytesAvailable <= Transport->DatagramSize );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    //
    //  This response is for an old request - ignore it.
    //

    if (BackupList->Token != Transport->BrowserServerListToken) {
        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    //  Verify that the incoming buffer is a series of valid strings, and
    //     that the number indicated are actually present in the buffer.
    //

    while (StringCount < BackupList->BackupServerCount &&
           Walker < BufferEnd) {
        if (*Walker == '\0') {
            StringCount++;
        }
        Walker++;
    }

    if (Walker == BufferEnd) {
        if (StringCount < BackupList->BackupServerCount) {
            RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
            return(STATUS_REQUEST_NOT_ACCEPTED);
        }
    }

    //
    //  Bump the token again to invalidate any incoming responses - they are
    //  no longer valid.
    //

    Transport->BrowserServerListToken += 1;

    if (Transport->BowserBackupList != NULL) {

        //
        //  Copy the received buffer.
        //

        TdiCopyLookaheadData(Transport->BowserBackupList, BackupList, BytesAvailable, ReceiveFlags);

        KeSetEvent(&Transport->GetBackupListComplete, IO_NETWORK_INCREMENT, FALSE);

    }

    RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);


    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(BytesTaken);
}


NTSTATUS
BowserSendBackupListRequest(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain
    )
/*++

Routine Description:

    This routine sends a getbackup list request to the master browser server
    for a specified domain.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    NTSTATUS Status, Status2;
    BACKUP_LIST_REQUEST Request;

    PAGED_CODE();

    Request.Type = GetBackupListReq;

    //
    //  Send this request.
    //

    Request.BackupListRequest.Token = Transport->BrowserServerListToken;

    //
    //  WinBALL only asks for 4 of these, so that's what I'll ask for.
    //

    Request.BackupListRequest.RequestedCount = 4;

    // ask for Master Browser
    Status = BowserSendSecondClassMailslot(Transport,
                            (Domain == NULL ?
                                    &Transport->DomainInfo->DomUnicodeDomainName :
                                    Domain),
                            MasterBrowser,
                            &Request, sizeof(Request), TRUE,
                            MAILSLOT_BROWSER_NAME,
                            NULL);



#ifdef ENABLE_PSEUDO_BROWSER
    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX) &&
        BowserData.PseudoServerLevel != BROWSER_SEMI_PSEUDO_NO_DMB) {
#else
        if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
#endif
        // search for PDC
        // In some configurations, it is valid not to have a PDC, thus,
        // ignore status code (do not propagate up).
        // Do not talk to the DMB (PDC name) directly if we're semi-pseudo
        Status2 = BowserSendSecondClassMailslot(Transport,
                            (Domain == NULL ?
                                    &Transport->DomainInfo->DomUnicodeDomainName :
                                    Domain),
                            PrimaryDomainBrowser,
                            &Request, sizeof(Request), TRUE,
                            MAILSLOT_BROWSER_NAME,
                            NULL);
        // if either succeeded, we'll return success.
        Status = NT_SUCCESS(Status2) ? Status2: Status;
    }

    return (Status);
}


DATAGRAM_HANDLER(
    BowserGetBackupListRequest
    )
{
    NTSTATUS status;
    //
    //  We need to have at least enough bytes of data to read in
    //  a BACKUP_LIST_REQUEST_1 structure.
    //

    if (BytesAvailable < sizeof(BACKUP_LIST_REQUEST_1)) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    BowserStatistics.NumberOfGetBrowserServerListRequests += 1;

    status = BowserPostDatagramToWorkerThread(
            TransportName,
            Buffer,
            BytesAvailable,
            BytesTaken,
            SourceAddress,
            SourceAddressLength,
            SourceName,
            SourceNameLength,
            BowserGetBackupListWorker,
            NonPagedPool,
            DelayedWorkQueue,
            ReceiveFlags,
            TRUE);                  // Response will be sent.

    if (!NT_SUCCESS(status)) {
        BowserNumberOfMissedGetBrowserServerListRequests += 1;

        BowserStatistics.NumberOfMissedGetBrowserServerListRequests += 1;
        return status;
    }

    return status;
}

VOID
BowserGetBackupListWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PBACKUP_LIST_REQUEST_1 BackupListRequest = Context->Buffer;
    PIRP Irp = NULL;
    PTRANSPORT Transport = Context->TransportName->Transport;
    STRING ClientAddress;
    NTSTATUS Status;
    PBACKUP_LIST_RESPONSE BackupListResponse = NULL;
    PCHAR ClientName = Context->ClientName;
    UNICODE_STRING UClientName;
    OEM_STRING AClientName;
    WCHAR ClientNameBuffer[LM20_CNLEN+1];

    PAGED_CODE();

    ClientAddress.Buffer = Context->TdiClientAddress;
    ClientAddress.Length = ClientAddress.MaximumLength =
        (USHORT)Context->ClientAddressLength;

    UClientName.Buffer = ClientNameBuffer;
    UClientName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);

    RtlInitAnsiString(&AClientName, Context->ClientName);

    Status = RtlOemStringToUnicodeString(&UClientName, &AClientName, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, AClientName.Buffer, AClientName.Length );

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

        return;
    }

    //
    //  Lock the transport to allow us access to the list.  This prevents
    //  any role changes while we're responding to the caller.
    //

    LOCK_TRANSPORT_SHARED(Transport);

    //
    //  Do nothing if we're not a master browser.  This can happen if
    //  we're running on the PDC, and aren't the master for some reason (for
    //  instance, if the master browser is running a newer version of the
    //  browser).
    //

    if ( Transport->PagedTransport->Role != Master ) {
        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

        return;
    }

    LOCK_ANNOUNCE_DATABASE_SHARED(Transport);

    try {
        PUCHAR BackupPointer;
        PLIST_ENTRY BackupEntry;
        PLIST_ENTRY TraverseStart;
        USHORT Count;
        UCHAR NumberOfBackupServers = 0;
        ULONG EntriesInList;
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        BackupListResponse = ALLOCATE_POOL(PagedPool, BOWSER_BACKUP_LIST_RESPONSE_SIZE, POOL_BACKUPLIST_RESP);

        //
        //  If we can't allocate the buffer, just bail out.
        //

        if (BackupListResponse == NULL) {
            try_return(NOTHING);
        }

        BackupListResponse->Type = GetBackupListResp;

        BackupListResponse->BackupListResponse.BackupServerCount = 0;

        //
        //  Set the token to the clients requested value
        //

        SmbPutUlong(&BackupListResponse->BackupListResponse.Token, BackupListRequest->Token);

        BackupPointer = BackupListResponse->BackupListResponse.BackupServerList;

        //
        //  Since we're a backup browser, make sure that at least our name is
        //  in the list.
        //

        {
            RtlCopyMemory( BackupPointer,
                           Transport->DomainInfo->DomOemComputerName.Buffer,
                           Transport->DomainInfo->DomOemComputerName.MaximumLength );

            //
            //  Bump pointer by size of string.
            //

            BackupPointer += Transport->DomainInfo->DomOemComputerName.MaximumLength;

        }


        NumberOfBackupServers += 1;



#ifdef ENABLE_PSEUDO_BROWSER
        //
        // Pseudo Server should not advertise any backup server but itself.
        //

        if (BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#endif

            //
            //  Walk the list of servers forward by the Last DC returned # of elements
            //

            Count = BackupListRequest->RequestedCount;

            BackupEntry = PagedTransport->BackupBrowserList.Flink;

            EntriesInList = PagedTransport->NumberOfBackupServerListEntries;

            // KdPrint(("There are %ld entries in the list\n", EntriesInList));

            TraverseStart = BackupEntry;

            //
            //  Try to find DC's and BDC's to satisfy the users request
            //  first.  They presumably are more appropriate to be returned
            //  anyway.
            //

            dlog(DPRT_MASTER, ("Advanced servers: "));

            while (Count && EntriesInList -- ) {
                PANNOUNCE_ENTRY ServerEntry = CONTAINING_RECORD(BackupEntry, ANNOUNCE_ENTRY, BackupLink);

                // KdPrint(("Check entry %ws.  Flags: %lx\n", ServerEntry->ServerName, ServerEntry->ServerType));

                //
                //  If this machine was a backup, and is now a master, it is
                //  possible we might return ourselves in the list of backups.
                //
                //  While this is not fatal, it can possibly cause problems,
                //  so remove ourselves from the list and skip to the next server
                //  in the list.
                //
                //
                //  Since WfW machines don't support "double hops", we can't
                //  return them to clients as legitimate backup servers.
                //

                if (
                    (ServerEntry->ServerType & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL))

                        &&

                    (ServerEntry->ServerBrowserVersion >= (BROWSER_VERSION_MAJOR<<8)+BROWSER_VERSION_MINOR)

                        &&

                    (!(PagedTransport->Wannish)

                            ||

                     (ServerEntry->ServerType & SV_TYPE_NT))

                        &&

                    _wcsicmp(ServerEntry->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)
                   ) {

                    Status = AddBackupToBackupList(&BackupPointer, (PCHAR)BackupListResponse, ServerEntry);

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    //
                    //  And indicate we've packed another server entry.
                    //

                    NumberOfBackupServers += 1;

                    //
                    //  We've packed another entry in the buffer, so decrement the
                    //  count.
                    //

                    Count -= 1;

                }

                //
                //  Skip to the next entry in the list.
                //

                BackupEntry = BackupEntry->Flink;

                if (BackupEntry == &PagedTransport->BackupBrowserList) {
                    BackupEntry = BackupEntry->Flink;
                }

                if (BackupEntry == TraverseStart) {
                    break;
                }

            }

            dlog(DPRT_MASTER, ("\n"));

            //
            //  If we've not satisfied the users request with our DC's, then
            //  we want to fill the remainder of the list with ordinary backup
            //  browsers.
            //

            BackupEntry = PagedTransport->BackupBrowserList.Flink;

            EntriesInList = PagedTransport->NumberOfBackupServerListEntries;

            // KdPrint(("There are %ld entries in the list\n", EntriesInList));

            dlog(DPRT_MASTER, ("Other servers: "));

            TraverseStart = BackupEntry;

            while ( Count && EntriesInList--) {
                PANNOUNCE_ENTRY ServerEntry = CONTAINING_RECORD(BackupEntry, ANNOUNCE_ENTRY, BackupLink);

                // KdPrint(("Check entry %ws.  Flags: %lx\n", ServerEntry->ServerName, ServerEntry->ServerType));

                //
                //  If this machine was a backup, and is now a master, it is
                //  possible we might return ourselves in the list of backups.
                //
                //  While this is not fatal, it can possibly cause problems,
                //  so remove ourselves from the list and skip to the next server
                //  in the list.
                //
                //
                //  Since WfW machines don't support "double hops", we can't
                //  return them to clients as legitimate backup servers.
                //
                //
                //  Please note that we DO NOT include BDC's in this scan, since
                //  we already included them in the previous pass.
                //

                if (
                    (!(PagedTransport->Wannish)

                            ||

                     (ServerEntry->ServerType & SV_TYPE_NT))

                        &&

                    (ServerEntry->ServerBrowserVersion >= (BROWSER_VERSION_MAJOR<<8)+BROWSER_VERSION_MINOR)

                        &&

                    !(ServerEntry->ServerType & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL))

                        &&

                    _wcsicmp(ServerEntry->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)
                   ) {

                    Status = AddBackupToBackupList(&BackupPointer, (PCHAR)BackupListResponse, ServerEntry);

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    //
                    //  And indicate we've packed another server entry.
                    //

                    NumberOfBackupServers += 1;

                    //
                    //  We've packed another entry in the buffer, so decrement the
                    //  count.
                    //

                    Count -= 1;

                }

                //
                //  Skip to the next entry in the list.
                //

                BackupEntry = BackupEntry->Flink;

                if (BackupEntry == &PagedTransport->BackupBrowserList) {
                    BackupEntry = BackupEntry->Flink;
                }

                if (BackupEntry == TraverseStart) {
                    break;
                }

            }

            dlog(DPRT_MASTER, ("\n"));


#ifdef ENABLE_PSEUDO_BROWSER
        }
#endif

        BackupListResponse->BackupListResponse.BackupServerCount = NumberOfBackupServers;

//        dlog(DPRT_MASTER, ("Responding to server %wZ on %ws with %lx (length %lx)\n", &UClientName,
//                        PagedTransport->TransportName.Buffer,
//                        BackupListResponse,
//                        BackupPointer-(PUCHAR)BackupListResponse));

        //
        //  Now send the response to the poor guy who requested it (finally)
        //


        Status = BowserSendSecondClassMailslot(Transport,
                            &UClientName,       // Name receiving data
                            ComputerName,       // Name type of destination
                            BackupListResponse, // Datagram Buffer
                            (ULONG)(BackupPointer-(PUCHAR)BackupListResponse), // Length.
                            TRUE,
                            MAILSLOT_BROWSER_NAME,
                            &ClientAddress);




try_exit:NOTHING;
    } finally {
        if (BackupListResponse != NULL) {
            FREE_POOL(BackupListResponse);
        }

        UNLOCK_ANNOUNCE_DATABASE(Transport);

        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);
    }

    return;
}


NTSTATUS
AddBackupToBackupList(
    IN PCHAR *BackupPointer,
    IN PCHAR BackupListStart,
    IN PANNOUNCE_ENTRY ServerEntry
    )
{
    OEM_STRING OemBackupPointer;
    UNICODE_STRING UnicodeBackupPointer;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  If we can't fit this entry in the list, then we've packed all we
    //  can.
    //

    if (((*BackupPointer)+wcslen(ServerEntry->ServerName)+1)-BackupListStart >= BOWSER_BACKUP_LIST_RESPONSE_SIZE ) {
        return (STATUS_BUFFER_OVERFLOW);
    }

    dlog(DPRT_MASTER, ("%ws ", ServerEntry->ServerName));

//    KdPrint(("Add server %ws to list\n", ServerEntry->ServerName));

    OemBackupPointer.Buffer = (*BackupPointer);
    OemBackupPointer.MaximumLength = (USHORT)((ULONG_PTR)(BackupListStart + BOWSER_BACKUP_LIST_RESPONSE_SIZE) -
            (ULONG_PTR)(*BackupPointer));

    RtlInitUnicodeString(&UnicodeBackupPointer, ServerEntry->ServerName);

    Status = RtlUnicodeStringToOemString(&OemBackupPointer, &UnicodeBackupPointer, FALSE);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    (*BackupPointer) += OemBackupPointer.Length + 1;

    return STATUS_SUCCESS;
}




VOID
BowserpInitializeGetBrowserServerList(
    VOID
    )

{
    //
    //  We want to delay for the average amount of time it takes to force an
    //  election.
    //

    BowserGetBrowserListTimeout.QuadPart = Int32x32To64(  1000, -10000 );

    KeInitializeSpinLock(&BowserBackupListSpinLock);


}

VOID
BowserpUninitializeGetBrowserServerList(
    VOID
    )

{
    PAGED_CODE();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\brsrvlst.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brsrvlst.c.

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BRSRVLST_
#define _BRSRVLST_

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    );

VOID
BowserShuffleBrowserServerList(
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength,
    IN BOOLEAN IsPrimaryDomain,
    IN PDOMAIN_INFO DomainInfo
    );

NTSTATUS
BowserGetBrowserServerList(
    IN PIRP Irp,
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PWSTR **BrowserServerList,
    OUT PULONG BrowserServerListLength
    );

DATAGRAM_HANDLER(
    BowserGetBackupListResponse
    );
DATAGRAM_HANDLER(
    BowserGetBackupListRequest
    );

VOID
BowserpInitializeGetBrowserServerList(
    VOID
    );

VOID
BowserpUninitializeGetBrowserServerList(
    VOID
    );


#endif // _BRSRVLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\domain.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    domain.h

Abstract:

    Header file for code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 23-Jan-1995

Revision History:

--*/

//
// Description of a single domain.
//

typedef struct _DOMAIN_INFO {

    //
    // Link to next domain in 'BowserServicedDomains'
    //  (Serialized by BowserTransportDatabaseResource)
    //

    LIST_ENTRY Next;

    //
    // Name of the domain being handled
    //

    CHAR DomOemDomainName[DNLEN+1];
    DWORD DomOemDomainNameLength;
    CHAR DomNetbiosDomainName[NETBIOS_NAME_LEN+1];
    WCHAR DomUnicodeDomainNameBuffer[DNLEN+1];
    UNICODE_STRING DomUnicodeDomainName;

    //
    // Computer name associated with this domain.
    //

    WCHAR DomUnicodeComputerNameBuffer[CNLEN+1];
    UNICODE_STRING DomUnicodeComputerName;
    CHAR DomOemComputerNameBuffer[CNLEN+1];
    OEM_STRING DomOemComputerName;

    //
    // Number of outstanding pointer to the domain structure.
    //  (Serialized by BowserTransportDatabaseResource)
    //

    DWORD ReferenceCount;

} DOMAIN_INFO, *PDOMAIN_INFO;

//
// List of all domains.  The primary domain is at the front of the list.
//
extern LIST_ENTRY BowserServicedDomains;


//
// domain.c procedure forwards.
//

VOID
BowserInitializeDomains(
    VOID
    );

PDOMAIN_INFO
BowserCreateDomain(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ComputerName
    );

PDOMAIN_INFO
BowserFindDomain(
    PUNICODE_STRING DomainName
    );

VOID
BowserDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fsctl.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop
#include <stddef.h> // offsetof





PEPROCESS
RxGetRDBSSProcess();

NTSTATUS
BowserCommonDeviceIoControlFile (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
StartBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
BowserEnumTransports (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
EnumNames (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
BowserBindToTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
UnbindFromTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
AddBowserName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
DeleteName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
EnumServers (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );


NTSTATUS
WaitForBrowserRoleChange (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
WaitForNewMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
HandleBecomeBackup (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
BecomeMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
WaitForMasterAnnounce (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
WriteMailslot (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
UpdateStatus (
    IN PIRP Irp,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
GetBrowserServerList(
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN OUT PULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
QueryStatistics(
    IN PIRP Irp,
    OUT PBOWSER_STATISTICS OutputBuffer,
    IN OUT PULONG OutputBufferLength
    );

NTSTATUS
ResetStatistics(
    VOID
    );

NTSTATUS
BowserIpAddressChanged(
    IN PLMDR_REQUEST_PACKET InputBuffer
    );

NTSTATUS
BowserIpAddressChangedWorker(
    PTRANSPORT Transport,
    PVOID Context
    );

NTSTATUS
EnableDisableTransport (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
BowserRenameDomain (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

PLMDR_REQUEST_PACKET
RequestPacket32to64 (
    IN      PLMDR_REQUEST_PACKET32  RequestPacket32,
    IN  OUT PLMDR_REQUEST_PACKET    RequestPacket);




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserCommonDeviceIoControlFile)
#pragma alloc_text(PAGE, BowserFspDeviceIoControlFile)
#pragma alloc_text(PAGE, BowserFsdDeviceIoControlFile)
#pragma alloc_text(PAGE, StartBowser)
#pragma alloc_text(PAGE, BowserEnumTransports)
#pragma alloc_text(PAGE, EnumNames)
#pragma alloc_text(PAGE, BowserBindToTransport)
#pragma alloc_text(PAGE, UnbindFromTransport)
#pragma alloc_text(PAGE, AddBowserName)
#pragma alloc_text(PAGE, StopBowser)
#pragma alloc_text(PAGE, DeleteName)
#pragma alloc_text(PAGE, EnumServers)
#pragma alloc_text(PAGE, WaitForBrowserRoleChange)
#pragma alloc_text(PAGE, HandleBecomeBackup)
#pragma alloc_text(PAGE, BecomeMaster)
#pragma alloc_text(PAGE, WaitForMasterAnnounce)
#pragma alloc_text(PAGE, WriteMailslot)
#pragma alloc_text(PAGE, UpdateStatus)
#pragma alloc_text(PAGE, BowserStopProcessingAnnouncements)
#pragma alloc_text(PAGE, GetBrowserServerList)
#pragma alloc_text(PAGE, WaitForNewMaster)
#pragma alloc_text(PAGE, BowserIpAddressChanged)
#pragma alloc_text(PAGE, BowserIpAddressChangedWorker)
#pragma alloc_text(PAGE, EnableDisableTransport)
#pragma alloc_text(PAGE, BowserRenameDomain )
#pragma alloc_text(PAGE4BROW, QueryStatistics)
#pragma alloc_text(PAGE4BROW, ResetStatistics)
#pragma alloc_text(PAGE, RequestPacket32to64)
#if DBG
#pragma alloc_text(PAGE, BowserDebugCall)
#endif
#endif


NTSTATUS
BowserFspDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = BowserCommonDeviceIoControlFile(TRUE,
                                        FALSE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

#ifndef PRODUCT1
    FsRtlEnterFileSystem();
#endif

    //
    // Call the routine shared by the FSD/FSP.
    //
    // Even though this is the FSD, indicate we're in the FSP if our caller
    //  is in the system process.  This allows us to avoid posting this
    //  request to a worker thread if we're already in one.
    //
    Status = BowserCommonDeviceIoControlFile(
                 IoIsOperationSynchronous(Irp),
                 (BOOLEAN)(IoGetCurrentProcess() != BowserFspProcess),
                 DeviceObject,
                 Irp);

#ifndef PRODUCT1
    FsRtlExitFileSystem();
#endif

    return Status;


}

NTSTATUS
BowserCommonDeviceIoControlFile (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status                 = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp        = IoGetCurrentIrpStackLocation(Irp);
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer              = NULL;
    ULONG OutputBufferLength;
    ULONG IoControlCode             = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    ULONG MinorFunction             = IrpSp->MinorFunction;
    LPBYTE OriginalInputBuffer      = NULL;
    BOOLEAN CopyEnumResultsToCaller = FALSE;
    BOOLEAN fThunk32bit;
    LMDR_REQUEST_PACKET             ReqPacketBuffer;

// Local Definitions

#define BOWSECURITYCHECK( _irp, _irpsp, _status)                                                \
    if (_irp->RequestorMode != KernelMode               &&                                      \
        !IoIsSystemThread ( _irp->Tail.Overlay.Thread)  &&                                      \
        !BowserSecurityCheck(_irp, _irpsp, &_status)){                                          \
                try_return (_status = (NT_SUCCESS(_status) ? STATUS_ACCESS_DENIED : _status) ); \
    }

    PAGED_CODE();

    try {

        //
        //  Before we call the worker functions, prep the parameters to those
        //  functions.
        //

        //
        // Is caller in 32bit process?
        // we'll process irp field size calculations depending on this knowledge.
        //

#ifdef _WIN64
        fThunk32bit = IoIs32bitProcess(Irp);

        //
        // Filter out all IOCTLs we do not support:
        // Since the browser is getting phased out, we would support only those
        // IOCTLs used only for NetServerEnum.
        //
        if ( fThunk32bit &&
             IoControlCode != IOCTL_LMDR_ENUMERATE_TRANSPORTS  &&
             IoControlCode != IOCTL_LMDR_GET_BROWSER_SERVER_LIST ) {
            // Only these ioctl's are supported in th